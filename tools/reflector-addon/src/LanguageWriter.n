/*
 * Copyright (c) 2003-2007 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Internal;
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;

using Reflector.CodeModel;
using Reflector.CodeModel.Memory;
using Reflector.NemerleLanguage.CodeModel;

namespace Reflector.NemerleLanguage
{
  internal class LanguageWriter : LanguageWritterBase
  {
    _configuration : LanguageWriterConfiguration;

    public this
      ( formatter     : IFormatter
      , configuration : ILanguageWriterConfiguration
      )
    {
      when (configuration == null)
        throw ArgumentNullException("configuration");

      base(formatter);
      _configuration = LanguageWriterConfiguration(configuration);

      _voidTypeCache = Hashtable();
    }

    #region Module

    public override WriteAssembly(value : IAssembly) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      Write("// Assembly ");
      WriteDeclaration(value.Name);
      when (value.Version != null)
        Write($", Version $(value.Version)");

      WriteLine();
      WriteCustomAttributeList(value);

      WriteProperty("Location", value.Location);
      WriteProperty("Name",     value.ToString());
      WriteProperty("Type",
      match(value.Type)
      {
      | AssemblyType.Console     => "Console Application"
      | AssemblyType.Application => "Windows Application"
      | AssemblyType.Library     => "Class Library"
      | _                        => "<Unknown>"
      }
      );
    }

    public override WriteAssemblyReference(value : IAssemblyReference) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      Write("// Assembly Reference ");
      WriteDeclaration(value.Name);
      WriteLine();
      WriteProperty("Version", value.Version.ToString());
      WriteProperty("Name", value.ToString());
    }

    public override WriteModule(value : IModule) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      Write("// Module ");
      WriteDeclaration(value.Name);
      WriteLine();

      WriteCustomAttributeList(value);

      WriteProperty("Version", value.Version.ToString());
      WriteProperty("Location", value.Location);
      def loc = Environment.ExpandEnvironmentVariables(value.Location);
      when (File.Exists(loc))
        WriteProperty("Size", $"$(FileInfo(loc).Length) Bytes");
    }

    public override WriteModuleReference(value : IModuleReference) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      Write("// Module reference ");
      WriteDeclaration(value.Name);
      WriteLine();
    }

    public override WriteNamespace(value : INamespace) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      def global = string.IsNullOrEmpty(value.Name);
      unless (global)
      {
        WriteKeyword("namespace");
        Write(" ");
        WriteDeclaration(value.Name);
        WriteLine();
      }

      when (_configuration.ShowNamespaceBody)
      {
        unless (global)
          BeginBlock();

        when (_configuration.ShowNamespaceImports)
        {
          def visitor = UsingNamespaceVisitor();
          visitor.VisitNamespace(value);
          
          mutable foundAny = false;
          visitor.Namespaces.Sort(string.Compare).Iter(ns =>
            unless (string.IsNullOrEmpty(ns))
            {
              WriteKeyword("using");
              Write(" ");
              Write(ns);
              Write(";");
              WriteLine();
              foundAny = true;
            });

          when (foundAny)
            WriteLine();
        }

        def visibleTypes = value.Types.ToList()
          .Filter(e : ITypeDeclaration => _configuration.IsVisible(e));

        visibleTypes.Sort((x, y) => string.Compare(x.Name, y.Name)).Iter(ty =>
          {
            WriteTypeDeclaration(ty);
            WriteLine();

            // An extra line for readability
            //
            WriteLine();
          });

        unless (global)
          EndBlock();

      }
    }

    public override WriteResource(value : IResource) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      Write("// ");
      WriteKeyword(
        match (value.Visibility)
        {
        | ResourceVisibility.Public  => "public";
        | ResourceVisibility.Private => "private";
        });

      Write(" ");
      WriteKeyword("resource");
      Write(" ");
      WriteDeclaration(value.Name);
      WriteLine();

      match (value)
      {
      | embedded is IEmbeddedResource =>
          WriteProperty("Size", $"$(embedded.Value.Length) Bytes");
      | file     is IFileResource     =>
        WriteProperty("Location", file.Location);
        def loc = Environment.ExpandEnvironmentVariables(file.Location);
        when (File.Exists(loc))
          WriteProperty("Size", $"$(FileInfo(loc).Length) Bytes");
      | _                             => throw NotImplementedException();
      }
    }

    #endregion

    #region WriteStatement

    public override WriteStatement(value : IStatement) : void
    {
    | null                                => throw ArgumentNullException("value");
    | s is IBlockStatement                => WriteBlockStatement           (s);
    | s is IExpressionStatement           => WriteExpressionStatement      (s);
    | s is IGotoStatement                 => WriteGotoStatement            (s);
    | s is ILabeledStatement              => WriteLabeledStatement         (s);
    | s is IConditionStatement            => WriteConditionStatement       (s);
    | s is IMethodReturnStatement         => WriteMethodReturnStatement    (s);
    | s is IForStatement                  => WriteForStatement             (s);
    | s is IForEachStatement              => WriteForEachStatement         (s);
    | s is IUsingStatement                => WriteUsingStatement           (s);
    | s is IFixedStatement                => WriteFixedStatement           (s);
    | s is IWhileStatement                => WriteWhileStatement           (s);
    | s is IDoStatement                   => WriteDoStatement              (s);
    | s is ITryCatchFinallyStatement      => WriteTryCatchFinallyStatement (s);
    | s is IThrowExceptionStatement       => WriteThrowExceptionStatement  (s);
    | s is IAttachEventStatement          => WriteAttachEventStatement     (s);
    | s is IRemoveEventStatement          => WriteRemoveEventStatement     (s);
    | s is ISwitchStatement               => WriteSwitchStatement          (s);
    | s is IBreakStatement                => WriteBreakStatement           (s);
    | s is IContinueStatement             => WriteContinueStatement        (s);
    | s is ICommentStatement              => WriteCommentStatement         (s);
    | s is ILockStatement                 => WriteLockStatement            (s);
    | s is IMemoryCopyStatement           => WriteMemoryCopyStatement      (s);
    | s is IMemoryInitializeStatement     => WriteMemoryInitializeStatement(s);
    | s                                   => throw NotSupportedException($"Invalid statement type '$(s.GetType().Name)'.");
    }

    private WriteBlockStatement(value : IBlockStatement) : void
    {
      BeginBlock();
      value.Statements.Iter(s =>
        {
          WriteStatement(s);
          when (IsSingleLineStatement(s))
          {
            Write(";");
            WriteLine();
          }
        });
      EndBlock();
    }

    private WriteExpressionStatement(value : IExpressionStatement) : void
    {
      WriteExpression(value.Expression);
    }

    private WriteGotoStatement(value : IGotoStatement) : void
    {
      WriteComment($"/* goto $(value.Name); */");
    }

    private WriteLabeledStatement(value : ILabeledStatement) : void
    {
      WriteComment($"/* $(value.Name)");
      unless (value.Statement == null)
        WriteComment(":");
      WriteComment(" */");

      unless (value.Statement == null)
        WriteStatement(value.Statement);
    }

    private WriteConditionStatement(value : IConditionStatement) : void
    {
      def thenPresent = value.Then != null && value.Then.Statements.Count > 0;
      def elsePresent = value.Else != null && value.Else.Statements.Count > 0;

      WriteKeyword(
        match ((thenPresent, elsePresent))
        {
        | (true, false)  => "when";
        | (false, true)  => "unless";
        | (true, true)   => "if";
        | (false, false) => throw NotSupportedException("Condition statement without a body");
        });

      Write(" (");
      WriteExpression(value.Condition);
      Write(")");
      WriteBlockStatement(if (thenPresent) value.Then; else value.Else);
      when (thenPresent && elsePresent)
      {
        WriteKeyword("else");

        if (value.Else.Statements.Count == 1 && value.Else.Statements[0] is IConditionStatement)
        {
          // else if case
          //
          Write(" ");
          WriteConditionStatement(value.Else.Statements[0] :> IConditionStatement);
        }
        else
          WriteBlockStatement(value.Else);
      }
    }

    private WriteMethodReturnStatement(value : IMethodReturnStatement) : void
    {
      WriteComment("/* return */");
      unless (value.Expression == null)
        WriteExpression(value.Expression);
    }

    private WriteForStatement(value : IForStatement) : void
    {
      WriteKeyword("for");
      Write(" (");
      unless (value.Initializer == null)
        WriteStatement(value.Initializer);
      Write("; ");

      unless (value.Condition == null)
        WriteExpression(value.Condition);
      Write("; ");

      unless (value.Increment == null)
        WriteStatement(value.Increment);
      Write(")");

      WriteBody(value.Body);
    }

    private WriteForEachStatement(value : IForEachStatement) : void
    {
      WriteKeyword("foreach");
      Write(" (");
      WriteVariableDeclaration(value.Variable, true);
      Write(" ");
      WriteKeyword("in");
      Write(" ");
      WriteExpression(value.Expression);
      Write(")");

      WriteBody(value.Body);
    }

    private WriteUsingStatement(value : IUsingStatement) : void
    {
      WriteKeyword("using");
      Write(" (");
      WriteExpression(value.Variable);
      Write(" = ");
      WriteExpression(value.Expression);
      Write(")");

      WriteBody(value.Body);
    }

    private WriteFixedStatement(value : IFixedStatement) : void
    {
      WriteKeyword("fixed");
      Write(" (");
      WriteVariableDeclaration(value.Variable, true);
      Write(" = ");
      WriteExpression(value.Expression);
      Write(")");

      WriteBody(value.Body);
    }

    private WriteWhileStatement(value : IWhileStatement) : void
    {
      WriteKeyword("while");
      Write(" (");
      if (value.Condition != null)
        WriteExpression(value.Condition);
      else
        WriteLiteral("true");
      Write(")");

      WriteBody(value.Body);
    }

    private WriteDoStatement(value : IDoStatement) : void
    {
      WriteKeyword("do");

      WriteBody(value.Body);

      WriteKeyword("while");
      Write(" (");
      if (value.Condition != null)
        WriteExpression(value.Condition);
      else
        WriteLiteral("true");
      Write(");");
      WriteLine();
    }

    private WriteTryCatchFinallyStatement(value : ITryCatchFinallyStatement) : void
    {
      WriteKeyword("try");

      WriteBody(value.Try);

      unless (value.CatchClauses.Count == 0)
      {
        WriteKeyword("catch");

        BeginBlock();
        value.CatchClauses.Iter(WriteCatchClause);
        EndBlock();
      }

      unless (value.Fault == null || value.Fault.Statements.Count == 0)
      {
        WriteKeyword("fault");
        WriteBlockStatement(value.Fault);
      }

      unless (value.Finally == null || value.Finally.Statements.Count == 0)
      {
        WriteKeyword("finally");
        WriteBlockStatement(value.Finally);
      }
    }

    private WriteThrowExceptionStatement(value : IThrowExceptionStatement) : void
    {
      WriteKeyword("throw");
      unless (value.Expression == null)
      {
          Write(" ");
          WriteExpression(value.Expression);
      }
    }

    private WriteAttachEventStatement(value : IAttachEventStatement) : void
    {
      WriteEventReferenceExpression(value.Event);
      Write(" += ");
      WriteExpression(value.Listener);
    }

    private WriteRemoveEventStatement(value : IRemoveEventStatement) : void
    {
      WriteEventReferenceExpression(value.Event);
      Write(" -= ");
      WriteExpression(value.Listener);
    }

    private WriteSwitchStatement(value : ISwitchStatement) : void
    {
      WriteKeyword("match");
      Write(" (");
      WriteExpression(value.Expression);
      Write(")");
      BeginBlock();
      value.Cases.Iter(WriteSwitchCase);
      EndBlock();
    }

    private WriteBreakStatement(_ : IBreakStatement) : void
    {
      WriteComment("/* break */");
    }

    private WriteContinueStatement(_: IContinueStatement) : void
    {
      WriteComment("/* continue */");
    }

    private WriteCommentStatement(value : ICommentStatement) : void
    {
      value.Comment.Text
        .Split(array["\r\n", "\n\r", "\r", "\n"], StringSplitOptions.None)
        .Iter(line =>
          {
            WriteComment("// ");
            WriteComment(line);
            WriteLine();
          });
    }

    private WriteLockStatement(value : ILockStatement) : void
    {
      WriteKeyword("lock");
      Write(" (");
      WriteExpression(value.Expression);
      Write(")");
      WriteBody(value.Body);
    }

    // Lutz knows what is it...
    //
    private WriteMemoryCopyStatement(value : IMemoryCopyStatement) : void
    {
      WriteKeyword("memcpy");
      Write("(");
      WriteExpression(value.Source);
      Write(", ");
      WriteExpression(value.Destination);
      Write(", ");
      WriteExpression(value.Length);
      Write(")");
    }

    // Lutz knows what is it...
    //
    private WriteMemoryInitializeStatement(value : IMemoryInitializeStatement) : void
    {
      WriteKeyword("meminit");
      Write("(");
      WriteExpression(value.Offset);
      Write(", ");
      WriteExpression(value.Value);
      Write(", ");
      WriteExpression(value.Length);
      Write(")");
    }

    #endregion

    #region WriteExpression

    public override WriteExpression(value : IExpression) : void
    {
    | null                                     => throw ArgumentNullException("expression");
    | expr is ILiteralExpression               => WriteLiteralExpression(expr);
    | expr is IAssignExpression                => WriteAssignExpression(expr);
    | expr is ITypeOfExpression                => WriteTypeOfExpression(expr);
    | expr is INamedArgumentExpression         => WriteNamedArgumentExpression(expr);
    | expr is ITypeReferenceExpression         => WriteTypeReferenceExpression(expr);
    | expr is IFieldReferenceExpression        => WriteFieldReferenceExpression(expr);
    | expr is IEventReferenceExpression        => WriteEventReferenceExpression(expr);
    | expr is IMethodReferenceExpression       => WriteMethodReferenceExpression(expr);
    | expr is IArgumentListExpression          => WriteArgumentListExpression(expr);
    | expr is IStackAllocateExpression         => WriteStackAllocateExpression(expr);
    | expr is IPropertyReferenceExpression     => WritePropertyReferenceExpression(expr);
    | expr is IArrayCreateExpression           => WriteArrayCreateExpression(expr);
    | expr is IArrayInitializerExpression      => WriteArrayInitializerExpression(expr);
    | expr is IBaseReferenceExpression         => WriteBaseReferenceExpression(expr);
    | expr is IUnaryExpression                 => WriteUnaryExpression(expr);
    | expr is IBinaryExpression                => WriteBinaryExpression(expr);
    | expr is ITryCastExpression               => WriteTryCastExpression(expr);
    | expr is ICanCastExpression               => WriteCanCastExpression(expr);
    | expr is ICastExpression                  => WriteCastExpression(expr);
    | expr is IConditionExpression             => WriteConditionExpression(expr);
    | expr is INullCoalescingExpression        => WriteNullCoalescingExpression(expr);
    | expr is IDelegateCreateExpression        => WriteDelegateCreateExpression(expr);
    | expr is IArgumentReferenceExpression     => WriteArgumentReferenceExpression(expr);
    | expr is IVariableDeclarationExpression   => WriteVariableDeclarationExpression(expr);
    | expr is IVariableReferenceExpression     => WriteVariableReferenceExpression(expr);
    | expr is IPropertyIndexerExpression       => WritePropertyIndexerExpression(expr);
    | expr is IArrayIndexerExpression          => WriteArrayIndexerExpression(expr);
    | expr is IMethodInvokeExpression          => WriteMethodInvokeExpression(expr);
    | expr is IDelegateInvokeExpression        => WriteDelegateInvokeExpression(expr);
    | expr is IObjectCreateExpression          => WriteObjectCreateExpression(expr);
    | expr is IThisReferenceExpression         => WriteThisReferenceExpression(expr);
    | expr is IAddressOfExpression             => WriteAddressOfExpression(expr);
    | expr is IAddressOutExpression            => WriteAddressOutExpression(expr);
    | expr is IAddressReferenceExpression      => WriteAddressReferenceExpression(expr);
    | expr is IAddressDereferenceExpression    => WriteAddressDereferenceExpression(expr);
    | expr is ISizeOfExpression                => WriteSizeOfExpression(expr);
    | expr is IGenericDefaultExpression        => WriteGenericDefaultExpression(expr);
    | expr is ITypeOfTypedReferenceExpression  => WriteTypeOfTypedReferenceExpression(expr);
    | expr is IValueOfTypedReferenceExpression => WriteValueOfTypedReferenceExpression(expr);
    | expr is ITypedReferenceCreateExpression  => WriteTypedReferenceCreateExpression(expr);
    | expr is IObjectInitializeExpression      => WriteObjectInitializeExpression(expr);
    | expr is ISnippetExpression               => WriteSnippetExpression(expr);
    | _                                        => throw NotImplementedException();
    }

    private WriteLiteralExpression(expression : ILiteralExpression) : void
    {
      match (expression.Value)
      {
      | null                => WriteLiteral("null");
      | str is string       => WriteLiteral($"\"$(EscapeString(str))\"")
      | chr is char         => WriteLiteral($"'$(EscapeChar(chr))'")
      | other               => WriteLiteral(Convert.ToString(other, CultureInfo.InvariantCulture))
      }
    }

    private WriteAssignExpression(expr : IAssignExpression) : void
    {
      WriteExpression(expr.Target);

      def op =
        match (expr.Expression)
        {
        | binExpr is IBinaryExpression
          when expr.Target.Equals(binExpr.Left) =>
            match (binExpr.Operator)
            {
            | BinaryOperator.Add                => "+=";
            | BinaryOperator.Subtract           => "-=";
            | BinaryOperator.Multiply           => "*=";
            | BinaryOperator.Modulus            => "%=";
            | BinaryOperator.Divide             => "/=";
            | BinaryOperator.BitwiseOr          => "|=";
            | BinaryOperator.BitwiseAnd         => "&=";
            | BinaryOperator.BitwiseExclusiveOr => "^=";
            | BinaryOperator.ShiftLeft          => "<<=";
            | BinaryOperator.ShiftRight         => ">>=";
            | _                                 => null;
            }
        | _                                     => null;
        }

      if (op != null)
      {
        Write(" ");
        Write(op);
        Write(" ");
        WriteExpression((expr.Expression :> IBinaryExpression).Right);
      }
      else
      {
        Write(" = ");
        WriteExpression(expr.Expression);
      }
    }

    private WriteTypeOfExpression(expr : ITypeOfExpression) : void
    {
      WriteKeyword("typeof");
      Write(" (");
      WriteType(expr.Type);
      Write(")");
    }

    private WriteNamedArgumentExpression(expr : INamedArgumentExpression) : void
    {
      WriteMemberReference(expr.Member);
      Write(" = ");
      WriteExpression(expr.Value);
    }

    private WriteTypeReferenceExpression(expr : ITypeReferenceExpression) : void
    {
      WriteType(expr.Type);
    }

    private WriteFieldReferenceExpression(expr : IFieldReferenceExpression) : void
    {
      unless (expr.Target == null)
      {
        WriteExpression(expr.Target);
        Write(".");
      }
      WriteFieldReference(expr.Field);
    }

    private WriteEventReferenceExpression(expr : IEventReferenceExpression) : void
    {
      unless (expr.Target == null)
      {
        WriteExpression(expr.Target);
        Write(".");
      }
      WriteEventReference(expr.Event);
    }

    private WriteMethodReferenceExpression(expr : IMethodReferenceExpression) : void
    {
      unless (expr.Target == null)
      {
        if (expr.Target is IBinaryExpression)
        {
          Write("(");
          WriteExpression(expr.Target);
          Write(")");
        }
        else
          WriteExpression(expr.Target);
        Write(".");
      }
      WriteMethodReference(expr.Method);
    }

    private WriteArgumentListExpression(_ : IArgumentListExpression) : void
    {
      WriteComment("/* __arglist */");
    }

    private WriteStackAllocateExpression(expr : IStackAllocateExpression) : void
    {
      WriteKeyword("stackalloc");
      Write(" ");
      WriteType(expr.Type);
      Write("[");
      WriteExpression(expr.Expression);
      Write("]");
    }

    private WritePropertyReferenceExpression(expr : IPropertyReferenceExpression) : void
    {
      unless (expr.Target == null)
      {
        WriteExpression(expr.Target);
        Write(".");
      }
      WritePropertyReference(expr.Property);
    }

    private WriteArrayCreateExpression(expr : IArrayCreateExpression) : void
    {
      WriteKeyword("array");

      if (expr.Initializer != null)
        WriteExpression(expr.Initializer);
      else if (expr.Dimensions != null && expr.Dimensions.Count != 0)
        WriteList(expr.Dimensions.ToList(), "(", ")", WriteExpression);
      else
        Write("[]");
    }

    private WriteArrayInitializerExpression(expr : IArrayInitializerExpression) : void
    {
     WriteList(expr.Expressions.ToList(), "[", "]", WriteExpression);
    }

    private WriteBaseReferenceExpression(_ : IBaseReferenceExpression) : void
    {
      WriteKeyword("base");
    }

    private WriteUnaryExpression(expr : IUnaryExpression) : void
    {
      match (expr.Operator)
      {
      | UnaryOperator.Negate       with op = "-"
      | UnaryOperator.BooleanNot   with op = "!"
      | UnaryOperator.BitwiseNot   with op = "~"
      | UnaryOperator.PreIncrement with op = "++"
      | UnaryOperator.PreDecrement with op = "--" =>
        Write(op);
        WriteExpression(expr.Expression);

      | UnaryOperator.PostIncrement with op = "++"
      | UnaryOperator.PostDecrement with op = "--" =>
        WriteExpression(expr.Expression);
        Write(op);

      | _                           =>
        throw NotSupportedException(expr.Operator.ToString());
      }
     }

    private WriteBinaryExpression(expr : IBinaryExpression) : void
    {
      Write("(");
      WriteExpression(expr.Left);
      Write(" ");
      WriteBinaryOperator(expr.Operator);
      Write(" ");
      WriteExpression(expr.Right);
      Write(")");
    }

    private WriteTryCastExpression(expr : ITryCastExpression) : void
    {
      WriteKeyword("if");
      Write(" (");
      WriteExpression(expr.Expression);
      Write(" ");
      WriteKeyword("is");
      Write(" ");
      WriteType(expr.TargetType);
      Write(") ");

      WriteExpression(expr.Expression);
      Write(" :> ");
      WriteType(expr.TargetType);
      Write("; ");
      WriteKeyword("else");
      Write(" ");
      WriteLiteral("null");
    }

    private WriteCanCastExpression(expr : ICanCastExpression) : void
    {
      WriteExpression(expr.Expression);
      Write(" ");
      WriteKeyword("is");
      Write(" ");
      WriteType(expr.TargetType);
    }

    private WriteCastExpression(expr : ICastExpression) : void
    {
      Write("(");
      WriteExpression(expr.Expression);
      Write(" :> ");
      WriteType(expr.TargetType);
      Write(")");
    }

    private WriteConditionExpression(expr : IConditionExpression) : void
    {
      WriteKeyword("if");
      Write(" (");
      WriteExpression(expr.Condition);
      Write(") ");
      WriteExpression(expr.Then);
      Write("; ");
      WriteKeyword("else");
      Write(" ");
      WriteExpression(expr.Else);
    }

    private WriteNullCoalescingExpression(expr : INullCoalescingExpression) : void
    {
      WriteExpression(expr.Condition);
      Write(" ?? ");
      WriteExpression(expr.Expression);
    }

    private WriteDelegateCreateExpression(expr : IDelegateCreateExpression) : void
    {
      WriteType(expr.DelegateType);
      Write("(");
      WriteExpression(expr.Target);
      Write(".");
      WriteMethodReference(expr.Method);
      Write(")");
    }

    private WriteArgumentReferenceExpression(expr : IArgumentReferenceExpression) : void
    {
      WriteParameterReference(expr.Parameter);
    }

    private WriteVariableDeclarationExpression(expr : IVariableDeclarationExpression) : void
    {
      WriteVariableDeclaration(expr.Variable);
    }

    private WriteVariableReferenceExpression(expr : IVariableReferenceExpression) : void
    {
      WriteVariableReference(expr.Variable);
    }

    private WritePropertyIndexerExpression(expr : IPropertyIndexerExpression) : void
    {
      WriteExpression(expr.Target.Target);
      WriteList(expr.Indices.ToList(), "[", "]", WriteExpression);
    }

    private WriteArrayIndexerExpression(expr : IArrayIndexerExpression) : void
    {
      WriteExpression(expr.Target);
      WriteList(expr.Indices.ToList(), "[", "]", WriteExpression);
    }

    private WriteMethodInvokeExpression(expr : IMethodInvokeExpression) : void
    {
      WriteExpression(expr.Method);
      Write("(");
      WriteList(expr.Arguments.ToList(), WriteExpression);
      Write(")");
    }

    private WriteDelegateInvokeExpression(expr : IDelegateInvokeExpression) : void
    {
      WriteExpression(expr.Target);
      Write("(");
      WriteList(expr.Arguments.ToList(), WriteExpression);
      Write(")");
    }

    private WriteObjectCreateExpression(expr : IObjectCreateExpression) : void
    {
      WriteType(expr.Constructor.DeclaringType);
      Write("(");
      WriteList(expr.Arguments.ToList(), WriteExpression);
      Write(")");
    }

    private WriteThisReferenceExpression(_ : IThisReferenceExpression) : void
    {
      WriteKeyword("this");
    }

    private WriteAddressOfExpression(expr : IAddressOfExpression) : void
    {
      def isIndexer = expr.Expression is IArrayIndexerExpression;
      Write("&");
      when (isIndexer)
        Write("(");

      WriteExpression(expr.Expression);

      when (isIndexer)
          Write(")");
    }

    private WriteAddressOutExpression(expr : IAddressOutExpression) : void
    {
      WriteKeyword("out");
      Write(" ");
      WriteExpression(expr.Expression);
    }

    private WriteAddressReferenceExpression(expr : IAddressReferenceExpression) : void
    {
      WriteKeyword("ref");
      Write(" ");
      WriteExpression(expr.Expression);
    }

    private WriteAddressDereferenceExpression(expr : IAddressDereferenceExpression) : void
    {
      Write("*(");
      WriteExpression(expr.Expression);
      Write(")");
    }

    private WriteSizeOfExpression(expr : ISizeOfExpression) : void
    {
      WriteKeyword("sizeof");
      Write(" (");
      WriteType(expr.Type);
      Write(")");
    }

    private WriteGenericDefaultExpression(expr : IGenericDefaultExpression) : void
    {
      WriteType(expr.GenericArgument);
      Write("()");
    }

    private WriteTypeOfTypedReferenceExpression(expr : ITypeOfTypedReferenceExpression) : void
    {
      WriteComment("/* __reftype */");
      Write("(");
      WriteExpression(expr.Expression);
      Write(")");
    }

    private WriteValueOfTypedReferenceExpression(expr : IValueOfTypedReferenceExpression) : void
    {
      WriteComment("/* __refvalue */");
      Write("(");
      WriteExpression(expr.Expression);
      Write(", ");
      WriteType(expr.TargetType);
      Write(")");
    }

    private WriteTypedReferenceCreateExpression(expr : ITypedReferenceCreateExpression) : void
    {
      WriteComment("/* __makeref */");
      Write("(");
      WriteExpression(expr.Expression);
      Write(")");
    }

    private WriteObjectInitializeExpression(expr : IObjectInitializeExpression) : void
    {
      WriteType(expr.Type);
      Write("()");
    }

    private WriteSnippetExpression(expr : ISnippetExpression) : void
    {
      WriteComment(expr.Value);
    }

    #endregion

    #region Type members

    public override WriteEventDeclaration(value : IEventDeclaration) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      WriteDocumentation(value);
      WriteCustomAttributeList(value);

      unless (value.DeclaringType.IsInterface())
        WriteMethodVisibility(value.GetVisibility());

      WriteKeyword("event");
      Write(" ");
      WriteMemberName(value.Name);
      Write(" : ");
      WriteType(value.EventType);
      Write(";");

      unless (_configuration.ShowTypeDeclarationBody)
        WriteDeclaringTypeProperties(value.DeclaringType :> ITypeReference);
    }

    public override WriteFieldDeclaration(value : IFieldDeclaration) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      WriteDocumentation(value);
      WriteCustomAttributeList(value);

      match (value.GetVisibility())
      {
      | FieldVisibility.Private           => WriteKeyword("private");
      | FieldVisibility.PrivateScope      => WriteComment("/* private scope */");
      | FieldVisibility.FamilyAndAssembly => WriteKeyword("protected internal");
      | FieldVisibility.Assembly          => WriteKeyword("internal");
      | FieldVisibility.Family            => WriteKeyword("protected");
      | FieldVisibility.FamilyOrAssembly  => WriteKeyword("internal protected");
      | FieldVisibility.Public            => WriteKeyword("public");
      | _                                 => throw NotSupportedException()
      }

      Write(" ");

      when (value.Static)
      {
        WriteKeyword("static");
        Write(" ");
      }

      unless (value.ReadOnly || value.Literal)
      {
        WriteKeyword("mutable");
        Write(" ");
      }

      WriteMemberName(value.Name);

      Write(" : ");
      WriteType(value.FieldType);

      unless (value.Initializer == null)
      {
        Write(" = ");
        WriteExpression(value.Initializer);
      }

      Write(";");

      unless (_configuration.ShowTypeDeclarationBody)
        WriteDeclaringTypeProperties(value.DeclaringType :> ITypeReference);
    }

    public override WriteMethodDeclaration(value : IMethodDeclaration) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      def wrapper = CustomAttributeWrapper.Method(value);
      WriteDocumentation(value);
      WriteCustomAttributeList(wrapper.Attributes);
      WriteCustomAttributeList(value.ReturnType);

      unless (value.DeclaringType.IsInterface())
      {
        WriteMethodVisibility(value.GetVisibility());
        WriteMethodAttributes(value);

        when (wrapper.IsExternal || wrapper.InternalCall)
        {
          WriteKeyword("extern");
          Write(" ");
        }
      }

      if (value.IsConstructor())
      {
        WriteKeyword("this");
        Write("(");
        WriteList(value.Parameters.ToList(), WriteParameterDeclaration);
        Write(")");

        // Constructor body is broken by the translator for some unknown reason.
        //
        when (_configuration.ShowMethodDeclarationBody)
        {
          BeginBlock();
          match (value)
          {
          | cd is IConstructorDeclaration when cd.Initializer != null =>
            match (cd.Initializer.Method)
            {
            | mRef is IMethodReferenceExpression when mRef.Method.IsConstructor() =>
              unless (cd.Initializer.Arguments.Count == 0)
              {
                match (mRef.Target)
                {
                | _ is IBaseReferenceExpression with name = "base"
                | _ is IThisReferenceExpression with name = "this" =>
                  WriteReference(name, mRef.Method.GetUserFriendlyName(), mRef.Method, false);
                  Write("(");
                  WriteList(cd.Initializer.Arguments.ToList(), WriteExpression);
                  Write(")");
                | _ => WriteMethodInvokeExpression(cd.Initializer);
                }
                Write(";");
                WriteLine();
              }
            | _ =>
              WriteMethodInvokeExpression(cd.Initializer);
              Write(";");
              WriteLine();
            }
          | _ => {}
          }

          match (value.Body)
          {
          | b is IBlockStatement =>
            b.Statements.Iter(s =>
              {
                WriteStatement(s);
                when (IsSingleLineStatement(s))
                {
                  Write(";");
                  WriteLine();
                }
              });
          | s is IStatement      =>
            WriteStatement(s);
            Write(";");
            WriteLine();
          | _                    => {}
          }

          EndBlock();
        }
      }
      else
      {
        def genArgs = value.GenericArguments.ToList();

        WriteMemberName(value.Name);

        WriteList(genArgs, "[", "]", WriteType);
        Write("(");
        when (value.Static && wrapper.IsExtension)
        {
          WriteKeyword("this");
          Write(" ");
        }
        WriteList(value.Parameters.ToList(), WriteParameterDeclaration);
        Write(")");
        Write(" : ");
        WriteType(value.ReturnType.Type);
        WriteGenericParameterConstraintList(genArgs);

        def overrides = value.Overrides.ToList();
        unless (overrides.IsEmpty)
        {
          Write(" ");
          WriteKeyword("implements");
          Write(" ");
          WriteList(overrides, m =>
            {
              WriteType(m.DeclaringType);
              Write(".");
              WriteMethodReference(m);
            });
        }

        WriteMethodBody(value.Body);
      }

      unless (_configuration.ShowTypeDeclarationBody)
        WriteDeclaringTypeProperties(value.DeclaringType :> ITypeReference);
    }

    public override WritePropertyDeclaration(value : IPropertyDeclaration) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      WriteDocumentation(value);
      WriteCustomAttributeList(value);

      def getMethod = if (value.GetMethod != null) value.GetMethod.Resolve() else null;
      def setMethod = if (value.SetMethod != null) value.SetMethod.Resolve() else null;

      def isInterface    = value.DeclaringType.IsInterface();
      def propVisibility = value.GetVisibility();

      unless (isInterface)
      {
        WriteMethodVisibility(propVisibility);
        if (getMethod != null)
          WriteMethodAttributes(getMethod);
        else when (setMethod != null)
          WriteMethodAttributes(setMethod);
      }

      WriteMemberName(value.Name);

      WriteList(value.Parameters.ToList(), "[", "]", WriteParameterDeclaration);
      Write(" : ");
      WriteType(value.PropertyType);

      unless (getMethod == null && setMethod == null)
      {
        if (_configuration.ShowMethodDeclarationBody)
          BeginBlock();
        else
          Write(" { ");

        unless (getMethod == null)
        {
          WriteList(getMethod.Attributes.ToList(), "[", "] ", WriteCustomAttribute);

          unless (isInterface || propVisibility == getMethod.GetVisibility())
            WriteMethodVisibility(getMethod.GetVisibility());

          WriteKeyword("get");
          WriteMethodBody(getMethod.Body);
        }

        unless (setMethod == null)
        {
          WriteList(setMethod.Attributes.ToList(), "[", "] ", WriteCustomAttribute);

          unless (isInterface || propVisibility == setMethod.GetVisibility())
            WriteMethodVisibility(setMethod.GetVisibility());

          WriteKeyword("set");
          WriteMethodBody(setMethod.Body);
        }

        if (_configuration.ShowMethodDeclarationBody)
          EndBlock();
        else
          Write(" }");
      }

      unless (_configuration.ShowTypeDeclarationBody)
        WriteDeclaringTypeProperties(value.DeclaringType :> ITypeReference);
    }

    #endregion

    #region WriteTypeDeclaration

    public override WriteTypeDeclaration(value : ITypeDeclaration) : void
    {
      when (value == null)
        throw ArgumentNullException("value");

      unless (value.Namespace.Length == 0 && value.Name == "<Module>")
      {
        def wrapper = CustomAttributeWrapper.Type(value);
        WriteDocumentation(value);
        WriteCustomAttributeList(wrapper.Attributes);

        // Variant options has the same access as the outer variant.
        //
        unless (wrapper.IsVariantOption)
        {
          WriteKeyword(
            match (value.Visibility)
            {
            | TypeVisibility.Private
            | TypeVisibility.NestedAssembly          => "internal"
            | TypeVisibility.Public
            | TypeVisibility.NestedPublic            => "public"
            | TypeVisibility.NestedPrivate           => "private"
            | TypeVisibility.NestedFamily            => "protected"
            | TypeVisibility.NestedFamilyAndAssembly => "protected internal"
            | TypeVisibility.NestedFamilyOrAssembly  => "internal protected"
            | _                                      => throw NotSupportedException()
            });
          Write(" ");
        }

        match (value.GetBaseTypeName())
        {
        | ("System", "Delegate")
        | ("System", "MulticastDelegate") => WriteDelegateDeclaration(value)
        | ("System", "Enum")              => WriteEnumDeclaration(value, wrapper)
        | ("System", "ValueType")         => WriteTypeDeclaration(value, "struct")
        | _                               =>
          if (value.Interface)
            if (wrapper.TypeAlias != null)
              WriteTypeAliasDeclaration(value, wrapper)
            else
              WriteTypeDeclaration(value, "interface")
          else if (value.Abstract)
            if (value.Sealed)
              WriteTypeDeclaration(value, "module")
            else if (wrapper.IsVariant)
              WriteTypeDeclaration(value, "variant")
            else
            {
              WriteKeyword("abstract");
              Write(" ");
              WriteTypeDeclaration(value, "class")
            }
          else if (value.Sealed)
            if (wrapper.IsVariantOption)
              WriteTypeDeclaration(value, "|")
            else
            {
              WriteKeyword("sealed");
              Write(" ");
              WriteTypeDeclaration(value, "class")
            }
          else
              WriteTypeDeclaration(value, "class")
        }
      }
    }

    private WriteDelegateDeclaration(value : ITypeDeclaration) : void
    {
      WriteKeyword("delegate");
      Write(" ");
      WriteDeclaration(value.Name);

      def decl = value.Methods.Find(m : IMethodDeclaration => m.Name == "Invoke");
      unless (decl == null)
      {
        def genArgs = value.GenericArguments.ToList();
        WriteList(genArgs, "[", "]", WriteType);
        Write("(");
        WriteList(decl.Parameters.ToList(), WriteParameterDeclaration);
        Write(")");
        Write(" : ");
        WriteType(decl.ReturnType.Type);
        WriteGenericParameterConstraintList(genArgs);
      }

      Write(";");
    }

    private WriteEnumDeclaration
      ( value   : ITypeDeclaration
      , wrapper : CustomAttributeWrapper.Type
      )         : void
    {
      WriteKeyword("enum");
      Write(" ");
      WriteDeclaration(value.Name);

      // Usually, the first enum field is the enum underlying type.
      // The rest is the enum values.
      //
      def underliyngTypeField = value.Fields.Find(f : IFieldDeclaration =>
        f.SpecialName && f.RuntimeSpecialName && !f.FieldType.Equals(value));

      when (underliyngTypeField != null)
      {
        def (ns, name) = underliyngTypeField.FieldType.GetTypeName();

        // int is the default enum type. So hide them.
        //
        unless (ns == "System" && name == "Int32")
        {
          Write(" : ");
          WriteType(underliyngTypeField.FieldType)
        }
      }

      // Enum can contain only fields (values).
      // No events/methods/properties.
      //
      when (_configuration.ShowTypeDeclarationBody)
      {
        BeginBlock();

        mutable expectedValue = 0L;
        value.Fields.Iter(f : IFieldDeclaration =>
        {
          unless (f.SpecialName && f.RuntimeSpecialName && !f.FieldType.Equals(value))
          {
            Write("| ");
            WriteDeclaration(f.Name);

            // Initializer optimization.
            // Do not write redundant initializers.
            // Also [FlagsAttribute] marked enum values are written in hex.
            //
            def suppressInitializer =
              match (f.Initializer)
              {
              | literal is ILiteralExpression =>
                if (wrapper.IsFlagsEnumeration)
                {
                  match (literal.Value)
                  {
                  | fmt is IFormattable =>
                    Write(" = ");
                    WriteLiteral("0x" + fmt.ToString("X2", CultureInfo.InvariantCulture));
                    true
                  | _                   => false
                  }
                }
                else
                {
                  match (literal.Value)
                  {
                  | cvt is IConvertible =>
                    try
                    {
                      def actualValue = cvt.ToInt64(CultureInfo.InvariantCulture);
                      def same = (actualValue == expectedValue);
                      expectedValue = actualValue + 1;
                      same
                    }
                    catch
                    {
                    | _ =>
                      // On error turn off the optimization.
                      //
                      expectedValue = 0;
                      false
                    }
                  | _                   => false
                  }
                }
              | null                    => true
              | _                       => false
              }

            unless (suppressInitializer)
            {
              Write(" = ");
              WriteExpression(f.Initializer);
            }

            WriteLine();
          }
        });

        EndBlock();
      }
    }

    private WriteTypeAliasDeclaration
      ( value   : ITypeDeclaration
      , wrapper : CustomAttributeWrapper.Type
      )         : void
    {
      // TODO: Decode alias string to real type name and generic parameters
      // See ncc\external\Codec.n for details
      //
      def genArgs  = value.GenericArguments.ToList();
      def alias    = wrapper.TypeAlias;
      def dotIndex = alias.LastIndexOf('.');
      def typeRef  = TypeReference();

      if (dotIndex > 0)
      {
        typeRef.Namespace = alias.Substring(0, dotIndex);
        typeRef.Name      = alias.Substring(dotIndex + 1);
      }
      else
        typeRef.Name      = alias;

      WriteKeyword("type");
      Write(" ");

      WriteDeclaration(value.Name);
      WriteList(genArgs, "[", "]", WriteType);
      WriteGenericParameterConstraintList(genArgs);
      Write(" = ");

      WriteReference(alias, alias, typeRef);
      Write(";");
    }

    private WriteTypeDeclaration
      ( value    : ITypeDeclaration
      , keyword  : string
      )          : void
    {
      WriteKeyword(keyword);
      Write(" ");

      def genArgs = value.GenericArguments.ToList();
      WriteDeclaration(value.Name);

      // Skip variant option base type, generic arguments and constraints.
      //
      unless (keyword == "|")
      {
        WriteList(genArgs, "[", "]", WriteType);

        def baseTypes =
          match (value.GetBaseTypeName())
          {
          | (null, null)
          | ("System", "Object")
          | ("System", "ValueType") => value.Interfaces.ToList();
          | _                       => value.BaseType :: value.Interfaces.ToList();
          }

        WriteList(baseTypes, " : ", null, WriteType);
        WriteGenericParameterConstraintList(genArgs);
      }

      when (_configuration.ShowTypeDeclarationBody)
      {
        BeginBlock();

        def events      = value.Events     .ToList().Filter(e => !e.RuntimeSpecialName);
        def fields      = value.Fields     .ToList().Filter(e => !e.IsGenerated() && !e.RuntimeSpecialName);
        def innerTypes  = value.NestedTypes.ToList().Filter(e => !e.IsGenerated());
        def properties  = value.Properties .ToList().Filter(e => !e.IsGenerated());
        mutable methods = value.Methods    .ToList().Filter(e => !e.IsGenerated());

        events.Iter(e : IEventDeclaration =>
          {
            unless (e.AddMethod == null)
              methods = methods.Remove(e.AddMethod.Resolve());
            unless (e.RemoveMethod == null)
              methods = methods.Remove(e.RemoveMethod.Resolve());
            unless (e.InvokeMethod == null)
              methods = methods.Remove(e.InvokeMethod.Resolve());
          });

        properties.Iter(e : IPropertyDeclaration =>
          {
            unless (e.GetMethod == null)
              methods = methods.Remove(e.GetMethod.Resolve());
            unless (e.SetMethod == null)
              methods = methods.Remove(e.SetMethod.Resolve());
          });

        innerTypes.Iter(t : ITypeDeclaration => WriteTypeDeclaration(t));

        WriteMembersDeclaration(events,     "Events",     WriteEventDeclaration);
        WriteMembersDeclaration(fields,     "Fields",     WriteFieldDeclaration);
        WriteMembersDeclaration(methods,    "Methods",    WriteMethodDeclaration);
        WriteMembersDeclaration(properties, "Properties", WritePropertyDeclaration);

        EndBlock();
      }
    }

    private WriteMembersDeclaration['a](lst : list['a], name : string, writer : 'a -> void) : void
    {
      unless (lst.IsEmpty)
      {
        WriteKeyword("#region");
        Write(" ");
        Write(name);
        WriteLine();
        WriteLine();

        lst.Iter(m =>
          {
            writer(m);
            WriteLine();
          });

        WriteLine();
        WriteKeyword("#endregion");
        Write(" ");
        Write(name);
        WriteLine();
        WriteLine();
      }
    }

    #endregion

    #region Helpers

    private WriteFieldReference(value : IFieldReference) : void
    {
      WriteReference(value.Name, value.GetUserFriendlyName(), value);
    }

    private WriteMethodReference(value : IMethodReference) : void
    {
      def name =
        if (value.IsConstructor())
         value.DeclaringType.GetName();
        else
         value.Name;

      WriteReference(name, value.GetUserFriendlyName(), value);
    }

    private WritePropertyReference(value : IPropertyReference) : void
    {
      WriteReference(value.Name, value.GetUserFriendlyName(), value);
    }

    private WriteEventReference(value : IEventReference) : void
    {
      WriteReference(value.Name, value.GetUserFriendlyName(), value);
    }

    private WriteParameterReference(value : IParameterReference) : void
    {
      def ty =
        match (value.Resolve())
        {
        | null => string.Empty;
        | decl => decl.ParameterType.GetUserFriendlyName();
        };

      WriteReference(value.Name, $"$(value.Name) : $ty // Parameter", null);
    }

    private WriteVariableReference(value : IVariableReference) : void
    {
      def ty = value.Variable.VariableType.GetUserFriendlyName();
      WriteReference(value.Name, $"$(value.Name) : $ty // Local variable", null);
    }

    private WriteMemberReference(memberReference : IMemberReference) : void
    {
    | f is IFieldReference    => WriteFieldReference   (f);
    | m is IMethodReference   => WriteMethodReference  (m);
    | p is IPropertyReference => WritePropertyReference(p);
    | e is IEventReference    => WriteEventReference   (e);
    | _                       => throw NotSupportedException();
    }

    private WriteVariableDeclaration(value : IVariableDeclaration, inner : bool = false) : void
    {
      unless (inner)
      {
        WriteKeyword("mutable");
        Write(" ");
      }

      WriteDeclaration(value.Name);
      when (value.Pinned)
      {
          Write(" ");
          WriteComment("/* pinned */");
      }
      Write(" : ");
      WriteType(value.VariableType);
    }

    private WriteType(value : IType) : void
    {
    | typeRef is ITypeReference    =>
      match (typeRef.GetTypeName())
      {
      | ("Nemerle.Builtins", "Tuple")        =>
        WriteList(typeRef.GenericArguments.ToList(), "(", ")", " * ", WriteType);

      | ("Nemerle.Builtins", "Function")     =>
        def (genArgs, retType) = typeRef.GenericArguments.ToList().DivideLast();
        if (genArgs.IsEmpty)
        {
          WriteVoidRef(typeRef.GetAssembly());
          Write(" -> ");
        }
        else
          WriteList(genArgs, null, " -> ", " * ", WriteType);
        WriteType(retType);

      | ("Nemerle.Builtins", "FunctionVoid") =>
        def genArgs = typeRef.GenericArguments.ToList();
        if (genArgs.IsEmpty)
        {
          WriteVoidRef(typeRef.GetAssembly());
          Write(" -> ");
        }
        else
          WriteList(genArgs, null, " -> ", " * ", WriteType);
        WriteVoidRef(typeRef.GetAssembly());

      | _ =>
        def name = Helper.GetUserFriendlyName(typeRef);
        WriteTypeReference(typeRef, name, typeRef);
        WriteList(typeRef.GenericArguments.ToList(), "[", "]", WriteType);
      }

    | arrType is IArrayType        =>
      WriteKeyword("array");
      Write("[");

      def dims = arrType.Dimensions;
      when (dims.Count > 1)
      {
        WriteLiteral(dims.Count.ToString(CultureInfo.InvariantCulture));
        Write(", ");
      }

      for (mutable i = 0; i < dims.Count; ++i)
      {
        def dim = dims[i];
        when (dim.LowerBound > 0)
          WriteComment($"/* Dim $i LowerBound = $(dim.LowerBound)*/");
        when (dim.UpperBound != -1)
          WriteComment($"/* Dim $i UpperBound = $(dim.UpperBound)*/");
      }

      WriteType(arrType.ElementType);
      Write("]");

    | ptrType is IPointerType      =>
      WriteType(ptrType.ElementType);
      Write("*");

    | refType is IReferenceType    =>
      WriteKeyword("ref");
      Write(" ");
      WriteType(refType.ElementType);

    | modOpt  is IOptionalModifier =>
      WriteType(modOpt.ElementType);
      Write(" ");
      WriteKeyword("modopt");
      Write("(");
      WriteType(modOpt.Modifier);
      Write(")");

    | modReq  is IRequiredModifier =>
      match (modReq.Modifier)
      {
      | typeRef when typeRef != null
            && typeRef.Namespace == "System.Runtime.CompilerServices"
            && typeRef.Name      == "IsVolatile" =>
        WriteKeyword("volatile");
        Write(" ");
        WriteType(modReq.ElementType);
      | _                              =>
        WriteType(modReq.ElementType);
        Write(" ");
        WriteKeyword("modreq");
        Write("(");
        WriteType(modReq.Modifier);
        Write(")");
      }

    | funPtr  is IFunctionPointer  =>
      WriteType(funPtr.ReturnType.Type);
      Write(" *(");
      for (mutable i = 0; i < funPtr.Parameters.Count; ++i)
      {
        when (i != 0)
          Write(", ");

        WriteType(funPtr.Parameters[i].ParameterType);
      }
      Write(")");

    | genParm is IGenericParameter =>
      WriteDeclaration(genParm.Name);

    | genArg  is IGenericArgument  =>
      match (genArg.Resolve())
      {
      | genParm is IGenericParameter =>
        def name = genParm.Name + " // Generic Argument";
        WriteReference(genParm.Name, name, null);
      | other                        => WriteType(other)
      }

    | _                            =>
      throw NotSupportedException($"Unknown kind of type '$(value.GetType().Name)'.");
    }

    private WriteCatchClause(value : ICatchClause) : void
    {
      Write("| ");
      match (value.Variable.VariableType.GetTypeName())
      {
      | ("System", "Object") => Write("_");
      | _                    =>
        WriteDeclaration(value.Variable.Name);
        Write(" ");
        WriteKeyword("is");
        Write(" ");
        WriteType(value.Variable.VariableType);
      }

      unless (value.Condition == null)
      {
          Write(" ");
          WriteKeyword("when");
          Write(" (");
          WriteExpression(value.Condition);
          Write(")");
      }

      Write(" =>");
      WriteBody(value.Body);
    }

    private WriteSwitchCase(value : ISwitchCase) : void
    {
    | c is IConditionCase =>
      def writeCase(e)
      {
      | b is IBinaryExpression when b.Operator == BinaryOperator.BooleanOr =>
        writeCase(b.Left);
        WriteLine();
        writeCase(b.Right);
      | _ =>
        Write("| ");
        WriteExpression(e);
      }
      writeCase(c.Condition);
      Write(" =>");
      WriteBody(c.Body);

    | d is IDefaultCase   =>
      Write("| _ =>");
      WriteBody(d.Body);

    | _                   =>
      throw NotSupportedException($"Switch case type $(value.GetType().Name)");
    }

    private WriteBody(value : IBlockStatement) : void
    {
      if (value != null)
        WriteBlockStatement(value);
      else
      {
        // Write empty block.
        //
        BeginBlock();
        EndBlock();
      }
    }

    private WriteCustomAttribute(value : ICustomAttribute) : void
    {
      def ty       = value.Constructor.DeclaringType;
      def typeName = ty.GetName();

      WriteReference(
        {
          if (typeName.EndsWith("Attribute"))
            typeName.Substring(0, typeName.Length - 9);
          else
            typeName;
        }, ty.GetUserFriendlyName(), value.Constructor);

      WriteList(value.Arguments.ToList(), "(", ")", WriteExpression);
    }

    private WriteCustomAttributeList(attrs : list[ICustomAttribute]) : void
    {
      when (_configuration.ShowCustomAttributes && !attrs.IsEmpty)
      {
        WriteList(attrs, "[", "]", WriteCustomAttribute);
        WriteLine();
      }
    }

    private WriteCustomAttributeList(provider : ICustomAttributeProvider) : void
    {
      def attrs = provider.Attributes.ToList();
      when (_configuration.ShowCustomAttributes && !attrs.IsEmpty)
      {
        def target =
          match (provider)
          {
          | _ is IAssembly         => "assembly";
          | _ is IModule           => "module";
          | _ is IMethodReturnType => "return";
          | _                      => null;
          }

        if (target != null)
        {
          // Special attributes are written one per line.
          //
          attrs.Iter(attr =>
            {
              Write("[");
              WriteKeyword(target);
              Write(": ");
              WriteCustomAttribute(attr);
              Write("]");
              WriteLine();
            })
        }
        else
        {
          WriteList(attrs, "[", "]", WriteCustomAttribute);
          WriteLine();
        }
      }
    }

    private WriteDocumentation(value : IDocumentationProvider ) : void
    {
      when (_configuration.ShowDocumentation)
      {
        def doc = value.Documentation;
        unless (string.IsNullOrEmpty(doc))
        {
          using (rdr = StringReader(doc))
          {
            while (rdr.Peek() != -1)
            {
              def line = rdr.ReadLine();
              WriteComment("/// ");
              WriteComment(line);
              WriteLine();
            }
          }
        }
      }
    }

    private WriteGenericParameterConstraint(value : IType) : void
    {
    | _ is IDefaultConstructorConstraint =>
      WriteKeyword("new");
      Write("()");
    | _ is IReferenceTypeConstraint      =>
      WriteKeyword("class");
    | _ is IValueTypeConstraint          =>
      WriteKeyword("struct");
    | _                                  =>
      WriteType(value);
    }

    private WriteGenericParameterConstraintList(lst : list[IType]) : void
    {
      lst.Iter(e =>
        {
        | p is IGenericParameter when p.Constraints.Count != 0 =>
          Write(" ");
          WriteKeyword("where");
          Write(" ");
          Write(p.Name);
          Write(" : ");

          WriteList(p.Constraints.ToList(), WriteGenericParameterConstraint);
        | _                                                    => ()
        }
      );
    }

    private WriteParameterDeclaration(value : IParameterDeclaration) : void
    {
      def wrapper = CustomAttributeWrapper.Parameter(value);
      WriteList(wrapper.Attributes, "[", "] ", WriteCustomAttribute);

      when (wrapper.IsParamArray)
      {
        WriteKeyword("params");
        Write(" ");
      }

      WriteIdentifier(if (value.IsGenerated()) "_" else value.Name);
      Write(" : ");

      if (wrapper.IsOut && !wrapper.IsIn && value.ParameterType is IReferenceType)
      {
        // The 'out' parameter is actually a 'ref' parameter
        // wich must be initialized until return.
        //
        WriteKeyword("out");
        Write(" ");
        WriteType((value.ParameterType :> IReferenceType).ElementType);
      }
      else
        WriteType(value.ParameterType);

      unless (value.DefaultValue == null)
      {
        Write(" = ");
        WriteExpression(value.DefaultValue);
      }
    }

    private WriteMemberName(name : string) : void
    {
      // Convert a c#-style name of explicit implementation member
      // to the Nemerle style. F.e. System.Cloneable becomes System'Cloneable
      //
      WriteDeclaration(name.Replace('.', '\'').Replace('<', '_').Replace('>', '_'));
    }

    private WriteDeclaringTypeProperties(value : ITypeReference) : void
    {
      WriteProperty("Declaring Type", value.GetUserFriendlyName());
      match (value.GetAssembly())
      {
      | null
      | a when a.Name == null =>()
      | a                     =>
        def ver = if (a.Version == null) string.Empty else ", Version=" + a.Version.ToString();
        WriteProperty("Assembly", a.Name + ver);
      }
    }

    private WriteMethodBody(value : object) : void
    {
    | b is IBlockStatement
      when _configuration.ShowMethodDeclarationBody =>
        WriteBlockStatement(b);
    | s is IStatement
      when _configuration.ShowMethodDeclarationBody =>
      BeginBlock();
      WriteStatement(s);
      Write(";");
      WriteLine();
      EndBlock();
    | _                                             =>
      Write(";");
    }

    private WriteMethodAttributes(value : IMethodDeclaration) : void
    {
      when (value.Static)
      {
          WriteKeyword("static");
          Write(" ");
      }

      when (!value.NewSlot && value.Final)
      {
          WriteKeyword("sealed");
          Write(" ");
      }

      when (value.Virtual)
      {
          if (value.Abstract)
          {
              WriteKeyword("abstract");
              Write(" ");
          }
          else when (value.NewSlot && !value.Final)
          {
              WriteKeyword("virtual");
              Write(" ");
          }

          unless (value.NewSlot)
          {
              WriteKeyword("override");
              Write(" ");
          }
      }
    }

    private WriteMethodVisibility(value : MethodVisibility) : void
    {
      WriteKeyword(
        match (value)
        {
        | MethodVisibility.Private
        | MethodVisibility.PrivateScope      => "private"
        | MethodVisibility.FamilyAndAssembly => "protected internal"
        | MethodVisibility.Assembly          => "internal"
        | MethodVisibility.Family            => "protected"
        | MethodVisibility.FamilyOrAssembly  => "internal protected"
        | MethodVisibility.Public            => "public"
        | _                                  => throw NotSupportedException()
        });
      Write(" ");
    }

    private WriteBinaryOperator(value : BinaryOperator) : void
    {
      Write(
        match (value)
        {
        | BinaryOperator.Add                => "+";
        | BinaryOperator.Subtract           => "-";
        | BinaryOperator.Multiply           => "*";
        | BinaryOperator.Divide             => "/";
        | BinaryOperator.Modulus            => "%";
        | BinaryOperator.ShiftLeft          => "<<";
        | BinaryOperator.ShiftRight         => ">>";
        | BinaryOperator.IdentityEquality
        | BinaryOperator.ValueEquality      => "==";
        | BinaryOperator.IdentityInequality
        | BinaryOperator.ValueInequality    => "!=";
        | BinaryOperator.BitwiseOr          => "%|";
        | BinaryOperator.BitwiseAnd         => "%&";
        | BinaryOperator.BitwiseExclusiveOr => "%^";
        | BinaryOperator.BooleanOr          => "||";
        | BinaryOperator.BooleanAnd         => "&&";
        | BinaryOperator.LessThan           => "<";
        | BinaryOperator.LessThanOrEqual    => "<=";
        | BinaryOperator.GreaterThan        => ">";
        | BinaryOperator.GreaterThanOrEqual => ">=";
        | _                                 =>  throw NotSupportedException($"Unsupported BinaryOperator '$value'");
        });
    }

    private EscapeString(value : string) : string
    {
      def builder = StringBuilder(value.Length * 2);

      for (mutable i = 0; i < value.Length; ++i)
      {
        _ =
          match (value[i])
          {
          | '\0'               => builder.Append(@"\0");
          | '\b'               => builder.Append(@"\b");
          | '\e'               => builder.Append(@"\e");
          | '\n'               => builder.Append(@"\n");
          | '\r'               => builder.Append(@"\r");
          | '\t'               => builder.Append(@"\t");
          | '\\'               => builder.Append(@"\\");
          | '\''               => builder.Append(@"\'");
          | '$'                => builder.Append(@"\$");
          | '"'                => builder.Append(@"\""");
          | c when c < ' '     => builder.Append(@"\x" + (c :> short).ToString("X2", CultureInfo.InvariantCulture));
          | c when c > '\xFF'  => builder.Append(@"\u" + (c :> short).ToString("X4", CultureInfo.InvariantCulture));
          | c                  => builder.Append(c);
          };
      }

      builder.ToString();
    }

    private EscapeChar(value : char) : string
    {
    | '\0'              => @"\0";
    | '\b'              => @"\b";
    | '\e'              => @"\e";
    | '\n'              => @"\n";
    | '\r'              => @"\r";
    | '\t'              => @"\t";
    | '\\'              => @"\\";
    | '\''              => @"\'";
    | '$'               => @"\$";
    | '"'               => @"\""";
    | c when c < ' '    => @"\x" + (value :> short).ToString("X2", CultureInfo.InvariantCulture);
    | c when c > '\xFF' => @"\u" + (value :> short).ToString("X4", CultureInfo.InvariantCulture);
    | c                 => c.ToString();
    }

    private IsSingleLineStatement(value : IStatement) : bool
    {
    | null                                => throw ArgumentNullException("value");
    | _ is IBlockStatement
    | _ is IForStatement
    | _ is IForEachStatement
    | _ is IUsingStatement
    | _ is IFixedStatement
    | _ is IWhileStatement
    | _ is IDoStatement
    | _ is ITryCatchFinallyStatement
    | _ is ISwitchStatement
    | _ is ICommentStatement
    | _ is ILockStatement
    | _ is IConditionStatement            => false;
    | _ is IExpressionStatement
    | _ is IGotoStatement
    | _ is IMethodReturnStatement
    | _ is IThrowExceptionStatement
    | _ is IAttachEventStatement
    | _ is IRemoveEventStatement
    | _ is IBreakStatement
    | _ is IContinueStatement
    | _ is IMemoryCopyStatement
    | _ is IMemoryInitializeStatement
    | _ is ILabeledStatement              => true;
    | _                                   => throw NotSupportedException($"Invalid statement type '$(value.GetType().Name)'.");
    }

    private _voidTypeCache : Hashtable[IAssemblyReference, ITypeReference];

    private WriteVoidRef(asmRef : IAssemblyReference) : void
    {
      def voidTypeRef = _voidTypeCache.GetValue(asmRef, fun()
        {
          mutable voidTypeRef = null;

          def asm = asmRef.Resolve();
          unless (asm == null)
          {
            mutable asmMsCorLibRef = null;
            for (mutable i = 0; asmMsCorLibRef == null && i < asm.Modules.Count; ++i)
              asmMsCorLibRef = asm.Modules[0].AssemblyReferences.Find(a : IAssemblyReference => a.Name == "mscorlib");

            unless (asmMsCorLibRef == null)
            {
              def asmMsCorLib = asmMsCorLibRef.Resolve();
              unless (asmMsCorLib == null)
              {
                for (mutable i = 0; voidTypeRef == null && i < asmMsCorLib.Modules.Count; ++i)
                  voidTypeRef = asmMsCorLib.Modules[i].Types.Find(t : ITypeDeclaration => t.Namespace == "System" && t.Name == "Void");
              }
            }
          }
          voidTypeRef;
        });

      if (voidTypeRef != null)
        WriteType(voidTypeRef);
      else
        Write("void");
    }

    #endregion

    #region Keywords

    protected override EscapeKeyword(value : string) : string
    {
      "@" + value;
    }

    protected override GetKeywords() : Set[string]
    {
      Set(
      [ "abort",     "abstract", "and",        "array",   "as",        "assert"
      , "base"
      , "catch",     "class"
      , "def",       "delegate", "do"
      , "else",      "enum",     "event",      "extends", "extern"
      , "false",     "finally",  "for",        "foreach", "fun"
      , "if",        "ignore",   "implements", "in",      "interface", "internal", "is"
      , "lock"
      , "macro",     "match",    "matches",    "module",  "mutable"
      , "namespace", "new",      "null"
      , "out",       "override"
      , "params",    "partial",  "private",  "protected",  "public"
      , "ref"
      , "sealed",    "static",   "struct",     "syntax"
      , "this",      "throw",    "true",       "try",     "type",      "typeof"
      , "unless",    "using"
      , "variant",   "virtual",  "volatile"
      , "when",      "where",    "while",      "with"
      ]);
    }

    protected override GetTypes() : Map[string, string]
    {
      Map()
        .Add("System.Boolean", "bool")
        .Add("System.Byte",    "byte")
        .Add("System.Char",    "char")
        .Add("System.Decimal", "decimal")
        .Add("System.Double",  "double")
        .Add("System.Int16",   "short")
        .Add("System.Int32",   "int")
        .Add("System.Int64",   "long")
        .Add("System.Object",  "object")
        .Add("System.SByte",   "sbyte")
        .Add("System.Single",  "float")
        .Add("System.String",  "string")
        .Add("System.UInt16",  "ushort")
        .Add("System.UInt32",  "uint")
        .Add("System.UInt64",  "ulong")
        .Add("System.Void",    "void")
        ;
      }

    // Copy'n'pasted from MethodBuilder.OperatorLongName.
    // See ncc\hierarchy\ClassMembers.n
    //
    // Note that some operators like op_True, op_PointerDereference,
    // op_UnsignedRightShiftAssignment and some other are not supported
    // in Nemerle and are passed as is.
    //
    // See ECMA TC39/TG3 part I, chapter 9,
    // "Name and Type Rules for the Common Language Specification"
    // for complete list of operator names.
    //
    protected override GetSpecialMethods() : Map[string, string]
    {
      Map()
        .Add("op_Addition",                 "+")
        .Add("op_AdditionAssignment",       "+=")
        .Add("op_Assign",                   "=")
        .Add("op_BitwiseAnd",               "&")
        .Add("op_BitwiseAndAssignment",     "&=")
        .Add("op_BitwiseOr",                "|")
        .Add("op_BitwiseOrAssignment",      "|=")
        .Add("op_Comma",                    ",")
        .Add("op_Decrement",                "--")
        .Add("op_Division",                 "/")
        .Add("op_DivisionAssignment",       "/=")
        .Add("op_Equality",                 "==")
        .Add("op_ExclusiveOr",               "^")
        .Add("op_ExclusiveOrAssignment",    "^=")
        .Add("op_Explicit",                 ":>")
        .Add("op_GreaterThan",              ">")
        .Add("op_GreaterThanOrEqual",       ">=")
        .Add("op_Implicit",                 ":")
        .Add("op_Increment",                "++")
        .Add("op_Inequality",               "!=")
        .Add("op_LeftShift",                "<<")
        .Add("op_LeftShiftAssignment",      "<<=")
        .Add("op_LessThan",                 "<")
        .Add("op_LessThanOrEqual",          "<=")
        .Add("op_LogicalAnd",               "&&")
        .Add("op_LogicalNot",               "!")
        .Add("op_LogicalOr",                "||")
        .Add("op_Modulus",                  "%")
        .Add("op_ModulusAssignment",        "%=")
        .Add("op_MultiplicationAssignment", "*=")
        .Add("op_Multiply",                 "*")
        .Add("op_OnesComplement",           "~")
        .Add("op_RightShift",               ">>")
        .Add("op_Subtraction",              "-")
        .Add("op_SubtractionAssignment",    "-=")
        .Add("op_UnaryNegation",            "-")
        .Add("op_UnaryPlus",                "+")
    }

    #endregion

  }
}
