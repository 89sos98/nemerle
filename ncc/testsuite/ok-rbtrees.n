
open Nemerle.Collections.New;

public class IntCmp implements IComparableTo(IntCmp)
		{
			public val:int;

			public this(val:int){
				this.val<-val;
			}
	
			public Compare(x: IntCmp):int implements IComparableTo.Compare
			{
				this.val-x.val
			}
		}

public module RBTester
{

	public Main():void {

	def op_count=1000;
	def key_range=50;
	def rand = System.Random();
	def op_range = 3;
	def check_array=(System.Array.CreateInstance(typeof(System.Boolean),key_range) :> array(bool));
	
	mutable i<-key_range-1;
	while(i>=0){
		check_array[i]<-false;
		i<-i-1
	};

	def PrintNode(tree:Tree.Node(IntCmp)):void {
		match (tree){
		| Tree.Leaf => print_endline(" ")
		| Tree.Tr(key,Tree.Red,ltree,rtree) => 
			print_string(" Red:"+string_of_int(key.val));
			PrintNode(ltree);
			PrintNode(rtree)
		| Tree.Tr(key,Tree.Black,ltree,rtree) => 
			print_string(" Black:"+string_of_int(key.val));
			PrintNode(ltree);
			PrintNode(rtree)
		}
		};
	def PrintList(op_list:list(string)):void{
		match (op_list){
		| Nil => ()
		| h::tl => print_string(h+"|");
			PrintList(tl)
		}
	};
		
	def TestRB(tree: Tree.Node(IntCmp)):bool 
	{
		def _testrb(tree: Tree.Node(IntCmp),red:bool):int{
			match ((tree,red)){
			| (Tree.Tr(_,Tree.Red,_,_),true) =>
					print_endline("Red conflict");
					raise BalanceViolation()
			| (Tree.Tr(_,Tree.Red,ltree,rtree),false)=>
					match ((ltree,rtree)){
					|(Tree.Leaf,Tree.Leaf) => 
						0
					|(Tree.Leaf,_) =>
						_testrb(rtree,true)
					|(_,Tree.Leaf) =>
						_testrb(ltree,true)
					| _ => def count=_testrb(ltree,true);
						when (count!=_testrb(rtree,true)){
							print_endline("No black balance");
							raise BalanceViolation()	
						};
						count		
					}
			| (Tree.Tr(_,Tree.Black,ltree,rtree),_)=>
					match ((ltree,rtree)){
					|(Tree.Leaf,Tree.Leaf) => 
						0
					|(Tree.Leaf,_) =>
						_testrb(rtree,false)
					|(_,Tree.Leaf) =>
						_testrb(ltree,false)
					| _ => def count=_testrb(ltree,false);
						when (count!=_testrb(rtree,false)){
							print_endline("No black balance");
							raise BalanceViolation()	
						};
						count+1		
					}
			| _ => raise BalanceViolation()
			}
		};
	try {
		match (tree){
		| Tree.Leaf => true
		| _ => def _=_testrb(tree,false);
			true
		}
		} with { _:BalanceViolation => false}
	};
	def IterOpps (tree: Tree.Node(IntCmp),op_list: list(string),counter:int):void
	{
		
	 unless (TestRB(tree)){
		PrintList(op_list);
		raise BalanceViolation()
		};
	 if (counter>=0)
	 	match (rand.Next(op_range)){
		| 0 => def i=rand.Next(key_range);
			 check_array[i]<-true;
			 IterOpps(Tree.Insert(tree,IntCmp(i),false),("I("+string_of_int(i)+")")::op_list,counter-1)
		| 1 => def i=rand.Next(key_range);
			 check_array[i]<-false;
			 IterOpps(Tree.Delete(tree,IntCmp(i)),("D("+string_of_int(i)+")")::op_list,counter-1)
		| 2 => def i=rand.Next(key_range);
			 match (Tree.Get(tree,IntCmp(i))){
			 | Some (key) => 
				if (key.val==i&&check_array[i])
					IterOpps(tree,("G("+string_of_int(i)+")")::op_list,counter-1)
				else {
				print_endline("Wrong Get is "+string_of_int(i)+" "+string_of_int(key.val));
				PrintList(op_list);
				print_endline("tree:");
				PrintNode(tree);
				raise BalanceViolation()
				}
			| None =>
				if (!check_array[i])
					IterOpps(tree,("G("+string_of_int(i)+")")::op_list,counter-1)
				else {
				print_endline("Wrong Get not"+string_of_int(i));
				PrintList(op_list);
				print_endline("tree:");
				PrintNode(tree);
				raise BalanceViolation()
				}	
			}	
		| _ => ()
		}
	 else
		()
	};
	try 
	IterOpps(Tree.Leaf(),Nil(),op_count)
	with { _:BalanceViolation => print_endline("\nError occurred")
	}
	}
} 

(*
BEGIN-INPUT
END-INPUT
*)
