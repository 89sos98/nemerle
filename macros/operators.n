/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Macros;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

module Operators {
  char_tc : Tycon;
  bool_tc : Tycon;
  enum_tc : Tycon;
  int_tc : Tycon;
  string_tc : Tycon;

  variant ArithmeticTypeKind
  {
    | ATK_signed
    | ATK_unsigned
    | ATK_float
  }

  class ArithmeticTypeDecriptor
  {
    public tycon : Tycon;
    public kind : ArithmeticTypeKind;
  }

  arithmetic_types : list <ArithmeticTypeDecriptor>;

  op_name (name : string, td : ArithmeticTypeDecriptor) : string
  {
    match (td.kind) {
      | ATK_unsigned => name + ".u"
      | ATK_signed => name + ".s"
      | ATK_float => name + ".f"
    }
  }
  
  this () {
    int_tc <- GlobalEnv.LookupInternalType ("System.Int32");
    char_tc <- GlobalEnv.LookupInternalType ("System.Char");
    bool_tc <- GlobalEnv.LookupInternalType ("System.Boolean");
    enum_tc <- GlobalEnv.LookupInternalType ("System.Enum");
    string_tc <- GlobalEnv.LookupInternalType ("System.String");

    def f (name, kind) { 
      def t = GlobalEnv.LookupInternalType ("System." + name);
      ArithmeticTypeDecriptor (t, kind)
    };

    arithmetic_types <- [
      f ("Int32", ATK_signed ()),
      f ("Byte", ATK_unsigned ()),
      f ("Single", ATK_float ()),
      f ("Double", ATK_float ()),
      f ("Int64", ATK_signed ()),
      f ("Int16", ATK_signed ()),
      f ("SByte", ATK_signed ()),
      f ("UInt32", ATK_unsigned ()),
      f ("UInt64", ATK_unsigned ()),
      f ("UInt16", ATK_unsigned ())
    ];
  }

  lookup_overloaded_operator (name : string, parms : list <Expr>)
  : option <PT.Expr>
  {
    def collect (parm, acc) {
      match (Tyutil.top_expand (Tyexpr.type_of (parm))) {
        | T_app (tc, _) =>
          def is_op (m : IMember) {
            match (m.GetKind ()) {
              | MK_method => m.IsStatic ()
              | _ => false
            }
          };
          def loop (tc : Tycon) {
            // fscking special case, why there is no System.String.op_Addition ?
            def name =
              if (name == "op_Addition" && tc.GetFullName () == "System.String")
                "Concat"
              else 
                name;
            match (List.Filter (tc.LookupMember (name), is_op)) {
              | [] =>
                match (tc.SuperClass ()) {
                  | Some (tc') => loop (tc')
                  | None => acc
                }
              | lst => List.Append (lst, acc)
            }
          };
          loop (tc)
        | _ => acc
      }
    };
    def collapse (mem : IMember, acc) {
      def tyname = mem.GetDeclaringTycon ().GetFullName ();
      match (acc) {
        | Some (tn) when tn == tyname => acc
        | Some (tn) =>
          Message.error (sprintf ("ambiguity resolution between `%s' from types `%s' and `%s'", 
                                  name, tn, tyname));
          acc
        | None => Some (tyname)
      }
    };
    match (List.FoldLeft (List.FoldLeft (parms, [], collect), None (), collapse)) {
      | Some ("System.String") when name == "op_Addition" =>
        match (parms) {
          | [e1, e2] =>
            Tyexpr.expect_type ("left-hand side of the `+' operator", 
                                e1, T_app (string_tc, []));
            Tyexpr.expect_type ("right-hand side of the `+' operator",
                                e2, T_app (string_tc, []));
            Some (<[ System.String.Concat ($(e1 : typed), $(e2 : typed)) ]>)
          | _ => assert (false)
        }
      | Some (tn) =>
        def parms = List.Map (parms, fun (e) { 
          PT.Parm (false, <[ $(e : typed) ]>, PT.SS_string (PT.Name (""))) 
        });
        Some (<[ $(tn : dyn) . $(name : dyn) (.. $parms ) ]>)
      | None => None ()
    }
  }

  try_emit_binary (name : string, arg_tc : Tycon, ret_tc : Tycon, e1 : Expr, 
                   e2 : Expr) : option <PT.Expr>
  {
    def type_of (e) { Tyutil.top_expand (Tyexpr.type_of (e)) };
    
    match ((type_of (e1), type_of (e2))) {
      | (T_app (tc, _), _) when arg_tc.SameAs (tc) 
      | (_, T_app (tc, _)) when arg_tc.SameAs (tc) =>
        def ret_type = T_app (ret_tc, []);
        def arg_type = T_app (arg_tc, []);
        def op_type = T_fun (T_prod ([arg_type, arg_type]), ret_type);
        
        Tyexpr.expect_type (sprintf ("left-hand side of the `%s' operator", name),
                            e1, arg_type);
        Tyexpr.expect_type (sprintf ("right-hand side of the `%s' operator", name),
                            e2, arg_type);
        
        Some (<[ $(E_call (e1.loc, ret_type, E_opcode (e1.loc, op_type, name), 
                       [Parm (false, e1, ""), Parm (false, e2, "")]) : typed) ]>)
      | _ => None ()
    }
  }

  type_of (e : Expr) : Type
  {
    Tyutil.top_expand (Tyexpr.type_of (e))
  }

  internal lookup_binary_compare_operator (ctx : TypingContext, 
                                           name : string, long_name : string, 
                                           e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def emit (lst) {
      | td :: xs =>
        match (try_emit_binary (op_name (name, td), td.tycon, bool_tc, e1, e2)) {
          | Some (ret) => ret
          | None => emit (xs)
        }
      | [] =>
        match (try_emit_binary (name + ".u", char_tc, bool_tc, e1, e2)) {
          | Some (ret) => ret
          | None =>
            match (lookup_overloaded_operator (long_name, [e1, e2])) {
              | Some (expr) => expr
              | None =>
                Message.fatal_error (sprintf ("no match for binary operator `%s' taking %s and %s arguments",
                                              name, type_of (e1).as_string (), type_of (e2).as_string ()));
            }
        }
    };

    emit (arithmetic_types);
  }

  internal lookup_binary_arithmetic_operator (_N_ctx : TypingContext, 
                                              name : string, long_name : string, 
                                              e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (_N_ctx, e1);
    def e2 = Tyexpr.ty_expr (_N_ctx, e2);

    def try_arith (lst) {
      | td :: xs =>
        match (try_emit_binary (op_name (name, td), td.tycon, td.tycon, e1, e2)) {
          | Some (ret) => ret
          | None => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error (sprintf (
               "no match for binary operator `%s' taking %s and %s arguments",
               name, type_of (e1).as_string (), type_of (e2).as_string ()));
        }
    };

    match ((e1, e2)) {
      | (E_literal (L_int (x1)), E_literal (L_int (x2))) =>
        def int_type = <[ ttype : int ]>;
        def val = 
          match (name) {
            | "+" => x1 + x2
            | "-" => x1 - x2
            | "/" => x1 / x2
            | "%" => x1 % x2
            | "*" => x1 * x2
            | _ => Message.fatal_error ("Unknown operator " + name)
          };
        <[ $(E_literal (loc, int_type, L_int (val)) : typed) ]>
      | _ =>
        try_arith (arithmetic_types)
    }
  }

  internal lookup_unary_arithmetic_operator (_N_ctx : TypingContext, 
                                             name : string, long_name : string, 
                                             e1 : PT.Expr) : PT.Expr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (_N_ctx, e1);

    def try_arith (lst : list <ArithmeticTypeDecriptor>) {
      | { kind = ATK_unsigned } :: xs when name == "-" => try_arith (xs)
      | td :: xs =>
        def et = type_of (e1);
        match (et) {
          | T_app (tc', _) when td.tycon.SameAs (tc') =>
            def op_type = <[ ttype: $et -> $et ]>;
            <[ $(E_call (loc, et, E_opcode (loc, op_type, "unary." + op_name (name, td)), 
                         [Parm (false, e1, "")]) : typed) ]>
          | _ => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error (sprintf ("no match for binary operator `%s' taking %s argument",
                                          name, type_of (e1).as_string ()));
        }
    };
      
    match (e1) {
      | E_literal (L_int (x)) =>
        def int_type = <[ ttype: int ]>;
        def val = 
          if (name == "-") -x
          else x;
        <[ $(E_literal (loc, int_type, L_int (val)) : typed) ]>
      | _ => try_arith (arithmetic_types)
    }
  }

  internal lookup_enum_operator (ctx : TypingContext, 
                                 name : string, long_name : string, 
                                 e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    // FIXME: check for FlagsAttribute
    def is_enum (t) {
      match (t) {
        | T_app (tc, _) =>
          Option.IsSome (tc.SuperType (enum_tc))
        | _ => false
      }
    };

    def t1 = type_of (e1);
    def t2 = type_of (e2);

    def try_arith (lst : list <ArithmeticTypeDecriptor>) {
      | { kind = ATK_float } :: xs => try_arith (xs)
      | td :: xs =>
        match (try_emit_binary (op_name (name, td), td.tycon, td.tycon, e1, e2)) {
          | Some (ret) => ret
          | None => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (ret) => ret
          | None =>
            Message.fatal_error (sprintf (
               "no match for binary operator `%s' taking %s and %s arguments",
               name, t1.as_string (), t2.as_string ()));
        }
    };

    if (is_enum (t1) || is_enum (t2)) {
      match (Tyutil.unify (t1, t2)) {
        | Some (subst) =>
          Tyvar.global_store (subst);
          def tc =
            match (Tyutil.top_expand (t1)) {
              | T_app (tc, _) => tc
              | _ => Util.ice ()
            };
          Option.UnSome (try_emit_binary (name + ".u", tc, tc, e1, e2))
        | None =>
          Message.fatal_error (sprintf (
             "the enum types %s and %s (on sides of `%s' operator) are not compatible",
             t1.as_string (), t2.as_string (), name));
      }
    } else
      try_arith (arithmetic_types)
  }
  

  // == or !=
  internal lookup_equality_operator (_N_ctx : TypingContext, 
                                     name : string, long_name : string, 
                                     e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (_N_ctx, e1);
    def e2 = Tyexpr.ty_expr (_N_ctx, e2);

    match (lookup_overloaded_operator (long_name, [e1, e2])) {
      | Some (expr) => expr
      | None =>
        def t1 = type_of (e1);
        def t2 = type_of (e2);
        match (Tyutil.unify (t1, t2)) {
          | Some (subst) =>
            def ret_type = <[ ttype: bool ]>;
            def op_type = <[ ttype: $t1 * $t2 -> bool ]>;
            
            Tyvar.global_store (subst);
            // FIXME: check if value types, some bigger values types
            // FIXME: if references and not system.object -- emit warning
            <[ $(E_call (e1.loc, ret_type, E_opcode (e1.loc, op_type, name), 
                         [Parm (false, e1, ""), Parm (false, e2, "")]) : typed) ]>
          | None =>
            Message.fatal_error (sprintf (
               "the types %s and %s (on sides of `%s' operator) are not compatible",
               t1.as_string (), t2.as_string (), name));
        }
    }
  }

  internal cache_assign_expr (ctx : TypingContext, e : PT.Expr) : PT.Expr * PT.Expr {
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        def tmp = Macros.NewSymbol ();
        (<[ def $(tmp : var) = $obj ]>, <[ $(tmp : var).$mem ]>)
      | <[ $tab [$idx] ]> =>
        def (tmp1, tmp2) = (Macros.NewSymbol (), Macros.NewSymbol ());
        (<[ def ($(tmp1 : var), $(tmp2 : var)) = ($tab, $idx) ]>,
         <[ $(tmp1 : var) [$(tmp2 : var)] ]>)
      | _ => (<[ () ]>, e)
    }
  }
}

  macro @&& (e1, e2) 
  {
    <[ 
      match ($e1) {
        | false => false
        | _ => 
          match ($e2) { 
            | false => false
            | _ => true
          }
      }
    ]>
  }

  macro @|| (e1, e2) 
  {
    <[ 
      match ($e1) {
        | true => true
        | _ => 
          match ($e2) { 
            | true => true
            | _ => false
          }
      }
    ]>
  }

  macro @! (e)
  {
    def tval = Tyexpr.ty_expr (ImplicitCTX (), e);
    def bool_ty = <[ ttype: bool ]>;
    def op_ty = <[ ttype: bool -> bool ]>;
    Tyexpr.expect_type ("negated value", tval, bool_ty);
    <[ $(E_call (e.loc, bool_ty, E_opcode (e.loc, op_ty, "bool.!"), 
                 [Parm (false, tval, "")]) : typed) ]>
  }

  macro @- (params args : array <expr>)
  {
    match (args.Length) {
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (ImplicitCTX (), "-",
                                                    "op_UnaryMinus", args[0])

      | 2 =>
        Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "-",
                                                     "op_Subtraction", args[0], args[1])
      | _ => 
        Message.fatal_error ("the `-' operator can only take one or two parameters")
    }
  }

  macro @+ (params parms : array <expr>) 
  {
    match (parms.Length) {
      | 2 =>
        Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "+", "op_Addition",
                                                     parms[0], parms[1])
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (ImplicitCTX (), "+",
                                                    "op_UnaryPlus", parms[0])
      | _ =>
        Message.fatal_error ("the `+' operator can only take one or two parameters")
    }
  }

  macro @* (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "*",
                                                 "op_Multiply", e1, e2)
  }

  macro @/ (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "/",
                                                 "op_Division", e1, e2)
  }

  macro @% (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "%",
                                                 "op_Modulus", e1, e2)
  }
  
  macro @< (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), "<",
                                              "op_LessThan", e1, e2)
  }
  
  macro @> (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), ">",
                                              "op_GreaterThan", e1, e2)
  }
  
  macro @<= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), "<=",
                                              "op_LessThanOrEqual", e1, e2)
  }
  
  macro @>= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), ">=",
                                              "op_GreaterThanOrEqual", e1, e2)
  }
  
  macro @%| (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "|", "op_BitwiseOr", e1, e2)
  }
  
  macro @%& (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "&", "op_BitwiseAnd", e1, e2)
  }
  
  macro @%^ (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "^", "op_ExclusiveOr", e1, e2)
  }
  
  macro @== (e1, e2)
  {
    Operators.lookup_equality_operator (ImplicitCTX (), "==", "op_Equality", e1, e2)
  }
  
  macro @!= (e1, e2)
  {
    Operators.lookup_equality_operator (ImplicitCTX (), "!=", "op_Inequality", e1, e2)
  }

 
  macro @++ (e) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe <- $safe + 1 ]>
  }

  macro @-- (e) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe <- $safe - 1 ]>
  }
  
  macro @<-> (e1, e2)
  {
    def (cached1, safe1) = Operators.cache_assign_expr (ImplicitCTX (), e1);
    def (cached2, safe2) = Operators.cache_assign_expr (ImplicitCTX (), e2);    
    <[
      $cached1;
      $cached2;
      def tmp = $safe1;
      $safe1 <- $safe2;
      $safe2 <- tmp;
    ]>
  }
}
