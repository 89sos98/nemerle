/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

namespace Nemerle.Compiler
{
  internal module Delegates
  {
    /**
     * Generates a delegate class
     */
    internal GenerateDelegateClass (globenv : GlobalEnv, parent_type : option <TypeBuilder>,
                                    attrs : Modifiers, header : Fun_header) : void
    {
      Util.locate (header.loc, {
        def delegate_name = Macros.NameOfSString (header.name);

        when ((attrs.mods %& ~NemerleAttributes.AccessModifiers) != NemerleAttributes.None)
          Message.error (header.loc, "delegates are only allowed to have access specifiers as attributes");
        
        attrs.mods |= NemerleAttributes.Sealed;

        // add the delegate class as a nested type in the delegate's parent type or in global env
        def pt_decl = <[ decl:
          ..$(attrs) class $(delegate_name : name) : System.MulticastDelegate { }
        ]>;
        mutable parent_builder = null;
        def td = 
          match (parent_type) {
            | Some (parent) =>
              parent_builder = parent;
              parent.DefineNestedType (pt_decl);
             
            | None =>
              globenv.Define (pt_decl)
          };

        // collect the Invoke and BeginInvoke parameters
        def invoke_parms =
          List.Map (header.parms, fun (fp : Fun_parm) {
            <[ funparm: $(fp.name) : $(fp.ty) ]>
          });

        def begin_invoke_parms =
          List.Append (invoke_parms, [<[ funparm: _ : System.AsyncCallback ]>,
                                      <[ funparm: _ : object ]>]);

        // build the delegate's return type and method body for the type inference engine
        def ret_type = Tyvar.TEnv ().bind (globenv, parent_builder, header.ret_type, check_parms = false);
        def invoke_body = Macros.DefaultValueOfType (ret_type);
      
        // build the delegate methods
        td.Define (<[ decl:
          public virtual BeginInvoke (..$begin_invoke_parms) : System.IAsyncResult { null }
        ]>);

        td.Define (<[ decl:
          public virtual EndInvoke (_ : System.IAsyncResult) : $(ret_type : typed) $(invoke_body)
        ]>);
      
        td.Define (<[ decl:
          public virtual Invoke (..$invoke_parms) : $(ret_type : typed) $(invoke_body)
        ]>);

        def fun_from =
          match (header.parms) {
            | [] => <[ type: void ]>;
            | [p] => p.ty
            | lst =>
              def parm_types = List.Map (lst, fun (p : Fun_parm) { p.ty });
              <[ type: (.. $parm_types ) ]>
          };
          
        // this won't be emitted but is needed by our type system
        td.Define (<[ decl:
          public this (_ : $fun_from -> $(ret_type : typed))
          {
          }
        ]>);

        // and this one is made public later
        td.Define (<[ decl:
          private this (_ : object, _ : System.IntPtr)
          {
            base (typeof (System.Object), "")
          }
        ]>);

        td.MarkWithSpecialName ();
        
        td.Compile ()
      })
    }
  }
}
