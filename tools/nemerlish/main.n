using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility.NString;
using SC = System.Console;
using System.IO;
using System.Text;
using System.Text.RegularExpressions.Regex;
using Interp = Nemerle.Evaluation.Interpreter.Internals;
  
namespace Nemerle.Evaluation.Interpreter
{  
  module MainClass
  {
    Main () : void {
      def histfile = "hist.txt";

      def print_welcome () : void {
        SC.WriteLine ("Welcome to Nemerle interpreter.\n");
        SC.WriteLine ("Please enter expressions appended with \";;\".");
        SC.WriteLine ("To add open namespaces, reference libraries or set "
                      "various preferences, use");
        SC.WriteLine ("properties from the Interp namespace. Their list is "
                      "available via \"Interp.Help;;\"\n");
      }
     
      print_welcome ();
  
      def e = Nemerle.Evaluation.Evaluator ();
#if READLINE
      def rl = Mono.ReadLine.GnuReadLine ();
      Iter (Rev (HistoryFile.ReadHistory (100, histfile)), 
           fun (l) { rl.AddHistory (l) });
#endif
      def readinput (code : string) : void {
#if READLINE
        def line = rl.ReadLine (Interp.Prompt);
#else
        SC.Write (Interp.Prompt);
        def line = SC.ReadLine ();
#endif
        match (line) {
          | null => ()
          | _ => 
#if READLINE
            rl.AddHistory (line);
            HistoryFile.AddHistory (histfile, line);
#endif
            regexp match (line) {
              | @"^\s*$" => readinput (code)
              | _ =>  { 
                def l = line.TrimEnd ();
                if (l.EndsWith (";;")) {
                  try { 
                    def m = code + l.TrimEnd (array [';',' ','\t']);
                    def c = regexp match (m) {
                      | @"(?<b>.*([;}]\s*|^\s*))using\s+(?<u>[a-zA-Z0-9]+((\.[a-zA-Z0-9]+)*(\s*=\s*[a-zA-Z0-9]+)*)*)[\s;]*(?<e>.*)$" => 
                        if (Interp.Using != "") {
                          Interp.Using = u + ", " + Interp.Using;
                        }
                        else {
                          Interp.Using = u;
                        }
                        def r = b + e;
                        if (r == "")
                          "()"
                        else
                          r
                      | _ => m
                    }
                    def (nmnvts) = e.Eval (Interp.RefParsed, 
                                           Interp.UsingParsed, c);
                    Iter (nmnvts, fun (x) {
                      def (newvar, mut, name, val, ty) = x;
                      when (newvar) 
                        match ((mut, val, ty)) {
                          | (false, null, _) =>
                            SC.WriteLine ($"def $name : $ty")
                          | (_, null, _) =>
                            SC.WriteLine ($"mutable $name : $ty")
                          | (_, _, <[ $_ -> $_ ]>) =>
                            SC.WriteLine ($"def $name : $ty")
                          | (false, _, _) => 
                            SC.WriteLine ($"def $name = $val : $ty")
                          | _ => 
                            SC.WriteLine ($"mutable $name = $val : $ty")
                      }
                    })
                  } 
                  catch {
                    | e is System.Exception =>
                      unless (Nemerle.Compiler.Message.SeenError) {
                        SC.WriteLine (e.Message + e.StackTrace);
                        SC.WriteLine (e.ToString ())
                      }
                  } 
                  Interp.Prompt = Interp.PS1;
                  readinput ("") 
                }
                else { 
                  Interp.Prompt = Interp.PS2;
                  readinput (code + line + " ") 
                }
              }
            }
        }
      }
  
      //FIXME: this is a temporary workaround, to be removed later
      Interp.Ref = "";
      Interp.Using = "";
  
      readinput ("")
    }
  }

  module HistoryFile {
    public AddHistory (filename: string, line : string) : void {
      def sw = File.AppendText (filename);
      sw.WriteLine (line);
      sw.Close ();
    }

    public ReadHistory (ln : int, filename : string) : list [string] {
      def sr = File.OpenText (filename);
      def loop (i, acc) {
        def l = sr.ReadLine ();
        if (l != null && i < ln)
          if (acc.Equals ([]) || l != Hd (acc))
            loop (i + 1, l :: acc)
          else
            loop (i + 1, acc)
        else 
          acc
      }

      def res = loop (0, []);
      sr.Close ();
     
      res
    }
  }
} 
