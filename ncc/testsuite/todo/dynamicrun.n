
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

class M {
  class StagedMacro : IMacro {
    public Run (_ctx : TypingContext, val : list [SyntaxElement]) : PExpr {
      match (val) {
        | [SyntaxElement.Expression (expr)] =>
          def locals = _ctx.GetLocals ();
          def values = locals.Fold (fun (n : Name, loc : LocalValue, acc) {
            <[ ($(loc.name : string), $(loc.ty.ToString () : string),
                $(n : name) : object) :: $acc
            ]>
          }, <[ [] ]>);
          <[ ($expr : object, $values) ]>

        | _ => Util.ice ()
      }
    }

    // not interesting macro stuff (will disappear)
    public CallTransform (l : list [PExpr]) : list [SyntaxElement]
    { List.Map (l, SyntaxElement.Expression); }
    public SyntaxExtension () : string * list [Parser.GrammarElement] * list [int]
    { ("", [], []) }
    public IsTailRecursionTransparent : bool { get { false } }
    public GetName () : string { "stagedmacro" }
    public GetNamespace () : string { "" }
    // not interesting macro stuff
  }

  // analyze given expression and return the new one with
  // our macro's call at the end
  static inject (body : PExpr) : PExpr {
    match (body) {
      | <[ {..$seq } ]> =>
        def (beg, last) = List.DivideLast (seq);
        def last = 
          match (last) {
            // if the last expression in sequence is definition,
            // it must be before our macro and also return value is void then
            | <[ def $_ = $_ ]> | <[ mutable $_ = $_ ]> =>
              <[ $last; stagedmacro (()) ]>
            // pass last expression (return value) to our macro
            | _ => <[ stagedmacro ($last) ]>
          }
        // return enchanced sequence, with our macro as the last expression
        <[ {..$ (beg + [last]) } ]>
      | _ => <[ stagedmacro ($body) ]>
    }
  }
  
  static DoTheStuff (_ : list [Parsetree.TopDeclaration]) : void {
    MacroRegistry.register_macro (StagedMacro ());
    
    def tb = GlobalEnv.DefineExact (<[ decl: public class A { } ]>);

    def body = <[
      def x = 5;
      def _y = "bla";
      def f = fun (x) { x };
      def u = [];
      x
    ]>;
    // def body = Parser.ParseExpr ("{ def x = 5; x; }");    
    def whole = inject (body);
    // PrettyPrint.PrintExpr (None (), whole);
    
    tb.Define (<[ decl:
                 public static Run (_ : object) : object * list [string * string * object]
                 { $whole }
               ]>);
    tb.Compile ();
  }
  
  static Main () : void {
    Message.InitOutput (System.Console.Out);         

    Options.Sources = [""];
    Options.CompileToMemory = true;
    Options.ProgressBar = false;
    
    Passes.LexingPipeline = fun (_) { null };
    Passes.ParsingPipeline = fun (_) { [] };
    Passes.ScanningPipeline = DoTheStuff;
    Passes.Run ();
    
    def ass = Passes.GeneratedAssembly;
    def meth = ass.GetTypes()[0].GetMethod("Run");
    def res = meth.Invoke (null, array ["bla" : object]);
    System.Console.WriteLine (res);
  }
}
