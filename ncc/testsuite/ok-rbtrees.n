
 using Nemerle.Collections.New;

  public class IntCmp implements IComparable (IntCmp)
  {
    public val : int;

    public this (val : int)
    {
      this.val <- val
    }

    public CompareTo (x : IntCmp) : int implements IComparable.CompareTo
    {
      this.val-x.val
    }
  }

  public module RBTester
  {

    public Main () : void 
    {
      def op_count = 1000;
      def key_range = 50;
      def rand = System.Random ();
      def op_range = 5;
      def check_array = (System.Array.CreateInstance (typeof (System.Boolean), key_range) :> array (bool));
  
      mutable i <- key_range - 1;
      while (i >= 0) 
      {
        check_array[i] <- false;
        i <- i-1
      };
      
      def BoolFunc1 (elem : IntCmp ) : bool
          {
            (elem.CompareTo (IntCmp (25)) >= 0)
          };
      def BoolFunc2 (elem : IntCmp ) : bool
          {
            (elem.CompareTo (IntCmp (45)) >= 0)
          };
      def ArrayForAll (func : IntCmp -> bool) : bool 
          {
            mutable i <- 0;
            mutable bl <- true;
            
            while (i < key_range) 
            {
              unless (!check_array [i] || func (IntCmp (i))) {
                i <- key_range;
                bl <- false 
              };
              i <- i + 1
            };
            bl
          };
      def ArrayExists (func : IntCmp -> bool) : bool 
          {
            mutable i <- 0;
            mutable bl <- false;
            
            while (i < key_range) 
            {
              when (check_array [i] && func (IntCmp (i))) {
                i <- key_range;
                bl <- true
              };
              i <- i + 1
            };
            bl
          };
      def PrintNode (tree : Tree.Node (IntCmp)) : void 
          {
            match (tree) {
              | Tree.Leaf => print_endline (" ")
              | Tree.Tr (key, false, ltree, rtree) => 
                  print_string (" Red : "+string_of_int (key.val));
                  PrintNode (ltree);
                  PrintNode (rtree)
              | Tree.Tr (key, true, ltree, rtree) => 
                  print_string (" Black : "+string_of_int (key.val));
                  PrintNode (ltree);
                  PrintNode (rtree)
            }
          };
      def PrintList (op_list : list (string)) : void
          {
            match (op_list) {
              | Nil => ()
              | h :: tl => print_string (h+"|");
                  PrintList (tl)
            }
          }; 
      def TestRB (tree : Tree.Node (IntCmp)) : bool 
          {
            def testrb (tree : Tree.Node (IntCmp), red : bool) : int
                {
                  match ( (tree, red)) {
                    | (Tree.Tr (_, false, _, _), true) =>
                        print_endline ("Red conflict");
                        raise BalanceViolation ()
                    | (Tree.Tr (_, false, ltree, rtree), false) =>
                        match ( (ltree, rtree)) {
                          | (Tree.Leaf, Tree.Leaf) => 
                              0
                          | (Tree.Leaf, _) =>
                              testrb (rtree, true)
                          | (_, Tree.Leaf) =>
                              testrb (ltree, true)
                          | _ =>  def count = testrb (ltree, true);
                                  when (count != testrb (rtree, true))
                                  {
                                    print_endline ("No black balance");
                                    raise BalanceViolation ()  
                                  };
                                  count    
                        }
                    | (Tree.Tr (_, true, ltree, rtree), _) =>
                        match ( (ltree, rtree)){
                          | (Tree.Leaf, Tree.Leaf) => 
                              0
                          | (Tree.Leaf, _) =>
                              testrb (rtree, false)
                          | (_, Tree.Leaf) =>
                              testrb (ltree, false)
                          | _ =>  def count = testrb (ltree, false);
                                  when (count != testrb (rtree, false))
                                  {
                                    print_endline ("No black balance");
                                    raise BalanceViolation ()  
                                  };
                                  count+1    
                        }
                    | _ => raise BalanceViolation ()
                  }
                };
            try 
              {
                match (tree){
                  | Tree.Leaf => true
                  | _ => def _= testrb (tree, false);
                     true
                }
              } with 
                { 
                  _ : BalanceViolation => false
                }
          };

      def IterOps (tree : Tree.Node (IntCmp), op_list : list (string), counter : int) : void
          { 
            unless (TestRB (tree))
            {
              PrintList (op_list);
              raise BalanceViolation ()
            };
            when (counter >= 0)
              match (rand.Next (op_range)){
                | 0 => 
                    def i = rand.Next (key_range);
                    check_array[i] <- true;
//                    IterOps (Tree.Insert (tree, IntCmp (i), false), ("I ("+string_of_int (i)+")") :: op_list, counter - 1)
                    IterOps (Tree.Insert (tree, IntCmp (i), false), op_list, counter - 1)  
                | 1 => 
                    def i = rand.Next (key_range);
                    match (Tree.AckDelete (tree, IntCmp(i))) {
                      (treee, bl) =>
                        when (bl != check_array[i]) 
                        {
                          print_endline ("Wrong deletion acknowledge");
                          PrintList (("D ("+string_of_int (i)+")") :: op_list);
                          raise BalanceViolation ()
                        };  
                        check_array[i] <- false;
//                        IterOps (treee, ("D ("+string_of_int (i)+")") :: op_list, counter - 1)
                        IterOps (treee, op_list, counter - 1)
                    }
                | 2 => 
                    def i = rand.Next (key_range);
                    match (Tree.Get (tree, IntCmp (i))){
                      | Some (key) => 
                          if (key.val == i && check_array[i])
                            //IterOps (tree, ("G ("+string_of_int (i)+")") :: op_list, counter - 1)
                            IterOps (tree, op_list, counter-1)
                          else 
                          {
                            print_endline ("Wrong Get is "+string_of_int (i)+" "+string_of_int (key.val));
                            PrintList (op_list);
                            print_endline ("tree : ");
                            PrintNode (tree);
                            raise BalanceViolation ()
                          }
                      | None =>
                          if (!check_array[i])
                            //IterOps (tree, ("G ("+string_of_int (i)+")") :: op_list, counter-1)
                            IterOps (tree, op_list, counter-1)
                          else 
                          {
                            print_endline ("Wrong Get not"+string_of_int (i));
                            PrintList (op_list);
                            print_endline ("tree : ");
                            PrintNode (tree);
                            raise BalanceViolation ()
                          }  
                    }
                | 3 => 
                    def bl = Tree.ForAll (tree, BoolFunc1); 
                    when (ArrayForAll (BoolFunc1) != bl)
                    {
                      if (bl)
                        print_endline ("Wrong ForAll answer (true)")
                      else
                        print_endline ("Wrong ForAll answer (false)");
                      PrintList (op_list);
                      print_endline ("tree : ");
                      PrintNode (tree);
                      raise BalanceViolation ()
                    };
                    IterOps (tree, ("ForAll") :: op_list, counter - 1)
               | 4 => 
                    def bl = Tree.Exists (tree, BoolFunc2); 
                    when (ArrayExists (BoolFunc2) != bl)
                    {
                      if (bl)
                        print_endline ("Wrong Exists answer (true)")
                      else
                        print_endline ("Wrong Exists answer (false)");
                      PrintList (op_list);
                      print_endline ("tree : ");
                      PrintNode (tree);
                      raise BalanceViolation ()
                    };
                    IterOps (tree, ("Exists") :: op_list, counter - 1)
                | _ => ()
              }
        };

      try 
        IterOps (Tree.Leaf (), Nil (), op_count)
      with 
        {
          _ : BalanceViolation => print_endline ("\nError occurred")
        }
    }
  } 

/*
BEGIN-OUTPUT
END-OUTPUT
*/
