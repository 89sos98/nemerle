(* ------------------------------------------------------------------------- *)
(*   Shift-Or exact string matching algorithm                                *)
(*                                                                           *)
(*   See ESMAJ: http://www-igm.univ-mlv.fr/~lecroq/string/node6.html         *)
(* ------------------------------------------------------------------------- *)

(* NOTE: there's a bug in this program but I was too lazy to fix it ;)       *)

open System;
open System.Collections;

class ShiftOr
{
  private mutable _pattern : array (char);
  private mutable _pattern_length : int;
  private mutable _R : BitArray;
  private mutable _S : array (BitArray);
  private mutable _L : BitArray;
  
  private static dump (title : string, mask : BitArray) : void {
    
    printf ("(%s):%d: ", title, mask.Length);
    
    def loop (index : int) : void {
      
      if (index >= 0) {
        print_string (if (mask.Get (index)) "!" else ".");
        loop (index - 1);
      }
      else ()    
    };
    
    loop (mask.Length - 1);
    
    print_endline ("")
  }
 
  private shift_left (mask : BitArray) : void {
  
    def shift (index : int) : void {
    
      if (index >= 0) {
      
        mask.Set (index + 1, mask.Get (index));
        mask.Set (index, false);
      
        shift (index - 1)
      }
      else ()
    };
    
    shift (mask.Length - 2)
  }
  
  private shift_right (mask : BitArray) : void {
  
    def shift (index : int) : void {
    
      if (index < mask.Length) {
      
        mask.Set (index - 1, mask.Get (index));
        mask.Set (index, false);
      
        shift (index + 1)
      }
      else ()
    };
    
    shift (1)
  }
    
  private init_S (index : int) : void
  {
    if (index < 256)
    {
      this._S [index] <- BitArray (this._pattern_length, true);
    
      this.init_S (index + 1)
    }
    else ()    
  }
    
  private build_S (index : int) : void
  {
    if (index < this._pattern_length)
    {
      if ((this._pattern [index] :> int) >= 256)
        raise Invalid_argument ("_pattern")
      else ();
      
      mutable mask <- BitArray (this._pattern_length, true);
      mask.Set (index, false);
      def current_char = (this._pattern [ index ] :> int); 
      def s = this._S [ current_char ];
      this._S [ current_char ] <- s.And (mask);

      mask <- mask.Not ();      
      this._L <- this._L.Or (mask);
                      
      this.build_S (index + 1)
    }
    else ()
  }
    
  public this (pattern : string) 
  {
    this._pattern <- pattern.ToCharArray ();  
    this._pattern_length <- pattern.Length;
    
    this._L <- BitArray (this._pattern_length, false);
        
    this._S <- (Array.CreateInstance (this._L.GetType (), 256) :> array (BitArray));
    
    this.init_S (0);
    this.build_S (0);
    
    this.shift_right (this._L);    

    this._L <- this._L.Not ()
  }
  
  public Search (text : string) : option (int)
  {
    this._R <- BitArray (this._pattern_length, true);

    def text = text.ToCharArray ();
    
    def le (index : int, l : BitArray, r : BitArray) : bool
    {
      if (index > 0) {
      
        if (l.Get (index) == false && r.Get (index) == true)
          true
        else      
          le (index - 1, l, r)
      }
      else false
    };
    
    def loop (index : int) : option (int)
    {    
      if (index < (text : Array).Length) {
              
        this.shift_left (this._R);
        def t = this._S [ (text [ index ] :> int) ];
        this._R <- this._R.Or (t);

        if (le (this._R.Length - 1, this._R, this._L))
          Some (index)
        else
          loop (index + 1)      
      }
      else None ();
    };
      
    loop (0)
  }
  
  public static Main () : void {
 
    def r = ShiftOr ("coca");
    
    match (r.Search ("Trink coca cola!")) {
      | Some (i) => printf ("Found, ending at index %d\n", i + 1)
      | None => printf ("Not found\n")
    }
  }
}

(*
BEGIN-OUTPUT
Found, ending at index 10
END-OUTPUT
*)
