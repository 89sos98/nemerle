/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler 
{
  using Nemerle.Collections;
  using Nemerle.Compiler;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Compiler.Tyops;

  using System.Reflection;

  /**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   */
  public class LibraryReferenceException : System.Exception 
  {
    public this () {}
  }


  /**
   * Manager for the referenced libraries
   */
  public class LibraryReferenceManager
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */
  
    /**
     * Static constructor. Always load the Framework core library.
     */
    public static this () {

      _libraries <- [];
      _lib_path <- [".", GetNemerleDirectory (), GetSystemDirectory ()];
      _loaded_types <- Hashtable (1000);
      _loaded_assemblies_by_name <- Hashtable (20);
      
      LoadCoreLibraries ();
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */
  
    /**
     * Stores the referenced library for later lookup by the namespaces.
     */
    public static AddLibrary (name : string) : void 
    {
      def assembly = LookupAssembly (name);
      if (assembly == null)
        Message.error ("cannot find assembly `" + name + "'")
      else {
        if (_loaded_assemblies_by_name.Contains (assembly.FullName))
          Message.warning ("assembly `" + name + "' already loaded")
        else {
          _libraries <- LibraryReference (assembly) :: _libraries;
          _loaded_assemblies_by_name.Set (assembly.FullName, assembly)
        }
      }
    }
    
    // used also by LibraryReference class below
    internal static mutable _loaded_types : Hashtable <string, option <Tycon>>;
  
    /**
     * Searches for a type name in all referenced external libraries.
     */
    public static LookupType (type_name : string) : option <Tycon>
    {
      def loop (lib : LibraryReference, acc) {
        match ((acc, lib.Lookup (type_name))) {
          | (_, None) => acc
          | (Some, Some) =>
            Message.fatal_error ("type `" + type_name + 
                                 "' is defined in more then one library")
          | (None, (Some) as x) => x
        }
      };
      match (_loaded_types.Get (type_name)) {
        | Some (r) => r
        | None =>
          def res = List.FoldLeft (_libraries, None (), loop);
          _loaded_types.Set (type_name, res);
          res
      }
    }


    public static AddSearchDirectory (name : string) : void
    {
      _lib_path <- name :: _lib_path;
    }
    

    /* -- PRIVATE METHODS -------------------------------------------------- */

    /**
     * Remove assembly file name from URL returned by Assembly.CodeBase.
     */
    private static DirectoryOfCodebase (path : string) : string
    {
      def path =
        if (path.LastIndexOf ('/') > path.LastIndexOf ('\\'))
          path.Substring (0, path.LastIndexOf ('/'))
        else
          path.Substring (0, path.LastIndexOf ('\\'));

      path
    }

    /**
     * Return directory mscorlib.dll resides in.
     */
    private static GetSystemDirectory () : string
    {
      DirectoryOfCodebase (typeof (System.Object).Assembly.CodeBase)
    }

    /**
     * Return directory Nemerle.dll resides in.
     */
    public static GetNemerleDirectory () : string
    { 
      // create instance of type we know it is in Nemerle.dll
      def exn = AssertionException ("", 0, "");
      def t = exn.GetType ();
      DirectoryOfCodebase (t.Assembly.CodeBase)
    }

    private static LookupAssembly (name : string) : Assembly
    {
      def name =
        if (name.EndsWith (".dll")) name
        else name + ".dll";

      def assembly_by_name (path) {
        try {
          Assembly.LoadFrom (path)
        } catch { _ : System.IO.FileNotFoundException => null };
      };

      if (name.IndexOf ('/') != -1 || name.IndexOf ('\\') != -1) {
        assembly_by_name (name)
      } else {
        def lookup (libs) {
          | lib :: libs =>
            def ret = assembly_by_name (System.IO.Path.Combine (lib, name));
            if (ret == null) lookup (libs)
            else ret
          | [] => null
        };

        lookup (_lib_path);
      }
    }

    /**
     * Tries to load the core framework libraries.
     */
    private static LoadCoreLibraries () : void
    {
      AddLibrary ("mscorlib");
      AddLibrary ("System");
    }


    private static load_macro (lib : Assembly, macro_name : string) : void
    {
      def macro_type = lib.GetType (macro_name.Replace ("&", "\\&"));
      if (macro_type == null) {
        Message.warning ("failed to lookup macro `" + macro_name + "' in assembly " + 
                         lib.FullName);
      } else {
        def ctor = macro_type.GetConstructor (System.Type.EmptyTypes);
        if (ctor == null) {
          Message.warning ("failed to lookup constructor in macro `" + macro_name + 
                           "' from assembly " + lib.FullName);
        } else {
          def macro_object = ctor.Invoke (null);
          if (macro_object == null) {
            Message.warning ("failed to construct instance of macro `" + macro_name + 
                             "' from assembly " + lib.FullName);
          } else {
            def casted_macro =
              try {
                (macro_object :> IMacro)
              } catch {
                | _ : System.InvalidCastException =>
                  Message.warning ("instance of macro `" + macro_name + 
                                   "' from assembly " + lib.FullName + 
                                   " does not implement IMacro interface");
                  null
              };
              when (casted_macro != null)
                MacroRegistry.register_macro (casted_macro);
          }
        }
      }
    }

    
    public static LoadMacrosFrom (lib : Assembly) : void
    {
      def maybe_load_macro (attribute : System.Object) {
        def attribute_type = (attribute :> System.Attribute).GetType ();
        when (attribute_type.FullName == "Nemerle.Internal.ContainsMacroAttribute") {
          def meth = attribute_type.GetMethod ("GetName");
          def macro_name = (meth.Invoke (attribute, null) :> string);
          load_macro (lib, macro_name)
        }
      };

      NArray.Iter (lib.GetCustomAttributes (true), maybe_load_macro)
    }
    
    
    public static LoadMacrosFrom (name : string) : void
    {
      def assembly = LookupAssembly (name);
      if (assembly == null)
        Message.error ("cannot load assembly with macros `" + name + "'")
      else
        LoadMacrosFrom (assembly);
    }
      
    
    /* -- PRIVATE VARIABLES ------------------------------------------------ */
    
    /**
     * The referenced library list
     */
    private static mutable _libraries : list <LibraryReference>;

    /**
     * List of directories we look for assemblies in.
     */
    private static mutable _lib_path : list <string>;

    private static _loaded_assemblies_by_name : Hashtable <string, Assembly>;
  }


  /**
   * This class stores information extracted from a referenced external library.
   */
  public class LibraryReference
  {
    /**
     * The assembly associated with this object
     */
    private mutable _library : Assembly;

    /**
     * The location of this library
     */
    private mutable _location : Location;
    
    /**
     * The assembly's custom attributes
     */
    private mutable _assembly_attributes : list <System.Object>;
       
    /**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     */
    private mutable _is_generated_by_nemerle : bool;
       
       
    /**
     * Load an assembly. Extracts and processes the custom attributes array.
     */
    public this (assembly : Assembly) 
    {
      _library <- assembly;

      _location <- Location("[library:" + (_library.GetName ()).Name + "]", 0, 0);
      _assembly_attributes <- List.FromArray (_library.GetCustomAttributes (true));
      process_assembly_attributes ();

      LibraryReferenceManager.LoadMacrosFrom (_library);
    }



    /**
     * Scans the assembly custom attributes looking for something interesting...
     */
    private process_assembly_attributes () : void
    {
      def loop (attributes : list <System.Object>) : void {
        match (attributes) {
          | [] => ()
          | attribute :: rest =>
            def attribute_type = (attribute :> System.Attribute).GetType ();
            match (attribute_type.FullName) {
              | "System.Reflection.AssemblyConfigurationAttribute" =>
                def configuration_attribute = (attribute :> AssemblyConfigurationAttribute);
                
                when (configuration_attribute.Configuration == "ContainsNemerleTypes") {
                  //Message.debug ("Loaded assembly " + this._library.FullName + " contains Nemerle types...");
                  this._is_generated_by_nemerle <- true
                }
              | _ => ()
            };
            
            loop (rest)
        }
      };
      
      loop (this._assembly_attributes);
    }


    /**
     * Turns a Framework type into something edible by Nemerle's type system
     */
    private TypeOfType (framework_type : System.Type) : Type
    {
      def framework_type_as_string = framework_type.FullName;
      
      // FIXME: ref and out types, anyone?
      if (framework_type_as_string == "System.Void")
        T_void ()
      else if (framework_type.IsArray)
        T_array (TypeOfType (framework_type.GetElementType ()))
      else if (framework_type.IsByRef)
        T_ref (TypeOfType (framework_type.GetElementType ()))
      else
        match (LibraryReferenceManager.LookupType (framework_type_as_string)) {
          | Some (tc) => T_app (tc, [])
          | None => Util.ice ("unbound external type " + framework_type_as_string)
        }
    } 

    private TyconOfType (framework_type : System.Type) : Tycon
    {
      match (TypeOfType (framework_type)) {
        | T_app (tc, []) => tc
        | _ => Util.ice ()
      }
    } 

    /**
     * If true, the library seems to have been generated by the Nemerle compiler
     */
    public IsGeneratedByNemerle () : bool 
    {
      this._is_generated_by_nemerle
    }
    
    /**
     * Looks up a type name in this assembly. The type name is expected
     * to be full, i.e. containing the full namespace qualifier.
     */
    public Lookup (name : string) : option <Tycon> {

      /* always first check if such a type is defined in the current library */
      def reflected_type = this._library.GetType (name);

      //  Message.debug ("Lookup in " + _library.FullName + " for '" + name + "' " +
      //    if (reflected_type == null) " failed" else " ok");

      if (reflected_type != null)
        if (_is_generated_by_nemerle)
          if (has_attribute ("Nemerle.Internal.TypeAttribute", reflected_type.GetCustomAttributes (false)))
            Some ((ExternalNemerleType (this, reflected_type) : Tycon))
          else
            Some ((NetType (this, reflected_type) : Tycon))
        else
          Some ((NetType (this, reflected_type) : Tycon))
      else None ()
    }

    /* -----------------------------------------------------------------
     * .NET types
     * ----------------------------------------------------------------- 
     */
    private class NetType
      : Tycon
    {
      protected handle : System.Type;
      protected library : LibraryReference;
      protected id : int;
      protected members : Hashtable <string, list <IMember>>;

      public this (lib : LibraryReference, h : System.Type)
      {
        // first cache ourself to avoid loops
        LibraryReferenceManager._loaded_types.Set (h.FullName, Some ((this : Tycon)));
        LibraryReferenceManager._loaded_types.Set (h.FullName.Replace ('+', '.'), Some ((this : Tycon)));
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        members <- Hashtable (2);

        when (IsDelegate ()) {
          def pref = "problem with delegate type `" + GetFullName () + "': ";
          match (LookupMember (".ctor")) {
            | [ctor] =>
              def meth = (ctor :> IMethod);
              def fh = meth.GetHeader ();
              match (fh.parms) {
                | [_, p2] =>
                  match (LookupMember ("Invoke")) {
                    | [inv] => 
                      def ty = (inv :> IMethod).GetMemType ();
                      fh.parms <- [p2];
                      p2.ty <- ty
                    | invs =>
                      Message.warning (pref + sprintf ("invoke count %d", List.Length (invs)))
                  }
                | parms =>
                  Message.warning (pref + sprintf ("ctor has %d parms", List.Length (parms)))
              }
            | ctors => Message.warning (pref + sprintf ("%d constructors", List.Length (ctors)))
          }
        }
      }

      public IsDelegate () : bool
      {
        handle.IsSubclassOf (typeof (System.MulticastDelegate))
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        T_app (this, [])
      }

      public GetKind () : MemberKind
      {
        MK_type (this)
      }

      public GetConstantObject () : option <IField>
      {
        None ()
      }

      public GetDeclaringTycon () : Tycon
      {
        if (handle.DeclaringType == null)
          null
        else
          library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list <Modifier>
      {
        // FIXME
        [Mod_public ()]
      }

      public IsStatic () : bool
      {
        true
      }

      public GetId () : int
      {
        id
      }

      public GetFullName () : string
      {
        handle.FullName.Replace ('+', '.')
      }

      public GetTyconKind () : TyconKind
      {
        TK_ExternalNetType (handle)
      }

      public GetTydecl () : Type_decl
      {
        if (handle.IsInterface)
          TD_interface ()
        else
          TD_class ()
      }

      public MakeSubst (parms : list <Type>) : Subst
      {
        match (parms) {
          | [] => ()
          | _ =>
            Message.error ("framework type `" + GetFullName () + "' supplied with type arguments")
        };
        SystemMap ()
      }

      public FreshSubst () : Subst
      {
        SystemMap ()
      }

      public SuperType (tc : Tycon) : option <list <Type>>
      {
        match (tc.GetTyconKind ()) {
          | TK_ExternalNetType (t) when t.IsAssignableFrom (handle)
          | TK_ExternalNemerleType (t) when t.IsAssignableFrom (handle) => Some ([])
          | _ => None ()
        }
      }

      public SubtypingSubst (_ : Tycon) : Subst
      {
        SystemMap ()
      }

      public SuperClass () : option <Tycon>
      {
        if (handle.BaseType == null)
          None ()
        else
          Some (library.TyconOfType (handle.BaseType))
      }

      public GetSuperTypes () : list <Type>
      {
        def supertypes = Hashtable (30);
        def add_bt (t : Type) {
          match (t) {
            | T_app (tc, []) =>
              if (supertypes.Contains (tc.GetId ())) ()
              else {
                supertypes.Add (tc.GetId (), t);
                match (tc.SuperClass ()) {
                  | Some (tc) => add_bt (T_app (tc, []))
                  | None => ()
                }
              }
            | _ => Util.ice ()
          }
        };
        List.Iter (GetDirectSuperTypes (), add_bt);
        supertypes.Fold (fun (_, tc, acc) { tc :: acc }, [])
      }

      public GetDirectSuperTypes () : list <Type>
      {
        def ifaces = List.Map (List.FromArray (handle.GetInterfaces ()), 
                               library.TypeOfType);
        match (SuperClass ()) {
          | Some (r) => T_app (r, []) :: ifaces
          | None => ifaces
        }
      }

      public SameAs (tc : Tycon) : bool 
      {
        GetId () == tc.GetId ()
      }

      public GetMembers () : list <IMember> 
      {
        LookupMember ("")
      }

      protected virtual imember_of_memberinfo (m : MemberInfo) : option <IMember>
      {
        def is_a (x) {
          m.MemberType %& x != (0 :> MemberTypes)
        };
        def ret (x : IMember) { Some (x) };
        
        if (is_a (MemberTypes.Constructor) || is_a (MemberTypes.Method))
          ret (NetMethod (library, (m :> MethodBase)))
        else if (is_a (MemberTypes.Field))
          ret (NetField (library, (m :> FieldInfo)))
        else if (is_a (MemberTypes.Property))
          ret (NetProperty (library, (m :> PropertyInfo)))
        else if (is_a (MemberTypes.NestedType))
          ret (library.TyconOfType ((m :> System.Type)))
        else
          None ()
      }

      private collect_members (name : string) : list <IMember> 
      {
        def add_member (m : MemberInfo, acc) {
          def tc = library.TyconOfType (m.DeclaringType);
          if (this.SameAs (tc)) {
            match (imember_of_memberinfo (m)) {
              | Some (r) => r :: acc
              | None => acc
            }
          } else {
            def fullname = m.ToString ();
            def proper_name (m : IMember) {
              m.GetHandle ().ToString () == fullname
            };
//            Message.debug ("name " + name + " look for " + fullname + " in " + tc.GetFullName () + " from " + GetFullName ());
            match (List.Filter (tc.LookupMember (name), proper_name)) {
              | [] => Util.ice ("no match for " + name)
              | [x] => x :: acc
              | _ =>  Util.ice ("2+ matches for " + name)
            }
          }
        };
        
        def flags = BindingFlags.Public     %|
                    BindingFlags.NonPublic  %|
                    BindingFlags.Static     %|
                    BindingFlags.Instance   ;
                    
        def member_array = 
          if (name == "")
            handle.GetMembers (flags) 
          else 
            handle.GetMember (name, flags);
            
        List.Rev (NArray.Fold (member_array, [], add_member))
      }

      public LookupMember (name : string) : list <IMember> 
      {
        match (members.Get (name)) {
          | Some (r) => r
          | None =>
            def lst = collect_members (name);
            members.Set (name, lst);
            lst
        }
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || handle.IsNestedPublic ||
          (handle.DeclaringType != null &&
           Option.IsSome (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsNestedFamily)
      }

      public GetSystemType () : System.Type
      {
        handle
      }
    }
    
    private class NetField 
      : IField
    {
      protected handle : FieldInfo;
      protected library : LibraryReference;
      protected id : int;

      public this (lib : LibraryReference, h : FieldInfo)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
      }

      public GetFieldInfo () : FieldInfo
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        library.TypeOfType (handle.FieldType);
      }

      public GetKind () : MemberKind
      {
        MK_field (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list <Modifier>
      {
        // FIXME
        if (handle.IsStatic) [Mod_public (), Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        handle.IsStatic
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        ! handle.IsInitOnly
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsFamily)
      }
    }
    
    class NetProperty
      : IProperty
    {
      protected handle : PropertyInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected getter : NetMethod;
      protected setter : NetMethod;
      protected mem_type : Type;

      public this (lib : LibraryReference, h : PropertyInfo)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        is_static <- {
          def get_method = handle.GetGetMethod (true);
          def set_method = handle.GetSetMethod (true);
          (get_method != null && get_method.IsStatic) ||
          (set_method != null && set_method.IsStatic);
        };
        
        unless (handle.GetGetMethod () == null)
          getter <- NetMethod (library, handle.GetGetMethod ());
        unless (handle.GetSetMethod () == null)
          setter <- NetMethod (library, handle.GetSetMethod ());

        def ret_type = library.TypeOfType (handle.PropertyType);

        def fun_args (t) {
          match (t) {
            | T_fun (T_void, _) => []
            | T_fun (T_prod (lst), _) => lst
            | T_fun (t, _) => [t]
            | _ => Util.ice ()
          }
        };

        def args =
          if (getter != null)
            fun_args (getter.GetMemType ())
          else if (setter != null)
            List.Rev (List.Tail (List.Rev (fun_args (setter.GetMemType ()))))
          else
            [];
        
        mem_type <-
          match (args) {
            | [] => ret_type
            | [x] => T_fun (x, ret_type)
            | lst => T_fun (T_prod (lst), ret_type)
          };
      }

      public GetGetter () : IMethod
      {
        getter
      }

      public GetSetter () : IMethod
      {
        setter
      }

      public GetPropertyInfo () : PropertyInfo
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public GetKind () : MemberKind
      {
        MK_property (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list <Modifier>
      {
        // FIXME
        if (is_static) [Mod_public (), Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        is_static
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        handle.CanWrite
      }

      public CanAccess (_source : Tycon) : bool
      {
        // FIXME: this is broken... we need to check method attributes
        true
      }
    }
    
    class NetMethod
      : IMethod
    {
      protected handle : MethodBase;
      protected library : LibraryReference;
      protected id : int;
      protected fun_header : Fun_header;

      public this (lib : LibraryReference, h : MethodBase)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        def mkparm (p : ParameterInfo) {
          Fun_parm (
            loc = library._location,
            name = p.Name,
            ty = library.TypeOfType (p.ParameterType),
            decl = null
          )
        };
        def ret_type =
          if (handle.Name == ".ctor" || handle.Name == ".cctor")
            T_void ()
          else
            library.TypeOfType ((handle :> MethodInfo).ReturnType);
        fun_header <-
          Fun_header (
            loc = library._location,
            name = GetName (),
            id = id,
            ret_type = ret_type,
            parms = List.Map (List.FromArray (handle.GetParameters ()), 
                              mkparm),
            typarms = [],
            tenv = null,
            closure_vars = null, // hm..
            all_locals = null,
            decl = null,
            cg_method = null
          )
      }
      
      public GetExternName () : string
      {
        null
      }

      public GetMethodBase () : MethodBase
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        Tyutil.fun_type (GetHeader ())
      }

      public GetKind () : MemberKind
      {
        MK_method (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list <Modifier>
      {
        // FIXME
        if (handle.IsStatic) [Mod_public (), Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        handle.IsStatic 
      }

      public GetId () : int
      {
        id
      }

      public GetFreshType () : Type
      {
        GetMemType ()
      }

      public GetFunKind () : Fun_kind
      {
        if (handle.DeclaringType.IsInterface)
          FK_iface_method (false)
        else
          if (handle.IsConstructor)
            if (handle.IsStatic)
              FK_static_ctor ()
            else
              FK_ctor ()
          else
            if (handle.IsStatic)
              FK_function ()
            else
              FK_bound_method ([])
      }

      public GetConstructorInfo () : ConstructorInfo
      {
        assert (handle.IsConstructor);
        (handle :> ConstructorInfo)
      }

      public GetMethodInfo () : MethodInfo
      {
        assert (!handle.IsConstructor);
        (handle :> MethodInfo)
      }

      public GetHeader () : Fun_header
      {
        fun_header
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsFamily)
      }
    }
   
    /* -----------------------------------------------------------------
     * External Nemerle types
     * ----------------------------------------------------------------- 
     */
     
    private static get_string_attribute (attr_name : string, meth_name : string,
                                         attributes : array <object>) : string
    {
      def loop (i) {
        if (i >= attributes.Length) null
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == attr_name) {
            def meth = attr_ty.GetMethod (meth_name);
            (meth.Invoke (attr, null) :> string)
          } else loop (i + 1)
        }
      };
      loop (0)
    }

    private static get_encoded_type (attributes : array <object>) : string
    {
      get_string_attribute ("Nemerle.Internal.TypeAttribute", "GetEncodedType", attributes)
    }

    private static get_variant_options (attributes : array <object>) : list <string>
    {
      def str = get_string_attribute ("Nemerle.Internal.VariantAttribute", 
                                      "GetVariantOptions", attributes);
      List.FromArray (str.Split (array [',']))
    }

    private static has_attribute (name : string, attributes : array <object>) : bool
    {
      def loop (i) {
        if (i >= attributes.Length) false
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == name) true
          else loop (i + 1)
        }
      };
      loop (0)
    }
    
    private class ExternalNemerleType : NetType
    {
      tenv : SystemMap <int, Tyvar.T>;
      typarms : list <Tyvar.T>;
      direct_supertypes : list <Type>;
      supertypes : list <Type>;
      supertype_map : SystemMap <int, Type>;
      tydecl : Type_decl;
      constant_object : option <IField>;
      
      public this (lib : LibraryReference, h : System.Type)
      {
        base (lib, h);
        
        def tenv =
          if (handle.DeclaringType != null)
            (library.TyconOfType (handle.DeclaringType) :> ExternalNemerleType).tenv
          else SystemMap ();

        def type_attrs = h.GetCustomAttributes (false);

        def attr_str = get_encoded_type (type_attrs); 
        def (typarms, tenv, dst, st) = TyCodec.DecodeTyinfo (tenv, attr_str);

        this.typarms <- typarms;
        this.tenv <- tenv;
        direct_supertypes <- dst;
        supertypes <- st;

        def add (t, m : SystemMap <int, Type>) {
          match (t) {
            | T_app (tc, _) => m.Add (tc.GetId (), t)
            | _ => Util.ice ("invalid supertype")
          }
        };

        supertype_map <- List.FoldLeft (supertypes, SystemMap (), add);
        constant_object <- None ();

        if (has_attribute ("Nemerle.Internal.VariantAttribute", type_attrs)) {
          def names = get_variant_options (type_attrs);
          def get_opt (name) {
            match (LibraryReferenceManager.LookupType (name)) {
              | Some (tc) => tc
              | None => Util.ice ("cannot find variant option named " + name)
            }
          };
          tydecl <- TD_variant (List.Map (names, get_opt))
        } else if (has_attribute ("Nemerle.Internal.VariantOptionAttribute", type_attrs)) {
          tydecl <- TD_variant_option ()
        } else if (has_attribute ("Nemerle.Internal.ConstantVariantOptionAttribute", type_attrs)) {
          tydecl <- TD_variant_option ();
          match (LookupMember ("_N_constant_object")) {
            | [fld] =>
              constant_object <- Some ((fld :> IField))
            | _ => Util.ice ("cannot find _N_constant_object")
          }
        } else if (has_attribute ("Nemerle.Internal.TypeAliasAttribute", type_attrs)) {
          def type_string = 
            get_string_attribute ("Nemerle.Internal.TypeAliasAttribute",
                                  "GetAliasedType", type_attrs);
          tydecl <- TD_alias (TyCodec.DecodeType (tenv, type_string))
        } else if (handle.IsInterface)
          tydecl <- TD_interface ()
        else
          tydecl <- TD_class ()
      }
      
      public override GetMemType () : Type
      {
        T_app (this, List.Map (typarms, fun (tv) { T_var (tv) }))
      }

      public override GetTyconKind () : TyconKind
      {
        TK_ExternalNemerleType (handle)
      }

      public override GetTydecl () : Type_decl
      {
        tydecl
      }

      public override GetConstantObject () : option <IField>
      {
        constant_object
      }

      public override MakeSubst (parms : list <Type>) : Subst
      {
        Tyinfo.ConstructSubst (this, typarms, parms)
      }

      public override FreshSubst () : Subst
      {
        Tyvar.fresh_subst (typarms)
      }

      public override SuperType (tc : Tycon) : option <list <Type>>
      {
        match (supertype_map.Find (tc.GetId ())) {
          | Some (T_app (_, args)) => Some (args)
          | Some => Util.ice ()
          | None => None ()
        }
      }

      public override SubtypingSubst (tc : Tycon) : Subst
      {
        if (tc.GetId () == GetId ())
          SystemMap () // current type, no substitution
        else
          tc.MakeSubst (Option.UnSome (SuperType (tc)));
      }

      public override GetSuperTypes () : list <Type>
      {
        supertypes
      }

      public override GetDirectSuperTypes () : list <Type>
      {
        direct_supertypes
      }

      protected override imember_of_memberinfo (m : MemberInfo) : option <IMember>
      {
        def is_a (x) {
          m.MemberType %& x != (0 :> MemberTypes)
        };
        def is_nem (x : MemberInfo) {
          has_attribute ("Nemerle.Internal.TypeAttribute", x.GetCustomAttributes (false))
        };
        def ret (x : IMember) { Some (x) };
        
        if (is_a (MemberTypes.Constructor) || is_a (MemberTypes.Method)) {
          if (is_nem (m))
            ret (ExternalNemerleMethod (tenv, library, (m :> MethodBase)))
          else
            ret (NetMethod (library, (m :> MethodBase)))
        } else if (is_a (MemberTypes.Field)) {
          if (is_nem (m))
            ret (ExternalNemerleField (tenv, library, (m :> FieldInfo)))
          else
            ret (NetField (library, (m :> FieldInfo)))
        } else if (is_a (MemberTypes.Property))
          Util.ice ("property in external nemerle type")
        else if (is_a (MemberTypes.NestedType))
          ret (library.TyconOfType ((m :> System.Type)))
        else
          Util.ice ("unknown object in nemerle type " + 
                    m.Name + " in " + GetFullName ())
      }
    }
    
    private class ExternalNemerleField : NetField
    {
      real_type : Type;
      
      public this (tenv : SystemMap <int, Tyvar.T>, lib : LibraryReference, h : FieldInfo)
      {
        base (lib, h);
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        real_type <- TyCodec.DecodeType (tenv, attr_str);
      }

      public override GetMemType () : Type
      {
        real_type
      }
    }
    
    class ExternalNemerleMethod : NetMethod
    {
      public this (tenv : SystemMap <int, Tyvar.T>, lib : LibraryReference, h : MethodBase)
      {
        base (lib, h);
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        TyCodec.FixupFunctionHeader (tenv, fun_header, attr_str);
      }
      
      public override GetExternName () : string
      {
        null
      }

      public override GetFreshType () : Type
      {
        GetMemType () /- Tyvar.fresh_subst (fun_header.typarms)
      }
    }
   
  }


  
} /* namespace */
