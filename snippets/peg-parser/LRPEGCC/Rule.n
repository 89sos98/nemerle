using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace LRPEGCC
{
  // TODO: Понять на фиг нужен этот вариант!!!
  internal variant RuleType
  {
    | List  { ty : RuleType; }
    | Tuple { types : list[RuleType]; }
    | NType { ty : PExpr; }
    | Range
    | None
  }

  internal variant Rule
  {
    | Choice                        { rules : list[Rule]; }
    | Sequence                      { rules : list[Rule]; }
    | Call                          { name : string; }
    | RepeatMin                     { minCount : int; rule : Rule; }
    | RepeatMinMax                  { minCount : int; maxCount : int; rule : Rule; }
    | Chars                         { chars : list[RangeSet]; }
    | Not                           { rule : Rule; }
    | And                           { rule : Rule; }
    // TODO: С типами в Capture похоже творится фигня... Надо разобраться.
    | Capture                       { name : string; argType : RuleType; retType : RuleType; rule : Rule; }
    | CaptureNamedTerminalSymbol    { name : string; rule : Rule; }
    | ExtensionPoint                { name : string; }
    
    public Walk(func : Rule -> Rule) : Rule
    {
      def loop(rule : Rule) : Rule
      {
        def rule2 = func(rule);
        
        def rule3 = 
          match (rule2)
          {
            | Choice(rules)                             => Choice(rules.Map(loop))
            | Sequence(rules)                           => Sequence(rules.Map(loop))
            | RepeatMin(x, rule)                        => RepeatMin(x, loop(rule))
            | RepeatMinMax(min, max, rule)              => RepeatMinMax(min, max, loop(rule))
            | Not(rule)                                 => Not(loop(rule))                             
            | And(rule)                                 => And(loop(rule))                             
            | Capture(name, argType, retType, rule)     => Capture(name, argType, retType, loop(rule))             
            | CaptureNamedTerminalSymbol(name, rule)    => CaptureNamedTerminalSymbol(name, loop(rule))
            | Call | Chars | ExtensionPoint             => rule2
          };
          
        rule3.Index = rule.Index;
        rule3
      }

      loop(this)
    }
    
    public Index : int { get; private set; }
    
    internal UpdateIndecis() : void
    {
      //assert2(!this.ToString().Contains("inputError"));
      
      def loop(rule : Rule, index : int) : void
      {
        rule.Index = index;
        
        match (rule)
        {
          | Choice(rules)                           =>
            foreach (r in rules)
              loop(r, index)
              
          | Sequence(rules)                         => 
            mutable i = 0;
            foreach (r in rules)
            {
              loop(r, i);
              i++;
            }
          
          | Not(r) | And(r) 
          | RepeatMinMax(0, 1, r)                   => loop(r, 0)
          | RepeatMin(_, r) | RepeatMinMax(_, _, r) => loop(r, index)
          | CaptureNamedTerminalSymbol(_, r)
          | Capture(_, _, _, r)                     => loop(r, 0)
          | Call| Chars | ExtensionPoint            => ()
        }
      }
      
      loop(this, 0);
    }
    
    public Priority : int
    {
      get
      {
        match (this)
        {
          | Chars                       => 5
          | CaptureNamedTerminalSymbol  => 5
          | Capture                     => 5
          | ExtensionPoint              => 5
          | Call                        => 5
          | RepeatMin                   => 4
          | RepeatMinMax                => 4
          | Not                         => 3
          | And                         => 3
          | Sequence                    => 2
          | Choice                      => 1
        }
      }
    }

    public override ToString() : string
    {
      def p(rule : Rule)
      {
        if (rule.Priority <= this.Priority) 
          $"($rule)"
        else                                
          rule.ToString()
      }
      
      match (this)
      {
        | Choice(rules)                             => $<#..$(rules; " / "; p)#>
        | Sequence(rules)                           => $<#..$(rules; " "; p)#>
        | Call(name)                                => name
        | RepeatMin(0, rule)                        => $"$(p(rule))*"
        | RepeatMin(1, rule)                        => $"$(p(rule))+"
        | RepeatMin(x, rule)                        => $"$RepeatMin($x, $rule)"
        | RepeatMinMax(0, 1, rule)                  => $"$(p(rule))?"
        | RepeatMinMax(min, max, rule)              => $"$RepeatMin($min, $max, $rule)"
        | Chars([chars])                            => $"[$chars]"
        | Chars(chars)                              => $<#(..$(chars; " "; ch => $"[$ch]"))#>
        | Not(rule)                                 => $"!$(p(rule))"
        | And(rule)                                 => $"&$(p(rule))"
        | Capture(name, _, _, rule)                 => $"NTerm[$name]($rule)"
        | CaptureNamedTerminalSymbol(name, rule)    => $"Term[$name]($rule)"
        | ExtensionPoint(name)                      => $"ExtensionPoint($name)"
      }
    }
  }
}
