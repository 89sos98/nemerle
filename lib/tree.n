/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met :
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections.New 
{

 /* Comparision releated definition */

  /* Interfaces */

  public interface IComparable ('a)
  {
    CompareTo (_ : 'a) : int;
  }

  public interface IComparator ('a)
  {
    Compare (_ : 'a, _ : 'a) : int;
  }

/* End of Comparision releated definitions */

/* Functional Red-Black Trees implementation */

  public class BalanceViolation extends System.Exception
  {
    public this () {}
  }

  public module Tree 
  {

/* Definition of the node Node ('a) of tree  */

    public variant Node ('a) where 'a : > IComparable ('a)
    {
      | RedNode {
             key : 'a;
             lchild : Node ('a);
             rchild : Node ('a); 
           }
      | BlackNode {
             key : 'a;
             lchild : Node ('a);
             rchild : Node ('a); 
           }
      | Leaf
    }

/* Function finds a node and returns it (if any) as an option ('a) */
    public 'a where 'a : > IComparable ('a) 
    Get (tree : Node ('a), elem : 'a) : option ('a)
    {
      def get (tree : Node ('a), candidate : option ('a)) : option ('a) 
          { 
            match (tree) {
              | (RedNode) as treee => 
                                if (treee.key.CompareTo (elem) > 0)
                                  get (treee.lchild, candidate)
                                else
                                  get (treee.rchild, Some (treee.key)) 
              | (BlackNode) as treee => 
                                if (treee.key.CompareTo (elem) > 0)
                                  get (treee.lchild, candidate)
                                else
                                  get (treee.rchild, Some (treee.key))
              | Leaf => match (candidate) {
                          | Some (key) => if (elem.CompareTo (key) == 0)
                                            candidate
                                          else 
                                            None ()
                          | None => None ()
                        }
            }
          };
      get (tree, None ())
    }

/* 
  Function returns a passed tree TREE with inserted (replaced if REPLACE is true)
  element ELEM and information whether passed ELEM has been factually added as a 
  new node
*/ 
    public 'a where 'a : > IComparable ('a)
    AckInsert (tree : Node ('a), elem : 'a, replace : bool) : Node ('a) * bool
    {
      def insert (tree : Node ('a)) : Node ('a) * bool
          {
            match (tree) {
              | (RedNode (key, ltree, rtree)) as node =>
                  if (elem.CompareTo (key) > 0)
                    match (insert (rtree)) {
                      (treee, bl) => 
                        (RedNode (key, ltree, treee), bl)
                    }
                  else if (elem.CompareTo (key) < 0)
                    match (insert (ltree)) {
                      (treee, bl) =>
                          (RedNode (key, treee, rtree), bl)
                    }
                  else if (replace)
                    (RedNode (elem, ltree, rtree), false)
                  else 
                    (node, false)
              | (BlackNode (key, ltree, rtree)) as node =>
                  if (elem.CompareTo (key) > 0)
                    match (insert (rtree)) {
                      (treee, bl) => 
                        (BalanceRight (key, ltree, treee), bl)
                    }
                  else if (elem.CompareTo (key)<0)
                    match (insert (ltree)) {
                      (treee, bl) =>
                        (BalanceLeft (key, treee, rtree), bl)
                    }
                  else if (replace)
                    (RedNode (elem, ltree, rtree), false)
                  else 
                    (node, false)
              | Leaf => 
                  (RedNode (elem, Leaf (), Leaf ()), true)
            }
          };
      match (insert (tree)){
        | ((BlackNode) as treee, bl) => (treee, bl)
        | (RedNode (key, ltree, rtree), bl) =>
            (BlackNode (key, ltree, rtree), bl)
        | (Leaf, bl) => (Leaf (), bl)
      }
    }

/* 
  Function returns a passed tree TREE with inserted (replaced if REPLACE is true)
  element ELEM 
*/ 
    public 'a where 'a : > IComparable ('a)
    Insert (tree : Node ('a), elem : 'a, replace : bool) : Node ('a)
    {
      match (AckInsert (tree, elem, replace)) {
        (treee, _) => treee
      }
    }

/* 
  Function returns a passed tree TREE with removed element ELEM and information 
  whether ELEM was factually removed
*/ 

    public 'a where 'a : > IComparable ('a)
    AckDelete (tree : Node ('a), elem : 'a) : Node ('a) * bool
    {
      def delete (tree : Node ('a)) : Node ('a) * bool
          {
            match (tree){
              | RedNode (key, ltree, rtree)
              | BlackNode (key, ltree, rtree) =>
                  if (elem.CompareTo (key)>0)
                    match (rtree) {
                      | BlackNode => 
                          match (delete (rtree)) {
                            (treee, bl) =>
                              (BalRight (key, ltree, treee), bl)
                          }  
                      | _ => 
                          match (delete (rtree)) {
                            (treee, bl) => (RedNode (key, ltree, treee), bl)
                          }
                    } 
                  else if (elem.CompareTo (key)<0)
                    match (ltree) {
                      | BlackNode =>   
                          match (delete (ltree)) {
                            (treee, bl) =>
                              (BalLeft (key, treee, rtree), bl)
                          }  
                      | _ =>
                          match (delete (ltree)) {
                            (treee, bl) => (RedNode (key, treee, rtree), bl)
                          }
                    }
                  else 
                    (GetSubst (ltree, rtree),true)
              | Leaf => (Leaf (), false)
            }
          };
      match (delete (tree)){
        | ((BlackNode, _)) as treee => treee
        | (RedNode (key, ltree, rtree), bl) =>
            (BlackNode (key, ltree, rtree), bl)
        | (Leaf, bl) => (Leaf (), bl)
      } 
    }

/* 
  Function returns a passed tree TREE with removed element ELEM
*/ 

    public 'a where 'a :> IComparable ('a)
    Delete (tree : Node ('a), elem : 'a) : Node ('a)
    {
      match (AckDelete (tree, elem)) {
        (treee, _) => treee
      }
    }
   
/* 
  Function goes through each TREE node and counts cumulative
  value of function FUNC with intial value INI
*/ 

    public 'a, 'b where 'a : > IComparable ('a) 
    Fold (tree : Node ('a), func : 'b * 'a -> 'b, ini : 'b) : 'b 
    {
      match (tree) {
        | RedNode (key, ltree, rtree)
        | BlackNode (key, ltree, rtree) =>
            Fold (rtree, func, func (Fold (ltree, func, ini), key))
        | Leaf => ini
      }
    } 

/*
  Function returns true if and only if there exists such node X 
  of TREE that FUNC(X) is true 
*/
    public 'a where 'a :> IComparable ('a) 
    Exists (tree : Node ('a), func : 'a -> bool) : bool
    {
      def exists (tree : Node ('a)) : bool
          {
            match (tree) {
              | RedNode (key, ltree, rtree)
              | BlackNode (key, ltree, rtree) =>
                  if (func (key))
                    true
                  else 
                    if (exists (ltree))
                      true
                    else
                      exists (rtree)
              | Leaf => false
            }
          };
      exists (tree)
    }
   
/*
  Function returns true if and only if for every node X 
  of TREE FUNC(X) is true 
*/ 

    public 'a where 'a :> IComparable ('a) 
    ForAll (tree : Node ('a), func : 'a -> bool) : bool
    {
      def forall (tree : Node ('a)) : bool
          {
            match (tree) {
              | RedNode (key, ltree, rtree)
              | BlackNode (key, ltree, rtree) =>
                  if (func (key))
                    if (forall (ltree))
                       forall (rtree)
                    else
                       false
                  else
                    false
              | Leaf => true
            }
          };
      forall (tree)
    }

/*
  Function returns TREE1 * INT1 * TREE2 * INT2 where tree TREE1 consists
  of this nodes X of TREE that FUNC(X) is true and tree TREE2 contains
  all nodes of TREE that are not in TREE1. INT1 is the size of TREE1 and
  INT2 is the size of TREE2   
*/

    public 'a where 'a : > IComparable ('a) 
    CountPartition (tree : Node ('a), func : 'a -> bool) : Node ('a) * int * Node ('a) * int
    {
      def partition (tree : Node ('a), yntree : Node ('a) * int * Node ('a) * int) : Node ('a) * int * Node ('a) * int
          {
            match (tree) {
              | RedNode (key, ltree, rtree)
              | BlackNode (key, ltree, rtree) =>
                  match (yntree) {
                    (ytree, ysize, ntree, nsize) =>
                      if ( func (key) )
                        partition (rtree, partition (ltree, (Insert (ytree, key, false), ysize + 1, ntree, nsize)))
                      else 
                        partition (rtree, partition (ltree, (ytree, ysize, Insert (ntree, key, false), nsize + 1)))
                  }
              | Leaf => yntree
            }
          };
      partition (tree, (Leaf (), 0, Leaf (), 0))
    } 

/*
  Function returns TREE1 * TREE2 where tree TREE1 consists of this nodes X
  of TREE that FUNC(X) is true and tree TREE2 contains all nodes of TREE 
  that are not in TREE1.   
*/

    public 'a where 'a : > IComparable ('a) 
    Partition (tree : Node ('a), func : 'a -> bool) : Node ('a) * Node ('a)
    {
      match (CountPartition (tree, func)) {
        (ytree, _, ntree, _) =>
          (ytree, ntree)
      }
    }

/*
  Functions returns TREE1 * INT1 where TREE1 is a tree that contains this nodes X 
  of TREE that FUNC(X) is true and INT1 is the size of TREE1
*/

    public 'a where 'a : > IComparable ('a) 
    CountFilter (tree : Node ('a), func : 'a -> bool) : Node ('a) * int
    {
      def filter (tree : Node ('a), ytree : Node ('a) * int) : Node ('a) * int
          {
            match (tree) {
              | RedNode (key, ltree, rtree)
              | BlackNode (key, ltree, rtree) =>
                  match (ytree) {
                    (ytree, ysize) =>
                      if ( func (key) )
                        filter (rtree, filter (ltree, (Insert (ytree, key, false), ysize + 1)))
                      else 
                        filter (rtree, filter (ltree, (ytree, ysize)))
                  }
              | Leaf => ytree
            }
          };
      filter (tree, (Leaf (), 0))
    } 

/*
  Functions returns a tree that contains this nodes X 
  of TREE that FUNC(X) is true
*/

    public 'a where 'a : > IComparable ('a) 
    Filter (tree : Node ('a), func : 'a -> bool) : Node ('a)
    {
      match (CountFilter (tree, func)) {
        (treee, _) => treee
      }
    }

  
/*
  FIXME: There is a problem with this function - it doesn't need to do correct tranformation

    public 'a,'b where 'a :> IComparable ('a), 'b :> IComparable ('b)
    Map (tree : Node ('a), func : 'a -> 'b) : Node ('b)
    {
      def map (tree: Node ('a)) : Node ('b)
          {
            match (tree) {
              | Tr (key, color, ltree, rtree) =>
                  Tr (func (key), color, map (ltree), map (rtree))
              | Leaf => Leaf ()
            } 
          };
      map (tree)
    }
*/   

/*
  Internal functions used for tree balancing 
*/
    private 'a where 'a : > IComparable ('a)
    BalRight (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ( (elem, lchild, rchild)){
        | (key, ltree, RedNode (key1, ltree1, rtree1)) =>
            RedNode (key, ltree, BlackNode (key1, ltree1, rtree1))
        | (key, BlackNode (key1, ltree1, rtree1), rtree) =>
            BalanceLeft (key, RedNode (key1, ltree1, rtree1), rtree)
        | (key, RedNode (key1, BlackNode (key3, ltree3, rtree3), BlackNode (key2, ltree2, rtree2)), rtree) =>
            RedNode (key2, BalanceLeft (key1, RedNode (key3, ltree3, rtree3), ltree2), BlackNode (key, rtree2, rtree))
        | _ => throw BalanceViolation ()
      }
    }

    private 'a where 'a : > IComparable ('a)
    BalLeft (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ( (elem, lchild, rchild)){
        | (key, RedNode (key1, ltree1, rtree1), rtree) =>
            RedNode (key, BlackNode (key1, ltree1, rtree1), rtree)
        | (key, ltree, BlackNode (key1, ltree1, rtree1)) =>
            BalanceRight (key, ltree, RedNode (key1, ltree1, rtree1))
        | (key, ltree, RedNode (key1, BlackNode (key3, ltree3, rtree3), BlackNode (key2, ltree2, rtree2))) =>
            RedNode (key3, BlackNode (key, ltree, ltree3), BalanceRight (key1, rtree3, RedNode (key2, ltree2, rtree2)))
        | _ => throw BalanceViolation ()
      }
    }

    private 'a where 'a : > IComparable ('a)
    GetSubst (lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ( (lchild, rchild)){
        | (Leaf, tree) => tree
        | (tree, Leaf) => tree
        | (RedNode (key, ltree, rtree), RedNode (key1, ltree1, rtree1)) =>
            match (GetSubst (rtree, ltree1)){
              | RedNode (key2, ltree2, rtree2) =>
                  RedNode (key2, RedNode (key, ltree, ltree2), RedNode (key1, rtree2, rtree1))
              | tree => RedNode (key, ltree, RedNode (key1, tree, rtree1))
            }
        | (BlackNode (key, ltree, rtree), BlackNode (key1, ltree1, rtree1)) =>
            match (GetSubst (rtree, ltree1)){
              | RedNode (key2, ltree2, rtree2) =>
                  RedNode (key2, BlackNode (key, ltree, ltree2), BlackNode (key1, rtree2, rtree1))
              | tree => BalLeft (key, ltree, BlackNode (key1, tree, rtree1))
            }
        | (tree, RedNode (key, ltree, rtree)) =>
            RedNode (key, GetSubst (tree, ltree), rtree)
        | (RedNode (key, ltree, rtree), tree) =>
            RedNode (key, ltree, GetSubst (rtree, tree))
      }
    }

    private 'a where 'a : > IComparable ('a)
    BalanceLeft (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ((elem, lchild, rchild)){
        | (key, RedNode (key1, ltree1, rtree1), RedNode (key2, ltree2, rtree2)) =>
            RedNode (key, BlackNode (key1, ltree1, rtree1), BlackNode (key2, ltree2, rtree2))
        | (key, RedNode (key1, RedNode (key2, ltree2, rtree2), rtree1), rtree) =>
            RedNode (key1, BlackNode (key2, ltree2, rtree2), BlackNode (key, rtree1, rtree))
        | (key, RedNode (key1, ltree1, RedNode (key2, ltree2, rtree2)), rtree) =>
            RedNode (key2, BlackNode (key1, ltree1, ltree2), BlackNode (key, rtree2, rtree))
        | (key, ltree, rtree) =>
            BlackNode (key, ltree, rtree)
      } 
    }

    private 'a where 'a : > IComparable ('a)
    BalanceRight (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ((elem, lchild, rchild)){
        | (key, RedNode (key1, ltree1, rtree1), RedNode (key2, ltree2, rtree2)) =>
            RedNode (key, BlackNode (key1, ltree1, rtree1), BlackNode (key2, ltree2, rtree2))
        | (key, ltree, RedNode (key1, ltree1, RedNode (key2, ltree2, rtree2))) =>
            RedNode (key1, BlackNode (key, ltree, ltree1), BlackNode (key2, ltree2, rtree2))
        | (key, ltree, RedNode (key1, RedNode (key2, ltree2, rtree2), rtree1)) =>
            RedNode (key2, BlackNode (key, ltree, ltree2), BlackNode (key1, rtree2, rtree1))
        | (key, ltree, rtree) =>
            BlackNode (key, ltree, rtree)
      } 
    } 
  } 

/* End of Functional Red-Black Trees implementation */

/* Implementation of mapping using Red-Black Trees */

  /* Main (public) module dedicated to create particular instance of Map */

  public module Map ('a, 'b) 
  {

/* 
   Function returns an empty IMap ('a, 'b) where
   'a elements are compared using System.IComparable
   interface
*/
    public 'a, 'b where 'a :> System.IComparable
     MakeSysMap () : IMap ('a, 'b)
    {
      SystemMap ()
    } 
    
/* 
   Function returns an empty IMap ('a, 'b) where
   'a elements are compared using Nemerle.Collections.IComparable
   interface
*/

    public 'a, 'b where 'a :> IComparable ('a)
     MakeNemMap () : IMap ('a, 'b)
    {
      NemerleMap ()
    }
   
/*
   Function returns an empty IMap (int, 'c) where
   keys are of int type
*/

    public 'c IntMap () : IMap (int, 'c)
    { 
       (SystemMap () :> IMap (int, 'c))
    }

/*
   Function returns an empty IMap (int, 'c) where
   keys are of string type
*/
  
    public 'c StringMap () : IMap (string, 'c)
    { 
       (SystemMap () :> IMap (string, 'c)) 
    }  
  } 
  
  public class NotFound extends System.Exception
  {
    public this () {}
  }

  /* Interface dedicated to be the only way to interact with Map object */

  public interface IMap ('a, 'b) 
  {
  /*
    Method returns a IMap ('a, 'b) with added pair (k,v)
  */
    Add (k : 'a, v : 'b) : IMap ('a, 'b); 
  /*
    Method returns an empty IMap ('a, 'b)
  */
    Clear () : IMap ('a, 'b);
  /*
    Method returns a copy of THIS IMap ('a, 'b) 
  */
    Copy () : IMap ('a, 'b);
  /*
    Method returns true if and only if there exists such pair (X,Y) 
    of THIS IMap ('a,'b) that FUNC(X,Y) is true 
  */   
    Exists (func : 'a * 'b -> bool) : bool; 
  /*
    Method returns an IMAP that consists of THIS pair (X,Y)
    of THIS IMap that FUNC(X) is true   
  */ 
    Filter (func : 'a * 'b -> bool) : IMap ('a, 'b);
  /* 
    Method finds and returns a value associated with key K
    (if there is no such value then None is returned)
  */ 
    Find (k : 'a) : option ('b); 
  /*
    Method returns some value that is contained in IMap
    Note: This value depends on IMap manipulation 
  */
    First () : 'b;
  /* 
    Method goes through each of THIS IMap pair and counts cumulative
    value of function FUNC with intial value INI
  */  
    'c Fold (func : 'c * 'a * 'b -> 'c, ini : 'c) : 'c;
  /*
    Method returns true if and only if for every pair (X,Y) 
    of THIS IMap ('a,'b) FUNC(X,Y) is true 
  */  
    ForAll (func : 'a * 'b -> bool) : bool;
    Get (k : 'a) : 'b;
    IsEmpty () : bool;
  /* 
    Method goes through each of THIS Imap pair (X,Y) and computes
    FUNC (X,Y) 
  */
    Iter (func : 'a * 'b -> void) : void;
  /* 
    Method return true if a key K is contained in THIS IMap
  */
    Member (k : 'a) : bool;
  /*
    Method returns IMAP1 * IMAP2 where IMAP1 consists of this pair (X,Y)
    of IMAP1 that FUNC(X) is true and IMAP2 contains all this pairs of THIS IMap 
    that are not in IMAP1.   
  */ 
    Partition (func : 'a * 'b -> bool) : IMap ('a, 'b) * IMap ('a, 'b); 
  /*
    Method returns THIS IMap with removed pair (K,V)
  */
    Remove (k : 'a, v : 'b) : IMap ('a, 'b);
  /*
    Method returns THIS IMap with replaced pair (K,V)
  */
    Replace (k : 'a, v : 'b) : IMap ('a, 'b);
  /* 
    Method returns size of THIS IMap
  */
    Size () : int;    
  }     

  public class NodeSys ('a, 'b) where 'a :> System.IComparable implements IComparable (NodeSys ('a, 'b)) 
  {
    public key : 'a;
    public val : 'b;
    
    public CompareTo (x : NodeSys ('a, 'b)) : int implements IComparable.CompareTo
    { 
      key.CompareTo (x.key) 
    }

    public this (k : 'a, v : 'b) 
    { 
      this.key <- k; 
      this.val <- v;
    }

    public this (k : 'a) 
    {
      this.key <- k;
    }
  } 

  public class NodeNem ('a, 'b) where 'a :> IComparable ('a) implements IComparable (NodeNem ('a, 'b))
  {
    public key : 'a;
    public val : 'b;
    
    public CompareTo (x : NodeNem ('a, 'b)) : int implements IComparable.CompareTo
    { 
      key.CompareTo (x.key) 
    }

    public this (k : 'a, v : 'b) 
    { 
      this.key <- k; 
      this.val <- v;
    }

    public this (k : 'a) 
    {
      this.key <- k;
    }
  } 

  /* definition of Map class that uses Nemerle.IComparable.CompareTo method of 'a for comparision */
   
  public class NemerleMap ('a, 'b) where 'a :> IComparable ('a) implements IMap ('a, 'b) 
  {
    protected root : Tree.Node (NodeNem ('a, 'b));
    protected size : int;

    // TODO : Make it implement ICollection (problem with names and being functional or imperative - both mb)

    public this ()
    {
      this.root <- Tree.Leaf ();
      this.size <- 0;
    }

    protected this (size : int, r : Tree.Node (NodeNem ('a, 'b))) 
    {
      this.size <- size;
      this.root <- r;
    }

    public Copy () : NemerleMap ('a, 'b) implements IMap.Copy
    {
      this
    }


    public First () : 'b  implements IMap.First
    {
      match (root) {
        | Tree.Leaf => throw Nemerle.Collections.EmptyCollection("Map is empty")
        | Tree.RedNode (key, _, _)
        | Tree.BlackNode (key, _, _) => key.val
      }
    }

    public IsEmpty () : bool implements IMap.IsEmpty
    {
      match (root) {
        | Tree.Leaf => true
        | _ => false
      }
    }

    public Clear () : NemerleMap ('a, 'b) implements IMap.Clear
    {
      NemerleMap ()
    }

    public Add (k : 'a, v : 'b) : NemerleMap ('a, 'b)  implements IMap.Add
    { 
      match (Tree.AckInsert (this.root, NodeNem (k, v), false)) {
        | (treee, true) =>
            NemerleMap (this.size + 1, treee)
        | (treee, false) =>
            NemerleMap (this.size, treee)
      } 
    }

    public Replace (k : 'a, v : 'b) : NemerleMap ('a, 'b)  implements IMap.Replace
    { 
      match (Tree.AckInsert (this.root, NodeNem (k, v), true)) {
        | (treee, true) =>
            NemerleMap (this.size + 1, treee)
        | (treee, false) =>
            NemerleMap (this.size, treee)
      } 
    }

    public Find (k : 'a) : option ('b)  implements IMap.Find
    {
      match (Tree.Get (this.root, NodeNem (k))) {
        | (Some) as n => Some (n.val.val) 
        | None => None ()
      }
    }

    public Get (k : 'a) : 'b  implements IMap.Get
    {
      match (Tree.Get (this.root, NodeNem (k))) {
        | (Some) as n => n.val.val 
        | None => throw (NotFound ())
      }
    }

    public Member (k : 'a) : bool implements IMap.Member
    {
      match (Tree.Get (this.root, NodeNem (k))) {
        | Some => true 
        | None => throw (NotFound ())
      }
    }
 
    public Remove (k : 'a, v : 'b) : NemerleMap ('a, 'b) implements IMap.Remove
    {
      match (Tree.AckDelete (this.root, NodeNem (k, v))) {
        | (tree, true) =>
            NemerleMap (this.size - 1, tree)
        | (tree, false) =>
            NemerleMap (this.size, tree)   
      }      
    }

    public Size () : int implements IMap.Size
    {
      this.size
    }

    public 'd Fold (func : 'd * 'a * 'b -> 'd, ini : 'd) : 'd implements IMap.Fold
    {
      def wrap (ctx : 'd, n : NodeNem ('a, 'b)) : 'd 
          {
            func (ctx, n.key, n.val)
          };
      Tree.Fold (this.root, wrap, ini)
    }

    public Iter (func : 'a * 'b -> void) : void implements IMap.Iter
    {
      def wrap (ctx : int, n : NodeNem ('a, 'b)) : int
          { 
            func (n.key, n.val); 
            ctx 
          };
      def _ = Tree.Fold (this.root, wrap, 0);
      ()
    }
    
    public ForAll (func : 'a * 'b -> bool) : bool implements IMap.ForAll
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.ForAll (this.root, wrap)
    }

    public Exists (func : 'a * 'b -> bool) : bool implements IMap.Exists
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.Exists (this.root, wrap)
    }

    public Filter (func : 'a * 'b -> bool) : NemerleMap ('a, 'b) implements IMap.Filter
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountFilter (this.root, wrap)) {
        (ytree, ycount) =>
          NemerleMap (ycount, ytree) 
      }
    }

    public Partition (func : 'a * 'b -> bool) : NemerleMap ('a, 'b) * NemerleMap ('a, 'b) implements IMap.Partition
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountPartition (this.root, wrap)) {
        (ytree, ycount, ntree, ncount) =>
          (NemerleMap (ycount, ytree), NemerleMap (ncount, ntree)) 
      }
    }

  }

  /* definition of Map class that uses System.IComparable.CompareTo method of 'a for comparision */

  public class SystemMap ('a, 'b) where 'a :> System.IComparable implements IMap ('a, 'b)
  {
    protected root : Tree.Node (NodeSys ('a, 'b));
    protected size : int;

    // TODO : Make it implement ICollection (problem with names and being functional or imperative - both mb)

    public this ()
    {
      this.root <- Tree.Leaf ();
      this.size <- 0;
    }

    protected this (size : int, r : Tree.Node (NodeSys ('a, 'b))) 
    {
      this.size <- size;
      this.root <- r;
    }

    public Copy () : SystemMap ('a, 'b) implements IMap.Copy
    {
      this
    }


    public First () : 'b  implements IMap.First
    {
      match (root) {
        | Tree.Leaf => throw Nemerle.Collections.EmptyCollection("Map is empty")
        | Tree.RedNode (key, _, _)
        | Tree.BlackNode (key, _, _) => key.val
      }
    }

    public IsEmpty () : bool implements IMap.IsEmpty
    {
      match (root) {
        | Tree.Leaf => true
        | _ => false
      }
    }

    public Clear () : SystemMap ('a, 'b) implements IMap.Clear
    {
      SystemMap ()
    }

    public Add (k : 'a, v : 'b) : SystemMap ('a, 'b)  implements IMap.Add
    { 
      match (Tree.AckInsert (this.root, NodeSys (k, v), false)) {
        | (treee, true) =>
            SystemMap (this.size + 1, treee)
        | (treee, false) =>
            SystemMap (this.size, treee)
      } 
    }

    public Replace (k : 'a, v : 'b) : SystemMap ('a, 'b)  implements IMap.Replace
    { 
      match (Tree.AckInsert (this.root, NodeSys (k, v), true)) {
        | (treee, true) =>
            SystemMap (this.size + 1, treee)
        | (treee, false) =>
            SystemMap (this.size, treee)
      } 
    }

    public Find (k : 'a) : option ('b)  implements IMap.Find
    {
      match (Tree.Get (this.root, NodeSys (k))) {
        | (Some) as n => Some (n.val.val) 
        | None => None ()
      }
    }

    public Get (k : 'a) : 'b  implements IMap.Get
    {
      match (Tree.Get (this.root, NodeSys (k))) {
        | (Some) as n => n.val.val 
        | None => throw (NotFound ())
      }
    }

    public Member (k : 'a) : bool implements IMap.Member
    {
      match (Tree.Get (this.root, NodeSys (k))) {
        | Some => true 
        | None => throw (NotFound ())
      }
    }
 
    public Remove (k : 'a, v : 'b) : SystemMap ('a, 'b) implements IMap.Remove
    {
      match (Tree.AckDelete (this.root, NodeSys (k, v))) {
        | (tree, true) =>
            SystemMap (this.size - 1, tree)
        | (tree, false) =>
            SystemMap (this.size, tree)   
      }      
    }

    public Size () : int implements IMap.Size
    {
      this.size
    }

    public 'd Fold (func : 'd * 'a * 'b -> 'd, ini : 'd) : 'd implements IMap.Fold
    {
      def wrap (ctx : 'd, n : NodeSys ('a, 'b)) : 'd 
          {
            func (ctx, n.key, n.val)
          };
      Tree.Fold (this.root, wrap, ini)
    }

    public Iter (func : 'a * 'b -> void) : void implements IMap.Iter
    {
      def wrap (ctx : int, n : NodeSys ('a, 'b)) : int
          { 
            func (n.key, n.val); 
            ctx 
          };
      def _ = Tree.Fold (this.root, wrap, 0);
      ()
    }
    
    public ForAll (func : 'a * 'b -> bool) : bool implements IMap.ForAll
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.ForAll (this.root, wrap)
    }

    public Exists (func : 'a * 'b -> bool) : bool implements IMap.Exists
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.Exists (this.root, wrap)
    }

    public Filter (func : 'a * 'b -> bool) : SystemMap ('a, 'b) implements IMap.Filter
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountFilter (this.root, wrap)) {
        (ytree, ycount) =>
          SystemMap (ycount, ytree) 
      }
    }

    public Partition (func : 'a * 'b -> bool) : SystemMap ('a, 'b) * SystemMap ('a, 'b) implements IMap.Partition
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountPartition (this.root, wrap)) {
        (ytree, ycount, ntree, ncount) =>
          (SystemMap (ycount, ytree), SystemMap (ncount, ntree)) 
      }
    }

  }

  /* End of Implementation of mapping using Red-Black Trees */
}
