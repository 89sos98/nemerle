(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.CGexpr;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

open System.Reflection;
open System.Reflection.Emit;

namespace Nemerle.Compiler {

module CGexpr {
  public cg_type (ctx : CTX, t : Type) : System.Type
  {
    cg_type (ctx.current_type.GetSystemType (), t)
  }

  tuple_type (len : int) : System.Type
  {
    def name = "Nemerle.Tuple" + string_of_int (len);
    (GlobalEnv.LookupInternalType (name)).GetSystemType ()
  }
  
  function_type (len : int) : System.Type
  {
    def name = "Nemerle.Func" + string_of_int (len);
    (GlobalEnv.LookupInternalType (name)).GetSystemType ()
  }

  get_apply_method (parm_cnt : int) : IMethod
  {
    def name = "Nemerle.Func" + string_of_int (parm_cnt);
    def tc = GlobalEnv.LookupInternalType (name);
    def our_method (m : IMember) {
      match (m.GetKind ()) {
        | MK_method (m) => 
          List.length (m.GetHeader ().parms) == parm_cnt
        | _ => false
      }
    };
    match (List.filter (our_method, tc.LookupMember ("apply", LF_all ()))) {
      | [m] => (m :> IMethod)
      | _ => Util.ice ()
    }
  }

  tuple_ref (val : CG_expr, pos : int, len : int) : CG_expr
  {
    def name = "Nemerle.Tuple" + string_of_int (len);
    def tc = GlobalEnv.LookupInternalType (name);
    def fld =
      match (tc.LookupMember ("field" + string_of_int (pos), LF_all ())) {
        | [x] =>
          match (x.GetKind ()) {
            | MK_field (f) => f
            | _ => Util.ice ("tuple_ref: not field")
          }
        | [] => Util.ice ("tuple_ref: not found " + string_of_int (pos) + 
                          " / " + string_of_int (len))
        | _ => Util.ice ("tuple_ref: more then 1")
      };
    CE_field_ref (val, fld.GetFieldInfo ())
  }

  tuple_ctor (vals : list (CG_expr)) : CG_expr
  {
    def len = List.length (vals);
    def name = "Nemerle.Tuple" + string_of_int (len);
    def tc = GlobalEnv.LookupInternalType (name);
    def ctor =
      match (tc.LookupMember (".ctor", LF_all ())) {
        | [x] =>
          match (x.GetKind ()) {
            | MK_method (f) => f.GetConstructorInfo ()
            | _ => Util.ice ()
          }
        | _ => Util.ice ()
      };
    CE_call (CE_ctor_ref (ctor), vals)
  }
  
  public cg_type (tybuilder : System.Type, t : Type) : System.Type
  {
    match (Tyutil.top_expand (t)) {
      | T_void => typeof (System.Void)
      | T_prod (l) =>
        tuple_type (List.length (l))
      | T_fun (args, _) => 
        function_type (List.length (Tyutil.fun_args (args)))
      | T_var (tv) =>
        match (Tyvar.constraints (tv)) {
          | [] => typeof (System.Object)
          | t :: _ => cg_type (tybuilder, t)
        }
      | T_app (ti, _) => 
        match (ti.GetTydecl ()) {
          | TD_external (x) =>
            (GlobalEnv.LookupInternalType (x)).GetSystemType ()
          | _ =>
            def ret = ti.GetSystemType ();
            assert (ret != null);
            ret
        }
      | T_ref => Util.ice ("FIXME: cg ref")
      | T_out => Util.ice ("FIXME: cg out")
      | T_array (et) =>
        def et = cg_type (tybuilder, et);
        def ty = tybuilder.Module.GetType (et.FullName + "[]");
        if (ty == null) {
          def arr = System.Array.CreateInstance (et, 0);
          when (arr == null)
            Util.ice ("unbound array type " + et.FullName + "[]");
          arr.GetType ()
        } else {
          ty
        }
    }
  }

  class CTX
  {
    public mutable current_fun : Fun_header;
    public mutable current_closure : option (CG_val);
    public mutable closure_fields : Int_map (FieldInfo);
    public mutable closure_ptrs : Int_map (FieldInfo);
    public mutable locals : Int_map (CG_val);
    public mutable current_type : Tyinfo;
  }

  copy_ctx (c : CTX) : CTX 
  {
    CTX (current_fun = c.current_fun,
         current_closure = c.current_closure,
         closure_fields = c.closure_fields,
         closure_ptrs = c.closure_ptrs,
         locals = c.locals,
         current_type = c.current_type)
  }

  empty_ctx (ti : Tyinfo) : CTX
  {
    CTX (current_fun = null,
         current_closure = None (),
         closure_fields = Map.int_map (),
         closure_ptrs = Map.int_map (),
         locals = Map.int_map (),
         current_type = ti)
  }

  store_in_closure (ctx : CTX, d : LocalValue, val : CG_expr) : CG_expr
  {
    def rf = CE_field_ref (CE_ref (Option.unsome (ctx.current_closure)),
                           ctx.closure_fields.get (d.id));
    CE_assign (rf, val);
  }

  store_local (ctx : CTX, d : LocalValue, val : CG_expr) : CTX * CG_val
  {
    if (d.in_closure) {
      def assign = store_in_closure (ctx, d, val);
      def cgv = CG_val (loc = d.loc, 
                        name = Util.tmpname ("dummy"),
                        ty = typeof (System.Void), 
                        val = assign);
      (copy_ctx (ctx), cgv)
    } else {
      def cgv = CG_val (loc = d.loc, 
                        name = decl_uniq_name(d), 
                        ty = cg_type (ctx, d.ty), 
                        val = val);
      def ctx' = copy_ctx (ctx);
      ctx'.locals <- ctx.locals.add (d.id, cgv);
      (ctx', cgv)
    }
  }

  closure_ref (ctx : CTX, fn : Fun_header) : CG_expr
  {
    if (ctx.current_fun.id == fn.id)
      CE_ref (Option.unsome (ctx.current_closure))
    else
      CE_field_ref (CE_this (), ctx.closure_ptrs.get (fn.id))
  }

  public is_dummy_type (t : System.Type) : bool
  {
    t.FullName == "System.Void"
  }

  public type_of (ex : CG_expr) : System.Type
  {
    if (ex.ty != null) ex.ty
    else {
      def ty =
        match (ex) {
          | CE_ref (d) => d.ty
          | CE_global_ref (obj) =>
            if (obj.MemberType %& MemberTypes.Field != (0 :> MemberTypes))
              (obj :> FieldInfo).FieldType
            else if (obj.MemberType %& MemberTypes.Property != (0 :> MemberTypes))
              (obj :> PropertyInfo).PropertyType
            else
              Util.ice ()
              
          | CE_field_ref (_, f) => f.FieldType
          
          | CE_tail_call (CE_global_ref (m), _)
          | CE_call (CE_global_ref (m), _) => (m :> MethodInfo).ReturnType
          
          | CE_tail_call (CE_method_ref (_, m), _)
          | CE_call (CE_method_ref (_, m), _) => m.ReturnType
          
          | CE_tail_call (CE_ctor_ref (c), _)
          | CE_call (CE_ctor_ref (c), _) => c.DeclaringType
          
          | CE_tail_call (CE_base_ctor_ref, _)
          | CE_call (CE_base_ctor_ref, _) => typeof (System.Void)
          
          | CE_self_tail_call
          | CE_tail_call
          | CE_call => Util.ice ()
          
          | CE_assign => typeof (System.Void)
          | CE_let (_, b) => type_of (b)
          | CE_has_type => typeof (System.Boolean)
          | CE_raise => typeof (System.Void)
          | CE_if (_, _, _) => Util.ice ("ought to be cached")
          | CE_try_with (e, _, _) => type_of (e)
          | CE_try_finally (e, _) => type_of (e)
          | CE_literal (l) => 
            match (l) {
              | L_void => typeof (System.Void)
              | L_null => typeof (System.Object)
              | L_int => typeof (System.Int32)
              | L_char => typeof (System.Char)
              | L_string => typeof (System.String)
              | L_float => typeof (System.Double)
              | L_bool => typeof (System.Boolean)
            }
          | CE_this => typeof (System.Object) // cheat a bit 
          | CE_cast (_, t) => t
          | CE_sequence (b) => type_of (List.last (b))
          | CE_mkarray 
          | CE_array_indexer (_, _) => Util.ice ("should be cached")
          | CE_opcode => Util.ice ()
          | CE_ignore | CE_skip => typeof (System.Void)

          // can't tell
          | CE_none => Util.ice ()

          // these are supported only as part of call
          | CE_ctor_ref => Util.ice ()
          | CE_method_ref => Util.ice ()
          | CE_base_ctor_ref => Util.ice ()
        };
      ex.ty <- ty;
      ty
    }
  }

  box_value (body : CG_expr) : CG_expr 
  {
    if (is_dummy_type (type_of (body)))
      CE_sequence ([body; CE_literal (L_null ())])
    else
      if (type_of (body).IsValueType)
        CE_cast (body, typeof (System.Object))
      else
        body
  }

  cg_pattern (ctx : CTX, val : CG_expr, pats : list (Pattern * Expr)) : CG_expr * bool * CTX * list (CG_val)
  {
    mutable vals <- Map.int_map ();
    mutable rctx <- ctx;
    mutable always_matches <- true;
    
    def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
      match (pat) {
        | P_underscore => CE_literal (L_bool (true))
        
        | P_as (subpat, d) =>
          if (d.in_closure) ()
          else
            match (vals.find (d.id)) {
              | Some => ()
              | None =>
                def (ctx, v) = store_local (rctx, d, CE_none ());
                rctx <- ctx;
                vals <- vals.add (d.id, v);
            };
          def ass = CE_assign (local_ref (rctx, d), maybe_cast (ctx, cg_type (ctx, d.ty), val));
          match (subpat) {
            | P_cons =>
              match (cgpat (val, subpat)) {
                | (CE_if (c, e_then, e_else)) as e =>
                  CE_if (e.ty, c, CE_sequence ([ass; e_then]), e_else)
                | _ => Util.ice ()
              }
            | _ =>
              CE_sequence ([ass; cgpat (val, subpat)])
          }
          
        | P_tuple (args) =>
          def len = List.length (args);
          def f (acc, arg)
            {
              def (pos, ex) = acc;
              def cond = cgpat (tuple_ref (CE_cast (val, tuple_type (len)), pos, len), arg);
              (pos - 1, CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false))))
            };
          def ini = (len, CE_literal (L_bool (true)));
          def (_, ex) = List.fold_left (f, ini, List.rev (args));
          ex

        | P_literal (lit) =>
          def litexpr = CE_literal (lit);
          CE_call (typeof (System.Boolean), 
                   CE_opcode ("=="), 
                   [CE_cast (val, type_of (litexpr)); litexpr])
          
        | P_record (args) =>
          def val = CE_cast (val, cg_type (ctx, pat.ty));
          def f (ex, np) {
            def (name, pat) = np;
            def cond = cgpat (CE_field_ref (val, (name : IField).GetFieldInfo ()), pat);
            CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false)))
          };
          List.fold_left (f, CE_literal (L_bool (true)), List.rev (args))
        
        | P_cons (n, a) =>
          always_matches <- false;
          def tyname = n.GetSystemType ();
          def ex = CE_has_type (val, tyname);
          CE_if (typeof (System.Boolean), ex, 
                   cgpat (CE_cast (val, tyname), a), 
                   CE_literal (L_bool (false)))
      }
    };

    mutable global_always_matches <- false;

    def loop (pats) {
      match (pats) {
        | (pat, expr) :: rest =>
          always_matches <- true;
          def cond = cgpat (val, pat);
          def cond =
            match (expr) {
              | E_literal (L_bool (true)) => cond
              | _ =>
                always_matches <- false;
                CE_if (typeof (System.Boolean), cond, cg_expr (rctx, expr), CE_literal (L_bool (false)))
            };
          global_always_matches <- global_always_matches || always_matches;
          CE_if (typeof (System.Boolean), cond, CE_literal (L_bool (true)), loop (rest))
        | [] =>
          CE_literal (L_bool (false))
      }
    };

    def r = loop (pats);
    def collect_vals (acc : list (CG_val), _ : int, v : CG_val) : list (CG_val) { v :: acc };
    (r, global_always_matches, rctx, vals.fold (collect_vals, []))
  }

  
  (**
   * Matching over arbitrary types
   *)
  cg_match_over_any_type (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr 
  {
    match (mcs) {
      | [] =>
        // FIXME: cache it
        def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.Match_failure");
        def match_failure = get_default_ctor (ctx, tc);
        CE_raise (CE_call (CE_ctor_ref (match_failure), []))

      | m :: ms =>
        // FIXME: do something with always_matches
        def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
        def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) };
        def then_part = cg_expr (ctx', m.body);
        def else_part = cg_match (t, ctx, val, ms);
        List.fold_left (mklet, CE_if (t, cond, then_part, else_part), vals)
    }
  }


  (**
   * Matching over booleans.
   *)
  cg_match_over_booleans (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
  {
    def type_of_bool = typeof(System.Boolean); // FIXME: how to reflect types here?
    
    mutable vals <- Map.int_map ();
    mutable rctx <- ctx;

    mutable true_handled <- false;
    mutable false_handled <- false;
    mutable last_pattern_always_matches <- false;

    def is_always_true (expr : Expr) : bool {
      match (expr) {
        | E_literal (L_bool (true)) => true
        | _ => false
      }    
    };

    def make_cond (patterns : list (Pattern * Expr)) : CG_expr {
      match (patterns) {        
        | (P_underscore, when_expr) :: _ when is_always_true (when_expr) =>
          last_pattern_always_matches <- true;          
          CE_literal (L_bool (true))
      
        | (P_underscore, when_expr) :: rest =>
          CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))

        | (P_literal (L_bool (literal)), when_expr) :: rest when is_always_true (when_expr) =>
          def literal_already_handled = if (literal) true_handled else false_handled;          
          when (literal_already_handled) Message.warning ("unreachable pattern in matching");
          
          if (literal) true_handled <- true else false_handled <- true;
                    
          if (true_handled && false_handled) {
            last_pattern_always_matches <- true;          
            CE_literal (L_bool (true))
          }
          else {
            def literal_eq_expr =
              CE_call (type_of_bool, CE_opcode ("=="), 
                      [val; CE_literal (L_bool (literal))]);

            CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), make_cond (rest))
          }

        | (P_literal (L_bool (literal)), when_expr) :: rest =>
          def literal_already_handled = if (literal) true_handled else false_handled;          
          when (literal_already_handled) Message.warning ("unreachable pattern in matching");

          def opposite_handled = if (literal) false_handled else true_handled;

          if (opposite_handled) {
            CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))          
          }
          else {
            def literal_eq_expr =
              CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                      [val; CE_literal (L_bool (literal))]);

            CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), 
              CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), 
                make_cond (rest)))
          }

        | (P_as (subpat, decl), _) :: rest =>
          if (decl.in_closure) ()
          else
            match (vals.find (decl.id)) {
              | Some => ()
              | None =>
                def (ctx, v) = store_local (rctx, decl, CE_none ());
                rctx <- ctx;
                vals <- vals.add (decl.id, v);
            };
          def assign_expr = 
            CE_assign (local_ref (rctx, decl), maybe_cast (rctx, cg_type (ctx, decl.ty), val));
          match (subpat) {
            | P_cons =>
              match (make_cond (rest)) {
                | CE_if (cond_expr, then_expr, else_expr) =>
                  CE_if (type_of_bool, cond_expr, CE_sequence ([assign_expr; then_expr]), else_expr)
                | _ => Util.ice ()
              }
            | _ =>
              CE_sequence ([assign_expr; make_cond (rest)])
          }

        | [] => CE_literal (L_bool (false))

        | (P_tuple, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_tuple")
        | (P_record, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_record")
        | (P_cons, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_cons")

        | _ :: _ => 
          Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
      }      
    };

    def walk_match_cases (mcs : list (Match_case)) : CG_expr {
      match (mcs) {
        | [] =>
          def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.Match_failure");
          def match_failure = get_default_ctor (rctx, tc);
          CE_raise (CE_call (CE_ctor_ref (match_failure), []))

        | mc :: rest =>
          def cond = make_cond (mc.patterns);
          def body = cg_expr (rctx, mc.body);
          
          if (true_handled && false_handled || last_pattern_always_matches) {
            when (List.length (rest) > 0) Message.warning ("unreachable match cases");
            body
          }
          else
            CE_if (cond, body, walk_match_cases (rest))
      }
    };

    (* handle the special cases for the if/when/unless macros *)
    match (mcs) {
      | [then_case; else_case] =>
        match ((then_case.patterns, else_case.patterns)) {
          | ([(P_literal (L_bool (literal)), then_case_when_expr)], [(P_underscore, else_case_when_expr)]) 
              when is_always_true (then_case_when_expr) && is_always_true (else_case_when_expr) =>
              
            def literal_eq_expr =
              CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                      [val; CE_literal (L_bool (literal))]);

            CE_if (t, literal_eq_expr, cg_expr (ctx, then_case.body), cg_expr (ctx, else_case.body))         
          | _ => walk_match_cases (mcs)
        }
      | _ => walk_match_cases (mcs)
    }
  }


  (**
   * Matching
   *)
  cg_match (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
  {
    def type_of_val = type_of (val);
        
    if (type_of_val.FullName == "System.Boolean") cg_match_over_booleans (t, ctx, val, mcs)
    else cg_match_over_any_type (t, ctx, val, mcs)
  }
    

  get_default_ctor (_ctx : CTX, tc : Tycon) : ConstructorInfo
  {
    match (tc.LookupMember (".ctor", LF_all ())) {
      | [x] =>
        match (x.GetKind ()) {
          | MK_method (m) => m.GetConstructorInfo ()
          | _ => Util.ice ()
        }
      | _ => Util.ice ()
    }
  }
 
  // always return a new copy
  build_cg_method (tybuilder : System.Type, header : Fun_header) : CG_method
  {
    def mkparm (p : Fun_parm) : CG_val {
      CG_val (loc = header.loc,
              name = p.name, 
              ty = cg_type (tybuilder, p.ty),
              val = CE_none ())
    };
    def m = CG_method ();
    m.name <- header.name;
    m.ret_type <- cg_type (tybuilder, header.ret_type);
    m.parms <- List.map (mkparm, header.parms);
    m.implemented_methods <- [];
    m
  }
  
  build_cg_method (ctx : CTX, header : Fun_header) : CG_method
  {
    build_cg_method (ctx.current_type.GetSystemType (), header)
  }

  fixup_cg_method (meth : IMethod) : void
  {
    def cgm = GetCgMethod (meth);
    cgm.modifiers <- meth.GetModifiers ();
  }

  public GetCgMethod (meth : IMethod) : CG_method
  {
    def header = meth.GetHeader ();
    when (header.cg_method == null) {
      def tb = meth.GetDeclaringTycon ().GetSystemType ();
      header.cg_method <- build_cg_method (tb, header);
      fixup_cg_method (meth);
    };
    header.cg_method
  }
  
  build_cg_method (ctx : CTX, meth : IMethod) : CG_method
  {
    build_cg_method (ctx, meth.GetHeader ())
  }

  // return cached copy for given method
  get_cg_method (ctx : CTX, header : Fun_header) : CG_method
  {
    when (header.cg_method == null) {
      header.cg_method <- build_cg_method (ctx, header);
    };
    header.cg_method;
  }
  
  get_cg_method (ctx : CTX, meth : IMethod) : CG_method
  {
    get_cg_method (ctx, meth.GetHeader ())
  }

  make_tupled_method (ctx : CTX, parm_cnt : int) : CG_method
  {
    def cgm = build_cg_method (ctx, get_apply_method (1));
    def parms =
      if (parm_cnt == 0) 
        []
      else {
        def tup = CE_cast (CE_ref (List.hd (cgm.parms)), tuple_type (parm_cnt));
        def mkparm (acc, i) {
          if (i == 0) acc
          else mkparm (tuple_ref (tup, i, parm_cnt) :: acc, i - 1)
        };
        mkparm ([], parm_cnt)
      };
    def meth = get_apply_method (parm_cnt);
    def multi_apply = CE_method_ref (CE_this (), meth.GetMethodInfo ());
    cgm.body <- CE_call (multi_apply, parms);
    cgm.implemented_methods <- [get_apply_method (1)];
    cgm.modifiers <- [Mod_internal ()];
    cgm
  }

  make_untupled_method (ctx : CTX, parm_cnt : int) : CG_method
  {
    def cgm = build_cg_method (ctx, get_apply_method (parm_cnt));
    
    def mkparm (v) { CE_ref (v) };
    def parm = tuple_ctor (List.map (mkparm, cgm.parms));

    def meth = get_apply_method (1);
    def single_apply = CE_method_ref (CE_this (), meth.GetMethodInfo ());
    
    cgm.body <- CE_call (single_apply, [parm]);
    cgm.implemented_methods <- [get_apply_method (parm_cnt)];
    cgm.modifiers <- [Mod_internal ()];
    cgm
  }

  get_lambda_proxy (ctx : CTX, meth : IMethod) : ConstructorInfo
  {
    def cg_method = GetCgMethod (meth);
    when (cg_method.lambda_ctor == null) {
      // FIXME: we should generate proxies in module *or* in the class depending
      // on permissions
      //def mod = (ctx.current_type.GetSystemType ().Module :> ModuleBuilder);
      def parm_cnt = List.length (cg_method.parms);
      def impl =
        if (parm_cnt == 1)
          mkarray [function_type (1)]
        else
          mkarray [function_type (parm_cnt); function_type (1)];
      //def tb = mod.DefineType ("Nemerle.Proxies." + fun_uniq_name (meth.GetHeader ()), 
      //                         TypeAttributes.Class, typeof (System.Object), impl);
      def tb = ctx.current_type.GetTypeBuilder ().
                DefineNestedType (fun_uniq_name (meth.GetHeader ()), 
                                  TypeAttributes.NestedAssembly, typeof (System.Object), impl);
      Passes.cgil.RegisterAuxType (tb);
      cg_method.lambda_ctor <- Passes.cgil.AddImplicitCtor (tb);
      
      // get separate copy
      def cgm = build_cg_method (ctx, meth);
      cgm.name <- "apply";
      cgm.implemented_methods <- [get_apply_method (parm_cnt)];
      cgm.modifiers <- [Mod_internal ()];
      
      def mkparm (v : CG_val) {
        def t = v.ty;
        v.ty <- typeof (System.Object);
        CE_cast (CE_ref (v), t)
      };
      cgm.ret_type <- typeof (System.Object);
      cgm.body <- box_value (CE_call (CE_global_ref (meth.GetMethodInfo ()), 
                                      List.map (mkparm, cgm.parms)));

      Passes.cgil.AddMethod (cgm, tb);
      when (parm_cnt != 1)
        Passes.cgil.AddMethod (make_tupled_method (ctx, parm_cnt), tb);
    };
    
    cg_method.lambda_ctor
  }

  global_ref (ctx : CTX, m : IMember) : CG_expr {
    match (m.GetKind ()) {
      | MK_type => Util.ice ()

      | MK_field (f) =>
        CE_global_ref (f.GetFieldInfo ())

      | MK_property (f) =>
        CE_global_ref (f.GetPropertyInfo ())
        
      | MK_method (f) =>
        CE_call (CE_ctor_ref (get_lambda_proxy (ctx, f)), [])
    }
  }

  local_ref (ctx : CTX, d : LocalValue) : CG_expr
  {
    if (d.in_closure) {
      def defined_in = Option.unsome (d.parent_fun);
      CE_field_ref (closure_ref (ctx, defined_in), 
                    ctx.closure_fields.get (d.id))
    } else if (ctx.locals.mem (d.id)) {
      CE_ref (ctx.locals.get (d.id))
    } else {
      Message.debug ("undef " + d.name + " = " + string_of_int (d.id));
      Util.ice ("ref to undef val " + d.name)
    }
  }

  maybe_cast (_ctx : CTX, needed_type : System.Type, ex : CG_expr) : CG_expr
  {
    assert (needed_type != null);
    def current_type = type_of (ex);
    assert (current_type != null);
    if (needed_type.FullName == "System.Void")
      if (current_type.FullName == "System.Void")
        ex
      else
        CE_ignore (ex)
    else if (needed_type.FullName == current_type.FullName || 
             (needed_type.IsAssignableFrom (current_type) && !current_type.IsValueType))
      ex
    else 
     CE_cast (ex, needed_type)
  }

  get_fn_header (fn : LocalValue) : Fun_header
  {
    match (fn.kind) {
      | D_local_fun (h, _) => h
      | _ => Util.ice ()
    }
  }

  casted_parms (ctx : CTX, formals : list (CG_val), parms : list (CG_expr)) : list (CG_expr)
  {
    def do_cast (v : CG_val, e : CG_expr) {
      maybe_cast (ctx, v.ty, e)
    };
    List.map2 (do_cast, formals, parms)
  }

  raw_cg_expr (ctx : CTX, inex : Expr) : CG_expr
  {
    //Message.debug ("emit");
    def self (e : Expr) : CG_expr { cg_expr (ctx, e) };
    match (inex) {
      | E_local_ref (d) => 
        local_ref (ctx, d)

      | E_static_ref (d) => 
        global_ref (ctx, d)

      | E_field_ref (o, f) =>
        maybe_cast (ctx, cg_type (ctx, inex.expr_ty), CE_field_ref (self (o), f.GetFieldInfo ()))

      | E_method_ref => Util.ice ()
      | E_property_ref => Util.ice ()
      | E_static_property_ref => Util.ice ()

      | E_call (f, ps) =>
        def compile_parm (p : Parm) { self (p.expr) };
        def emit_call (cgm : CG_method, callable) {
          def parms = List.map (compile_parm, ps);
          if (cgm == null) {
            CE_call (cg_type (ctx, inex.expr_ty), callable, parms)
          } else {
            def parms = casted_parms (ctx, cgm.parms, parms);
            maybe_cast (ctx, cg_type (ctx, inex.expr_ty), CE_call (callable, parms))
          }
        };
        def plain_call () {
          def len = List.length (ps);
          def imeth = get_apply_method (len);
          emit_call (GetCgMethod (imeth), CE_method_ref (self (f), imeth.GetMethodInfo ()))
        };
        
        match (f) {
          | E_static_ref (m) =>
            match (m.GetKind ()) {
              | MK_method (m) =>
                match (m.GetFunKind ()) {
                  | _ when m.GetExternName () != null =>
                    def opname = m.GetExternName ();
                    assert (opname.StartsWith ("%op"));
                    emit_call (null, CE_opcode (opname.Substring (3)))
                  | FK_ctor =>
                    emit_call (GetCgMethod (m), CE_ctor_ref (m.GetConstructorInfo ()))
                  | _ =>
                    emit_call (GetCgMethod (m), CE_global_ref (m.GetMethodInfo ()))
                }
              | _ => plain_call ()
            }
          | E_method_ref (o, m) => 
            emit_call (GetCgMethod (m), CE_method_ref (self (o), m.GetMethodInfo ()))
          | E_base (m) =>
            emit_call (GetCgMethod (m), CE_base_ctor_ref (m.GetConstructorInfo ()))
          | E_local_ref (d) =>
            match (d.kind) {
              | D_local_fun (h, _) when h.id == ctx.current_fun.id =>
                assert (h.cg_method.method_builder != null);
                emit_call (get_cg_method (ctx, h),
                           CE_method_ref (CE_this (), h.cg_method.method_builder))
              | _ => plain_call ()
            }
          | _ => plain_call ()
        }

      | E_assign (e1, e2) =>
        CE_assign (self (e1), self (e2))
        
      | E_mkarray (initializers) =>
        def element_type =
          match (initializers) {
            | [] => typeof (System.Object)
            | element :: _ =>
              cg_type (ctx, element.expr_ty)
          };
        CE_mkarray (ty = cg_type (ctx, inex.expr_ty), 
                    element_type = element_type, 
                    initializers = List.map (self, initializers))

      | E_array_indexer (ty, obj, args) =>
        // FIXME: this won't work for multidimensional arrays which have to
        // be treated as System.Array objects and use respective access props.
        match (obj.expr_ty) {
          | T_array => CE_array_indexer (cg_type (ctx, ty), self (obj), List.map (self, args))
          | _ => Util.ice ()
        }

      | E_let (d, v, b) =>
        def (ctx', cgv) = store_local (ctx, d, self (v));
        CE_let (cgv, cg_expr (ctx', b))

      | E_letfun (fs, body) =>
        mutable vals <- [];
        def store (ctx : CTX, f : Function_decl) : CTX {
          def ct = make_lambda_ctor_call (ctx, get_fn_header (f.decl));
          def (ctx, val) = store_local (ctx, f.decl, ct);
          vals <- val :: vals;
          ctx
        };
        def emit (f : Function_decl) {
          emit_lambda_code (ctx, get_fn_header (f.decl), f.body);
        };
        def mklet (acc, val) { CE_let (val, acc) };

        def ctx = List.fold_left (store, ctx, fs);
        List.iter (emit, fs);
        List.fold_left (mklet, cg_expr (ctx, body), vals)

      | E_match (e, mcs) =>
        def v =
          CG_val (loc = e.loc, 
                  name = Util.tmpname ("matched_value"),
                  ty = cg_type (ctx, e.expr_ty), 
                  val = cg_expr (ctx, e));
        CE_let (v, cg_match (cg_type (ctx, inex.expr_ty), ctx, CE_ref (v), mcs))

      | E_raise (e) =>
        CE_raise (cg_expr (ctx, e))

      | E_try_with (body, exn, handler) =>
        def body = cg_expr (ctx, body);
        // FIXME: this is broken for exn values to go into closure
        def (ctx', v) = store_local (ctx, exn, CE_none ());
        def handler = cg_expr (ctx', handler);
        def res = CE_try_with (body, v, handler);
        res.ty <- cg_type (ctx, inex.expr_ty);
        res

      | E_try_finally (e1, e2) =>
        CE_try_finally (cg_expr (ctx, e1), cg_expr (ctx, e2))

      | E_literal (l) => 
        CE_literal (l)

      | E_this => 
        CE_this ()

      | E_type_conversion (e, t) => 
        CE_cast (cg_expr (ctx, e), cg_type (ctx, t))

      | E_type_enforcement (e, _) =>
        cg_expr (ctx, e)

      | E_sequence (e1, e2) =>
        CE_sequence ([cg_expr (ctx, e1); cg_expr (ctx, e2)])

      | E_tuple (l) =>
        tuple_ctor (List.map (fun (e) { box_value (self (e)) }, l))

      | E_base =>
        Util.ice ("stray base")
    }
  }

  (** 
   * Flatten given [Typedtree.Expr] object into [CG_expr].
   *
   * <remarks>
   *   As a side-effect few classes for closures and local functions
   *   can be generated and stored in current type builder.
   * </remarks>
   *)
  cg_expr (ctx : CTX, ex : Expr) : CG_expr
  {
    Util.locate (ex.loc, fun () {
        def e = raw_cg_expr (ctx, ex);
        e.loc <- ex.loc;
        e
      })
  }

  mangle (s : string) : string
  {
    def p = s.ToCharArray ();
    
    for (mutable i <- 0; i < (p : System.Array).Length; i <- i + 1)
      unless ((p[i] >= 'a' && p[i] <= 'z') ||
              (p[i] >= 'A' && p[i] <= 'Z') ||
              (p[i] >= '0' && p[i] <= '9'))
        p[i] <- '_';

    System.String (p)
  }

  fun_uniq_name (h : Fun_header) : string
  {
    mangle (h.name) + "_" + string_of_int (h.id)
  }

  decl_uniq_name (d : LocalValue) : string
  {
    mangle (d.name) + "_" + string_of_int (d.id)
  }

  make_closure_class (ctx : CTX, h : Fun_header) : CTX
  {
    def name = fun_uniq_name (h);
    def tb = ctx.current_type.GetTypeBuilder ().DefineNestedType 
                ("_N_cl_" + name, TypeAttributes.NestedAssembly, typeof (System.Object),
                 System.Type.EmptyTypes);
    Passes.cgil.RegisterAuxType (tb);
    def ctor = Passes.cgil.AddImplicitCtor (tb);
    
    def mk_clo_fld (acc : Int_map (FieldInfo), d : LocalValue) {
      def fi = tb.DefineField (decl_uniq_name (d), cg_type (ctx, d.ty), FieldAttributes.FamORAssem);
      acc.add (d.id, fi)
    };
    def closure_fields = List.fold_left (mk_clo_fld, ctx.closure_fields, h.closure_vars);
    def cloexpr = CE_call (CE_ctor_ref (ctor), []);
    def cloval = CG_val (h.loc, "_N_closure", tb, cloexpr);
    def cgm = get_cg_method (ctx, h);
    cgm.closure_type <- tb;
    def ctx = copy_ctx (ctx);
    ctx.closure_fields <- closure_fields;
    ctx.current_closure <- Some (cloval);
    ctx
  }

  prepare_ctx_for_fun (ctx : CTX, h : Fun_header) : CTX
  {
    def ctx =
      match (h.closure_vars) {
        | [] => 
          def ctx = copy_ctx (ctx);
          ctx.current_closure <- None ();
          ctx

        | _ =>
          make_closure_class (ctx, h)
      };
   
    def cgm = get_cg_method (ctx, h);
    ctx.closure_ptrs <- cgm.closure_pointers;
    ctx.locals <- Map.int_map ();
    ctx.current_fun <- h;
    ctx
  }

  get_parents_with_closures (_ctx : CTX, h : Fun_header) : list (Fun_header)
  {
    def parents =
      match (h.decl.kind) {
        | D_local_fun (_, pars) => pars
        | _ => Util.ice ()
      };
    def loop (acc, fh : Fun_header) {
      match (fh.closure_vars) {
        | _ :: _ => fh :: acc
        | [] => acc
      }
    };
    List.fold_left (loop, [], parents)
  }

  get_lambda_ctor (ctx : CTX, h : Fun_header) : ConstructorInfo
  {
    def cg_method = get_cg_method (ctx, h);
    when (cg_method.lambda_ctor == null) {
      def name = fun_uniq_name (h);
      def real_parm_cnt = List.length (cg_method.parms);
      def virtual_parm_cnt =
        match (Tyutil.fun_type (h)) {
          | T_fun (args, _) => 
            List.length (Tyutil.fun_args (args))
          | _ => Util.ice ()
        };
      
      // first create type builder
      def impl =
        if (virtual_parm_cnt == 1)
          mkarray [function_type (1)]
        else
          mkarray [function_type (virtual_parm_cnt); function_type (1)];
      def tb = ctx.current_type.GetTypeBuilder ().DefineNestedType 
                  ("_N_lm_" + name, TypeAttributes.NestedAssembly, typeof (System.Object),
                   impl);
      Passes.cgil.RegisterAuxType (tb);
      cg_method.lambda_type_builder <- tb;

      when (virtual_parm_cnt != real_parm_cnt) {
        assert (real_parm_cnt == 1);
        Passes.cgil.AddMethod (make_untupled_method (ctx, virtual_parm_cnt), tb);
      };
      
      // and then constructor
      def mkparm (acc, fh : Fun_header) {
        def (assigns, vals, ptrs) = acc;
        def cgm = get_cg_method (ctx, fh);
        assert (cgm.closure_type != null);
        def name = fun_uniq_name (fh);
        
        def fld = 
          tb.DefineField (name, cgm.closure_type, FieldAttributes.Private);
          
        def val =
          CG_val (loc = fh.loc, name = name, ty = cgm.closure_type,
                  val = CE_none ());
        
        def assign =
          CE_assign (CE_field_ref (CE_this (), fld), CE_ref (val));

        (assign :: assigns, val :: vals, (ptrs : Int_map (FieldInfo)).add (fh.id, fld))
      };

      def (assigns, vals, ptrs) = 
        List.fold_left (mkparm, ([], [], Map.int_map ()), 
                        get_parents_with_closures (ctx, h));

      def ctor_cgm = CG_method ();
      ctor_cgm.parms <- List.rev (vals);
      ctor_cgm.modifiers <- [Mod_internal ()];
      ctor_cgm.body <- CE_sequence (assigns);

      cg_method.closure_pointers <- ptrs;
      Passes.cgil.AddConstructorBuilder (ctor_cgm, tb);
      Passes.cgil.EmitConstructor (ctor_cgm);
      cg_method.lambda_ctor <- ctor_cgm.constructor_builder;
    };
    cg_method.lambda_ctor
  }

  emit_lambda_code (ctx : CTX, fh : Fun_header, body : Expr) : void
  {
    ignore (get_lambda_ctor (ctx, fh));
    def ctx = prepare_ctx_for_fun (ctx, fh);
    def cgm = get_cg_method (ctx, fh);
    List.iter (fun (parm : CG_val) { parm.ty <- typeof (System.Object) }, cgm.parms);
    cgm.ret_type <- typeof (System.Object);
    
    def parm_cnt = List.length (cgm.parms);
    cgm.implemented_methods <- [get_apply_method (parm_cnt)];
    cgm.modifiers <- [Mod_internal ()];
    
    Passes.cgil.AddMethodBuilder (cgm, cgm.lambda_type_builder);

    cg_fun_body (ctx, fh, body);
    
    Passes.cgil.EmitMethod (cgm);
    
    when (parm_cnt != 1)
      Passes.cgil.AddMethod (make_tupled_method (ctx, parm_cnt), cgm.lambda_type_builder);
  }

  make_lambda_ctor_call (ctx : CTX, fh : Fun_header) : CG_expr
  {
    def ctor = get_lambda_ctor (ctx, fh);
    def parms = get_parents_with_closures (ctx, fh);
    def parms' = List.map (fun (x) { closure_ref (ctx, x) }, parms);
    CE_call (CE_ctor_ref (ctor), parms')
  }

  cg_fun_body (ctx : CTX, hd : Fun_header, body : Expr) : void
  {
    def ctx' = copy_ctx (ctx);
    mutable assigns <- [];
    mutable vals <- [];
    
    def loadparm (parm_val : CG_val, fp : Fun_parm) {
      def parm = fp.decl;
      def needed_type = cg_type (ctx, parm.ty);

      if (parm.in_closure) {
        def a =
          CE_assign (local_ref (ctx, parm), 
                     maybe_cast (ctx, needed_type, CE_ref (parm_val)));
        assigns <- a :: assigns
      } else {
        def v =
          if (needed_type.FullName == parm_val.ty.FullName)
            parm_val
          else {
            def v = CG_val (loc = fp.decl.loc, 
                            name = Util.tmpname (parm_val.name),
                            ty = needed_type, 
                            val = CE_cast (CE_ref (parm_val), needed_type));
            vals <- v :: vals;
            v
          };
        ctx'.locals <- ctx'.locals.add (parm.id, v)
      }
    };

    def store_this (d : LocalValue) : void {
      match (d.kind) {
        | D_closurised_this_ptr =>
          when (d.in_closure) {
            assigns <- CE_assign (local_ref (ctx, d), CE_this ()) :: assigns
          }
        | _ => ()
      }
    };

    def cgm = get_cg_method (ctx, hd);

    List.iter2 (loadparm, cgm.parms, hd.parms);
    List.iter (store_this, ctx.current_fun.closure_vars);
    
    def body = cg_expr (ctx', body);
    def buildlet (e : CG_expr, v : CG_val) : CG_expr { CE_let (v, e) };
    def body =
      List.fold_left (buildlet, 
                      CE_sequence (List.rev (body :: assigns)),
                      vals);

    def body =
      match (ctx.current_closure) {
        | Some (v) => CE_let (v, body)
        | None => body
      };

    def body =
      if (cgm.ret_type.FullName == "System.Object")
        box_value (body)
      else
        body;

    cgm.body <- body;
  }

  cg_global_fun (ctx : CTX, m : IMethod, body : Expr) : void
  {
    fixup_cg_method (m);
    def hd = m.GetHeader ();
    def ctx = prepare_ctx_for_fun (ctx, hd);
    cg_fun_body (ctx, hd, body)
  }
    
  public CompileMethod (meth : NemerleMethod) : void
  {
    match (meth.fun_body) {
      | FB_parsed_expr => Tyexpr.TypeMethod (meth)
      | _ => ()
    };
    
    Util.locate (meth.GetLocation (), fun () {
      match (meth.fun_body) {
        | FB_extern => ()
        | FB_compiled_expr => Util.ice ()
        | FB_parsed_expr => Util.ice ()

        | FB_typed_expr when Message.seen_error () =>
          // just skip it
          meth.fun_body <- FB_compiled_expr ()
          
        | FB_typed_expr (body) =>
          def ctx = empty_ctx ((meth.GetDeclaringTycon () :> Tyinfo));
          cg_global_fun (ctx, meth, body);
          // release memory for GC
          meth.fun_body <- FB_compiled_expr ();
          match (meth.GetFunKind ()) {
            | FK_bound_method (impl_list) =>
              def cgm = GetCgMethod (meth);

              Passes.cgil.EmitMethod (cgm);

              def tb = (meth.GetDeclaringTycon () :> Tyinfo).GetTypeBuilder ();

              def mkparm (ifp : CG_val, methp : CG_val) : CG_expr {
                CE_cast (CE_ref (ifp), methp.ty)
              };
              def make_impl_wrapper (impl_meth : IMethod) {
                def cgm' = build_cg_method (ctx, impl_meth);
                cgm'.body <- CE_call (CE_method_ref (CE_this (), meth.GetMethodBuilder ()),
                                      List.map2 (mkparm, cgm'.parms, cgm.parms));
                cgm'.name <- impl_meth.GetDeclaringTycon ().GetFullName () + "." + cgm.name;
                cgm'.implemented_methods <- [impl_meth];
                cgm'.modifiers <- [Mod_private ()];
                Passes.cgil.AddMethod (cgm', tb)
              };
              List.iter (make_impl_wrapper, impl_list)
              
            | FK_ctor =>
              Passes.cgil.EmitConstructor (GetCgMethod (meth))
              
            | _ => 
              Passes.cgil.EmitMethod (GetCgMethod (meth));
          }
        | FB_abstract => ()
      }
    })
  }

} // end module
} // end ns
