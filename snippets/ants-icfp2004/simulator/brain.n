/*
 * The Ants simulator
 *
 * BRAIN
 */
 
namespace Nemerle.Ants 
{ 
  using System;
  using System.IO;
  using Nemerle.Attributes;
  using Nemerle.Utility;
  using Nemerle.Collections;
  
  public variant Condition {
    | C_Friend                      /* cell contains an ant of the same color */
    | C_Foe                         /* cell contains an ant of the other color */
    | C_FriendWithFood              /* cell contains an ant of the same color carrying food */
    | C_FoeWithFood                 /* cell contains an ant of the other color carrying food */
    | C_Food                        /* cell contains food (not being carried by an ant) */
    | C_Rock                        /* cell is rocky */
    | C_Marker { marker : Marker; } /* cell is marked with a marker of this ant's color */
    | C_FoeMarker                   /* cell is marked with *some* marker of the other color */
    | C_Home                        /* cell belongs to this ant's anthill */
    | C_FoeHome                     /* cell belongs to the other anthill */
  }

  public type State = int;

  public variant Instruction {
    | I_Sense { sense_dir : SenseDirection; on_success : State; on_failure : State; cond : Condition; }
    | I_Mark { marker : Marker; next_state : State; }
    | I_Unmark { marker : Marker; next_state : State; }
    | I_PickUp { on_success : State; on_failure : State; }
    | I_Drop { next_state : State; }
    | I_Turn { left_or_right : LeftOrRight; next_state : State; }
    | I_Move { on_success : State; on_failure : State; }
    | I_Flip { dice : int; on_zero : State; on_not_zero : State; }
  }


  public class Brain
  {
    public this (brain_file_name : string)
    {
      m_instructions_count <- 0;
      
      try {
        m_brain_stream <-
          StreamReader (brain_file_name);
          
        create_brain ();
        
        read_brain ()      
      }
      catch {      
        | e : Exception =>
          assert (false, "Brain: failed to load the brain file: " + e.Message)
      }    
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */


    /**
     * Returns an instruction that has to be executed at a state
     */
    [Requires (state >= 0 && state < m_instructions_count)]
    public GetInstruction (state : State) : Instruction
    {
      m_instructions [state]
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    /// creates the instructions array
    private create_brain () : void
    {
      m_instructions <- array (10000)
    }


    /// reads the instructions from the brain file
    private read_brain () : void
    {
      read_brain_instruction (0)
    }


    /// reads a brain instruction
    private read_brain_instruction (index : int) : void
    {   
      match (get_next_line ()) {
        | Some (line) when line.Length > 0 =>
          def comment_index =
            line.IndexOf (';');
            
          def line =
            if (comment_index != -1)
              line.Substring (0, comment_index)
            else
              line;

          def instruction =
            parse_instruction (NString.Split (line, array [' ', '\t']));

          ++m_instructions_count;
          
          m_instructions [index] <- instruction;
          
          read_brain_instruction (index + 1)

        | _ => ()
      }
    }
  
  
    /// parses a brain instruction
    private parse_instruction (tokens : list <string>) : Instruction
    {
      def head = List.Head (tokens);
      def tail = List.Tail (tokens);
      
      def parse_sense_dir (sense_dir : string) : SenseDirection {
        | "here" | "Here" => SD_Here ()
        | "ahead" | "Ahead" => SD_Ahead ()
        | "leftahead" | "LeftAhead" => SD_LeftAhead ()
        | "rightahead" | "RightAhead" => SD_RightAhead ()
        | _ =>
          assert (false, "Brain: invalid sense direction token: '" + sense_dir + "'");      
      };

      def parse_int (some_string : string) : int
      {
        Int32.Parse (some_string)      
      };

      def parse_marker (marker : string) : Marker
      {
        Int32.Parse (marker)      
      };
      
      def parse_state (state : string) : State
      {
        Int32.Parse (state)      
      };
      
      def parse_condition (condition : string) : Condition
      {
        | "Friend" => C_Friend ()
        | "Foe" => C_Foe ()
        | "FriendWithFood" => C_FriendWithFood ()
        | "FoeWithFood" => C_FoeWithFood ()
        | "Food" => C_Food ()
        | "Rock" => C_Rock ()
        | "FoeMarker" => C_FoeMarker ()
        | "Home" => C_Home ()
        | "FoeHome" => C_FoeHome ()
        | _ =>
          assert (false, "Brain: invalid condition token: '" + condition + "'");              
      };
      
      def parse_turn (turn : string) : LeftOrRight
      {
        | "Left" => LR_Left ()
        | "Right" => LR_Right ()
        | _ =>
          assert (false, "Brain: invalid turn token: '" + turn + "'");              
      };
      
      match (head) {
        | "Sense"  =>
          match (tail) {
            | [sense_dir, on_success, on_failure, condition] =>
              I_Sense (parse_sense_dir (sense_dir),
                       parse_state (on_success),
                       parse_state (on_failure),
                       parse_condition (condition))

            | [sense_dir, on_success, on_failure, "Marker", marker] =>
              I_Sense (parse_sense_dir (sense_dir),
                       parse_state (on_success),
                       parse_state (on_failure),
                       C_Marker (parse_marker (marker)))
                       
            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
              
        | "Mark" =>
          match (tail) {
            | [marker, next_state] =>
              I_Mark (parse_marker (marker), 
                      parse_state (next_state))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | "Unmark" =>
          match (tail) {
            | [marker, next_state] =>
              I_Unmark (parse_marker (marker), 
                        parse_state (next_state))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | "PickUp" =>
          match (tail) {
            | [on_success, on_failure] =>
              I_PickUp (parse_state (on_success), 
                        parse_state (on_failure))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | "Drop" =>
          match (tail) {
            | [next_state] =>
              I_Drop (parse_state (next_state))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | "Turn" =>
          match (tail) {
            | [turn, next_state] =>
              I_Turn (parse_turn (turn), 
                      parse_state (next_state))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | "Move" =>
          match (tail) {
            | [on_success, on_failure] =>
              I_Move (parse_state (on_success), 
                      parse_state (on_failure))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | "Flip" =>
          match (tail) {
            | [dice, on_zero, on_not_zero] =>
              I_Flip (parse_int (dice), 
                      parse_state (on_zero),
                      parse_state (on_not_zero))

            | _ =>
              assert (false, "Brain: failed to parse the '" + head + "' instruction");
          }
        
        | _ =>
          assert (false, "Brain: invalid instruction token: '" + head + "'");      
      }
    }
  
  
    /// reads a line from the input file  
    private get_next_line () : option <string>
    {
      def line = 
        m_brain_stream.ReadLine ();
        
      if (line != null)
        Some (line)
      else
        None ()
    }
    
    
    /* -- PRIVATE FIELDS --------------------------------------------------- */
    
    private mutable m_instructions : array <Instruction>;
    private mutable m_instructions_count : int;
    private m_brain_stream : StreamReader;
  }
}

/*** END OF FILE ***/
