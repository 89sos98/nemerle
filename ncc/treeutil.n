(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Parsetree;
open Nemerle.Compiler.Treeutil;
open Nemerle.Collections;

namespace Nemerle.Compiler {

  class Treeutil
    {
      class Skip_recursion extends System.Exception 
        {
          this () {}
        }

      static ('a) decl_walk(tydecl_f : 'a * Type_decl -> 'a,
                         decl_f : 'a * Class_member -> void,
                         ctx : 'a,
                         tydecls : list (Type_decl)) : void =

        letfun do_tydecl(ctx : 'a, decl : Type_decl) : void =
          try
            Util.locate(decl#loc, fun () : void =>
              //let _ = Message.error("in: " + decl#name) in
              let ctx' = tydecl_f(ctx, decl) in
              match decl with [
                | TD_class (?ds) => do_decls(ctx', ds)
                | TD_interface (?ds) => do_decls(ctx', ds)
                | TD_variant (?tds) => 
                  List.iter(fun (d : Type_decl) : void => do_tydecl(ctx', d), tds)
                | TD_variant_option (?ds) => do_decls(ctx', ds)
                | TD_alias => ()
                | TD_external => ()
              ])
          with ?x : Recovery => ()
        and do_decls(ctx : 'a, decls : list (Class_member)) : void =
          letfun do_decl (decl : Class_member) : void =
            try
              Util.locate(decl#loc, fun () : void => {
                //let _ = Message.error("ind: " + decl#name) in
                decl_f(ctx, decl);
                match decl with [
                  | M_type (?t) => do_tydecl(ctx, t)
                  | M_function => ()
                  | M_field => ()
                  | M_value => ()
                ]})
            with ?x : Recovery => ()
          in 
          List.iter(do_decl, decls)
        in
        List.iter(fun (d : Type_decl) : void => do_tydecl(ctx, d), tydecls);
   
      static ('a) pattern_fold (func : 'a * Pattern -> 'a, ini : 'a, pat : Pattern) : 'a =
        try
          try
            letfun self(ini : 'a, e : Pattern) : 'a = 
              pattern_fold(func, ini, e) 
            in
            let ini = func(ini, pat) in
            match pat with [
              | P_underscore => ini
              | P_variable => ini
              | P_tuple (?pts) => List.fold_left(self, ini, pts)
              | P_record (?pis) => 
                let mkpat = fun (x : Named_pattern) : Pattern => x#pat in
                List.fold_left(self, ini, List.map(mkpat, pis))
              | P_cons (_, ?a) => self(ini, a)
            ]
          with ?x : Skip_recursion => ini
        with ?x : Recovery => ini;
     
   
      static ('a) expr_walk (func : 'a * Expr -> 'a, ini : 'a, expr : Expr) : void =
         try
           Util.locate(expr#loc, fun () : void =>
            try
              let ini' = func(ini, expr) in
              letfun self(e : Expr) : void = expr_walk(func, ini', e) in
              match expr with [
                | E_ref => ()
                | E_this => ()
                | E_literal => ()
                | E_member (?e, _) => self(e)
                | E_call (?e, ?ps) =>
                    {
                      self(e);
                      List.iter(fun (p : Parm) : void => self(p#expr), ps)
                    }
                | E_assign (?e1, ?e2) => { self(e1); self(e2) }
                | E_let (_, _, ?e1, ?e2) => { self(e1); self(e2) }
                | E_letfun (?fs, ?e) =>
                    letfun do_fun(f : Function_decl) : void = self(f#body) in {
                      List.iter(do_fun, fs);
                      self(e)
                    }
                | E_lambda (?d) => self(d#body)
                | E_match (?e, ?mcs) =>
                    {
                      self(e);
                      List.iter(fun (m : Match_case) : void => self(m#body), mcs);
                    }
                | E_raise (?e) => self(e)
                | E_if (?e1, ?e2, ?e3) => { self(e1); self(e2); self(e3) }
                | E_try_with (?e1, _, _, ?e2) => { self(e1); self(e2) }
                | E_try_finally (?e1, ?e2) => { self(e1); self(e2) }
                | E_type_conversion (?e, _) => self(e)
                | E_type_enforcement (?e, _) => self(e)
                | E_sequence (?es) => List.iter(self, es)
                | E_tuple (?es) => List.iter(self, es)
              ]
            with ?x : Skip_recursion => ())
         with ?x : Recovery => ();

      static walk_all_types (func : Type -> void, decls : list (Type_decl)) : void =
        letfun do_tydecl(_ : int, decl : Type_decl) : int =
          let types =
            match decl#t_extends with [
              | Some (?t) => Cons (t, decl#t_implements)
              | None => decl#t_implements
            ]
          in {
            List.iter(func, types);
            List.iter (func, List.map (fun (c : Constraint) : Type => c#ty, decl#typarms#constraints));
            match decl with [
              | TD_alias (?t) => func (t)
              | _ => ()
            ];
            0
          }

        and do_expr(expr : Expr) : void =
          letfun f(_ : int, expr : Expr) : int {
            match expr with [
              | E_letfun (?fs, ?b) =>
                letfun do_fun (d : Function_decl) : void =
                  do_header (d#fun_header)
                in List.iter (do_fun, fs)
              | E_lambda (?d) => do_header (d#fun_header)
              | E_try_with ?x => func (x#exn_ty)
              | E_type_conversion ?x => func (x#ty)
              | E_type_enforcement ?x => func (x#ty)
              | _ => ()
            ]; 
            0 
          } in Treeutil.expr_walk(f, 0, expr)

        and do_header(h : Fun_header) : void =
          letfun doparm(p : Fun_parm) : void = func (p#ty) 
          in { 
            func (h#ret_type); 
            List.iter (func, List.map (fun (c : Constraint) : Type => c#ty, h#typarms#constraints));
            List.iter(doparm, h#parms) 
          }

        and do_decl(_ : int, decl : Class_member) : void =
          match decl with [
            | M_value (?t, _) => func (t)
            | M_field (?t, _) => func (t)
            | M_function (?h, _, ?b) => 
              {
                match b with [ FB_expr (?e) => do_expr (e) | _ => () ];
                do_header (h)
              }
            | M_type => ()
          ]
        in 
        Treeutil.decl_walk(do_tydecl, do_decl, 0, decls);
   }

  class Passes
    {
      static run(decls : list (list (Top_decl))) : void =
        let _ = Env.globals <- Map.string_map() in
        let dd = List.map(Scan_globals.run, decls) in
        let decls = List.concat(dd) in {
          Tyinfo.make (decls);
          Bind_types.run (decls);
          Tyinfo.fill (decls);
          Check_constraints.run (decls);
          Tyexpr.run (decls);
    //      let _ = CGexpr.run (decls) in ()
        };
    }

} // N.C
