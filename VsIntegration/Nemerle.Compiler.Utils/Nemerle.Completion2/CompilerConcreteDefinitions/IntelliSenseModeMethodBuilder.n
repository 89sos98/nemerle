using System;
using Nemerle.Assertions;
using Nemerle.Compiler;
using Nemerle.Utility;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using System.Diagnostics;
using Nemerle.Compiler.Utils;

using Typed = Nemerle.Compiler.Typedtree;
using SR = System.Reflection;
using SCG = System.Collections.Generic;

namespace Nemerle.Completion2.Factories
{
  public class IntelliSenseModeMethodBuilder : MethodBuilder
  {
    protected new Manager         : Engine { get { base.Manager :> Engine } }
		public        TypeTreeVersion : int    { get; private set; }

    public this (par : TypeBuilder, functionAst : ClassMember.Function)
    {
      this (par, functionAst, false);
    }

    public this (par : TypeBuilder, functionAst : ClassMember.Function, is_property : bool)
    {
      base (par, functionAst, is_property);
      //_bodyTokens = functionAst.Tokens; // токены портятся при парсинга, а теперь мы парсим тела методов при построении дерева типов. Так что не запоминаем их.
      TypeTreeVersion = Manager.TypeTreeVersion;
    }
    
    public override Body : PExpr 
    {
      get { base.Body }      
      set { ResetCodeCache(); SetBodyParsed(value); }
    }
    
    public override EnsureCompiled() : void
    {
      unless (BodyLocation.FileIndex > 0 && this.Attributes %&& NemerleAttributes.Abstract)
        _ = BodyTyped;
    }
  
    mutable _bodyMessages : SCG.List[CompilerMessage];
    public override BodyMessages : SCG.List[CompilerMessage]
    {
      get
      {
        Debug.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        when (_bodyMessages == null)
          _bodyMessages = SCG.List();
  
        _bodyMessages
      }
    }
  
    public override ResetCodeCache () : void
    {
      when (_bodyMessages != null && !_bodyTyping)
        _bodyMessages.Clear();
  
      _bodyTokens     = null;
      _bodyParsed     = null;
      _bodyTyped      = null;
      fun_header.body = null;
    }
  
    mutable _bodyTokens : Token.BracesGroup;
  
    //mutable _indent : string = "";
  
    /// The method body tokens. 
    public override BodyTokens : Token.BracesGroup
    {
      get
      {
        ManagerClass.Instance = Manager;
        //Trace.WriteLine($"$_indent>>>> ##### BodyTokens ($Name)!");
        Debug.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        when (_bodyTokens == null)
        {
          //def indent = _indent; _indent += "  ";
          Manager.SetCompiletMessages(this, BodyMessages);
          _bodyTokens = PreParseMethodBody (this);
          //_indent = indent;
        }
  
        //Trace.WriteLine($"$_indent<<<< ##### BodyTokens ($Name)!");
        _bodyTokens
      }
  
      set { ResetCodeCache(); _bodyTokens = value; }
    }
    
    SetBodyParsed(mutable bodyParsed : PExpr) : void
    {
      ManagerClass.Instance = Manager;
      // Do all transform of method body.
      when (BeforeBodyTyping != null)
        foreach (handler in BeforeBodyTyping)
          bodyParsed = handler(this, bodyParsed);

      _bodyParsed = bodyParsed;

      fun_header.body = FunBody.Parsed (_bodyParsed);
    }
  
    mutable _bodyParsed : PExpr;
  
    /// The method body parsed expressions. 
    public override BodyParsed : PExpr
    {
      get
      {
        ManagerClass.Instance = Manager;
        //Trace.WriteLine($"$_indent>>>> ##### BodyParsed ($Name)!");
        Debug.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        when (_bodyParsed == null)
        {
          // Теперь тела методв парсятся при построении дерева типов, так что если в fun_header.body
          // находится FunBody.Parsed, то берем PExpr из него.
          // if (Location.IsGenerated && !fun_header.Name.OrdinalStartsWith("_N_field_initialiser"))
          match (fun_header.body)
          {
            | FunBody.Parsed(code) => Body = code;
            | _ =>
              //def indent = _indent; _indent += "  ";
              Manager.SetCompiletMessages(this, BodyMessages);

              try
              {
                SetBodyParsed(MainParser.ParseFunctionBody (Env, Ast.header, BodyTokens));
              }
              finally { Manager.SetCompiletMessages(null, null); } // reset!
              //_indent = indent;
          }
          _bodyTokens = null;
        }
  
        //Trace.WriteLine($"$_indent<<<< ##### BodyParsed ($Name)!");
        _bodyParsed
      }
    }
  
    public override IsBodyCompilable : bool
    {
      get
      {
        def res = HasAbstractBody //|| BodyLocation.IsGenerated 
          || BodyLocation.FileIndex <= 0
          || Attributes %&& NemerleAttributes.Abstract
          //|| Attributes %&& NemerleAttributes.SpecialName
          ;
        !res
      }
    }
  
    mutable _bodyTyped  : TExpr;
    mutable _bodyTyping : bool;
  
    /// The method body parsed expressions. 
    public override BodyTyped : TExpr
    {
      get
      {
        _bodyTyping = true;
        ManagerClass.Instance = Manager;
        Manager.CheckSolver();
        //Trace.WriteLine($"$_indent>>>> ##### BodyTyped ($Name)!");
        Debug.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        when (_bodyTyped == null)
        {
          //def indent = _indent; _indent += "  ";
          _ = BodyParsed; // Use side affect
          Manager.SetCompiletMessages(this, BodyMessages);
          try
          {
            //Manager.Solver.CurrentMessenger.NeedMessage = false;
            RunBodyTyper();
            when (fun_header.body != null)
              _bodyTyped = (fun_header.body :> FunBody.Typed).expr;
          }
          catch 
          { | e => BodyMessages.Add(CompilerMessageForMethod(BodyLocation,  
                    $"Exception:$(e.Message)", MessageKind.Error, this));
          }
          finally 
          {
            _bodyTyping = false;
            Manager.ReportMemberErrors(this);
            Manager.SetCompiletMessages(null, null); // reset!
          }
          //_indent = indent;
        }
  
        //Trace.WriteLine($"$_indent<<<< ##### BodyTyped ($Name)!");
        _bodyTyped
      }
    }
    
    PreParseMethodBody (method : MethodBuilder) : Token.BracesGroup
    {
      def reportError(e, msg)
      {
        Trace.WriteLine($"$msg method body of:");
        Trace.WriteLine($"\t$method");
        Trace.WriteLine( "\tfailed.");
        Trace.WriteLine($"\tError: $(e.Message)");
      }

      def loc      = method.BodyLocation;
      def engine = Manager;
      def bodyCode =
        if (loc == Location.Default)
          "{}"
        else try   { engine.ProjectSources.GetSource(loc.File).GetRegion(loc); }
             catch { e => reportError(e, "Try get"); "{}" }; // return empty body!

      try
      {
        def lexer     = LexerString(engine, bodyCode, loc);
        def preparser = PreParser(lexer, method.Env);

        preparser.PreParse()
      }
      catch 
      { e =>
        reportError(e, "Try to compile");
        Token.BracesGroup(null)
      } // return empty body!
    }
  } // class
} // namespace
