//
// CodeCompletionEngine.n
//
// Author:
//  Alejandro Serrano (trupill at yahoo dot es)
//

/*
 * Copyright (c) 2005-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using Nemerle.Assertions;
using Nemerle.Compiler;
using Nemerle.Utility;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using System.Diagnostics;

using Typed = Nemerle.Compiler.Typedtree;
using SR = System.Reflection;
using SCG = System.Collections.Generic;

namespace Nemerle.Compiler
{
  // Relocation
  public interface ISupportRelocation
  {
    RelocateImpl (info : RelocationInfo/*, ident : string*/) : void;
  }

  //[Record(Exclude = [VisitedObjects])]
  public class RelocationInfo
  {
    public this(fileIndex : int, line : int, ch : int, lineOffset : int, charOffset : int)
    {
      this.VisitedObjects = Hashtable();
      this.CharOffset     = charOffset;
      this.LineOffset     = lineOffset;
      this.Char           = ch;
      this.Line           = line;
      this.FileIndex      = fileIndex;
    }

    public VisitedObjects : Hashtable[object, byte];
    public FileIndex      : int;
    public Line           : int;
    public Char           : int;
    public LineOffset     : int;
    public CharOffset     : int;

    //public mutable VisitCount  : int;
    //public mutable NodeCount  : int;
    
    override public ToString() : string
    {
      $"FileIndex=$FileIndex Line=$Line Char=$(this.Char) LineOffset=$LineOffset CharOffset=$CharOffset"
    }
  }
  
  public module Completion
  {
    /// Shift Location.
    public Relocate (loc : Location, info : RelocationInfo) : Location
    {
      def relocatePoint (oldLn, oldCh, info, ch)
      {
        if (oldLn > info.Line)
          (oldLn + info.LineOffset, oldCh)
        else if (oldLn == info.Line && oldCh >= ch)
          (oldLn + info.LineOffset, oldCh + info.CharOffset)
        else
          (oldLn, oldCh) 
      }

      if (loc.FileIndex == info.FileIndex)
      {
        def (newLn, newCh)       = relocatePoint(loc.Line,    loc.Column,    info, info.Char);// + 1
        def (newEndLn, newEndCh) = relocatePoint(loc.EndLine, loc.EndColumn, info, info.Char);

        Location (loc, newLn, newCh, newEndLn, newEndCh);
      }
      else
        loc
    }
    
    /// Shift Location.
    public RelocateFile (loc : Location, info : RelocationInfo) : Location
    {
      if (loc.FileIndex == info.FileIndex)
        Relocate (loc, info)
      else
        loc
    }

    /// Shift Location.
    public Relocate (loc : Location, line : int, ch : int, lineOffset : int, chOffset : int) : Location
    {
      def relocatePoint (oldLn, oldCh, line, ch, lineOffset, chOffset)
      {
        if (oldLn > line)
          (oldLn + lineOffset, oldCh)
        else if (oldLn == line && oldCh >= ch)
          (oldLn + lineOffset, oldCh + chOffset)
        else
          (oldLn, oldCh) 
      }

      def (newLn, newCh)       = relocatePoint(loc.Line,    loc.Column,    line, ch, lineOffset, chOffset); // + 1
      def (newEndLn, newEndCh) = relocatePoint(loc.EndLine, loc.EndColumn, line, ch, lineOffset, chOffset);

      Location (loc.FileIndex, newLn, newCh, newEndLn, newEndCh);
    }
    
    CmpOptions = System.StringComparison.InvariantCultureIgnoreCase;

    /// extract information about types/namespaces and add it to 'elems' list.
    public AddTypesAndNamespaces (
      [NotNull] elems : SCG.List[Elem],
      [NotNull] nss : list [NamespaceTree.Node],
      obj : PExpr, // nullable
      [NotNull] name : Parsetree.Name,
      noMacros : bool) : void
    {
      def prefix = name.Id;
      def isAll = string.IsNullOrEmpty(prefix); // don't use prefix
      // scan namespace tree node and add appropriate nodes into 'elems' list.
      def scanAndAdd (subNode : NamespaceTree.Node)
      {
        when (subNode.Children != null)
          foreach (elem when isAll || elem.Key.StartsWith(prefix, CmpOptions) in subNode.Children)
          {
            def name = elem.Key;
            def node = elem.Value;

            match (node.Value)
            {
              | No => ()
              | MacroCall(macr) => 
                when (!noMacros)
                  elems.Add(Elem.Node (
                    if (macr.Keywords.IsEmpty) node.PartName else macr.Keywords.Head,
                    node));
              
              | _ => elems.Add(Elem.Node (name, node));
            }
          }
        
        subNode.EnsureCached ();

        def scanStaticMembers (ti)
        {
          foreach (member in ti.GetMembers (BindingFlags.Public | BindingFlags.Static))
            when (isAll || member.GetName().StartsWith(prefix, CmpOptions))
              elems.Add(Elem.Member (member));
        }

        match (subNode.Value)
        {
          | Cached(ti)                 => scanStaticMembers (ti)
          | CachedAmbiguous(typeInfos) =>
            foreach (ti in typeInfos)
              scanStaticMembers (ti);

          | _                          => ()
        }

      }

      if (obj is null)
        foreach (subNode in nss)
          scanAndAdd (subNode)
      else match (Util.QidOfExpr (obj)) // extract list of name parts from expression
      {
        | Some ((nameParts, _)) => 
          match (NamespaceTree.Node.PassTo (nss, nameParts)) // open node
          {
            | null => ()
            | subNode => scanAndAdd (subNode)
          }
        | None => ()
      }
    }

    public GetName (this member : IMember) : string
    {
      match (member.MemberKind)
      {
        | Constructor => ReplaceSpecialName (member.DeclaringType.Name)
        | _ => member.Name
      }
    }

    /// Look for special names
    public ReplaceSpecialName(name : string) : string
    {
      | "Nemerle.Core.list" 
      | "Nemerle.Core.list+Cons" 
      | "Nemerle.Core.list+Nil"  => "list"
      | "System.Byte"            => "byte"
      | "System.SByte"           => "sbyte"
      | "System.Int16"           => "short"
      | "System.UInt16"          => "ushort"
      | "System.Int32"           => "int"
      | "System.UInt32"          => "uint"
      | "System.Int64"           => "long"
      | "System.UInt64"          => "ulong"
      | "System.Single"          => "float"
      | "System.Double"          => "double"
      | "System.Decimal"         => "decimal"
      | "System.String"          => "string"
      | "System.Object"          => "object"
      | "System.Boolean"         => "bool"
      | "System.Char"            => "char"
      | _                        => name
    }
  }
}
