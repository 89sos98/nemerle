(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Collections;
open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

module Parser {

  class CTX {
    public lexer : ILexer;
    public mutable last_token : Token;
    public mutable push_back : option (Token);
  }

  'a where 'a :> Located 
  opt_locate (ctx : CTX, f : void -> option ('a)) : option ('a) {
    def loc = ctx.lexer.get_location ();
    def ret = Util.locate (loc, f);
    match (ret) {
      | Some (x) => x.loc <- loc
      | None => ()
    };
    ret
  }

  get_token (ctx : CTX) : Token { 
    match (ctx.push_back) {
      | Some (x) =>
        ctx.push_back <- None ();
        x
      | None =>
        ctx.last_token <- ctx.lexer.get_token ();
        ctx.last_token
    }
  }

  push_back (ctx : CTX) : void {
    match (ctx.push_back) {
      | Some => Util.ice ()
      | None =>
        ctx.push_back <- Some (ctx.last_token)
    }
  }

  location (ctx : CTX) : Location {
    ctx.lexer.get_location ()
  }

  'a fatal_error (ctx : CTX, msg : string) : 'a {
    Message.fatal_error (location (ctx), "parse error: " + msg)
  }

  error (ctx : CTX, msg : string) : void {
    Message.error (location (ctx), "parse error: " + msg)
  }

  get_qid (ctx : CTX) : string {
    def loop (acc) {
      match (get_token (ctx)) {
        | Tok_operator (".", _) =>
          match (get_token (ctx)) {
            | Tok_identifier (x) => loop (acc + "." + x)
            | _ => fatal_error (ctx, "expecting identifier after dot in qualified ID")
          }
        | _ =>
          push_back (ctx);
          acc
      }
    };

    match (get_token (ctx)) {
      | Tok_identifier (x) =>
        loop (x)
      | _ =>
        fatal_error (ctx, "expecting qualified identifier")
    }
  }
  
  expect_operator (ctx : CTX, op : string) : void {
    match (get_token (ctx)) {
      | Tok_operator (o, _) when op == o => ()
      | _ =>
        fatal_error (ctx, "expecting '" + op + "'");
    }
  }


  parse_type_member (ctx : CTX) : option (Class_member) { null
  }

  parse_type (ctx : CTX) : Type { null }

  get_attrs (ctx : CTX) : list (Modifier) { [] }
  
  parse_type_decl (ctx : CTX) : option (Type_decl) {
    def parse_header () {
      (null : Type_decl_base)
    };
    
    def parse_variant_member (_) { null };
    def parse_iface_member (_) { null };
    
    def parse_members () {
      expect_operator (ctx, "{");
      def ret = collect_list (ctx, parse_type_member);
      expect_operator (ctx, "}");
      ret
    };
  
    def attrs = get_attrs (ctx);
    def tok = get_token (ctx);
    opt_locate (ctx, fun () {
      match (tok) {
        | Tok_keyword ("type")
        | Tok_keyword ("class")
        | Tok_keyword ("struct")
        | Tok_keyword ("module")
        | Tok_keyword ("interface")
        | Tok_keyword ("variant") =>
          def header = parse_header ();
          def (attrs, td) =
            match (tok) {
              | Tok_keyword ("class") =>
                (attrs, TD_class (parse_members ()))
              | Tok_keyword ("struct") =>
                (Mod_struct () :: attrs, TD_class (parse_members ()))
              | Tok_keyword ("module") =>
                (Mod_module () :: attrs, TD_class (parse_members ()))
              | Tok_keyword ("type") =>
                expect_operator (ctx, "=");
                match (get_token (ctx)) {
                  | Tok_keyword ("extern") =>
                    match (get_token (ctx)) {
                      | Tok_string_literal (s) => 
                        expect_operator (ctx, ";");
                        (attrs, TD_external (s))
                      | _ => 
                        fatal_error (ctx, "expecting quoted type name after `extern'")
                    }
                    
                  | _ =>
                    push_back (ctx);
                    def t = parse_type (ctx);
                    expect_operator (ctx, ";");
                    (attrs, TD_alias (t))
                }
                
              | Tok_keyword ("interface") =>
                expect_operator (ctx, "{");
                def decls = collect_list (ctx, parse_iface_member);
                expect_operator (ctx, "}");
                (attrs, TD_interface (decls))
                
              | Tok_keyword ("variant") =>
                expect_operator (ctx, "{");
                def decls = collect_list (ctx, parse_variant_member);
                expect_operator (ctx, "}");
                (attrs, TD_variant (decls))
             
              | _ => Util.ice ()
            };
            
          td.modifiers <- attrs;
          
          td.name <- header.name;
          td.typarms <- header.typarms;
          td.t_extends <- header.t_extends;
          td.t_implements <- header.t_implements;

          Some (td)
          
        | Tok_keyword ("macro") => Util.ice () // FIXME
        | _ => 
          None ()
      }
    })
  }

  parse_topdecl (ctx : CTX) : option (Top_decl) {
    def tok = get_token (ctx);
    opt_locate (ctx, fun () {
      match (tok) {
        | Tok_keyword ("open") =>
          def id = get_qid (ctx);
          expect_operator (ctx, ";");
          Some (TD_open (id))
          
        | Tok_keyword ("namespace") =>
          def id = get_qid (ctx);
          match (get_token (ctx)) {
            | Tok_operator ("=", _) =>
              when (id.IndexOf ('.') != -1) {
                Message.error ("namespace alias cannot contain dots")
              };
              def id' = get_qid (ctx);
              expect_operator (ctx, ";");
              Some (TD_namespace_alias (id, id'))
              
            | Tok_operator ("{", _) =>
              def decls = parse_topdecls (ctx);
              expect_operator (ctx, "}");
              Some (TD_namespace (id, decls))

            | _ =>
              fatal_error (ctx, "expecting '}' or '='")
          }

        | Tok_operator ("}", _) 
        | Tok_EOF =>
          push_back (ctx);
          None ()

        | _ =>
          push_back (ctx);
          match (parse_type_decl (ctx)) {
            | Some (r) => Some (TD_type (r))
            | None => None ()
          }
      }
    })
  }

  'a collect_list (ctx : CTX, f : CTX -> option ('a)) : list ('a) {
    def loop (acc) {
      match (f (ctx)) {
        | None => List.rev (acc)
        | Some (x) => loop (x :: acc)
      }
    };
    loop ([])
  }

  parse_topdecls (ctx : CTX) : list (Top_decl) {
    collect_list (ctx, parse_topdecl)
  }
  
  public parse (lexer : ILexer) : list (Top_decl) {
    def ctx = CTX (lexer = lexer,
                   last_token = null, 
                   push_back = None ());
    parse_topdecls (ctx)
  }

} // end module
} // end namespace
