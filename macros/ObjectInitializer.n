//
// Object Initializer Macro for Nemerle
// Copyright (c) 2011, Nemerle Project Team
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//     * Neither the name of the author nor the names of its contributors may be
//       used to endorse or promote products derived from this software without
//       specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;

[assembly: Nemerle.Internal.OperatorAttribute ("Nemerle.Extensions", "<-", false, 141, 140)]

namespace Nemerle.Extensions
{
  /// syntax is <[ obj <- { Foo = bar; ... } ]>
  /// or <[ obj <- ( Foo = bar, ... ) ]>
  /// or <[ obj <- [ foo, bar, ... ] ]>
  public macro @<-(obj, initializer)
  {
    WithMacroImpl.Run(obj, initializer);
  }

  internal module WithMacroImpl
  {
    public Run(obj : PExpr, initializer : PExpr) : PExpr
    {
      def (obj, name) = match(obj)
      {
        | <[ $obj as $(n : name) ]> => 
          //match(Macros.ImplicitCTX().LocalContext.FindLocal(n))
          //{
          //  | Some(localValue) when localValue.IsMutable =>
          //    Message.Hint(n.Location, $"case2, mutable variable name detected: $n");

          //  | _ =>
          //    Message.Hint(n.Location, $"case1, variable name detected: $n");
          //}
          //Message.Hint(n.Location, $"case1, variable name detected: $n");
          (obj, PExpr.Ref(n))

        | <[ $obj as $n ]> => 
          Message.Error(n.Location, $"variable name expected, but `$n' found");
          (obj, PExpr.Ref(Macros.NewSymbol("initializedObject")))
          
        | _ => (obj, PExpr.Ref(Macros.NewSymbol("initializedObject")))
      }
      
      def (statements, assignment) = 
        match (initializer)
        {
          | <[ ( ..$xs ) ]>
          | <[ { ..$xs } ]> => (MakePropertyInitializers(xs, name), <[ def $(name) = $(obj)]>)
          | <[ [ ..$xs ] ]> => (MakeCollectionInitializers(xs, name), <[ def $(name) = $(obj)]>)
          | <[ $_op($(PExpr.ToComplete(_)), $_) ]>
          | <[ $(PExpr.ToComplete(_)) =  $_ ]> 
          | <[ $_ =  $_ ]>        
          | <[ $_ += $_ ]>        
          | <[ $_ -= $_ ]>        
          | <[ $_ => $_ ]> 
          | <[ $_ ::= $_ ]> => (MakePropertyInitializers([initializer], name), <[ def $(name) = $(obj)]>)
          | _               => ([<[ $(obj) = $(name)]>], <[ def $(name) = $(initializer)]>)
        };
        
      <[
        $(assignment);
        {..$(statements)}
        $(name)
      ]>
    }

    private MakePropertyInitializers(elements : list[PExpr], name : PExpr) : list[PExpr]
    {
      def createAssignment(elem)
      {
        // completion support
        | PExpr.ToComplete(n)
        | <[ $_op($(PExpr.ToComplete(n)), $_val) ]>
        | <[ $(PExpr.ToComplete(n)) =  $_val ]> => <[ $name.$(Splicable.HalfId(n.Location, n)) ]>
//      | <[ $(_) = $(PExpr.ToComplete(n)) ]>   => ???????
        | <[ $(prop : name) =    $val ]>        => <[ $name.$(prop : name) =  $val ]>
        | <[ $(prop : name) +=   $val ]>        => <[ $name.$(prop : name) += $val ]>
        | <[ $(prop : name) -=   $val ]>        => <[ $name.$(prop : name) -= $val ]>
        | <[ $(prop : name) =>   $val ]>        => <[ $name.$($"add_$(prop.Id )" : usesite) ((_) => $val) ]>
        | <[ $(prop : name) ::=  $val ]>        => <[ _ = $name.$(prop : name).AddRange($val) ]>
        | <[ @<-($(prop : name), $val) ]>       => <[ _ = $(Run(<[ $name.$(prop : name) ]>, val))]>          
        | <[ _ = $(met : name) (..$parms) ]>    //todo allow return
        | <[     $(met : name) (..$parms) ]>    => <[ _ = $name.$(met : name) (..$parms) ]>
        | _ =>
          Message.Error($"Unrecognized syntax $(elem.ToString()) for a property initializer.");
          <[ () ]>
      }
      def createLocatedAssignment(elem)
      {
        Util.locate(elem.Location, createAssignment(elem));
      }
      elements.Map(createLocatedAssignment)
    }

    private MakeCollectionInitializers(elements : list[PExpr], name : PExpr) : list[PExpr]
    {
      def createAssignment(elem)
      {
        | <[ $prop = $val ]> => <[ _ = $name.Add($prop, $val) ]> // works for some lists and most dictionaries
        | val                => <[ _ = $name.Add($val) ]> // works on both lists and dictionaries (through tuples)
      }
      def createLocatedAssignment(elem)
      {
        Util.locate(elem.Location, createAssignment(elem));
      }
      elements.Map(createLocatedAssignment)
    }
  }
}