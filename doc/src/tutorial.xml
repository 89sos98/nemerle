<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Don't Panic! - Nemerle for C# Programmers</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This tutorial will describe basics of programming in Nemerle. We assume
        the reader is familiar with C#.
      </p>
    </body>
  </section>


  <section id="simple">
    <title>Simple examples</title>
    <body>
      <p>
        This section lists simple example, that look almost the same as
        in C#.
      </p>
    </body>
    <subsection id="hello">
      <title>The very-first example</title>
      <body>
<code>
class Hello
{
  static Main () : void
  {
    System.Console.WriteLine ("Hello world!");
  }
}
</code>
        <p>
          As you can see the only difference between Nemerle and C#
          version of this program is that we write method's return type
          at the right, after colon. There are some reasons to do it this
          way, we will explain them in future.
        </p>
        <p>
          To run this example:
        </p>
        <ul>
          <li>
            write it with your favorite text editor and save it in 
            <file>hello.n</file>
          </li>
          <li>
            run the Nemerle compiler by typing <tt>ncc hello.n</tt>
          </li>
          <li>
            the output goes to <file>out.exe</file>
          </li>
          <li>
            run it by typing <tt>out</tt> or <tt>./out.exe</tt> depending
            on your OS
          </li>
        </ul>
        <p>
          For people unfamiliar with C#: the entry point of
          execution is the static <tt>Main</tt> method in some
          class. <tt>System.Console.WriteLine</tt> is call to function
          from the .NET framework.
        </p>
      </body>
    </subsection>
    <subsection id="adder">
      <title>The adder</title>
      <body>
        <p>
          We will now write a very simple program to read and add two numbers.
        </p>
<code>
/* Our second example.  This is a comment. */
// This is also a comment.

using System;

public class Adder      // As in C# we can mark class public.
{
  public static Main () : void          // And method too.
  {
    /* Read two lines, convert them to integers and return their
       sum.  */
    Console.WriteLine ("The sum is {0}", 
                       Int32.Parse (Console.ReadLine ()) + 
                       Int32.Parse (Console.ReadLine ()));
  }
}
</code>
        <p>
          The <tt>using</tt> declaration imports identifiers from
          specified namespace, so they can be used without prefix.
          Unlike in C# it can also import members from classes, not only
          from namespaces. For example:
        </p>
<code>
using System;
using System.Console;

public class Adder
{
  public static Main () : void
  {
    WriteLine ("The sum is {0}", 
               Int32.Parse (ReadLine ()) + 
               Int32.Parse (ReadLine ()));
  }
}
</code>
        <p>
          As you can see for both lines we first read them and then
          convert to integer. We can factor this into a method:
        </p>
<code>
using System;

public class Adder
{
  // It is private by default.
  static ReadInteger () : int
  {
    Int32.Parse (Console.ReadLine ())
  }
  
  public static Main () : void
  {
    def x = ReadInteger (); // Variable definition.
    def y = ReadInteger ();
    // Use standard .NET function for formatting output.
    Console.WriteLine ("{0} + {1} = {2}", x, y, x + y);
  }
}
</code>
        <p>
          The method definition looks the way we would expect from
          <tt>Main</tt> example. However in <tt>Main</tt> itself we
          <b>define two values</b>: <tt>x</tt> and <tt>y</tt>. This is done
          using the <tt>def</tt> keyword. As you can see we do not write
          type of variable at the place of definition. The compiler sees
          that <tt>ReadInteger</tt> returns <tt>int</tt> and therefore
          type of <tt>x</tt> has to also be <tt>int</tt>. This is called
          <b>type inference</b>.
        </p>
        <p>
          In this example we see no gain from using <tt>def</tt> instead
          of <tt>int</tt> as you would do in C# (both are 3 characters long :-).
          However in most cases type names are far longer:
        </p>
<code>
FooBarQuxxFactory fact = new FooBarQuxxFactory (); // C#
def fact = FooBarQuxxFactory (); // Nemerle
</code>
        <p>
          As you can see we also do not use the <tt>new</tt> keyword.
        </p>
      </body>
    </subsection>
    <subsection id="read-file">
      <title>Couting lines in file</title>
      <body>
<code>
<![CDATA[class LineCounter
{
  public static Main () : void
  {
    def sr = System.IO.StreamReader ("SomeFile.txt");   // (1)
    mutable line_no <- 0;                               // (2)
    mutable line <- sr.ReadLine ();                     
    while (line != null) {              // (3)
      System.Console.WriteLine (line);
      line_no <- line_no + 1;           // (4)
      line <- sr.ReadLine ();
    };                                  // (5)
    System.Console.WriteLine ("Line count: {0}", line_no);
  }
}]]>
</code>
        <p>
          There are few remarkable things about this example. First one
          is the very important difference between lines marked (1) and
          (2).
        </p>
        <p>
          In (1) we define <b>immutable value</b> <tt>sr</tt>. Immutable means
          it cannot be changed once it is defined. This may first seem
          odd, but it is quite often that variables are never changed,
          once created. The <tt>def</tt> statement is there to mark this 
          intent.
        </p>
        <p>
          In (2) we define <b>mutable value</b>. This is the same thing as
          variable in C#, It has to be initialized before use and can be
          changed later. The assignment operator in Nemerle is called
          <tt>&lt;-</tt>. It works much like <tt>=</tt> in C#. We see
          its use in (4).
        </p>
        <p>
          In (3) we see the <b><tt>while</tt> loop</b>. It works much like
          in C#. We also have <tt>do ... while</tt> and <tt>repeat
          ... until</tt> loops in Nemerle. There is one slight difference
          between the <tt>while</tt> loop in Nemerle and C# -- as you
          see in (5) we need to put semicolon (<tt>;</tt>) after closing
          brace. This is general rule in Nemerle -- when expression is
          followed by some other expression in sequence, it need to be
          closed by semicolon.
        </p>
        <!-- This doesn't seem to help.
        <p>
          This is no mistake to call the <tt>while</tt> loop an
          expression. There is no such thing as statement in Nemerle,
          there are only expressions. It is perfectly valid to write:
        </p>
<code>
(if (foo) 1 else { while (qux) baz; 2 }) + 7
</code>
        <p>
          Each expression returns some value, although some expressions
          (like the <tt>while</tt> loop, <tt>def</tt> or <tt>mutable</tt>
          declarations, or an assignment operation) do not return
          any <b>useful</b> value. Such a value has type <tt>void</tt>,
          and you cannot do much with it.
        </p>
        -->
      </body>
    </subsection>
  </section>
  
  <section id="functional-style">
    <title>Functional examples</title>
    <body>
      <p>
        This section will introduce some more functional features
        of Nemerle.
      </p>
      <p>
        <b>Functional programming (FP)</b> is style in which you do not
        modify state of the machine with instructions, but rather evaluate
        functions yielding new and new values. That is entire program is
        just one big expression. In purely functional language (Haskell
        being main example) you cannot modify any objects once they are
        created (there is no assignment operator, like <tt>&lt;-</tt>
        in Nemerle). There are no loops, just recursive functions.
      </p>
      <p>
        Nemerle does not force you to use FP. However it makes it easy
        to use it when it's needed. Some algorithms have very natural
        representation when written in functional style -- for example
        functional languages are very good at manipulation of tree-like
        data structures (like XML, in fact XSLT can be thought of as a
        functional language).
      </p>
      <p>
        However at the begging we will use functional style to write
        simple programs, that could be written in imperative style
        without much problems.
      </p>
      <p>
        We will be using terms <b>method</b> and <b>function</b>
        interchangeably.
      </p>
    </body>
    
    <subsection id="read-file-half-func">
      <title>Rewriting line counter without the loop</title>
      <body>
        <p>
          We will now rewrite our <a ref="#read-file">previous example</a>
          not to use loops, just recursive function. It will get longer,
          but we will fix that soon.
        </p>
<code>
<![CDATA[class LineCounterWithoutLoop
{
  public static Main () : void
  {
    def sr = System.IO.StreamReader ("SomeFile.txt");
    mutable line_no <- 0;

    def read_lines () : void {            // (1)
      def line = sr.ReadLine ();
      when (line != null) {               // (2)
        System.Console.WriteLine (line);  // (3)
        line_no <- line_no + 1;           // (4)
        read_lines ()                     // (5)
      }
    };
    
    read_lines ();      // (6)
    
    System.Console.WriteLine ("Line count: {0}", line_no); // (7)
  }
}]]>
</code>
        <p>
          In (1) we define <b>nested method</b> called <tt>read_lines</tt>
          inside the <tt>Main</tt> method. The method is there to
          simulate the <tt>while</tt> loop from our previous example.
          It takes no parameters and returns void value.
        </p>
        <p>
          (2) If line wasn't <tt>null</tt> (i.e. it was not the last
          line), (3) we write the line we just read, (4) increase the
          line number, and finally (5) call ourself to read rest of the
          lines. The <tt>when</tt> expression is explained below.
        </p>
        <p>
          Next (6) we call <tt>read_lines</tt> for the first time,
          and finally (7) print the line count.
        </p>
        <p>
          The <tt>read_lines</tt> will get called as many times as there
          are lines in the file. As you can see this is the same as the
          <tt>while</tt> loop, just expressed in a slightly different way.
          It is very important to grok this concept of writing loops
          as recursion, in order to program functionally in Nemerle.
        </p>
        <p>
          If you are concerned about performance of this form of writing
          loops -- fear you not. When function body ends with call
          to another function -- no new stack frame is created. It is
          called <b>tail call</b>.  Thanks to it the example above is as
          efficient as the <tt>while</tt> loop we seen before.
        </p>
        <p>
          In Nemerle the <tt>if</tt> expression always need to have the
          <tt>else</tt> clause. If you do not want the <tt>else</tt> clause,
          use <tt>when</tt> expression, as seen in the example. There is
          also <tt>unless</tt> expression, equivalent to <tt>when</tt>
          with condition negated.
        </p>
      </body>
    </subsection>
    <subsection id="read-file-func">
      <title>Rewriting line counter without mutable values</title>
      <body>
        <p>
          Our <a ref="#read-file-half-func">previous aim</a> of rewriting 
          line counter removed the loop and one mutable value. However
          one mutable value has left, so we cannot say the example is written
          functionally. We will now kill it.
        </p>
<code>
<![CDATA[class FunctionalLineCounter
{
  public static Main () : void
  {
    def sr = System.IO.StreamReader ("SomeFile.txt");
    def read_lines (line_no : int) : int {   // (1)
      def line = sr.ReadLine ();
      if (line == null)      // (2)
        line_no              // (3)
      else {
        System.Console.WriteLine (line);  // (4)
        read_lines (line_no + 1)          // (5)
      }
    };
    
    System.Console.WriteLine ("Line count: {0}", read_lines (0)); // (7)
  }
}]]>
</code>
        <p>
          In (1) we again define nested method called <tt>read_lines</tt>.
          However this time it takes one integer parameter -- the current
          line number.  It returns number of lines in entire file.
        </p>
        <p>
          (2) If line we just read is <tt>null</tt> (that was last line),
          we (3) return the current line number as number of lines in
          entire file. As you can see there is <b>no <tt>return</tt>
          statement</b>. The return value of method is its last
          expression.
        </p>
        <p>
          (4) Otherwise (it was not last line) we write the line we just
          read. Next (5) we call ourself to read the next line. We need
          to increase line number, since it is next line what we will
          be reading. Note that as a return value from this invocation
          of <tt>read_lines</tt> we return what the next invocation of
          <tt>read_lines</tt> returned. It in turn returns what the next
          invocation returned and so on, until, at the end of file, we reach
          (3), and final line count is returned through each invocation
          of <tt>read_lines</tt>.
        </p>
        <p>
          In (7) we call the <tt>read_lines</tt> nested method, with
          initial line number of 0 to read the file and print
          out line count.
        </p>
      </body>
    </subsection>
  </section>
  
   <!--
     Describe:
       - type inference
       - variants and matching
       - functions as first class citizens
       - namespace aliases
       - continuation monad
   -->
  

    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
