/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler
{
  using Nemerle.Collections;
  using Nemerle.Utility;

  using System;
  using System.IO;
  using System.Reflection;
  using System.Reflection.Emit;
  using System.Runtime.InteropServices;
  using System.Diagnostics.SymbolStore;

  using Nemerle.Compiler.Typedtree;
  using Nemerle.Logging;

  using NC = Nemerle.Compiler;

  [assembly: LogFlag (EMIT, 0)]


  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  [ManagerAccess]
  class ILEmitter
  {
    private _module_builder : ModuleBuilder;
    private _ilg : NemerleGenerator;
    private _parent_type_builder : NC.TypeBuilder;

    private _this_is_value_type : bool;
    private _type_of_this : System.Type;

    private _method_name : string;
    private _method_builder : NC.MethodBuilder;
    private mutable _method_start_label : Label;
    private mutable _debug_doc : ISymbolDocumentWriter;
    private mutable _is_ctor   : bool;
    private mutable _is_lambda : bool;

    private _labels : Hashtable [int, Label] = Hashtable ();
    private _label_usage : Hashtable [int, TExpr] = Hashtable ();

    static MS_NET_RuntimeType : System.Type 
      = typeof (object).Assembly.GetType ("System.RuntimeType");

    /**
     * Creates and executes a code generator for a method
     */
    internal this (method_builder : NC.MethodBuilder)
    {
      Manager = method_builder.Manager;
      _method_builder = method_builder;
      def mbase = _method_builder.GetMethodBase ();

      _ilg = Late.late_macro (NemerleGenerator (mbase.GetILGenerator () :> ILGenerator));
      _module_builder = mbase.Module :> ModuleBuilder;
      _parent_type_builder = _method_builder.DeclaringType;

      _method_name = mbase.DeclaringType.TypeFullName () + "::" + mbase.Name;
      _this_is_value_type = _parent_type_builder.IsValueType;
      _type_of_this = _parent_type_builder.GetMemType ().GetSystemType ();
    }

    public Run () : void
    {
      _ilg.SetDocument (_debug_doc);

      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      match (_method_builder.GetHeader ().body) {
        | FunBody.Typed (body) =>

          _is_ctor   = is_ctor(_method_builder);
          _is_lambda = _method_builder.DeclaringType.is_lambda;

          _ilg.BeginScope ();
          emit (body);

          unless (body.Throws)
            _ilg.Emit (OpCodes.Ret);
          _ilg.EndScope ();

          // let GC take it
          _method_builder.GetHeader ().body = FunBody.ILed ();
        | _ => Util.ice ($"method $_method_name is already ILed")
      }
      
      _label_usage.Iter (fun (id, v : TExpr) {
        // shouldn't happen now
        when (v != null)
          Message.Error (v.Location, 
                         $ "non local goto (block return?) detected (l$id)");
      })
    }

    private is_always_true (expr : TExpr) : bool
    {
      | Literal (Literal.Bool (true)) => true

      | If (cond_expr, then_expr, else_expr, _, _) =>
        def cond_always_true  = is_always_true  (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_true  = is_always_true  (then_expr);
        def else_always_true  = is_always_true  (else_expr);
        
        cond_always_true && then_always_true ||
        cond_always_false && else_always_true
        // unsafe, cond can have side effects
        // then_always_true && else_always_true

      | _ => false
    }

    public SetDocument (loc : Location) : void
    {
      if (loc != Location.Default)
        _debug_doc = _module_builder.DefineDocument (Path.GetFullPath (loc.File), 
          SymDocumentType.Text, SymLanguageType.ILAssembly, SymLanguageVendor.Microsoft);
      else {
        Message.Warning ("missing debug location, this is probably some internal compiler error"); 
        def loc = Location_stack.top ();
        when (loc != Location.Default)
          SetDocument (loc);
      }
    }

    private is_always_false (expr : TExpr) : bool
    {
      | Literal (Bool (false)) => true

      | If (cond_expr, then_expr, else_expr, _, _) =>
        def cond_always_true  = is_always_true  (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_false = is_always_false (then_expr);
        def else_always_false = is_always_false (else_expr);

        cond_always_true && then_always_false ||
        cond_always_false && else_always_false
        // unsafe, cond can have side effects
        // then_always_false && else_always_false
        
      | _ => false
    }

    IsDebugEnabled : bool { get { _debug_doc != null } }


    /** Emit volatile prefix if needed. */
    private maybe_volatile (expr : TExpr) : void
    {
      | StaticRef (_, f is IField, _)
      | FieldMember (_, f) =>
        when (f.IsVolatile)
          _ilg.Emit (OpCodes.Volatile)
      | _ => ()
    }


    /** Box the value of type [t] if needed.  */
    need_reference (t : System.Type) : void
    {
      when (t.IsValueType || t.IsGenericParameter)
        _ilg.Emit (OpCodes.Box, t);
    }


    is_void (ty : TyVar) : bool
    {
      ty.Fix () : object == InternalType.Void
    }


    static is_ctor (meth : IMethod) : bool
    {
      meth.MemberKind == MemberKinds.Constructor
    }

    #region HACKS FOR MS.NET BUGS
    static GetHackishConstructor (_from_type : System.Type, ctr : ConstructorInfo) : ConstructorInfo 
    {
      def curtok = 
        if (ctr is ConstructorBuilder)
          typeof (ConstructorBuilder).GetProperty ("MetadataTokenInternal", BindingFlags.NonPublic | BindingFlags.Instance).GetValue (ctr, null) :> int;
        else 
          ctr.MetadataToken;

      res: {
        foreach (c in _from_type.GetConstructors (BindingFlags.NonPublic | BindingFlags.Public |
                                                  BindingFlags.Instance | BindingFlags.Static |
                                                  BindingFlags.DeclaredOnly))
          when (c.MetadataToken == curtok)
            res (c);
        throw System.Exception ($"not found: $ctr in $_from_type")
      }
    }

    static GetHackishMethod (_from_type : System.Type, meth : MethodInfo) : MethodInfo 
    {
      def curtok = 
        if (meth is Emit.MethodBuilder)
          typeof (Emit.MethodBuilder).GetProperty ("MetadataTokenInternal", BindingFlags.NonPublic | BindingFlags.Instance).GetValue (meth, null) :> int;
        else
          meth.MetadataToken;

      res: {
        foreach (m in _from_type.GetMethods (BindingFlags.NonPublic | BindingFlags.Public |
                                             BindingFlags.Instance | BindingFlags.Static |
                                             BindingFlags.DeclaredOnly))
          when (m.MetadataToken == curtok)
            res (m);
        throw System.Exception ($"not found: $meth in $_from_type")
      }
    }

    static GetHackishField (_from_type : System.Type, fld : FieldInfo) : FieldInfo 
    {
      def curtok = 
        if (fld is Emit.FieldBuilder)
          typeof (Emit.FieldBuilder).GetProperty ("MetadataTokenInternal", BindingFlags.NonPublic | BindingFlags.Instance).GetValue (fld, null) :> int;
        else
          fld.MetadataToken;

      res: {
        foreach (f in _from_type.GetFields (BindingFlags.NonPublic | BindingFlags.Public |
                                            BindingFlags.Instance | BindingFlags.Static |
                                            BindingFlags.DeclaredOnly))
          when (f.MetadataToken == curtok)
            res (f);
        throw System.Exception ($"not found: $fld in $_from_type")
      }
    }
    #endregion

    static FrameworkGetConstructor (t : System.Type, mutable m : ConstructorInfo) : ConstructorInfo
    {
      if (MS_NET_RuntimeType != null && t.GetType().Equals (MS_NET_RuntimeType))
        GetHackishConstructor (t, m);
      else {
        def td = t.GetGenericTypeDefinition ();
        when (MS_NET_RuntimeType != null && td.GetType().Equals (MS_NET_RuntimeType)) {
          m = GetHackishConstructor (td, m)
        }
        TypeBuilder.GetConstructor (t, m);
      }
    }

    static FrameworkGetMethod (t : System.Type, mutable m : MethodInfo) : MethodInfo
    {
      if (MS_NET_RuntimeType != null)
        if (t.GetType().Equals (MS_NET_RuntimeType))
          // workaround MS.NET limitation of not allowing RuntimeType in TypeBuilder.GetMethod   
          GetHackishMethod (t, m);
        else {
          def td = t.GetGenericTypeDefinition ();
          when (td.GetType().Equals (MS_NET_RuntimeType))
            m = GetHackishMethod (td, m);

          TypeBuilder.GetMethod (t, m);
        }
      else
        TypeBuilder.GetMethod (t, m);
    }

    static FrameworkGetField (t : System.Type, mutable m : FieldInfo) : FieldInfo
    {
      if (MS_NET_RuntimeType != null && t.GetType().Equals (MS_NET_RuntimeType))
        GetHackishField (t, m);
      else {
        def td = t.GetGenericTypeDefinition ();
        when (MS_NET_RuntimeType != null && td.GetType().Equals (MS_NET_RuntimeType)) {
          m = GetHackishField (td, m)
        }
        TypeBuilder.GetField (t, m);
      }
    }

    static GetConstructorInfo (_from_type : System.Type, meth : IMethod) : ConstructorInfo
    {
      mutable ctr_inf = meth.GetConstructorInfo ();
      when (_from_type.IsGenericType) {
        ctr_inf = FrameworkGetConstructor (_from_type, ctr_inf);
      }
      ctr_inf
    }

    // FIXME: get rid of this
    internal static GetMethodInfo (_from_type : MType, meth : IMethod) : MethodInfo
    {
      mutable meth_inf = meth.GetMethodInfo ();
      //Message.Debug ($"gmi: $_from_type $meth $(meth.GetHeader ().typarms)");
      //Message.Debug ($"gmi mi: $meth_inf");

      def _from_type = _from_type.Fix ().GetInstantiatedSuperType (meth.DeclaringType).GetSystemType ();

      when (_from_type.IsGenericType) {
        meth_inf = FrameworkGetMethod (_from_type, meth_inf);
      }
      //Message.Debug ($"gmi mi2: $meth_inf");

      meth_inf
    }

    
    static GetMethodInfo (from_type : TyVar, meth : IMethod, typars : list [TyVar]) : MethodInfo
    {
      mutable meth_inf = meth.GetMethodInfo ();

      //Message.Debug ($"gmi: $from_type $meth $(meth.GetHeader ().typarms) $typars");
      //Message.Debug ($"gmi mi: $meth_inf");

      def from_type = from_type.Fix ().GetInstantiatedSuperType (meth.DeclaringType);
      def system_from_type = from_type.GetSystemType ();

      when (system_from_type.IsGenericType)
        meth_inf = FrameworkGetMethod (system_from_type, meth_inf);
      //Message.Debug ($"gmi mi2: $meth_inf");

      def m_typarms = meth.GetHeader ().typarms;
      unless (m_typarms.IsEmpty) {
        def pars = array (typars.Length);
        _ = List.FoldLeft (typars, 0, fun (x, i) {
          pars [i] = x.GetNonVoidSystemType ();
          i + 1
        });
        def errs = Message.ErrorCount;
        List.Iter2 (m_typarms, typars, _.CheckConstraints (_, meth));
        when (errs == Message.ErrorCount)
          meth_inf = meth_inf.MakeGenericMethod (pars);
        // Message.Debug ($"res gmi: $meth_inf");
      }
      meth_inf
    }

    static GetFieldInfo (_obj : TExpr, fld : IField) : FieldInfo
    {
      def obj_type = _obj.MType().GetInstantiatedSuperType (fld.DeclaringType).GetSystemType ();
      GetFieldInfo (obj_type, fld);
    }
    
    
    static GetFieldInfo (_from_type : System.Type, meth : IField) : FieldInfo
    {
      mutable fld_inf = meth.GetFieldInfo ();
      when (_from_type.IsGenericType)
        fld_inf = FrameworkGetField (_from_type, fld_inf);

      fld_inf
    }
   
    
    store_local (decl : LocalValue) : void
    {
      if (decl.IsParm) {
        Util.cassert (! decl.IsByRefParm);
        store_argument (decl.ParmIndex)
      } else
        // simply skip assignment here
        unless (is_void (decl.Type))
          _ilg.Emit (OpCodes.Stloc, decl.LocalSlot);
    }


    emit_parms (parms : list [Parm]) : void
    {
      emit_exprs (parms.Map (_.expr));
    }

    static skipped (expr : TExpr) : void
    {
      | TExpr.Goto
      | TExpr.Literal (Literal.Void)
      | TExpr.Label (_, Literal (Void))
      | TExpr.DebugInfo (Literal (Void), null)
      | TExpr.DebugInfo (null, _) => ()
      | _ =>
        Message.Warning (expr.Location,
                         "this expression has been skipped in code "
                         "generation because of unreachable code");
        //Message.Warning (expr.loc, expr.ToString ());
    }

    static no_cast_needed (src_type : System.Type, target_type : System.Type) : bool
    {
      src_type : object == target_type
    }


    static make_ref_type (t : System.Type) : System.Type
    {
      t.MakeByRefType ()
    }

    private emit_tuple_function_conversion (after : MType, member_from : MType, member : IMember) : void
    {
      def interesting_part (t) {
        if (member is IMethod)
          match (t.Fix ()) {
            | MType.Fun (_, t) => t
            | _ => Util.ice ()
          }
        else t
      }

      def is_single_arg_function (t) {
        match (interesting_part (t).Fix ()) {
          | Fun (from, _) => ! (from.Fix () is MType.Tuple)
          | _ => false
        }
      }

      match (member_from) {
        | Class | Array | TyVarRef =>
          match (after) {
            | Fun (from, to) =>
              match (from.Fix ()) {
                | Tuple (parms) =>

                  // I think there is one more case
                  // class A[T] { x : T; }
                  // B[T] : A[T->void]
                  // C[T] : B[T*T]
                  // but this is really perverse

                  when (is_single_arg_function (member.GetMemType ()) ||
                        is_single_arg_function (member_from.TypeOfMember (member))) {

                    def ftn = InternalType.GetFunctionType (parms.Length);
                    def info =
                      if (to.Fix () is MType.Void) {
                        def mt = MType.Class (ftn.FromTupleVoidTyCon, parms);
                        GetConstructorInfo (mt.GetSystemType (), ftn.FromTupleVoidCtor)
                      } else {
                        def mt = MType.Class (ftn.FromTupleTyCon, parms + [to]);
                        GetConstructorInfo (mt.GetSystemType (), ftn.FromTupleCtor)
                      }
                    // Message.Warning ($ "using f1->fN conversion");
                    _ilg.Emit (OpCodes.Newobj, info)
                  }

                | _ => {}
              }
            | _ => {}
          }
        | _ => {}
      }
    }


    /**
     * Emits an expression.
     */
    private emit (expr : TExpr) : void
    {
      log (EMIT, $"{ emit: $expr");
      Util.cassert (expr != null);
      Util.locate (expr.Location,
      match (expr) {

        /* -- SEQUENCING --------------------------------------------------- */

        /* emits a sequence of expressions */
        | Sequence (e1, e2) =>
          emit (e1);
          if (!e1.Throws || e2.JumpTarget)
            emit (e2);
          else
            skipped (e2);

        | DefValIn (_, let_val, body) when let_val.Throws && ! body.JumpTarget =>
          emit (let_val);
          skipped (body);
        
        /* emits a local value definition */
        | DefValIn (decl, let_val, let_in) =>

          match (let_val) {
            | DefaultValue when !decl.IsMutable =>
              unless (is_void (decl.Type))
                declare_val_local_slot_ex (decl);

            | ImplicitValueTypeCtor =>
              def slot = declare_val_local_slot (decl);
              _ilg.Emit (OpCodes.Ldloca, slot);
              _ilg.Emit (OpCodes.Initobj, let_val.GetSystemType ());

            | _ =>
              emit (let_val);
              unless (is_void (decl.Type)) {
                if (!decl.EverUsed) {
                  _ilg.Emit (OpCodes.Pop);
                } else {
                  def local_slot = declare_val_local_slot (decl);
                  unless (let_val.Throws)
                    _ilg.Emit (OpCodes.Stloc, local_slot);
                }
              }
          }

          emit (let_in);


        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction */
        | If (cond_expr, then_expr, else_expr, then_debug_loc, else_debug_loc) =>

          def emit_debug (loc) {
            // This code locates the debugger right after the condition gets successful or fails.
            // Used to debug match cases.
            //
            when (IsDebugEnabled && !loc.IsGeneratedOrEmpty)
              emit_debug_info (TExpr.DebugInfo (loc, null, null, null));
          }

          def emit_branch (expr : TExpr, else_label : Label, debug_loc: Location) {

            def emit_br (opcode1, opcode2)
            {
              if (!IsDebugEnabled || debug_loc.IsGeneratedOrEmpty) {
                _ilg.Emit (opcode1, else_label);
              } else {
                def debug_label = _ilg.DefineLabel ();
                _ilg.Emit (opcode2, debug_label);
                emit_debug (debug_loc);
                _ilg.Emit (OpCodes.Br, else_label);
                _ilg.MarkLabel (debug_label);
              }
            }

            match (expr) {
              | Call (OpCode ("=="), [nested_cond,
                Parm where (expr = TExpr.TypeConversion(TExpr.Literal(Literal.Bool(true)), _, _, _))], _) =>
                emit_branch(nested_cond.expr, else_label, Location.Default)

              | Call (OpCode (opcode), parms, _) =>
                emit_parms (parms);

                /* NOTE: the opcodes are swapped so that the 'then' expression
                         can be emitted before the 'else' expression */
                def opcodes =
                  match (opcode) {
                    | "==.ref" | "=="   => (OpCodes.Bne_Un, OpCodes.Beq)
                    | "!=.ref" | "!="   => (OpCodes.Beq,    OpCodes.Bne_Un)
                    | "<.s"    | "<.f"  => (OpCodes.Bge,    OpCodes.Blt)
                    | "<.u"             => (OpCodes.Bge_Un, OpCodes.Blt_Un)
                    | ">.s"    | ">.f"  => (OpCodes.Ble,    OpCodes.Bgt)
                    | ">.u"             => (OpCodes.Ble_Un, OpCodes.Bgt_Un)
                    | "<=.s"   | "<=.f" => (OpCodes.Bgt,    OpCodes.Ble)
                    | "<=.u"            => (OpCodes.Bgt_Un, OpCodes.Ble_Un)
                    | ">=.s"   | ">=.f" => (OpCodes.Blt,    OpCodes.Bge)
                    | ">=.u"            => (OpCodes.Blt_Un, OpCodes.Bge_Un)
                    | "bool.!"          => (OpCodes.Brtrue, OpCodes.Brfalse)
                    | _ => Util.ice ("invalid opcode '" + opcode +
                                     "' in optimized TExpr.If pattern")
                  };

                emit_br (opcodes);

              | HasType (val, ty) =>
                emit (val);
                need_reference (val.GetSystemType ());
                _ilg.Emit (OpCodes.Isinst, ty.GetSystemType ());
                emit_br (OpCodes.Brfalse, OpCodes.Brtrue);

              | If (new_cond, new_then, new_else, _, _) =>
                def my_label_else = _ilg.DefineLabel ();
                def my_label_fi = _ilg.DefineLabel ();
                emit_branch (new_cond, my_label_else, Location.Default);
                emit_branch (new_then, else_label, Location.Default);
                unless (new_then.Throws)
                  _ilg.Emit (OpCodes.Br, my_label_fi);
                _ilg.MarkLabel (my_label_else);
                emit_branch (new_else, else_label, Location.Default);
                _ilg.MarkLabel (my_label_fi);

              | e when is_always_true (e) => ()
              | e when is_always_false (e) =>
                _ilg.Emit (OpCodes.Br, else_label);

              | _ =>
                //Message.Debug (e.loc, pretty_print (e));
                // most of other expressions here are TExpr.Ref
                emit (expr);

                unless (expr.Throws)
                  emit_br (OpCodes.Brfalse, OpCodes.Brtrue);
            }
          }

          def label_condition_else = _ilg.DefineLabel ();
          def label_condition_fi   = _ilg.DefineLabel ();

          def inScope(emit)
          {
            _ilg.BeginScope ();
            emit ();
            _ilg.EndScope ();
          }

          inScope (() => {
            emit_branch (cond_expr, label_condition_else, else_debug_loc);

            inScope (() => {
              emit_debug (then_debug_loc);
              emit (then_expr);
            });

            unless (then_expr.Throws)
              _ilg.Emit (OpCodes.Br, label_condition_fi);

            inScope (() => {
              _ilg.MarkLabel (label_condition_else);
              emit (else_expr);
            });

            _ilg.MarkLabel (label_condition_fi);
          });


        /* emit a type check construction */
        | HasType (expr, ty) =>
          emit (expr);
          def label_condition_not_null = _ilg.DefineLabel ();
          def label_condition_has_type = _ilg.DefineLabel ();
          def label_condition_continue = _ilg.DefineLabel ();

          _ilg.Emit (OpCodes.Dup);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);

          _ilg.ThrowException (SystemTypeCache.NullMatchException);

          _ilg.MarkLabel (label_condition_not_null);

          need_reference (expr.GetSystemType ());
          _ilg.Emit (OpCodes.Isinst, ty.GetSystemType ());
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_0);
          _ilg.Emit (OpCodes.Br_S, label_condition_continue);
          _ilg.MarkLabel (label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_1);
          _ilg.MarkLabel (label_condition_continue);

          
        | DefaultValue =>
          match(expr.GetSystemType ()) {
            | _ when is_void(expr.MType()) => ()
            | ty when ty.Equals (SystemTypeCache.Char)
            | ty when ty.Equals (SystemTypeCache.Byte)
            | ty when ty.Equals (SystemTypeCache.SByte)
            | ty when ty.Equals (SystemTypeCache.Int16)
            | ty when ty.Equals (SystemTypeCache.Int32)
            | ty when ty.Equals (SystemTypeCache.UInt16)
            | ty when ty.Equals (SystemTypeCache.UInt32)
            | ty when ty.Equals (SystemTypeCache.Boolean) =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
            | ty when ty.Equals (SystemTypeCache.Int64)
            | ty when ty.Equals (SystemTypeCache.UInt64) =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Conv_I8);
            | ty when ty.Equals (SystemTypeCache.Single) =>
              _ilg.Emit (OpCodes.Ldc_R4, 0.0f);
            | ty when ty.Equals (SystemTypeCache.Double) =>
              _ilg.Emit (OpCodes.Ldc_R8, 0.0d);
            | ty when ty.Equals (SystemTypeCache.Decimal) =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Newobj, ty.GetConstructor (array [SystemTypeCache.Int32]));
            | ty when ty.IsValueType || ty.IsGenericParameter =>
              def local_slot = _ilg.DeclareLocal (ty);
              _ilg.Emit (OpCodes.Ldloca, local_slot);
              _ilg.Emit (OpCodes.Initobj, ty);
              _ilg.Emit (OpCodes.Ldloc, local_slot);
            | _ => _ilg.Emit (OpCodes.Ldnull);
          }
            
            
        | CtorOf(ty, method) =>
          def sysType = ty.GetSystemType();
          def ctorInfo = GetConstructorInfo (sysType, method);
          _ilg.Emit (OpCodes.Ldtoken, ctorInfo);
          _ilg.Emit (OpCodes.Ldtoken, sysType);
          _ilg.Emit (OpCodes.Call, SystemTypeCache.MethodBase_GetMethodFromHandle2);
          _ilg.Emit (OpCodes.Castclass, typeof(ConstructorInfo));
          
        | MethodOf(from_type, method, typars) =>
          def methodInfo = GetMethodInfo(from_type, method, typars);
          def declTy = methodInfo.DeclaringType;
          _ilg.Emit (OpCodes.Ldtoken, methodInfo);
          if (declTy == null)
            _ilg.Emit (OpCodes.Call, SystemTypeCache.MethodBase_GetMethodFromHandle);
          else
          {
            _ilg.Emit (OpCodes.Ldtoken, declTy);
            _ilg.Emit (OpCodes.Call, SystemTypeCache.MethodBase_GetMethodFromHandle2);
          }
          _ilg.Emit (OpCodes.Castclass, typeof(MethodInfo));
          
        | FieldOf(ty, field) =>
          def fielfInfo = GetFieldInfo(ty.GetSystemType(), field);
          def declTy = fielfInfo.DeclaringType;
          _ilg.Emit (OpCodes.Ldtoken, fielfInfo);
          if (declTy == null)
            _ilg.Emit (OpCodes.Call, SystemTypeCache.FieldInfo_GetFieldFromHandle);
          else
          {
            _ilg.Emit (OpCodes.Ldtoken, declTy);
            _ilg.Emit (OpCodes.Call, SystemTypeCache.FieldInfo_GetFieldFromHandle2);
          }
          _ilg.Emit (OpCodes.Castclass, typeof(FieldInfo));
          
        /* load runtime representation of given type */
        | TypeOf (t) =>
          _ilg.Emit (OpCodes.Ldtoken, t.GetSystemType ());
          _ilg.Emit (OpCodes.Call, SystemTypeCache.Type_GetTypeFromHandle);


        /* emits the TExpr.Switch instruction */
        | Switch (indexing_expr, default_expr, cases) =>
          match (cases) {
            | [] => Message.Warning ("empty TExpr.Switch instruction");
            | _ =>
              emit (indexing_expr);
              emit_switch (default_expr, cases)
          }


        | MacroEnvelope (_, _, expr, _) =>
          emit (expr)


        /* insert label so TExpr.Goto can work */
        | Label (id, expr) =>
          if (_labels.Contains (id))
            _label_usage [id] = null;
          else
            _labels [id] = _ilg.DefineLabel ();
          _ilg.MarkLabel (_labels [id]);
          emit (expr)


        | Goto (id, try_block) =>
          if (_labels.Contains (id)) {
            _label_usage [id] = null;
          } else {
            _label_usage [id] = expr;
            _labels [id] = _ilg.DefineLabel ();
          }
          
          if (try_block == 0)
            _ilg.Emit (OpCodes.Br, _labels [id])
          else {
            // Message.Warning (expr.loc, $"emit leave, id=$id");
            _ilg.Emit (OpCodes.Leave, _labels [id])
          }


        /* -- TYPE CONVERSIONS --------------------------------------------- */


        // when expr throws we shouldn't emit anything
        | TypeConversion (expr, _, _, _) when expr.Throws =>
          emit (expr)

        /* do not perform casts between same types */
        | TypeConversion (expr, cast_to_type, _, _) 
          when no_cast_needed (expr.GetSystemType (), cast_to_type.GetSystemType ()) =>
          emit (expr)

        // special case for  'a : 'b conversion
        | TypeConversion (expr, cast_to_type, ConversionKind.Boxing, _) 
          when cast_to_type.GetSystemType ().IsGenericParameter =>
          emit (expr);
          _ilg.Emit (OpCodes.Box, expr.GetSystemType ());
          _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.GetSystemType ());

        | TypeConversion (expr, cast_to_type, _, _) when cast_to_type.GetSystemType ().IsGenericParameter =>
          emit (expr);
          when (expr.MType().IsValueType || expr.MType() is MType.TyVarRef)
            _ilg.Emit (OpCodes.Box, expr.GetSystemType ());
          _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.GetSystemType ());
          
        | TypeConversion (ignored, ty, _, _) when is_void (ty) =>
          // a little trickery, so emit can be tail called sometimes
          if (is_void (ignored.Type))
            emit (ignored)
          else {
            emit (ignored);
            _ilg.Emit (OpCodes.Pop);
          }
        
        /* to nonvalue type */
        | TypeConversion (expr, cast_to_type, kind, _) when !cast_to_type.Fix ().IsValueType =>
          emit (expr);
          if (is_void (expr.Type))
            /* special case casts from void */
            _ilg.Emit (OpCodes.Ldnull);
          else if (expr.GetSystemType ().IsGenericParameter) {
            _ilg.Emit (OpCodes.Box, expr.GetSystemType ());
            unless (cast_to_type.Fix ().IsSystemObject)
              if (cast_to_type.Fix ().IsValueType)
                _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.GetSystemType ());
              else
                _ilg.Emit (OpCodes.Castclass, cast_to_type.GetSystemType ());
          }
          else if (expr.GetSystemType ().IsValueType)
          {
            // Message.Debug (k.ToString ());
            /* box value types casted to non value types */          
            _ilg.Emit (OpCodes.Box, expr.GetSystemType ());
          }
          else {
            /* upcast / downcast non-value types */
            def cast_to_type = cast_to_type.GetSystemType ();
            when (expr.GetSystemType ().IsArray && cast_to_type.IsArray &&
                  expr.GetSystemType ().GetElementType ().IsValueType !=
                  cast_to_type.GetElementType ().IsValueType)
              Message.Error (expr.Location, $ "attempting to cast a value type array "
                                              "$(expr.GetSystemType ()) to non-value type array "
                                              "$(cast_to_type) which cannot succeed");
            unless (kind is ConversionKind.UpCast)
              _ilg.Emit (OpCodes.Castclass, cast_to_type);
          }

        /* unbox value types or perform value type conversion */
        | TypeConversion (val, cast_to_type, kind, _) =>
          def is_checked = ! (kind is IL (false));
          emit (val);
          def type_of_expr = val.GetSystemType ();
          def cast_to_stype = cast_to_type.GetSystemType ();

          def is_generic =
            if (type_of_expr.IsGenericParameter) {
              _ilg.Emit (OpCodes.Box, type_of_expr);
              true
            } else false;

          if (type_of_expr.IsValueType) {
            /* perform conversion of value types */
            emit_value_type_conversion (expr.Location, val.MType(), cast_to_type.Fix (), is_checked)
          }
          else if (is_generic || 
                   SystemTypeCache.Object : object == type_of_expr || 
                   type_of_expr.IsInterface || 
                   (SystemTypeCache.Enum : object == type_of_expr && cast_to_stype.IsEnum)) {
            /* unboxing returns a pointer to a value */
            _ilg.Emit (OpCodes.Unbox, cast_to_stype);

            maybe_volatile (val);

            emit_ldind_for_value_type (cast_to_stype)
          }
          else {
            Util.ice ($ "$_method_name: failed to convert non-value "
                        "type $type_of_expr to a value type "
                        "$cast_to_type");
          }


        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | LocalRef (decl) =>
          unless (is_void (decl.Type))
            emit_ce_ref (decl, get_address_for_value_types = expr.NeedAddress)

        /* load the value of a field */
        | FieldMember (base_object, field) =>
          def result_will_be_address = expr.NeedAddress;

          if (result_will_be_address) 
            _ = emit_and_convert_to_address (base_object);
          else
            emit (base_object);

          maybe_volatile (expr);

          def field_info = GetFieldInfo (base_object, field);

          when (base_object.GetSystemType ().IsGenericParameter)
            _ilg.Emit (OpCodes.Box, base_object.GetSystemType ());

          if (result_will_be_address) {
            if(field.IsMutable)
              _ilg.Emit (OpCodes.Ldflda, field_info);
            else {
              def temp = _ilg.DeclareLocal (field.GetMemType().GetSystemType ());
              _ilg.Emit (OpCodes.Ldfld, field_info);
              _ilg.Emit (OpCodes.Stloc, temp);
              _ilg.Emit (OpCodes.Ldloca, temp);
            }
          }
          else
            _ilg.Emit (OpCodes.Ldfld, field_info);

          emit_tuple_function_conversion (expr.MType(), base_object.MType(), field);

        /* load the value of a static field */
        | StaticRef (t, field is IField, _) =>
          def field_info = GetFieldInfo (t.GetSystemType (), field);
          
          assert (field_info.IsStatic, "GlobalRef to a non-static field");

          when (field_info.IsLiteral)
            // should not happen
            Message.Warning ("loading literal as field `" + field_info.ToString () + "'");

          maybe_volatile (expr);
          if (expr.NeedAddress) {
            if(field.IsMutable)
               _ilg.Emit (OpCodes.Ldsflda, field_info);
            else {
               def temp = _ilg.DeclareLocal (field.GetMemType().GetSystemType ());
               _ilg.Emit (OpCodes.Ldsfld, field_info);
               _ilg.Emit (OpCodes.Stloc, temp);
               _ilg.Emit (OpCodes.Ldloca, temp);
            }
          }
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);

          emit_tuple_function_conversion (expr.MType(), t, field);

        /* load an array element */
        | ArrayIndexer (array_obj, [index]) =>
          emit_exprs ([array_obj, index]);
          def element_type = array_obj.GetSystemType ().GetElementType ();
          assert (element_type != null, "non-array in TExpr.ArrayIndexer");

          if (expr.NeedAddress)
            _ilg.Emit (OpCodes.Ldelema, element_type)
          else
            emit_array_load_opcode (element_type);
          

        | ArrayIndexer (array_obj, indexes) =>
          emit_exprs ([array_obj] + indexes);
          def method =
            if (expr.NeedAddress) array_addr_method (array_obj)
            else array_get_method (array_obj);
          emit_method_call (expr, true, method);


        /* -- ASSIGNMENTS -------------------------------------------------- */

        | Assign (LocalRef, val) when val.Throws
        | Assign (LocalRef (local_var), val) when is_void (local_var.Type) =>
          emit (val);
          
        
        /* special case these assignments for performance */
        | Assign (LocalRef (decl), ImplicitValueTypeCtor as ctr) =>
          emit_ce_ref (decl, get_address_for_value_types = true);
          _ilg.Emit (OpCodes.Initobj, ctr.GetSystemType ());

     
        /* assignment to ref/out parameter */
        | Assign (LocalRef (local_var), val) when local_var.IsByRefParm =>
          def vars = emit_exprs_prepare ([val]);
          emit_ldarg (local_var.ParmIndex);
          emit_exprs_push (vars, [val]);

          def ty = val.GetSystemType ();
          if (ty.IsValueType || ty.IsGenericParameter)
            _ilg.Emit (OpCodes.Stobj, ty)
          else
            _ilg.Emit (OpCodes.Stind_Ref);


        /* assignment to a local variable */
        | Assign (LocalRef (local_var), val) =>
          emit (val);
          unless (val.Throws)
            store_local (local_var);


        /* assignment to a field */
        | Assign (FieldMember (base_object, field) as target, val) =>
          if (val.NeedsEmptyStack) {
            def base_local = _ilg.DeclareLocal (base_object.GetSystemType ());
            def val_local = _ilg.DeclareLocal (val.GetSystemType ());

            emit (base_object);
            _ilg.Emit (OpCodes.Stloc, base_local);

            emit (val);
            _ilg.Emit (OpCodes.Stloc, val_local);

            _ilg.Emit (OpCodes.Ldloc, base_local);
            when (base_object.GetSystemType ().IsGenericParameter)
              _ilg.Emit (OpCodes.Box, base_object.GetSystemType ());
            _ilg.Emit (OpCodes.Ldloc, val_local);
          } else {
            emit (base_object);
            when (base_object.GetSystemType ().IsGenericParameter)
              _ilg.Emit (OpCodes.Box, base_object.GetSystemType ());
            emit (val);
          }
          maybe_volatile (target);

          def field_info = GetFieldInfo (base_object, field);
          
          _ilg.Emit (OpCodes.Stfld, field_info);


        /* assignment to a static field */
        | Assign (StaticRef (t, f is IField, _) as target, val) =>
          emit (val);
          maybe_volatile (target);

          def field_info = GetFieldInfo (t.GetSystemType (), f);
          
          _ilg.Emit (OpCodes.Stsfld, field_info);


        /* assignment to an array element */
        | Assign (ArrayIndexer (array_obj, [index]) as target, val) =>
          def type_of_val = val.GetSystemType ();
          if (index.NeedsEmptyStack || val.NeedsEmptyStack) {
            def obj_local = _ilg.DeclareLocal (array_obj.GetSystemType ());
            def index_local = _ilg.DeclareLocal (index.GetSystemType ());
            def val_local = _ilg.DeclareLocal (val.GetSystemType ());

            emit (array_obj);
            _ilg.Emit (OpCodes.Stloc, obj_local);

            emit (index);
            _ilg.Emit (OpCodes.Stloc, index_local);

            emit (val);
            _ilg.Emit (OpCodes.Stloc, val_local);

            _ilg.Emit (OpCodes.Ldloc, obj_local);
            _ilg.Emit (OpCodes.Ldloc, index_local);
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);

            _ilg.Emit (OpCodes.Ldloc, val_local);
          } else {
            emit (array_obj);
            emit (index);
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);

            emit (val);
          }
          emit_array_store_opcode (target.GetSystemType ());

        | Assign (ArrayIndexer (array_obj, indexes), val) =>
          emit_exprs ([array_obj] + indexes + [val]);
          def method = array_set_method (array_obj);
          emit_method_call (expr, true, method);

        | Assign (This, val) =>
          Util.cassert (_this_is_value_type,
                        "we can assign to 'this' only in valuetypes");
          def vars = emit_exprs_prepare ([val]);
          _ilg.Emit (OpCodes.Ldarg_0);
          emit_exprs_push (vars, [val]);
         
          _ilg.Emit (OpCodes.Stobj, _type_of_this)
          
        | MultipleAssign (assigns) =>
          def emit_store (local_var : LocalValue, _) {
            if (local_var.EverUsed)
              store_local (local_var)
            else
              _ilg.Emit (OpCodes.Pop);
          }
          emit_exprs (assigns.Map ((_, e) => e));
          List.Iter (List.Rev (assigns), emit_store);


        /* -- CALLS -------------------------------------------------------- */

        /* call the base constructor */
        | Call (Base (base_ctor), ctor_params, _) =>
          def parameters = ctor_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);
          _ilg.Emit (OpCodes.Ldarg_0);
          emit_exprs_push(vars, parameters);

          def from =
            if (base_ctor.DeclaringType.Equals (_parent_type_builder))
              _type_of_this
            else _type_of_this.BaseType;

          def ctr_inf = GetConstructorInfo (from, base_ctor);
          _ilg.Emit (OpCodes.Call, ctr_inf);
          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);

        /* create a new object */
        | Call (StaticRef (_t, meth is IMethod, _), ctor_params, _) when is_ctor (meth) =>
          emit_parms (ctor_params);

          def ctr_inf = GetConstructorInfo (_t.GetSystemType (), meth);
          _ilg.Emit (OpCodes.Newobj, ctr_inf);
          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);


        /* emit a call to an instance method, basing on the 'this' pointer for value types */
        | Call (MethodRef (This as th, method, tparms, _), method_params, _)
                                                      when _this_is_value_type =>
          def method_inf = GetMethodInfo (th.Type, method, tparms);
            
          def parameters = method_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);
          
          _ilg.Emit (OpCodes.Ldarg_0);

          // it actually IS the proper way to do it --
          // if this is our method, then we do not need to box
          unless (th.MType().Equals (_parent_type_builder.GetMemType ())) {
            _ilg.Emit (OpCodes.Ldobj, _type_of_this);
            _ilg.Emit (OpCodes.Box, _type_of_this);
          }
          emit_exprs_push(vars, parameters);
          
          emit_method_call (expr, true, method_inf, method, th.MType())


        /* emit a call to an instance method */
        | Call (MethodRef (base_object, method, tparms, notvirt), method_params, _) =>
          def method_inf = GetMethodInfo (base_object.Type, method, tparms);
          
          def parameters = method_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);

          def is_value_type = emit_and_convert_to_address (base_object);

          emit_exprs_push(vars, parameters);

          if (base_object.NeedsConstrained) {
            def is_tail = expr.GenerateTail;
            when (is_tail) {
              expr.GenerateTail = false;
              _ilg.Emit (OpCodes.Tailcall);
            }
            _ilg.Emit (OpCodes.Constrained, base_object.GetSystemType ());
            emit_method_call (expr, false, method_inf, method, base_object.MType()); // constrained always need callvirt
            when (is_tail)
              _ilg.Emit (OpCodes.Ret);
          } else
            emit_method_call (expr, is_value_type || notvirt, method_inf, method, base_object.MType())


        /* emit a call to a static method */
        | Call (StaticRef (_t, mi is IMethod, tparms), method_parms, _) =>
          def method_info = GetMethodInfo (_t, mi, tparms);
        
          Util.cassert (method_info.IsStatic,
                        $ "Call TExpr.GlobalRef to a non-static field: $(method_info.Name)");

          emit_parms (method_parms);
          emit_method_call (expr, true, method_info, mi, _t)


        /* emit an operator */
        | Call (OpCode (opcode), parms, _) =>
          // FIXME: seperate out
          emit_parms (parms);
          match (opcode) {
            | "+.s" =>  _ilg.Emit (OpCodes.Add_Ovf)
            | "+.u" => _ilg.Emit (OpCodes.Add_Ovf_Un)
            | "+.f" =>  _ilg.Emit (OpCodes.Add)

            | "<<.s" | "<<.f" | "<<.u" =>  _ilg.Emit (OpCodes.Shl)
            | ">>.s" | ">>.f" =>  _ilg.Emit (OpCodes.Shr)
            | ">>.u" =>  _ilg.Emit (OpCodes.Shr_Un)

            | "unary.+.s" | "unary.+.u" | "unary.+.f" => ()

            | "-.s" =>  _ilg.Emit (OpCodes.Sub_Ovf)
            | "-.u" => _ilg.Emit (OpCodes.Sub_Ovf_Un)
            | "-.f" =>  _ilg.Emit (OpCodes.Sub)

            | "unary.-.s" =>
              _ilg.Emit (OpCodes.Ldc_I4_M1);
              emit_value_type_conversion (expr.Location, InternalType.Int32,
                                          parms.Head.expr.MType(), true);
              _ilg.Emit (OpCodes.Mul_Ovf)
            | "unary.-.f" =>
              _ilg.Emit (OpCodes.Neg)

            | "unary.~.u"
            | "unary.~.s" =>
              _ilg.Emit (OpCodes.Not);

            | "++.i4.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Add);
            | "--.i4.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Sub);
            | "++.i4.s" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Add_Ovf);
            | "--.i4.s" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Sub_Ovf);
            | "++.i4.u" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Add_Ovf_Un);
            | "--.i4.u" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Sub_Ovf_Un);
            
            | "++.i4.s.i1" =>
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Add_Ovf); 
              _ilg.Emit (OpCodes.Conv_Ovf_I1);
            | "--.i4.s.i1" => 
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Sub_Ovf);
              _ilg.Emit (OpCodes.Conv_Ovf_I1);
            | "++.i4.u.i1" =>
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Add_Ovf_Un);
              _ilg.Emit (OpCodes.Conv_Ovf_I1_Un);
            | "--.i4.u.i1" =>
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Sub_Ovf_Un);
              _ilg.Emit (OpCodes.Conv_Ovf_I1_Un);

            | "++.i4.s.i2" =>
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Add_Ovf); 
              _ilg.Emit (OpCodes.Conv_Ovf_I2);
            | "--.i4.s.i2" => 
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Sub_Ovf);
              _ilg.Emit (OpCodes.Conv_Ovf_I2);
            | "++.i4.u.i2" =>
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Add_Ovf_Un);
              _ilg.Emit (OpCodes.Conv_Ovf_I2_Un);
            | "--.i4.u.i2" =>
              _ilg.Emit (OpCodes.Ldc_I4_1); 
              _ilg.Emit (OpCodes.Sub_Ovf_Un);
              _ilg.Emit (OpCodes.Conv_Ovf_I2_Un);

            | "++.i8.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_I8); _ilg.Emit (OpCodes.Add);
            | "--.i8.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_I8); _ilg.Emit (OpCodes.Sub);
            | "++.i8.s" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_I8); _ilg.Emit (OpCodes.Add_Ovf);
            | "--.i8.s" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_I8); _ilg.Emit (OpCodes.Sub_Ovf);
            | "++.i8.u" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_I8); _ilg.Emit (OpCodes.Add_Ovf_Un);
            | "--.i8.u" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_I8); _ilg.Emit (OpCodes.Sub_Ovf_Un);
            | "++.r4.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_R4); _ilg.Emit (OpCodes.Add);
            | "--.r4.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_R4); _ilg.Emit (OpCodes.Sub);
            | "++.r8.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_R8); _ilg.Emit (OpCodes.Add);
            | "--.r8.f" => _ilg.Emit (OpCodes.Ldc_I4_1); _ilg.Emit (OpCodes.Conv_R8); _ilg.Emit (OpCodes.Sub);

            | "unary.~.f" =>
              def type_of_parm = parms.Head.expr.GetSystemType ();
              when (type_of_parm.TypeFullName () == "System.Single" ||
                    type_of_parm.TypeFullName () == "System.Double" ||
                    type_of_parm.TypeFullName () == "System.Decimal")
                Util.ice ("float, double or decimal as an argument for binary negation in CGIL");
              _ilg.Emit (OpCodes.Not);

            | "*.s" =>  _ilg.Emit (OpCodes.Mul_Ovf)
            | "*.u" => _ilg.Emit (OpCodes.Mul_Ovf_Un)
            | "*.f" =>  _ilg.Emit (OpCodes.Mul)

            | "/.s" | "/.f" =>  _ilg.Emit (OpCodes.Div)
            | "/.u" => _ilg.Emit (OpCodes.Div_Un)
            | "%.s" | "%.f" =>  _ilg.Emit (OpCodes.Rem)
            | "%.u" => _ilg.Emit (OpCodes.Rem_Un)

            | "|.s" | "|.u" | "|.f" => _ilg.Emit (OpCodes.Or);
            | "&.s" | "&.u" | "&.f" => _ilg.Emit (OpCodes.And);
            | "^.s" | "^.u" | "^.f" => _ilg.Emit (OpCodes.Xor);
            | "bool.!" =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Ceq)
            | "==.ref" | "==" =>
              _ilg.Emit (OpCodes.Ceq);
            | "!=.ref" | "!=" =>
              _ilg.Emit (OpCodes.Ceq);
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Ceq);
            | "<.s" | "<.f" => emit_compare (OpCodes.Blt_S)
            | "<.u" => emit_compare (OpCodes.Blt_Un_S)
            | ">.s" | ">.f" => emit_compare (OpCodes.Bgt_S)
            | ">.u" => emit_compare (OpCodes.Bgt_Un_S)
            | "<=.s" | "<=.f" => emit_compare (OpCodes.Ble_S)
            | "<=.u" => emit_compare (OpCodes.Ble_Un_S)
            | ">=.s" | ">=.f" => emit_compare (OpCodes.Bge_S)
            | ">=.u" => emit_compare (OpCodes.Bge_Un_S)
            | _ =>
              Util.ice (_method_name + ": unmatched TExpr.Opcode (" + opcode + ")")
          }
          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);

        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | Throw (null) =>
          _ilg.Emit (OpCodes.Rethrow);
        
        | Throw (exc) =>
          emit (exc);
          _ilg.Emit (OpCodes.Throw);


        /* emit the try/with construction */
        | TryFinally (try_expr, finally_expr) =>
          def type_of_try_expr = try_expr.GetSystemType ();

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          def ignore_try_result = is_void (try_expr.Type);
          mutable try_result = null;

          unless (ignore_try_result) {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            unless (try_expr.Throws)
              _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          emit (finally_expr);

          _ilg.EndExceptionBlock ();

          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        | Try (try_expr, try_cases) =>
          def type_of_try_expr = expr.GetSystemType ();

          def ignore_try_result = is_void (try_expr.Type);
          mutable try_result = null;

          unless (ignore_try_result)
            try_result = _ilg.DeclareLocal (type_of_try_expr);

          _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          unless (try_expr.Throws || ignore_try_result)
            _ilg.Emit (OpCodes.Stloc, try_result);

          def walk_case (case) {
            | Try_case.Fault (catch_expr) =>
              _ilg.BeginFaultBlock ();
              emit (catch_expr);
            
            | Try_case.Catch (catch_val, catch_expr) =>
              _ilg.BeginCatchBlock (catch_val.Type.GetSystemType ());

              def catch_val_local_slot = declare_val_local_slot (catch_val);
              _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);

              emit (catch_expr);

              unless (catch_expr.Throws || ignore_try_result)
                _ilg.Emit (OpCodes.Stloc, try_result);

            | Try_case.Filter (catch_val, filter_expr, catch_expr) =>
              def label_badclass = _ilg.DefineLabel ();
              def label_endfilter = _ilg.DefineLabel ();

              // emit filter preamble
              _ilg.BeginExceptFilterBlock ();
              _ilg.Emit (OpCodes.Isinst, catch_val.Type.GetSystemType ());
              _ilg.Emit (OpCodes.Dup);
              _ilg.Emit (OpCodes.Brfalse, label_badclass);

              // emit filter block
              def catch_val_local_slot = declare_val_local_slot (catch_val);
              _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);
              emit (filter_expr);
              _ilg.Emit (OpCodes.Br, label_endfilter);

              // when bad class return 0
              _ilg.MarkLabel (label_badclass);
              _ilg.Emit (OpCodes.Pop);
              _ilg.Emit (OpCodes.Ldc_I4_0);

              // mark end of filter
              _ilg.MarkLabel (label_endfilter);

              // emit catch block
              _ilg.BeginCatchBlock (null);
              _ilg.Emit (OpCodes.Pop); // ignore value on stack, it's already local
              emit (catch_expr);

              unless (catch_expr.Throws || ignore_try_result)
                _ilg.Emit (OpCodes.Stloc, try_result);
          }

          foreach (try_case in try_cases)
            walk_case (try_case);

          _ilg.EndExceptionBlock ();

          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        /* -- TUPLES -------------------------------------------------------- */
        | Tuple (vals) =>
          emit_exprs (vals);
          def ctor = InternalType.GetTupleType (vals.Length).Ctor;
          _ilg.Emit (OpCodes.Newobj, GetConstructorInfo (expr.GetSystemType (), ctor));
          

        | TupleIndexer (obj, pos, len) =>
          def tt = InternalType.GetTupleType (len);
          //when (tt.TyCon.IsValueType && !obj.NeedAddress)
          //  obj.NeedAddress = true;
          emit (obj);
          _ilg.Emit (OpCodes.Ldfld, GetFieldInfo (obj.GetSystemType (), tt.GetField (pos + 1)));


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | This =>
          Util.cassert (!_method_builder.IsStatic, "This is a static method");
          _ilg.Emit (OpCodes.Ldarg_0);
          
          // when we are in value type, this contains address of current
          // value type - so if value is expected instead of address, we must
          // create a copy
          when (_this_is_value_type && !expr.NeedAddress)
            _ilg.Emit (OpCodes.Ldobj, expr.GetSystemType ());


        /* loads a literal on the evaluation stack */
        | Literal (l) => 
          Util.cassert (l != null);
          if (l is Literal.Null)
            match (expr.MType()) {
              | TyVarRef 
              | Class (tc,[_]) when tc.Equals (InternalType.Generic_Nullable_tc) =>
                emit (TExpr.DefaultValue (expr.Location, expr.Type))
              | _ => emit_literal (l);
            }
          else if (l is Literal.Void) {
          } else
            emit_literal (l);

        /* loads address of given method */
        | MethodAddress (from, meth, is_virt, typarms) =>
          def meth = GetMethodInfo (from, meth, typarms);
          if (is_virt && meth.IsVirtual) {
            // ldvirtftn expects also an object reference
            // this is always part of delegate ctor, therefore
            // we can just dup the object reference
            _ilg.Emit (OpCodes.Dup);
            _ilg.Emit (OpCodes.Ldvirtftn, meth);
          } else
            _ilg.Emit (OpCodes.Ldftn, meth);


        /* creates object of value type using implicit ctor */
        | ImplicitValueTypeCtor =>
          def t = expr.GetSystemType ();
          def local_slot = _ilg.DeclareLocal (t);
          _ilg.Emit (OpCodes.Ldloca, local_slot);
          _ilg.Emit (OpCodes.Initobj, t);
          _ilg.Emit (OpCodes.Ldloc, local_slot);


        /* creates a new array, given a list of initializers */
        | Array (initializers, [size]) =>
          def element_type =
            match (expr.Type.Fix ()) {
              | MType.Array (t, _) => t.GetSystemType ()
              | _ => Util.ice ()
            }
          emit (size);
          _ilg.Emit (OpCodes.Newarr, element_type);

          def need_empty_stack = initializers.Exists (_.NeedsEmptyStack);

          mutable local_array_var = null;
          mutable local_val_var = null;
          when (need_empty_stack) {
            local_array_var = _ilg.DeclareLocal (expr.GetSystemType ());
            local_val_var = _ilg.DeclareLocal (element_type);
            _ilg.Emit (OpCodes.Stloc, local_array_var);
            _ilg.Emit (OpCodes.Ldloc, local_array_var);
          }
          
          def load_elements (index : int, elements : list [TExpr]) {
            match (elements) {
              | [] => ()
              | element :: rest =>
                if (element.NeedsEmptyStack) {
                  _ilg.Emit (OpCodes.Pop); // stack should be empty now

                  emit (element);
                  _ilg.Emit (OpCodes.Stloc, local_val_var);

                  _ilg.Emit (OpCodes.Ldloc, local_array_var);
                  _ilg.Emit (OpCodes.Ldc_I4, index);

                  when (element_type.IsValueType && !element_type.IsPrimitive)
                    _ilg.Emit (OpCodes.Ldelema, element_type);

                  _ilg.Emit (OpCodes.Ldloc, local_val_var);
                  emit_array_store_opcode (element_type);
                  _ilg.Emit (OpCodes.Ldloc, local_array_var); // restore stack layout for "normal" initializers
                } else {
                  _ilg.Emit (OpCodes.Dup);
                  _ilg.Emit (OpCodes.Ldc_I4, index);

                  when (element_type.IsValueType && !element_type.IsPrimitive)
                    _ilg.Emit (OpCodes.Ldelema, element_type);

                  emit (element);
                  emit_array_store_opcode (element_type);
                }
                load_elements (index + 1, rest)
            }
          };
          load_elements (0, initializers);

        | Array (initializers, dimensions) =>
          def element_type =
            match (expr.Type.Fix ()) {
              | MType.Array (t, _) => t.GetSystemType ()
              | _ => Util.ice ()
            }

          def size = dimensions.Length;
          emit_exprs (dimensions);

          def arg_types = array (size);
          for (mutable i = 0; i < size; ++i)
            arg_types [i] = SystemTypeCache.Int32;
          def method =
            _module_builder.GetArrayMethod (expr.GetSystemType (), ".ctor", 
                                            CallingConventions.HasThis,
                                            null, arg_types);
          _ilg.Emit (OpCodes.Newobj, method);

          unless (initializers.IsEmpty) {
            def method = array_set_method (expr.GetSystemType ());

            def dimensions_array = array (size);
            mutable i = 0;
            foreach (TExpr.Literal (Literal.Integer (it, _, _)) in dimensions) {
              dimensions_array [i] = it;
              ++i;
            };
            Util.cassert (i == size,
                          "dimensions must be literals when initializes are supplied");

            def need_empty_stack = initializers.Exists (_.NeedsEmptyStack);

            mutable local_array_var = null;
            mutable local_val_var = null;
            when (need_empty_stack) {
              local_array_var = _ilg.DeclareLocal (expr.GetSystemType ());
              local_val_var = _ilg.DeclareLocal (element_type);
              _ilg.Emit (OpCodes.Stloc, local_array_var);
              _ilg.Emit (OpCodes.Ldloc, local_array_var);
            }

            def load_elements (index : array [ulong], elements : list [TExpr]) {
              match (elements) {
                | [] => ()
                | element :: rest =>
                  if (element.NeedsEmptyStack) {
                    _ilg.Emit (OpCodes.Pop); // stack should be empty now

                    emit (element);
                    _ilg.Emit (OpCodes.Stloc, local_val_var);

                    _ilg.Emit (OpCodes.Ldloc, local_array_var);
                    _ilg.Emit (OpCodes.Dup);

                    for (mutable j = 0; j < index.Length; ++j)
                      emit_literal (Literal.Integer ((index [j] :> int) :> ulong, false, InternalType.Int32));
                    
                    _ilg.Emit (OpCodes.Ldloc, local_val_var);
                  } else {
                    _ilg.Emit (OpCodes.Dup);
                    for (mutable j = 0; j < index.Length; ++j)
                      emit_literal (Literal.Integer ((index [j] :> int) :> ulong, false, InternalType.Int32));
                    emit (element);
                  }
                  def next (index : array [ulong])
                  {
                    ++index [index.Length - 1];
                    for (mutable j = index.Length - 1; index [j] == dimensions_array [j] && j > 0; --j)
                    {
                      index [j] = 0;
                      ++index [j - 1];
                    }
                    index
                  }
                  emit_method_call (expr, true, method);
                  load_elements (next (index), rest)
              }
            }
            load_elements (array (dimensions_array.Length), initializers);
          }

        | DebugInfo as di =>
          emit_debug_info(di);

        | _ =>
          Message.Warning ($ "FIXME: unmatched: $expr");
      });
      log (EMIT, "} emit");
    }

    /*
     * Emit all expressions and push them onto the stack.
     * Take care when some expressions need an empty stack.
     */
    private emit_exprs (exprs : list[TExpr]) : void
    {
      def vars = emit_exprs_prepare (exprs);
      emit_exprs_push (vars, exprs);
    }
    
    /*
     * Emit all expressions up to the last which needs an empty stack and
     * return the local variables where the result is stored.
     */
    private emit_exprs_prepare (exprs : list[TExpr]) : array[LocalBuilder]
    {
      def exprs_array = exprs.ToArray ();
      def len = exprs.Length;
      
      mutable needed_local_variables = 0;
      foreach (i in [0 .. len - 1]) {
        when (exprs_array[i].NeedsEmptyStack)
          needed_local_variables = i + 1;
      }

      def local_variables = array (needed_local_variables);

      foreach (i in [0 .. needed_local_variables - 1]) {
        def expr = exprs_array[i];
        def var_type =
          if (expr.NeedAddress)
            make_ref_type (expr.GetSystemType ())
          else
            expr.GetSystemType ();
        local_variables[i] = _ilg.DeclareLocal (var_type);
        emit (expr);
        _ilg.Emit (OpCodes.Stloc, local_variables[i]);
      }

      local_variables
    }

    /*
     * Push the local variables and emit all expressions with a higher index
     * than the array length
     */
    private emit_exprs_push (local_variables : array[LocalBuilder], exprs : list[TExpr]) : void {
      foreach (var in local_variables) {
        _ilg.Emit (OpCodes.Ldloc, var);
      }

      mutable i = 0;
      foreach (e in exprs) {
        when (i >= local_variables.Length) {
          emit (e);
        }
        i++;
      }
    }
    
    private emit_debug_info(di : TExpr.DebugInfo) : void
    {
      if (_debug_doc == null) {
        emit(di.expr);
      } else {

        def emit_debug (line, col, eline, ecol) {
          _ilg.MarkSequencePoint (_debug_doc, line, col, eline, ecol);
        }

        def l = di.Location;

        match (di.pexpr)
        {
          | Sequence =>
            emit_debug (l.Line, l.Column, l.Line,    l.Column + 1);
            _ilg.BeginScope ();

          | _ => emit_debug (l.Line, l.Column, l.EndLine, l.EndColumn);
        }

        unless (di.expr == null)
          emit (di.expr);

        match (di.pexpr)
        {
          | Sequence =>
            emit_debug (l.EndLine, l.EndColumn - 1, l.EndLine, l.EndColumn);
            _ilg.EndScope ();

          | _ => ()
        }
      }
    }

    private array_set_method (t : System.Type) : MethodInfo
    {
        def rank = t.GetArrayRank ();

        def args = array (rank + 1);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = SystemTypeCache.Int32;
        }
        args [rank] = t.GetElementType ();

        _module_builder.GetArrayMethod (t, "Set",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        SystemTypeCache.Void, args);
    }


    /*
     * Emits a local reference instruction
     */
    private emit_ce_ref (decl : LocalValue, get_address_for_value_types : bool) : void
    {
      if (decl.IsParm) {
        if (get_address_for_value_types && ! decl.IsByRefParm)
          emit_ldarga (decl.ParmIndex)
        else {
          emit_ldarg (decl.ParmIndex);
          when (! get_address_for_value_types && decl.IsByRefParm) {
            def ty = decl.Type.GetSystemType ();
            if (ty.IsGenericParameter || ty.IsValueType)
               emit_ldind_for_value_type (ty)
            else
              _ilg.Emit (OpCodes.Ldind_Ref);
          }
        }
      } else {
        if (get_address_for_value_types && !decl.IsManagedPtr)
          _ilg.Emit (OpCodes.Ldloca, decl.LocalSlot)
        else
          _ilg.Emit (OpCodes.Ldloc, decl.LocalSlot)
      }
    }


    private array_set_method (arr : TExpr) : MethodInfo
    {
        array_set_method (arr.GetSystemType ());
    }

    private array_get_method (arr : TExpr) : MethodInfo
    {
        def t = arr.GetSystemType ();
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = SystemTypeCache.Int32;
        }

        _module_builder.GetArrayMethod (t, "Get",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        t.GetElementType (), args);
    }

    private array_addr_method (arr : TExpr) : MethodInfo
    {
        def t = arr.GetSystemType ();
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = SystemTypeCache.Int32;
        }

        _module_builder.GetArrayMethod (t, "Address",
                                        CallingConventions.HasThis | CallingConventions.Standard,
                                        make_ref_type (t.GetElementType ()), args);
    }

    /**
     * Emits the TExpr.Switch instruction
     *
     * Asserts that the first of the case indices is zero. Quietly
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never
     * generate too long switch instructions -- assuring this should belong
     * to a higher level logic.
     */
    private emit_switch (default_expr : option [TExpr], 
                         cases : list [int * TExpr]) : void
    {
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr) {
          | Some => label_default
          | None => label_next_instruction
        };

      // step one: sort the cases increasingly
      def compare_cases (l : int * TExpr, r : int * TExpr) : int {
        Pair.First (l).CompareTo (r [0])
      };

      def cases = List.Sort (cases, compare_cases);
      Util.cassert (cases.Head [0] == 0);

      // step three: generate the jump labels for the switch cases
      mutable reversed_labels = [];

      def make_labels (index : int, cases : list [int * TExpr])
                                        : list [Label * TExpr] {
        Util.cassert (index >= 0);
        match (cases) {
          | (case_index, case_expr) :: rest =>
            Util.cassert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;

              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)
            }
          | [] => []
        }
      };

      def labeled_cases = make_labels (0, cases);
      def labels_array = reversed_labels.ToArray ();
      System.Array.Reverse (labels_array);

      // step four: emit the switch instruction and the default expression
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr) {
        | Some (default_expr) =>
          emit (default_expr);
          unless (default_expr.Throws)
            _ilg.Emit (OpCodes.Br, label_next_instruction);
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
      };

      // step five: emit the switch cases
      def walk_cases (cases : list [Label * TExpr]) : void {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          emit (expr);
          unless (expr.Throws)
            _ilg.Emit (OpCodes.Br, label_next_instruction);
          walk_cases (rest)
        | [] => ()
      };

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      _ilg.MarkLabel (label_next_instruction);
    }


    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (index : int) : void
    {
      | 0 => _ilg.Emit (OpCodes.Ldarg_0)
      | 1 => _ilg.Emit (OpCodes.Ldarg_1)
      | 2 => _ilg.Emit (OpCodes.Ldarg_2)
      | 3 => _ilg.Emit (OpCodes.Ldarg_3)
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarg, index)
    }


    private store_argument (index : int) : void
    {
      if (index < 256)
        _ilg.Emit (OpCodes.Starg_S, index :> byte)
      else
        _ilg.Emit (OpCodes.Starg, index);
    }

    
    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (index : int) : void
    {
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarga, index)
    }

    /**
     * Performs value type conversion form l to r
     */
    private emit_value_type_conversion (loc : Location,
                                        l_t : MType, r_t : MType,
                                        is_checked : bool) : void
    {
      def fail()
      {
        Message.Warning (loc, $"failed to emit value type conversion from $l_t to $r_t")
      }
      
      unless (l_t.Equals (r_t))
      {
        mutable lt = l_t.TypeInfo;
        when (lt.IsEnum) lt = lt.UnderlyingType;
        mutable rt = r_t.TypeInfo;  
        when (rt.IsEnum) rt = rt.UnderlyingType;

        match (rt)
        {
          | rt is LibraryReference.ExternalPrimitiveTypeInfo when (lt :> LibraryReference.ExternalPrimitiveTypeInfo).CanOmmitConversionTo (rt) => ()
          | rt is LibraryReference.ExternalPrimitiveTypeInfo =>
            def is_unsigned_l = 
              match (lt.Name [0])
              {
                // UInt32, UInt64, UInt16
                | 'U'
                // Byte
                | 'B'
                // Char
                | 'C'   => true
                | _ => false
              }
          
            def rname = rt.Name;
            def opcode =
              match (rname)
              {
                | "Single" when is_unsigned_l => OpCodes.Conv_R_Un
                | "Single"                    => OpCodes.Conv_R4
                | "Double" when is_unsigned_l => _ilg.Emit (OpCodes.Conv_R_Un); OpCodes.Conv_R8                
                | "Double"                    => OpCodes.Conv_R8
                | _ =>
                  if (is_checked)
                    match (rname)
                    {
                      | "Int64" when is_unsigned_l   => OpCodes.Conv_Ovf_I8_Un
                      | "Int64"                      => OpCodes.Conv_Ovf_I8
                      | "Int32" when is_unsigned_l   => OpCodes.Conv_Ovf_I4_Un
                      | "Int32"                      => OpCodes.Conv_Ovf_I4
                      | "Int16" when is_unsigned_l   => OpCodes.Conv_Ovf_I2_Un
                      | "Int16"                      => OpCodes.Conv_Ovf_I2
                      | "SByte" when is_unsigned_l   => OpCodes.Conv_Ovf_I1_Un
                      | "SByte"                      => OpCodes.Conv_Ovf_I1
                      | "UInt64" when is_unsigned_l  => OpCodes.Conv_Ovf_U8_Un
                      | "UInt64"                     => OpCodes.Conv_Ovf_U8
                      | "UInt32" when is_unsigned_l  => OpCodes.Conv_Ovf_U4_Un
                      | "UInt32"                     => OpCodes.Conv_Ovf_U4
                      | "UInt16" when is_unsigned_l  => OpCodes.Conv_Ovf_U2_Un
                      | "UInt16"                     => OpCodes.Conv_Ovf_U2
                      | "Boolean" when is_unsigned_l => OpCodes.Conv_Ovf_U1_Un
                      | "Boolean"                    => OpCodes.Conv_Ovf_U1
                      | "Byte" when is_unsigned_l    => OpCodes.Conv_Ovf_U1_Un
                      | "Byte"                       => OpCodes.Conv_Ovf_U1
                      | "Char" when is_unsigned_l    => OpCodes.Conv_Ovf_U2_Un
                      | "Char"                       => OpCodes.Conv_Ovf_U2
    
                      | _ => fail (); OpCodes.Nop
                    }
                  else match (rname)
                  {
                    | "Int64"   => OpCodes.Conv_I8
                    | "Int32"   => OpCodes.Conv_I4
                    | "Int16"   => OpCodes.Conv_I2
                    | "SByte"   => OpCodes.Conv_I1
                    | "UInt64"  => OpCodes.Conv_U8
                    | "UInt32"  => OpCodes.Conv_U4
                    | "UInt16"  => OpCodes.Conv_U2
                    | "Byte"    => OpCodes.Conv_U1
                    | "Boolean" => OpCodes.Conv_U1
                    | "Char"    => OpCodes.Conv_U2
                    | _         => fail (); OpCodes.Nop
                  }
              };

            _ilg.Emit (opcode)
            
          | _ when rt.Equals (InternalType.Decimal_tc) =>
            def lname = lt.Name;
            match (lname)
            {
              | "Int32" | "UInt32" | "Single" | "Int64" | "UInt64" | "Double" =>
                _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get (lname)))

              | _ => fail ()
            }
            
          | _ => fail ()
        }
      }
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier.
     */
    private emit_method_call (expr : TExpr,
                              base_is_value_type_or_static : bool,
                              method : MethodInfo,
                              imethod : IMethod = null,
                              from : MType = null) : void
    {
      // Message.Debug ($"emc: $(method.Name)");
      when (expr.GenerateTail)
        _ilg.Emit (OpCodes.Tailcall);

      if (base_is_value_type_or_static)
        _ilg.Emit (OpCodes.Call, method)
      else
        _ilg.Emit (OpCodes.Callvirt, method);

      
      when (imethod != null)
        emit_tuple_function_conversion (expr.MType(), from, imethod);

      when (expr.GenerateTail)
        _ilg.Emit (OpCodes.Ret);
    }

    /* Emits code of given expression and converts its value to adress
       (if it is a value type) or leave it as reference (non value type).
       This is needed in various places, where we need a real reference
       (address in case of value types) to access its methods or fields.

       Returns value indicating if base_object was really a value type
    */
    private emit_and_convert_to_address (base_object : TExpr) : bool 
    {
      emit (base_object);
      def stype = base_object.GetSystemType ();
      def is_value_type = stype.IsValueType;

      // we must allocate additional temporary variable if during
      // emit(base_object) address was not granted
      when ((is_value_type || stype.IsGenericParameter)
            && !base_object.NeedAddress) {
        def local_slot = _ilg.DeclareLocal (base_object.GetSystemType ());
        _ilg.Emit (OpCodes.Stloc, local_slot);
        _ilg.Emit (OpCodes.Ldloca, local_slot);
      };
      // is_value_type is checked to decide in call vs callvirt emission
      is_value_type
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : LocalValue) : LocalBuilder
    {
      def ty =
        if (val.IsManagedPtr)
          val.Type.GetSystemType ().MakeByRefType ()
        else val.Type.GetSystemType ();

      def local_slot = _ilg.DeclareLocal (ty);
      when (IsDebugEnabled && !val.Location.IsGeneratedOrEmpty)
        local_slot.SetLocalSymInfo (val.Name);
      val.LocalSlot = local_slot;
      local_slot
    }

    private declare_val_local_slot_ex (val : LocalValue) : void
    {
      if (val.PostponedDeclaration && IsDebugEnabled && !val.Location.IsGeneratedOrEmpty)
        val.Declare = fun() { _ = declare_val_local_slot (val) };
      else
        _ = declare_val_local_slot (val)
    }

    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     */
    private emit_array_store_opcode (ty : System.Type) : void
    {
      if (ty.IsGenericParameter) _ilg.Emit (OpCodes.Stelem, ty)
      else if (ty.IsPrimitive) {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"
            | "Byte"                     => OpCodes.Stelem_I1
            | "Char" | "Int16"
            | "UInt16"                   => OpCodes.Stelem_I2
            | "Int32" | "UInt32"         => OpCodes.Stelem_I4
            | "Int64" | "UInt64"         => OpCodes.Stelem_I8
            | "Single"                   => OpCodes.Stelem_R4
            | "Double"                   => OpCodes.Stelem_R8
            | "IntPtr" | "UIntPtr"       => OpCodes.Stelem_I
            | _ => Util.ice ("System.Type IsPrimitive has lied")
          }
          _ilg.Emit (opcode);
      }
      else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
      else _ilg.Emit (OpCodes.Stelem_Ref);
    }


    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : System.Type) : void
    {
      if (ty.IsGenericParameter)
        _ilg.Emit (OpCodes.Ldelem, ty)
      else if (ty.IsValueType && !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldelema, ty);
        _ilg.Emit (OpCodes.Ldobj, ty);
      } 
      else {
        def opcode =
          if (ty.IsPrimitive)
            match (ty.Name) {
              | "SByte" | "Boolean" => OpCodes.Ldelem_I1
              | "Byte"              => OpCodes.Ldelem_U1
              | "Char" | "Int16"    => OpCodes.Ldelem_I2
              | "UInt16"            => OpCodes.Ldelem_U2
              | "Int32"             => OpCodes.Ldelem_I4
              | "UInt32"            => OpCodes.Ldelem_U4
              | "Int64" | "UInt64"  => OpCodes.Ldelem_I8
              | "Single"            => OpCodes.Ldelem_R4
              | "Double"            => OpCodes.Ldelem_R8
              | "IntPtr" | "UIntPtr" => OpCodes.Ldelem_I
              | _ => Util.ice ("System.Type.IsPrimitive has lied")
            }
          else
            OpCodes.Ldelem_Ref;

        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : System.Type) : void
    {
      if (!ty.IsPrimitive || ty.IsEnum)
        _ilg.Emit (OpCodes.Ldobj, ty)
      else {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"     => OpCodes.Ldind_I1
            | "Byte"                  => OpCodes.Ldind_U1
            | "Char" | "Int16"        => OpCodes.Ldind_I2
            | "UInt16"                => OpCodes.Ldind_U2
            | "Int32"                 => OpCodes.Ldind_I4
            | "UInt32"                => OpCodes.Ldind_U4
            | "Int64"                 => OpCodes.Ldind_I8
            | "UInt64"                => OpCodes.Ldind_I8
            | "Single"                => OpCodes.Ldind_R4
            | "Double"                => OpCodes.Ldind_R8
            | "IntPtr" | "UIntPtr"    => OpCodes.Ldind_I
            | _ =>
              Util.ice (_method_name + ": not a recognized value type: " + ty.TypeFullName ());
          }

        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a literal
     */
    private emit_literal (l : Literal) : void
    {
      def emit_i4 (x) {
        | -1 => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | 0  => _ilg.Emit (OpCodes.Ldc_I4_0)
        | 1  => _ilg.Emit (OpCodes.Ldc_I4_1)
        | 2  => _ilg.Emit (OpCodes.Ldc_I4_2)
        | 3  => _ilg.Emit (OpCodes.Ldc_I4_3)
        | 4  => _ilg.Emit (OpCodes.Ldc_I4_4)
        | 5  => _ilg.Emit (OpCodes.Ldc_I4_5)
        | 6  => _ilg.Emit (OpCodes.Ldc_I4_6)
        | 7  => _ilg.Emit (OpCodes.Ldc_I4_7)
        | 8  => _ilg.Emit (OpCodes.Ldc_I4_8)
        | k when (k >= -128 && k <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, k :> sbyte)
        | k => _ilg.Emit (OpCodes.Ldc_I4, k)
      }

      match (l) {
        | Literal.Void         => ()
        | Literal.Null         => _ilg.Emit (OpCodes.Ldnull)
        | Literal.Bool (true)  => _ilg.Emit (OpCodes.Ldc_I4_1)
        | Literal.Bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)

        | Literal.Char (k)     => emit_i4 (k :> int)

        | Literal.Integer (k, is_neg, t) =>
          assert (t != null);
          if (t.Equals (InternalType.UInt64)) {
            assert (!is_neg);
            unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
            // i don't think this is needed here
            _ilg.Emit (OpCodes.Conv_U8)
          } else if (t.Equals (InternalType.Int64)) {
            if (is_neg)
              if (k == 0x8000000000000000UL)
                _ilg.Emit (OpCodes.Ldc_I8, System.Int64.MinValue);
              else
                _ilg.Emit (OpCodes.Ldc_I8, - (k :> long));
            else
              unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
          } else if (t.Equals (InternalType.UInt32)) {
            assert (!is_neg);
            unchecked (emit_i4 (k :> int))
          } else
            if (k <= System.Int32.MaxValue)
              emit_i4 (if (is_neg) - (k :> int) else (k :> int))
            else if (k == (- (System.Int32.MinValue : long)) :> ulong && is_neg)
              emit_i4 (System.Int32.MinValue)
            else {
              Message.Warning ($ "cannot emit: $l : $t");
              assert (false)
            }
          
        | Literal.String (s)   =>
          assert (s != null); _ilg.Emit (OpCodes.Ldstr, s)
          
        | Literal.Float (f)    => _ilg.Emit (OpCodes.Ldc_R4, f)
        | Literal.Double (f)   => _ilg.Emit (OpCodes.Ldc_R8, f)
        | Literal.Decimal (m)  =>
          def decimal_bits = System.Decimal.GetBits (m);

          _ilg.Emit (OpCodes.Ldc_I4_4);

          _ilg.Emit (OpCodes.Newarr, SystemTypeCache.Int32);

          when (decimal_bits [0] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [1] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [2] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [3] != 0)
            _ilg.Emit (OpCodes.Dup);

          when (decimal_bits [0] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [0]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [1] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [1]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [2] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_2);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [2]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [3] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_3);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [3]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }

          _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get ("Int32[]")))

        | Literal.Enum (l, _, _) => emit_literal (l)
      }
    }


    /**
     * Emits a comparison operation
     */
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }

#pragma warning disable 10003

    class NemerleGenerator
    {
      private _ilg : ILGenerator;

      public this(ilg : ILGenerator)
      {
        _ilg = ilg;
      }

      private mutable _document : ISymbolDocumentWriter;

      public SetDocument (document : ISymbolDocumentWriter) : void
      {
        _document = document;
      }

      public BeginCatchBlock (tp : Type) : void  { _throw = false; _ilg.BeginCatchBlock(tp)      }
      public BeginExceptFilterBlock ()   : void  {                 _ilg.BeginExceptFilterBlock() }
      public BeginExceptionBlock    ()   : Label {                 _ilg.BeginExceptionBlock()    }
      public BeginFaultBlock        ()   : void  {                 _ilg.BeginFaultBlock()        }
      public BeginFinallyBlock      ()   : void  { _throw = false; _ilg.BeginFinallyBlock()      }
      public EndExceptionBlock      ()   : void  {                 _ilg.EndExceptionBlock()      }

      public ThrowException (excType : Type) : void { _ilg.ThrowException(excType) }

      public BeginScope () : void { _ilg.BeginScope() }
      public EndScope   () : void { _ilg.EndScope  () }

      public DeclareLocal (localType : Type)                : LocalBuilder { _ilg.DeclareLocal(localType)         }
      public DeclareLocal (localType : Type, pinned : bool) : LocalBuilder { _ilg.DeclareLocal(localType, pinned) }

      public DefineLabel () : Label { _ilg.DefineLabel() }

      public Emit (opcode : OpCode)                              : void { Emited(opcode); _ilg.Emit(opcode)            }
      public Emit (opcode : OpCode, arg       : byte)            : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, con       : ConstructorInfo) : void { Emited(opcode); _ilg.Emit(opcode, con)       }
      public Emit (opcode : OpCode, arg       : double )         : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, field     : FieldInfo )      : void { Emited(opcode); _ilg.Emit(opcode, field)     }
      public Emit (opcode : OpCode, arg       : float)           : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, arg       : int)             : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, label     : Label)           : void { Emited(opcode); _ilg.Emit(opcode, label)     }
      public Emit (opcode : OpCode, labels    : array[Label])    : void { Emited(opcode); _ilg.Emit(opcode, labels)    }
      public Emit (opcode : OpCode, local     : LocalBuilder)    : void { Emited(opcode); _ilg.Emit(opcode, local)     }
      public Emit (opcode : OpCode, arg       : long)            : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, meth      : MethodInfo)      : void { Emited(opcode); _ilg.Emit(opcode, meth)      }
      public Emit (opcode : OpCode, arg       : sbyte)           : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, arg       : short)           : void { Emited(opcode); _ilg.Emit(opcode, arg)       }
      public Emit (opcode : OpCode, signature : SignatureHelper) : void { Emited(opcode); _ilg.Emit(opcode, signature) }
      public Emit (opcode : OpCode, str       : string)          : void { Emited(opcode); _ilg.Emit(opcode, str)       }
      public Emit (opcode : OpCode, cls       : Type)            : void { Emited(opcode); _ilg.Emit(opcode, cls)       }

      public EmitCall (opcode : OpCode, methodInfo : MethodInfo , optionalParameterTypes : array[Type]) : void
        { Emited(opcode); _ilg.EmitCall(opcode, methodInfo, optionalParameterTypes) }
      public EmitCalli (opcode : OpCode, unmanagedCallConv : CallingConvention, returnType : Type, parameterTypes : array[Type]) : void
        { Emited(opcode); _ilg.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes) }
      public EmitCalli (opcode : OpCode, callingConvention : CallingConventions, returnType : Type, parameterTypes : array[Type], optionalParameterTypes : array[Type]) : void
        { Emited(opcode); _ilg.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes) }

      public EmitWriteLine (fld          : FieldInfo)    : void { _ilg.EmitWriteLine(fld)          }
      public EmitWriteLine (localBuilder : LocalBuilder) : void { _ilg.EmitWriteLine(localBuilder) }
      public EmitWriteLine (value        : string)       : void { _ilg.EmitWriteLine(value)        }

      public MarkLabel (loc : Label ) : void
      {
        _throw = false;

        _ilg.MarkLabel(loc);

        when (_marked)
        {
          _marked = false;

          // Hide from the debugger.
          //
          _ilg.MarkSequencePoint (_document, 0xFeeFee, 0, 0xFeeFee, 0);
          _ilg.Emit (OpCodes.Nop);
        }
      }

      private mutable _throw  : bool;
      private mutable _marked : bool;
      private mutable _first_code = true;

      public MarkSequencePoint (document : ISymbolDocumentWriter, startLine : int, startColumn : int, endLine : int, endColumn : int) : void
      {
        unless (_throw)
        {
          _marked = true;

          _ilg.MarkSequencePoint (document, startLine, startColumn, endLine, endColumn);
          _ilg.Emit (OpCodes.Nop);
        }
      }

      public UsingNamespace (usingNamespace : string) : void { _ilg.UsingNamespace(usingNamespace) }

      private Emited(opcode : OpCode) : void
      {
        when (_first_code)
        {
          _first_code = false;

          when (_document != null && !_marked)
            _ilg.MarkSequencePoint (_document, 0xFeeFee, 0, 0xFeeFee, 0);
        }

        when (opcode == OpCodes.Throw || opcode == OpCodes.Rethrow)
          _throw = true;
      }
    }

#pragma warning restore 10003

  } /* end of the class */

} /* end of the namespace */
