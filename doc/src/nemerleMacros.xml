<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>Nemerle type-safe macros</title>
  <section>
    <title>Intro</title>    
    <body>
      <p>
        You can think about macros as system of compile-time transformations 
        and automatic generation of code with regard to some rules. 
        It can be used either
	to automate simple actions performed on similar sets of data-types
	and fragments of code or to enrich language with some shortcuts
	to complicated function calls or other programming tricks,
	which makes coding faster.
      </p>
      <p>
        Idea of making simple inline operations on code comes from macros,
	which many languages (especially C, C++) contained since early times
	of compiler design. We are following them in direction of much more
	powerful, and at the same time more secure (type-safe), solutions
	like Haskell template meta-programming.
      </p>
    </body>
  </section>
  <section>
    <title>Key features</title>
      <body>
        <ul>
	  <li> creating functions, whose amount and type of arguments depend
	    on each other (like C printf); our system would allow various 
	    transformations resulting in encapsulation of complex function
	    calls into simple and clear code</li>
	  <li> algorithmic generation of code, which may be dependent on
	    external factors, like XML files, script programs or even remote
	    web sites </li>
	  <li> completing data-types with automatically created methods for
	    arbitrary operations on them, e.g. reading datasets from file,
	    sending then through network or storing in SQL database </li>
	  <li> using context of compilation provided by compiler's internal
	    structures, like line number (for error reporting), names of
	    processed type, function, class or namespace </li>
	</ul>
    </body>
  </section>
  <section>
    <title>What exactly macro is?</title>
      <body>
        <p>
	  Basically every macro is a function, which takes some fragment
	  of code as parameter(s) and returns some other code. On the highest 
	  level it doesn't matter if they are type definitions, function calls 
	  or just a list of assignments. Most important fact is that they are 
	  not common objects (e.g. instances of defined types, like integer 
	  numbers), but their internal representation in compiler (i.e. syntax 
	  tree).
	</p>
	<p>
	  Those functions are defined in program just like any other functions.
	  They are written in common Nemerle syntax and the only difference
	  is the structure of data they operate on (we provide special ways
	  to parse and generate syntax trees).
	</p>  
	<p>
	  Macros, once defined, can be used to process some part of the code.
	  It's done by calling them with block(s) of code as parameters. 
	  This operation is in most cases indistinguishable from common function
	  calls, so programmer using macros won't be confused by unknown
	  syntax. Main concept of design is to make usage macros as much 
          transparent as possible. From the user point of view, it is not 
          important if particular parameters are passed to ordinary function 
          or one, which would process them at compile time and insert some new 
          code in their place.
	</p>
      </body>
  </section>
  <section>
    <title>Usage</title>
      <subsection>
        <title>Defining new extension</title>
          <body>
            <p>
	      Writing a macro is as simple as writing common function, except
	      it is proceeded by keyword <tt>macro</tt>. This will make compiler
	      know about how to use defined method (i.e. run it at compile time
	      when it is called). 
	    </p>
	    <p>
	      Macros can take zero (if we just want to generate new code)
	      or more parameters. They are all of the type <tt>syntax_tree</tt>,
	      the same as return value.
	    </p>
	    <p>
	      Example:
	    </p>  
<code>
macro doNothing () : syntax_tree 
{
  &lt;[ () ]&gt;
}
</code>
	    <p>
	      This example macro doesn't take any parameters, so it's used in 
              code by simply writing <tt>doNothing();</tt>. It makes nothing
	      special, just inserts '<tt>()</tt>' (return value of its
	      execution) in place where it's used.
	    </p>
	  </body>
      </subsection>      
      <subsection>
        <title>Operating on syntax trees</title>
	  <body>
	    <p>
	      The example above shows simplest macro, but it also 
	      introduced some new syntax used only in writing macros.
	      We've written here <tt>&lt;[ ... ]&gt;</tt> constructor to
	      build syntax tree of expression '<tt>()</tt>'.
	    </p>
            <subsubsection>
              <title>Quotation operator</title>
                <body>
	          <p>
	            <tt>&lt;[ ... ]&gt;</tt> is used to both construction and 
                    decomposition of syntax trees. Those operations are similar to
                    quotation of code. Simply, everything which is written inside 
                    <tt>&lt;[ ... ]&gt;</tt>, corresponds to its own syntax tree. 
                    It can be any valid Nemerle code, so programmer doesn't have to 
                    learn internal structure of trees in compiler.
	         </p>
<code>
macro fold_one_plus_one ( expr : syntax_tree ) : syntax_tree
{                   
  match expr with [
    | &lt;[ 1 + 1 ]&gt; =&gt;
        &lt;[ 2 ]&gt;
    | _ =&gt; expr
}
</code>
                  <p>
                    Quotation alone allows using only constant expressions, which
                    is insufficient for most tasks. In next section we introduce
                    rest of macros' syntax to operate on general syntax trees.
	    	</body>
            </subsubsection>
            <subsubsection>
              <title>Matching subexpressions</title>
                <body>
	          <p>
                    When we want to decompose some large code (or more precisely, 
                    its syntax tree), we must bind its smaller parts to variables.
                    Then we can process them recursively or just use them in 
                    arbitrary way to construct the result.
                  </p>
                  <p>
                    We can operate on entire subexpressions by writing 
                    <tt>$( ... )</tt> inside quotation operator 
                    <tt>&lt;[ ... ]&gt;</tt>.
                  </p>
<code>
macro switch_sub_add ( expr : syntax_tree ) : syntax_tree
{                   
  match expr with [
    | &lt;[ $(a) + $(b) ]&gt; =&gt;
       &lt;[ $(switch_sub_add (a)) - $(swith_sub_add (b))]&gt;
    | &lt;[ $(a) - $(b) ]&gt; =&gt;
       &lt;[ $(switch_sub_add (a)) + $(swith_sub_add (b))]&gt;
    | _ =&gt; expr
}
</code>
                  <p>
                    Above macro traverses expression builded with <tt>+</tt>
                    and <tt>-</tt> recursively, changing all operators.
                  </p>
	    	</body>
            </subsubsection>
        </body>
      </subsection>
  </section>
</document>
