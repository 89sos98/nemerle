open Nemerle.Compiler;
open Nemerle.Collections;

namespace Nemerle.Compiler {

  class Treeutil
    {
      fun ('a) decl_walk(tydecl_f : 'a * Type_decl -> 'a,
                         decl_f : 'a * Class_member -> void,
                         ctx : 'a,
                         tydecls : list (Type_decl)) : void =

        letfun do_tydecl(ctx : 'a, decl : Type_decl) : void =
          try
            Util.locate(decl#loc, fun () : void =>
              let ctx' = tydecl_f(ctx, decl) in
              match decl with [
                | TD_class (?ds) => do_decls(ctx', ds)
                | TD_interface (?ds) => do_decls(ctx', ds)
                | TD_variant (?tds) => 
                  List.iter(fun (d : Type_decl) : void => do_tydecl(ctx', d), tds)
                | TD_variant_option (?ds) => do_decls(ctx', ds)
                | TD_alias => ()
                | TD_external => ()
              ])
          with (?x : Recovery) ()
        and do_decls(ctx : 'a, decls : list (Class_member)) : void =
          letfun do_decl (decl : Class_member) : void =
            try
              Util.locate(decl#loc, fun () : void => {
                decl_f(ctx, decl);
                match decl with [
                  | M_type (?t) => do_tydecl(ctx, t)
                  | M_iface_method => ()
                  | M_function => ()
                  | M_field => ()
                  | M_value => ()
                ]})
            with (?x : Recovery) ()
          in 
          List.iter(do_decl, decls)
        in
        List.iter(fun (d : Type_decl) : void => do_tydecl(ctx, d), tydecls);
    }

  class Passes
    {
      fun run(decls : list (list (Top_decl))) : void =
        let _ = Env.globals <- Map.string_map() in
        let dd = List.map(Scan_globals.run, List.rev(decls)) in
        let decls = List.concat(dd) in {
          Bind_types.run(decls);
        };
    }

} // N.C
