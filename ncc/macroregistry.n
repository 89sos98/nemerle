(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

(** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 *)
public interface IMacro {
  GetName () : string;
  Run (ctx : CTX, args : list (PT.Parm)) : MacroRegistry.MacroExpansionResult;
} 

public module MacroRegistry {
  public variant MacroExpansionResult {
    | Typed { tyex : Nemerle.Compiler.Typedtree.Expr; }
    | Untyped { paex : Nemerle.Compiler.Parsetree.Expr; }
  }

  mutable macros : Hashtable (string, IMacro);

  this () {
    macros <- Hashtable ();
  }

  public register_macro (m : IMacro) : void {
    def name = m.GetName ();
    if (macros.Contains (name))
      Util.ice ("macro already registered: " + name)
    else
      macros.Set (name, m)
  }

  public expand_macro (ctx : CTX, expr : PT.Expr) : MacroExpansionResult {
    match (expr) {
      | PT.E_call (PT.E_ref (n), args) =>
        match (macros.Get (n)) {
          | Some (x) => 
            def expanded = x.Run (ctx, args);
            match (expanded) {
              | Typed => expanded
              | Untyped (e) => expand_macro (ctx, e)
            }
          | None => Untyped (expr)
        }
      | _ => Untyped (expr)
    }
  }

}
} // end ns
