using System;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;

namespace LRPEGCC
{
  public class CriticalUnexpectedException : Exception  { }
  
  /// <summary>
  /// Description of Parsing.
  /// </summary>
  module Parsing
  {
    public ParseRules(typer : Typer, startRule : RuleRef, rules : PExpr) : Grammar
    {
      match (rules)
      { // Match grammar { ... } RawToken macro (defined above)
      | MacroCall(name, _ns, [SyntaxElement.RawToken(LooseGroup(BracesGroup(tokens, _)))]) => // Name * NamespaceTree.Node * list [SyntaxElement]
        if (name.Id != "grammar")
          ReportCriticalUnexpected(rules, "grammar { ... }")
        else
          Parsing.ParseEbnf(typer, tokens, Grammar(startRule))
      | rule            => ReportCriticalUnexpected(rule, "grammar { ... }")
      }
    }

    public ParseEbnf(typer : Typer, token : Token, grammar : Grammar) : Grammar
    {
      #region Grammar rules
      // Rule            = RuleName Eq OrderedChoice
      // OrderedChoice   = Sequence ('/' Sequence)*
      // Sequence        = PredicateRule+
      // PredicateRule   = ('!' / '&')? CardinalityRule
      // CardinalityRule = SimpleRule ('?' / '+' / '*')?
      // SimpleRule      = FailureRecovery '(' OrderedChoice ')', RuleName '{' OrderedChoice '}' / RuleName / Range / Char / String / '(' OrderedChoice ')' / Empty
      // RuleName        = Token.Identifier(name)
      // Char            = Token.CharLiteral
      // String          = Token.StringLiteral
      // Range           = Token.SquareGroup(LooseGroup(CharLiteral, Operator(".."), CharLiteral))
      // Eq              = Token.Operator("=")
      // Empty           = Token.Identifier("Empty")
      #endregion Grammar rules
      #region Parse helpers
      
      def parseZeroOrMany(
        tok            : Token,
        parseDelemiter : Token -> Token,
        parseParser    : Token -> Rule * Token
      )
        : list[Rule] * Token
      {
        def tok1 = match (tok)
          {
            | LooseGroup(child) => child
            | _ => tok
          };

        def (seq, nextTok) = parseParser(tok1);
        
        def loop(tok, acc) : list[Rule] * Token
        {
          def nextTok1 = if (parseDelemiter == null) tok else parseDelemiter(tok);
            
          if (nextTok1 == null)
            (acc, tok) // predicate not matched
          else
          {
            def (seq, nextTok2) = parseParser(nextTok1);
            if (seq == null)           (acc, nextTok2)
            else if (nextTok2 == null) (seq :: acc, null)
            else                       loop(nextTok2, seq :: acc)
          }
        }
        
        if (seq == null)
          ([], tok)
        else if (nextTok == null)
          ([seq], nextTok)
        else
        {
          def (res, nextTok) = loop(nextTok, [seq]);
          (res.Rev(), nextTok)
        }
      }

      def parseOneOrMany(
        tok : Token,
        parseDelemiter : Token -> Token,
        parseParser    : Token -> Rule * Token,
        expected : string
      ) : list[Rule] * Token
      {
        def result = parseZeroOrMany(tok, parseDelemiter, parseParser);

        when (result[0].IsEmpty)
          _ = ReportCriticalUnexpected(tok, expected);

        result
      }

      #endregion Parse helpers
      #region Rules parsing
      
      def parser = MainParser(typer.Env);

      // Range           = Token.SquareGroup(LooseGroup(CharLiteral, Operator(".."), CharLiteral))
      def parseRange(tok : Token) : Rule * Token
      {
        | SquareGroup(entry) =>
          def parseEntry(entry : Token, set : RangeSet) : RangeSet
          {
            match (entry)
            {
              | LooseGroup(CharLiteral
                where (Next = Operator where (name = "..", Next = CharLiteral as ch2)) as ch1) =>
                
                def resSet = set.AddRange(ch1.value, ch2.value);
                if (entry.Next == null) resSet
                else                    parseEntry(entry.Next, resSet)
                  
              | CharLiteral(ch) => 
                def resSet = set.AddRange(ch, ch);
                if (entry.Next == null) resSet
                else                    parseEntry(entry.Next, resSet)

              | LooseGroup(Identifier(name))
              | Identifier(name) =>
                match(UnicodeCategoryTable.StrToUnicodeCategory(name)) 
                {
                  | Some(cat) =>
                    def resSet = set.AddRange(cat);
                    if (entry.Next == null) resSet
                    else                    parseEntry(entry.Next, resSet)
                  | _ => ReportCriticalUnexpected(entry, "valid unicode class name")
                }

              | _ => ReportCriticalUnexpected(entry, "startChar .. endChar or char")
            }
          }
          
          def set = parseEntry(entry, RangeSet());
          (Rule.Chars(tok.Location, [set]), tok.Next)
          
        | _ => ReportCriticalUnexpected(tok, "[ ... ]")
      }
      // SimpleRule      = FailureRecovery '(' Identifier,  OrderedChoice ')', RuleName '{' OrderedChoice '}' / RuleName / Range / Char / String / '(' OrderedChoice ')' / Empty
      and parseSimpleRule(tok : Token) : Rule * Token
      {
        | SquareGroup as group        => (parseRange(group)[0], group.Next)
        | Token.Operator("%")         => (Rule.Cut(tok.Location), tok.Next)
        | Identifier(name)            =>
          def ruleName = RuleRef(tok.Location, name);
          
          match (tok.Next)
          {
            | RoundGroup when name == "FailureRecovery" => 
              def (recoveryRule, next) = parceRecoveryParams(tok);
              (recoveryRule, next) // unfortunatly tuple not support covariance and we need repack it
              
            | BracesGroup as group => (Rule.Scope(tok.Location + group.Location, ruleName, parseOrderedChoice(group.Child)[0]), group.Next)
            | _                    => (Rule.Call(tok.Location, ruleName), tok.Next)
          }
          
        | RoundGroup as group         => (parseOrderedChoice(group.Child)[0], group.Next)
        | StringLiteral(value = str)  => (Rule.Chars(tok.Location, str.Map(ch => RangeSet().AddRange(ch, ch))), tok.Next)
        | CharLiteral(ch)             => (Rule.Chars(tok.Location, [RangeSet().AddRange(ch, ch)]), tok.Next)
        | null                        => (Rule.Sequence([]), null)
        | _                           => (null, tok)
      }
      // CardinalityRule = SimpleRule ('?' / '+' / '*')?
      and parseCardinalityRule(tok : Token) : Rule * Token
      {
        def (innerRule, nextTok2) = parseSimpleRule(tok);
        
        match (nextTok2)
        {
          | Operator("?") => (Rule.RepeatMinMax(nextTok2.Location, 0, 1, innerRule), nextTok2.Next)
          | Operator("+") => (Rule.RepeatMin(nextTok2.Location, 1, innerRule),       nextTok2.Next)
          | Operator("*") => (Rule.RepeatMin(nextTok2.Location, 0, innerRule),       nextTok2.Next)
          | _             => (innerRule, nextTok2)
        }
      }
      // PredicateRule   = ('!' / '&')? CardinalityRule
      and parsePredicateRule(tok : Token) : Rule * Token
      {
        def (rule, nextTok1) =
          match (tok)
          {
           | Operator("!") => (Rule.Not : Location * Rule -> Rule, tok.Next)
           | Operator("&") => (Rule.And : Location * Rule -> Rule, tok.Next)
           | _             => (null,     tok)
          };
          
        def (innerRule, nextTok2) = parseCardinalityRule(nextTok1);
        if (rule == null) (innerRule,       nextTok2)
        else              (rule(tok.Location, innerRule), nextTok2)
      }
      // Sequence        = PredicateRule+
      and parseSequence(tok : Token) : Rule * Token
      {
        def  (seqs, nextTok) = parseOneOrMany(tok, null, parsePredicateRule, "PredicateRule");
        def loc = if (seqs.IsEmpty) tok.Location else tok.Location + seqs.Last.Location;
        (Rule.Sequence(loc, seqs), nextTok)
      }
      // OrderedChoice   = Sequence ( '/' Sequence)*
      and parseOrderedChoice(tok : Token) : Rule * Token
      {
        def parseSlash(tok : Token) : Token
        {
          | Operator("/") => 
            if (tok.Next == null) ReportCriticalUnexpected(tok, "rule")
            else tok.Next
            
          | _             => null
        }
      
        def  (seqs, nextTok) = parseOneOrMany(tok, parseSlash, parseSequence, "sequence");
        def loc = if (seqs.IsEmpty) tok.Location else tok.Location + seqs.Last.Location;
        (Rule.Choice(loc, seqs), nextTok)
      }
      and parceRecoveryParams(tok : Token) : Rule.Recovery * Token
      {
        match (tok.Next)
        {
          | RoundGroup as group => 
            match (group.Child)
            {
              | LooseGroup(Identifier(handlerName) as id) as looseGroup => 
                if (looseGroup.Next is LooseGroup)
                {
                  when (looseGroup.Next == null)
                    _ = ReportCriticalUnexpected(looseGroup, "recovery-handler-name, stopper-rule, rule-to-skip");
                  when (looseGroup.Next.Next == null)
                    _ = ReportCriticalUnexpected(looseGroup.Next, "recovery-handler-name, stopper-rule, rule-to-skip");

                  def (stopperRule, _) = parseOrderedChoice(looseGroup.Next);
                  def (skipRule, _)    = parseOrderedChoice(looseGroup.Next.Next);

                  (Rule.Recovery(tok.Location + group.Location, 
                                 RuleRef(id.Location, handlerName),
                                 stopperRule,
                                 skipRule), group.Next)
                }
                else
                  ReportCriticalUnexpected(group, "(recovery-handler-name, stopper-rule, rule-to-skip)")

              | _ => ReportCriticalUnexpected(group, "(recovery-handler-name, stopper-rule, rule-to-skip)")
            }
          | null => ReportCriticalUnexpected(tok, "FailureRecovery(recovery-handler-name, stopper-rule, rule-to-skip)")
          | x => ReportCriticalUnexpected(x, "(recovery-handler-name, stopper-rule, rule-to-skip)")
        }
      }
      // Rule            = RuleName Eq OrderedChoice
      def parseRule(tok : Token, ruleId : int) : RuleDefinition
      {
        def getName(tok : Token) : RuleRef
        {
          match (tok.Next)
          {
            | Identifier(name) as id  =>
              when (id.Next != null)
                ReportUnexpected(id.Next, "nothing");
              
              RuleRef(id.Location, name)
                
            | null                    => ReportCriticalUnexpected(tok, "rule-name");
            | x                       => ReportCriticalUnexpected(x, "rule-name");
          }
        }
        match (tok)
        {
          | LooseGroup(child) =>
            def parceAttrs(tok)
            {
              | SquareGroup(child) =>
              
                def parseAttr(g) : RuleAttribute * Token
                {
                  | LooseGroup(tok) =>
                    match (tok)
                    {
                      | Identifier("Inline")            => (RuleAttribute.Inline(g.Location), g.Next)
                      | Identifier("InlineAllSubrules") => (RuleAttribute.InlineAllSubrules(g.Location), g.Next)
                      | Identifier("Extensible")        => (RuleAttribute.Extensible(g.Location), g.Next)
                      | Operator("%")   => 
                        def (recoveryRule, next) = parceRecoveryParams(tok);
                        (RuleAttribute.Cut(recoveryRule), next)
                        
                      | Identifier("FailureRecovery")   => 
                        def (recoveryRule, next) = parceRecoveryParams(tok);
                        (RuleAttribute.Recovery(recoveryRule), next)
                        
                      | Operator("<")   => (RuleAttribute.PrecedenceLesserThan (g.Location, getName(tok)), g.Next)
                      | Operator(">")   => (RuleAttribute.PrecedenceGreaterThan(g.Location, getName(tok)), g.Next)
                      | Operator("==")  => (RuleAttribute.PrecedenceEqualsTo   (g.Location, getName(tok)), g.Next)
                      | _ => ReportCriticalUnexpected(g, RuleAttribute.GetUsages())
                    }
                  
                  | _ => ReportCriticalUnexpected(tok, RuleAttribute.GetUsages())
                }
                def parseAttrs(currTok : Token, attrs = [])
                {
                  if (currTok == null) attrs.Reverse()
                  else
                  {
                    def (attr, next) = parseAttr(currTok);
                    parseAttrs(next, attr :: attrs)
                  }
                }
                
                (tok.Next, parseAttrs(child, []))
                
              | _ => (tok, [])
            }
            def (tok2, ruleAttrs) = parceAttrs(child);
              
            def (expr, nextToken) = parser.ParseExpr(tok2, TokenStoppers.All);
            
            when (!(nextToken is Operator("=")) || nextToken.Next == null)
              _ = ReportUnexpected(nextToken, "'=' rule-body ';'");

            def (rule, nextTok) = parseOrderedChoice(nextToken.Next);
          
            def (id, ruleType) =
              match (expr)
              {
                | <[ $name : $ty ]> => (name, Some(BindFixedType(ty, typer)))
                | Ref as name       => (name, None())
                | _                 => ReportCriticalUnexpected(tok2, "rule-name (':' return-type)?");
              };

            when (nextTok != null)
              _ = ReportUnexpected(nextTok, "EOF");

            def name = RuleRef(id.Location, id.ToString());
            RuleDefinition(id.Location + rule.Location, ruleId, name, ruleType, ruleAttrs, rule);

          | _ => ReportCriticalUnexpected(token, " rule-name = rule-body;")
        }
      }
      def parseGramar(grammar : Grammar, token : Token) : Grammar
      {
        def ruleDefinition = parseRule(token, grammar.Count);

        if (ruleDefinition.Rule == null)
          grammar
        else if (token.Next == null)
          grammar.Add(ruleDefinition)
        else
          parseGramar(grammar.Add(ruleDefinition), token.Next)
      }

      #endregion Rules parsing

      parseGramar(grammar, token)
    }

    mutable _debug : bool = true;

    #region Error handling

    ReportCriticalUnexpected[T](token : Token, expected : string) : T
    {
      ReportUnexpected(token, expected);
      throw CriticalUnexpectedException()
    }

    ReportUnexpected(token : Token, expected : string) : void
    {
      assert2(!_debug);
      Message.Error(token.Location, $"expected «$expected» but found «$token» ($(token.GetType().Name))");
    }

    ReportUnexpected(expr : PExpr, expected : string) : void
    {
      assert2(!_debug);
      Message.Error(expr.Location, $"expected $expected but found $expr ($(expr.GetType().Name))");
    }

    ReportCriticalUnexpected[T](expr : PExpr, expected : string) : T
    {
      ReportUnexpected(expr, expected);
      throw CriticalUnexpectedException()
    }

    #endregion
    
    #region Helpers
    
    BindFixedType(id : PExpr, typer : Typer) : RuleType.NType
    {
      RuleType.NType(id.Location, typer.BindFixedType(id))
    }
    
    #endregion
  }
}
