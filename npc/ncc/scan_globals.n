open Nemerle.Compiler;
open Nemerle.Collections;


namespace Nemerle.Compiler {

(*
pass 1:
  Walk through Top_decls, set env field for all global symbols, register
  all global symbols. Return list of Type_decls.
*)

class Scan_globals
  {
    fun run (decls : list (Top_decl)) : list (Type_decl) =
      letfun in_prefix (env : Env, n : string) : Env =
        let env' = env#copy() in {
          env'#current_namespace <- env#current_namespace + n + ".";
          env'
        }
      in
      letfun make_member(d : Type_decl) : Class_member =
        let mem = M_type(d) in {
          mem#name <- d#name;
          mem#loc <- d#loc;
          mem#modifiers <- d#modifiers;
          mem#env <- d#env;
          mem#id <- d#id;
          mem
        }
      in
      letfun do_type(env : Env, t : Type_decl) : Env {
        t#env <- env;
        Env.add_global(env#current_namespace, make_member(t));
        in_prefix(env, t#name)
      } and do_decl(env : Env, d : Class_member) : void {
        if env == null then Util.ice() else
        d#env <- env;
        match d with [
          | M_type => ()
          | _ => Env.add_global(env#current_namespace, d)
        ]
      } in
      letfun loop (state : Env * list (Type_decl), decl : Top_decl) : Env * list (Type_decl) =
        let (?env, ?acc) = state in
        match decl with [
          | TD_namespace (?n, ?d) =>
            let env' = in_prefix(env, n) in
            let (_, ?acc) = List.fold_left (loop, (env', acc), d) in
            (env, acc)
          | TD_open (?n) =>
            let env' = env#copy() in {
              env'#add_open(n);
              (env', acc)
            }
          | TD_namespace_alias (?s, ?l) =>
            let env' = env#copy() in {
              env'#add_namespace_alias(s, l);
              (env', acc)
            }
          | TD_type (?d) =>
            {
// Message.error("decl walk");
              Treeutil.decl_walk(do_type, do_decl, env, List.cons(d));
              (env, Cons(d, acc))
            }
        ]
      in 
      let env = Env() in {
        env#add_open("Nemerle.Core");
        let (_, ?r) = List.fold_left (loop, (env, Nil()), decls) 
        in List.rev(r)
      };
  }


(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

} // N.C
