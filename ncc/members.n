/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;

using System.Reflection;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public class NemerleMember : IMember {
  loc : Location;
  protected mutable name : string;
  protected accessibility : Accessibility;
  internal modifiers : Modifiers;
  declaring_type : TypeBuilder;
  id : int;
  protected mutable kind : MemberKind;
  internal mutable ty : Type;
  protected mutable handle : MemberInfo;

  mutable is_protected : bool;
  mutable is_public : bool;
  mutable is_internal : bool;

  protected this (par : TypeBuilder, d : PT.Class_member) {
    loc = d.loc;
    modifiers = d.modifiers;
    name = List.Head (Macros.UnSString (d.name)); 
    declaring_type = par;
    id = Util.next_id ();

    is_public = modifiers.mods %&& NemerleAttributes.Public;
    is_internal = modifiers.mods %&& NemerleAttributes.Internal;
    is_protected = modifiers.mods %&& NemerleAttributes.Protected;

    if (is_public)
      accessibility = A_public ()
    else if (is_protected && is_internal)
      accessibility = A_protected_or_internal ()
    else if (is_protected)
      accessibility = A_protected ()
    else if (is_internal)
      accessibility = A_internal ()
    else
      accessibility = A_private ();

    match ((par.GetAccessibility (), accessibility)) {
      | (A_private, _) =>
        accessibility = A_private ()
      | (A_public, _) => ()
      | (A_internal, A_public) =>
        accessibility = A_internal ()
      | (A_protected, A_internal)
      | (A_internal, A_protected) =>
        accessibility = A_protected_and_internal ()
      | _ => ()
    }
  }

  public CanAccess (source : Tycon) : bool
  {
    def walk_declaring (tc : Tycon) {
      tc.SameAs (declaring_type) || 
        (tc.DeclaringType != null && walk_declaring (tc.DeclaringType))
    };
    is_public || 
    declaring_type.SameAs (source) ||
    (is_internal && 
      (match (source.GetTyconKind ()) { 
        | TK_NemerleType => true 
        | _ => false 
      })) || 
    (is_protected && Option.IsSome (source.SuperType (declaring_type))) ||
    walk_declaring (source)
  }

  public DeclaringType : Tycon {
    get { declaring_type }
  }

  public Name : string {
    get { name }
  }

  public MemberType : System.Reflection.MemberTypes {
    get {
      match (kind) {
        | MK_field => MemberTypes.Field
        | MK_method => MemberTypes.Method
        | MK_property => MemberTypes.Property
        | MK_type => MemberTypes.NestedType
        | MK_event => MemberTypes.Event
      }
    }
  }

  public GetMemType () : Type
  {
    ty
  }

  public GetKind () : MemberKind
  {
    kind
  }

  public GetLocation () : Location
  {
    loc
  }
  
  public Attributes : NemerleAttributes
  {
    get { modifiers.mods }
  }

  public GetModifiers () : Modifiers
  {
    modifiers
  }
  
  public IsStatic : bool
  {
    get { Attributes %&& NemerleAttributes.Static }
  }

  public GetId () : int
  {
    id
  }

  public virtual GetHandle () : System.Reflection.MemberInfo
  {
    assert (false)
  }

  public MarkWithSpecialName () : void
  {
    modifiers.mods = modifiers.mods %| NemerleAttributes.SpecialName
  }
}

public class NemerleField : NemerleMember, IField
{
  private is_mutable : bool;
  private is_volatile : bool;
  
  public mutable field_builder : Emit.FieldBuilder;
  public mutable enum_value : object;
  
  public this (par : TypeBuilder, f : PT.M_field) {
    base (par, f);
    def is_static = Attributes %&& NemerleAttributes.Static;
    is_mutable = Attributes %&& NemerleAttributes.Mutable;
    is_volatile = Attributes %&& NemerleAttributes.Volatile;
    ty =
      if (is_static)
        par.BindType (Tyvar.TEnv (), f.ty)
      else
        par.BindType (f.ty);
    kind = MK_field (this);
    Tyutil.CheckAccessibility (accessibility, ty);
  }

  public IsMutable : bool
  {
    get { is_mutable }
  }

  public IsVolatile : bool
  {
    get { is_volatile }
  }
  
  public IsLiteral : bool
  {
    get
    {
      match (DeclaringType.GetTydecl ()) {
        | TD_enum when IsStatic => true
        | _ => false
      }
    }
  }

  public GetValue () : object
  {
    assert (IsLiteral);
    enum_value
  }

  public GetFieldInfo () : FieldInfo
  {
    field_builder
  }
  
  override public GetHandle () : System.Reflection.MemberInfo
  {
    field_builder
  }
}

public class NemerleProperty : NemerleMember, IProperty
{
  is_mutable : bool;
  getter : NemerleMethod;
  setter : NemerleMethod;
  internal parms : list <Type>;
  
  internal mutable property_builder : Emit.PropertyBuilder;
  
  public this (par : TypeBuilder, f : PT.M_property) {
    base (par, f);
    is_mutable = Option.IsSome (f.set);
    
    def is_static = Attributes %&& NemerleAttributes.Static;
    ty =
      if (is_static)
        par.BindType (Tyvar.TEnv (), f.prop_ty)
      else
        par.BindType (f.prop_ty);

    kind = MK_property (this);
    Tyutil.CheckAccessibility (accessibility, ty);

    def loc = f.loc;
    def par = par;
    
    parms = 
      List.Map (f.dims, fun (parm : PT.Fun_parm) {
        par.BindType (parm.ty)
      });

    def kind =
      match (par.GetTydecl ()) {
        | TD_interface => FK_iface_method ()
        | _ => FK_method ([])
      };
      
    match (f.get) {
      | Some (meth) =>
        def name = PT.SS_string (PT.Name ("get_" + Name));
        def fh = PT.Fun_header (loc, name, f.ty, f.dims);
        def fn = PT.M_function (loc, fh.name, f.modifiers, fh, kind, meth);
        getter = NemerleMethod (par, (fn :> PT.M_function), is_property = true);
        par.AddMember (getter);
      | None => ()
    };
    match (f.set) {
      | Some (meth) =>
        def value_parm = PT.Fun_parm (loc, PT.SS_string (PT.Name ("value")), 
                                      f.ty, Modifiers.Empty);
        def parms = List.Append (f.dims, [value_parm]);
        def name = PT.SS_string (PT.Name ("set_" + Name));
        def fh = PT.Fun_header (loc, name, PT.T_void (), parms);
        def fn = PT.M_function (loc, fh.name, f.modifiers, fh, kind, meth);
        setter = NemerleMethod (par, (fn :> PT.M_function), is_property = true);
        par.AddMember (setter);
      | None => ()
    };
  }

  public IsMutable : bool
  {
    get { is_mutable }
  }

  public IsIndexer : bool
  {
    get
    {
      List.Length (parms) > 0
    }
  }
  
  public GetPropertyInfo () : PropertyInfo
  {
    property_builder
  }

  public GetGetter () : IMethod
  {
    getter
  }
  
  public GetSetter () : IMethod
  {
    setter
  }
  
  override public GetHandle () : System.Reflection.MemberInfo
  {
    property_builder
  }
}

public class NemerleMethod : NemerleMember, IMethod
{
  // FIXME: make these private
  public mutable fun_kind : Fun_kind;
  public mutable fun_body : Fun_body;
  public mutable fun_header : Fun_header;
  
  public mutable method_builder : System.Reflection.Emit.MethodBuilder;
  public mutable ctor_builder : System.Reflection.Emit.ConstructorBuilder;

  is_var_args : bool;

  public GetMethodBase () : MethodBase
  {
    if (method_builder == null)
      (ctor_builder : MethodBase)
    else
      method_builder
  }

  public override GetHandle () : MemberInfo
  {
    GetMethodBase ()
  }

  public GetConstructorBuilder () : Emit.ConstructorBuilder 
    implements IMethod.GetConstructorInfo
  {
    assert (ctor_builder != null);
    ctor_builder
  }
  
  public GetMethodBuilder () : Emit.MethodBuilder 
    implements IMethod.GetMethodInfo
  {
    assert (method_builder != null);
    method_builder
  }

  public GetExternName () : string
  {
    match (fun_body) {
      | FB_extern (name) => name
      | _ => null
    }
  }

  public HasExternBody : bool
  {
    get { (fun_body is FB_extern) }
  }

  public HasAbstractBody : bool
  {
    get { (fun_body is FB_abstract) }
  }
  
  public Body : PT.Expr {
    get {
      match (fun_body) {
        | FB_parsed_expr (e) => e
        | _ =>
          Message.fatal_error ("No parsetree body accessible")
      }
    }
    
    set { fun_body = FB_parsed_expr (value) }
  }
  
  public IsVarArgs : bool
  {
    get { is_var_args }
  }

  public this (par : TypeBuilder, f : PT.M_function)
  {
    this (par, f, false)
  }
  
  public this (par : TypeBuilder, f : PT.M_function, is_property : bool)
  {
    base (par, f);

    // convert +, -, /= name to op_Addition equivalents
    match (OperatorLongName (this.name, List.Length (f.header.parms))) {
      | Some (long) => this.name = long
      | None => ()
    };
    
    def par = par; // hack, so previouse par is not closurised
    def accessibility = accessibility; // ditto, this

    // both override and abstract imply virtual
    when (Attributes %&& (NemerleAttributes.Override 
                          %| NemerleAttributes.Abstract))
      modifiers.mods |= NemerleAttributes.Virtual;

    def is_static = Attributes %&& NemerleAttributes.Static;
 
    def (tenv', typarms) =
      if (is_static)
        par.BindTyparms (Tyvar.TEnv (), f.header.typarms)
      else
        par.BindTyparms (f.header.typarms);
    
    List.Iter (typarms, fun (tv) { 
      List.Iter (Tyvar.constraints (tv), fun (t) { 
        Tyutil.CheckAccessibility (accessibility, t)
      })
    });
    def bind (t) {
      def ty = par.BindType (tenv', t);
      Tyutil.CheckAccessibility (accessibility, ty);
      ty
    };
    def mkparm (p : PT.Fun_parm) : Fun_parm {
      def name = Macros.NameOfSString (p.name);
      Fun_parm (loc = p.loc, name = List.Head (name.idl), color = name.color, ty = bind (p.ty), 
                decl = null, modifiers = p.modifiers)
    };
    fun_body = f.body;
    
   /* We need to convert things like:
        foo (x : int * int) : int { bar }
            ===>
        foo (_1 : int, _2 : int) : int { def x = (_1, _2); bar }
      To be consistent. */

    def parms =
      match (f.header.parms) {
        | [parm] when ! is_property =>
          match (Tyutil.top_expand (bind (parm.ty))) {
            | T_prod (types) =>
              mutable modifiers = parm.modifiers;
              def mkdummyparm (t : Type) {
                // make the first argument intercept custom attributes
                def mods = modifiers;
                modifiers = Modifiers.Empty;
                Fun_parm (loc = parm.loc, 
                          name = Util.tmpname ("tupled"),
                          color = TypingContext.MacroColor,
                          ty = t, 
                          decl = null,
                          modifiers = mods)
              };
              def parms = List.Map (types, mkdummyparm);
              def refs = List.Map (parms, fun (fp : Fun_parm) {
                PT.E_ref (PT.Name (fp.name))
              });
              match (fun_body) {
                | FB_parsed_expr (body) =>
                  fun_body = FB_parsed_expr (<[ { def $(parm.name) =
                    ( .. $refs ); $body } ]>)
                | _ => Util.ice ()
              };
              parms
            | _ => List.Map (f.header.parms, mkparm)
          }
        | _ => List.Map (f.header.parms, mkparm)
      };

    when (! parms.IsEmpty ()) {
      def is_params (parm : Fun_parm) {
        List.Exists (parm.modifiers.custom_attrs, 
          fun (e) {
            | <[ System.ParamArrayAttribute ]>
            | <[ System.ParamArrayAttribute () ]>
            | <[ System.ParamArray ]>
            | <[ System.ParamArray () ]> => true
            | _ => false
          })
      }
      def (till_last, last) = List.DivideLast (parms);
      
      when (is_params (last)) {
        match (last.ty) {
          | T_array (_, 1) =>
            is_var_args = true
          | _ =>
            Message.error ("only single-dimensional arrays are allowed in `params' parameters")
        }
      }

      when (List.Exists (till_last, is_params))
        Message.error ("`params' is allowed only on last parameter");
    }

    fun_kind =
      match ((f.kind, this.name)) {
        | (FK_method ([]), ".ctor") when is_static =>
          this.name = ".cctor";
          FK_static_ctor ()
        | (FK_method ([]), ".ctor") =>
          FK_ctor ()
        | (FK_method ([]), _) when is_static =>
          FK_function ()
        | (FK_ctor, _) when is_static =>
          this.name = ".cctor";
          FK_static_ctor ()
        | (FK_method (_ :: _), ".ctor") =>
          Message.error ("constructor cannot implement anything");
          FK_ctor ()
        | (FK_method (_ :: _), _) when is_static =>
          Message.error ("static function cannot implement anything");
          FK_function ()
        | (x, _) => x
      };

    fun_header = Fun_header (
      ret_type = bind (f.header.ret_type),
      typarms = typarms,
      name = this.name,
      parms = parms,
      tenv = tenv',
      loc = f.header.loc);
      
    ty = Tyutil.fun_type (fun_header);
    
    kind = MK_method (this);
  }

  public SetHeader (h : Fun_header) : void {
    fun_header = h;
    ty = Tyutil.fun_type (fun_header);
  }

  public GetHeader () : Fun_header
  { fun_header }

  public ReturnType : Type {
    get { fun_header.ret_type }
  }
  
  public GetFreshType () : Type
  { GetMemType () /- Tyvar.fresh_subst (fun_header.typarms) }

  public GetFunKind () : Fun_kind
  { fun_kind }

  static OperatorLongName (op : string, params_amount : int) : option <string>
  {
    if (params_amount == 2) {
      match (op) {
        | ":" => Some ("op_Implicit")
        | ":>" => Some ("op_Explicit")
        | "+" => Some ("op_Addition")
        | "-" => Some ("op_Subtraction")
        | "*" => Some ("op_Multiply")
        | "/" => Some ("op_Division")
        | "%" => Some ("op_Modulus")
        | "%^" => Some ("op_ExclusiveOr")
        | "%&" => Some ("op_BitwiseAnd")
        | "%|" => Some ("op_BitwiseOr")
        | "&&" => Some ("op_LogicalAnd")
        | "||" => Some ("op_LogicalOr")
        | "=" => Some ("op_Assign")
        | "<<" => Some ("op_LeftShift")
        | ">>" => Some ("op_RightShift")
        // | ">>*" => Some ("op_SignedRightShift")
        // | ">>&" => Some ("op_UnsignedRightShift")
        | "==" => Some ("op_Equality")
        | ">" => Some ("op_GreaterThan")
        | "<" => Some ("op_LessThan")
        | "!=" => Some ("op_Inequality")
        | ">=" => Some ("op_GreaterThanOrEqual")
        | "<=" => Some ("op_LessThanOrEqual")
        | "*=" => Some ("op_MultiplicationAssignment")
        | "-=" => Some ("op_SubtractionAssignment")
        | "^=" => Some ("op_ExclusiveOrAssignment")
        | "<<=" => Some ("op_LeftShiftAssignment")
        | "%=" => Some ("op_ModulusAssignment")
        | "+=" => Some ("op_AdditionAssignment")
        | "&=" => Some ("op_BitwiseAndAssignment")
        | "|=" => Some ("op_BitwiseOrAssignment")
        | "," => Some ("op_Comma")
        | "/=" => Some ("op_DivisionAssignment")
        | _ => None ()
      }
    }
    else if (params_amount == 1) {
      match (op) {
        | "+" when params_amount == 1 => Some ("op_UnaryPlus")
        | "-" => Some ("op_UnaryNegation")        
        | "--" => Some ("op_Decrement")
        | "++" => Some ("op_Increment")
        | "~" => Some ("op_OnesComplement")
        | "!" => Some ("op_LogicalNot")
        | _ => None ()
      }
    }
    else None ()
  }
}

public class NemerleEvent
  : NemerleMember, IEvent
{
  is_mutable : bool;
  adder : NemerleMethod;
  remover : NemerleMethod;
  
  internal mutable event_builder : Emit.EventBuilder;
  internal storage_field : NemerleField;
  
  public this (par : TypeBuilder, f : PT.M_event) {
    base (par, f);
    
    def is_static = Attributes %&& NemerleAttributes.Static; 
    ty =
      if (is_static)
        par.BindType (Tyvar.TEnv (), f.ty)
      else
        par.BindType (f.ty);

    kind = MK_event (this);
    Tyutil.CheckAccessibility (accessibility, ty);

    def loc = f.loc;
    def par = par;

    def (is_iface, kind) =
      match (par.GetTydecl ()) {
        | TD_interface => (true, FK_iface_method ())
        | _ => (false, FK_method ([]))
      };

    def (add, remove) =
      match ((f.add, f.remove)) {
        | (Some (add), Some (remove)) =>
          (add, remove)
        | (None, None) =>
          if (is_iface)
            (FB_abstract (), FB_abstract ())
          else {
            def mods = 
              NemerleAttributes.Private %| NemerleAttributes.Mutable %|
              (if (is_static) NemerleAttributes.Static
               else NemerleAttributes.None);
            def field_name = PT.Name (Util.tmpname (List.Head (Macros.UnSString (f.name))));
            def field = PT.M_field (f.loc, PT.SS_string (field_name),
                                    Modifiers (mods, []), f.ty);
            storage_field = NemerleField (par, (field :> PT.M_field));
            par.AddMember (storage_field);

            (FB_parsed_expr (<[ $(field_name : name) += $("value" : dyn) ]>),
             FB_parsed_expr (<[ $(field_name : name) -= $("value" : dyn) ]>))
          }
        | _ =>
          Message.fatal_error ("events must have both `add' and `remove' methods")
      };
    
    def self = this;
    def make_method (pref, meth) {
      def name = PT.SS_string (PT.Name (pref + self.Name));
      def value_parm = PT.Fun_parm (loc, PT.SS_string (PT.Name ("value")), 
                                    f.ty, Modifiers.Empty);
      def fh = PT.Fun_header (loc, name, PT.T_void (), [value_parm]);
      def fn = PT.M_function (loc, fh.name, f.modifiers, fh, kind, meth);
      def meth' = NemerleMethod (par, (fn :> PT.M_function));
      par.AddMember (meth');
      meth'
    };

    adder = make_method ("add_", add);
    remover = make_method ("remove_", remove);
  }

  public GetEventInfo () : EventInfo
  {
    // for some reason !(event_builder : EventInfo)...
    assert (false)
  }

  public override GetHandle () : MemberInfo
  {
    // for some reason !(EventBuilder : EventInfo)...
    assert (false)
  }

  public GetAdder () : IMethod
  {
    adder
  }
  
  public GetRemover () : IMethod
  {
    remover
  }
}


}
