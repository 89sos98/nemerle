<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle Language Reference</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document presents in semi-formal way syntax and semantics
        of the Nemerle language. It is not meant to be a tutorial.
      </p>
      <p>
        We often refer to <tt>.NET</tt> terminology [FIXME: reference it].
      </p>
    </body>
  </section>


  <section id="lexical">
    <title>Lexical Conventions</title>
    <body>
      <p>
        Programs are written using the Unicode character set. Every
        Nemerle source file is reduced to a sequence of lexical units
        (tokens) separated by sequences of white characters (blanks).
      </p>
    </body>
    <subsection id="tokens">
      <title>Tokens</title>
      <body>
        <p>
          There are five classes of lexical tokens: 
        </p>
        <ul>
          <li>identifiers</li>
          <li>type variables</li>
          <li>keywords</li>
          <li>literals</li>
          <li>blanks</li>
        </ul>
<code>
/* A comment. */
// Also a comment

foo               // identifier
foo_bar foo' foo3 // other identifiers
42                // integer literal
0x2a              // hexadecimal integer literal
0o52              // octal integer literal
0b101010          // binary integer literal
'a'               // character literal
'\n'              // also a character literal
"foo\nbar"        // string literal
@"x\n"            // same as "x\\n"
@if               // keyword used as identifier
</code>
      </body>
    </subsection>
    <subsection id="blanks">
      <title>Blanks</title>
      <body>
        <p>
          Spaces, vertical and horizontal tabulation characters,
          new-page characters, new-line characters and comments (called blanks
          altogether) are discarded, but can separate other lexical tokens.
        </p>
        <p>
          A traditional comment begins with a <tt>/*</tt>, and ends with
          <tt>*/</tt>.  An end-of-line comment starts with <tt>//</tt>,
          and ends with the line terminator (ASCII LF character).
        </p>
      </body>
    </subsection>
    <subsection id="type-variables">
      <title>Type variables</title>
      <body>
        <p>
          Type variables occur in polymorfic definition of types. It can be
          any valid identifier.
        </p>
      </body>
    </subsection>
    <subsection id="identifiers">
      <title>Identifiers</title>
      <body>
        <p>
          Ordinary identifiers consist of letters, digits, underscores
          and apostrophe, but cannot begin with a digit nor an apostrophe.
          Identifiers may be quoted with the <tt>@</tt> character, which
          is stripped. It removes any lexical and syntactic meaning from
          the following string of characters until blank, thus enabling
          programmer to use keywords as identifiers.
        </p>
        <p>
          There is an important difference between identifiers starting
          with underscore character <tt>_</tt> and the other ones.
          When you define local value with name starting with <tt>_</tt>
          and won't use it, compiler won't complain about it. It will
          warn about other unused values though.
        </p>
        <p>
          Symbolic identifiers consist of following characters: 
          <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>@</tt>,
          <tt>^</tt>, <tt>|</tt>, <tt>&amp;</tt>, <tt>+</tt>, <tt>-</tt>,
          <tt>*</tt>, <tt>/</tt>, <tt>$</tt>, <tt>%</tt>, <tt>!</tt>,
          <tt>?</tt>, <tt>~</tt>, <tt>.</tt>, <tt>:</tt>, <tt>#</tt>.
          Symbolic identifiers are treated as standard identifiers except
          to the fact that they are always treated as infix operators.
        </p>
      </body>
    </subsection>
    <subsection id="keywords">
      <title>Keywords</title>
      <body>
        <p>
          Following identifiers are used as keywords, and may not be
          used in any other context unquoted:
          [[FIXME: update this list.]]
          <tt>_</tt>, <tt>abstract</tt>, <tt>and</tt>, <tt>array</tt>,
          <tt>as</tt>, <tt>base</tt>, <tt>class</tt>, <tt>const</tt>,
          <tt>def</tt>, <tt>else</tt>, <tt>ensure</tt>, <tt>enum</tt>,
          <tt>extern</tt>, <tt>finally</tt>, <tt>fun</tt>, <tt>if</tt>, 
          <tt>in</tt>, <tt>interface</tt>, <tt>internal</tt>,
          <tt>let</tt>, <tt>macro</tt>, <tt>match</tt>,
          <tt>module</tt>, <tt>mutable</tt>, <tt>namespace</tt>,
          <tt>new</tt>, <tt>null</tt>, <tt>using</tt>, <tt>out</tt>,
          <tt>private</tt>, <tt>protected</tt>, <tt>public</tt>,
          <tt>throw</tt>, <tt>ref</tt>, <tt>require</tt>, <tt>sealed</tt>,
          <tt>static</tt>, <tt>struct</tt>, <tt>then</tt>, <tt>this</tt>,
          <tt>try</tt>, <tt>tymatch</tt>, <tt>type</tt>, <tt>variant</tt>,
          <tt>void</tt>, <tt>volatile</tt>, <tt>where</tt>, <tt>with</tt>.
        </p>
        <p>
          Following infix identifiers are reserved keywords:
          <tt>=</tt>, <tt>$</tt>, <tt>?</tt>, <tt>|</tt>, <tt>&lt;-</tt>,
          <tt>-&gt;</tt>, <tt>=&gt;</tt>, <tt>&lt;[</tt>, <tt>]></tt>,
          <tt>&amp;&amp;</tt>, <tt>||</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="literals">
      <title>Literals</title>
      <body>
        <p>
          There are few kinds of literals:
            </p>
        <ul>
          <li>
            String literals, enclosed in <tt>""</tt>. Compiler processes
            backslash escapes much like in C#.
          </li>
          <li>
            Raw string literals, written like ordinary string literals,
            but prefixed with <tt>@</tt>. Escapes are not processed.
          </li>
          <li>
            Character literals, enclosed in <tt>'</tt>. Escapes are
            processed.
          </li>
          <li>
            Integer literals, possibly prefixed with <tt>0x</tt>,
            <tt>0o</tt> or <tt>0b</tt> to denote hexadecimal, octal or
            binary encoding respectively. The prefixes are not implemented 
            yet.
          </li>
          <li>
            Floating point literals, defined as:
            <rule name="floating_point_literal">
              <non-terminal name="digits"/>
              <terminal name="."/>
              <optional>
                 <non-terminal name="digits"/>
              </optional>
              <optional>
                 <non-terminal name="exponential_marker"/>
                 <optional>
                    <non-terminal name="sign"/>
                 </optional>
                 <non-terminal name="digits"/>
              </optional>
            </rule>
            <rule name="digits">
              <nonterminal name="digit"/>
              <repeat>
                <nonterminal name="digit"/>
              </repeat>
            </rule>
            <rule name="exponential_marker">
              <terminal name="e"/>
            </rule>
            <rule name="exponential_marker">
              <terminal name="E"/>
            </rule>
            <rule name="sign">
              <terminal name="+"/>
            </rule>
            <rule name="sign">
              <terminal name="-"/>
            </rule>
          </li>
        </ul>
      </body>
    </subsection>
  </section>


  <section id="compilation-units">
    <title>Compilation units</title>
    <body>
      <rule name="compilation_unit">
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
      </rule>
      <p>
        A Nemerle program consists of one or more compilation
        units. Compilation units are text files with the <tt>.n</tt> 
        extension. Compilation unit consists of namespace-related 
        declarations and types within them.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="using"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Add the specified namespace (which, unlike in C#, can also be a
        type name) to the symbol search path. Every symbol till end of
        current namespace or compilation unit (if not within namspace)
        will be searched also in location specified by this path.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <special-terminal name="IDENTIFIER"/>
        <terminal name="="/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Define an alias for a namespace. After <tt>namespace Foo =
        Bar.Baz;</tt> any reference to <tt>Foo.bar</tt> will be expanded
        to <tt>Bar.Baz.bar</tt>.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name="{"/>
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
        <terminal name="}"/>
      </rule>
      <p>
        Put declarations within the specified namespace. Namespaces can
        be nested, creating a tree of namespaces. 
      </p>
      <rule name="toplevel_declaration">
        <non-terminal name="type_declaration"/>
      </rule>
      <p>
        Define a new top level type.
      </p>
    </body>
  </section>


  <section id="misc">
    <title>Stuff that doesn't fit anywhere else</title>
    <body>
      <p>
        This section lists grammar rules common to most of other sections.
      </p>
    </body>
    <subsection id="id-or-dummy">
      <title>Identifier or dummy</title>
      <body>
        <rule name="identifier_or_dummy">
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <rule name="identifier_or_dummy">
          <terminal name="_"/>
        </rule>
        <p>
          In several places it is possible to use the <tt>_</tt> keyword to denote 
          the intent to ignore a parameter or return value. Semantics of <tt>_</tt> 
          in such places is to generate a new temporary name.
        </p>
      </body>
    </subsection>
    <subsection id="qid">
      <title>Qualified identifier</title>
      <body>
        <rule name="qualified_identifier">
          <special-terminal name="IDENTIFIER"/>
          <repeat>
            <terminal name="."/>
            <special-terminal name="IDENTIFIER"/>
          </repeat>
        </rule>
        <p>
          Identifiers can be qualified with namespaces.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-declarations">
    <title>Type declarations</title>
    <body>
      <p>
        Types are defined at the top level, within namespaces or within
        other types. Top level type names are prefixed with the namespace
        they are defined in. Nested type names are prefixed with the
        parent type name. Nesting affects accessibility of a type.
      </p>
    </body>
    <subsection id="ty-header">
      <title>Type header</title>
      <body>
        <rule name="type_header">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <non-terminal name="type_parameters"/>
          </optional>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
          </optional>
          <non-terminal name="where_constraints"/>
        </rule>
        <p>
          Type header is similar to .NET. The main difference is
          the optional <tt>type_parameters</tt> list, defined below.
        </p>
      </body>
    </subsection>
    <subsection id="ty-parms">
      <title>Type parameters</title>
      <body>
        <rule name="type_parameters">
          <terminal name="&lt;"/>
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <terminal name="&gt;"/>
        </rule>
        <rule name="where_constraints">
          <repeat>
            <terminal name="where"/>
            <special-terminal name="TYPE_VARIABLE"/>
            <terminal name=":"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
          </repeat> 
        </rule>
        <p>
          When defining polymorphic type one has to specify list
          of type variables in declaration. It can have following form:
        </p>
<code>
class Foo &lt;a, b>
</code>
        <p>
          Optional list of <tt>where</tt> parameters can be used to add 
          constraints to the type variables (type coercion).
        </p>
<code>
where a : Nemerle.Collections.IEnumerable, IComparable
where b : Nemerle.Collections.IDictionary
</code>
      </body>
    </subsection>
    <subsection id="type-alias">
      <title>Type alias</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
          This type declaration creates an alias to another type.
        </p>
      </body>
    </subsection>
    <subsection id="interface-def">
      <title>Interface definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="interface"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="interface_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Nemerle interfaces are similar to .NET.
        </p>
      </body>
    </subsection>
    <subsection id="class-def">
      <title>Class definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="class"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Class definition is similar to .NET.
        </p>
      </body>
    </subsection>
    <subsection id="module-def">
      <title>Module definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="module"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Module is much like a class, but all module members are
          static. There is no need to place <tt>static</tt> attributes
          on module members. It is also not possible to create instances
          of module types.
        </p>
      </body>
    </subsection>
    <subsection id="variant-def">
      <title>Variant definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="variant"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="variant_option"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Variant declaration consist of a type name and a list of
          bar-separated constructors enclosed in brackets.
        </p>
        <rule name="variant_option">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <terminal name="{"/>
            <repeat>
              <non-terminal name="field_definition"/>
            </repeat>
            <terminal name="}"/>
          </optional>
        </rule>
        <p>
          The constructor declaration describe the constructor
          associated to this variant type.  A constructor may take an
          argument. Constructor name must be capitalized.
        </p>
      </body>
    </subsection>
  </section>


  <section id="attributes">
    <title>Attributes</title>
    <body>
      <p>
        The semantics of attributes is the same as in C#.
      </p>
      <rule name="attributes">
        <repeat>
          <non-terminal name="attribute"/>
        </repeat>
      </rule>
      <rule name="attribute">
        <terminal name="new"/>
      </rule>
      <rule name="attribute">
        <terminal name="public"/>
      </rule>
      <rule name="attribute">
        <terminal name="protected"/>
      </rule>
      <rule name="attribute">
        <terminal name="internal"/>
      </rule>
      <rule name="attribute">
        <terminal name="private"/>
      </rule>
      <rule name="attribute">
        <terminal name="abstract"/>
      </rule>
      <rule name="attribute">
        <terminal name="sealed"/>
      </rule>
      <rule name="attribute">
        <terminal name="override"/>
      </rule>
      <rule name="attribute">
        <terminal name="static"/>
      </rule>
    </body>
  </section>


  <section id="type-members">
    <title>Declarations within types</title>
    <body>
      <p>
        Following fields are allowed in <a ref="#class-def">class</a> 
        or <a ref="#module-def">module</a> body:
      </p>
      <rule name="type_member">
        <non-terminal name="field_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="method_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="type_declaration"/>
      </rule>
    </body>
    <subsection id="field-def">
      <title>Field definition</title>
      <body>
        <rule name="field_definition">
          <non-terminal name="attributes"/>
          <optional>
            <terminal name="mutable"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
          Unless the optional <tt>mutable</tt> keyword is used the field 
          can be modified only inside the constructor.
        </p>
      </body>
    </subsection>
    <subsection id="interface-mem-def">
      <title>Interface member</title>
      <body>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <non-terminal name="method_header"/>
          <terminal name=";"/>
        </rule>
        <p>
          Keyword <tt>new</tt> is necessary when declared method hides
          inherited one from another interface.
        </p>
      </body>
    </subsection>
    <subsection id="method-def">
      <title>Method definition</title>
      <body>
        <rule name="method_definition">
          <non-terminal name="attributes"/>
          <non-terminal name="method_header"/>
          <non-terminal name="method_body"/>
        </rule>
        <p>
          This is definition of method within class or module.
          Program entry point is method static <tt>Main</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="method-head">
      <title>Method header</title>
      <body>
        <rule name="method_type_parameters">
          <terminal name="&lt;"/>
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <terminal name="&gt;"/>
        </rule>
        <p>
          Declaration of polymorphic method needs its type
          variables listed after the identifier.
        </p>
        <rule name="method_header">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
          <non-terminal name="method_implements"/>
        </rule>
        <p>
          This is declaration of method. Unlike C# type is specified after
          parameters list.
        </p>
        <rule name="method_header">
          <terminal name="this"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
        </rule>
        <p>
          Special method named <tt>this</tt> specifies constructor.
          This declaration cannot contain method type and method has
          to have type <tt>void</tt>.
        </p>
        <rule name="method_implements">
          <optional>
            <terminal name="implements"/>
            <non-terminal name="qualified_identifier"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="qualified_identifier"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-parms">
      <title>Method parameters</title>
      <body>
        <rule name="method_parameter">
          <non-terminal name="identifier_or_dummy"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
        </rule>
        <p>
          Method parameter is a pair consisting of <tt>identifier</tt>
          or <tt>_</tt> and it's type specification. Type declaration can be
          omitted in local functions definitions.
        </p>
        <rule name="method_parameters">
          <optional>
            <non-terminal name="method_parameters"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="method_parameter"/>
            </repeat>
          </optional>
        </rule>
        <p>
          Method parameters are comma-separated list of parameter specification.
        </p>
      </body>
    </subsection>
    <subsection id="method-body">
      <title>Method body</title>
      <body>
        <rule name="method_body">
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <p>
          Method body can be linked to external function, example:
        </p>
<code>
static ps (s : string) : void = extern "System.Console.Write";
</code>
        <p>
          This feature is used to give meaning to infix operators. It
          isn't currently fully supported. It should not be considered
          rock-stable feature.
        </p>
        <rule name="method_body">
          <terminal name=";"/>
        </rule>
        <p>
          Empty method body (a <tt>;</tt>) is a method declaration.
        </p>
        <rule name="method_body">
          <non-terminal name="block"/>
        </rule>
        <p>
          This is classical method definition.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-expressions">
    <title>Type expressions</title>
    <body>
      <p>
        Type expression relate to <a ref="#type-declarations">type
        declarations</a> much like function calls relate to function
        and value definitions. Type declarations define ways the types
        can be constructed and type expressions define actual types.
      </p>
      <p>
        Types are both static and dynamic characterization of values.
        Static type of expression depends on its building blocks and
        is defined in paragraph describing given expression. Dynamic
        (runtime) type is bound to the value at the moment it is created,
        and remains there until the value is garbage collected.
      </p>
      <p>
        The type system is modeled after .NET Generics design, except
        for tuple and function types, which are new, but can be easily
        simulated using generics.
      </p>
    </body>
    <subsection id="type-app">
      <title>Type constructor application</title>
      <body>
        <rule name="primary_type">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <terminal name="&lt;"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
            <terminal name="&gt;"/>
          </optional>
        </rule>
        <p>
          Type constructor (defined with <a ref="#type-definitions">type
          declaration</a>) can be applied to zero or more arguments
          forming type expression. Number of type arguments in type
          application must match number of <a ref="#ty-parms">type
          arguments</a> in definition.  Moreover actual type arguments
          must solve <a ref="#ty-parms"><tt>where</tt> constraints</a>
          imposed on formal type arguments.
        </p>
      </body>
    </subsection>
    <subsection id="tyvar">
      <title>Type variable reference</title>
      <body>
        <rule name="primary_type">
          <special-terminal name="TYPE_VARIABLE"/>
        </rule>
        <p>
          Refer to type substituted to given type variable. The type
          variable has to be defined (bound, quantified) before it is used.
          Type variable can be defined in <a ref="#ty-parms">type
          arguments</a> or <a ref="#method-head">method header</a>
          (of global or local function).
        </p>
      </body>
    </subsection>
    <subsection id="group-ty">
      <title>Grouping types</title>
      <body>
        <rule name="primary_type">
          <terminal name="("/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          This construct has no semantic meaning -- it exists only to
          enforce particular syntax decomposition.
        </p>
      </body>
    </subsection>
    <subsection id="void-ty">
      <title>Void type</title>
      <body>
        <rule name="primary_type">
          <terminal name="void"/>
        </rule>
        <p>
          This is mostly an alias for <tt>System.Void</tt> -- a type with
          exactly one inhibiting value it is however first class value
          -- can be passed as function parameter as well as returned
          from functions.
        </p>
        <p>
          The name comes from <tt>System.Void</tt>, but should be in
          fact <tt>unit</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="ref-out-ty">
      <title>Ref and Out types</title>
      <body>
        <rule name="primary_type">
          <terminal name="ref"/>
          <non-terminal name="primary_type"/>
        </rule>
        <rule name="primary_type">
          <terminal name="out"/>
          <non-terminal name="primary_type"/>
        </rule>
        <p>
          These are for parameters passed by reference. This is not
          implemented yet, but will have semantics similar as in C#.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ty">
      <title>Tuple type</title>
      <body>
        <rule name="type">
          <non-terminal name="primary_type"/>
          <repeat>
            <terminal name="*"/>
            <non-terminal name="primary_type"/>
          </repeat>
        </rule>
        <p>
          Construct product (tuple) type. This operator is not associative, which
          means that each two of following types are different:
        </p>
<code>
int * int * int
(int * int) * int
int * (int * int)
</code>
      </body>
    </subsection>
    <subsection id="function-ty">
      <title>Function type</title>
      <body>
        <rule name="type">
          <non-terminal name="type"/>
          <terminal name="->"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          Construct function type with specified argument and return
          types respectively. The <tt>-></tt> operator is right
          associative, which means that the following type are equivalent:
        </p>
<code>
int -> int -> int
int -> (int -> int)
</code>
        <p>
          Multi-argument function types are written using tuple notation,
          for example after local declaration:
        </p>
<code>
def some_function (a : int, b : string) : float { ... }
</code>
        <p>
          the expression <tt>some_function</tt> has type <tt>int *
          string -> float</tt>.
        </p>
      </body>
    </subsection>
  </section>

  <section id="literal-exprs">
    <title>Literal expressions</title>
    <body>
      <p>
        These are used in expressions and patterns.
      </p>
    </body>
    <subsection id="boolean-lit">
      <title>Boolean</title>
      <body>
        <rule name="literal">
          <terminal name="true"/>
        </rule>
        <rule name="literal">
          <terminal name="false"/>
        </rule>
        <p>
          These literals have type <tt>bool</tt> and represent respectively
          true (false) boolean value 
        </p>
      </body>
    </subsection>
    <subsection id="null-lit">
      <title>Null</title>
      <body>
        <rule name="literal">
          <terminal name="null"/>
        </rule>
        <p>
          Represents null reference, one that does not refer to any
          object.  It posses types of all reference types -- can be
          used in any context reference type is required. It does not
          however posses the <tt>void</tt> type nor any value type
          (like <tt>System.Int32</tt> or <tt>System.Single</tt>).
        </p>
      </body>
    </subsection>
    <subsection id="void-lit">
      <title>Void</title>
      <body>
        <rule name="literal">
          <terminal name="("/>
          <terminal name=")"/>
        </rule>
        <p>
          Indicates returning no value. It is the only possible value of type <tt>void</tt>.
          See also <a ref="void-ty">void type</a>.
        </p>
      </body>
    </subsection>
    <subsection id="string-lit">
      <title>String</title>
      <body>
        <rule name="literal">
          <special-terminal name="STRING_LITERAL"/>
        </rule>
        <p>
          Represents <tt>string</tt> constant. Nemerle supports two forms of string:
        </p>
        <ul>
         <li> regular string literals </li>
         <li> verbatim string literals </li>
        </ul>
        
        <p>
          A regular string literal consists of zero or more characters enclosed in double
          quotes and may include both simple escape sequences (such as \n for the newline
          character) and hexadecimal and Unicode escape sequences (See 
          <a ref="character">character literals</a> for details).
        </p>
        <p>
          A verbatim string literal consists of an @ character followed by a double-quote 
          character, zero or more characters, and a closing double-quote character. 
          In a verbatim string literal, the characters between the double-quotes are recognized
          verbatim, the only exception is a sequence <tt>""</tt> (used to indicate <tt>'"'</tt>
          character) (Note that simple escape sequences and hexadecimal and Unicode escape sequences
          are not recognized in verbatim string literals). A verbatim string literal may span
          multiple lines. 
        </p>
        <p>
          Examples:
        </p>
<code>
def s1 = "Nemerle string !";            // Nemerle string !
def s2 = @"Nemerle string !";           // Nemerle string !
def s3 = "Nemerle\tstring !";           // Nemerle    string !
def s4 = @"Nemerle\tstring !";          // Nemerle\tstring !
def s5 = "I heard \"zonk !\"";          // I heard "zonk !"
def s6 = @"I heard ""zonk !""";         // I heard "zonk !"
def s7 = "\\\\trunk\\ncc\\ncc.exe";     // \\trunk\ncc\ncc.exe
def s8 = @"\\trunk\ncc\ncc.exe";        // \\trunk\ncc\ncc.exe
def s9 = "\"Nemerle\"\nstring\n!";      // "Nemerle"
                                        // string
                                        // !
def s10 = @"""Nemerle""                 // same as s9
rocks
!";
</code>
        <p>
          String s10 is a verbatim string literal that spans 3 lines.
        </p>
      </body>
    </subsection>
    <subsection id="number">
      <title>Number</title>
      <body>
        <rule name="literal">
          <special-terminal name="NUMBER_LITERAL"/>
        </rule>
        <p>
          Represents one of numeric types. See <a ref="literals"> literals </a> for details
          of representing particular numerical types.  
        </p>
      </body>
    </subsection>
    <subsection id="character">
      <title>Character</title>
      <body>
        <rule name="literal">
          <special-terminal name="CHARACTER_LITERAL"/>
        </rule>
        <p>
          Character literal consist of one character enclosed in single-quotes (' ')
          or escape character of form '\X' where X can be one of following:
          [FIXME : characters with (N) are not implemented yet (will they ?)]
        </p>
        <ul>
          <li> \, ', " - this allows representation of (respectively) backslash, single-quote
            double-quote </li> 
          <li> 0X - where X is an octal ASCII code (up to three digits) of character we want to represent (N)</li>
          <li> xX - where X is an hexadecimal ASCII code (exactly two digits) of character we want to represent (N) </li>
          <li> uX - where X is an hexadecimal UNICODE code (exactly four digits) of character we want to represent (N)</li>
          <li> a - matches a bell (alarm) (N)</li>
          <li> b - matches a backspace \u0008 </li>
          <li> r - matches carriage return \u000D </li> 
          <li> v - matches vertical tab \u000B (N)</li>
          <li> f - matches form feed \u000C (N)</li>
          <li> n - matches a new line \u000A </li>
          <li> e - matches an escape \u001B (N)</li>
          <li> cX - matches an ASCII control character; for example \cC represents control-C (N) </li>
        </ul>
        <p>
          It has type <tt>char</tt>.
        </p>
      </body>
    </subsection>
  </section>


  <section id="prim-expressions">
    <title>Primary expressions</title>
    <body>
      <p>
        Primary expressions is grammar category referring to expressions
        that have closed structure and are otherwise simple. Primary
        expressions and plain expressions do not differ at the semantic
        level.
      </p>
    </body>
    <subsection id="literal-ref">
      <title>Literal expression</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="literal"/>
        </rule>
        <p>
          The value and type of expression being literal is the value
          and type of respective literal.
        </p>
      </body>
    </subsection>
    <subsection id="variable-ref">
      <title>Variable reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="qualified_identifier"/>
        </rule>
        <p>
          This expression result is a variable itself (not its value).  [[FIXME: hem?!]]
          Type of this expression is <tt>ref 'a</tt> where <tt>'a</tt> is
          a type of variable being referenced.
        </p>
      </body>
    </subsection>
    <subsection id="this-ref">
      <title>this pointer reference</title>
      <body>
        <rule name="primary_expr">
          <terminal name="this"/>
        </rule>
        <p>
          This expression can only be used within non-static methods and indicates
          a reference to the current instance of the class (which posses this method).
        </p>
        <p>
          Expression like <tt>this.foo</tt> can be shortened to
          <tt>foo</tt> unless it would generate an identifier ambiguity
          with some variable being in this lexical scope.
        </p>
      </body>
    </subsection>
    <subsection id="grouping">
      <title>Grouping expression</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
        </rule>
        <p>
          Grouping expression allow to enforce particular syntax
          decomposition of expression.
        </p>
      </body>
    </subsection>
    <subsection id="type-cast">
      <title>Type cast</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          This expression allows dynamic type coercion. It is
          done during runtime and if it cannot be realized then
          <tt>System.InvalidCastException</tt> is thrown. If it
          succeeds the type of this expression is equal to the type of
          <non-terminal name="type"/>.
        </p>
      </body>
    </subsection>
    <subsection id="type-enf">
      <title>Type enforcement</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          This expression allows static type enforcement. It is checked
          during compile-time and error is reported if <non-terminal
          name="expr"/> type is not a subtype of <non-terminal
          name="type"/>.  It allows only type widening. If it succeeds the
          type of this expression is equal to the type of <non-terminal
          name="type"/>.
        </p>
      </body>
    </subsection>
    <subsection id="member-ref">
      <title>Member reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="primary_expr"/>
          <terminal name="."/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          This expression allows referring to the field or method that
          object represented by <non-terminal name="primary_expr"/>
          contains.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ctor">
      <title>Tuple constructor</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <repeat-plus>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat-plus>
          <terminal name=")"/>
        </rule>
        <p>
          This expression allows creating a tuple of <non-terminal
          name="expr"/> whose types may differ.  The type of that tuple
          is <tt>type_1 * ... * type_n</tt> where type_1 and the following
          are types of corresponding expressions.
        </p>
      </body>
    </subsection>
    <subsection id="indexer-ref">
      <title>Indexer reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="expr"/>
          <terminal name="["/>
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <p>
          This expression allows to refer to indexed (even by multiple
          indexes) fields of objects represented by leftmost <non-terminal
          name="expr"/> where second (and further) <non-terminal
          name="expr"/> are indexes values of field we want to refer to.
          <non-terminal name="expr"/> must refer to indexing object.
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="core-expressions">
    <title>Core Expressions</title>
    <body>
       <p>
       </p>
    </body>
    <subsection id="prim-expr-ref">
      <title>Primary expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
        </rule>
        <p>
          The value and type are the same as <non-terminal
          name="primary_expr"/> we are referring to.
        </p>
      </body>
    </subsection>
    <subsection id="call">
      <title>Function call</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="("/>
          <optional>
            <non-terminal name="parameter"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="parameter"/>
            </repeat>
          </optional>
          <terminal name=")"/>
        </rule>
        <p>
          Call a function with given parameters. The type of the function call
          expression is the same as the type of the function return value;
          that is, if function's type is <tt>'a -> 'b</tt>, then the type of
          the function call expression is <tt>'b</tt>. The value of the whole
          expression is the return value of the function.
        </p>
      </body>
    </subsection>
    <subsection id="assign">
      <title>Assignment</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Assign a value to a variable. Left side of the assignment expression
          must evaluate to a mutable variable. The type of the assignment is
          always <tt>void</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="match-expr">
      <title>Match expression</title>
      <body>
        <rule name="expr">
          <terminal name="match"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          <tt>expr</tt> is matched sequentially to the patterns in given
          match cases. If one of the patterns is consistent with the value of
          <tt>expr</tt> then the corresponding computation branch of the
          match case is evaluated. Patterns in all the match cases must be of
          the same type. Expressions being computation branches in all the
          match cases must be of the same type, as well. The type of the match
          expression is the same as the type of the computation branch in
          all the match cases.
        </p>
      </body>
    </subsection>
    <subsection id="throw-expr">
      <title>Throw expression</title>
      <body>
        <rule name="expr">
          <terminal name="throw"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Throws given exception. The expression given must be of type
          <tt>System.Exception</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="try-catch">
      <title>Try..catch expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="catch"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="try_catch_handler"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="try_catch_handler"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          If the evaluation of <tt>expr</tt> does not throw any exception,
          then the result is that of the evaluation of <tt>expr</tt>.
          Otherwise, the runtime type of the exception which was
          thrown is compared against each type description in handlers.
          First matching handler is executed and its value returned. If
          none of the handlers matches the exception is propagated.
          The type of the whole expression is the same as type of
          guarded expression. The value is the value of expression or
          lunched handler.  Consult <tt>.NET</tt> specification if you
          want to know more about exceptions.
        </p>
      </body>
    </subsection>
    <subsection id="try-finally">
      <title>Try..finally expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="finally"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Evaluates the first expression and -- regardless of whether the
          evaluation has finished correctly or some exception has been thrown
          during the evaluation -- the second expression is evaluated. The
          value (and thus the type) of the whole expression is the value of
          the first expression.
        </p>
      </body>
    </subsection>
    <subsection id="unary-op">
      <title>Unary operator application</title>
      <body>
        <rule name="expr">
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="binary-op">
      <title>Binary operator application</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="block-ref">
      <title>Block expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="sequence"/>
        </rule>
        <p>
          The value (and thus the type) of the whole expression is the value of
          the last expression in the sequence.
        </p>
      </body>
    </subsection>
    <subsection id="array-ctor">
      <title>Array constructor</title>
      <body>
        <rule name="expr">
          <terminal name="array"/>
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=","/>
            </repeat>
            <non-terminal name="expr"/>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          Create an array consisting of given elements. All elements must be
          of the same type. If the elements are of the type <tt>'a</tt> then
          the whole expression is of the type <tt>array ('a)</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="value-def">
      <title>Value definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="pattern"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Defines the binding between the variables in the pattern and the
          value of the expression <tt>expr</tt> which will be known to all
          subsequent expressions in the current block.
        </p>
      </body>
    </subsection>
    <subsection id="local-fun-def">
      <title>Local function definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="method_header"/>
          <non-terminal name="block"/>
          <repeat>
            <terminal name="and"/>
            <non-terminal name="method_header"/>
            <non-terminal name="block"/>
          </repeat>
        </rule>
        <p>
          Defines the functions which will be known to all subsequent
          expressions in the current block. Names of all defined functions are
          put into the symbol space before their bodies are parsed.
        </p>
      </body>
    </subsection>
    <subsection id="mutable-def">
      <title>Mutable value definition</title>
      <body>
        <rule name="expr">
          <terminal name="mutable"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Defines new variable, value of which can be changed at any time
          using the assignment expression.
        </p>
      </body>
    </subsection>
  </section>
  

  <section id="macro-expressions">
    <title>Secondary Expressions</title>
    <body>
      <p>
        This section describes expressions that are in fact just syntactic sugar
        over Core Expressions. We just present translation of Secondary Expressions
        into Core Expressions.
      </p>
    </body>
    <subsection id="if-expr">
      <title>Conditional expression</title>
      <body>
        <rule name="expr">
          <terminal name="if"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
          <terminal name="else"/>
          <non-terminal name="expr"/>
        </rule>
          <p>   
            Standard branch, which executes and returns value of first expression 
            if condition evaluates to true or second elsewhere.
          </p>
          <p>
            Internally it is translated into
          </p>
<code>
match (cond) {
  | true => expr1
  | false => expr2
}
</code>             
      </body>
    </subsection>
    <subsection id="while-expr">
      <title>While loop</title>
      <body>
        <rule name="expr">
          <terminal name="while"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Loop, executing body expression as long as condition is true.
          Its value is always checked before execution of body and if it
          evaluates to false, then loop ends. Body must be of type 
          <tt>void</tt>.
        </p>
        <p>
          While loop is translated internally into following code
        </p>
<code>
def loop () {
  if (cond) 
    { body; loop () }
  else
    ()
};
loop ()
</code>
      </body>
    </subsection>
    <subsection id="when-expr">
      <title>When expression</title>
      <body>
        <rule name="expr">
          <terminal name="when"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Version of <tt>if</tt> condition, but having only one branch --
          execution of body only when condition is satisfied. If its value
          if <tt>false</tt>, then nothing is done (i. e. <tt>()</tt> is 
          returned).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) body else ()
</code>
      </body>
    </subsection>
    <subsection id="unless-expr">
      <title>Unless expression</title>
      <body>
        <rule name="expr">
          <terminal name="unless"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Opposite version of <tt>when</tt>. It executes and returns value
          of body only if conditions if not satisfied (i. e. evaluates to 
          <tt>false</tt>).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) () else body
</code>
      </body>
    </subsection>
    <subsection id="lambda-expr">
      <title>Lambda expression</title>
      <body>
        <rule name="expr">
          <terminal name="fun"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
          Lambda expressions can be thought as of anonymous local functions.
          This construct defines such a function and returns it as a
          functional value. This value can be used just like the name of 
          regular local function.
        </p>
        <p>
          Example:
        </p>
<code>
List.Iter (fun (x) { printf ("%d\n", x) }, intList)
</code>
        <p>
          is equivalent to
        </p>
<code>
def tmpfunc (x) { printf ("%d\n", x) };
List.Iter (tmpfunc, intList)
</code>
        <p>
          Lambda expression is indeed translated internally to
        </p>
        <rule name="expr">
          <terminal name="def"/>
          <special-terminal name="temporary_name"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
          where <tt>temporary_name</tt> is automatically created by compiler.
        </p>
      </body>
    </subsection>
    <subsection id="list-expr">
      <title>List constructor</title>
      <body>
        <rule name="expr">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=","/>
            </repeat>
            <non-terminal name="expr"/>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          <tt>[1, 2, 3]</tt> is translated to <tt>Cons (1, Cons (2, Cons
          (3, Nil ())))</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="plusplus_op">
      <title>Increment operator</title>
      <body>
        <rule name="expr">
          <terminal name="++"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Prefix operator <tt>++</tt> is used to increment integer value of assignable
          expression.
          It is translated to something similar to <tt>e &lt;- e + 1</tt>, except that 
          <tt>e</tt> is evaluated only once, so <tt>++a[x.Next()]</tt> can be used safely.
          Entire expression has type <tt>void</tt> (incremented value is not returned).
        </p>
      </body>
    </subsection>
    <subsection id="minusminus_op">
      <title>Decrement operator</title>
      <body>
        <rule name="expr">
          <terminal name="--"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Prefix operator <tt>--</tt> is used to increment integer value of assignable
          expression.
          It is translated to something similar to <tt>e &lt;- e - 1</tt>, except that 
          <tt>e</tt> is evaluated only once, so <tt>--a[x.Next()]</tt> can be used safely.
          Entire expression has type <tt>void</tt> (decremented value is not returned).
        </p>
      </body>
    </subsection>
    <subsection id="swap_op">
      <title>Swap operator</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <terminal name="&lt;->"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Infix operator <tt>&lt;-></tt> is used to swap values of two assignable
          expressions. You can think about it as being translated to 
        </p>
<code>
def temp = e1;
e2 &lt;- e1;
e1 &lt;- e2
</code>
        <p>
          except that expressions are evaluated only once (we have special
          macro to assure this), so <tt>a[x.Next()] &lt;-> a[x.Next()]</tt> can
          be used safely.
        </p>
      </body>
    </subsection>
  </section>

  <section id="expression-helpers">
    <title>Expression helpers</title>
    <body>
      <p>
        This section describes some constructs used in Expressions
        section.
      </p>
    </body>
    <subsection id="sequence">
      <title>Sequence</title>
      <body>
        <rule name="sequence">
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=";"/>
            <non-terminal name="expr"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
        </rule>
        <p>
          Expressions in the sequence are evaluated sequentially, and the
          value (and thus the type) of the sequence is the value of the last
          expression in the sequence.
        </p>
        <p>
          Value of expression (except for the last one) are ignored,
          and thus if the type of some expression is not <tt>void</tt>
          -- a warning is generated.
        </p>
      </body>
    </subsection>
    <subsection id="block">
      <title>Block</title>
      <body>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="sequence"/>
          <terminal name="}"/>
        </rule>
        <p>
          This is just a standard execution of sequence of expressions. Value (and type) of
          this block is the same as last expression in a sequence.
        </p>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          This syntax is a shortcut for matching parameters of defined function
          with given list of patterns. It is equivalent to making a tuple from
          parameters of function and creating <a ref="#match-expr">match expression</a>.
        </p>
<code>
def f (p1, p2, p3) { 
  | (1, 3, "a") => 1
  | _ => 2
}
</code>
        <p>
          translates to
        </p> 
<code>
def f (p1, p2, p3) { 
  match ((p1, p2, p3)) {
    | (1, 3, "a") => 1
    | _ => 2
  }
}
</code>
        <p>
          It is also to note, that when function has only one parameter, matching goes just
          on this parameter itself (there is no one element tuples).
        </p>
      </body>
    </subsection>
    <subsection id="try-catch-handler">
      <title>Try..catch handler</title>
      <body>
        <rule name="try_catch_handler">
          <non-terminal name="identifier_or_dummy"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name="=&gt;"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="fun-parm">
      <title>Function parameter</title>
      <body>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          <tt>ref</tt> is used to denote parameter passes by reference. This is
          not implemented yet, but will have semantics similar as in C#.
        </p>
      </body>
    </subsection>
    <subsection id="match-case">
      <title>Match case</title>
      <body>
        <rule name="guarded_pattern">
          <non-terminal name="pattern"/>
          <optional>
            <terminal name="when"/>
            <non-terminal name="expr"/>
          </optional>
        </rule>
        <p>
          Guarded pattern requires expression <tt>expr</tt> to be of type
          <tt>bool</tt>. Given some expression <tt>e</tt> this expression
          satisfies the guarded pattern only if it is pattern-matched with
          <tt>pattern</tt> and expression <tt>expr</tt> is evaluated to
          <tt>true</tt>.
        </p>
        <rule name="match_case">
          <non-terminal name="guarded_pattern"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="guarded_pattern"/>
          </repeat>
          <terminal name="=&gt;"/>
          <non-terminal name="sequence"/>
        </rule>
        <p>
          Given some expression <tt>e</tt> this expression satisfies
          this match case if and only if it satisfies one of the guarded
          patterns in this match case.
        </p>
      </body>
    </subsection>
  </section>


  <section id="patterns">
    <title>Patterns</title>
    <body>
      <p>
        Patterns are form of accessing data structures, especially trees.
        Patterns can <i>match</i> values. Definition of the term <i>to
        match</i> is given with each pattern construct. However the
        main idea behind patterns is that they match values that look
        like them.
      </p>
      <p>
        Pattern are used in <a ref="#match-expr">match expression</a>
        and <a ref="#value-def">value definitions</a>.
      </p>
    </body>
    <subsection id="cons-pat">
      <title>Constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <non-terminal name="pattern"/>
          </optional>
        </rule>
        <p>
          The identifier should refer to name of variant option. This
          pattern matches value iff it is specified variant option,
          and sub-pattern matches variant option payload.
        </p>
      </body>
    </subsection>
    <subsection id="dummy-pat">
      <title>Throw-away pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="_"/>
        </rule>
        <p>
          This pattern matches any value.
        </p>
      </body>
    </subsection>
    <subsection id="record-pat">
      <title>Record pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="{"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=";"/>
            <special-terminal name="IDENTIFIER"/>
            <terminal name="="/>
            <non-terminal name="pattern"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
          <terminal name="}"/>
        </rule>
        <p>
          This pattern matches value of class, that has all specified
          fields (this is checked statically), and value of each field
          matches respective pattern.
        </p>
      </body>
    </subsection>
    <subsection id="as-pat">
      <title>As binding</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <terminal name=")"/>
          <terminal name="as"/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          This pattern matches the same value as enclosed pattern
          does. However in addition value matched by enclosed pattern
          is bound to specified variable, which can be used in <tt>when</tt>
          guard or <tt>match</tt> body.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-pat">
      <title>Tuple pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="pattern"/>
          </repeat>
          <terminal name=")"/>
        </rule>
        <p>
          This pattern matches a tuple with specified contents (each
          tuple member is matched be respective pattern).
        </p>
        <p>
          In addition, when tuple pattern is seen, where record pattern
          would be otherwise expected -- tuple pattern is transformed
          to record pattern by adding field identifiers in order they
          appear in definition of given class. Tuple pattern transformed
          to record pattern cannot match fields inherited from the
          base class.
        </p>
      </body>
    </subsection>
    <subsection id="list-pat">
      <title>List constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="pattern"/>
          <terminal name="::"/>
          <non-terminal name="pattern"/>
        </rule>
        <p>
          The following two lines are equivalent:
        </p>
<code>
<meta>pattern1</meta> :: <meta>pattern2</meta>
Cons (<meta>pattern1</meta>, <meta>pattern2</meta>)
</code>
      </body>
    </subsection>
    <subsection id="list-lit-pat">
      <title>List literal pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="pattern"/>
              <terminal name=","/>
            </repeat>
            <non-terminal name="pattern"/>
            <optional>
              <terminal name=","/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          The following are equivalent:
        </p>
<code>
[ <meta>pattern1</meta> , <meta>pattern2</meta> , ... , <meta>patternN</meta> ]
Cons (<meta>pattern1</meta>, Cons (<meta>pattern2</meta>, ... Cons (<meta>pattern2</meta>, Nil) ... ))
</code>
      </body>
    </subsection>
    <subsection id="lit-pattern">
      <title>Literal pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="literal"/>
        </rule>
        <p>
          This pattern matches specified constant value.
        </p>
      </body>
    </subsection>
  </section>


  <section id="macros">
    <title>Macros</title>
    <body>
      <p>
        Please refer to <link>macros.html</link> for now.
      </p>
    </body>
  </section>


    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
