<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle Language Reference</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document presents in semi-formal way syntax and semantics
        of the Nemerle language. It is not meant to be a tutorial.
      </p>
      <p>
        We often refer to <tt>.NET</tt> terminology [FIXME: reference it].
      </p>
    </body>
  </section>


  <section id="lexical">
    <title>Lexical Conventions</title>
    <body>
      <p>
        Programs are written using the Unicode character set.  Every
        Nemerle source file is reduced to a sequence of lexical units
        (tokens).
      </p>
    </body>
    <subsection id="tokens">
      <title>Tokens</title>
      <body>
        <p>
	  There are five classes of lexical tokens: 
        </p>
        <ul>
          <li>identifiers</li>
          <li>type variables</li>
          <li>keywords</li>
          <li>literals</li>
          <li>blanks</li>
        </ul>
<code>
(* A comment. *)
// Also a comment

foo               // identifier
foo_bar foo' foo3 // other identifiers
'a                // type variable 
42                // integer literal
0x2a              // hexadecimal integer literal
0o52              // octal integer literal
0b101010          // binary integer literal
'a'               // character literal
'\n'              // also a character literal
"foo\nbar"        // string literal
@"x\n"            // same as "x\\n"
@if               // keyword used as identifier
</code>
      </body>
    </subsection>
    <subsection id="blanks">
      <title>Blanks</title>
      <body>
        <p>
	  Spaces, vertical, and horizontal tabulation characters,
	  new-page, and new-line characters, and comments (called blanks
	  altogether) are discarded, but can separate other lexical tokens.
	</p>
        <p>
	  A traditional comment begin with <tt>(*</tt>, and end with
	  <tt>*)</tt>.  A end-of-line comment begin with <tt>//</tt>,
	  and end with line terminator (ASCII LF character).
	</p>
      </body>
    </subsection>
    <subsection id="type-variables">
      <title>Type variables</title>
      <body>
        <p>
          Type variables start with apostrophe (<tt>'</tt>) and consists of
          characters allowed in identifiers, but cannot contain apostrophe.
	</p>
      </body>
    </subsection>
    <subsection id="identifiers">
      <title>Identifiers</title>
      <body>
        <p>
	  Ordinary identifiers consist of letters, digits, underscores
	  and apostrophe, but cannot begin with a digit nor an apostrophe.
	  Identifiers may be quoted with the <tt>@</tt> character, which
	  is stripped. It removes any lexical and syntactic meaning from
	  the following string of characters until blank, thus enabling
	  programmer to use keywords as identifiers.
	</p>
	<p>
	  Symbolic identifiers consist of following characters: 
          <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>@</tt>,
          <tt>^</tt>, <tt>|</tt>, <tt>&amp;</tt>, <tt>+</tt>, <tt>-</tt>,
          <tt>*</tt>, <tt>/</tt>, <tt>$</tt>, <tt>%</tt>, <tt>!</tt>,
          <tt>?</tt>, <tt>~</tt>, <tt>.</tt>, <tt>:</tt>, <tt>#</tt>.
          Symbolic identifiers may be used, wherever ordinary
	  identifiers may, but have additional property of being used
	  as infix operators.
	</p>
      </body>
    </subsection>
    <subsection id="keywords">
      <title>Keywords</title>
      <body>
        <p>
	  Following identifiers are used as keywords, and may not be
	  used in any other context unquoted:
          <tt>_</tt>, <tt>abstract</tt>, <tt>and</tt>, <tt>array</tt>,
          <tt>as</tt>, <tt>base</tt>, <tt>class</tt>, <tt>const</tt>,
          <tt>def</tt>, <tt>else</tt>, <tt>ensure</tt>, <tt>enum</tt>,
          <tt>extends</tt>, <tt>extern</tt>, <tt>finally</tt>,
          <tt>fun</tt>, <tt>if</tt>, <tt>implements</tt>,
          <tt>in</tt>, <tt>interface</tt>, <tt>internal</tt>,
          <tt>let</tt>, <tt>macro</tt>, <tt>match</tt>,
          <tt>module</tt>, <tt>mutable</tt>, <tt>namespace</tt>,
          <tt>new</tt>, <tt>null</tt>, <tt>open</tt>, <tt>out</tt>,
          <tt>private</tt>, <tt>protected</tt>, <tt>public</tt>,
          <tt>raise</tt>, <tt>ref</tt>, <tt>require</tt>, <tt>sealed</tt>,
          <tt>static</tt>, <tt>struct</tt>, <tt>then</tt>, <tt>this</tt>,
          <tt>try</tt>, <tt>tymatch</tt>, <tt>type</tt>, <tt>variant</tt>,
          <tt>void</tt>, <tt>volatile</tt>, <tt>where</tt>, <tt>with</tt>.
        </p>
        <p>
          Following infix identifiers are keywords:
          <tt>=</tt>, <tt>$</tt>, <tt>?</tt>, <tt>|</tt>, <tt>&lt;-</tt>,
          <tt>-&gt;</tt>, <tt>=&gt;</tt>, <tt>&lt;[</tt>, <tt>]></tt>,
          <tt>&amp;&amp;</tt>, <tt>||</tt>.
	</p>
      </body>
    </subsection>
    <subsection id="literals">
      <title>Literals</title>
      <body>
        <p>
          There are few kinds of literals:
	</p>
        <ul>
          <li>
            String literals, enclosed in <tt>""</tt>. Compiler processes
            backslash escapes much like in C#.
          </li>
          <li>
            Raw string literals, written like ordinary string literals,
            but prefixed with <tt>@</tt>. Escapes are not processed.
          </li>
          <li>
            Character literals, enclosed in <tt>'</tt>. Escapes are
            processed.
          </li>
          <li>
            Integer literals, possibly prefixed with <tt>0x</tt>,
            <tt>0o</tt> or <tt>0b</tt> to donate hexadecimal, octal or
            binary encoding respectively.
          </li>
        </ul>
      </body>
    </subsection>
  </section>


  <section id="compilation-units">
    <title>Compilation units</title>
    <body>
      <rule name="compilation_unit">
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
      </rule>
      <p>
        Nemerle program consists of one or more compilation
        units. Compilation units are files with <tt>.n</tt> suffix.
        Compilation unit consists of namespace-related declarations and
        types within them.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="open"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Add specified namespace (which can be type or namespace name,
        unlike in C#) to symbol search path.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <special-terminal name="IDENTIFIER"/>
        <terminal name="="/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Define alias for namespace. After <tt>namespace Foo =
         Bar.Baz;</tt> any reference to <tt>Foo.bar</tt> will be expanded
        to <tt>Bar.Baz.bar</tt>.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name="{"/>
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
        <terminal name="}"/>
      </rule>
      <p>
        Put declarations within specified namespace. Namespaces can
        be nested.
      </p>
      <rule name="toplevel_declaration">
        <non-terminal name="type_declaration"/>
      </rule>
      <p>
        Define new type.
      </p>
    </body>
  </section>


  <section id="misc">
    <title>Stuff that doesn't fit anywhere else</title>
    <body>
      <p>
        This section lists grammar rules common to most of other sections.
      </p>
    </body>
    <subsection id="id-or-dummy">
      <title>Identifier or dummy</title>
      <body>
        <rule name="identifier_or_dummy">
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <rule name="identifier_or_dummy">
          <terminal name="_"/>
        </rule>
        <p>
          In several places it is possible to use keyword <tt>_</tt> to donate intent
          to ignore parameter. Semantics of <tt>_</tt> in such places is to generate
          new temporary name.
        </p>
      </body>
    </subsection>
    <subsection id="qid">
      <title>Qualified identifier</title>
      <body>
        <rule name="qualified_identifier">
          <special-terminal name="IDENTIFIER"/>
          <repeat>
            <terminal name="."/>
            <special-terminal name="IDENTIFIER"/>
          </repeat>
        </rule>
        <p>
          Identifiers can be often qualified with namespaces.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-declarations">
    <title>Type declarations</title>
    <body>
      <p>
        Types are defined at the top level, within namespaces or within
        other types. Defining type within namespace affects its name --
        it's prefixed with namespace name. Defining type with other type
        additionally affects accessibility of type. The rules here are
        the same as in .NET.
      </p>
    </body>
    <subsection id="ty-header">
      <title>Type header</title>
      <body>
        <rule name="type_header">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <non-terminal name="type_parameters"/>
          </optional>
          <optional>
            <terminal name="extends"/>
            <non-terminal name="type"/>
          </optional>
          <optional>
            <terminal name="implements"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
          </optional>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="ty-parms">
      <title>Type parameters</title>
      <body>
        <rule name="type_parameters">
          <terminal name="("/>
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <terminal name=")"/>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
        </rule>
        <rule name="where_constraints">
          <terminal name="where"/>
          <special-terminal name="TYPE_VARIABLE"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
            <terminal name=":&gt;"/>
            <non-terminal name="type"/>
          </repeat>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="type-alias">
      <title>Type alias</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="extern-type">
      <title>External type declaration</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="interface-def">
      <title>Interface definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="interface"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="interface_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="class-def">
      <title>Class definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="class"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="module-def">
      <title>Module definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="module"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Module is much like class, but all module members are
          static. There is no need to place <tt>static</tt> attributes
          on module members. It is also not possible to create instances
          of module types.
        </p>
      </body>
    </subsection>
    <subsection id="variant-def">
      <title>Variant definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="variant"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="variant_option"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
        <rule name="variant_option">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <terminal name="{"/>
            <repeat>
              <non-terminal name="field_definition"/>
            </repeat>
            <terminal name="}"/>
          </optional>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="attributes">
    <title>Attributes</title>
    <body>
      <p>
        The semantics of attributes is the same as in C#.
      </p>
      <rule name="attributes">
        <repeat>
          <non-terminal name="attribute"/>
        </repeat>
      </rule>
      <rule name="attribute">
        <terminal name="new"/>
      </rule>
      <rule name="attribute">
        <terminal name="public"/>
      </rule>
      <rule name="attribute">
        <terminal name="protected"/>
      </rule>
      <rule name="attribute">
        <terminal name="internal"/>
      </rule>
      <rule name="attribute">
        <terminal name="private"/>
      </rule>
      <rule name="attribute">
        <terminal name="abstract"/>
      </rule>
      <rule name="attribute">
        <terminal name="sealed"/>
      </rule>
      <rule name="attribute">
        <terminal name="static"/>
      </rule>
    </body>
  </section>


  <section id="type-members">
    <title>Declarations within types</title>
    <body>
      <rule name="type_member">
        <non-terminal name="field_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="method_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="type_declaration"/>
      </rule>
    </body>
    <subsection id="field-def">
      <title>Field definition</title>
      <body>
        <rule name="field_definition">
          <non-terminal name="attributes"/>
          <optional>
            <terminal name="mutable"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
      </body>
    </subsection>
    <subsection id="interface-mem-def">
      <title>Interface member</title>
      <body>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <non-terminal name="method_header"/>
          <terminal name=";"/>
        </rule>
      </body>
    </subsection>
    <subsection id="method-def">
      <title>Method definition</title>
      <body>
        <rule name="method_definition">
          <non-terminal name="attributes"/>
          <non-terminal name="method_header"/>
          <non-terminal name="method_body"/>
        </rule>
      </body>
    </subsection>
    <subsection id="method-head">
      <title>Method header</title>
      <body>
        <rule name="method_type_parameters">
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
        </rule>
        <rule name="method_header">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <non-terminal name="method_implements"/>
        </rule>
        <rule name="method_header">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="this"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
        </rule>
        <rule name="method_implements">
          <optional>
            <terminal name="implements"/>
            <non-terminal name="qualified_identifier"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="qualified_identifier"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-parms">
      <title>Method parameters</title>
      <body>
        <rule name="method_parameter">
          <non-terminal name="identifier_or_dummy"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
        </rule>
        <rule name="method_parameters">
          <optional>
            <non-terminal name="method_parameters"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="method_parameter"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-body">
      <title>Method body</title>
      <body>
        <rule name="method_body">
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <rule name="method_body">
          <non-terminal name="block"/>
        </rule>
      </body>
    </subsection>
  </section>


  <section id="type-expressions">
    <title>Type expressions</title>
    <body>
      <p>
      </p>
    </body>
    <subsection id="type-app">
      <title>Type constructor application</title>
      <body>
        <rule name="primary_type">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <terminal name="("/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
            <terminal name=")"/>
          </optional>
        </rule>
        <p>
          Type constructor (defined with <a ref="#type-definitions">type
          declaration</a>) can be applied to zero or more arguments
          forming type expression. Number of type arguments in type
          application must match number of <a ref="#ty-parms">type
          arguments</a> in definition.  Moreover actual type arguments
          must solve <a ref="#ty-parms"><tt>where</tt> constraints</a>
          imposed on formal type arguments.
        </p>
      </body>
    </subsection>
    <subsection id="tyvar">
      <title>Type variable reference</title>
      <body>
        <rule name="primary_type">
          <special-terminal name="TYPE_VARIABLE"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="group-ty">
      <title>Grouping types</title>
      <body>
        <rule name="primary_type">
          <terminal name="("/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="void-ty">
      <title>Void type</title>
      <body>
        <rule name="primary_type">
          <terminal name="void"/>
        </rule>
        <p>
          This is mostly an alias for <tt>System.Void</tt> (hence the
          name, it should be in fact called <tt>unit</tt>). It is however
          first class value -- can be passed as function parameter as
          well as returned from functions.
        </p>
      </body>
    </subsection>
    <subsection id="ref-out-ty">
      <title>Ref and Out types</title>
      <body>
        <rule name="primary_type">
          <terminal name="ref"/>
          <non-terminal name="primary_type"/>
        </rule>
        <rule name="primary_type">
          <terminal name="out"/>
          <non-terminal name="primary_type"/>
        </rule>
        <p>
          These are for parameters passed by reference. This is not
          implemented yet, but will have semantics similar as in C#.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ty">
      <title>Tuple type</title>
      <body>
        <rule name="type">
          <non-terminal name="primary_type"/>
          <repeat>
            <terminal name="*"/>
            <non-terminal name="primary_type"/>
          </repeat>
        </rule>
        <p>
          Construct product (tuple) type. This operator is not associative, which
          means that each two of following types are different:
        </p>
<code>
int * int * int
(int * int) * int
int * (int * int)
</code>
      </body>
    </subsection>
    <subsection id="function-ty">
      <title>Function type</title>
      <body>
        <rule name="type">
          <non-terminal name="type"/>
          <terminal name="->"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          Construct function type with specified argument and return
          types respectively. The <tt>-></tt> operator is right
          associative, which means that the following type are equivalent:
        </p>
<code>
int -> int -> int
int -> (int -> int)
</code>
      </body>
    </subsection>
  </section>


  <section id="literal-exprs">
    <title>Literal expressions</title>
    <body>
      <p>
        These are used in expressions and patterns.
      </p>
    </body>
    <subsection id="boolean-lit">
      <title>Boolean</title>
      <body>
        <rule name="literal">
          <terminal name="true"/>
        </rule>
        <rule name="literal">
          <terminal name="false"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="null-lit">
      <title>Null</title>
      <body>
        <rule name="literal">
          <terminal name="null"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="void-lit">
      <title>Void</title>
      <body>
        <rule name="literal">
          <terminal name="("/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="string-lit">
      <title>String</title>
      <body>
        <rule name="literal">
          <special-terminal name="STRING_LITERAL"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="number">
      <title>Number</title>
      <body>
        <rule name="literal">
          <special-terminal name="NUMBER_LITERAL"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="character">
      <title>Character</title>
      <body>
        <rule name="literal">
          <special-terminal name="CHARACTER_LITERAL"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="prim-expressions">
    <title>Primary expressions</title>
    <body>
      <p>
        Primary expressions is grammar category referring to expressions
        that have closed structure and are otherwise simple. Primary
        expressions and plain expressions do not differ at the semantic
        level.
      </p>
    </body>
    <subsection id="literal-ref">
      <title>Literal expression</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="literal"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="variable-ref">
      <title>Variable reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="qualified_identifier"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="this-ref">
      <title>this pointer reference</title>
      <body>
        <rule name="primary_expr">
          <terminal name="this"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="grouping">
      <title>Grouping expression</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="type-cast">
      <title>Type cast</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="type-enf">
      <title>Type enforcement</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="member-ref">
      <title>Member reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="primary_expr"/>
          <terminal name="."/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ctor">
      <title>Tuple constructor</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <repeat-plus>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat-plus>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="indexer-ref">
      <title>Indexer reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="expr"/>
          <terminal name="["/>
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>

  
  <section id="core-expressions">
    <title>Core Expressions</title>
    <body>
       <p>
       </p>
    </body>
    <subsection id="prim-expr-ref">
      <title>Primary expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="call">
      <title>Function call</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="("/>
          <optional>
            <non-terminal name="parameter"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="parameter"/>
            </repeat>
          </optional>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="assign">
      <title>Assignment</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="match-expr">
      <title>Match expression</title>
      <body>
        <rule name="expr">
          <terminal name="match"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="raise-expr">
      <title>Raise expression</title>
      <body>
        <rule name="expr">
          <terminal name="raise"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-with">
      <title>Try..with expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="with"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="try_with_handler"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="try_with_handler"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-finally">
      <title>Try..finally expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="finally"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="unary-op">
      <title>Unary operator application</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="binary-op">
      <title>Binary operator application</title>
      <body>
        <rule name="expr">
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="block-ref">
      <title>Block expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="block"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="array-ctor">
      <title>Array constructor</title>
      <body>
        <rule name="expr">
          <terminal name="array"/>
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="expr"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="value-def">
      <title>Value definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="pattern"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="local-fun-def">
      <title>Local function definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="method_header"/>
          <non-terminal name="block"/>
          <repeat>
            <terminal name="and"/>
            <non-terminal name="method_header"/>
            <non-terminal name="block"/>
          </repeat>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="mutable-def">
      <title>Mutable value definition</title>
      <body>
        <rule name="expr">
          <terminal name="mutable"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>
  

  <section id="macro-expressions">
    <title>Secondary Expressions</title>
    <body>
      <p>
        This section describes expressions that are in fact just syntactic sugar
        over Core Expressions. We just present translation of Secondary Expressions
        into Core Expressions.
      </p>
    </body>
    <subsection id="if-expr">
      <title>Conditional expression</title>
      <body>
        <rule name="expr">
          <terminal name="if"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
          <terminal name="else"/>
          <non-terminal name="expr"/>
        </rule>
          <p>	
	    Standard branch, which executes and return value of first expression 
	    if condition evaluates to true or second elsewere.
          </p>
          <p>
            Internally it is translated into
          </p>
<code>
match (cond) {
  | true => expr1
  | false => expr2
}
</code>             
      </body>
    </subsection>
    <subsection id="while-expr">
      <title>While loop</title>
      <body>
        <rule name="expr">
          <terminal name="while"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Loop for executing body expression as long as condition is true.
          Its value is always checked before execution of body and if it
          evaluates to false, then loop ends. Body must be of type 
          <tt>void</tt>.
        </p>
        <p>
          While loop is translated internally into following code
        </p>
<code>
def loop () {
  if (cond) 
    body; loop ()
  else
    ()
};
loop ()
</code>
      </body>
    </subsection>
    <subsection id="when-expr">
      <title>When expression</title>
      <body>
        <rule name="expr">
          <terminal name="when"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Version of <tt>if</tt> condition, but having only one branch - 
          execution of body only when condition is satisfied. If its value
          if <tt>false</tt>, then nothing is done (i. e. <tt>()</tt> is 
          returned).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) body else ()
</code>
      </body>
    </subsection>
    <subsection id="unless-expr">
      <title>Unless expression</title>
      <body>
        <rule name="expr">
          <terminal name="unless"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Opposite version of <tt>when</tt>. It executes and returns value
          of body only if conditions if not satisfied (i. e. evaluates to 
          <tt>false</tt>).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) () else body
</code>
      </body>
    </subsection>
    <subsection id="lambda-expr">
      <title>Lambda expression</title>
      <body>
        <rule name="expr">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="fun"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
	  Lambda expressions can be thought as of anonymous local functions.
	  This construct defines such a function and returns it as the
	  functional value. This value can be used just like the name of 
	  regular local function.
        </p>
        <p>
          Example:
        </p>
<code>
List.iter (fun (x) { printf ("%d\n", x) }, intList)
</code>
        <p>
          is equivalent to
        </p>
<code>
def tmpfunc (x) { printf ("%d\n", x) };
List.iter (tmpfunc, intList)
</code>
        <p>
          Lambda expression is indeed translated internally to
        </p>
          <rule name="expr">
            <terminal name="def"/>
            <optional>
              <non-terminal name="method_type_parameters"/>
            </optional>
            <special-terminal name="new temporary name"/>
            <terminal name="("/>
            <non-terminal name="method_parameters"/>
            <terminal name=")"/>
            <optional>
              <terminal name=":"/>
              <non-terminal name="type"/>
            </optional>
            <non-terminal name="block"/>
          </rule>
      </body>
    </subsection>
    <subsection id="list-expr">
      <title>List constructor</title>
      <body>
        <rule name="expr">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="expr"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          <tt>[1;2;3]</tt> is translated to <tt>Cons (1, Cons (2, Cons
          (3, Nil ())))</tt>.
        </p>
      </body>
    </subsection>
  </section>

  <section id="expression-helpers">
    <title>Expression helpers</title>
    <body>
      <p>
        This section describes some constructs used in Expressions
        section.
      </p>
    </body>
    <subsection id="sequence">
      <title>Sequence</title>
      <body>
        <rule name="sequence">
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=";"/>
            <non-terminal name="expr"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="block">
      <title>Block</title>
      <body>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="sequence"/>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-with-handler">
      <title>Try..with handler</title>
      <body>
        <rule name="try_with_handler">
          <non-terminal name="identifier_or_dummy"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name="=&gt;"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="fun-parm">
      <title>Function parameter</title>
      <body>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="match-case">
      <title>Match case</title>
      <body>
        <rule name="guarded_pattern">
          <non-terminal name="pattern"/>
          <optional>
            <terminal name="when"/>
            <non-terminal name="expr"/>
          </optional>
        </rule>
        <p>
        </p>
        <rule name="match_case">
          <non-terminal name="guarded_pattern"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="guarded_pattern"/>
          </repeat>
          <terminal name="=&gt;"/>
          <non-terminal name="sequence"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="patterns">
    <title>Patterns</title>
    <body>
      <p>
      </p>
    </body>
    <subsection id="cons-pat">
      <title>Constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <non-terminal name="pattern"/>
          </optional>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="dummy-pat">
      <title>Throw-away pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="_"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="record-pat">
      <title>Record pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="{"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=";"/>
            <special-terminal name="IDENTIFIER"/>
            <terminal name="="/>
            <non-terminal name="pattern"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="as-pat">
      <title>As binding</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <terminal name=")"/>
          <terminal name="as"/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="tuple-pat">
      <title>Tuple pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="pattern"/>
          </repeat>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="list-pat">
      <title>List constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="pattern"/>
          <terminal name="::"/>
          <non-terminal name="pattern"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="list-lit-pat">
      <title>List literal pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="pattern"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="pattern"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="lit-pattern">
      <title>Literal pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="literal"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="macros">
    <title>Macros</title>
    <body>
      <p>
        Please refer to <link>macros.html</link> for now.
      </p>
    </body>
  </section>


    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
