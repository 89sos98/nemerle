
module M {

  // test case for pattern overriding //
  method_a (parm : char, phaser : int) : int {
    match (parm) {
      | 'A' when phaser % 4 == 0 => 1000 + (parm :> int)
      | 'A' when phaser % 4 == 1 => 1
      | 'A' => 2 // W: this pattern overrides pattern:
      | 'A' => 3 // W: pattern is redundant
      | 'A' when phaser % 4 == 2 => 4 // W: pattern is redundant
      | 'A' => 5 // W: pattern is redundant
      | _ when parm == 'x' => 13
      | 'A' => 6 // W: pattern is redundant
      | 'A' => 7 // W: pattern is redundant
      | 'A' when parm == 'y' => 8 // W: pattern is redundant
      | 'A' => 9 // W: pattern is redundant
      | 'B' => 10
      | 'C' => 11
      | x when x >= '0' && x <= '9' => 255
      | _ => -1
    }
  }

  // test case for no literal patterns //
  method_b (parm : char, _phaser : int) : int {
    match (parm) {
      | x when x == 'A' => 0
      | _ => 1
    }
  }

  // test case for non-value result types //
  method_c (parm : char) : option (int) {
    match (parm) {
      | 'A' => Some (42)
      | _ => None ()
    }
  }

  // test case for P_as //
  method_d (parm : char, _phaser : int) : int {
    match (parm) {
      | 'A' => 0
      | ch => (ch :> int)
    }
  }

  Main () : void 
  {
    def run_method (method : char * int -> int) : void {

      printf ("%d\n", method ('A', 0));
      printf ("%d\n", method ('A', 1));
      printf ("%d\n", method ('A', 2));
      printf ("%d\n", method ('A', 3));
      printf ("%d\n", method ('A', 0));
      printf ("%d\n", method ('B', 0));
      printf ("%d\n", method ('0', 0));
      printf ("%d\n", method ('x', 0));
      printf ("---\n")
    };

    def methods = [method_a; method_b; method_d];

    Nemerle.Collections.List.Iter (run_method, methods);

    if (Option.is_some (method_c ('A'))) printf ("method_c OK\n")
    else printf ("method_c FAILED\n");

    printf ("---\n")
  }
}

/*
BEGIN_OUTPUT
1065
1
2
2
1065
10
255
13
---
0
0
0
0
0
1
1
1
---
0
0
0
0
0
66
48
120
---
method_c OK
---
END_OUTPUT
*/
