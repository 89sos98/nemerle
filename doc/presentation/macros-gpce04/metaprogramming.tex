% Meta-programming in Nemerle
%
\documentclass{llncs}
%
\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\netf}[0]{{\tt .NET} framework}
\newcommand{\nem}[0]{Nemerle}
\newcommand{\cs}[0]{C\#}
\newcommand{\oo}[0]{object-oriented}
\newcommand{\kw}[1]{{\tt \bf #1}}
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%
\title{Meta-programming in \nem}
%
\titlerunning{Meta-programming in Nemerle}  
%
\author{Kamil Skalski \and Micha³ Moskal \and Pawe³ Olszta}
%
\authorrunning{Kamil Skalski et al.} 
%
%
\institute{University of Wroc³aw, Poland \\
           \texttt{http://www.nemerle.org}}
%
\maketitle              % typeset the title of the contribution
%
\begin{abstract}
We present design of meta-programming system embedded into the new functional
language \nem\ for \net\ platform. It introduces support for set of 
operations performed on code at compile-time, allowing generation,
transformation and automated analysis of programs. They consist of
code quotation system, syntax extensions, operating on code like on any
other datatype (e.g. listing, adding or changing members of class'
definition), performing guided by user partial typing of program's syntax tree
(compiler's internal typing procedures are executed by macro's code)
and other interoperability with compilation process, which can be fully
parametrized with any external data (like database, file or web page).

Our system provides a good tool for Aspects Oriented Programming, by 
operating on datatypes, traversing program's code and performing algorithmic 
addition of various concerns to its content.
\end{abstract}

\section{Introduction}
Idea of compile-time meta-programming has been studied for quite a long time.
It was incorporated into several languages, like Scheme Lisp hygienic macros 
\cite{Lisp:Scheme}, C preprocessor-based macros, C++ template system and finally 
Haskell Template Meta-programming \cite{Haskell:Meta}. 
They vary on their power and ease of use, but generally involve computations 
made during compilation of program and generating code from some definitions.

During this process programs are treated as \emph{object programs}, which are 
data supplied to \emph{meta-programs}. Then they can be arbitrarily transformed or 
analyzed and the final result is compiled just like a regular program. These operations 
may be repeated or take place in stages. In latter case generated programs can 
generate other programs and so on.

\emph{Meta-language} is the language for programming those operations. It 
commonly has its own syntax for describing various constructs of object language.
For example in our system, \verb,<[ 1 + f (2 * x) ]>, is annotation for syntax 
tree of expression \verb,1 + f (2 * x),. This idea is called 
\emph{quasi-quotation}. The prefix \emph{quasi} comes from the possibility
of inserting values of meta-language expressions into the quoted context -- 
if \verb,g(y), is such an expression, we can write \verb.<[ 1 + $(g (y)) ]>., %$
which describe syntax tree, whose second part is replaced by result of evaluation of
\verb,g(y),.

\subsection{Our contribution}
In this paper we introduce a few new ideas about syntax of meta-language, its much 
widened interoperability with compilation process and usage of new technologies to 
connect great abilities of meta-programming with top industrial standards in 
computer technology:
\begin{itemize}
  \item We develop uniform and simple quasi-quotation system, which doesn't require
    learning of internal compiler data structures to generate and transform quite 
    complicated object programs. It also contains easy way to write variable argument 
    constructs (like tuples or function calls with arbitrary amount of parameters)
  \item Using macros is transparent from user's point of view -- meta-program and 
    common function calls are indistinguishable, so user can use most complex
    macros prepared by others without even knowing idea of meta-programming
  \item Flexible definition of syntax extensions allow even greater embedding of 
    macros into language without interfering with compiler internals
  \item Our system can be used to transform or generate practically any fragment
    of program, which composed with \net\ \oo\ structure gives powerful tools for
    software engineering methodologies like aspects-oriented programming
  \item We allow macros to type fragments of code, which they operate on, during
    their execution. This allows to parameterize them not only with syntax of provided
    expressions, but also with entire context of program and type correctness of
    those expressions
\end{itemize}

\subsection{Characteristics of \nem 's meta-system} 
Our meta-system has both \emph{program generation} and \emph{analysis}
capabilities \cite{Meta:Accomplishments}. It can easily walk through the abstract 
syntax tree of object program and gather informations about it as well as change it 
(often using gathered data).

System is mainly designed for operating on object programs at compile-time.
However using features of \net\ and its dynamic code loading abilities, it is also
possible to execute macros during run-time. 

Meta-language is \emph{homogeneous}, which means that it's the same as object 
language. We can use common \nem\ functions within macros and the syntax 
of generated programs is no different than one used to write macros.

Quasi-quotation provides clear separation of object program from meta-language.
This manual annotation gives us way to separate stages of execution in well
understood fashion. It's also semantically clear which part of code is generated 
and which generates. Although we allow only one level of quotation (to avoid confusion
associated with multi-layered code) it's easy to recurse through structure of
program. 

\section{First examples}
Let's suppose we want to add some new syntax to our language, like
\kw{for} loop. We could embed it into compiler, but it's rather hard
and inelegant way -- such addition is quite short and it shouldn't
involve much effort to complete. And here is the place, where we can
use macro.

\begin{verbatim}
macro for (init, cond, change, body) 
{
  <[ 
    $init;
    def loop () {
      if ($cond) { $body; $change; loop() } 
      else () 
    }; 
    loop ()
  ]>
}
\end{verbatim}

This code creates special meta-function, which is executed at compile-time
in every place where its orginal call is placed. After that, its result is 
inserted into a program. Always when we write something like

\begin{verbatim}
  for (i <- 0, i < n, i <- i + 2, a[i] <- i)
\end{verbatim}

appropriate code is created according to the \kw{for} macro and replaces original 
call.

We can also instruct compiler to extend its syntax, to allow usual (C-like)
usage of \kw{for} loop. Writing

\begin{verbatim}
  macro for (init, cond, change, body) 
  syntax ("for", "(", init, cond, change, ")", body) { ... }
\end{verbatim}

would add new rule to the parser, which allows using

\begin{verbatim}
  for (i <- 0; i < n; i <- i + 2) a[i] <- i
\end{verbatim}

as shortcut to call mentioned above.

\subsection{Compiling sublanguages from strings}
Macros are very useful for initial checking and processing of code
written as strings in program. This relates to many simple languages,
like SQL, regular expressions, printf formatting string, which are often
used inside program directly. 

Let's consider common situation, when we want to parameterize SQL query
with some values from our program. Most database providers in 
\netf\ allows us to write commands with parameters, but neither their
syntax is checked during compilation, nor types are controlled to agree
between database and program.

With well written macro, we could write
\begin{verbatim}
  sql_loop (conn, "SELECT salary, LOWER (name) AS lname"
                  "  FROM employees"
                  "  WHERE salary > $min_salary") {
    print ("$lname : $salary\n")
  }
\end{verbatim} %$

to obtain syntax and type-checked SQL query and code of following form
\begin{verbatim}
  def cmd = SqlCommand ("SELECT salary, LOWER (name)"
                        "  FROM employees"
                        "  WHERE salary > @parm1", conn);

  (cmd.Parameters.Add (SqlParameter ("@parm1", DbType.Int32)))
    .Value <- min_salary;
  def r = cmd.ExecuteReader ();
  while (r.Read ()) {
    def salary = r.GetInt32 (0);
    def lname = r.GetString (1);
    print ("$lname : $salary\n")
  }
\end{verbatim}

In fact \verb,print, function here is another macro, that generates following
code, basing on given string parameter:

\begin{verbatim}
  System.Console.Write (lname.ToString ());
  System.Console.Write (" : ");
  System.Console.Write (salary.ToString ());
  System.Console.Write ("\n")
\end{verbatim}

\section{Variable amount of arguments}
Quotation gives us full freedom in constructing any kind of expression.
For example we can decompose tuple of any size and print its elements.

\begin{verbatim}
  macro PrintTuple (tup, size : int)
  {
    def symbols = array (size);
    mutable pvars <- [];
    for (mutable i <- size - 1; i >= 0; i <- i - 1) {
      symbols[i] <- NewSymbol ();
      pvars <- <[ pattern: $(symbols[i] : var) ]> :: pvars;
    };
    mutable exps <- [];
    for (mutable i <- size - 1; i >= 0; i <- i - 1)
      exps <- <[ WriteLine ($(symbols[i] : var)) ]> :: exps;

    exps <- <[ def (.. $pvars) = $tup ]> :: exps;
    <[ {.. $exps } ]>
  }
\end{verbatim} %$

Note that here we need number describing size of tuple. Later, we show how
to obtain type of given expression within macro, thus size of tuple
described by \verb,tup, variable can be computed.

\section{Pattern matching on programs}
Quotation can be used to analyze structure of program as easily as generate
it. Standard mechanisms of language, like pattern matching, fit perfect
for such a purpose. 

Let's suppose, we want to check code for occurrences of following buggy
fragments:
\begin{verbatim}
 if ( foo != null && foo.bar || foo.blah ) foo.blah
\end{verbatim}

We write macro, which inspects given program to signal such constructs.
\begin{verbatim}
macro analyze (exp) : void 
{
  def traverse (ex, checked) {
    match (exp) {
      | <[ $(name : var) != null ]> => checked.Add (name)
      | <[ $(name : var).$(_) ]> => 
        if (!checked.Contains (name)) 
          throw MaybeBug() 
        else 
          checked
      | <[ $e1 && $e2 ]> => traverse (e2, traverse (e1, checked))
      | <[ $e1 || $e2 ]> => 
        def chck1 = traverse (e1, checked);
        def chck2 = traverse (e2, checked);
        Intersect (chck1, chck2)
      | <[ if ($cond) $e1 else $e2 ]> =>
        traverse (e1, traverse (cond, checked));
        traverse (e2, checked)
      | _ => Macros.ApplyExpr (fun (x) { traverse (x, checked) }, 
                               exp)
    }
  };
  Macros.ApplyExpr (fun (x) { traverse (x, Set ()) }, exp)
}
\end{verbatim} %$

\section{Macros on declarations} \label{Declarations}
Macros can operate not only on expressions, patterns, types, but on
any part of language, like classes, interfaces, other type declarations,
methods, etc. Syntax for those operations is quite different. We again
treat language constructs as data objects, which we can transform, but
it isn't done with quotations. We use special API provided by those
objects.

With such a tool, we can analyze, generate or change any declaration
in program. For example, dump definition of each data structure 
to XML file, create serialization methods, automatically
generate fields or methods from external description.

Such macros aren't called like ordinary functions, but are added as
attributes in front of declaration, in similar way to \cs\ attributes.

\begin{verbatim}
  [ToXML ("Company")] public module Company {
    [SerializeBinary ()] public class Employee {
      ...
    }

    [FromXML ("Product"), Comparable ()] public class Product;
  }
\end{verbatim}

\subsection{Transforming types}
Macros that operate on declarations change them in imperative fashion.
Their first parameter is always object representing given declaration. 

\begin{verbatim}
macro ToXML (c : ClassDeclaration, file : string) { 
\end{verbatim}

We can easily list data contained in provided object, like fields or methods 
of a class.

\begin{verbatim}
def flds = c.GetFields ();
def meths = c.GetMethods ();
\end{verbatim}

FIXME: FINISH THIS EXAMPLE

\section{Aspects-oriented programming}
AOP has been proposed as technique for separating of different 
\emph{concerns} in software. It's often a problem, when they crosscut 
natural modularity of the rest of implementation and must be written 
together in code, leading to tangled code. 

In contrary to many other systems, which define fixed \emph{join points}
in code (like AspectJ \cite{AspectJ}), macros allow to place user code in 
arbitrary parts of program. One can write a macro, which traverses all classes
and add some behavior to their bodies. Defining these points isn't
restricted to any design, but user can write a program that defines them.

In general it should be possible to implement most Aspects-oriented
and Adaptive-programming systems' design with more or less complex 
macros.

\section{Details of our design}
We provide more formal definition of macro and our meta-system.

FIXME: THIS IS OBSOLETED
Macro is a top-level function, which may have modifiers 
\verb,public,, or \verb,private, and resides in standard \net/\nem\ namespace. 
Private macro may be accessed only within file, where it's defined. 
It can have standard name, which is considered in program as name of standard
function (but it's treated in special way by compiler).

Its formal parameters' types are restricted to the set of \nem\
grammar elements (including simple literal types). Parameters of 
macro are passed always as their syntax trees, which for some
types are partially decomposed. For example literal types appear
within macro as real values (int, string, etc.), but they are passed
as syntax trees, so they must be given as constant literals (it's
obvious since these values must be known at compile-time).

\subsection{Macro as a function}
Macro is never recursive and can't be passed as first class citizen.
But still, it can use any function from the rest of program in a standard ML
fashion, so we consider this as a minor disadvantage. If a complex 
computations on syntax trees are needed, one must simply put them 
into some arbitrary functions and run entire computation from within a macro. 
Such design allows to easily distinguish which functions are run at
compile-time without any special annotations.

\subsection{Names binding in quotation}
Very important property of meta-system is called ``hygiene''. It specifies that
variables introduced by macro may not bind to variables used in code passed
to this macro. Particularly variables with the same names, but coming from 
different contexts should be automatically distinguished and renamed.
 
Consider following example:

\begin{verbatim}
  macro identity (e) { <[ def f (x) { x }; f($e) ]> }
\end{verbatim} %$

Calling it with \verb,identity (f(1)), might generate confusing code like

\begin{verbatim}
  def f (x) { x }; f (f (1))
\end{verbatim}

To preserve names capture, all macro generated variables should be renamed 
to their unique counterparts, like in

\begin{verbatim}
  def f_42 (x_43) { x_43 }; f_42 (f (1))
\end{verbatim}

In general, names in generated code bind to definitions visible in their scope.
Binding is done after all transformations during execution of macro are finished.
This means that variable used in some quotation may not necessarily refer 
to definition visible directly in place where it's written. All depends on
where it occurs in finally generates code. Consider following example:

\begin{verbatim}
  macro foo (body) {
    def d1 = <[ def mail = login + "@nemerle.org" ]>;
    def d2 = <[ def login = $(developer : string) ]>
    <[ $d2;
       $d1;
       def msg = MailMessage ();
       msg.To <- mail;
       msg.Body <- $body;
       SmtpMail.Send (msg)
    ]>
  }
\end{verbatim}

As macros might get large and complex it's frequently very
useful to compute parts of expression independently and then compose
final code from them. Still, names in this macro are alpha-renamed to
do not capture any external definitions. Renaming is defined as putting
names created in single macro execution into the same ``namespace'' which is
mutually exclusive with all other ``namespaces'' and top-level code.
This is exactly the rule of hygiene -- neither macro can capture names
used in macro-use place nor it can define anything colliding with external
code. 

This is an opposite approach to Template Haskell \cite{Haskell:Meta}, 
where lexical scoping means binding variables from object code immediately 
to definitions visible at construction of quotation.
We find our approach more flexible as we can transform code with much
more freedom, while still keeping hygienic system. This is of course just a
design decision, which come with some costs. Sometimes it's not obvious to
recreate bindings simply by looking on code, but here we assume that programmer
of macro knows the structure of code to be generated. We also lose ability to 
detect some errors earlier, but as they are always detected during compilation of 
generated code, we see it a minor disadvantage. 

\subsection{Breaking hygiene}
Sometimes it is useful to share some names between few macro executions.
It can be done safely by generating unique identifier independent of macro
executions. We support it by function \verb,NewSymbol (), whose return value
can be stored in some variable, giving solution preserving hygiene.

There are also situations, where we know exact name of variable used in code
passed to macro. If we wanted to define name referring to it, we would have to
get into context of our macro's use site. As it breaks hygiene, it should be done
in controlled fashion. Consider macro introducing \kw{using} keyword (C\# keyword,
simplified for the purpose of this paper):

\begin{verbatim}
macro using (name : string, val, body) {
  def v = Macros.UseSiteSymbol (name);
  <[ 
    def $(v : var) = $val;
    try $body finally $v.Dispose ()
  ]>
}
\end{verbatim}

It should define symbol binding to variables of the same name in \verb,body,.
But if it contains some other external code, like in:

\begin{verbatim}
macro bar(ext) { <[ using ("x", Foo (), { $ext; x.Compute () }) ]> }
\end{verbatim} %$

some inadverent capture of variables in \verb,ext, might be done if 
\verb,x, would be just plain, dynamically scoped variable.

Although it is not recommended, also nonhigienic symbols can be created, by
\verb,$(x : dyn),, where \verb,x, is of type string.

\subsection{Global symbols}

\begin{verbatim}
  using System.Text.RegularExpressions;

  public module Finder 
  {
    public static current : string;

    macro finddigit (x : string)
    {
      <[ 
        def numreg = Regex (@"\d+-\d+");
        def m = numreg.Match (current + x);
        m.Success ();
      ]>
    }
  }
\end{verbatim}

brings some dependency on currently imported namespaces. We would like
generated code to behave the same no matter where it used, thus 
\verb,Regex, constructor and \verb,current, variable should be prefixed
with their full namespace -- \verb,System.Text.RegularExpressions.Regex,
and \verb,Finder.current, respectively. This operation is automatically
done by quotation system.

Note that there is no possibility to override security permissions this
way. Access rights from lexical scope of macro aren't exported to the place
where generated code is used. \net\ policies doesn't allow this, thus
programmer must not generate code, which access private fields, etc.

\subsection{Accessing compiler internals}
It's important for meta-functions to be able to use all benefits they have
from running at compile-time. They can retrieve informations from
compiler, use its methods to access, analyze and change data stored
in its internal structures. 

\subsubsection{Retrieving declarations}
For example we can ask compiler to give us \emph{type declaration} of
given \emph{type}. It will be available as syntax tree, just like we
would put special macro attribute \ref{Declarations} before that declaration.
Of course it must not be external type, and be available within compiled 
program as source code.

FIXME: MORE COMPLEX EXAMPLE
\begin{verbatim}
  def decl = Compiler.GetDeclaration (<[ type: Person ]>);
  xmlize (decl);
\end{verbatim}

\subsection{Working on object program datatypes}
Also object programs have some internal data and functionality associated 
with them, like location in source code. When working with type 
declarations wide range of interoperability is available through
special API for macros.

\section{Runtime program generation}
It might be possible, but we didn't think about it yet.

Uses: optimizations for runtime accessible data only,
dynamic profiling of long running code, etc.

\section{Typing during execution of macro}
Some more advanced techniques are also possible. They involve closer
interaction with compiler, using its methods and data structures
or even interweaving with internal compilation stages.

For example we can ask compiler to type some of object programs,
which are passed to macro, retrieve and compare their types or to try 
to find common type, which is subtyped by all elements of set of
object programs. This means, that we can plug between many important 
actions performed by compiler, adding our own code there. It might
be just some nicer bug reporting (especially for macros defining
complex syntax extensions), making code generation dependent on
types of input programs or enrich analysis of code by additional
information.

\subsection{Example}
Let's consider following translation of \kw{if} condition to standard
ML matching:

\begin{verbatim}
  macro ifmacro (cond, e1, e2)
  syntax ("if", "(", cond, ")", e1, "else", e1) 
  {
    <[ 
      match ($cond) {
        | true => $e1
        | false => $e2
      }       
    ]>
  }
\end{verbatim} % $

If somebody wrote \verb,if (x) 1 else "no",, compiler would comply
that types of match cases don't fit each other. Such error message could
be very confusing, because programmer may not know, that his \verb,if,
statement is being transformed to \verb,match, statement. Thus, we would
like to check few thing during execution of macro.

\subsection{Usage}
Instead of directly passing object expressions to the result of macro, we
can first make compiler type them and then find out if they have proper
type. The body of above \kw{if} macro is

\begin{verbatim}
   def tcond = TypedExpr (cond);
   def te1 = TypedExpr (e1);
   def te2 = TypedExpr (e2);
   match ( tcond.Type == <[ ttype: bool ]> ) {
     | true =>
       match ( UnifiesTo (te1.Type, te2.Type) ) {
         | Some =>
           <[ 
             match ($(tcond : typed)) { 
               | true => $(te1 : typed) 
               | false => $(te2 : typed) 
             } 
           ]>
         | None =>
           FailWith ("`if...else' body has type " + te1.Type.ToString() + 
                     " while the `else' clause has type " + te2.Type.ToString())
     | _ =>
       FailWith ("`if' condition must have type bool, while it has " + 
                 tcond.Type.ToString())
   }
\end{verbatim}
%$

Note that typed expressions are again used in quotation, but with special 
splicing tag ``typed''. This means, that compiler need not to perform typing
(indeed, it can't do this from now on) on provided syntax trees. Such notation
introduces some kind of laziness in typing, which is directly guided by
programmer of a macro.

\section{How it works}
We will now describe how our meta-programming system works internally. Each
macro is translated to separate class implementing special interface. 
It provides method to run the macro, which in most cases involves passing
it the list of \nem grammar elements (untyped syntax trees of object 
programs). 

\subsection{Operating on syntax trees}
When we consider object programs passed to \emph{Run} function as datatypes
of compiler's internal representation of syntax trees, then macros are 
simply functions operating on them. In the matter of fact programmer can
directly open compiler's data namespaces and build syntax trees using its
constructors. 

Quotation system is just a shortcut for doing this. For example \verb,f(x),
expression is represented as \verb.E_call ("f", [Parm (E_ref ("x"))]).,
which is equivalent to \verb,<[ f (x) ]>,. Translating the quotation brings
us to one more level of this ``lifting'', when we are given the representation
of some program (syntax tree) and we must create representation of this tree,
just as it would be the program. This implies building syntax tree of given
syntax tree, like:

\begin{verbatim}
E_call ("f", [Parm (E_ref ("x"))] =>
  E_call ("E_call", [Parm (E_litral (L_string ("f")));
    Parm (E_call ("Cons", [Parm (E_call ("Parm", 
      [Parm (E_call ("E_ref", 
         [Parm (E_literal (L_string ("x")))]))]))]))])
\end{verbatim}

or when using quotation

\begin{verbatim}
<[ f (x) ]> =>
  <[ E_call ("f", [Parm (E_ref ("x"))]) ]>
\end{verbatim}

Now splicing means just ``do not lift'', because we want to pass value of 
meta-language expression as object code. Of course it is only valid when this 
expression describes (is type of) syntax tree. Operator \verb,.., inside 
quotation is translated as syntax tree of list containing lifted expressions 
from provided list (which must occur after \verb,..,).

One more thing to consider are the typed trees possibly stored in a result
of executed macro. We need special element in untyped syntax tree, which
holds typed tree inside and which is treated in a special way during real
typing by compiler. It is dereferenced and took as it would be the result of 
recursive typing procedure. 

\subsection{Typing macros}
Key element of meta-programming is execution of meta-programs during compile-time.
To do this we must have them in executable form, and thus compile them before
they are used. 

FIXME: DESCRIBE OUR RESTRICTED APPROACH

Of course this procedure might quickly lead to cycle, when somebody uses
macro, which is just created, then it's impossible to compile such a code.
We forbid this and require that macros are independent (no cycles going 
through any newly declared macro). This is also the good design decision,
which encourage programmers to put macros in libraries.

\subsection{Compiling and loading}
FIXME: WRITE IT DOWN!

\section{Related works}
FIXME: BORING (BUT INSPIRING) WORK WITH COMPARISONS AND GOOGLING


%
% ---- Bibliography ----
%
\begin{thebibliography}{}
%
\bibitem {Lisp:Scheme}
Scheme Lisp

\bibitem {Haskell:Meta}
Sheard, T., Jones, S. P.:
Template Meta-programming for Haskell.
Haskell Workshop, Oct. 2002, Pittsburgh

\bibitem {Meta:Accomplishments}
Sheard, T.:
Accomplishments and Research Challenges in Meta-Programming
2001

\bibitem {AspectJ}
AspectJ

\end{thebibliography}

\end{document}
