/*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler 
{
  using Nemerle.Compiler;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Collections;
  using Nemerle.Utility;
  
  using System.Reflection;
  using System.Reflection.Emit;

  using NC = Nemerle.Compiler;
  using SR = System.Reflection;

  /**
   * An IL code generator
   */
  public class CGIL
  {
    /* -- PUBLIC CONSTRUCTORS ---------------------------------------------- */

    public this (target_exe : bool, output_file_name : string, assem_name : AssemblyName)
    {
      def basename (s : string) {
        def dot = s.LastIndexOf ('.');
        def s = if (dot == -1) s else s.Substring (0, dot);
        strip_directory (s)
      };
   
      _output_file_name = output_file_name;
      _assembly_name = assem_name;

      /* define a dynamic assembly */
      this._assembly_name.Name = basename (output_file_name);

      this._assembly_builder = 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      /* we can embed resources only on mono */
      if (SystemType.AssemblyBuilder_EmbedResourceFile != null)                    
        List.Iter (_embedded_resources, fun (file, name : string) {
          try {
            def margs = array [name : object, file : object];
            if (System.IO.File.Exists (file))
                ignore (SystemType.AssemblyBuilder_EmbedResourceFile
                        .Invoke (_assembly_builder, margs));
            else
              Message.error ("Could not find resource " + file);                      
          }
          catch {
            | e : System.Exception =>
              Message.error ("Could not embed resource: " + e.Message);
          }
        })
      else
        when (_embedded_resources matches _ :: _)
          Message.error ("Cannot embed resource on this runtime... use mono");
        
      List.Iter (_linked_resources, fun (file, name) {
        try {
          _assembly_builder.AddResourceFile (name, file);
        }
        catch {
          | _ : System.IO.FileNotFoundException =>
            Message.error ("Could not find resource " + file);
          | e : System.ArgumentException =>
            Message.error ("Could not link resource: " + e.Message);
        }
      });

      def attr = make_string_attribute (SystemType.Reflection_AssemblyConfigurationAttribute,
                                        "ContainsNemerleTypes");
      this._assembly_builder.SetCustomAttribute (attr);

      /* create a dynamic module */
      this._module_builder = 
        this._assembly_builder.DefineDynamicModule ("Module_" + basename (output_file_name), 
                                                    strip_directory (output_file_name), 
                                                    true); // FIXME

      when (target_exe) {
        _need_entry_point = true;
        _entry_point = None ();
      };

      _aux_types = [];
    }


    /**
     *
     */
    public EmitAuxDecls () : void
    {
      compile_all_tyinfos (true)
    }


    /**
     *
     */    
    public EmitDecls () : void
    { 
      foreach (x in AttributeCompiler.GetCompiledAssemblyAttributes ())
        _assembly_builder.SetCustomAttribute (x);

      compile_all_tyinfos (false)
    }

    /**
     * Adds new resource to list of resources to be embedded into output
     * assembly
     */
    public static AddResource (x : string) : void
    {
      def cp = x.IndexOf (',');
      
      def element =
        if (cp != -1)
          (x.Substring (0, cp), x.Substring (cp + 1))
        else
          (x, x.Replace ('/','.').Replace ('\\', '.'));
      
      _embedded_resources = element :: _embedded_resources;
    }

    /**
     * Adds new resource to list of resources to be linked in output
     * assembly
     */
    public static AddLinkedResource (x : string) : void
    {
      def cp = x.IndexOf (',');
      def element =
        if (cp != -1)
          (x.Substring (0, cp), x.Substring (cp + 1))
        else
          (x, x);
      
      _linked_resources = element :: _linked_resources;
    }
     
    /**
     * Saves the constructed assembly to a file
     */
    public SaveAssembly () : void 
    {
      // set the entry point
      match ((_need_entry_point, _entry_point)) {
        | (true, Some (entry_point_method_info)) =>
          _assembly_builder.SetEntryPoint (entry_point_method_info,
                                           PEFileKinds.ConsoleApplication)
        | (true, None) =>
          Message.error ("no suitable entry point (Main function) found")
        | _ => ()
      };

      // save the assembly
      // we cannot save file with directory (see Save description)
      _assembly_builder.Save (strip_directory (_output_file_name));
      when (strip_directory (_output_file_name) != _output_file_name) {
        when (System.IO.File.Exists (_output_file_name))
          System.IO.File.Delete (_output_file_name);
          
        System.IO.File.Move (strip_directory (_output_file_name), _output_file_name)
      }
    }

    /**
     * Tell IL generator that we have created type instance elsewhere, and
     * it needs to get finalized before saving an assembly.
     */
    public RegisterAuxType (tb : Emit.TypeBuilder) : void
    {
      _aux_types = tb :: _aux_types;
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    private strip_directory (s : string) : string
    {
      def slash =
        if (s.LastIndexOf ('/') > s.LastIndexOf ('\\')) 
          s.LastIndexOf ('/')
        else
          s.LastIndexOf ('\\');
      s.Substring (slash + 1)
    }
    
    /**
     *
     */
    emit_implementation (ti : NC.TypeBuilder) : void
    {
      ti.is_finalized = true;

      mutable skip_types = false;
      def emit_member (m : IMember) {
        def mods = m.GetModifiers ();
        unless (mods.IsEmpty) {
          def handle = m.GetHandle ();
          //Message.debug (handle.ToString () + ": " + handle.GetType ().ToString ());
          mutable context = m.DeclaringType;
          def adder =
            match (m.GetKind ()) {
              | MK_method (m) => 
                // FIXME: we should allow [return:] here, but lame S.R.E. doesn't allow
                // this, mono has an extension though
// bug in MS Framework?      if ((handle :> MethodBase).IsConstructor)
                if (m.GetFunKind () is FK_ctor)
                  fun (target, attribute) {
                    if (target != System.AttributeTargets.Method &&
                        target != System.AttributeTargets.All)
                      Message.error ("only [method:] target allowed on constructor")
                    else {
                      def x = (handle :> ConstructorBuilder).SetCustomAttribute (attribute) ;
                      x
                     }
                    }
                else
                  fun (target, a) {
                    if (target == System.AttributeTargets.ReturnValue)
                      Message.error ("[return:] attribute target not supported yet")
                    else if (target != System.AttributeTargets.Method &&
                             target != System.AttributeTargets.All)
                      Message.error ("only [method:] and [return:] targets allowed on methods")
                    else
                     (handle :> MethodBuilder).SetCustomAttribute (a)
                  }
              | MK_property => 
                fun (target, a) {
                  if (target != System.AttributeTargets.Property &&
                           target != System.AttributeTargets.All)
                    Message.error ("only [property:] targets allowed on properties")
                  else
                   (handle :> PropertyBuilder).SetCustomAttribute (a)
                }
              | MK_event => 
                fun (target, a) {
                  if (target != System.AttributeTargets.Event &&
                      target != System.AttributeTargets.All)
                    Message.error ("only [event:] target allowed on events")
                  else
                   (m :> NemerleEvent).event_builder.SetCustomAttribute (a)
                }
              | MK_field  =>
                fun (target, a) {
                  if (target != System.AttributeTargets.Field &&
                      target != System.AttributeTargets.All)
                    Message.error ("only [field:] target allowed on fields")
                  else
                   (handle :> FieldBuilder).SetCustomAttribute (a)
                }
              | MK_type (tc) =>
                if (skip_types)
                  null
                else {
                  context = tc;
                  fun (target, a) {
                    if (target != System.AttributeTargets.Class &&
                        target != System.AttributeTargets.All)
                      Message.error ("only [type:] target allowed on types")
                    else
                     (handle :> SR.Emit.TypeBuilder).SetCustomAttribute (a)
                  }
                }
            };
          
          when (adder != null)
            mods.SaveCustomAttributes ((context :> NC.TypeBuilder), adder)
        }
        
        match (m.GetKind ()) {
          | MK_field =>
            when ((m :> NemerleField).IsVolatile)
            {
              def volatile_attr =
                make_void_attribute (SystemType.VolatileModifier);

              (m.GetHandle () :> FieldBuilder).SetCustomAttribute (volatile_attr)
            }
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod))
          | MK_property (p) =>
            compile_property (p)
          | MK_event (p) =>
            compile_event (p)
          | _ => ()
        }
      };

      emit_member (ti);
      skip_types = true;
      List.Iter (ti.GetDirectMembers (), emit_member);
      //Message.debug ("finalizing " + ti.FullName);
      unless (Message.seen_error ())
        ti.FinalizeType ();
      //Message.debug ("finalized " + ti.FullName);
    }


    compile_property (prop : IProperty) : void
    {
      def builder = (prop.GetPropertyInfo () :> PropertyBuilder);
      when (prop.GetGetter () != null)
        builder.SetGetMethod ((prop.GetGetter ().GetMethodInfo () :> MethodBuilder));
      when (prop.GetSetter () != null)
        builder.SetSetMethod ((prop.GetSetter ().GetMethodInfo () :> MethodBuilder));
    }


    compile_event (prop : IEvent) : void
    {
      def builder = (prop :> NemerleEvent).event_builder;
      builder.SetAddOnMethod ((prop.GetAdder ().GetMethodInfo () :> MethodBuilder));
      builder.SetRemoveOnMethod ((prop.GetRemover ().GetMethodInfo () :> MethodBuilder));
    }


    finalize_aux_types () : void
    {
      unless (Message.seen_error ())
        List.Iter (_aux_types, fun (x : Emit.TypeBuilder) {
          ignore (x.CreateType ())
        });
      _aux_types = [];
    }


    /**
     *
     */
    compile_all_tyinfos (aux_phase : bool) : void
    {
      def allow_it (ti : NC.TypeBuilder) {
        !ti.is_finalized &&
        is_aux_decl (ti) == aux_phase
      };
      def set_type_builder (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("make type builder for " + ti.FullName);
          ti.ConstructTypeBuilder ();
          when (ti.Attributes %&& NemerleAttributes.Macro) {
            def attr = make_string_attribute (SystemType.ContainsMacroAttribute,
                                              ti.GetTypeBuilder ().FullName);
            _assembly_builder.SetCustomAttribute (attr);
          }
        }
      };
      def emit_decls (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("generating declarations " + ti.FullName);
          add_declarations (ti)
        }
      };
      def emit_impl_iface (ti : NC.TypeBuilder) {
        when ((ti.GetTydecl () matches TD_interface) && allow_it (ti)) {
          //Message.debug ("generating code for interface type " + ti.FullName);
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };
      def emit_impl_vt (ti : NC.TypeBuilder) {
        when (ti.IsValueType && allow_it (ti)) {
          //Message.debug ("generating code for value type " + ti.FullName);
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };
      def emit_impl (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("generating code for " + ti.FullName);
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };

      this._emit_nemerle_attributes = !aux_phase;

      when (!aux_phase) _cgil_phase = 1;
      NC.TypeBuilder.Iter (set_type_builder);
      
      when (!aux_phase) _cgil_phase = 2;
      NC.TypeBuilder.Iter (emit_decls);

      //FIXME: need a better ordering of emissions here (bug 158)
      when (!aux_phase) _cgil_phase = 3;
      NC.TypeBuilder.Iter (emit_impl_iface);
      NC.TypeBuilder.Iter (emit_impl_vt);
      NC.TypeBuilder.Iter (emit_impl);

      Message.maybe_bailout ();
      
      when (!aux_phase) _cgil_phase = 4;
      finalize_aux_types ();
    }
    

    internal MemberAdded (ti : NC.TypeBuilder, mem : IMember) : void
    {
      when (_cgil_phase >= 1)
        ti.ConstructTypeBuilder ();

      when (_cgil_phase >= 2)
        add_declaration (ti, mem);

      when (_cgil_phase >= 3)
        match (mem.GetKind ()) {
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod));
          | _ => ()
        };

      when (_cgil_phase >= 4)
        finalize_aux_types ();
    }
    

    /**
     * Check if declaration is auxiliary, used internally etc.
     */
    private is_aux_decl (ti : NC.TypeBuilder) : bool
    {
      def tn = ti.FullName;

      tn.StartsWith ("Nemerle.Internal.") ||
      tn == "Nemerle.Core.NullMatchException"
    }

    
    private make_string_attribute (attr_type : System.Type, value : string) : CustomAttributeBuilder
    {
      def constructor_param_types = array [SystemType.String];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      assert (constructor_info != null);
      def constructor_params = array [(value : object)];
      CustomAttributeBuilder (constructor_info, constructor_params)
    }


    private make_void_attribute (attr_type : System.Type) : CustomAttributeBuilder
    {
      def constructor_info = attr_type.GetConstructor (System.Type.EmptyTypes);
      CustomAttributeBuilder (constructor_info, array [])
    }
    
    
    /**
     * Builds a Nemerle type attribute
     */
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      make_string_attribute (SystemType.TypeAttribute, encoded_type)
    }


    /**
     * Builds a Nemerle variant attribute
     */
    private make_nemerle_variant_attribute (decls : list <Tycon>) : CustomAttributeBuilder
    {
      def names = List.Map (decls, Tyutil.FrameworkTypeName);
      make_string_attribute (SystemType.VariantAttribute,
                             NString.Concat (",", names))
    }
    

    /**
     * Builds a Nemerle type alias
     */
    private make_nemerle_type_alias_attribute (t : Type) : CustomAttributeBuilder
    {
      make_string_attribute (SystemType.TypeAliasAttribute, TyCodec.EncodeType (t))
    }
    

    /**
     * Builds a Nemerle variant option attribute
     */
    private make_nemerle_variant_option_attribute (is_const : bool) : CustomAttributeBuilder
    {
      make_void_attribute (if (is_const) 
                             SystemType.ConstantVariantOptionAttribute
                           else 
                             SystemType.VariantOptionAttribute)
    }


    /**
     * Converts Nemerle property modifiers to the CLI property attributes.
     */
    private make_property_attributes (attrs : NemerleAttributes) : PropertyAttributes
    {
      mutable result = PropertyAttributes.None;
      
      when (attrs %&& NemerleAttributes.SpecialName) result |= PropertyAttributes.SpecialName;

      when (attrs %&& (NemerleAttributes.Mutable %| 
                       NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro))
        Util.ice ("given modifier is not supported for properties");

      result
    }


    /**
     * Converts Nemerle field modifiers to the CLI field attributes.
     */
    private make_field_attributes (attrs : NemerleAttributes) : FieldAttributes
    {
      mutable result = FieldAttributes.PrivateScope;
      
      when (attrs %&& NemerleAttributes.Public) result |= FieldAttributes.Public;
      when (attrs %&& NemerleAttributes.Private) result |= FieldAttributes.Private;
      when (attrs %&& NemerleAttributes.Protected) result |= FieldAttributes.Family;
      when (attrs %&& NemerleAttributes.Internal) result |= FieldAttributes.FamORAssem;
      when (attrs %&& NemerleAttributes.Static) result |= FieldAttributes.Static;
      when (attrs %&& NemerleAttributes.SpecialName) result |= FieldAttributes.SpecialName;
        
      when (attrs %&& (NemerleAttributes.Abstract %|
                       NemerleAttributes.Virtual %|
                       NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro %|
                       NemerleAttributes.Override))
        Util.ice ("given attribute is not supported for fields");
      result
    }


    /**
     * Converts Nemerle method modifiers to the CLI method attributes.
     */
    private make_method_attributes (attrs : NemerleAttributes) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;
      
      when (attrs %&& NemerleAttributes.Public) result |= MethodAttributes.Public;
      when (attrs %&& NemerleAttributes.Private) result |= MethodAttributes.Private;
      when (attrs %&& NemerleAttributes.Protected) result |= MethodAttributes.Family;
      when (attrs %&& NemerleAttributes.Internal) result |= MethodAttributes.FamORAssem;
      when (attrs %&& NemerleAttributes.Static) result |= MethodAttributes.Static;
      when (attrs %&& NemerleAttributes.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;        
      when (attrs %&& NemerleAttributes.New) result |= MethodAttributes.NewSlot;
      when (attrs %&& NemerleAttributes.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;
      when (attrs %&& NemerleAttributes.Virtual) result |= MethodAttributes.Virtual;
      when (attrs %&& NemerleAttributes.Sealed) result |= MethodAttributes.Final;
      when (attrs %&& NemerleAttributes.SpecialName) result |= MethodAttributes.SpecialName;
        
      when (attrs %&& (NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro))
        Util.ice ("given attribute is not supported for methods");
        
      result
    }


    /**
     * Converts Nemerle method modifiers to the Framework type attributes.
     */
    private make_type_attributes (attrs : NemerleAttributes, is_nested : bool) : TypeAttributes
    {
      mutable result = TypeAttributes.AutoLayout;
      when (attrs %&& NemerleAttributes.Public)
        if (is_nested) result |= TypeAttributes.NestedPublic
        else result |= TypeAttributes.Public;
      when (attrs %&& NemerleAttributes.Private)
        if (is_nested) result |= TypeAttributes.NestedPrivate 
        else Message.error ("Private is not allowed for top level types");
      when (attrs %&& NemerleAttributes.Protected)
        if (is_nested) result |= TypeAttributes.NestedFamily 
        else Message.error ("Protected is not allowed for top level types");
      when (attrs %&& NemerleAttributes.Internal && is_nested)
        result |= TypeAttributes.NestedFamORAssem;
      when (attrs %&& NemerleAttributes.Abstract) result |= TypeAttributes.Abstract;
      when (attrs %&& NemerleAttributes.Sealed) result |= TypeAttributes.Sealed;
      when (attrs %&& NemerleAttributes.SpecialName) result |= TypeAttributes.SpecialName;
      when (attrs %&& (NemerleAttributes.New %|
                       NemerleAttributes.Virtual %|
                       NemerleAttributes.Mutable %|                       
                       NemerleAttributes.Override))
        Util.ice ("given attribute is not supported for types");
      result
    }


    /**
     * Converts a System.Type list to a System.Type array.
     * FIXME: array <x> won't work here as the list's length is not know.
     */  
    internal type_list_to_type_array (x : list <System.Type>) : array <System.Type> 
    {
      Nemerle.Utility.NArray.FromList (typeof (System.Type), x)
    }


    /**
     * Reads the inheritance list of a class and retrieves the base
     * type and builds the array of interfaces implemented by the class.
     */
    private determine_inheritance (ti : NC.TypeBuilder) : (System.Type * array <System.Type>)
    {
      def is_interface (t : Tycon) {
        match (t.GetTydecl ()) {
          | TD_interface | TD_alias => true
          | _ => false
        }
      };
      
      match (ti.GetTydecl ()) {
        | TD_enum => (SystemType.Enum, array [])
        | _ => 
          def base_class_type =
            match (ti.GetDirectSuperTypes ()) {
              | T_app (base_class, _) :: _ when !is_interface (base_class) =>
                base_class.GetSystemType ()
              | _ when is_interface (ti) => null
              | _ => SystemType.Object
            };

          def ifaces_types = List.Map (ti.InterfacesToImplement (), 
                                       fun (tc : Tycon) { tc.GetSystemType () });
          
          (base_class_type, type_list_to_type_array (ifaces_types))
      }
    }
  
      
    /**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     */
    public ConstructTypeBuilder (tyinfo : NC.TypeBuilder) : Emit.TypeBuilder
    {      
      /* create optional custom attributes for this type */
      def custom_attribute =
        match (tyinfo.GetTydecl ()) {          
          | TD_variant (decls) => 
            make_nemerle_variant_attribute (decls)
          | TD_variant_option =>
            def has_co_ctor = Option.IsSome (tyinfo.GetConstantObject ());
            make_nemerle_variant_option_attribute (has_co_ctor)
          | TD_alias (t) =>
            make_nemerle_type_alias_attribute (t)
          | _ => null
        };

      /* decide the new type attributes */
      def is_nested = tyinfo.DeclaringType != null;
      mutable is_interface = false;
      
      def type_kind_attrs = 
        match (tyinfo.GetTydecl ()) { 
          | TD_class => TypeAttributes.Class
          | TD_alias // we pretend type alias is an interface
          | TD_interface => 
            is_interface = true;
            TypeAttributes.Interface %| TypeAttributes.Abstract
          | TD_variant => TypeAttributes.Class
          | TD_variant_option => TypeAttributes.Class
          | TD_enum =>
            TypeAttributes.Sealed %| TypeAttributes.Class
        };
        
      def attrs = make_type_attributes (tyinfo.Attributes, is_nested) %| type_kind_attrs;

      /* determine the inheritance relation for this type */
      def (extends_class, implements_interfaces) = determine_inheritance (tyinfo);

      /* create the type builder for a top-level or nested class declaration */
      def new_type_builder = 
        if (!is_nested)
          this._module_builder.DefineType (tyinfo.FullName, attrs, 
                                           extends_class, implements_interfaces)
        else {
          def type_builder = (tyinfo.DeclaringType :> NC.TypeBuilder).GetTypeBuilder ();
          type_builder.DefineNestedType (tyinfo.Name, attrs, extends_class, 
                                         implements_interfaces)
        };

      when (custom_attribute != null && _emit_nemerle_attributes) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      new_type_builder
    }


    /**
     * Adds a an implicit parameterless constructor to a type builder
     */
    internal AddImplicitCtor (tb : Emit.TypeBuilder) : ConstructorBuilder
    {
      def constructor_builder = 
        tb.DefineDefaultConstructor (MethodAttributes.FamORAssem);

      constructor_builder
    }
    

    /**
     * Adds a constructor builder to a type builder
     */
    internal AddConstructorBuilder (cgm : CG_method, tb : Emit.TypeBuilder,
                                    is_delegate_ctor : bool) : void
    {
      // Message.debug ("-- AddConstructorBuilder: " + tb.FullName + "." + cgm.name);

      /* build the parameter types array */      
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.Map (cgm.parms, mkparm);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      mutable skip_it_altogether = false;

      when (is_delegate_ctor) {
        if (cgm.modifiers %&& NemerleAttributes.Public)
          skip_it_altogether = true;
        else
          cgm.modifiers = NemerleAttributes.Public;
      }

      unless (skip_it_altogether) {
        /* create the constructor builder */
        def constructor_builder =
          tb.DefineConstructor (make_method_attributes (cgm.modifiers) %|
                                MethodAttributes.RTSpecialName %| 
                                MethodAttributes.SpecialName,
                                CallingConventions.Standard, parm_types_array);

        /* add the runtime modifiers for delegate constructors */
        when (is_delegate_ctor) {
          constructor_builder.SetImplementationFlags (
            MethodImplAttributes.Runtime %| MethodImplAttributes.Managed
          )
        }
                                
        def name_parms (pos, parms) {
          match (parms) {
            | [] => ()
            | (p : CG_val) :: ps =>
              assert (p.parm_info != null, "parm " + p.name);
              p.parm_info.builder =
                 constructor_builder.DefineParameter 
                       (pos, parameter_attributes (p.parm_info), p.name);
              name_parms (pos + 1, ps)
          }
        };
        name_parms (1, cgm.parms);

        cgm.constructor_builder = constructor_builder;
      }
    }


    /**
     * Emits a constructor's body
     */
    internal EmitConstructor (context : NC.TypeBuilder, cgm : CG_method) : void
    {
      unless (context.IsDelegate) {
        def cb = cgm.constructor_builder;
        assign_parameter_indexes (cb.IsStatic, cgm);

        emit_parameter_attributes (context, cgm);

        CGopt.Optimize (cgm);
      
        /* emit the constructor's body */
        def _ = CodeGenerator (cb, _module_builder, cgm);
        
        ()
      }
    }

    parameter_attributes (pi : CG_parm_info) : ParameterAttributes
    {
      if (pi.parm_kind == ParmKind.Ref)
        ParameterAttributes.None
      else if (pi.parm_kind == ParmKind.Out)
        ParameterAttributes.Out
      else
        ParameterAttributes.None
    }


    /**
     * Adds a method builder to a type builder
     */
    internal AddMethodBuilder (cgm : CG_method, tb : Emit.TypeBuilder, is_delegate_method : bool) : void
    {
      // Message.debug ("-- AddMethodBuilder: " + tb.FullName + "." + cgm.name);
      
      /* build the parameter types array */      
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.Map (cgm.parms, mkparm);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      /* update the modifiers list */
      def modifiers =
        if (cgm.implemented_methods == null) cgm.modifiers
        else
          match (cgm.implemented_methods) {
            | [] => cgm.modifiers
            | _ => NemerleAttributes.Virtual %| cgm.modifiers
          };
          
      def attrs = make_method_attributes (modifiers);
      def attrs =
        if (cgm.name == ".cctor")
          attrs %| MethodAttributes.RTSpecialName %| MethodAttributes.SpecialName
        else
          attrs;
      
      /* add the method to the type builder */
      def method_builder =
        tb.DefineMethod (cgm.name, attrs,
                         cgm.ret_type, parm_types_array);

      /* add the runtime modifiers for delegate methods */
      when (is_delegate_method) {
        method_builder.SetImplementationFlags (
          MethodImplAttributes.Runtime %| MethodImplAttributes.Managed
        )
      }
                         
      def name_parms (pos, parms) {
        match (parms) {
          | [] => ()
          | (p : CG_val) :: ps =>
            p.parm_info.builder =
               method_builder.DefineParameter 
                     (pos, parameter_attributes (p.parm_info), (p : CG_val).name);
            name_parms (pos + 1, ps)
        }
      };
      name_parms (1, cgm.parms);

      cgm.method_builder = method_builder;
    }


    emit_parameter_attributes (context : NC.TypeBuilder, cgm : CG_method) : void
    {
      List.Iter (cgm.parms, fun (v : CG_val) {
        v.parm_info.modifiers.SaveCustomAttributes (context, fun (target, attr) {
          if (target != System.AttributeTargets.Parameter &&
              target != System.AttributeTargets.All)
            Message.error ("only [param:] custom attribute target is allowed here")
          else
            v.parm_info.builder.SetCustomAttribute (attr)
        })
      })
    }


    /**
     * Emits a method's body
     */
    internal EmitMethod (context : NC.TypeBuilder, cgm : CG_method) : void
    {
      unless (context.IsDelegate) {
        def mb = cgm.method_builder;
        assign_parameter_indexes (mb.IsStatic, cgm);

        emit_parameter_attributes (context, cgm);
      
        CGopt.Optimize (cgm);
      
        /* update the entry point settings, if necessary */
        when (_need_entry_point && cgm.name == "Main" && mb.IsStatic) {
          match (_entry_point) {
            | Some =>
              Message.error ("ambiguous match for entry point candidate in type " + 
                             mb.DeclaringType.FullName);
            | None =>
              _entry_point = Some ((mb : MethodInfo))
          }
        };
      
        /* update the overriding relationships */
        def type_builder = (mb.DeclaringType :> Emit.TypeBuilder);
        def method_info = (mb :> MethodInfo);
            
        def update_override (overridden : IMethod) : void {
          def overridden_info = overridden.GetMethodInfo ();
        
          //Message.debug ("override " + method_info.Name + " " + overridden_info.Name + " in " +
          //                type_builder.FullName);
          type_builder.DefineMethodOverride (method_info, overridden_info)
        };
      
        List.Iter (cgm.implemented_methods, update_override);
      
        /* emit the method body */
        def _ = CodeGenerator (mb, _module_builder, cgm);
      
        ()
      }
    }


    /**
     * Adds a method and immediately emits it's body
     */
    internal AddMethod (ctx : NC.TypeBuilder, cgm : CG_method, tb : Emit.TypeBuilder) : void
    {
      AddMethodBuilder (cgm, tb, is_delegate_method = ctx.IsDelegate);
      EmitMethod (ctx, cgm);
    }


    /**
     * Adds a field builder
     */
    internal AddFieldBuilder (field : IField, tb : Emit.TypeBuilder) : FieldBuilder
    {
      def attrs = make_field_attributes (field.Attributes);
      def nemerle_field = (field :> NemerleField);
      def attrs =
        if (nemerle_field.enum_value != null)
          attrs %| FieldAttributes.Literal
        else if (field.Name == "value__" && 
                 (field.DeclaringType.GetTydecl () matches TD_enum))
          attrs %| FieldAttributes.RTSpecialName
        else
          attrs;
      def field_builder = 
        tb.DefineField (field.Name, 
                        CGexpr.cg_type (tb, field.GetMemType ()),
                        attrs);

      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (field));
        field_builder.SetCustomAttribute (attr);
      };

      when (nemerle_field.enum_value != null) {
        //Message.debug ("setting value to " + nemerle_field.enum_value.ToString ());
        field_builder.SetConstant (nemerle_field.enum_value);
      };

      nemerle_field.field_builder = field_builder;
      field_builder
    }

    /**
     * Adds a property builder
     */
    internal AddPropertyBuilder (prop : IProperty, tb : Emit.TypeBuilder) : PropertyBuilder
    {
      def prop = (prop :> NemerleProperty);
      def parms = List.Map (prop.parms, fun (t) { CGexpr.cg_type (tb, t) });
      def parms = type_list_to_type_array (parms);
      def attrs = make_property_attributes (prop.Attributes);
      def ty = CGexpr.cg_type (tb, prop.GetMemType ());
      
      def prop_builder = tb.DefineProperty (prop.Name, attrs, ty, parms);

      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (prop));
        prop_builder.SetCustomAttribute (attr);
      };

      prop.property_builder = prop_builder;
      prop_builder
    }

    /**
     * Adds an event builder
     */
    internal AddEventBuilder (the_event : IEvent, tb : Emit.TypeBuilder) : EventBuilder
    {
      def ty = CGexpr.cg_type (tb, the_event.GetMemType ());
      def event_builder =
        tb.DefineEvent (the_event.Name, EventAttributes.None, ty);

      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (the_event));
        event_builder.SetCustomAttribute (attr);
      };

      (the_event :> NemerleEvent).event_builder = event_builder;
      event_builder
    }

    add_declaration (ti : NC.TypeBuilder, m : IMember) : void
    {
      def type_builder = ti.GetTypeBuilder ();
      match (m.GetKind ()) {
        | MK_field (field) =>
          ignore (AddFieldBuilder (field, type_builder))
          
        | MK_event (ev) =>
          ignore (AddEventBuilder (ev, type_builder))
          
        | MK_property (p) =>
          ignore (AddPropertyBuilder (p, type_builder))
          
        | MK_method (m) when Option.IsSome (m.GetExternName ()) => () // skip extern methods
        
        | MK_method (m) =>
          def attr = 
            if (_emit_nemerle_attributes)
              make_nemerle_type_attr (TyCodec.EncodeMemberType (m))
            else
              null;
          match (m.GetFunKind ()) {
            | FK_ctor =>
              def cgm = CGexpr.GetCgMethod (m);
              AddConstructorBuilder (cgm, type_builder, ti.IsDelegate);
              def builder = cgm.constructor_builder;
              // we don't need our atributes on delegate ctors
              when (!ti.IsDelegate && _emit_nemerle_attributes)
                builder.SetCustomAttribute (attr);
              (m :> NemerleMethod).ctor_builder = builder
            | _ =>
              def cgm = CGexpr.GetCgMethod (m);
              AddMethodBuilder (cgm, type_builder, ti.IsDelegate);
              def builder = cgm.method_builder;
              when (_emit_nemerle_attributes)
                builder.SetCustomAttribute (attr);
              (m :> NemerleMethod).method_builder = builder
          }
          
        | MK_type => () // skip
      }
    }


    /**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     */    
    add_declarations (ti : NC.TypeBuilder) : void
    {    
      def type_builder = ti.GetTypeBuilder ();

      when (_emit_nemerle_attributes) {
        def tyattr = make_nemerle_type_attr (TyCodec.EncodeMemberType (ti));
        type_builder.SetCustomAttribute (tyattr);
      };

      def add_member (m) { add_declaration (ti, m) };
      
      List.Iter (ti.GetDirectMembers (), add_member);

      when (ti.IsDelegate) {
        // a lil' fixup
        match (ti.LookupMember (".ctor")) {
          | [c1 : NemerleMethod, c2 : NemerleMethod] =>
            if (c1.ctor_builder == null)
              c1.ctor_builder = c2.ctor_builder
            else
              c2.ctor_builder = c1.ctor_builder
          | _ => assert (false)
        }
      }
    }


    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    private assign_parameter_indexes (is_static : bool, cgm : CG_method) : void
    {
      def walk_parms (index : int, parms : list <CG_val>) : void {        
        match (parms) {
          | parm :: rest => 
            parm.parm_index = Some (index);
            walk_parms (index + 1, rest)
          | [] => ()
        }
      };
      
      walk_parms (if (is_static) 0 else 1, cgm.parms)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _emit_nemerle_attributes : bool;
    private mutable _need_entry_point : bool;
    private mutable _entry_point : option <MethodInfo>;
    private mutable _output_file_name : string;
    private mutable _aux_types : list <Emit.TypeBuilder>;
    private mutable _cgil_phase : int;
    private static mutable _embedded_resources : list <string * string> = [];
    private static mutable _linked_resources : list <string * string> = [];    
  }



  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  internal class CodeGenerator
  {
    private mutable _cg_method : CG_method;
    private mutable _ilg : ILGenerator;
    private mutable _module_builder : ModuleBuilder;

    private mutable _method_name : string;
    private mutable _method_is_static : bool;
    private mutable _this_is_value_type : bool;
    private mutable _type_of_this : System.Type;
    
    private mutable _method_start_label : Label;


    /**
     * Creates and executes a code generator for a method
     */
    internal this (method_builder : MethodBuilder, module_builder : ModuleBuilder, cg_method : CG_method)
    {
      _cg_method = cg_method;
      
      _ilg = method_builder.GetILGenerator ();
      _module_builder = module_builder;
      
      _method_name = method_builder.DeclaringType.FullName + "::" + method_builder.Name;
      _method_is_static = method_builder.IsStatic;
      _this_is_value_type = method_builder.DeclaringType.IsValueType;
      _type_of_this = method_builder.DeclaringType;
      
      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      unless (emit (_cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }


    /**
     * Creates and executes a code generator for a method
     */
    internal this (constructor_builder : ConstructorBuilder,
                   module_builder : ModuleBuilder, cg_method : CG_method)
    {
      _cg_method = cg_method;
      
      _ilg = constructor_builder.GetILGenerator ();
      _module_builder = module_builder;
      
      _method_name = constructor_builder.DeclaringType.FullName + "::"
                      + constructor_builder.Name;
      _method_is_static = constructor_builder.IsStatic;
      _this_is_value_type = constructor_builder.DeclaringType.IsValueType;
      _type_of_this = constructor_builder.DeclaringType;

      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      // -- HACK HACK HACK REMOVE ME REMOVE ME REMOVE ME HACK HACK HACK -- //
      unless (CodeGenerator.has_base_ctor_call (_cg_method.body) || _method_is_static) {
        def base_type = constructor_builder.DeclaringType.BaseType;
        assert (base_type != null);

        unless (base_type.IsValueType || constructor_builder.DeclaringType.IsValueType) {
//          Message.debug ("Adding base ctor implicit call: " + constructor_builder.DeclaringType.FullName + 
//                         ", base class: " + base_type.FullName);
                         
          def ctors = 
            base_type.GetConstructors (BindingFlags.NonPublic %| BindingFlags.Public %|
                                       BindingFlags.Instance);

          mutable empty_default_ctor = null;
          mutable params_default_ctors = [];
          foreach (ctr : ConstructorInfo in ctors) {
            def parms = ctr.GetParameters ();
            match (parms.Length) {
              | 0 => empty_default_ctor = ctr;
              | 1 =>
                def attrs = parms [0].GetCustomAttributes (SystemType.ParamArrayAttribute, false);
                when (attrs.Length > 0)
                  params_default_ctors = (ctr, parms[0].ParameterType) :: params_default_ctors;
              | _ => ()
            }
          }
                                      
          if (empty_default_ctor != null) {
            _ilg.Emit (OpCodes.Ldarg_0);
            _ilg.Emit (OpCodes.Call, empty_default_ctor)
          }
          else match (params_default_ctors) {
            | [(ctor, ty)] =>
              _ilg.Emit (OpCodes.Ldarg_0);
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Newarr, ty);                      
              _ilg.Emit (OpCodes.Call, ctor);
           
            | (x, _) :: (y, _) :: _ =>
              Message.fatal_error ($"ambiguous implicit call to base constructors `$(x)' and `$(y)' "
                                   "in `" + base_type.FullName + "', please add explicit base(...) call")
            | [] =>
              // FIXME -- this should be detected earlier
              Message.fatal_error ("cannot find default constructor in `" + base_type.FullName + 
                                   "', please add explicit base(...) call")
          }
        };
      }
      
      unless (emit (_cg_method.body))
        _ilg.Emit (OpCodes.Ret);
    }

    /**
     * This method checks if a given expression contains 
     * a call to a class' base constructor.
     */     
    private static has_base_ctor_call (expr : CG_expr) : bool 
    {        
      // -- HACK HACK HACK REMOVE ME REMOVE ME REMOVE ME HACK HACK HACK -- //
      | CE_sequence ([]) => false
      | CE_sequence (body) => List.Exists (body, has_base_ctor_call)
      | CE_tail_call (CE_base_ctor_ref (_), _)
      | CE_call (CE_base_ctor_ref (_), _) => true
      | CE_let (_, expr)
      | CE_cast (expr, _, _) => has_base_ctor_call (expr)
      | _ => false
    }

    private is_always_true (expr : CG_expr) : bool
    {
      match (expr) {
        | CE_literal (L_bool (true)) => true

        | CE_if (cond_expr, then_expr, else_expr) =>
          def cond_always_true = is_always_true (cond_expr);
          def cond_always_false = is_always_false (cond_expr);
          def then_always_true = is_always_true (then_expr);
          def else_always_true = is_always_true (else_expr);
          
          cond_always_true && then_always_true || 
          cond_always_false && else_always_true ||
          then_always_true && else_always_true

        | _ => false
      }
    }


    private is_always_false (expr : CG_expr) : bool
    {
      match (expr) {
        | CE_literal (L_bool (false)) => true

        | CE_if (cond_expr, then_expr, else_expr) =>
          def cond_always_true = is_always_true (cond_expr);
          def cond_always_false = is_always_false (cond_expr);
          def then_always_false = is_always_false (then_expr);
          def else_always_false = is_always_false (else_expr);
          
          cond_always_true && then_always_false || 
          cond_always_false && else_always_false ||
          then_always_false && else_always_false
        
        | _ => false
      }
    }


    /**
     * Check if named operator is defined in the class of the first parameter.
     */
    // FIXME: this shouldn't be needed anymore?
    private can_emit_operator (name : string, parms : list <CG_expr>) : bool
    {
      def parm_type = type_of (List.Head (parms));
      def ns = NString.Split (parm_type.FullName, array ['+', '.']);
      def tc = GlobalEnv.LookupInternalType (ns);
      match (tc.LookupMember (name)) {
        | [symbol] =>
          match (symbol.GetKind ()) {
            | MK_method (_) => true
            | _ => false
          }
        | _ => false
      }
    }
    

    /**
     * Emits an expression.
     */
    private emit (expr : CG_expr) : bool 
    {      
      // Message.debug ("emit: " + pretty_print (expr));

      match (expr) {
      
        /* -- SEQUENCING --------------------------------------------------- */

        /* emits a sequence of expressions */
        | CE_sequence (expr_seq) =>
          def emit_sequence (expr_seq : list <CG_expr>) : bool {
            match (expr_seq) {
              | [] => false
              | expr :: rest =>
                if (emit (expr)) true
                else emit_sequence (rest)
            }
          };

          emit_sequence (expr_seq)


        /* emits a local value definition */
        | CE_let (let_val, let_in) =>
          match (let_val.val) {
            | CE_none =>
              unless (is_system_void (let_val.ty)) {
                def _ = declare_val_local_slot (let_val); ()
              };

              emit (let_in)

            | CE_init_obj (t) =>
              def slot = declare_val_local_slot (let_val);
              _ilg.Emit (OpCodes.Ldloca, slot);
              _ilg.Emit (OpCodes.Initobj, t);

              emit (let_in)

            | _ =>
              if (emit (let_val.val)) true
              else {
                unless (is_system_void (let_val.ty)) {
                  def local_slot = declare_val_local_slot (let_val);
                  _ilg.Emit (OpCodes.Stloc, local_slot)
                };

                emit (let_in)
              }
          };


        /* ignores the results of a computation */
        | CE_ignore (expr) =>
          def cutoff = emit (expr);
          unless (cutoff)
            _ilg.Emit (OpCodes.Pop);            
          cutoff



        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction: special case for comparison ops */
        | CE_if (cond_expr, then_expr, else_expr) when
          is_comparison_opcode_call (cond_expr) =>
          match (cond_expr) {
            | CE_call (CE_opcode (opcode), parms) =>
              if (emit_call_parameters (parms)) true
              else {
                /* NOTE: the opcodes are swapped so that the 'then' expression
                         can be emitted before the 'else' expression */
                def opcode =
                  match (opcode) {
                    | "==" => OpCodes.Bne_Un
                    | "!=" => OpCodes.Beq
                    | "<.s" | "<.f" => OpCodes.Bge
                    | "<.u" => OpCodes.Bge_Un
                    | ">.s" | ">.f" => OpCodes.Ble
                    | ">.u" => OpCodes.Ble_Un
                    | "<=.s" | "<=.f" => OpCodes.Bgt
                    | "<=.u" => OpCodes.Bgt_Un
                    | ">=.s" | ">=.f" => OpCodes.Blt
                    | ">=.u" => OpCodes.Blt_Un
                    | _ => Util.ice ("invalid opcode '" + opcode +
                                     "' in optimized CE_if pattern")
                  };

                def label_condition_else = _ilg.DefineLabel ();
                def label_condition_fi = _ilg.DefineLabel ();

                _ilg.Emit (opcode, label_condition_else);
                
                def cutoff_then = emit (then_expr);
                unless (cutoff_then) { _ilg.Emit (OpCodes.Br, label_condition_fi) };

                _ilg.MarkLabel (label_condition_else);
                def cutoff_else = emit (else_expr);

                _ilg.MarkLabel (label_condition_fi);
                cutoff_then && cutoff_else
              }
                            
            | _ => Util.ice ("invalid instruction in optimized CE_if pattern: "
                             + pretty_print (expr))
          }

        /* emits the if/then/else construction, special case for constants */
        | CE_if (cond_expr, then_expr, _) when is_always_true (cond_expr) =>
          emit (then_expr)
          
        /* emits the if/then/else construction, special case for constants */
        | CE_if (cond_expr, _, else_expr) when is_always_false (cond_expr) =>
          emit (else_expr)

        /* emits the if/then/else construction */
        | CE_if (cond_expr, then_expr, else_expr) =>
          if (emit (cond_expr)) true
          else {
            def label_condition_else = _ilg.DefineLabel ();
            def label_condition_fi = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Brfalse, label_condition_else);
            
            def cutoff_then = emit (then_expr);
            unless (cutoff_then) { _ilg.Emit (OpCodes.Br, label_condition_fi) };

            _ilg.MarkLabel (label_condition_else);
            def cutoff_else = emit (else_expr);

            _ilg.MarkLabel (label_condition_fi);
            cutoff_then && cutoff_else
          }


        /* emit a type check construction */
        | CE_has_type (expr, ty) =>
          if (emit (expr)) true
          else {
            def label_condition_not_null = _ilg.DefineLabel ();
            def label_condition_has_type = _ilg.DefineLabel ();
            def label_condition_continue = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Dup);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);
            
            _ilg.ThrowException (SystemType.NullMatchException);

            _ilg.MarkLabel (label_condition_not_null);

            _ilg.Emit (OpCodes.Isinst, ty);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Br_S, label_condition_continue);
            _ilg.MarkLabel (label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.MarkLabel (label_condition_continue);
            false
          }


        /* emit a nullness check construction */
        | CE_not_null (expr) =>
          if (emit (expr)) true
          else {
            def label_condition_not_null = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);
            
            _ilg.ThrowException (SystemType.NullMatchException);

            _ilg.MarkLabel (label_condition_not_null);
            false
          }


        /* load runtime representation of given type */
        | CE_typeof (t) =>
          _ilg.Emit (OpCodes.Ldtoken, t);
          _ilg.Emit (OpCodes.Call, SystemType.Type_GetTypeFromHandle);
          false

  
        /* emits the CE_switch instruction */
        | CE_switch (indexing_expr, default_expr, cases) =>
          match (cases) {
            | [] => 
              Message.warning ("empty CE_switch instruction");
              false
            | _ => 
              if (emit (indexing_expr)) true
              else emit_switch (default_expr, cases)
          }


        /* insert label so CE_continue_loop can work */
        | (CE_loop (expr, _)) as loop =>
          def label = _ilg.DefineLabel ();
          loop.label = Some (label);
          _ilg.MarkLabel (label);
          emit (expr)
          

        /* branch to loop beginning. */
        | CE_continue_loop (which) =>
          _ilg.Emit (OpCodes.Br, Option.UnSome (which.label));
          true


        /* -- TYPE CONVERSIONS --------------------------------------------- */

        /* do not perform casts between same types */
        | CE_cast (expr, cast_to_type, _) when type_eq (type_of (expr), cast_to_type) =>
          emit (expr)

        
        /* special case casts from void */
        | CE_cast (expr, cast_to_type, _) when is_system_void (type_of (expr)) && 
                                               !cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            _ilg.Emit (OpCodes.Ldnull);
            false
          }
          
        
        /* box value types casted to non value types */
        | CE_cast (expr, cast_to_type, _) when type_of (expr).IsValueType
          && ! cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            _ilg.Emit (OpCodes.Box, type_of (expr));
            false            
          }


        /* unbox value types or perform value type conversion */          
        | CE_cast (expr, cast_to_type, is_checked) when cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            def type_of_expr = type_of (expr);

            if (type_of_expr.IsValueType) {
              /* perform conversion of value types */
              emit_value_type_conversion (type_of_expr, cast_to_type, is_checked)
            }
            else if (is_system_object (type_of_expr) || type_of_expr.IsInterface) {
              /* unboxing returns a pointer to a value */
              _ilg.Emit (OpCodes.Unbox, cast_to_type);

              when ((expr matches CE_volatile_field_ref) ||
                    (expr matches CE_volatile_global_ref))
                _ilg.Emit (OpCodes.Volatile);
                    
              emit_ldind_for_value_type (cast_to_type)
            }
            else {
              Util.ice (_method_name + ": failed to convert non-value type "
                        + type_of_expr.FullName + " to a value type "
                        + cast_to_type.FullName)
            };
            
            false
          }
          

        /* upcast / downcast non-value types */
        | CE_cast (expr, cast_to_type, _) =>
          if (emit (expr)) true
          else {
            /* upcasting / downcasting */
            _ilg.Emit (OpCodes.Castclass, cast_to_type);
            false
          }



        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | CE_ref (decl) =>
          emit_ce_ref (decl, get_address_for_value_types = false)

        /* load the value of a field */
        | CE_field_ref (base_object, field) =>
          if (emit (base_object)) true
          else {
            _ilg.Emit (OpCodes.Ldfld, field);
            false
          }

        /* load the value of a volatile field */
        | CE_volatile_field_ref (base_object, field) =>
          if (emit (base_object)) true
          else {
            _ilg.Emit (OpCodes.Volatile);
            _ilg.Emit (OpCodes.Ldfld, field);
            false
          }

        /* load the value of a static field */
        | CE_global_ref (mi) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");
            
          if (field_info.IsLiteral) {
            // should not happen
            Message.warning ("loading literal as field `" + field_info.ToString () + "'");
          }
          else {
            _ilg.Emit (OpCodes.Ldsfld, field_info);
          }
          false
          
        /* load the value of a volatile static field */
        | CE_volatile_global_ref (mi) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "CE_volatile_global_ref to a non-static field");
            
          if (field_info.IsLiteral) {
            // should not happen
            Message.warning ("loading literal as field `" + field_info.ToString () + "'")
          }
          else {
            _ilg.Emit (OpCodes.Volatile);
            _ilg.Emit (OpCodes.Ldsfld, field_info)
          }
          false

        /* load an array element */
        | CE_array_indexer (array_obj, [index]) =>
          if (emit (array_obj)) true
          else {          
            if (emit (index)) true
            else {
              def element_type = type_of (array_obj).GetElementType ();
              assert (element_type != null, "non-array in CE_array_indexer");
              
              emit_array_load_opcode (element_type);
              false
            }
          }

        | CE_array_indexer (array_obj, indexes) =>
          if (emit (array_obj)) true
          else if (List.FoldLeft (indexes, false, 
                                  fun (idx, b)
                                  {
                                    if (b) true
                                    else emit (idx)
                                  })) true
          else {
            def method = array_get_method (array_obj);
            emit_method_call (expr, true, method);
          }

        /* -- ASSIGNMENTS -------------------------------------------------- */

        /* FIXME */
        | CE_assign (CE_cast (expr, _, _), val) =>
          Message.debug ("FIXME: warning, working around the CE_cast () = val bug");
          emit (CE_assign (expr, val))


        /* assignment to a local variable */
        | CE_assign (CE_ref (local_var), val) =>
          match (local_var.local_slot) {
            | Some (local_slot) =>
              if (emit (val)) true
              else {
                _ilg.Emit (OpCodes.Stloc, local_slot);
                false
              }
            | _ when is_system_void (type_of (val)) =>
              // simply skip assignment here
              emit (val)
            | _ =>
              Util.ice (_method_name + ": null local slot in CE_assign (CE_ref + "
                        + local_var.name + ")")
          };


        /* assignment to ref/out parameter */
        | CE_assign (CE_indirect (CE_ref ({ parm_index = Some (parm_index) })), val) =>
          emit_ldarg (parm_index);
          if (emit (val)) true
          else {
            def ty = type_of (val);
            if (ty.IsValueType)
              _ilg.Emit (OpCodes.Stobj, ty)
            else
              _ilg.Emit (OpCodes.Stind_Ref);
            false
          }

          
        /* assignment to a field of a value type based on a local declaration */
        | CE_assign (CE_field_ref (CE_ref (decl), field), val) when field.DeclaringType.IsValueType =>
          if (emit_ce_ref (decl, get_address_for_value_types = true)) true
          else if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stfld, field);
            false
          }

          
        /* assignment to a field */
        | CE_assign (CE_field_ref (base_object, field), val) =>
          if (emit (base_object)) true
          else if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stfld, field);
            false
          }

          
        /* assignment to a volatile field */
        | CE_assign (CE_volatile_field_ref (base_object, field), val) =>
          if (emit (base_object)) true
          else if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Volatile);
            _ilg.Emit (OpCodes.Stfld, field);
            false
          }

          
        /* assignment to a static field */
        | CE_assign (CE_global_ref (mi), val) when member_is_field (mi) =>
          if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stsfld, (mi :> FieldInfo));
            false
          }

        /* assignment to a static volatile field */
        | CE_assign (CE_volatile_global_ref (mi), val) when member_is_field (mi) =>
          if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Volatile);
            _ilg.Emit (OpCodes.Stsfld, (mi :> FieldInfo));
            false
          }

          
        /* assignment to an array element */
        | CE_assign (CE_array_indexer (array_obj, [index]), val) =>
          def type_of_val = type_of (val);
          
          if (emit (array_obj)) true
          else if (emit (index)) true
          else {
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);
          
            if (emit (val)) true
            else {
              emit_array_store_opcode (type_of_val);
              false
            }
          }

        | CE_assign (CE_array_indexer (array_obj, indexes), val) =>
          if (emit (array_obj)) true
          else if (List.FoldLeft (indexes, false, 
                                  fun (idx, b)
                                  {
                                    if (b) true
                                    else emit (idx)
                                  })) true
          else {
            if (emit (val)) true
            else {
              def method = array_set_method (array_obj);
              emit_method_call (expr, true, method);
            }
          }

        | CE_multiple_assign (assigns) =>
          def emit_values (lst) {
            | (_, v) :: xs =>
              if (emit (v)) {
                Message.warning ("argument broke control flow");
                true
              } else
                emit_values (xs)
            | [] => false
          };
          def emit_store (local_var : CG_val, _) {
            match (local_var.local_slot) {
              | Some (local_slot) =>
                _ilg.Emit (OpCodes.Stloc, local_slot);
              | _ =>
                Util.ice (_method_name + ": null local slot in CE_multiple_assign")
            }
          };
          if (emit_values (assigns))
            true
          else {
            List.Iter (List.Rev (assigns), emit_store);
            false
          }
            


        /* -- CALLS -------------------------------------------------------- */

        /* call the base constructor */
        | CE_tail_call (CE_base_ctor_ref (base_ctor), ctor_params)
        | CE_call (CE_base_ctor_ref (base_ctor), ctor_params) =>          
          _ilg.Emit (OpCodes.Ldarg_0);

          if (emit_call_parameters (ctor_params)) true
          else {
            _ilg.Emit (OpCodes.Call, base_ctor);
            false
          }


        /* create a new object */
        | CE_tail_call (CE_ctor_ref (ctor), ctor_params)
        | CE_call (CE_ctor_ref (ctor), ctor_params) =>
          if (emit_call_parameters (ctor_params)) true
          else {            
            _ilg.Emit (OpCodes.Newobj, ctor);
            false
          }


        /* emit a call to an instance method, basing on the 'this' pointer for value types */
        | CE_tail_call (CE_method_ref (CE_this, method, _), method_params)
                                                      when _this_is_value_type
        | CE_call (CE_method_ref (CE_this, method, _), method_params)
                                                      when _this_is_value_type =>
          _ilg.Emit (OpCodes.Ldarg_0);
          _ilg.Emit (OpCodes.Ldobj, _type_of_this);
          _ilg.Emit (OpCodes.Box, _type_of_this);
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, true, method)

          
        /* emit a call to an instance method, basing on an instance field's contents */
        | CE_tail_call (CE_method_ref (CE_field_ref (base_object, field),
                                       method, notvirtual), method_params)
        | CE_call (CE_method_ref (CE_field_ref (base_object, field), method, notvirtual),
                   method_params) => 
          if (emit (base_object)) true
          else {
            def base_is_value_type = field.FieldType.IsValueType;
              
            if (base_is_value_type)
              _ilg.Emit (OpCodes.Ldflda, field)
            else
              _ilg.Emit (OpCodes.Ldfld, field);

            if (emit_call_parameters (method_params)) true
            else
              emit_method_call (expr, base_is_value_type  || notvirtual, method)
          }


        /* emit a call to an instance method, basing on a static field's contents */
        | CE_tail_call (CE_method_ref (CE_global_ref (mi), method, notvirt),
                        method_params) when member_is_field (mi)
        | CE_call (CE_method_ref (CE_global_ref (mi), method, notvirt),
                   method_params) when member_is_field (mi) => 
          def field_info = (mi :> FieldInfo);          

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");
                    
          def base_is_value_type = field_info.FieldType.IsValueType;
              
          if (base_is_value_type)
            _ilg.Emit (OpCodes.Ldsflda, field_info)
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, base_is_value_type || notvirt, method);



        /* emit a call to an instance method, basing on a local variable */
        | CE_tail_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method, notvirt), method_params)
        | CE_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method, notvirt), method_params) =>
          def base_is_value_type = decl.ty.IsValueType;
          
          if (base_is_value_type) {
            match (decl.local_slot) {
              | Some (local_slot) => _ilg.Emit (OpCodes.Ldloca, local_slot)
              | _ => 
                match (decl.parm_index) {
                  | Some (parm_index) => emit_ldarga (parm_index)
                  | _ => Util.ice (_method_name +
                                   ": null local slot or no parameter index " +
                                   "in CE_call (CE_method_ref (CE_ref + " +
                                   decl.name + "))")
                }
            }
          }
          else {
            def _ = emit (decl_ref); ()
          };
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, base_is_value_type || notvirt, method)


        /* emit a call to an instance method */
        | CE_tail_call (CE_method_ref (base_object, method, notvirt), method_params)
        | CE_call (CE_method_ref (base_object, method, notvirt), method_params) => 
          if (emit (base_object)) true
          else {
            def is_value_type = type_of (base_object).IsValueType;
            when (is_value_type) {
              def local_slot = _ilg.DeclareLocal (type_of (base_object));
              _ilg.Emit (OpCodes.Stloc, local_slot);
              _ilg.Emit (OpCodes.Ldloca, local_slot);
            };
            if (emit_call_parameters (method_params)) true
            else
              emit_method_call (expr, is_value_type || notvirt, method)
          }


        /* emit a call to a static method */
        | CE_tail_call (CE_global_ref (mi), method_parms) when member_is_method (mi)
        | CE_call (CE_global_ref (mi), method_parms) when member_is_method (mi) =>
          def method_info = (mi :> MethodInfo);

          assert (method_info.IsStatic, "CE_call CE_global_ref to a non-static field");
                              
          if (emit_call_parameters (method_parms)) true
          else
            emit_method_call (expr, true, method_info)


        /* emit an operator */
        | CE_tail_call (CE_opcode (opcode), parms)
        | CE_call (CE_opcode (opcode), parms) =>
          if (emit_call_parameters (parms)) true
          else {
            match (opcode) {
              // FIXME: handle the overloaded operators properly
              //        (see == and != for System.String)
              | "+.s" =>  _ilg.Emit (OpCodes.Add_Ovf)
              | "+.u" => _ilg.Emit (OpCodes.Add_Ovf_Un)
              | "+.f" =>  _ilg.Emit (OpCodes.Add)
              
              | "<<.s" | "<<.u" =>  _ilg.Emit (OpCodes.Shl)
              | ">>.s" =>  _ilg.Emit (OpCodes.Shr)
              | ">>.u" =>  _ilg.Emit (OpCodes.Shr_Un)
              
              | "unary.+.s" | "unary.+.u" | "unary.+.f" => ()

              | "-.s" =>  _ilg.Emit (OpCodes.Sub_Ovf)
              | "-.u" => _ilg.Emit (OpCodes.Sub_Ovf_Un)
              | "-.f" =>  _ilg.Emit (OpCodes.Sub)
              
              | "unary.-.s" =>
                _ilg.Emit (OpCodes.Ldc_I4_M1);
                emit_value_type_conversion (SystemType.Int32,
                                            type_of (List.Hd (parms)), true);
                _ilg.Emit (OpCodes.Mul_Ovf)
              | "unary.-.f" =>
                _ilg.Emit (OpCodes.Neg)

              | "unary.~.u"
              | "unary.~.s" =>
                _ilg.Emit (OpCodes.Not);

              | "unary.~.f" =>
                def type_of_parm = type_of (List.Head (parms));
                when (type_of_parm.FullName == "System.Single" ||
                      type_of_parm.FullName == "System.Double" ||
                      type_of_parm.FullName == "System.Decimal")
                  Util.ice ("float, double or decimal as an argument for binary negation in CGIL");
                _ilg.Emit (OpCodes.Not);
                
              | "*.s" =>  _ilg.Emit (OpCodes.Mul_Ovf)
              | "*.u" => _ilg.Emit (OpCodes.Mul_Ovf_Un)
              | "*.f" =>  _ilg.Emit (OpCodes.Mul)
              
              | "/.s" | "/.f" =>  _ilg.Emit (OpCodes.Div)
              | "/.u" => _ilg.Emit (OpCodes.Div_Un)
              | "%.s" | "%.f" =>  _ilg.Emit (OpCodes.Rem)
              | "%.u" => _ilg.Emit (OpCodes.Rem_Un)
              
              | "|.s" | "|.u" => _ilg.Emit (OpCodes.Or);
              | "&.s" | "&.u" => _ilg.Emit (OpCodes.And);
              | "^.s" | "^.u" => _ilg.Emit (OpCodes.Xor);
              | "bool.!" =>
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq)
              | "==" =>
                _ilg.Emit (OpCodes.Ceq);
              | "!=" => 
                _ilg.Emit (OpCodes.Ceq);
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq);
              | "<.s" | "<.f" => emit_compare (OpCodes.Blt_S)
              | "<.u" => emit_compare (OpCodes.Blt_Un_S)
              | ">.s" | ">.f" => emit_compare (OpCodes.Bgt_S)
              | ">.u" => emit_compare (OpCodes.Bgt_Un_S)
              | "<=.s" | "<=.f" => emit_compare (OpCodes.Ble_S)
              | "<=.u" => emit_compare (OpCodes.Ble_Un_S)
              | ">=.s" | ">=.f" => emit_compare (OpCodes.Bge_S)
              | ">=.u" => emit_compare (OpCodes.Bge_Un_S)
              | _ =>
                Util.ice (_method_name + ": unmatched CE_opcode (" + opcode + ")")
            };
            false
          }

        /* emit self tail call -- that is jump to method start */
        | CE_self_tail_call (method_params) =>
          if (emit_call_parameters (method_params)) true
          else {
            def store_argument (cgv : CG_val) {
              match (cgv.parm_index) {
                | Some (index) =>
                  if (index < 256)
                    _ilg.Emit (OpCodes.Starg_S, (index :> System.Byte))
                  else
                    _ilg.Emit (OpCodes.Starg, index);
                | None => Util.ice ()
              }
            };
            List.Iter (List.Rev (_cg_method.parms), store_argument);
            _ilg.Emit (OpCodes.Br, _method_start_label);
            true
          }


        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | CE_raise (exc) =>
          if (emit (exc)) true
          else {
            _ilg.Emit (OpCodes.Throw);
            true
          }


        /* emit the try/with construction */
        | CE_try_with (try_expr, catch_val, catch_expr) =>
          def type_of_try_expr = type_of (expr);
               
          def ignore_try_with_result = is_system_void (type_of_try_expr);
          mutable try_result = null;
                             
          unless (ignore_try_with_result)
            try_result = _ilg.DeclareLocal (type_of_try_expr);

          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff_on_try = emit (try_expr);
          
          unless (cutoff_on_try || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);
          
          _ilg.BeginCatchBlock (catch_val.ty);

          def catch_val_local_slot = declare_val_local_slot (catch_val);
          _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);
          
          def cutoff_on_catch = emit (catch_expr);
          
          unless (cutoff_on_catch || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);
                    
          _ilg.EndExceptionBlock ();
          
          def cutoff = cutoff_on_try && cutoff_on_catch;
          
          unless (cutoff || ignore_try_with_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        // FIXME: how does finally work? what about storing it's result in
        //        try_result as in CE_try_with?
        | CE_try_finally (try_expr, finally_expr) =>
          def type_of_try_expr = type_of (try_expr);

          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff = emit (try_expr);

          def ignore_try_result = cutoff || is_system_void (type_of_try_expr);
          mutable try_result = null;

          unless (ignore_try_result) {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          def _ = emit (finally_expr);

          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | CE_this =>
          assert (!_method_is_static, "CE_this is a static method");

          _ilg.Emit (OpCodes.Ldarg_0);
          false


        /* loads a literal on the evaluation stack */
        | CE_literal (l) =>
          emit_literal (l);
          false


        /* loads address of given method */
        | CE_method_addr (meth) =>
          _ilg.Emit (OpCodes.Ldftn, meth);
          false


        /* creates object of value type using implicit ctor */
        | CE_init_obj (t) =>
          def local_slot = _ilg.DeclareLocal (t);
          _ilg.Emit (OpCodes.Ldloca, local_slot);
          _ilg.Emit (OpCodes.Initobj, t);
          _ilg.Emit (OpCodes.Ldloc, local_slot);
          false
          

        /* special case these assignments for performance */
        | CE_assign (CE_ref (decl), CE_init_obj (t)) =>
          if (emit_ce_ref (decl, get_address_for_value_types = true)) true
          else {
            _ilg.Emit (OpCodes.Initobj, t);
            false
          }
          

        /* creates a new array, given a list of initializers */
        | CE_mkarray (element_type, initializers, [size]) =>
          def local_slot = _ilg.DeclareLocal (type_of (expr));
                    
          _ilg.Emit (OpCodes.Ldc_I4, size);
          _ilg.Emit (OpCodes.Newarr, element_type);

          _ilg.Emit (OpCodes.Stloc, local_slot);

          def load_elements (index : int, elements : list <CG_expr>) : bool {
            match (elements) {
              | [] => false
              | element :: rest =>
                _ilg.Emit (OpCodes.Ldloc, local_slot);
                _ilg.Emit (OpCodes.Ldc_I4, index);
                
                when (element_type.IsValueType && !element_type.IsPrimitive)
                  _ilg.Emit (OpCodes.Ldelema, element_type);
                  
                if (emit (element)) true
                else {
                  emit_array_store_opcode (element_type);
                  load_elements (index + 1, rest)
                }
            }
          };

          def cutoff = load_elements (0, initializers);          
          unless (cutoff) _ilg.Emit (OpCodes.Ldloc, local_slot);          
          cutoff

        | CE_mkarray (element_type, initializers, dimensions) =>
          def local_slot_dimensions = _ilg.DeclareLocal (typeof (array <System.Int32>));
          def local_slot_array = _ilg.DeclareLocal (type_of (expr));
                    
          _ilg.Emit (OpCodes.Ldc_I4, List.Length (dimensions));
          _ilg.Emit (OpCodes.Newarr, typeof (System.Int32));
          _ilg.Emit (OpCodes.Stloc, local_slot_dimensions);

          def load_dimensions (index : int, dimensions : list <int>) {
            match (dimensions) {
              | [] => ()
              | element :: rest =>
                _ilg.Emit (OpCodes.Ldloc, local_slot_dimensions);
                _ilg.Emit (OpCodes.Ldc_I4, index);

                emit_literal (L_int (element));
                _ilg.Emit (OpCodes.Stelem_I4);
                load_dimensions (index + 1, rest)
            }
          }

          load_dimensions (0, dimensions);
          _ilg.Emit (OpCodes.Ldtoken, element_type);
          _ilg.Emit (OpCodes.Call, SystemType.Type_GetTypeFromHandle);
          _ilg.Emit (OpCodes.Ldloc, local_slot_dimensions);
          
          def method =
            SystemType.Array.GetMethod ("CreateInstance", array [SystemType.Type,
                                                                  typeof (array <int>)]);

          _ilg.Emit (OpCodes.Call, method);
          _ilg.Emit (OpCodes.Stloc, local_slot_array);

          def method = array_set_method (type_of (expr));
          
          def dimensions_array = array (dimensions.Length ());
          mutable i = 0;
          List.Iter (dimensions, fun (it) { dimensions_array [i] = it; ++i});

          def load_elements (index : array <int>, elements : list <CG_expr>) : bool {
            match (elements) {
              | [] => false
              | element :: rest =>
                _ilg.Emit (OpCodes.Ldloc, local_slot_array);
                for (mutable j = 0; j < index.Length; ++j)
                  emit_literal (L_int (index [j]));
                if (emit (element)) true
                else {
                  def next (index : array <int>)
                  {
                    ++index [index.Length - 1];
                    for (mutable j = index.Length - 1; index [j] == dimensions_array [j] && j > 0; --j)
                    {
                      index [j] = 0;
                      ++index [j - 1];
                    }
                    index
                  }
                  if (emit_method_call (expr, true, method)) true
                  else load_elements (next (index), rest)
                }
            }
          }

          def cutoff = load_elements (array (dimensions_array.Length), initializers);
          unless (cutoff) _ilg.Emit (OpCodes.Ldloc, local_slot_array);          
          cutoff


        /* takes address of a value */
        | CE_addr (CE_indirect (expr)) =>
          emit (expr)

        | CE_indirect (CE_addr (expr)) =>
          emit (expr)

        | CE_addr (CE_ref ({ local_slot = Some (local_slot) })) =>
          _ilg.Emit (OpCodes.Ldloca, local_slot);
          false

        | CE_addr (CE_ref ({ parm_index = Some (parm_index) })) =>
          emit_ldarga (parm_index);
          false

        | CE_addr (CE_global_ref (mi)) =>
          def field_info = (mi :> FieldInfo);          
          assert (field_info.IsStatic, "CE_addr to a non-static field");
          _ilg.Emit (OpCodes.Ldsflda, field_info);
          false

        | CE_addr (CE_volatile_global_ref (mi)) =>
          def field_info = (mi :> FieldInfo);          
          assert (field_info.IsStatic, "CE_addr to a non-static field");
          _ilg.Emit (OpCodes.Volatile);
          _ilg.Emit (OpCodes.Ldsflda, field_info);
          false
          
        | CE_addr (CE_field_ref (obj, field_info)) =>
          if (emit (obj)) true
          else {
            _ilg.Emit (OpCodes.Ldflda, field_info);
            false
          }

        | CE_addr (CE_volatile_field_ref (obj, field_info)) =>
          if (emit (obj)) true
          else {
            _ilg.Emit (OpCodes.Volatile);
            _ilg.Emit (OpCodes.Ldflda, field_info);
            false
          }
          
        | CE_addr (CE_array_indexer (array_obj, [index])) =>
          if (emit (array_obj)) true
          else {          
            if (emit (index)) true
            else {
              def element_type = type_of (array_obj).GetElementType ();
              assert (element_type != null, "non-array in CE_addr(array_indexer)");
              _ilg.Emit (OpCodes.Ldelema, element_type);
              false
            }
          }
          
        | CE_addr (CE_array_indexer (array_obj, indexes)) =>
          if (emit (array_obj)) true
          else if (List.FoldLeft (indexes, false, 
                                  fun (idx, b)
                                  {
                                    if (b) true
                                    else emit (idx)
                                  })) true
          else {
            def method = array_addr_method (array_obj);
            emit_method_call (expr, true, method);
          }

        /* load value by pointer */
        | CE_indirect (expr) =>
          if (emit (expr)) true
          else {
            def ty = type_of (expr);
            def el_ty = ty.GetElementType ();
            assert (ty.IsByRef && el_ty != null);

            when ((expr matches CE_volatile_field_ref) ||
                  (expr matches CE_volatile_global_ref))
              _ilg.Emit (OpCodes.Volatile);
              
            if (el_ty.IsValueType)
              emit_ldind_for_value_type (el_ty)
            else
              _ilg.Emit (OpCodes.Ldind_Ref);
            false
          }
          
          
        
        /* an interrupting NOP instruction */
        | CE_none => false

        | _ =>
          Message.warning ("FIXME: unmatched: " + pretty_print (expr));
          false
      }
    }

    private array_set_method (t : System.Type) : MethodInfo
    {
        def rank = t.GetArrayRank ();

        def args = array (rank + 1);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }
        args [rank] = t.GetElementType ();

        _module_builder.GetArrayMethod (t, "Set",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        typeof (void), args);
    }

    
    /*
     * Emits a local reference instruction
     */
    private emit_ce_ref (decl : CG_val, get_address_for_value_types : bool) : bool
    {
      match (decl.local_slot) {
        | Some (local_slot) =>
          // local values
          if (get_address_for_value_types)
            _ilg.Emit (OpCodes.Ldloca, local_slot)
          else
            _ilg.Emit (OpCodes.Ldloc, local_slot)
            
        | _ =>
          // method parameters
          match (decl.parm_index) {
            | Some (parm_index) =>
              if (get_address_for_value_types)
                emit_ldarga (parm_index)
              else
                emit_ldarg (parm_index)
            | _ when is_system_void (decl.ty) => ()
            | _ =>
              Util.ice (_method_name + ": parameter index / variable local"
                        " slot undefined in CE_ref " + decl.name)
          }
      }

      false
    }
    

    private array_set_method (arr : CG_expr) : MethodInfo
    {
        array_set_method (type_of (arr));
    }

    private array_get_method (arr : CG_expr) : MethodInfo
    {
        def t = type_of (arr);
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }

        _module_builder.GetArrayMethod (t, "Get",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        t.GetElementType (), args);
    }

    private array_addr_method (arr : CG_expr) : MethodInfo
    {
        def t = type_of (arr);
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }

        def ret = _module_builder.GetArrayMethod (t, "Address",
                                                  CallingConventions.HasThis %| CallingConventions.Standard,
                                                  t.GetElementType (), args);
        ret
    }
    
    /**
     * Emits the CE_switch instruction
     * 
     * Asserts that the smallest of the case indices is positive. Quietly 
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never 
     * generate too long switch instructions -- assuring this should belong 
     * to a higher level logic.
     */
    private emit_switch (default_expr : option <CG_expr>, 
                         cases : list <int * CG_expr>) : bool
    { 
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr) {
          | Some => label_default
          | None => label_next_instruction
        };
               
      // step one: sort the cases increasingly
      def compare_cases (l : int * CG_expr, r : int * CG_expr) : int {
        def (l, _) = l; def (r, _) = r; l - r
      };
      
      def cases = List.Sort (cases, compare_cases);
      def (first_index, _) = List.Head (cases);

      // step two: rescale, so that the first label has value zero
      when (first_index != 0) {
        // NOTE: see the assumptions in the method description
        emit_literal (L_int (first_index));
        _ilg.Emit (OpCodes.Sub_Ovf)
      };

      // step three: generate the jump labels for the switch cases      
      mutable reversed_labels = [];
      
      def make_labels (index : int, cases : list <int * CG_expr>) 
                                        : list <Label * CG_expr> {
        match (cases) {
          | (case_index, case_expr) :: rest =>
            assert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;
            
              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)            
            }            
          | [] => []
        }
      };
            
      def labeled_cases = make_labels (first_index, cases);
      def labels = List.Rev (reversed_labels);

      def labels_array = label_list_to_array (labels);
     
      // step four: emit the switch instruction and the default expression
      mutable switch_cutoff = true;
                        
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr) {
        | Some (default_expr) =>
          unless (emit (default_expr)) {
            _ilg.Emit (OpCodes.Br, label_next_instruction);
            switch_cutoff = false
          }
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
          switch_cutoff = false
      };

      // step five: emit the switch cases
      def walk_cases (cases : list <Label * CG_expr>) : void {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          unless (emit (expr)) {
            switch_cutoff = false;
            _ilg.Emit (OpCodes.Br, label_next_instruction)
          };
          walk_cases (rest)
        | [] => ()
      };

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      unless (switch_cutoff)
        _ilg.MarkLabel (label_next_instruction);
      switch_cutoff
    }
     

    /**
     * Check if a given expression is a call to an opcode
     */
    private is_comparison_opcode_call (expr : CG_expr) : bool
    {
      def is_comparison_opcode (opcode : string) : bool {
        | ">.s" | ">.f" | ">.u"
        | "<.s" | "<.f" | "<.u"
        | ">=.s" | ">=.f" | ">=.u"
        | "<=.s" | "<=.f" | "<=.u" => true
        | _ => false
      };
      match (expr) {
        | CE_call (CE_opcode ("=="), parms) 
          when !can_emit_operator ("op_Equality", parms) => true
        | CE_call (CE_opcode ("!="), parms) 
          when !can_emit_operator ("op_Inequality", parms) => true
        | CE_call (CE_opcode (opcode), _)
          when is_comparison_opcode (opcode) => true
        | _ => false
      }      
    }


    /**
     * Checks two types for equality
     */
    private type_eq (l : System.Type, r : System.Type) : bool
    {
      l.Equals (r)
    }


    /**
     * Checks if a type is the System.Object type
     */
    private is_system_object (ty : System.Type) : bool
    {
      SystemType.Object.Equals (ty)
    }


    /**
     * Checks if a type is the System.Void type
     */
    private is_system_void (ty : System.Type) : bool
    {
      SystemType.Void.Equals (ty)
    }


    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (index : int) : void
    {
      | 0 => _ilg.Emit (OpCodes.Ldarg_0)
      | 1 => _ilg.Emit (OpCodes.Ldarg_1)
      | 2 => _ilg.Emit (OpCodes.Ldarg_2)
      | 3 => _ilg.Emit (OpCodes.Ldarg_3)
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarg, index)
    }


    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (index : int) : void
    {
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarga, index)
    }


    /**
     * Performs value type conversion form l to r
     */
    private emit_value_type_conversion (l : System.Type, r : System.Type,
                                        is_checked : bool) : void
    {
      def is_unsigned (t : System.Type) {
        match (t.Name [0]) {
          // UInt32, UInt64, UInt16
          | 'U'
          // Byte
          | 'B'
          // Char
          | 'C'   => true
          | _ => false
        }
      };
      def fail () {
        Message.warning ("failed to emit value type conversion from " + 
                         l.FullName + " to " + r.FullName)
      };

      match (()) {
        | _ when r.Equals (l) => ()
        | _ when l.IsPrimitive || l.IsEnum =>
          if (r.IsPrimitive || r.IsEnum) {
            def rname =
              // FIXME: use true underalying type
              if (r.IsEnum) "Int32" else r.Name;
            def opcode =
              if (is_checked) {
                match (rname) {
                  | "Int64" when is_unsigned (l) => OpCodes.Conv_Ovf_I8_Un
                  | "Int64" => OpCodes.Conv_I8 // Conv_Ovf_I8 is broken in mono
                  | "Int32" when is_unsigned (l) => OpCodes.Conv_Ovf_I4_Un
                  | "Int32" => OpCodes.Conv_Ovf_I4
                  | "Int16" when is_unsigned (l) => OpCodes.Conv_Ovf_I2_Un
                  | "Int16" => OpCodes.Conv_Ovf_I2
                  | "SByte" when is_unsigned (l) => OpCodes.Conv_Ovf_I1_Un
                  | "SByte" => OpCodes.Conv_Ovf_I1
                  | "UInt64" when is_unsigned (l) => OpCodes.Conv_Ovf_U8_Un
                  | "UInt64" => OpCodes.Conv_Ovf_U8
                  | "UInt32" when is_unsigned (l) => OpCodes.Conv_Ovf_U4_Un
                  | "UInt32" => OpCodes.Conv_Ovf_U4
                  | "UInt16" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
                  | "UInt16" => OpCodes.Conv_Ovf_U2
                  | "Boolean" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
                  | "Boolean" => OpCodes.Conv_Ovf_U1
                  | "Byte" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
                  | "Byte" => OpCodes.Conv_Ovf_U1
                  | "Char" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
                  | "Char" => OpCodes.Conv_Ovf_U2
            
                  | "Single" when is_unsigned (l) => OpCodes.Conv_R_Un
                  | "Single" => OpCodes.Conv_R4
                  // there is no OpCodes.Conv_R8_Un
                  | "Double" when !is_unsigned (l) => OpCodes.Conv_R8

                  | _ => fail (); OpCodes.Nop
                }
              }
              else {
                match (rname) {
                  | "Int64" => OpCodes.Conv_I8
                  | "Int32" => OpCodes.Conv_I4
                  | "Int16" => OpCodes.Conv_I2
                  | "SByte" => OpCodes.Conv_I1
                  | "UInt64" => OpCodes.Conv_U8
                  | "UInt32" => OpCodes.Conv_U4
                  | "UInt16" => OpCodes.Conv_U2
                  | "Byte" => OpCodes.Conv_U1
                  | "Boolean" => OpCodes.Conv_U1
                  | "Char" => OpCodes.Conv_U2
            
                  | "Single" when is_unsigned (l) => OpCodes.Conv_R_Un
                  | "Single" => OpCodes.Conv_R4
                  | "Double" => OpCodes.Conv_R8

                  | _ => fail (); OpCodes.Nop
                }              
              }
            _ilg.Emit (opcode)
          }
          else if (r.FullName == "System.Decimal") {
            // FIXME: use true underalying type
            def lname = if (l.IsEnum) "Int32" else l.Name;
            match (lname) {
              | "Int32" | "UInt32" | "Single" | "Int64" | "UInt64" 
              | "Double" =>
                _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemType.Decimal_ctors.Get (lname)))
              | _ => fail ()
            }  
          }
          else fail ()

        | _ => fail ()
      }
    }

    /**
     * Checks if a given member info describes a field
     */
    private member_is_field (mi : MemberInfo) : bool
    {
      mi.MemberType == System.Reflection.MemberTypes.Field    
    }


    /**
     * Checks if a given member info describes a method
     */
    private member_is_method (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Method
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier and return true (cutoff).
     */
    private emit_method_call (expr : CG_expr, 
                              base_is_value_type_or_static : bool, 
                              method : MethodInfo) : bool
    {
      def is_tail =
        match (expr) {
          | CE_tail_call when Flags.general_tail_call_opt =>
            _ilg.Emit (OpCodes.Tailcall); 
            true
          | _ => false
        };
        
      if (base_is_value_type_or_static)
        _ilg.Emit (OpCodes.Call, method)
      else
        _ilg.Emit (OpCodes.Callvirt, method);

      if (is_tail) {
        _ilg.Emit (OpCodes.Ret);
        true
      } else false
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : CG_val) : LocalBuilder 
    {    
      def local_slot = _ilg.DeclareLocal (val.ty);
      local_slot.SetLocalSymInfo (val.name);
      val.local_slot = Some (local_slot);
      local_slot
    }

    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     */
    private emit_array_store_opcode (ty : System.Type) : void
    {
      assert (!is_system_void (ty), "tried to store a System.Void in an array");

      if (ty.IsPrimitive) {
        def opcode = 
          match (ty.Name) {
            | "SByte" | "Boolean" 
            | "Byte"                     => OpCodes.Stelem_I1
            | "Char" | "Int16" 
            | "UInt16"                   => OpCodes.Stelem_I2
            | "Int32" | "UInt32"         => OpCodes.Stelem_I4
            | "Int64" | "UInt64"         => OpCodes.Stelem_I8
            | "Single"                   => OpCodes.Stelem_R4
            | "Double"                   => OpCodes.Stelem_R8
            | _ => Util.ice ("System.Type IsPrimitive has lied")
          }
          _ilg.Emit (opcode);
        }
        else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
        else _ilg.Emit (OpCodes.Stelem_Ref);
    }


    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : System.Type) : void
    {
      assert (!is_system_void (ty), "tried to load a System.Void from an array");
      
      def opcode =
        if (ty.IsPrimitive) 
        {
          match (ty.Name) { 
            | "SByte" | "Boolean" => OpCodes.Ldelem_I1
            | "Byte"              => OpCodes.Ldelem_U1
            | "Char" | "Int16"    => OpCodes.Ldelem_I2
            | "UInt16"            => OpCodes.Ldelem_U2
            | "Int32"             => OpCodes.Ldelem_I4
            | "UInt32"            => OpCodes.Ldelem_U4
            | "Int64" | "UInt64"  => OpCodes.Ldelem_I8
            | "Single"            => OpCodes.Ldelem_R4
            | "Double"            => OpCodes.Ldelem_R8
            | _ => Util.ice ("System.Type.IsPrimitive has lied")
          }
        }
        else
          OpCodes.Ldelem_Ref;

      _ilg.Emit (opcode)
    }
    
   

    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : System.Type) : void
    {
      if (ty.IsEnum || !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldobj, ty)
      }
      else {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"     => OpCodes.Ldind_I1
            | "Byte"                  => OpCodes.Ldind_U1
            | "Char" | "Int16"        => OpCodes.Ldind_I2
            | "UInt16"                => OpCodes.Ldind_U2
            | "Int32"                 => OpCodes.Ldind_I4
            | "UInt32"                => OpCodes.Ldind_U4
            | "Int64"                 => OpCodes.Ldind_I8
            | "UInt64"                => OpCodes.Ldind_I8            
            | "Single"                => OpCodes.Ldind_R4
            | "Double"                => OpCodes.Ldind_R8
            | _ =>  
              Util.ice (_method_name + ": not a recognized value type: " + ty.FullName);
          }
            
        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a literal
     */
    private emit_literal (l : Literal) : void
    {
      match (l) {
        | L_void => ()
        | L_null => 
          _ilg.Emit (OpCodes.Ldnull)

        | L_int (-1) => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | L_int (0) => _ilg.Emit (OpCodes.Ldc_I4_0)
        | L_int (1) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_int (2) => _ilg.Emit (OpCodes.Ldc_I4_2)
        | L_int (3) => _ilg.Emit (OpCodes.Ldc_I4_3)
        | L_int (4) => _ilg.Emit (OpCodes.Ldc_I4_4)
        | L_int (5) => _ilg.Emit (OpCodes.Ldc_I4_5)
        | L_int (6) => _ilg.Emit (OpCodes.Ldc_I4_6)
        | L_int (7) => _ilg.Emit (OpCodes.Ldc_I4_7)
        | L_int (8) => _ilg.Emit (OpCodes.Ldc_I4_8)
        | L_int (k) when (k >= -128 && k <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, (k :> System.SByte))
        | L_int (k) => _ilg.Emit (OpCodes.Ldc_I4, k)
          
        | L_byte (k) when k <= 127b =>
          _ilg.Emit (OpCodes.Ldc_I4_S, (k :> System.SByte))
        | L_byte (k) =>
          _ilg.Emit (OpCodes.Ldc_I4, (k :> int))

        | L_uint (k) =>
          unchecked {
            _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
          }
          _ilg.Emit (OpCodes.Conv_U4)
          
        | L_short (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
        | L_ushort (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int)) 
        | L_sbyte (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int)) 
                    
        | L_long (k) => _ilg.Emit (OpCodes.Ldc_I8, k)
        | L_ulong (k) =>
          unchecked {
            _ilg.Emit (OpCodes.Ldc_I8, (k :> long))
          }
          _ilg.Emit (OpCodes.Conv_U8)
            
        | L_char (k) when ((k :> int) <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, (k :> System.Byte))
          
        | L_char (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
        
        | L_bool (true) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)

        | L_string (s) => _ilg.Emit (OpCodes.Ldstr, s)
        | L_float (f) => _ilg.Emit (OpCodes.Ldc_R4, f)
        | L_double (f) => _ilg.Emit (OpCodes.Ldc_R8, f)
        | L_decimal (m) =>
          def decimal_bits = System.Decimal.GetBits (m);

          _ilg.Emit (OpCodes.Ldc_I4_4);
          
          _ilg.Emit (OpCodes.Newarr, SystemType.Int32);

          when (decimal_bits [0] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [1] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [2] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [3] != 0)
            _ilg.Emit (OpCodes.Dup);

          when (decimal_bits [0] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [0]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [1] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [1]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [2] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_2);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [2]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [3] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_3);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [3]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }

          _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemType.Decimal_ctors.Get ("Int32[]")))

        | L_enum (l, _) => emit_literal (l)
      }
    }


    /**
     * Emits a list of expressions. This is used to emit call parameters,
     * specialization allows better error messages here.
     */
    private emit_call_parameters (parms : list <CG_expr>) : bool
    {
      match (parms) {
        | [] => false
        | parm :: rest =>
          if (emit (parm)) {
            Message.warning ("a control-flow terminating call parameter in "
                             + _method_name);
            true
          }
          else emit_call_parameters (rest)
      }
    }


    /**
     * Emits a comparison operation
     */
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }



    /**
     * Computes the type of an expression
     */
    type_of (ex : CG_expr) : System.Type
    {
      CGexpr.type_of (ex)
    }


    /**
     * Pretty prints a list of expressions
     */
    pretty_print_list (exs : list <CG_expr>, acc : string) : string 
    {
      match (exs) {
        | [] => acc
        | ex :: rest => pretty_print_list (rest, acc + pretty_print (ex))
      }
    }


    /**
     * Pretty prints an expression
     */
    pretty_print (ex : CG_expr) : string 
    {
      match (ex) {
        | CE_ref (decl) =>
          "CE_ref (" + decl.name + "); "
        | CE_global_ref (mi) =>
          "CE_global_ref (" + pretty_print_member_info (mi) + "); "
        | CE_volatile_global_ref (mi) =>
          "CE_volatile_global_ref (" + pretty_print_member_info (mi) + "); "
        | CE_base_ctor_ref (mi) =>
          "CE_base_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_ctor_ref (mi) =>
          "CE_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_field_ref (_, fld) =>
          "CE_field_ref (" + pretty_print_member_info (fld) +"); "
        | CE_volatile_field_ref (_, fld) =>
          "CE_volatile_field_ref (" + pretty_print_member_info (fld) +"); "
        | CE_method_ref (_, meth, _) =>
          "CE_method_ref (" + pretty_print_member_info (meth) + "); "
        | CE_method_addr (meth) =>
          "CE_method_addr (" + pretty_print_member_info (meth) + "); "
        | CE_ignore (expr) =>
          "CE_ignore (" + pretty_print (expr) + "); "
        | CE_opcode (name) =>
          "CE_opcode (" + name + "); "
        | CE_self_tail_call (parms) =>
          "CE_self_tail_call (" + pretty_print_list (parms, "") + "); "
        | CE_call (func, parms) =>
          "CE_call " + pretty_print (func) + " (" + pretty_print_list (parms, "") + "); "
        | CE_tail_call (func, parms) =>
          "CE_tail_call " + pretty_print (func) + " (" +
          pretty_print_list (parms, "") + "); "
        | CE_assign (target, source) => 
          pretty_print (target) + " = " + pretty_print (source) + "; "
        | CE_addr (expr) => 
          "CE_addr (" + pretty_print (expr) + "); "
        | CE_indirect (expr) => 
          "CE_indirect (" + pretty_print (expr) + "); "
        | CE_multiple_assign => 
          "CE_multiple_assign; "
        | CE_loop (expr, _) =>
          "CE_loop (" + pretty_print (expr) + "); "
        | CE_continue_loop =>
          "CE_continue_loop; "
        | CE_let (name, body) => 
          "let " + name.name + " = " + pretty_print (name.val) + " in "
          + pretty_print (body) + "; "
        | CE_has_type (_, ty) => "CE_has_type (" + pretty_print_type (ty) + "); "
        | CE_not_null => "CE_not_null; "
        | CE_typeof (ty) => "CE_typeof (" + pretty_print_type (ty) + "); "
        | CE_raise (exn) => "CE_raise (" + pretty_print (exn) + "); "
        | CE_if (cond, e_then, e_else) => 
          "if (" + pretty_print (cond) + ") " + pretty_print (e_then)
          + " else " + pretty_print (e_else) + "; "
        | CE_try_with => "CE_try_with; "
        | CE_try_finally => "CE_try_finally; "
        | CE_literal => "CE_literal; "
        | CE_this => "CE_this; "
        | CE_skip => "CE_skip; "
        | CE_cast (expr, ty, _) =>
          "CE_cast < " + pretty_print (expr)
          + " to " + pretty_print_type (ty) + "> "
        | CE_init_obj (ty) =>
          "CE_init_obj (" + pretty_print_type (ty) + ") "
        | CE_sequence (body) => "{ " + pretty_print_list (body, "") + " }; "
        | CE_none => "CE_none"
        | CE_mkarray (_, initializers, dimensions) =>
          "CE_mkarray { " + pretty_print_list (initializers, "") + " } {"+ List.FoldLeft (dimensions, "", fun (i, acc) { acc + i.ToString () + "; " }) +"}; "
        | CE_array_indexer (obj, args) =>
          "CE_mindexer " + pretty_print (obj) + "[" +
          pretty_print_list (args, "") + "]" + "; "
        | CE_switch (indexer, _, _) =>
          "CE_switch ( " + pretty_print (indexer) + " ); "
      }
    }


    /**
     * Pretty prints a type
     */
    private pretty_print_type (ty : System.Type) : string
    {
      ty.FullName
    }


    /**
     * Pretty prints a member info name
     */
    private pretty_print_member_info (mi : MemberInfo) : string
    {
      mi.DeclaringType.FullName + "::" + mi.Name
    }

    /**
     * Converts a list <Label> into a array <Label>
     * FIXME: this should work now?
     */
    private label_list_to_array (x : list <Label>) : array <Label> 
    {
      def result = array (List.Length (x));
      
      def loop (index : int, x : list <Label>) : void {        
        match (x) {
          | head :: tail =>
            result [index] = head;
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }

  } /* end of the class */
  
} /* end of the namespace */
