(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.CGexpr;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

module CGexpr {
  mutable cg_members : System.Collections.Hashtable;
  
  lookup_field (decl : M_field) : CM_field {
    def result = (cg_members [decl.id] :> CM_field);
    
    if (result == null) {
      def m = (CM_field (decl.ty, cg_type (decl.ty)) :> CM_field);
      m.name <- decl.name;
      m.attrs <- cg_attrs (decl.modifiers);
      cg_members.Add (decl.id, m);
      m
    }
    else result
  }

  lookup_property (decl : M_property) : CM_property {
    def result = (cg_members [decl.id] :> CM_property);

    if (result == null) {
      def m = (CM_property (cg_type (decl.ty)) :> CM_property);
      m.name <- decl.name;
      m.attrs <- cg_attrs (decl.modifiers);
      cg_members.Add (decl.id, m);
      m
    }
    else result
  }

  lookup_value (decl : M_value) : CM_field {
    def result = (cg_members [decl.id] :> CM_field);
    
    if (result == null) {
      def m = (CM_field (decl.ty, cg_type (decl.ty)) :> CM_field);
      m.name <- decl.name;
      m.attrs <- cg_attrs (decl.modifiers);
      make_static (m);
      cg_members.Add (decl.id, m);
      m
    }
    else result
  }

  lookup_function (h : Fun_header) : CM_method {
    def result = (cg_members [h.id] :> CM_method);
    
    if (result == null) {
      def m = cg_header (h);
      cg_members.Add (h.id, m);
      m
    }
    else result
  }

  lookup_function (h : Fun_header, ti : Tyinfo) : CM_method {
    def result = (cg_members [h.id] :> CM_method);

    if (result == null) {
      def m = cg_header (h);

      if (ti.env.current_namespace != "")
        m.extern_name <- ti.env.current_namespace + ti.name + "." + m.name
      else
        m.extern_name <- ti.name + "." + m.name;

      cg_members.Add (h.id, m);
      m
    }
    else result
  }

  lookup_class (ti : Tyinfo) : CM_class {
    def result = (cg_members [ti.id] :> CM_class);

    if (result == null) {
      def inh = List.map (cg_type, ti.direct_supertypes ());
      def r = (CM_class ("", CK_class (), inh, []) :> CM_class);
      r.loc <- ti.loc;
      r.name <- ti.name;
      if (ti.env.current_namespace != "")
        r.extern_name <- ti.env.current_namespace + ti.name
      else
        r.extern_name <- ti.name;
      r.attrs <- cg_attrs (ti.modifiers);
      cg_members.Add (ti.id, r);
      r
    }
    else result
  }
    
  cg_type (t : Type) : CG_type {
    match (Tyutil.top_expand (t)) {
      | T_void => CT_void ()
      | T_prod (l) => CT_tuple (List.length (l))
      | T_fun (args, _) => CT_fun (List.length (Tyutil.fun_args (args)))
      | T_var (tv) =>
        match (Tyvar.constraints (tv)) {
          | [] => CT_object ()
          | t :: _ => cg_type (t)
        }
      | T_app (ti, _) => 
        match (ti.tydecl) {
          | TD_external (x) => 
            if (x == "object") CT_object ()
            else CT_ref (x)
          | _ => CT_ref (ti.fullname())
        }
      | T_ref => Util.ice ("FIXME: cg ref")
      | T_out => Util.ice ("FIXME: cg out")
      | T_array (at) => CT_array (cg_type (at))
    }
  }

  mutable closures : list (CG_member);

  class CTX
    {
      public mutable current_fun : Decl;
      public mutable current_closure : option (CG_val);
      public mutable closure_fields : Int_map (CM_field);
      public mutable closure_ptrs : Int_map (CM_field);
      public mutable locals : Int_map (CG_val);
    }

  copy_ctx (c : CTX) : CTX {
    CTX (current_fun = c.current_fun,
         current_closure = c.current_closure,
         closure_fields = c.closure_fields,
         closure_ptrs = c.closure_ptrs,
         locals = c.locals)
  }

  empty_ctx () : CTX {
    CTX (current_fun = null,
         current_closure = None (),
         closure_fields = Map.int_map (),
         closure_ptrs = Map.int_map (),
         locals = Map.int_map ())
  }

  store_in_closure (ctx : CTX, d : Decl, val : CG_expr) : CG_expr
    {
      def rf = CE_field_ref (CE_ref (Util.unsome (ctx.current_closure)),
                             ctx.closure_fields.get (d.id));
      CE_assign (rf, val);
    }

  store_local (ctx : CTX, d : Decl, val : CG_expr) : CTX * CG_val {
    if (d.in_closure) {
      def assign = store_in_closure (ctx, d, val);
      def cgv = CG_val (loc = d.loc, 
                        name = "_N_dummy_" + string_of_int (Util.next_id ()), 
                        ty = CT_void (), 
                        val = assign);
      (copy_ctx (ctx), cgv)
    } else {
      def cgv = CG_val (loc = d.loc, 
                        name = decl_uniq_name(d), 
                        ty = cg_type (d.ty), 
                        val = val);
      def ctx' = copy_ctx (ctx);
      ctx'.locals <- ctx.locals.add (d.id, cgv);
      (ctx', cgv)
    }
  }

  closure_ref (ctx : CTX, fn : Decl) : CG_expr {
    if (ctx.current_fun.id == fn.id)
      CE_ref (Util.unsome (ctx.current_closure))
    else
      CE_field_ref (CE_this (), ctx.closure_ptrs.get (fn.id))
  }

  null_value (t : CG_type) : CG_expr {
    match (t) {
      | CT_bool => CE_false ()
      | CT_ref (n) =>
        if (n == "int" || n == "System.Int32") CE_literal (L_int (0))
        else if (n == "char" || n == "System.Char") CE_literal (L_char (0))
        else if (n == "bool" || n == "System.Boolean") CE_false ()
        else if (n == "float" || n == "System.Single" || n == "System.Double") CE_literal (L_int (0)) // FIXME ?
        else CE_literal (L_null ())
      | _ => CE_literal (L_null ())
    }
  }

  cg_pattern (ctx : CTX, val : CG_expr, pat : Pattern) : CG_expr * bool * CTX * list (CG_val)
    {
      mutable vals <- [];
      mutable rctx <- ctx;
      mutable always_matches <- true;
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_true ()
          
          | P_as (subpat, d) =>
            if (d.in_closure) ()
            else {
              def (ctx, v) = store_local (rctx, d, null_value (cg_type (d.ty)));
              rctx <- ctx;
              vals <- v :: vals;
            };
            def ass = CE_assign (val_ref (rctx, d), maybe_cast (d.ty, val));
            CE_sequence ([ass; cgpat (val, subpat)])
            
          | P_tuple (args) =>
            def len = List.length (args);
            def f (acc : int * CG_expr, arg : Pattern) : int * CG_expr
              {
                def (pos, ex) = acc;
                def cond = cgpat (CE_tuple_ref (CE_cast (val, CT_tuple (len)), pos), arg);
                (pos - 1, CE_if (CT_bool (), cond, ex, CE_false ()))
              };
            def ini = (len - 1, CE_true ());
            def (_, ex) = List.fold_left (f, ini, List.rev (args));
            ex

          | P_literal (lit) =>
            def eq = 
              match (Env.lookup_global ("Nemerle.Core.==")) {
                | {kind = D_class_member (M_function (h, _, _))} => lookup_function (h)
                | _ => Util.ice ()
              };
            def litexpr = CE_literal (lit);
            CE_call (CE_global_ref (eq), [CE_cast (val, CGflat.type_of (litexpr)); litexpr])
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (pat.ty));
            def f (ex : CG_expr, arg : Named_pattern) : CG_expr 
              {
                def cond = cgpat (CE_field_ref (val, lookup_field (arg.name)), arg.pat);
                CE_if (CT_bool (), cond, ex, CE_false ())
              };
            List.fold_left (f, CE_true (), List.rev (args))
          
          | P_cons (n, a) =>
            always_matches <- false;
            def tyname = CT_ref (n.fullname());
            def ex = CE_has_type (val, tyname);
            CE_if (CT_bool (), ex, cgpat (CE_cast (val, tyname), a), CE_false ())
        }
      };

      def r = cgpat (val, pat);
      (r, always_matches, rctx, vals);
    }

  cg_match (t : CG_type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr {
    match (mcs) {
      | [] =>
        def match_failure =
          match (Env.lookup_global ("Nemerle.Core.Match_failure")) {
            | {kind = D_type (x)} => lookup_class (x)
            | _ => Util.ice ()
          };
        CE_raise (CE_call (CE_ctor_ref (match_failure), []))

      | m :: ms =>
        def (cond, always_matches, ctx', vals) = cg_pattern (ctx, val, m.pattern);
        def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) };
        def then_part = cg_expr (ctx', m.body);
        def else_part = cg_match (t, ctx, val, ms);
        List.fold_left (mklet, CE_if (t, cond, then_part, else_part), vals)
    }
  }

  mutable lambda_proxies : Int_map (CM_class);

  val_ref (ctx : CTX, d : Decl) : CG_expr {
    if (d.in_closure) {
      def defined_in = Util.unsome (d.parent_fun);
      CE_field_ref (closure_ref (ctx, defined_in), 
                    ctx.closure_fields.get (d.id))
    } else
      match (d.kind) {
        | D_class_member (M_value v) => 
          CE_global_ref (lookup_value (v))
          
        | D_class_member (M_function f) =>
          if (lambda_proxies == null) lambda_proxies <- Map.int_map ()
          else ();
          def lc =
            match (lambda_proxies.find (f.id)) {
              | Some (lc) => lc
              | None =>
                def lc = make_lambda_class (ctx, Env.global_by_id (f.id));
                def mkparm (v : CG_val) : CG_expr 
                  {
                    def t = v.ty;
                    v.ty <- CT_object ();
                    CE_cast (CE_ref (v), t)
                  };
                def fn = cg_header (f.header);
                def fun_ref = CE_global_ref (lookup_function (f.header));
                fn.body <- CE_call (fun_ref, List.map (mkparm, fn.parms));
                lc.decls <- [(fn : CG_member)];
                
                match (f.header.parms) {
                  | [_] => ()
                  | _ =>
                    def parm = 
                      CG_val (loc = Location_stack.top (),
                              name = "_N_tupled",
                              ty = CT_object (),
                              val = CE_none ());
                    mutable pos <- -1;
                    def parm' = CE_cast (CE_ref (parm), CT_tuple (List.length (f.header.parms)));
                    def mktparm (p : Fun_parm) : CG_expr {
                      pos <- pos + 1;
                      CE_cast (CE_tuple_ref (parm', pos), cg_type (p.ty));
                    };
                    def body = CE_call (fun_ref, List.map (mktparm, f.header.parms));
                    def meth = CM_method (full_type = T_void (), // FIXME: build the full type here
                                          parms = [parm],
                                          ret_type = CT_object (),
                                          body = body);
                    meth.name <- "apply";
                    meth.attrs <- ["public"];
                    lc.decls <- meth :: lc.decls
                };
                
                lc.extern_name <- lc.name;
                fn.name <- "apply";
                fn.attrs <- ["public"];
                fn.ret_type <- CT_object ();
                closures <- (lc : CG_member) :: closures;
                lambda_proxies <- lambda_proxies.add (f.id, lc);
                lc
            };
          CE_call (CE_ctor_ref (lc), [])

        | D_class_member => Util.ice ()

        | _ => 
          if (ctx.locals.mem (d.id))
            CE_ref (ctx.locals.get (d.id))
          else {
            Message.debug ("undef " + d.name + " = " + string_of_int (d.id));
            Util.ice ("ref to undef val " + d.name)
          }
      }
  }

  public tmp () : string {
    "_N_ct" + string_of_int (Util.next_id ())
  }

  maybe_cast (needed_type : Type, ex : CG_expr) : CG_expr {
    match ((CGflat.type_of (ex), cg_type (needed_type))) {
      | (CT_object, CT_object) => ex
      | (CT_object, t) => CE_cast (ex, t)
      | (CT_ref (n1), CT_ref (n2)) =>
        if (n1 == n2) ex else CE_cast (ex, CT_ref (n2))
      | _ => ex
    }
  }

  raw_cg_expr (ctx : CTX, inex : Expr) : CG_expr
    {
      def self (e : Expr) : CG_expr { cg_expr (ctx, e) };
      match (inex) {
        | E_ref (d) => 
          val_ref (ctx, d)

        | E_field_ref (o, f) =>
          maybe_cast (inex.expr_ty, CE_field_ref (self (o), lookup_field (f)))

        | E_property_ref (o, p) =>
          maybe_cast (inex.expr_ty, CE_property_ref (self (o), lookup_property (p)))

        | E_method_ref => Util.ice ()

        | E_call (f, ps) =>
          def mkp (p : Parm) : CG_expr { self (p.expr) };
          def plain_call () : CG_expr {
            def len = List.length (ps);
            def fldname = "Nemerle.Func" + string_of_int (len) + ".apply";
            def get_header (d : Decl) : option (Fun_header) {
              match (d.kind) {
                | D_class_member (M_function {header = h}) =>
                  if (List.length (h.parms) == len) Some (h)
                  else None ()
                | _ => Util.ice ()
              }
            };
            def header =
              match (Env.lookup_multibound_global (fldname)) {
                | [x1; x2] =>
                  match ((get_header (x1), get_header (x2))) {
                    | (Some (h), None) => h
                    | (None, Some (h)) => h
                    | _ => Util.ice ()
                  }
                | [x] => Util.unsome (get_header (x))
                | _ => Util.ice ()
              };
            CE_method_ref (self (f), lookup_function (header))
          };
          def callable =
            match (f) {
              | E_ref ({kind = D_class_member (M_function f)}) =>
                def ti = f.tyinfo;
                match (f.kind) {
                  | FK_ctor =>
                    CE_ctor_ref (lookup_class (ti))
                  | _ =>
                    CE_global_ref (lookup_function (f.header, ti))
                }
              | E_method_ref (o, m) => 
                CE_method_ref (self (o), lookup_function (m.header))
              | E_ref (d) =>
                if (d == ctx.current_fun)
                  match (d.kind) {
                    | D_local_fun (h, _) =>
                      CE_method_ref (CE_this (), lookup_function (h))
                    | _ => Util.ice ()
                  }
                else plain_call ()
              | _ => plain_call ()
            };
          maybe_cast (inex.expr_ty, CE_call (callable, List.map (mkp, ps)))

        | E_assign (e1, e2) =>
          CE_assign (self (e1), self (e2))
          
        | E_mkarray (initializers) =>
          CE_mkarray (List.map (self, initializers))

        | E_indexer (ty, obj, args) =>
          CE_indexer (cg_type (ty), self (obj), List.map (self, args));

        | E_let (d, v, b) =>
          def (ctx', cgv) = store_local (ctx, d, self (v));
          CE_let (cgv, cg_expr (ctx', b))

        | E_letfun (fs, body) =>
          mutable l <- [];
          def store (ctx : CTX, f : Function_decl) : CTX 
            {
              def cl = make_lambda_class (ctx, f.decl);
              def ct = make_lambda_ctor (ctx, f.decl, cl);
              def (ctx, val) = store_local (ctx, f.decl, ct);
              l <- (val, cl) :: l;
              ctx
            };

          def ctx = List.fold_left (store, ctx, fs);
          
          def fill (f : Function_decl, acc : CG_val * CM_class) : void 
            {
              def (val, cl) = acc;
              closures <- (cl : CG_member) :: closures;
              fill_lambda_class (ctx, f.decl, f.body, cl)
            };

          List.iter2 (fill, fs, List.rev (l));

          def mklet (acc : CG_expr, x : CG_val * CM_class) : CG_expr
            {
              def (val, cl) = x;
              CE_let (val, acc)
            };

          List.fold_left (mklet, cg_expr (ctx, body), l)

        | E_match (e, mcs) =>
          def v =
            CG_val (loc = e.loc, 
                    name = tmp (),
                    ty = cg_type (e.expr_ty), 
                    val = cg_expr (ctx, e));
          CE_let (v, cg_match (cg_type (inex.expr_ty), ctx, CE_ref (v), mcs))

        | E_raise (e) =>
          CE_raise (cg_expr (ctx, e))

        | E_if (cond, e1, e2) =>
          CE_if (cg_type (inex.expr_ty), 
                 cg_expr (ctx, cond), 
                 cg_expr (ctx, e1), 
                 cg_expr (ctx, e2))

        | E_try_with (body, exn, handler) =>
          def body = cg_expr (ctx, body);
          // FIXME: this is broken for exn values to go into closure
          def (ctx', v) = store_local (ctx, exn, CE_none ());
          def handler = cg_expr (ctx', handler);
          CE_try_with (body, v, handler)

        | E_try_finally (e1, e2) =>
          CE_try_finally (cg_expr (ctx, e1), cg_expr (ctx, e2))

        | E_literal (l) => 
          CE_literal (l)

        | E_this => 
          CE_this ()

        | E_type_conversion (e, t) => 
          CE_cast (cg_expr (ctx, e), cg_type (t))

        | E_type_enforcement (e, _) =>
          cg_expr (ctx, e)

        | E_sequence (e1, e2) =>
          CE_sequence ([cg_expr (ctx, e1); cg_expr (ctx, e2)])

        | E_tuple (l) =>
          CE_tuple_ctor (List.map (self, l))
      }
    }

  (** Flatten given [Typedtree.Expr] object into [CG_expr].

      <remarks>
        As a side-effect few classes for closures and local functions
        can be generated and stored in [closures] stack.
      </remarks>
    *)
  cg_expr (ctx : CTX, ex : Expr) : CG_expr {
    Util.locate (ex.loc, fun () : CG_expr {
        def e = raw_cg_expr (ctx, ex);
        e.loc <- ex.loc;
        e
      })
  }

  fixup_function (f : M_function) : CM_method
    {
      def m = lookup_function (f.header);
      m.attrs <- cg_attrs (f.modifiers);
      m.full_type <- Tyutil.fun_type (f.header); // FIXME: build the full type here
      def fd = Env.global_by_id (f.id);
      def ti = f.tyinfo;
      match (f.kind) {
        | FK_bound_method => ()
        | FK_method => Util.ice ()
        | FK_static_ctor => 
          {
            m.name <- ti.basename ();
            m.ret_type <- CT_unreached ();
            m.attrs <- ["static"]
          }
        | FK_ctor => 
          {
            m.name <- ti.basename ();
            m.ret_type <- CT_unreached ()
          }
        | FK_function => make_static (m)
        | FK_iface_method => Util.ice ()
      };
      m
    }

  mangle (s : string) : string = 
    extern "Nemerle.Compiler.CS_glue.mangle";

  decl_uniq_name (d : Decl) : string {
    mangle (d.name) + "_" + string_of_int (d.id)
  }

  prepare_ctx_for_fun (ctx : CTX, fn : Decl) : CTX
    {
      def mk_clo_fld (d : Decl) : CG_member
        {
          def f = CM_field (d.ty, cg_type (d.ty));
          f.name <- decl_uniq_name (d);
          f.attrs <- ["internal"];
          f.loc <- d.loc;
          f
        };
  
      def mk_clo_var (clo_vars : Int_map (CM_field), d : Decl, v : CG_member) 
                     : Int_map (CM_field) {
        clo_vars.add (d.id, (v :> CM_field))
      };
    
      def ctx =
        {
          def h = fn.fun_header ();
          if (h.closure_vars == null) Util.ice () else ();
          match (h.closure_vars) {
            | [] => 
              def ctx = copy_ctx (ctx);
              ctx.current_closure <- None ();
              ctx

            | _ :: _ =>
              def fields = List.map (mk_clo_fld, h.closure_vars);
              def clovars = List.fold_left2 (mk_clo_var, ctx.closure_fields, 
                                             h.closure_vars, fields);
              def cloclass = (CM_class ("", CK_class (), [], fields) :> CM_class);
              def cloclname = "_N_cl_" + decl_uniq_name (fn);
              def clotype = CT_ref (cloclname);
              def cloexpr = CE_call (CE_ctor_ref (cloclass), []);
              def cloval = CG_val (fn.loc, "_N_closure", clotype, cloexpr);
              def ctx = copy_ctx (ctx);

              cloclass.name <- cloclname;
              cloclass.loc <- fn.loc;
              closures <- (cloclass : CG_member) :: closures; // push it
              ctx.closure_fields <- clovars;
              ctx.current_closure <- Some (cloval);
              ctx
          }
        };
        
      ctx.closure_ptrs <- Map.int_map ();
      ctx.locals <- Map.int_map ();
      ctx.current_fun <- fn;
      ctx
    }

  get_fn_header (fn : Decl) : Fun_header {
    match (fn.kind) {
      | D_local_fun (h, _) => h
      | D_class_member (M_function {header = h}) => h
      | _ => Util.ice ()
    }
  }

  make_lambda_class (ctx : CTX, fn : Decl) : CM_class
    {
      def h = get_fn_header (fn);
      def funty = CT_fun (List.length (h.parms));
      def lambdaclass = CM_class ("", CK_class (), [funty], []);
      lambdaclass.name <- decl_uniq_name (fn);
      (lambdaclass :> CM_class)
    }

  make_lambda_ctor (ctx : CTX, fn : Decl, cl : CM_class) : CG_expr
    {
      def pars =
        match (fn.kind) {
          | D_local_fun (_, pars) => pars
          | _ => []
        };
      def loop (acc : list (CG_expr), fn : Decl) : list (CG_expr) {
        match ((fn.fun_header ()).closure_vars) {
          | _ :: _ => closure_ref (ctx, fn) :: acc
          | [] => acc
        }
      };
      CE_call (CE_ctor_ref (cl), List.fold_left (loop, [], pars))
    }

  fill_lambda_class (ctx : CTX, fn : Decl, body : Expr, lambdaclass : CM_class) : void
    {
      def make_ctor (mems : list (CG_member)) : CG_member
        {
          def mkparm (f : CG_member) : CG_val {
            CG_val (loc = f.loc, name = f.name,
                    ty = (f :> CM_field).ty, val = CE_none ())
          };
          def mkassign (p : CG_val, f : CG_member) : CG_expr {
            CE_assign (CE_field_ref (CE_this (), (f :> CM_field)), CE_ref (p))
          };
            
          def parms = List.map (mkparm, mems);
          def assigns = List.map2 (mkassign, parms, mems);
          def meth = CM_method (T_void (), parms, CT_unreached (), CE_sequence (assigns)); // FIXME: the full type
          meth.name <- decl_uniq_name (fn);
          meth.attrs <- ["internal"];
          meth
        };
        
      def (hd, meth, pars) = 
        match (fn.kind) {
          | D_local_fun (h, pars) => (h, lookup_function (h), pars)
          | _ => Util.ice ()
        };

      def ctx = prepare_ctx_for_fun (ctx, fn);
      def mkcloptr (acc : list (CG_member), fn : Decl) : list (CG_member) {
        match ((fn.fun_header ()).closure_vars) {
          | _ :: _ => 
            def clotype = CT_ref ("_N_cl_" + decl_uniq_name (fn));
            def fld = CM_field (fn.ty, clotype); // FIXME: is this the correct type here?
            fld.name <- decl_uniq_name (fn);
            ctx.closure_ptrs <- ctx.closure_ptrs.add (fn.id, (fld :> CM_field));
            fld :: acc
          | [] => acc
        }
      };
      def fields = List.fold_left (mkcloptr, [], pars);
      def set_obj_parm (v : CG_val) : void { v.ty <- CT_object () };
      def members = make_ctor (fields) :: (meth : CG_member) :: fields;
      def members =
        match (meth.parms) {
          | [_] => members
          | l =>
            def parm = 
              CG_val (loc = Location_stack.top (),
                      name = "_N_tupled",
                      ty = CT_object (),
                      val = CE_none ());
            mutable pos <- -1;
            def parm' = CE_cast (CE_ref (parm), CT_tuple (List.length (meth.parms)));
            def mktparm (p : CG_val) : CG_expr {
              pos <- pos + 1;
              CE_cast (CE_tuple_ref (parm', pos), p.ty);
            };
            def fun_ref = CE_method_ref (CE_this (), meth);
            def body = CE_call (fun_ref, List.map (mktparm, meth.parms));
            def meth' = CM_method (full_type = T_void (), // FIXME: build the full type here
                                   parms = [parm],
                                   ret_type = CT_object (),
                                   body = body);
            meth'.name <- "apply";
            meth'.attrs <- ["public"];
            meth' :: members
        };
      
      lambdaclass.decls <- members;
      List.iter (set_obj_parm, meth.parms);
      meth.name <- "apply";
      meth.attrs <- ["public"];
      meth.ret_type <- CT_object ();
      meth.body <- cg_fun_body (ctx, hd, meth, body)
    }

  cg_fun_body (ctx : CTX, hd : Fun_header, meth : CM_method, body : Expr) : CG_expr
    {
      def ctx' = copy_ctx (ctx);
      mutable assigns <- [];
      mutable vals <- [];
      
      def loadparm (parm_val : CG_val, fp : Fun_parm) : void
        {
          def parm = fp.decl;
          def needed_type = cg_type (fp.decl.ty);
          def need_downcast =
            match ((needed_type, parm_val.ty)) {
              | (CT_object, CT_object) => false
              | (_, CT_object) => true
              | _ => false
            };

          if (parm.in_closure) {
            def a =
              CE_assign (val_ref (ctx, parm), 
                         if (need_downcast) 
                           CE_cast (CE_ref (parm_val), needed_type)
                         else CE_ref (parm_val));
            assigns <- a :: assigns
          } else {
            def v =
              if (need_downcast) {
                def v = CG_val (loc = fp.decl.loc, 
                                name = "_N_" + parm_val.name + "_" + 
                                       string_of_int (Util.next_id ()),
                                ty = needed_type, 
                                val = CE_cast (CE_ref (parm_val), needed_type));
                vals <- v :: vals;
                v
              } else parm_val;
            ctx'.locals <- ctx'.locals.add (parm.id, v)
          }
        };

      def store_this (d : Decl) : void {
        match (d.kind) {
          | D_closurised_this_ptr =>
            if (d.in_closure)
              assigns <- CE_assign (val_ref (ctx, d), CE_this ()) :: assigns
            else ()
          | _ => ()
        }
      };

      List.iter2 (loadparm, meth.parms, hd.parms);
      List.iter (store_this, (ctx.current_fun.fun_header ()).closure_vars);
      
      def body = cg_expr (ctx', body);
      def buildlet (e : CG_expr, v : CG_val) : CG_expr { CE_let (v, e) };
      def body =
        List.fold_left (buildlet, 
                        CE_sequence (List.rev (body :: assigns)),
                        vals);
                        
      match (ctx.current_closure) {
        | Some (v) => CE_let (v, body)
        | None => body
      };
    }

  cg_global_fun (ctx : CTX, fn : Decl, body : Expr) : CG_member
    {
      def ctx = prepare_ctx_for_fun (ctx, fn);
      def (hd, meth) =
        match (fn.kind) {
          | D_class_member (M_function f) => (f.header, fixup_function (f))
          | _ => Util.ice ()
        };
      meth.body <- cg_fun_body (ctx, hd, meth, body);
      meth
    }
    
  cg_header (h : Fun_header) : CM_method
    {
      def mkparm (p : Fun_parm) : CG_val {
        CG_val (loc = Location_stack.top (),
                name = p.name, 
                ty = cg_type (p.ty),
                val = CE_none ())
      };
      def m = CM_method (full_type = T_void (), // FIXME: build the full type here
                         parms = List.map (mkparm, h.parms), 
                         ret_type = cg_type (h.ret_type),
                         body = CE_none ());
      m.name <- h.name;
      (m :> CM_method)
    }

  cg_attrs (mods : list (Modifier)) : list (string)
    {
      def cg_attr (a : Modifier) : string {
        match (a) {
          | Mod_public => "public"
          | Mod_private => "private"
          | Mod_new => "new"
          | Mod_protected => "protected"
          | Mod_internal => "internal"
          | Mod_abstract => "abstract"
          | Mod_sealed => "sealed"
          | Mod_static => ""
          | Mod_struct => Util.ice ("FIXME: sorry, no structs yet")
          | Mod_module => ""
        }
      };
        
      List.map (cg_attr, mods);
    }

  make_static (m : CG_member) : void {
    m.attrs <- "static" :: m.attrs
  }

  cg_decl (decl : Class_member) : list (CG_member) {
    Util.locate (decl.loc, fun () : list (CG_member) {
      match (decl) {
        | M_value v => 
          def v' = lookup_value (v);
          match (v.kind) {
            | Val_normal =>
              [(v' : CG_member)]
            | Val_extern (n) =>
              v'.extern_name <- n;
              []
          }

        | M_field v => [(lookup_field (v) : CG_member)]

        | M_property v => [(lookup_property (v) : CG_member)]

        | M_function f =>
          match (f.body) {
            | FB_extern (n) =>
              def m = lookup_function (f.header);
              m.extern_name <- n; 
              []
            | FB_parsed_expr => Util.ice ()
            | FB_typed_expr (body) =>
              def decl = Env.global_by_id (f.id);
              CGexpr.closures <- [];
              def mem = cg_global_fun (empty_ctx (), decl, body);
              match (f.kind) {
                | FK_bound_method (impl) =>
                  def mkparm (ifp : CG_val, methp : CG_val) : CG_expr {
                    CE_cast (CE_ref (ifp), methp.ty)
                  };
                  def make_impl_wrapper (d : Decl) : CG_member {
                    match (d.kind) {
                      | D_class_member (M_function f) =>
                        def mem = (mem :> CM_method);
                        def m = cg_header (f.header);
                        m.body <- CE_call (CE_method_ref (CE_this (), mem),
                                           List.map2 (mkparm, m.parms, mem.parms));
                        m.name <- f.tyinfo.name + "." + f.name;
                        m
                      | _ => Util.ice ()
                    }
                  };
                  List.append (List.map (make_impl_wrapper, impl), 
                               mem :: CGexpr.closures)
                | _ => 
                  mem :: CGexpr.closures
              }
            | FB_abstract =>
              [(fixup_function (f) :> CG_member)]
          }
      }})
  }
  
  cg_list_decl (decls : list (Class_member)) : list (CG_member) {
    List.concat (List.map (cg_decl, decls))
  }
    
  cg_list_tydecl (decls : list (Tyinfo)) : list (CG_member)
    {
      def f (x : Tyinfo) : list (CG_member) {
        List.map (fun (x : CM_class) : CG_member { x }, cg_tydecl (x))
      };
      List.concat (List.map (f, decls))
    }

  set_extern_name (pref : string, decls : list (CG_member)) : void
    {
      def set_en (m : CG_member) : void 
        {
          if (m.extern_name == "")
            m.extern_name <- pref + m.name
          else ();
          match (m) {
            | CM_class c => set_extern_name (pref + c.name + ".", c.decls)
            | _ => ()
          }
        };
      List.iter (set_en, decls)
    }

  (** 
   * Generate code for given [Tyinfo] object and declarations within it.
   *
   * <remark>
   *   Type compilation is pretty straightforward.  Nemerle types
   *   mostly map to CIL types in 1:1 fashion.  We just drop type aliases.
   *
   *   FIXME: describe how variants are compiled.
   * </remark>
   *)        
  cg_tydecl (ti : Tyinfo) : list (CM_class)
    {
      def make_cm (decl : Tyinfo, kind : CM_kind) : CM_class
        {
          def r = lookup_class (decl);
          r.kind <- kind;
          r
        };

      def members = ti.member_list;
      
      match (ti.tydecl) {
        | TD_interface =>
          def mkmember (m : Class_member) : CG_member {
            match (m) {
              | M_function {kind = FK_iface_method (new_flag); header = h} =>
                def m = cg_header (h);
                if (new_flag) m.attrs <- "new" :: m.attrs else ();
                m
              | _ => Util.ice ()
            }
          };
          def cm = make_cm (ti, CK_interface ());
          cm.decls <- List.map (mkmember, members);
          [cm]

        | TD_variant =>
          def mkopt (m : Tyinfo) : CG_member {
            match (m.tydecl) {
              | TD_variant_option =>
                def cm = make_cm (m, CK_class ());
                cm.inheritance <- [cg_type (ti.generic_type ())];
                cm.decls <- cg_list_decl (m.member_list);
                cm
              | _ => Util.ice ()
            }
          };
          def cm = make_cm (ti, CK_class ());
          cm.decls <- List.map (mkopt, ti.contained_types);
          [cm]

        | TD_class =>
          def cm = make_cm (ti, CK_class ());
          cm.decls <- List.append (cg_list_tydecl (ti.contained_types), cg_list_decl (members));
          [cm]

        | TD_variant_option => Util.ice ()
          
        | TD_external => []
        // C# doesn't seem to provide typedef, not sure about CLS though
        | TD_alias => [] 

        | TD_macro => 
//        FIXME: here we must generate class implementing I_Macro interface using
//               stored function
          Util.ice ("we cannot generate code for macros yet")
      }
    }
  
  (** 
   * Generate code for all [Tyinfo] objects.
   *
   * <remarks>
   *   We define types and expressions flattened to CIL level in cgtree.n.
   * </remarks>
   *)
  public run () : list (CM_class)
  {
    mutable gres <- [];
  
    def run_cg_tydecl (decl : Tyinfo) : void {
      def set_ns (cmc : CM_class) : void {
        cmc.ns <- decl.env.current_namespace;
        set_extern_name (cmc.ns, [(cmc : CG_member)])
      };
      def res = Util.locate (decl.loc, 
        fun () : list (CM_class) { cg_tydecl (decl) });
      List.iter (set_ns, res);
      gres <- res :: gres
    };
    
    cg_members <- System.Collections.Hashtable (2000);
    Tyinfo.top_iter (run_cg_tydecl);
    List.concat (gres);
  }

} // end module
} // end ns
