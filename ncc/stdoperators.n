/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

module Operators {
  int_tc : Tycon;
  float_tc : Tycon;
  char_tc : Tycon;
  bool_tc : Tycon;
  enum_tc : Tycon;
  
  this () {
    int_tc <- GlobalEnv.LookupInternalType ("System.Int32");
    char_tc <- GlobalEnv.LookupInternalType ("System.Char");
    bool_tc <- GlobalEnv.LookupInternalType ("System.Boolean");
    float_tc <- GlobalEnv.LookupInternalType ("System.Single");
    enum_tc <- GlobalEnv.LookupInternalType ("System.Enum");
  }

  lookup_overloaded_operator (name : string, parms : list <Expr>)
  : option <PT.Expr>
  {
    mutable ret_name <- name;
    
    def collect (parm, acc) {
      match (Tyutil.top_expand (Tyexpr.type_of (parm))) {
        | T_app (tc, _) =>
          def is_op (m : IMember) {
            match (m.GetKind ()) {
              | MK_method => m.IsStatic ()
              | _ => false
            }
          };
          def loop (tc : Tycon) {
            // fscking special case, why there is no System.String.op_Addition ?
            def name =
              if (name == "op_Addition" && tc.GetFullName () == "System.String") {
                ret_name <- "Concat";
                "Concat"
              } else 
                name;
            match (List.Filter (tc.LookupMember (name), is_op)) {
              | [] =>
                match (tc.SuperClass ()) {
                  | Some (tc') => loop (tc')
                  | None => acc
                }
              | lst => List.Append (lst, acc)
            }
          };
          loop (tc)
        | _ => acc
      }
    };
    def collapse (mem : IMember, acc) {
      def tyname = mem.GetDeclaringTycon ().GetFullName ();
      match (acc) {
        | Some (tn) when tn == tyname => acc
        | Some (tn) =>
          Message.error (sprintf ("ambiguity resolution between `%s' from types `%s' and `%s'", 
                                  name, tn, tyname));
          acc
        | None => Some (tyname)
      }
    };
    match (List.FoldLeft (List.FoldLeft (parms, [], collect), None (), collapse)) {
      | Some (tn) =>
        def parms = List.Map (parms, fun (e) { 
          PT.Parm (false, <[ $(e : typed) ]>, PT.SS_string (PT.Name (""))) 
        });
        Some (<[ $(tn : dyn) . $(ret_name : dyn) (.. $parms ) ]>)
      | None => None ()
    }
  }

  try_emit_binary (name : string, arg_tc : Tycon, ret_tc : Tycon, e1 : Expr, 
                   e2 : Expr) : option <PT.Expr>
  {
    def type_of (e) { Tyutil.top_expand (Tyexpr.type_of (e)) };
    
    match ((type_of (e1), type_of (e2))) {
      | (T_app (tc, _), _) when arg_tc.SameAs (tc) 
      | (_, T_app (tc, _)) when arg_tc.SameAs (tc) =>
        def ret_type = T_app (ret_tc, []);
        def arg_type = T_app (arg_tc, []);
        def op_type = T_fun (T_prod ([arg_type, arg_type]), ret_type);
        
        Tyexpr.expect_type (sprintf ("left-hand side of the `%s' operator", name),
                            e1, arg_type);
        Tyexpr.expect_type (sprintf ("right-hand side of the `%s' operator", name),
                            e2, arg_type);
        
        Some (<[ $(E_call (e1.loc, ret_type, E_opcode (e1.loc, op_type, name), 
                       [Parm (false, e1, ""), Parm (false, e2, "")]) : typed) ]>)
      | _ => None ()
    }
  }

  type_of (e : Expr) : Type
  {
    Tyutil.top_expand (Tyexpr.type_of (e))
  }

  internal lookup_binary_compare_operator (ctx : TypingContext, 
                                           name : string, long_name : string, 
                                           e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);
   
    match (try_emit_binary (name, int_tc, bool_tc, e1, e2)) {
      | Some (ret) => ret
      | None =>
        match (try_emit_binary (name, char_tc, bool_tc, e1, e2)) {
          | Some (ret) => ret
          | None =>
            match (try_emit_binary (name, float_tc, bool_tc, e1, e2)) {
              | Some (ret) => ret
              | None =>
                match (lookup_overloaded_operator (long_name, [e1, e2])) {
                  | Some (expr) => expr
                  | None =>
                    Message.fatal_error (sprintf ("no match for binary operator `%s' taking %s and %s arguments",
                                                  name, type_of (e1).as_string (), type_of (e2).as_string ()));
                }
            }
        }
    }
  }

  internal lookup_binary_arithmetic_operator (_N_ctx : TypingContext, 
                                              name : string, long_name : string, 
                                              e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (_N_ctx, e1);
    def e2 = Tyexpr.ty_expr (_N_ctx, e2);
    
    match ((type_of (e1), type_of (e2))) {
      | (T_app (tc1, _), T_app (tc2, _)) 
        when int_tc.SameAs (tc1) && int_tc.SameAs (tc2) =>
        def int_type = <[ ttype: int ]>;

        match ((e1, e2)) {
          | (E_literal (L_int (x1)), E_literal (L_int (x2))) =>
            def val = 
              match (name) {
                | "+" => x1 + x2
                | "-" => x1 - x2
                | "/" => x1 / x2
                | "%" => x1 % x2
                | "*" => x1 * x2
                | _ => Message.fatal_error ("Unknown operator " + name)
              };
            <[ $(E_literal (loc, int_type, L_int (val)) : typed) ]>
          | _ =>
            Option.UnSome (try_emit_binary ("int32." + name, int_tc, int_tc, e1, e2))
        }

      | (T_app (tc1, _), T_app (tc2, _)) 
        when float_tc.SameAs (tc1) && float_tc.SameAs (tc2) =>
        def float_type = <[ ttype: float ]>;

        match ((e1, e2)) {
          | (E_literal (L_float (x1)), E_literal (L_float (x2))) =>
            def val = 
              match (name) {
                | "+" => x1 + x2
                | "-" => x1 - x2
                | "/" => x1 / x2
                | "*" => x1 * x2
                | _ => Message.fatal_error ("Unknown operator " + name)
              };
            <[ $(E_literal (loc, float_type, L_float (val)) : typed) ]>
          | _ =>
            Option.UnSome (try_emit_binary ("float32." + name, float_tc, float_tc, e1, e2))
        }

      | _ =>
        match (try_emit_binary ("int32." + name, int_tc, int_tc, e1, e2)) {
          | Some (ret) => ret
          | None =>
            match (lookup_overloaded_operator (long_name, [e1, e2])) {
              | Some (expr) => expr
              | None =>
                Message.fatal_error (sprintf (
                   "no match for binary operator `%s' taking %s and %s arguments",
                   name, type_of (e1).as_string (), type_of (e2).as_string ()));
            }
        }
    }
  }

  internal lookup_unary_arithmetic_operator (_N_ctx : TypingContext, 
                                             name : string, long_name : string, 
                                             e1 : PT.Expr) : PT.Expr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (_N_ctx, e1);
    
    match (type_of (e1)) {
      | T_app (tc1, _) when int_tc.SameAs (tc1) =>
        def int_type = <[ ttype: int ]>;
        def op_type = <[ ttype: int -> int ]>;

        match (e1) {
          | E_literal (L_int (x)) =>
            def val = 
              if (name == "-") -x
              else x;
            <[ $(E_literal (loc, int_type, L_int (val)) : typed) ]>
          | _ =>
            <[ $(E_call (loc, int_type, E_opcode (loc, op_type, "int32." + name), 
                         [Parm (false, e1, "")]) : typed) ]>
        }

      | T_app (tc1, _) when float_tc.SameAs (tc1) =>
        def float_type = <[ ttype: float ]>;
        def op_type = <[ ttype: float -> float ]>;

        match (e1) {
          | E_literal (L_float (x)) =>
            def val = 
              if (name == "-") -x
              else x;
            <[ $(E_literal (loc, float_type, L_float (val)) : typed) ]>
          | _ =>
            <[ $(E_call (loc, float_type, E_opcode (loc, op_type, "float32." + name), 
                         [Parm (false, e1, "")]) : typed) ]>
        }
        
      | _ =>
        match (lookup_overloaded_operator (long_name, [e1])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error (sprintf ("no match for binary operator `%s' taking %s argument",
                                          name, type_of (e1).as_string ()));
        }
    }
  }

  internal lookup_enum_operator (ctx : TypingContext, 
                                 name : string, long_name : string, 
                                 e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    // FIXME: check for FlagsAttribute
    def is_enum (t) {
      match (t) {
        | T_app (tc, _) =>
          Option.IsSome (tc.SuperType (enum_tc))
        | _ => false
      }
    };

    def t1 = type_of (e1);
    def t2 = type_of (e2);

    if (is_enum (t1) || is_enum (t2)) {
      match (Tyutil.unify (t1, t2)) {
        | Some (subst) =>
          Tyvar.global_store (subst);
          def tc =
            match (Tyutil.top_expand (t1)) {
              | T_app (tc, _) => tc
              | _ => Util.ice ()
            };
          Option.UnSome (try_emit_binary (name, tc, tc, e1, e2))
        | None =>
          Message.fatal_error (sprintf (
             "the enum types %s and %s (on sides of `%s' operator) are not compatible",
             t1.as_string (), t2.as_string (), name));
      }
    } else {
      match (try_emit_binary ("int32." + name, int_tc, int_tc, e1, e2)) {
        | Some (ret) => ret
        | None =>
          match (lookup_overloaded_operator (long_name, [e1, e2])) {
            | Some (ret) => ret
            | None =>
              Message.fatal_error (sprintf (
                 "no match for binary operator `%s' taking %s and %s arguments",
                 name, t1.as_string (), t2.as_string ()));
          }
      }
    }
  }
  

  // == or !=
  internal lookup_equality_operator (_N_ctx : TypingContext, 
                                     name : string, long_name : string, 
                                     e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (_N_ctx, e1);
    def e2 = Tyexpr.ty_expr (_N_ctx, e2);

    match (lookup_overloaded_operator (long_name, [e1, e2])) {
      | Some (expr) => expr
      | None =>
        def t1 = type_of (e1);
        def t2 = type_of (e2);
        match (Tyutil.unify (t1, t2)) {
          | Some (subst) =>
            def ret_type = <[ ttype: bool ]>;
            def op_type = <[ ttype: $t1 * $t2 -> bool ]>;
            
            Tyvar.global_store (subst);
            // FIXME: check if value types, some bigger values types
            // FIXME: if references and not system.object -- emit warning
            <[ $(E_call (e1.loc, ret_type, E_opcode (e1.loc, op_type, name), 
                         [Parm (false, e1, ""), Parm (false, e2, "")]) : typed) ]>
          | None =>
            Message.fatal_error (sprintf (
               "the types %s and %s (on sides of `%s' operator) are not compatible",
               t1.as_string (), t2.as_string (), name));
        }
    }
  }

  internal cache_assign_expr (ctx : TypingContext, e : PT.Expr) : PT.Expr * PT.Expr {
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        def tmp = Macros.NewSymbol ();
        (<[ def $(tmp : var) = $obj ]>, <[ $(tmp : var).$mem ]>)
      | <[ $tab [$idx] ]> =>
        def (tmp1, tmp2) = (Macros.NewSymbol (), Macros.NewSymbol ());
        (<[ def ($(tmp1 : var), $(tmp2 : var)) = ($tab, $idx) ]>,
         <[ $(tmp1 : var) [$(tmp2 : var)] ]>)
      | _ => (<[ () ]>, e)
    }
  }
}

  macro @&& (e1, e2) 
  {
    <[ 
      match ($e1) {
        | false => false
        | _ => 
          match ($e2) { 
            | false => false
            | _ => true
          }
      }
    ]>
  }

  macro @|| (e1, e2) 
  {
    <[ 
      match ($e1) {
        | true => true
        | _ => 
          match ($e2) { 
            | true => true
            | _ => false
          }
      }
    ]>
  }

  macro @! (e)
  {
    def tval = Tyexpr.ty_expr (_N_ctx, e);
    def bool_ty = <[ ttype: bool ]>;
    def op_ty = <[ ttype: bool -> bool ]>;
    Tyexpr.expect_type ("negated value", tval, bool_ty);
    <[ $(E_call (e.loc, bool_ty, E_opcode (e.loc, op_ty, "bool.!"), 
                 [Parm (false, tval, "")]) : typed) ]>
  }

  macro @- (params args : array <expr>)
  {
    match (args.Length) {
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (_N_ctx, "-",
                                                    "op_UnaryMinus", args[0])

      | 2 =>
        Operators.lookup_binary_arithmetic_operator (_N_ctx, "-", "op_Subtraction", 
                                                     args[0], args[1])
      | _ => 
        Message.fatal_error ("the `-' operator can only take one or two parameters")
    }
  }

  macro @+ (params parms : array <expr>) 
  {
    match (parms.Length) {
      | 2 =>
        Operators.lookup_binary_arithmetic_operator (_N_ctx, "+", "op_Addition", 
                                                     parms[0], parms[1])
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (_N_ctx, "+",
                                                    "op_UnaryPlus", parms[0])
      | _ =>
        Message.fatal_error ("the `+' operator can only take one or two parameters")
    }
  }

  macro @* (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (_N_ctx, "*", "op_Multiply", 
                                                 e1, e2)
  }

  macro @/ (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (_N_ctx, "/", "op_Division", 
                                                 e1, e2)
  }

  macro @% (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (_N_ctx, "%", "op_Modulus", 
                                                 e1, e2)
  }
  
  macro @< (e1, e2)
  {
    Operators.lookup_binary_compare_operator (_N_ctx, "<", "op_LessThan", 
                                              e1, e2)
  }
  
  macro @> (e1, e2)
  {
    Operators.lookup_binary_compare_operator (_N_ctx, ">", "op_GreaterThan", 
                                              e1, e2)
  }
  
  macro @<= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (_N_ctx, "<=", "op_LessThanOrEqual", 
                                              e1, e2)
  }
  
  macro @>= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (_N_ctx, ">=", "op_GreaterThanOrEqual", 
                                              e1, e2)
  }
  
  macro @%| (e1, e2)
  {
    Operators.lookup_enum_operator (_N_ctx, "|", "op_BitwiseOr", e1, e2)
  }
  
  macro @%& (e1, e2)
  {
    Operators.lookup_enum_operator (_N_ctx, "&", "op_BitwiseAnd", e1, e2)
  }
  
  macro @== (e1, e2)
  {
    Operators.lookup_equality_operator (_N_ctx, "==", "op_Equality", e1, e2)
  }
  
  macro @!= (e1, e2)
  {
    Operators.lookup_equality_operator (_N_ctx, "!=", "op_Inequality", e1, e2)
  }

 
  macro @++ (e) {
    def (cached, safe) = Operators.cache_assign_expr (_N_ctx, e);
    <[ $cached; $safe <- $safe + 1 ]>
  }

  macro @-- (e) {
    def (cached, safe) = Operators.cache_assign_expr (_N_ctx, e);
    <[ $cached; $safe <- $safe - 1 ]>
  }
  
  macro @<-> (e1, e2)
  {
    def (cached1, safe1) = Operators.cache_assign_expr (_N_ctx, e1);
    def (cached2, safe2) = Operators.cache_assign_expr (_N_ctx, e2);    
    <[
      $cached1;
      $cached2;
      def _N_tmp = $safe1;
      $safe1 <- $safe2;
      $safe2 <- _N_tmp;
    ]>
  }
}
