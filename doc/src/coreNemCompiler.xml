<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Core Nemerle to Generic C# Compiler</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document will describe (in informal way, through examples)
        translation from Core-Nem to Generic C#. It should help understand
        semantics behind Core-Nem and explain the basis of the compiler.
	More detailed description of the compiler design and implementation
	will also be presented here.
      </p>
      <p>
        Generic C# is proposed extension to <a
        ref="http://www.csharp.net/">C#</a>
        language, which aims to add parametric polymorphism
        to the language. C# language is defined in <a
        ref="http://www.ecma-international.org/publications/standards/ECMA-334.HTM">ECMA
        334</a> specification (if you are going to use it consider <a
        ref="http://www.jaggersoft.com/csharp_standard/">this format</a>).
      </p>
    </body>
  </section>
  <section id="types">
    <title>Types</title>
    <body>
      <p>
        We first need to say how we translate builtin type constructs. All
        types we mention here are prefixed with <tt>Nemerle.</tt>.
      </p>
      <p>
        When tuple and/or function types will be included in CLR spec,
        this section will be modified to conform it.
      </p>
      <p>
        For now we assume <tt>TUPLE_LIMIT</tt> is <tt>30</tt>. This is
        going to be fixed once final specification is released, based
        upon empirical evidence.
      </p>
    </body>
    <subsection id="tuples">
      <title>Tuples</title>
      <body>
        <p>
          Tuple types are translated to <tt>Tuple<meta>N</meta></tt> where
          <meta>N</meta> &lt; <tt>TUPLE_LIMIT</tt>. For example <tt>int * int * string</tt>
          to <tt>Tuple3&lt;int, int, string></tt>. 
        </p>
        <p>
          Bigger tuples are translated to <tt>Tuple_More</tt> type,
          e.g. if <tt>TUPLE_LIMIT</tt> were <tt>2</tt>, then above example
          would look: <tt>Tuple_More&lt;int, Tuple2&lt;int, string>></tt>.
        </p>
        <p>
          Of course the real-world assumption is that nobody is going
          to use so long tuples, but they can probably appear in
          autogenerated code.
        </p>
        <p>
          Implementation of tuple types is:
        </p>
<code>
public struct Tuple<meta>N</meta>&lt;t1, t2, <meta>...</meta>, t<meta>N</meta>>
{
    public t1 f1;
    public t2 f2;
    // ...
    public t<meta>N</meta> f<meta>N</meta>;
    Tuple<meta>N</meta>(t1 i1, t2 i2, <meta>...</meta>, t<meta>N</meta> i<meta>N</meta>)
    {
        f1 = i1;
        f2 = i2;
        // ...
        f<meta>N</meta> = i<meta>N</meta>;
    }
}

public struct Tuple_More&lt;t_head, t_tail>
{
    public t_head head;
    public t_tail tail;

    Tuple_More(t_head h, t_tail t)
    {
        head = h;
        tail = t;
    }
}
</code>
      </body>
    </subsection>
    <subsection id="func-types">
      <title>Function types</title>
      <body>
        <p>
          If <meta>N</meta> &lt; <tt>TUPLE_LIMIT</tt>, then function type:
        </p>
<code>
<meta>t1</meta> * ... * <meta>tN</meta> -> <meta>tr</meta>
</code>
        <p>is translated to:</p>
<code>
Func<meta>N</meta>&lt;<meta>tr</meta>, <meta>t1</meta>, ..., <meta>tN</meta>>
</code>
        <p>
          If <meta>N</meta> >= <tt>TUPLE_LIMIT</tt>, then input tuple
          is translated as described in previous subsection, and entire
          function type is translated to:
        </p>
<code>
Func_Tuple&lt;<meta>tr</meta>, Tuple_More&lt;<meta>t1, ...</meta>>>
</code>
        <p>
          Implementation of function types:
        </p>
<code>
public interface Func<meta>N</meta>&lt;tr, t1, t2, <meta>...</meta>, t<meta>N</meta>>
{
        tr apply(t1, t2, <meta>...</meta>, t<meta>N</meta>);
}

public interface Func_Tuple&lt;tr, t>
{
        tr apply(t);
}
</code>
        <p>
          We could avoid having <tt>Func<meta>N</meta></tt> in favor of just
          <tt>Func_Tuple</tt> but we don't do it for performance reasons.
        </p>
      </body>
    </subsection>
  </section>
  <section id="type-decl">
    <title>Type declarations</title>
    <body>
      <p>
        Now we can say how various type declarations are translated into Generic C#.
      </p>
    </body>
    <subsection id="ifaces">
      <title>Interfaces</title>
      <body>
        <p>
          Interfaces are mostly translated as is, just changing syntax.
          Example:
        </p>
<code>
interface I_Set ['a]
        where 'a :> I_Comparable_To['a]
        implements I_Foo['a]
{
  add : 'a -> void;
  mem : 'a -> bool;
  fold : ('a * 'b -> 'b) * 'b -> 'b;
}
</code>
        <p>
          C#:
        </p>
<code>
interface I_Set&lt;A>
        where A : I_Comparable_To&lt;A>
        : I_Foo&lt;A>
{
  void add(A);
  bool mem(A);
  B fold&lt;B>(Nemerle.Func2&lt;B, A, B>, B);
}
</code>
      </body>
    </subsection>
    <subsection id="classes">
      <title>Classes</title>
      <body>
        <p>
          Class translation is pretty strightforward (well... Core-Nem types
          were desgined to make this translation easy). 
        </p>
<code>
type C['a] where 'a :> I['a]
  extends B[int]
  implements I1, I2['a]
C_cons {
   ref i : int;
       j : int;
       s : string;
   ref o : X;

   method foo () : int implements I1.m1, I2.m3 = ... ;
   method m2 () : string implements I1.m2 = ... ;
   method m4 () : float implements I2.m4 = ... ;
}
</code>
        <p>
          This example covers mostly everything you can do with classes
          in Core-Nem. It's translated to:
        </p>
<code>
class C&lt;A> where A : I&lt;A> 
  : B&lt;int>, 
    I1, 
    I2&lt;A>
{
  int i;
  int j;
  string s;
  X o;
 
  // for easy construction
  C(int ii, int jj, string ss, X oo)
  {
    i = ii;
    j = jj;
    s = ss;
    o = oo;
  }

  int foo() { ... }
  string m2() { ... }
  float m4() { ... }
  // we can do better then this at the level of CIL
  string I1.m1() { return foo(); }
  string I2.m3() { return foo(); }
}
</code>
      </body>
    </subsection>
    <subsection id="variant-types">
      <title>Variant types</title>
      <body>
        <p>
          Variant types are translated to subclasses. For example:
        </p>
<code>
interface I_Iter['a]
{
  iter : ('a -> unit) -> unit;
}

type list['a] 
  implements I_Iter
[
  | Cons { head : 'a; tail : list['a]; }
  | Nil {}
]
{
  method ['a] iter ... implements I_Iter.iter = ... ;
}
</code>
<code>
interface I_Iter&lt;A> {
  void iter(A);
}

abstract class list&lt;A> : I_Iter&lt;A>
{
  void iter(Func1&lt;void,A> f) { ... }
}

class Cons&lt;A> : list&lt;A>
{
  public A head;
  public list&lt;A> tail;
  public Cons(A h, list&lt;A> t)
  {
    head = h;
    tail = t;
  }
}

class Nil&lt;A> : list&lt;A>
{
  public Nil() {}
}
</code>
      </body>
    </subsection>
  </section>
  <section id="expr">
    <title>Expressions</title>
    <body>
      <p>
        Here we'll first explain concept of function closure and next
        describe how each expression <a
        ref="coreNemGrammar.html">grammar</a> construct translates
        to C#.
      </p>
    </body>
    <subsection id="closures">
      <title>Closures</title>
      <body>
        <p>
          Since we have higher order functions (functions that can take
          functions as parameters and return other functions, possibly
          constructed at runtime), it is not enough for function to be
          represented just by pointer to its code. Functional values
          need to carry both pointer to function code and pointer to
          environment. For example consider:
        </p>
<code>
value f : int -> (int -> int) =
  fun (x : int) : (int -> int) ->
    let g (y : int) : int = x + y in
    g
</code>
        <p>
          Here function <tt>f <meta>k</meta></tt> constructs function
          <tt>g</tt> that adds <meta>k</meta> to its argument and returns
          it. It is clear that function <tt>g</tt> cannot be represented
          just by pointer to it's code (we assumed code is static),
          since it doesn't know value of <tt>x</tt>.
        </p>
        <p> 
          The code above is translated to:
        </p>
<code>
class tmp_6234 {
  private class f_closure {
    public int x;
    public f_closure(int xx) { x = xx; }
  }

  private class g : Func1&lt;int,int> {
    public f_closure closure;
    public int apply(int y)
    {
      return closure.x + y;
    }
    public g(f_closure c) { closure = c; }
  }

  public Func1&lt;int,int> f(int x)
  {
    f_closure closure = new f_closure(x);
    return new g(closure);
  }
}
</code>
        <p>
          <tt>class f_closure</tt> in general case needs to be separate
          from <tt>class g</tt> since there can be more then one function
          that needs this closure.
        </p>
        <p>
          There are several possible optimizations. For example merging
          <tt>f_closure</tt> and <tt>g</tt> if there is just one
          lambda expression that needs closure, merging several lambda
          expressions in one class (only allowed if they take different
          number of arguments) and so on.
        </p>
      </body>
    </subsection>
    <subsection id="value-ref">
      <title>Value reference</title>
      <body>
        <p>
          Represented by plain ID in Core-Nem source code.
        </p>
        <ul>
          <li>
            Local value that is not in closure: maybe just some name mangling.
          </li>
          <li>
            Local value that is in closure: take it from closure.
          </li>
          <li>
            Global value -- just name mangling.
          </li>
        </ul>
      </body>
    </subsection>
    <subsection id="obj-cons">
      <title>Object construction</title>
      <body>
        <p>
          Represented as <tt>Foo { x = 1; y = 3; }</tt>. It's translated to
          plain constructor call (after argument reordering). For example:
          <tt>Foo_type(3,1)</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="method-call">
      <title>Method call</title>
      <body>
        <p>
          <tt>o # m (x, y)</tt> --> <tt>o.m(x, y)</tt>
        </p>
      </body>
    </subsection>
    <subsection id="function-call">
      <title>Function call</title>
      <body>
        <p>
          <tt>f (x, y)</tt> --> <tt>f (x, y)</tt>
        </p>
      </body>
    </subsection>
    <subsection id="assign">
      <title>Assignment</title>
      <body>
        <p>
          <tt>x &lt;- y</tt> --> <tt>x = y</tt>
        </p>
      </body>
    </subsection>
    <subsection id="let">
      <title><tt>let</tt> binding</title>
      <body>
        <p>
          <tt>let</tt> both with and without <tt>ref</tt> is translated
          to variables, except when in closures. For example:
        </p>
<code>
let x = 1 in 
let ref y = 2 in
let ref z = 3 in
y &lt;- x
</code>
<code>
int x = 1;
closure.y = 2;
int z = 3;
closure.y = x;
</code>
        <p>
          Type of variable can be always easily determined in bottom up manner.
        </p>
      </body>
    </subsection>
    <subsection id="let-func">
      <title><tt>let</tt> binding for functions</title>
      <body>
        <p>
          At the beginning of function translation it is scanned to see
          which <tt>let</tt> bound values and formal parameters are used
          in local functions. Then closure is created.
        </p>
        <p>
          Then local functions are translated to nested classes, conforming
          <tt>Func<meta>N</meta></tt> interfaces, as seen in 
          <a ref="#closures">above</a>.
        </p>
      </body>
    </subsection>
    <subsection id="match">
      <title><tt>match</tt> expression</title>
      <body>
        <p>
          It's translated to sequence of <tt>if</tt> expressions.
          TODO: example.
        </p>
      </body>
    </subsection>
    <subsection id="exceptions">
      <title>Exception handling expressions</title>
      <body>
        <p>
          <tt>raise</tt> is translated to <tt>throw</tt> directly.
        </p>
        <p>
          <tt>try ... with</tt> is translated to <tt>try ... catch (...)</tt>.
          TODO: example.
        </p>
      </body>
    </subsection>
    <subsection id="tymatch">
      <title><tt>tymatch</tt> expression</title>
      <body>
        <p>
          It's translated to sequence of calls to CLI <tt>System.Reflection</tt>
          functions. TODO: find out more about it. TODO: example.
        </p>
      </body>
    </subsection>
  </section>
    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
