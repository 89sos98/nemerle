\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\kw}[1]{{\textcolor{kwcolor}{\tt #1}}}

\definecolor{kwcolor}{rgb}{0.2,0.4,0.0}
\definecolor{lgray}{rgb}{0.8,0.8,0.8}

\title{Nemerle}
\author{Micha{\l} Moskal}
\institute{Computer Science Institute, University of Wroc{\l}aw, Poland \\ 
Second ROTOR Workshop 2005, Redmond, WA}
\date{September 20, 2005}


\begin{document}

\section{Introduction}

\frame{\titlepage}

\frame{
\frametitle{Nemerle features}
\begin{itemize}
  \item very high--level, statically typed programming languages
    \begin{itemize}
      \item object--oriented, functional, imperative
      \item type inference
      \item pattern matching
     \end{itemize}
  \item since the beginning designed for the \net
  \item familiar, C\#--like syntax
  \item Turing-complete macros
  \item assertion system
\end{itemize}
}

\section{Reasons}


\frame{
\frametitle{Why \net\ ?}

\begin{itemize}
  \item wide variety of libraries
  \item multi--language paradigm
  \item runtime environment (GC, JIT)
  \item portable executable files (Microsoft \net, Mono, DotGNU, Rotor)
  \item dynamic class loading
  \item dynamic code generation
\end{itemize}
}

\frame{
\frametitle{Why a new language, from a user perspective?}

\begin{itemize}
  \item combining object--oriented and functional programming
  \begin{itemize}
    \item familiar, C\#--like, object--oriented top--level program structure
          (classes, interfaces)
    \item methods can implemented in a functional style
    \item easy access to imperative features
    \item we end up creating Extended C\#
  \end{itemize}
  \item code maintenance -- type inference, macros
  \item macros!
\end{itemize}
}

\frame{
\frametitle{Why a new language, from a computer scientist perspective?}
\begin{itemize}
  \item experimentation
  \begin{itemize}
    \item meta--programming system
    \item type inference algorithms
    \item programming language design
    \item .NET code generation using S.R.E. API
    \item stress testing generics
  \end{itemize}
\end{itemize}
}

\section{Language}

\frame{
\frametitle{What about the language?}

\begin{itemize}
  \item syntax reassembles C\#, especially at the class and method level
  \item expressions syntactically from C, semantically from ML
  \begin{itemize}
    \item no statements -- just expressions
    \item pattern matching on variant types
    \item functions as first class citizens
  \end{itemize}
\end{itemize}
}

\frame[containsverbatim]{
\frametitle{Type inference with deferral}

\begin{itemize}
  \item my MSc thesis :-)
  \item cannot type bottom up:
\begin{verbatim}
   def call_foo (x) { x.foo () }
   someList.Iter (call_foo)
\end{verbatim}
  \item and:
\begin{verbatim}
   def my_add (x, y) { x + y }
   my_add (2, 3)
\end{verbatim}
  \item solution: defer member/overload resolution until more information is known
\end{itemize}
}


\section{Macros}
\frame{
\frametitle{Macros}
\begin{itemize}
  \item dynamically loaded compiler modules (no connection with CPP!)
  \item transform, generate and analyse programs
  \item can extend syntax of the language
  \item can interact with type inference
  \item written in Nemerle
  \item work on syntax trees of expressions and types
  \item can read external files, query database etc.
\end{itemize}
}


\frame{
\frametitle{Uses of macros}
\begin{itemize}
  \item specialized sublanguages ({\tt printf}, {\tt scanf}, regular expressions,
    SQL, XML, XPath)
  \item generation of syntax trees out of external files and {\it vice versa} 
       (Yacc, Burg, types from DTD, documentation generation)
  \item generating trees from other trees (serialization, specialization of code)
  \item assertion system
  \item \textit{Aspect Oriented Programming}
\end{itemize}
}

\frame[containsverbatim]{
\frametitle{Example use of macro}
This macro checks syntax and type validity of a query at compile-time
(by connecting to a database). It creates code, which uses {\tt SqlParameter}
to pass value of {\it myval} to {\tt SqlCommand} securely.

\begin{verbatim}
def myval = "Kate";
SqlLoop ("SELECT * FROM employee WHERE"
         " firstname = $myval", dbcon, 
{
  printf ("%s %s\n", firstname, lastname)
});
\end{verbatim}
}


\section{The project}

\frame{
\frametitle{Compiler}

\begin{itemize}
  \item bootstrapping
  \item generates and consumes generics
  \item CLS producer
  \item 0.9.0 release, for August CTP and Mono 1.1.9
  \item issue tracker -- 500 issues total, 50 still open
\end{itemize}
}


\frame{
\frametitle{Projects using Nemerle}

\begin{itemize}
  \item Sioux -- HTTP/application server (founded from the grant)
  \item cs2n -- C\# to Nemerle converter (founded from the grant)
  \item nemish -- Nemerle Interactive Shell
  \item Speagram TRS programming system
  \item Asper IDE/editor
  \item Code Completion Engine
\end{itemize}
}


\frame{
\frametitle{Impact and community}

\begin{itemize}
  \item .NET runtime issues:
  \begin{itemize}
     \item several SRE issues reported to MSDN Product Feedback and
           one serious issue with static field initialization in generic classes
     \item even more issues reported to the Mono team (the runtime is much less
           stable)
  \end{itemize}
  \item mailing list (70 subscribers)
  \item online forum (recently started)
  \item online course will start around October 1st
  \item completed regular course at II
\end{itemize}
}


\section{Summary}
\frame{
\frametitle{Status}

\begin{itemize}
  \item 1.0 stable release approaching
  \item \textcolor{blue}{\tt http://nemerle.org/}
\end{itemize}
}


\end{document}

% vim: language=english
