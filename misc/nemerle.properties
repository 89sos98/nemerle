# Define SciTE settings for nemerle files.

# sma files are Small script (C-like)
filter.nemerle=Nemerle code |*.n|
file.patterns.nemerle=*.n
lexer.$(file.patterns.nemerle)=cpp
#lexer.*.n=nemerle
#file.patterns.n=*.n
#file.patterns.n.like=$(file.patterns.n)

#filter.n =Nemerle (n)|\
#$(file.patterns.n)|

file.patterns.braces=$(file.patterns.nemerle)

#lexer.$(file.patterns.n)= NEMERLE
default.file.ext = *.n

keywords.$(file.patterns.nemerle)= abstract and array as base catch def do \
else event extern false finally for foreach fun if implements in internal lock \
match mutable namespace new null out override params private protected public \
ref sealed static this throw true try type typeof unless using \
virtual when where while assert ignore _ testt

#types
keywords2.$(file.patterns.nemerle)= bool byte char decimal double enum float int \
long sbyte short struct uint ushort ulong \
object string void class interface delegate module variant syntax macro

#keywords3 doesn't seem to work...
#keywords3.$(file.patterns.nemerle)= 

#style of keywords
style.cpp.5=fore:#0000FF,bold
#style of keywords2
style.cpp.16=fore:#FF0000,bold
#style of keywords3
#style.cpp.17=fore:#0000FF


word.chars.nemerle=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.nemerle)=$(word.chars.nemerle)
#comment.block.nemerle=//~
#comment.block.at.line.start.cpp=1
comment.stream.start.nemerle=/*
comment.stream.end.nemerle=*/
comment.box.start.nemerle=/*
comment.box.middle.nemerle= *
comment.box.end.nemerle= */
fold.comment=1
fold.preprocessor=1
#fold.at.else=1

statement.indent.$(file.patterns.nemerle)=4 case catch class default do else finally \
for if private protected public struct try union while match module
statement.end.$(file.patterns.nemerle)=10 ;
statement.lookback.$(file.patterns.nemerle)=20
block.start.$(file.patterns.nemerle)=10 {
block.end.$(file.patterns.nemerle)=10 }

#autocomplete.*.fillups=(

autocompleteword.automatic=1

#styling.within.preprocessor=1
#preprocessor.symbol.$(file.patterns.nemerle)=#
#preprocessor.start.$(file.patterns.nemerle)=if ifdef ifndef
#preprocessor.middle.$(file.patterns.nemerle)=else elif
#preprocessor.end.$(file.patterns.nemerle)=endif

#default.file.ext=.n

#braces.check =1
#braces.sloppy=1

line.margin.visible=1

#configuration of default tools: Compile, Build, Go
#Go means Compile and Run
#Compile means "make windows debug version"
#Build means "make windows relase version"
#make sure the right path to the ncc.exe file.
command.compile.*.n=C:\Program Files\Nemerle\ncc.exe -no-color -debug -r System.Windows.Forms -target:winexe $(FileNameExt) -o $(FileName).exe
command.compile.subsystem.*.n = 1
command.build.*.n=C:\Program Files\Nemerle\ncc.exe -no-color -r System.Windows.Forms -target:winexe $(FileNameExt) -o $(FileName).exe
command.build.subsystem.*.n = 1
command.go.*.n=$(FileName).exe
command.go.subsystem.*.n=1
command.quiet.go.*.n=1
command.go.needs.*.n=C:\Program Files\Nemerle\ncc.exe -no-color -debug -r System.Windows.Forms -target:winexe $(FileNameExt) -o $(FileName).exe
command.go.needs.subsystem.*.n=1

#Extra tool: Console Compile
#Console Compile means "make console debug version"
command.name.0.*.n=Console Compile
command.0.*.n=C:\Program Files\Nemerle\ncc.exe -no-color -debug -r System.Windows.Forms $(FileNameExt) -o $(FileName).exe
command.0.subsystem.*.n = 0
command.save.before.0.*.n = 1
command.shortcut.0.*.n=Ctrl+Shift+F7

#Extra tool: Console Build
#Console Compile means "make console relase version"
command.name.1.*.n=Console Build
command.1.*.n=C:\Program Files\Nemerle\ncc.exe -no-color -r System.Windows.Forms $(FileNameExt) -o $(FileName).exe
command.1.subsystem.*.n=0
command.save.before.1.*.n=1
command.shortcut.1.*.n=Shift+F7

#Extra tool: Run
#Run means "Run last compiled file"
command.name.2.*.n=Run Last Build/Compiled
command.2.*.n=$(FileName).exe
command.2.subsystem.*.n=1
command.save.before.2.*.n=2
command.shortcut.2.*.n=Shift+F5

command.help.*.n=$(SciteDefaultHome)\sdk.bat
command.help.subsystem = 1

#Api loading
#api.*.n=net.api;nemerle.api

calltip.*.parameters.start = (
calltip.*.parameters.end = )
calltip.*.parameters.separator = ,
#calltip.*.end.definition = )
calltip.back=#FFFFF0