(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *) 


(* Requires $nempath/lib/hashtable.n, $nempath/lib/list.n and $nempath/lib/option.n *)

// NO-TEST
open System;
open System.Diagnostics;
open System.ComponentModel;
open System.IO;
open System.Text.RegularExpressions;
open System.String;
open Nemerle.Collections;
open Nemerle.Collections.List;

//TODO: Make INPUT sections

public class End_test extends System.Exception
{
	public this()
		{}
}

public class Tester{

	private _dnet_runtime:string;
	private _nem_runtime:string;
	private _csc_runtime:string;
	private _no_test_regexp:Regex;
	private _bo_regexp:Regex;	
	private _eo_regexp:Regex;
	private _err_regexp:Regex;
	private _warn_regexp:Regex;
	private _ok_regexp:Regex;
	private mutable _no_test:bool;
	private mutable _filename:string;
	private mutable _checked_msg:Hashtable(string,string);
	private mutable _warn_lines:Hashtable(string,Regex);
	private mutable _err_lines:Hashtable(string,Regex);
	private mutable _err_overall_count:int;
	private mutable _ok_lines:Hashtable(string,string);
	private mutable _is_reading_output:bool;
	private mutable _expected_output:list(string);
	private mutable _was_output:bool;
	private mutable _error_log:StreamWriter;
	private mutable _was_error_header:bool;


 public this(dnet_runtime:string,nem_comp:string,csc_comp:string)
	{

		this._dnet_runtime<-dnet_runtime;
		this._nem_runtime<-nem_comp;
		this._csc_runtime<-csc_comp;
		this._no_test_regexp<-Regex("//\\s*NO-TEST");
		this._bo_regexp<-Regex("^BEGIN-OUTPUT");	
		this._eo_regexp<-Regex("^END-OUTPUT");		
		this._err_regexp<-Regex("//\\s*E:\\s*(?<1>.*)$");
		this._err_overall_count<-0;
		this._warn_regexp<-Regex("//\\s*W:\\s*(?<1>.*)$");
		this._ok_regexp<-Regex("//\\s*OK\\s{0,1}.*$");
		this._error_log<-null;
		this.Init("");
		
 }



 private Init(filename:string):void
	{
	this._checked_msg<-Hashtable();
	this._filename<-filename;
	this._warn_lines<-Hashtable();
	this._err_lines<-Hashtable();
	this._ok_lines<-Hashtable();
	this._is_reading_output<-false;
	this._expected_output<-Nil();
	this._was_output<-false;
	this._no_test<-false;
	this._was_error_header<-false;
	()
	}

 private CheckLine(str:string,line_index:int):void		
	{

		if (this._eo_regexp.IsMatch(str))
		   {
			this._is_reading_output<-false;
			()
		   }
		else
		if (this._is_reading_output)
			{
			 this._expected_output<-(str::(this._expected_output));
			}
		 else 
		 {
		def _err_match=this._err_regexp.Match(str);
		if (_err_match.Success)
		   {
			this._err_lines.Add(string_of_int(line_index),Regex((_err_match.Groups[1]).ToString()));
			()
		   }
		else
		 {
		def _warn_match=this._warn_regexp.Match(str);
		if (_warn_match.Success)
		   {
			this._warn_lines.Add(string_of_int(line_index),Regex(_warn_match.Groups[1].ToString()));
			()
		   }
		else
		if (this._bo_regexp.IsMatch(str))
		   {
			this._is_reading_output<-true;
			this._was_output<-true;
			()
		   } 
		else
		if (this._ok_regexp.IsMatch(str))
		   {
			this._ok_lines.Add(string_of_int(line_index),"");
			()
		   }
		else
		if (this._no_test_regexp.IsMatch(str))
			raise End_test()
		else
		 ()
		}
		}			
	}

 private GetLineAndMsgType(out_str:string):int*string
	{
	  def out_line_match=(Regex(""+this._filename+":(?<1>\\d*):\\d*:\\s+(?<2>.*)$")).Match(out_str);
	  if (out_line_match.Success){
	  def line_number=((out_line_match.Groups[1]).ToString());
	  def msg_type_str=((out_line_match.Groups[2]).ToString());
	  if (msg_type_str.IndexOf("error:")!=(-1))
		(0,line_number)
	   else
	   if (msg_type_str.IndexOf("warning:")!=(-1))
		(1,line_number)
	   else
	        (-1,line_number)
	  }
	   else
	{
	  (-1,"")
	}
	}

 private HandleMsg(out_str:string):bool
	{
	  match (this.GetLineAndMsgType(out_str)){
		| (0,line) => 	 match (this._err_lines.Get(line)){
				| Some (err) => if(err.Match(out_str).Success&&(!this._checked_msg.Contains(line)))
						 this._checked_msg.Add(line,"")
						else
						();
						true					
				| None => 
				 if ((this._err_lines.Count())==0){
					false
					}
				 else
				 {
				  match (this._ok_lines.Get(line)){
					| Some (_) => false
					| None => true
					}
				 }
				}
		| (1,line) =>  	 match (this._warn_lines.Get(line)){
				| Some (warn) => if (warn.Match(out_str).Success&&(!this._checked_msg.Contains(line)))
						  this._checked_msg.Add(line,"")
						else 
						 ();
						true
				| None => (this._warn_lines.Count()!=0)
				 }
		| _ => true
		}		 
	}

 private NemerleTest():bool
	{
	
	mutable nem_compile<-Process();
	if (this._dnet_runtime.Length>0){
	 nem_compile.StartInfo.FileName<-this._dnet_runtime;
	 nem_compile.StartInfo.Arguments<-(this._nem_runtime+" ../../lib/core.n ../../lib/aliases.n ../../lib/list.n "+this._filename)
	} else {
	nem_compile.StartInfo.FileName<-(this._nem_runtime);
	nem_compile.StartInfo.Arguments<-("../../lib/core.n ../../lib/aliases.n ../../lib/list.n "+this._filename);
	};
	nem_compile.StartInfo.RedirectStandardOutput<-true;
	nem_compile.StartInfo.UseShellExecute<-false;
// TODO:Errors errors errors ;)
	try {
 		def _=nem_compile.Start();
	mutable nem_output<-nem_compile.StandardOutput.ReadLine();
	nem_compile.WaitForExit();
	mutable is_ok<-true;
	while(nem_output != null)
	{
	   if (this.HandleMsg(nem_output))
		()
		else {
		this.HandleErrorMsg("Unexpected Nemerle compiler's message:\n"+nem_output);
		is_ok<-false
		};
	   nem_output<-nem_compile.StandardOutput.ReadLine()
	}; 

	def Check(line:string,msg:Regex):void
		{
		  match (this._checked_msg.Get(line)){
		  | Some (_) => ()
		  | None => this.HandleErrorMsg("Expected error: \""+msg.ToString()+"\" hasn't occured in line: "+line);
		 	 is_ok<-false
			}
		};
	this._err_lines.Iter(Check);
	def Check(line:string,msg:Regex):void
	 {
		  match (this._checked_msg.Get(line)){
		  | Some (_) => ()
		  | None => this.HandleErrorMsg("Expected warning: \""+msg.ToString()+"\" hasn't occured in line: "+line);
		 	 is_ok<-false
			}
	};
	this._warn_lines.Iter(Check);
	is_ok
	}
	with { err:Win32Exception  =>
		this.HandleErrorMsg("Error occured while running Nemerle compiler");
		false
		}
    }

 private TestOutput():bool
	{
	try 
	{
	 mutable runtime<-Process();
	if (this._dnet_runtime.Length>0){
	 runtime.StartInfo.FileName<-this._dnet_runtime;
	 runtime.StartInfo.Arguments<-"./out.exe";
	} else {
	 runtime.StartInfo.FileName<-"./out.exe";
	 runtime.StartInfo.Arguments<-"";
	};
	 runtime.StartInfo.RedirectStandardOutput<-true;
  	 runtime.StartInfo.UseShellExecute<-false;
	def _=runtime.Start();
	runtime.WaitForExit();
	def CheckOutput(in_list:list(string),output:string,is_ok:bool):bool
		{
		  match((in_list,output)){
		  | (Nil,null) => is_ok
		  | (Nil,_) => this.HandleErrorMsg("Runtime output is longer than it should be");
				false
		  | (_,null) => this.HandleErrorMsg("Unexpected end of runtime output");
				false
		  | (h::tl,str) => if (h.Equals(str))
					CheckOutput(tl,runtime.StandardOutput.ReadLine(),is_ok)
				   else
					{
					this.HandleErrorMsg("Runtime output: \""+str+"\"\ndoes not match expected: \""+h+"\"");
					CheckOutput(tl,runtime.StandardOutput.ReadLine(),false) 
					}		
		   }
		};
	CheckOutput(this._expected_output,runtime.StandardOutput.ReadLine(),true)
	}
	with {err:Win32Exception =>
		this.HandleErrorMsg("Error occured while running the program");
		false
		}
	}

 private HandleErrorMsg(str:string):void
	{
		print_endline(str);
		if (this._error_log==null){
		 this._error_log<-File.CreateText("test_error.log");
		}
		else
		();
		if (!this._was_error_header){
		this._error_log.WriteLine("-------------------------");
		this._error_log.WriteLine("Test of "+this._filename);
		this._error_log.WriteLine("-------------------------");
		this._was_error_header<-true
		} else
		();
		this._error_log.WriteLine(str);
		this._error_log.WriteLine("-------------------------")
	}

 public AttachFile(filename:string):void
	{
	  try {	
		if (File.Exists(filename))
		 {
		
		this.Init(filename);
		def reader=File.OpenText(filename);
		mutable temp_str<-reader.ReadLine();
		mutable index<-1;	
		while(temp_str != null)
		 {
		   this.CheckLine(temp_str,index);
		   index<-index+1;
		   temp_str<-reader.ReadLine()
		 };
		reader.Close();
		this._expected_output<-List.rev(this._expected_output);
		 ()
		}
		else
		 ()
	  } with {
		|err:End_test => 
		this._no_test<-true;
		|err:Exception =>
		this.HandleErrorMsg("Error occured while reading the file")
		}
	}

 public Test():void 
	{
	print_endline("Testing..."+this._filename);
	if (this._no_test)
		print_endline("Test skipped")
	else 
	{
	try
	{
	if (this.NemerleTest()){
		if (this._err_lines.Count()==0)
		{
		try {
		def csc_compile=Process();
		csc_compile.StartInfo.FileName<-(this._csc_runtime);
		csc_compile.StartInfo.RedirectStandardOutput<-true;
		csc_compile.StartInfo.UseShellExecute<-false;
		if (this._was_output)
		csc_compile.StartInfo.Arguments<-("/out:out.exe /nowarn:162 /nowarn:649 /nowarn:219 out.cs")
		else
		csc_compile.StartInfo.Arguments<-("/out:"+this._filename.Substring(0,this._filename.Length-2)+".netmodule /target:module /nowarn:162 /nowarn:649 /nowarn:219 out.cs");
		def _=csc_compile.Start();
		def _=csc_compile.WaitForExit();
		if (csc_compile.ExitCode==0)
		 {
		   if (this._was_output)
			{
		    	if(this.TestOutput())
			  print_endline("Test passed")
			else
			  this.HandleErrorMsg("Runtime test failed")
			}
			else {
			print_endline("Test passed")
			 }
		}
	       	else
		   {
		   this.HandleErrorMsg("C# compilation failed");
		   this._err_overall_count<-this._err_overall_count+1
		   }
		} with {err:Win32Exception => 
		this.HandleErrorMsg("Error occured while running C# compiler")
		}
		}
		 else
		print_endline("Test passed")
	}
	else
	{
		this.HandleErrorMsg("Nemerle compile test failed");
		this._err_overall_count<-this._err_overall_count+1
	};
	()
	}
	with {err:Win32Exception => 
		this.HandleErrorMsg("Error occured while running Nemerle compiler")
		}
	}
	}

 public GetReport():int
	{
	 if(this._error_log!=null){
		this._error_log.Close();
		this._error_log<-null
	} else
	();
	 if(this._err_overall_count==0){
	   print_endline("All tests passed");
	   0
	}
	 else{
	   print_endline(string_of_int(this._err_overall_count)+" of tests failed\nSee test_error.log file for details");
	   1
	}
	}

 public static Main (args : array(string)): int 
	{ 
// TODO: Do it more elegant :)
		mutable dnet_env <- "";
		mutable nem_comp <- "../ncc2.exe";
		mutable csc_comp <- "mcs";
		mutable count<-args.Length;
		mutable cmd_str <- "";
		while(count>0){
		cmd_str<-args[count-1]+" "+cmd_str;
		count<-count-1;
		};
		def regexp = Regex("-r\\s{0,1}(?<1>\\w+)\\s");
		def reg_match= regexp.Match(cmd_str);
		if (reg_match.Success){
		  dnet_env<-reg_match.Groups[1].ToString();
		} else
		();
		def regexp = Regex("-n\\s{0,1}(?<1>\\w+)\\s");
		def reg_match= regexp.Match(cmd_str);
		if (reg_match.Success){
		  nem_comp<-reg_match.Groups[1].ToString();
		} else
		();	
		def regexp = Regex("-c\\s{0,1}(?<1>\\w+)\\s");
		def reg_match= regexp.Match(cmd_str);
		if (reg_match.Success){
		  csc_comp<-reg_match.Groups[1].ToString();
		} else
		();
		def tester = Tester(dnet_env,nem_comp,csc_comp);
		def str = Directory.GetFiles(Directory.GetCurrentDirectory(),"*.n");
		mutable fcounter<- ((str:Array).Length-1);

		while(fcounter>=0)
		{
// For Windows compatibility:
		  tester.AttachFile(str[fcounter].Replace("\\","/"));
		  tester.Test();
		  fcounter<-fcounter-1
		};
		tester.GetReport()
	}

}
