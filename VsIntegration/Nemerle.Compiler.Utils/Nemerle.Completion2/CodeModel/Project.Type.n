using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;

using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Utils;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Utility;
using Nemerle.Imperative;

using SCG = System.Collections.Generic;

namespace Nemerle.Completion2
{
  public partial class Project
  {
    public static TopKeywords : array[CompletionElem] { get { Engine.TopKeywords } }
    
    /// Complete word inside the method.
    CompleteInType(
      @type     : Decl.Type,
      _fileIndex : int,
      line      : int,
      col       : int, 
      source    : ISource
    )
      : array[CompletionElem]
    {
      CompleteInTopDeclaration(@type.Ast, source, line, col)
    }

    CompleteInTopDeclaration(
      tyAst  : TopDeclaration,
      source : ISource,
      line   : int,
      col    : int, 
    )
      : array[CompletionElem]
    {
      unless (tyAst.Location.Contains(line, col))
        return TopKeywords;

      // комлешон возможен в:
      // 1. Модификаторах.
      // 2. Кастом-атрибутах.
      // 3. Описании списка базовых типов.
      // 4. Теле.
      // 5. В ограничениях (where ...)

      if (tyAst.BodyInnerLocation.Contains(line, col)) // complete in body...
      {
        def members = tyAst.GetMembers();
        
        match (members.Find(m => m.Location.Contains(line, col)))
        {
          | Some(member) => Complete(member, source, line, col)
          | _ => TopKeywords
        }
      }
      else
      {
        if (tyAst.modifiers.CustomAttributesLocation.Contains(line, col))
        {
          //TODO: Реализовать дополнение в кастом-атрибутах!
          TopKeywords;
        }
        else
        {
          def modifiersLoc = tyAst.Location.FromStart() + tyAst.NameLocation.FromStart();

          if (modifiersLoc.Contains(line, col))
            TopKeywords //TODO: Возвратить список модификторов!
          else
          {

            def extendsLoc = tyAst.NameLocation.FromEnd() + tyAst.BodyLocation.FromStart();

            if (extendsLoc.Contains(line, col))
              TopKeywords //TODO: Реализовать дополнение для типов!
            else
              TopKeywords
          }
        }
      }
    }

    Complete(member : ClassMember, source : ISource, line : int, col : int) : array[CompletionElem]
    {
      def modsAndAttrsLoc = member.Location.FromStart() + member.NameLocation.FromStart();

      if (modsAndAttrsLoc.Contains(line, col))
        CompleteInMemberHeader(member, source, line, col)
      else match (member)
      {
        | ClassMember.Property        as prop   => CompleteInProperty(prop, source, line, col)
        | ClassMember.Function        as func   => CompleteInFunction(func, source, line, col)
        | ClassMember.Event           as aEvent => CompleteInEvent(aEvent, source, line, col)
        | ClassMember.Field           as field  => CompleteInField(field, source, line, col)
        | ClassMember.TypeDeclaration(td)       => CompleteInTopDeclaration(td, source, line, col)
        | ClassMember.EnumOption                => TopKeywords //TODO: Реализовать дополнение в EnumOption!
      }
    }

    CompleteInMemberHeader(_member : MemberBase, _source : ISource, _line : int, _col : int) : array[CompletionElem]
    {
      TopKeywords //TODO: Реализовать дополнение в заголовках!
    }

    CompleteInProperty(prop : ClassMember.Property, source : ISource, line : int, col : int) : array[CompletionElem]
    {
      match (prop)
      {
        | ClassMember.Property(get = Some(f)) when f.BodyInnerLocation.Contains(line, col) 
        | ClassMember.Property(set = Some(f)) when f.BodyInnerLocation.Contains(line, col) =>
          CompleteInFunction(f, source, line, col)

        | _ => this.Engine.CompleteInMember(prop.Env, source, prop.Builder.DeclaringType, prop.Location, line, col);
      }
    }

    CompleteInField(field : ClassMember.Field, source : ISource, line : int, col : int) : array[CompletionElem]
    {
      def fieldBuilder = field.Builder;

      if (fieldBuilder.InitializerLocation.Contains(source.FileIndex, line, col))
        CompleteInBody(fieldBuilder.LookupInitializerMethod(), fieldBuilder.InitializerLocation, source, line, col)
      else
        this.Engine.CompleteInMember(field.Env, source, fieldBuilder.DeclaringType, field.Location, line, col);
    }

    CompleteInEvent(prop : ClassMember.Event, source : ISource, line : int, col : int) : array[CompletionElem]
    {
      match (prop)
      {
        | ClassMember.Event(add    = f) when f.BodyInnerLocation.Contains(line, col) 
        | ClassMember.Event(remove = f) when f.BodyInnerLocation.Contains(line, col) =>
          CompleteInFunction(f, source, line, col)

        | _ => TopKeywords
      }
    }

    CompleteInFunction(func : ClassMember.Function, source : ISource, line : int, col : int) : array[CompletionElem]
    {
      if (func.BodyInnerLocation.Contains(line, col))
        CompleteInBody(func.Builder, func.BodyInnerLocation, source, line, col)
      else
        this.Engine.CompleteInMember(func.Env, source, func.Builder.DeclaringType, func.Location, line, col);
    }

    CompleteInTypeRef(env : GlobalEnv, tyLoc : Location, source : ISource, line : int, col : int) : array[CompletionElem]
     {
      def lexer = this.Engine.GetLexer(source, tyLoc);
      def toks = lexer.ReadAllTokens();

      when (toks.Length < 1 || !(toks[0] is Token.Operator(":")))
        return TopKeywords;

      def whereIndex = toks.FindIndex(tok => tok is Token.Keyword("where"));
      def endLoc     = if (whereIndex >= 0) toks[whereIndex].Location.FromStart() 
                       else toks.NLast().Location;
      def startLoc   = toks[0].Location.FromEnd();
      def loc        = startLoc + endLoc;
      def text       = source.GetRegion(loc);
      def result     = this.Engine.CompleteInTypeExpr(env, text, loc, line, col);
      result
    }

    CompleteInBody(methodBuilder : MethodBuilder, bodyInnerLocation : Location, source : ISource, line : int, col : int) : array[CompletionElem]
    {
      def loc = bodyInnerLocation;
      def bodyCode = source.GetRegion(loc.Line, loc.Column, loc.EndLine, loc.EndColumn);
      def result   = Engine.RunCompletionEngine(methodBuilder, bodyCode, loc, line, col);
      if (result == null)
      {
        Trace.WriteLine("### RunCompletionEngine() return null!");
        Engine.ExpressionDefaultKeywords
      }
      else
        Engine.MakeCompletionList(result, true);
    }


    // ---------------------------------------------------------------------------------------------------------------

    public FindObjectEverywhere(
      typeDecl  : Decl.Type,
      fileIndex : int,
      line      : int,
      col       : int,
      unpackMemberRefs = true
    )
      : Location * object * object
    {
      def res = FindObject(typeDecl, fileIndex, line, col);
      when (res[1] != null || res[2] != null)
        return res;
    
      def checkType(pexpr, texpr : TyVar) 
      {
        def pargs =
          match (pexpr)
          {
          | PExpr.Array  (_, p)          => [p]
          | PExpr.Call   (_, p)
          | PExpr.Indexer(_, p)
          | PExpr.GenericSpecifier(_, p) => p
          | _                            => []
          }

        match (pargs.Find((p) => p.Location.Contains(line, col)))
        {
        | Some(p) =>
            def targs =
              match (texpr)
              {
              | mType is MType =>
                match (mType)
                {
                | MType.Array (p, _) => [p]
                | MType.Fun   (f, t) => [f, t]
                | MType.Class (_, p)
                | MType.Tuple (p)    => p
                | _                  => []
                }
              | _                    => []
              };

            def idx = pargs.IndexOf(p);
            checkType(p, targs.Nth(idx))

        | _       => (pexpr.Location, null, texpr)
        }
      }
      def getMethod(method)
      {
        def ast = method.Ast;

        // Body must be processed first.
        if (ast.header.Location.Contains(line, col))
        {
          if (ast.header.ParsedSplicableName.Location.Contains(line, col))
            (ast.header.ParsedSplicableName.Location, ast, method)
          else if (ast.header.ParsedReturnType.Location.Contains(line, col))
            checkType(ast.header.ParsedReturnType, method.ReturnType);
          else if (ast.modifiers.custom_attrs.OrderedContains(line, col))
          {
            // PB06116: TODO: CustomAttributes
            //
            (Location.Default, null, null)
          }
          else
          {
            def getParam(pparms, tparms)
            {
              match (pparms)
              {
              | []     => (Location.Default, null, null)
              | p :: _ =>

                if (p.name.Location.Contains(line, col))
                  (p.name.Location, p.name, tparms.Head)
                else if (p.Type.Location.Contains(line, col))
                  checkType(p.Type, tparms.Head.ty)
                else
                  getParam(pparms.Tail, tparms.Tail)

              }
            }

            getParam(ast.header.ParsedParameters, method.Header.parms);
          }
        }
        else
        {
          def typarms = ast.header.ParsedTypeParameters;

          if (typarms.tyvars.OrderedContains(line, col))
            match (typarms.tyvars.Find(t => t.Location.Contains(line, col)))
            {
            | Some(t) => (t.Location, null, method.Header.typarms.Nth(typarms.tyvars.IndexOf(t)))
            | _       => (Location.Default, null, null)
            }
          else
          {
            def res = 
            {
              def found = ExprFinder().FindEverywhere(method.BodyParsed, method.BodyTyped, line, col, unpackMemberRefs);
              def (loc, _, typedObject) = found;

              def getParameterNumber(name, parameters, i = 0)
              {
                | (_, parameter :: tail, _) =>
                  if (parameter.Name == name)
                    i
                  else
                    getParameterNumber(name, tail, i + 1)
                | (_, [], _) => -1
              }

              match (typedObject)
              {
                | reference is LocalValue when (reference.ValKind is LocalValue.Kind.FunParm) =>
                  def function = reference.DefinedIn;
                  def number = getParameterNumber(reference.Name, function.ParametersDeclarations);
                  if (number < 0)
                    found
                  else
                  {
                    def parsedParameter = function.ParametersDeclarations.Nth(number);
                    def typedParameter = function.parms.Nth(number);
                    (loc, parsedParameter.name, typedParameter)
                  }
                | ty is TExpr.This | ty is TExpr.Base => (loc, null, ty.MType())
                | _ => found
              }
            }
            
            when (res[1] != null || res[2] != null)
              return res;
              
            // Covarian/Contravariant constraints breaks OrderedContains optimization
            // so process them one-by-one.
            //
            def constraints = typarms.constraints.RevFilter(c => !Utils.IsSpecialConstraint(c.ty));

            match (constraints.Find(c => c.ty.Location.Contains(line, col)))
            {
            | Some(c) =>

              def tyVarConstraints = constraints.Filter(tc => tc.tyvar.Equals(c.tyvar));
              def typarm = method.Header.typarms.Nth(typarms.tyvars.IndexOf(c.tyvar));

              Debug.Assert(tyVarConstraints.Length == typarm.Constraints.Length);
              (c.ty.Location, null, typarm.Constraints.Nth(tyVarConstraints.IndexOf(c)))

            | _       =>           (Location.Default, null, null)
            }
          }
        }
      }

      def typeBuilder = typeDecl.Ast.TypeBuilder;
      if (typeBuilder.IsDelegate) FindObject(typeDecl, fileIndex, line, col)
      else
      {
        def members = typeBuilder.GetMembers();
        
        foreach (member in members)
        {
          | mb is MethodBuilder   =>
           	when (mb.Name == "IndxEntry__StImpl") 
           	{
           	  assert2(true);
           	}
            def res = getMethod(mb);
            when (res[1] != null || res[2] != null)
              return res;
              
          | _ => ()
        }
        
        (Location.Default, null, null)
      }
    }

    /// Finds an object by provided location.
    /// Returns object location * associated Parsetree * associated Typedtree
    private FindObject(
      typeDecl  : Decl.Type,
      fileIndex : int,
      line      : int,
      col       : int,
      unpackMemberRefs = true
    )
      : Location * object * object
    {
      when (typeDecl.Ast != null && typeDecl.Ast.TypeBuilder == null)
        return (typeDecl.Ast.Location, null, typeDecl.Ast);

      def typeBuilder = typeDecl.Ast.TypeBuilder;
      def member      = 
        if (typeBuilder.IsDelegate) typeBuilder : IMember
        else typeBuilder.GetMemberByLocation(fileIndex, line, col) ?? typeBuilder;

      def checkType(pexpr, texpr : TyVar) 
      {
        def pargs =
          match (pexpr)
          {
          | PExpr.Array  (_, p)          => [p]
          | PExpr.Call   (_, p)
          | PExpr.Indexer(_, p)
          | PExpr.GenericSpecifier(_, p) => p
          | _                            => []
          }

        match (pargs.Find((p) => p.Location.Contains(line, col)))
        {
        | Some(p) =>
            def targs =
              match (texpr)
              {
              | mType is MType =>
                match (mType)
                {
                | MType.Array (p, _) => [p]
                | MType.Fun   (f, t) => [f, t]
                | MType.Class (_, p)
                | MType.Tuple (p)    => p
                | _                  => []
                }
              | _                    => []
              };

            def idx = pargs.IndexOf(p);
            checkType(p, targs.Nth(idx))

        | _       => (pexpr.Location, null, texpr)
        }
      }

      def getMethod(method)
      {
        def ast = method.Ast;
        def headerLocation = ast.header.Location;
        def bodyLocation = method.BodyLocation;

        // Body must be processed first.
        //
        if (method.IsBodyCompilable 
            && (bodyLocation.Contains(line, col) || bodyLocation.IsGenerated))
        {
          def found = ExprFinder().Find(method.BodyParsed, method.BodyTyped, line, col, unpackMemberRefs);
          def (loc, _, typedObject) = found;
/*
          def getParameter(name, parsedParameters, typedParameters)
          {
            match (parsedParameters)
            {
              | parameter :: tail =>
                if (parameter.Name == name)
                  (parameter.name.Location, parameter.name, typedParameters.Head)
                else
                  getParameter(name, tail, typedParameters.Tail)
              | [] => found
            }
          }

          match (typedObject)
          {
            | reference is LocalValue when (reference.ValKind is LocalValue.Kind.FunParm) =>
              getParameter(reference.Name, ast.header.parms, method.Header.parms);
            | _ => found
*/

          def getParameterNumber(name, parameters, i = 0)
          {
            | (_, parameter :: tail, _) =>
              if (parameter.Name == name)
                i
              else
                getParameterNumber(name, tail, i + 1)
            | (_, [], _) => -1
          }

          match (typedObject)
          {
            | reference is LocalValue when (reference.ValKind is LocalValue.Kind.FunParm) =>
              def function = reference.DefinedIn;
              def number = getParameterNumber(reference.Name, function.ParametersDeclarations);
              if (number < 0)
                found
              else
              {
                def parsedParameter = function.ParametersDeclarations.Nth(number);
                def typedParameter = function.parms.Nth(number);
                (loc, parsedParameter.name, typedParameter)
              }
            | ty is TExpr.This | ty is TExpr.Base => (loc, null, ty.MType())
            | _ => found
          }
        }
        else if (headerLocation.Contains(line, col) || headerLocation.IsGenerated)
        {
          if (ast.header.ParsedSplicableName.Location.Contains(line, col))
            (ast.header.ParsedSplicableName.Location, ast, method)
          else if (ast.header.ParsedReturnType.Location.Contains(line, col))
            checkType(ast.header.ParsedReturnType, method.ReturnType);
          else if (ast.modifiers.custom_attrs.OrderedContains(line, col))
          {
            // PB06116: TODO: CustomAttributes
            //
            (Location.Default, null, null)
          }
          else
          {
            def getParam(pparms, tparms)
            {
              match (pparms)
              {
              | []     => (Location.Default, null, null)
              | p :: _ =>

                if (p.name.Location.Contains(line, col))
                  (p.name.Location, p.name, tparms.Head)
                else if (p.Type.Location.Contains(line, col))
                  checkType(p.Type, tparms.Head.ty)
                else
                  getParam(pparms.Tail, tparms.Tail)

              }
            }

            getParam(ast.header.ParsedParameters, method.Header.parms);
          }
        }
        else
        {
          def typarms = ast.header.ParsedTypeParameters;

          if (typarms.tyvars.OrderedContains(line, col))
            match (typarms.tyvars.Find(t => t.Location.Contains(line, col)))
            {
            | Some(t) => (t.Location, null, method.Header.typarms.Nth(typarms.tyvars.IndexOf(t)))
            | _       => (Location.Default, null, null)
            }
          else
          {
            // Covarian/Contravariant constraints breaks OrderedContains optimization
            // so process them one-by-one.
            //
            def constraints = typarms.constraints.RevFilter(c => !Utils.IsSpecialConstraint(c.ty));

            match (constraints.Find(c => c.ty.Location.Contains(line, col)))
            {
            | Some(c) =>

              def tyVarConstraints = constraints.Filter(tc => tc.tyvar.Equals(c.tyvar));
              def typarm = method.Header.typarms.Nth(typarms.tyvars.IndexOf(c.tyvar));

              Debug.Assert(tyVarConstraints.Length == typarm.Constraints.Length);
              (c.ty.Location, null, typarm.Constraints.Nth(tyVarConstraints.IndexOf(c)))

            | _       =>           (Location.Default, null, null)
            }
          }
        }
      }

      def checkMethods (methods)
      {
        | hd :: tail =>
          if (hd != null && hd.BodyLocation.Contains(line, col))
            getMethod(hd)
          else
            checkMethods(tail)
        | []         => (Location.Default, null, null)
      }

      def processMember(member : IMember)
      {
        | mb is MethodBuilder   => getMethod(mb)
        | eb is EventBuilder    => 

            if (eb.Ast.ty.Location.Contains(line, col))
              checkType(eb.Ast.ty, eb.GetMemType())
            else if (eb.Ast.name.Location.Contains(line, col))
              (eb.Ast.name.Location, null, eb)
            else
              checkMethods([eb.GetAdder(), eb.GetRemover()])

        | fb is FieldBuilder    => 

          if (typeBuilder.IsEnum)
            if (fb.Attributes %&& NemerleAttributes.SpecialName)
              (Location.Default,     null, null)
            else
              (fb.Location,          null, fb)
          else
            if (fb.Ast.ty.Location.Contains(line, col))
              checkType(fb.Ast.ty, fb.GetMemType())
            else if (fb.Ast.name.Location.Contains(line, col))
              (fb.Ast.name.Location, null, fb)
            else if (fb.InitializerLocation.Contains(line, col))
              getMethod(fb.LookupInitializerMethod())
            else
              (fb.Location,          null, fb)

        | pb is PropertyBuilder => 

            if (pb.Ast.ty.Location.Contains(line, col))
              match (pb.GetMemType())
              {
              // Indexer
              //
              | f is MType.Fun => checkType(pb.Ast.ty, f.to)

              // Regular prop
              //
              | t              => checkType(pb.Ast.ty, t)
              }
            else if (pb.Ast.name.Location.Contains(line, col))
              (pb.Ast.name.Location, null, pb)
            else
            {
              def parms = pb.Ast.dims;

              match (parms.Find(p => p.Type.Location.Contains(line, col)))
              {
              | Some(p) => checkType(p.Type, pb.GetParameters().Nth(parms.IndexOf(p)))
              | _       => checkMethods([pb.GetGetter() :> MethodBuilder, pb.GetSetter() :> MethodBuilder])
              }
            }

        | tb is TypeBuilder     => 

          def lookupType(p)
          {
          | PExpr.Ref (name) =>
              match (name.context.LookupType([name.Id], tb, -1))
              {
              | Some(ty) => (p.Location, null, ty)
              | _        => (Location.Default, null, null)
              }
          | PExpr.Indexer(obj, args) =>
              match ((obj :: args).Find(a => a.Location.Contains(line, col)))
              {
              | Some (p) => lookupType(p)
              | _        => (Location.Default, null, null)
              }
          | _        => (Location.Default, null, null)
          }

          def processAst (tb, ast)
          {
            match (ast)
            {
            | TopDeclaration.Class    (extends, _)
            | TopDeclaration.Variant  (extends, _)
            | TopDeclaration.Interface(extends, _) =>

              // Remove compiler generated base type or interface
              //
              def extends = extends.Filter(cls => !cls.Location.IsGenerated);

              def typarms = ast.typarms;

              if (extends.OrderedContains(line, col))
                match (extends.Find(t => t.Location.Contains(line, col)))
                {
                | Some(p) => lookupType(p)
                | _       => (Location.Default, null, null)
                }
              else if (typarms.tyvars.OrderedContains(line, col))
                match (typarms.tyvars.Find(t => t.Location.Contains(line, col)))
                {
                | Some(t) => (t.Location, null, tb.Typarms.Nth(typarms.tyvars.IndexOf(t)))
                | _       => (Location.Default, null, null)
                }
              else
              {
                // Covariant/Contravariant constraints breaks OrderedContains optimization
                // so process them one-by-one.
                //
                match (typarms.constraints.Find(c => c.ty.Location.Contains(line, col)))
                {
                | Some (c) => lookupType(c.ty)
                | _        => (ast.PName.Location, null, tb : object)
                }
              }
            | _ => (ast.PName.Location, null, tb : object)
            }
          }

          match (tb.AstParts.Find(part => part.Location.Contains(fileIndex, line, col)))
          {
          | Some(ast) => processAst (tb, ast)
          | _         => (Location.Default, null, null)
          }

        | null                  => (Location.Default, null, null)
        | _                     => 
          Debug.Assert(false, $"Unknown member type '$member'.");
          throw System.Exception($"Unknown member type '$member'.");
      }
      
      def result = processMember(member);
      match (member, result)
      {
        | (mb is MemberBuilder, (_, null, null)) => mb.CallForAllRelated(processMember)
        | _ => 
          match (result)
          {
            //HACK: VladD2: The compiler not set information for static type ref in TExpr.StaticRef.
            | (_, PExpr.Member(pObj, _), TExpr.StaticRef(tObj, _, _)) 
              when pObj.Location.Contains(line, col) => 
              def tryFindNestedType(pObj, tObj : MType)
              {
                | (PExpr.Member(pObj, _), MType.Class(ti, tyArgs)) 
                  when ti.DeclaringType != null && pObj.Location.Contains(line, col) => 
                  tryFindNestedType(pObj, MType.Class(ti.DeclaringType, tyArgs))
                | _ => (pObj.Location, pObj, tObj)
              }
              
              tryFindNestedType(pObj, tObj)
              
            | _ => result
          }
      }
    }

    private FindPExprs(typeDecl  : Decl.Type, loc : Location) : list[PExpr]
    {
      def typeBuilder = typeDecl.Ast.TypeBuilder;
      
      when (typeBuilder.IsDelegate)
        return [];
        
      def member = typeBuilder.GetMemberByLocation(loc.FileIndex, loc.Line, loc.Column);
      def tryMethod(method : IMethod) : MethodBuilder
      {
        | m is MethodBuilder when m.BodyLocation.Contains(loc) => m
        | null | _ => null
      }
      def getMethod(member : IMember) : MethodBuilder
      {
        | mb is MethodBuilder   => mb
        | eb is EventBuilder    => tryMethod(eb.GetAdder()) ?? tryMethod(eb.GetRemover())
        | fb is FieldBuilder    => tryMethod(fb.LookupInitializerMethod())
        | pb is PropertyBuilder => tryMethod(pb.GetGetter()) ?? tryMethod(pb.GetSetter())
        | _tb is TypeBuilder    => assert2(false); null
        | _                     => null
      }
      def method  = getMethod(member);
      
      when (method == null || !method.BodyLocation.Contains(loc) && method.IsBodyCompilable)
        return [];
      
      method.EnsureCompiled();
      def exprs = SCG.HashSet();
      def walker = ExprWalker();
      def visit(info : ExprWalkInfo)
      {
        match (info.Node)
        {
          | expr is PExpr =>
            def find(expr)
            {
              when (expr.TypedObject is TExpr.MacroEnvelope(expandedPExpr = subExpr))
                walker.Walk(subExpr, visit);
              when (loc.Contains(expr.Location) && !expr.Location.IsGenerated)
                _ = exprs.Add(expr);
            }
            
            find(expr)
            
          | _ => ()
        }        
      }
      walker.Walk(method.BodyParsed, visit);
        
      def res = exprs.ToList();
      res
    }

    private GetTypeQuickTip(
      typeDecl  : Decl.Type,
      fileIndex : int,
      line      : int,
      col       : int,
      //2IT: практически любой класс в компиляторе содержит ссылку на ManagerClass.
      // По крайней мере MemberBuilder и TypeBuilder точно их имеют.
      // Так что этот параметр скорее всего ошибка.
      manager   : ManagerClass
    )
      : QuickTipInfo
    {
      def (loc, pObj, tObj) = FindObject(typeDecl, fileIndex, line, col, unpackMemberRefs = false);

      match (tObj)
      {
      | me is TExpr.MacroEnvelope         => (QuickTipInfo(loc, me))
      | lv is LocalValue                  => (QuickTipInfo(loc, lv))
      | mm is IMember                     => (QuickTipInfo(loc, mm, manager))
      | st is StaticTyVar                 => (QuickTipInfo(loc, st))
      | tv is TyVar                       => (QuickTipInfo(loc, tv))
      | tc is TExpr.ImplicitValueTypeCtor => (QuickTipInfo(loc, tc.ty))
      | fh is Typedtree.TFunHeader        => (QuickTipInfo(loc, fh))
      | fp is Typedtree.TParameter          => (QuickTipInfo(loc, fp))
      | p  is Pattern.Enum                => (QuickTipInfo(loc, p.fld, manager))
      | null                              => (null)
      | expr is TExpr                     => QuickTipInfo(loc, pObj, expr, manager)
#if DEBUG
      | o                                 => (QuickTipInfo(loc, o))
#else
      | _                                 => (null)
#endif
      }
    }

    GetMethodTip(
      typeDecl  : Decl.Type,
      fileIndex : int,
      line      : int,
      col       : int, 
      source    : ISource
    )
      : MethodTipInfo
    {
      def typeBuilder = typeDecl.Ast.TypeBuilder;
      def member      = typeBuilder.GetMemberByLocation(fileIndex, line, col);

      def getHintForMember(member : IMember)
      {
        | field  is FieldBuilder  => getHintForMember(field.LookupInitializerMethod())
        | method is MethodBuilder => 

          def loc = method.BodyLocation;
          
          if (loc.Contains(line, col)) // completion in method body
          {
            def timer    = Stopwatch.StartNew();
            def bodyCode = source.GetRegion(loc.Line, loc.Column, loc.EndLine, loc.EndColumn);
            def finder   = TokenFinder();
            def tokens   = finder.Find(method.BodyTokens, line, col);

            Debug.WriteLine($"Comlete took $(timer.Elapsed)");

            def findMethodNameToken(tokens)
            {
              | (Token.RoundGroup as parms) :: (Token.Identifier as id) :: _ 
                          => Some((id, parms))
              | _ :: tail => findMethodNameToken(tail)
              | []        => None()
            }

            match (findMethodNameToken(tokens))
            {
              | Some((id, paramsGroup)) =>
                def name = id.name;
                def locName = id.Location;
                def result = Engine.RunCompletionEngine(
                  method, bodyCode, loc, locName.EndLine, locName.EndColumn);

                if (result != null)
                {
                  def overloads = List();

                  def cmpName(m : IMethod)
                  {
                    if (m.Name == ".ctor" || m.Name == "..ctor")
                      m.DeclaringType.Name == name
                    else
                      m.Name == name
                  }

                  foreach (elem in result.Elems)
                  {
                    | Overloads(values) =>
                      foreach (overload in values)
                        match (overload.Member)
                        {
                          | m is IMethod when cmpName(m) => overloads.Add(overload);
                          | _            => ()
                        }
                    
                    | Local(func) when func.Name == name => 
                      def tip = LocalFuncMethodTipInfo(func, id, paramsGroup);
                      return if (tip.HasTip) tip else null;
                      
                    | _ => ()
                  }

                  if (overloads.Count > 0)
                  {
                    overloads.Sort((x, y) =>
                      {
                        def xparms = (x.Member :> IMethod).GetParameters();
                        def yparms = (y.Member :> IMethod).GetParameters();

                        xparms.Length - yparms.Length;
                      });
                    
                    def paramsCount(param, count = 0)
                    {
                      if (param == null) count
                      else paramsCount(param.Next, count + 1)
                    }
                    
                    def paramsCnt = paramsCount(paramsGroup.Child);
                    def res = overloads.FindAll(o => (o.Member :> IMethod).GetParameters().Length == paramsCnt);
                    
                    def defaultMethodIndex = 
                      if (res.Count == 1)
                          overloads.FindIndex(o => (o.Member :> IMethod).GetParameters().Length == paramsCnt)
                      else
                      {
                        def (_loc, _pexpr, texpr) = 
                          this.FindObject(typeDecl, locName.FileIndex, locName.EndLine, 
                            locName.EndColumn, true);
                          
                        overloads.FindIndex(o => o.Member == texpr);
                      };
                    
                    def tip = OverloadsMethodTipInfo(overloads, id, paramsGroup, defaultMethodIndex);
                    if (tip.HasTip) tip else null
                  }
                  else
                    (null)
                }
                else (null)

              | None => (null)
            }
          }
          else
          {
            if (method.Ast.header.Location.Contains(line, col))
            {
              (null)
            }
            else
              (null)
          }

        | null => (null)
        | _    => throw System.Exception($"Unknown member type '$member'.");
      }

      getHintForMember(member)
    }
  }
}
