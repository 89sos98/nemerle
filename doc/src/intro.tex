\documentclass[draft,11pt]{article}
\usepackage[latin2]{inputenc}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{hcolor}
\usepackage{color}
\usepackage[a4paper, margin=3cm]{geometry}

\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\netf}[0]{{\tt .NET} framework}
\newcommand{\nem}[0]{Nemerle}
\newcommand{\cs}[0]{C\#}
\newcommand{\oo}[0]{object-oriented}
\newcommand{\kw}[1]{{\tt \bf #1}}

\DefineVerbatimEnvironment
  {Code}{Verbatim}
  {frame=lines,numbers=left,xleftmargin=15mm,%
   xrightmargin=10mm,framesep=2mm,framerule=1mm,%
   rulecolor=\color[rgb]{0.8,0.8,0.8}}

\begin{document}

\title{{\Huge \sc Nemerle} \\ 
  (Not) Yet Another Functional \net\ Language \\
  {\large \tt http://nemerle.org/}}
\author{Micha³ Moskal \\ {\small University of Wroc³aw}}
\date{\today}

\maketitle

\thispagestyle{empty}

\begin{abstract}
  \nem is a new functional language designed from the ground up for the \net.
  We have focused on features absent in traditional ML-like and \oo\ languages:
  variant inheritance, powerful assertions and code-generating macros. We also 
  gave some concern for the syntax and ``spirit'' of \nem\ that makes it a good
  transition language for programmers with \cs\ background.
\end{abstract}

\pagestyle{fancy}
\lhead{Micha³ Moskal -- \it Nemerle}
\rhead{\thepage}
\cfoot{}


\section{Motivation}

Our objective was to create a statically typed functional language with well 
founded \net\ \cite{CLI}\ interoperability. The \netf\ environment, especially 
since the introduction of generics \cite{Generics}, provides an excellent 
platform for high-level language implementation which:

\begin{itemize}
  \item comes with a rich class library in the core system
  \item gives access to vast cache of additional third party libraries
  \item provides automatic garbage collection and security features
  \item handles native code generation and low-level optimizations (JIT)
  \item guarantees portability of executables
  \item allows integration with existing development tools
  \item etc. etc.
\end{itemize}

Of course, the framework is heavily \oo\ and primarily focused on traditional
\oo\ and imperative languages. Therefore ports of the existing functional 
languages to the \net\ did not fit in as well, as for example, \cs\ \cite{CS}
does. Addressing this issue was the main idea behind the design of \nem.

The language is less ``pure'' then say Haskell \cite{Haskell} or SML \cite{SML},
allowing to create purely \oo\ and imperative programs. This makes \nem\ 
a good transition language for people previously using C-like imperative 
and \oo\ languages. They can use imperative features until they gradually 
learn how to program in functional fashion.

Easy access to imperative constructs is only one of the requirements needed 
in such a transition language. Probably the hardest thing about learning ML 
is understanding the compiler error messages about typing mismatches. This 
may seem odd at the first glance, but this is the reality -- type inference
is very nice when it works, but when it fails, you are stuck with error
messages hundred lines from place of the real error. 

We have considered avoiding constructs that produce typing errors in ML, while
generating syntax errors in other languages (for example function application 
being just $\epsilon$); making the typing more explicit, at least for global 
functions -- it is going to be needed anyway, as we need good support 
for methods overloading.

It seems easy to observe that it is the quality of the design of the \oo\ system 
to determine usability of a programming language. While existing \oo\ extensions 
to functional languages are appalling because of their elegance, they do not fit 
with the \netf\ at all. We have decided to make our \oo\ system simply mirror 
the \net\ design.

Let's put these pieces together and see how it works!


\section{Overview}

At the high level \nem\ can be characterized as a combination of \cs\
at the class level and ML at the expression level. However the syntax
of ML fragment is less ambiguous and more C-like than Algol-like.
The result is an expression-oriented language pretending to be \cs.

Of course we also need variants\footnote{Called datatypes in SML,
and sometimes sum types in Caml.}, pattern matching and functional
values. But these can be thought of as extensions to what the programmer
already knows.

There are some other facts about \nem\ that are implied by the 
``not-so-ML-like \net\ language'' paradigm:

\begin{itemize}
  \item Language is statically typed, but dynamic cast are available
        and can be used when needed.
  \item Language combines functional, \oo, and imperative features.
  \item Object system is one-to-one mapping of CLR's -- making it
        fairly easy to understand.
  \item Language fully interoperates with other \net\ languages -- it
        is both a CLS consumer and producer.
\end{itemize}

In the following sections we will show how the language looks like and
how is it different from ML and \cs. Reader is assumed to have some
basic knowledge about both ML and \cs.

It is important to mention that the language is still evolving and that
its design is quite flexible. Especially assertions and macros are 
relatively new features. We are open to any suggestions.


\section{The language}

Top-level program structure reassembles \cs. There are namespaces,
then classes and finally methods. We also have modules (classes with all
members static and public) and variants. Let us look at the famous example:

\begin{Code}
  class Hello {
    public static Main () : void {
      System.Console.WriteLine ("Hello world, my name is not Jan B.!");
    }
  }
\end{Code}

Another way to write it could be:

\begin{Code}
  open System.Console;

  module Hello {
    public Main () : void {
      WriteLine ("Hello cruel world.");
    }
  }
\end{Code}

The basic building block of a method is a sequence. A sequence groups local
definitions (done with the \kw{def} keyword), expressions computed for
side effects and the final expression returned as the value of entire
sequence\footnote{We put here value bindings and side-effect expressions
into one can. This is exactly how it works in imperative languages and 
(under the hood) in eager functional languages. It models real world
behavior better, and should be easier to understand.}.

\begin{Code}
public static factorial (x : int) : int {
  def loop (acc : int, x : int) : int {
    if (x <= 1) 
      acc
    else 
      loop (acc * x, x - 1)
  }
  loop (1, x)
}
\end{Code}

As you see both global and local functions are explicitly typed. This
is a limitation of current implementation. We plan to lift it, at least
for local functions.


\subsection{Mutable values}

Mutable local values are defined using declarations like 
\kw{mutable}\ $x$\ {\tt <-}\ $expression${\tt ;}. The value $x$ can be 
later used as a value bound with \kw{def} without any explicit dereference 
operator\footnote{Like the {\tt !} operator in ML.}, but can only be 
assigned using the assignment operator ({\tt <-}).

\begin{Code}
public static factorial (x : int) : int {
  mutable acc <- 1;
  mutable k <- n;
  while (k > 0) {
    acc <- acc * k;
    k <- k - 1;
  }
  acc
}
\end{Code}

The \kw{while} loop should be considered just different form of tail recursion:

\begin{Code}
public static factorial (x : int) : int {
  mutable acc <- 1;
  mutable k <- n;
  def loop () : void {
    if (k > 0) {
      acc <- acc * k;
      k <- k - 1;
      loop ()
    } else ()
  }
  loop ();
  acc
}
\end{Code}

The \kw{mutable} keyword can be also used as a modifier on fields. The contents
of such fields can be modified using the same assignment operator.


\subsection{Variants and pattern matching}

Variants are compiled to subclassing and should be thought of as subtypes.
For example:

\begin{Code}
variant list ('a) {
  | Cons { hd : 'a; tl : list ('a); }
  | Nil
}
\end{Code}

Is compiled to:

\begin{Code}
class list<A> {}
class Cons<A> : list<A> { A hd; list<A> tl; }
class Nil<A> : list<A> {}
\end{Code}

Of course we can use regular ML-like matching:

\begin{Code}
'a head (l : list ('a)) : 'a {
  match (l) {
    | Cons (x, _) => x
    | Nil => raise Invalid_argument ("List.head")
  }
}
\end{Code}

The \verb|'a| in front of \verb|head| quantifies following occurrences of
\verb|'a|.

There is one tricky thing about the 3rd line of our example. It could have
been written in any of the following ways:

\begin{Code}
  | Cons (x, _) => x
  | Cons c => c.hd
  | Cons { hd = x; } => x
  | Cons { hd = x; tl = _; } => x
\end{Code}

In fact when the compiler sees a tuple pattern and expects a record pattern,
the tuple is transformed into a record. It is therefore not as painful
to require variant members to be named.

It is also possible to have deep patterns like \verb,Foo (Bar (Baz)),
or to match real tuples.


\subsection{Variant inheritance}

The subtyping model allows the variants to carry slightly more
information then their ML counterparts. In particular it is possible to
make the variant base class have some fields, methods or even derive
from some other class.  This way all variant options can have some
common part. Example (taken from \nem\ compiler, which is written in
\nem\ itself):

\begin{Code}
class Located {
  file : string;
  line : int;
}

variant Expr extends Located {
  | E_call { fn : Expr; parms : list (Expr); }
  | E_ref { name : string; }
}

public static dump (e : Expr) : void {
  print ("// " + e.file + ": " + e.line.ToString ());
  match (e) {
    | E_ref r => print (r.name)
    | E_call c =>
      dump (c.fn);
      List.iter (dump, c.parms)
  }
}
\end{Code}


\subsection{Constrained parametric types}

Types can be parametrized over other types. Type arguments can be
constrained. This works the same as generics in IL. It is also possible 
to parametrize methods.

\begin{Code}
variant tree ('a) where 'a :> IComparable ('a) {
  | Node { 
      left : tree ('a); 
      data : 'a; 
      right : tree ('a); 
    }
  | Tip
}
\end{Code}

This is the \nem\ way to do things that would have been done with
functors in ML-like languages. It is not strictly as powerful, but 
seems to be good enough in practice and it integreates well with 
the \netf.


\section{Assertions}

\nem\ has several different kinds of assertions. The simplest one is much like
regular \verb,assert,\ call known from C or OCaml. It comes in two flavors:

\begin{itemize}
  \item \kw{require}\ that can come anywhere within a block
  \item \kw{ensure}\ that need to come at the end of a block and can
    use \kw{value}\ keyword to refer to the value of given block
\end{itemize}

\begin{Code}
public static factorial (x : int) : int {
  require { x >= 1 }
  
  def loop (acc : int, x : int) : int {
    require { x >= 1 }
    if (x <= 1) 
      acc
    else 
      loop (acc * x, x - 1)
  }
  
  loop (1, x)
  ensure { value >= x;
           x >= 3 == (value % 3 == 0) }
}
\end{Code}


\subsection{Assertions for mutables}

As we have a good support for mutable values, we also have special
assertions for mutables to express invariants. These also come in two
flavors:

\begin{itemize}
  \item mutable values \kw{guarded}\ with assertions -- update of this very 
        value triggers associated assertion
  \item \kw{guard} assertions that are checked after update of any value 
        directly referenced from the assertion body; checks are performed 
        until the end of the current block
\end{itemize}

It is possible to attach the \kw{guard}\ assertions to local values, instance
fields, and static fields (global values).

We sometimes want assertions like \verb,x + y == 5, to hold, with mutable
\verb,x, and \verb,y,. To allow update of \verb,x, immediately followed
by update of \verb,y, \kw{transaction} block is introduced. Assertions to
be triggered during the \kw{transaction} block are stacked, and executed
when control leaves it.

It is to be reconsidered when exactly we check assertions. Enforcing
check after each update can be hard in presence of parameters passed
by \kw{ref}.


\section{Macros}

Macros in \nem\ have much more to do with Meta Haskell \cite{MetaHaskell}, 
CamlP4 \cite{CamlP4} or the Lisp code-generating macros, then with macros 
in languages like C. Macros are essentially compiler plugins -- pieces 
of \nem\ code that take type or expression abstract syntax trees (AST) 
and return some other expressions or types (also as AST).

Macros are by definition Turing-complete\footnote{It is not by accident
like in some other languages :-)}. Macros can access external files,
can extract typing information from a running database and generally
do whatever you can imagine.

Macros are executed at the compilation time. The code they generate is later
statically type checked. Macros are thus safe. There is always risk that
macro will crash (or loop) during the compilation, but there is no way
to avoid that while retaining its expressiveness.

As said before macros are written in Nemerle itself. In principle it 
would be possible to use any other \net\ language, but \nem\ provides special
syntax to construct and walk its own AST. This special syntax could be
in fact implemented as a macro, at some later time.


\subsection{Usage}

Example uses of macros:

\begin{itemize}
  \item embedding special purpose sublanguages in \nem:
  \begin{itemize}
    \item \verb,printf,\ and \verb,scanf,\ like functions
    \item \verb,$,-interpolation like in Bourne shell or Perl
    \item binding results of SQL queries to local variables in type safe way
    \item special syntax for XPath or some other XML-matching constructions
    \item binding named groups in regular expression to local variables
  \end{itemize}

  \item generation of AST from external files
  \begin{itemize}
    \item Yacc and Burg-like tools
    \item generating types from XML schema or DTD
  \end{itemize}

  \item generation of external files based on AST

  \item generation of AST based on other AST
  \begin{itemize}
    \item generating XML serialization methods
    \item specialization of code at the source language level
  \end{itemize}
\end{itemize}


\subsection{Example: regular expression macro}

This macro extracts names of groups in regular expression and binds
groups resulting from matching to source language values. For example
it transforms following code:

\begin{Code}
parse_time (t : string) : int {
  rxmatch (t, "([0-9]+:hour):([0-9]+:minute)");
  hour * 60 + minute
}
\end{Code}

\noindent into following code:

\begin{Code}
parse_time (t : string) : int {
  def r = Regexp ("([0-9]+):([0-9]+)");
  def m = r.Matches (t);
  def hour = r [0];
  def minute = r [1];
  hour * 60 + minute
}
\end{Code}


\subsection{Example: SQL queries macro}

This macro requires an SQL parser, and access to database we are working on,
so that the types of table columns and stored functions can be determined. 
It is needed to determine types of SQL expressions, which can be later used
to produce source language bindings for values returned by SQL queries.

\begin{Code}
  sql_loop (conn, "SELECT salary, LOWER (name) AS lname"
                  "  FROM employees"
	  	            "  WHERE salary > $(min_salary * 3)",
	          print ("$lname : $salary\n"))
\end{Code}

And the result:

\begin{Code}
  def cmd = SqlCommand ("SELECT salary, LOWER (name)"
                        "  FROM employees"
		                    "  WHERE salary > @parm1", conn);
  cmd.Parameters.Add ("@parm1", min_salary * 3);
  def r = cmd.ExecuteReader ();
  while (r.Read ()) {
    def salary = r.GetInt32 (0);
    def lname = r.GetString (1);
    print ("$lname : $salary\n")
  }
\end{Code}

In fact in the 9th line of output we see another extension, that is translated to:

\begin{Code}
  System.Console.Write (lname.ToString ());
  System.Console.Write (" : ");
  System.Console.Write (salary.ToString ());
  System.Console.Write ("\n")
\end{Code}


\section{Summary}

We have shown the key points of a new functional language for the \netf.
The language combines mostly well known features in a unique fashion.
We believe it can be used to teach the basics of functional programming
and \net. We also hope it can be used outside academia as a real life,
industry language.

\newcommand{\bibent}[3]{\bibitem{#1} #2: {\it #3}.}
\newcommand{\bibweb}[2]{\bibitem{#1} {\tt #2}}

\begin{thebibliography}{9}
\bibent{Generics}{Andrew Kennedy, Don Syme}{Design and Implementation of Generics for 
the .NET Common Language Runtime}
\bibent{SML}{Robin Milner, Mads Tofte, Robert Harper}{The Definition of Standard ML}
\bibent{Haskell}{Simon Peyton Jones, John Hughes}{Report on the Programming Language Haskell 98}
\bibent{MetaHaskell}{Tim Sheard, Simon Peyton Jones}{Template metaprogramming for Haskell}
\bibent{CS}{International Organization for Standardization}{C\# Language Specification,
ISO/IEC 23270:2003}
\bibent{CLI}{International Organization for Standardization}{Common Language Infrastructure,
ISO/IEC 23271:2003}
\bibweb{CamlP4}{http://caml.inria.fr/camlp4/}
\end{thebibliography}

\end{document}
