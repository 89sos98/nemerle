(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

module Tyops {
  `/-` (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
  `>>` (x : Type, y : Type) : bool = extern "Nemerle.Compiler.Tyutil.subtypes";
}
  
type Subst = Int_map(Type);

module Tyutil {

  subst (t : Type, s : Subst) : Type
    {
      def self (t : Type) : Type = subst (t, s);
      match t with [
        | T_ref (t) => T_ref (self (t))
        | T_out (t) => T_out (self (t))
        | T_fun (tl, t) => T_fun (self (tl), self (t))
        | T_void => t
        | T_prod (tl) => T_prod (List.map (self, tl))
        | T_app (ti, args) =>
          T_app (ti, List.map (self, args))
        | T_var (tv) =>
           match s.find (tv.id) with [
             | Some (T_var (tv2)) => 
               if tv.id == tv2.id then Util.ice ()
               else ()
             | _ => ()
           ];
           match s.find (tv.id) with [
             | Some (t') => self (t') // fixpoint
             | None => t
           ] 
      ];
    }
  
  subst_of_app (t : Type) : Subst * Tyinfo =
    match t with [
      | T_app (ti, args) => (ti.make_subst (args), ti)
      | _ => Util.ice ()
    ];

  top_expand (t : Type) : Type 
    {
      def f (t : Type) : Type =
        match t with [
          | T_app =>
            def (sub, ti) = subst_of_app (t);
            match ti.tydecl with [
              | TD_alias (t) =>
                f (t /- sub)  // fixpoint iteration
              | _ => t
            ]
          | _ => t
        ];
        
      f (Tyvar.global_expand (t));
    }

  // t1 :> t2 (or t1 =? t2)
  unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst)
    {
      def sub1 (t : Type) : Type
        {
          def t = top_expand (t);
          match t with [
            | T_var (tv) =>
              match s.find (tv.id) with [
                | Some (t') => sub1 (t')
                | None => t
              ]
            | _ => t
          ]
        };
      //def sign = if allow_subtyping then " :> " else " =? ";
      //Message.debug ("unify " + string_of_type (t1) + sign + string_of_type (t2));
      def (t1, t2) = 
        match (t1, t2) with [
          | (T_var (tv1), T_var (tv2)) =>
            if tv1.id == tv2.id then (t1, t2)
            else (sub1 (t1), sub1 (t2))
          | _ => (sub1 (t1), sub1 (t2))
        ];
      //Message.debug ("  --> " + string_of_type (t1) + sign + string_of_type (t2));
      def unify_lists (s : Subst, t1 : list (Type), t2 : list (Type), 
                       allow_subtyping : bool) : option (Subst) =
        match (t1, t2) with [
          | (Cons (t1, ts1), Cons (t2, ts2)) =>
            match unify (s, t1, t2, allow_subtyping) with [
              | Some (s') => unify_lists (s', ts1, ts2, allow_subtyping)
              | None => None ()
            ]
          | (Nil, Nil) => Some (s)
          | _ => None ()
        ];
      
      def unify_with_tyvar (t1 : Type, t2 : Type) : option (Subst) =
        match t1 with [
          | T_var (tv) =>
            if Tyvar.is_free (tv) then {
              def check_constraint (s : option (Subst), c : Type) : option (Subst) =
                match s with [
                  | None => None ()
                  | Some (s) => unify (s, t2, c, true)
                ];
              List.fold_left (check_constraint, Some (s.add (tv.id, t2)),
                              Tyvar.constraints (tv))
            } else None ()
          | _ => None ()
        ];
        
      def fallback (t1 : Type, t2 : Type) : option (Subst) =
        match unify_with_tyvar (t1, t2) with [
          | Some (s) => Some (s)
          | None => unify_with_tyvar (t2, t1)
        ];
      
      match (t1, t2) with [
        | (T_ref (t1), T_ref (t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_out (t1), T_out (t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_prod (l1), T_prod (l2)) => 
          unify_lists (s, l1, l2, allow_subtyping)
        | (T_void, T_void) => Some (s)
        
        | (T_fun (a1, r1), T_fun (a2, r2)) =>
          match unify (s, r1, r2, allow_subtyping) with [
            | Some (s) => unify (s, a2, a1, allow_subtyping)
            | None => None ()
          ]

        | (T_app (ti1, a1), T_app (ti2, a2)) =>
          if ti1.id == ti2.id then 
            unify_lists (s, a1, a2, false)
          else
            if allow_subtyping then {
              def s1 = ti1.make_subst (a1);
              match ti1.how_subtypes (ti2) with [
                | Some (l) =>
                  def f (t : option (Type)) : Type =
                    match t with [
                      | None => Tyvar.free_variable ()
                      | Some (t) => t /- s1
                    ];
                  unify (s, T_app (ti2, List.map (f, l)), t2, true)
                | None => None ()
              ]
            } else 
              None ()
            
        | (T_var (tv1), T_var (tv2)) =>
          if tv1.id == tv2.id then Some (s)
          else fallback (t1, t2)
        
        | (T_var (tv), _) =>
          if allow_subtyping then {
            // check to see if any of our constraints is enough
            def check_constraints (cs : list (Type)) : option (Subst) =
               match cs with [
                 | Nil => fallback (t1, t2)
                 | Cons (c, cs) =>
                   match unify (s, c, t2, true) with [
                     | Some (r) => Some (r)
                     | None => check_constraints (cs)
                   ]
               ];
             check_constraints (Tyvar.constraints (tv))
          } else fallback (t1, t2)
        
        | _ => 
          fallback (t1, t2)
      ];
    }

  unify (t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
    unify (Map.int_map (), t1, t2, allow_subtyping);
  
  unify (t1 : Type, t2 : Type) : option (Subst) =
    unify (Map.int_map (), t1, t2, false);
 
  // FIXME: this might be broken (if there are free variables in types to
  // begin with)
  types_eq (a : Type, b : Type) : bool =
    match unify (a, b) with [
      | Some => true
      | None => false
    ];

  // check if a :> b and if so, incorporate substitution into
  // global context
  subtypes (a : Type, b : Type) : bool =
    match unify (a, b, true) with [
      | Some (s) => { Tyvar.global_store (s); true }
      | None => false
    ];

  string_of_type (t : Type) : string
    {
      def map (sep : string, args : list (Type)) : string =
        Util.concat_strings(sep, List.map (string_of_type, args));
      match t with [
        | T_app (ti, args) =>
          def name = ti.fullname ();
          match args with [
            | Nil => name
            | _ => name + " (" + map (", ", args) + ")"
          ]
        | T_var (tv) => 
          "'" + tv.name + "_" + string_of_int (tv.id) + if Tyvar.is_free (tv) then "*" else ""
        | T_ref (t) => "ref " + string_of_type (t)
        | T_out (t) => "out " + string_of_type (t)
        | T_void => "void"
        | T_prod (args) => 
          "(" + map (" * ", args) + ")"
        | T_fun (from, to) =>
          "(" + string_of_type (from) + " -> " + string_of_type (to) + ")"
      ];
    }
  
  // Given function declaration, construct its type.
  fun_type (h : Fun_header) : Type = 
    match List.map (fun (p : Fun_parm) : Type => p.ty, h.parms) with [
      | Cons (x, Nil) => T_fun (x, h.ret_type)
      | Nil => T_fun (T_void (), h.ret_type)
      | l => T_fun (T_prod (l), h.ret_type)
    ];

  make_tapp (env : Env, n : string) : Type =
    T_app (env.lookup_type (n), Nil ());

  fun_args (from : Type) : list (Type) =
    match top_expand (from) with [
      | T_prod (a) => a
      | T_void => Nil ()
      | t => Cons (t, Nil ())
    ];
}

} // ns
