<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003, 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>Nemerle type-safe macros</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        You can think about macros as system of compile-time transformations 
        and automatic generation of code with regard to some rules. 
        It can be used either to automate manipulations performed on similar
        data-types and fragments of code, add syntax shortcuts to language,
        optimize and make some computations safer by moving them from runtime
        to compile-time.
      </p>
      <p>
        Idea of making simple inline operations on code comes from preprocessor
        macros,	which many languages (especially C, C++) contained since early 
        times of compiler design. We are following them in direction of much more
	powerful, and at the same time more secure (type-safe), solutions
	like Haskell Template Meta-programming.
      </p>
    </body>
  </section>
  <section id="features">
    <title>Key features</title>
      <body>
        <ul>
          <li>builtin ability of extending language syntax</li>
	  <li>creating functions, whose amount and type of arguments depend
	    on each other (like C printf) with full type-checking during
            compile-time</li>
	  <li>algorithmic generation of code, which may be dependent on
	    external factors, like XML files, script programs, databases or 
            even remote web sites </li>
	  <li>completing datatypes with automatically created methods for
            performing arbitrary operations, e.g. reading datasets from file,
	    sending them through network or storing in SQL database</li>
	  <li>using context of compilation provided by compiler's internal
	    structures, like line numbers (for error reporting), names of
	    processed type, function, class or namespace, accessing
            datatype definitions by name</li>
	</ul>
    </body>
  </section>
  <section id="description">
    <title>What exactly macro is?</title>
      <body>
        <p>
	  Basically every macro is a function, which takes some fragment
	  of code as parameter(s) and returns some other code. On a highest 
	  level of abstraction it doesn't matter if parameters are type definitions, 
          function calls or just a sequence of assignments. Most important fact is 
          that they are not common objects (e.g. instances of defined types, like 
          integer numbers), but their internal representation in compiler (i.e. 
          syntax tree).
	</p>
	<p>
	  Those functions are defined in program just like any other functions.
	  They are written in common Nemerle syntax and the only difference
	  is the structure of data they operate on (we provide special ways
	  to parse and generate syntax trees).
	</p>
	<p>
	  Macros, once defined, can be used to process some parts of code.
	  It's done by calling them with block(s) of code as parameters. 
	  This operation is in most cases indistinguishable from common function
	  calls, so programmer using macros won't be confused by unknown
	  syntax. Main concept of our design is to make usage of macros as much 
          transparent as possible. From the user point of view, it is not 
          important if particular parameters are passed to ordinary function 
          or one, which would process them at compile-time and insert some new 
          code in their place.
	</p>
      </body>
  </section>
  <section id="defining">
    <title>Defining new macro</title>
      <body>
        <p>
          Writing a macro is as simple as writing common function, except
          it is preceded by keyword <tt>macro</tt>. This will make compiler
          know about how to use defined method (i.e. run it at compile-time
          in every place where it is used). 
        </p>
        <p>
          Macros can take zero (if we just want to generate new code)
          or more parameters. They are all some of elements of language 
          grammar, so their type is limited to the set of defined
          syntax objects. The same holds for return value of macro.
        </p>
        <p>
          Example:
        </p>  
<code>
macro generate_expression ()
{
  compute_some_expression ();
}
</code>
        <p>
          This example macro doesn't take any parameters and it's used in 
          code by simply writing <tt>generate_expression ();</tt>. 
          Most important is a difference between <tt>generate_expression</tt>
          and <tt>compute_some_expression</tt> - first one is a function
          executed by compiler during compilation, while latter is just
          some common function that must return syntax tree of expression
          (which is here returned and inserted into program's code by
            <tt>generate_expression</tt>).
        </p>
        <subsection id="compiling">
          <title>Compiling simplest macro</title>
            <body>
              <p>
                In order to create and use some macro you have to write
                library, which will contain its executable form. You just 
                create new file <tt>mymacro.n</tt>, which can contain for 
                example
              </p>
<code>
macro m () {
  printf ("compile-time\n");
  &lt;[ printf ("run-time\n") ]&gt;
}
</code>
              <p>
                and compile it with command
              </p>
<code>
ncc -r Nemerle.Compiler.dll -tdll mymacro.n -o mymacro.dll
</code>
              <p>
                Library <tt>Nemerle.Compiler.dll</tt> will be probably
                loaded automatically in future releases. Note that if
                you use release 0.1.1 or earlier you have to add
              </p>
<code>
using Nemerle.Collections;
</code>
              <p>
                at the top of <tt>mymacro.n</tt> (it's because of some
                dependency, which is now fixed in svn version).
              </p>
              <p>
                Now you can use <tt>m()</tt> in any program, like here
              </p>
<code>
module M {
  public Main () : void {
    m ();
  }
}
</code>
              <p>
                You must add reference to <tt>mymacro.dll</tt> during 
                compilation of this program. It might look like this
              </p>
<code>
ncc -r mymacro.dll myprog.n -o myprog.exe
</code>
            </body>
        </subsection>
      </body>
  </section>      
  <section id="syntax_trees">
    <title>Operating on syntax trees</title>
      <body>
        <p>
          Definition of function <tt>compute_some_expression</tt> might look
          like this:
        </p>
<code>
compute_some_expression () : Expr 
{
  if (debug_on) 
    &lt;[ System.Console.WriteLine ("Hello, I'm debug message") ]&gt;
  else
    &lt;[ () ]&gt;
}
</code>
        <p>
          The examples above shows macro, which conditionally inlines expression
          printing some message. It's not quite useful yet, but it introduced 
          meaning of compile-time computations and also some new syntax used only 
          in writing macros and functions operating on syntax trees.
          We've written here <tt>&lt;[ ... ]&gt;</tt> constructor to
          build syntax tree of expression (e.g. '<tt>()</tt>').
        </p>
        <subsection id="quotation">
          <title>Quotation operator</title>
            <body>
              <p>
                <tt>&lt;[ ... ]&gt;</tt> is used to both construction and 
                decomposition of syntax trees. Those operations are similar to
                quotation of code. Simply, everything which is written inside 
                <tt>&lt;[ ... ]&gt;</tt>, corresponds to its own syntax tree. 
                It can be any valid Nemerle code, so programmer doesn't have to 
                learn internal representation of syntax trees in compiler.
             </p>
<code>
macro print_date (at_compile_time)
{                   
  match (at_compile_time) {
    | &lt;[ true ]&gt; =&gt; print_compilation_time ()
    | _ =&gt; &lt;[ WriteLine (DateTime.Now.ToString ()) ]&gt;
  }
}
</code>
              <p>
                Quotation alone allows using only constant expressions, which
                is insufficient for most tasks. For example, to write function
                <tt>print_compilation_time</tt> we must be able to create expression
                based on value known at compile-time. In next sections we introduce
                rest of macros' syntax to operate on general syntax trees.
              </p>
            </body>
        </subsection>
        <subsection id="spliced">
          <title>Matching subexpressions</title>
            <body>
              <p>
                When we want to decompose some large code (or more precisely, 
                its syntax tree), we must bind its smaller parts to variables.
                Then we can process them recursively or just use them in 
                arbitrary way to construct the result.
              </p>
              <p>
                We can operate on entire subexpressions by writing 
                <tt>$( ... )</tt> or <tt>$ID</tt> inside quotation operator 
                <tt>&lt;[ ... ]&gt;</tt>. This means binding value of 
                <tt>ID</tt> or interior of parenthesized expression to part of 
                syntax tree described by corresponding quotation.
              </p>
<code>
macro for (init, cond, change, body)
{
  &lt;[ 
    $init;
    def loop () : void {
      if ($cond) { $body; $change; loop() } 
      else ()
    };
    loop ()
  ]&gt;
}
</code>
              <p>
                The above macro defines function <tt>for</tt>, which is
                similar to the loop known from C. It can be used like this
              </p>
<code>
for (mutable i &lt;- 0; i &lt; 10; i &lt;- i + 1, printf ("%d", i))
</code>
              <p>
                Later we show how to extend language syntax to make syntax
                of <tt>for</tt> exactly the same like in C.
              </p>
            </body>
        </subsection>
        <subsection id="base_splicing">
          <title>Base elements of grammar</title>
            <body>
              <p>
                Sometimes quoted expressions have literals inside of them
                (like strings, integers, etc.) and we want to operate on
                their value, not on their syntax trees. It's possible, 
                because they are constant expressions and their runtime
                value is known at compile-time. 
              </p>
              <p>
                Let's consider previously used function 
                <tt>print_compilation_time</tt>. 
              </p>
<code>
print_compilation_time () : Expr
{                   
  &lt;[ System.Console.WriteLine ($(DateTime.Now.ToString () : string)) ]&gt;
}
</code>
              <p>
                Here we see some new extension of splicing syntax where we 
                create syntax tree of string literal from some known value.
                It is done by adding <tt>: string</tt> inside of 
                <tt>$(...)</tt> construct. One can think about it as of
                enforcing type of spliced expression to literal (similar
                to common Nemerle type enforcement), but in the matter
                of fact something more is happening here - real value
                is lifted to its representation as syntax tree of literal.
              </p>
              <p>
                Other types of literals are treated in the same way 
                (<tt>int</tt>, <tt>bool</tt>, <tt>float</tt>, <tt>char</tt>). 
                This notation can be used also in pattern matching. We can
                match constant values in expressions this way.
              </p>
              <p>
                There is also similar schema for splicing and matching 
                variables of given name. <tt>$(v : var)</tt> denotes
                variable, whose name is contained by object <tt>v</tt> 
                (of special type <tt>Name</tt>). There are some good 
                <a ref="#hygiene">reasons</a> for encapsulating real identifier
                within this object. 
              </p>

            </body>
        </subsection>
        <subsection id="variable_elements">
          <title>Constructs with variable amount of elements</title>
            <body>
              <p>
                You might have noticed, that Nemerle has a few grammar elements, 
                which are composed of list of subexpression. For example sequence
                of expressions enclosed with <tt>{</tt> .. <tt>}</tt> braces may
                contain zero or more elements. 
              </p>
              <p>
                When splicing values of some expressions, we would like to decompose
                or compose such constructs in a general way - i.e. obtain all expressions
                in given sequence. It's natural to think about them as list of expressions
                and to bind this list to some variable in meta-language. We do this with
                special syntax <tt>..</tt>:
              </p>
<code>
mutable exps &lt;- [ &lt;[ printf ("%d ", x) ]>, &lt;[ printf ("%d ", y) ]> ];
exps &lt;- &lt;[ def x = 1 ]&gt; :: &lt;[ def y = 2 ]&gt; :: exps;
&lt;[ {.. $exps } ]&gt;
</code>
              <p>
                We used <tt>{ .. $exps }</tt> here, to create the sequence of 
                expressions from list <tt>exps : list&lt;Expr>;</tt>. 
                Similar syntax is used to splice content of tuples (<tt>( .. $elist )</tt>) 
                and other constructs, like <tt>array []</tt>:
              </p>
<code>
macro castedarray (e) {
 match (e) {
  | &lt;[ array [.. $elements ] ]> =>
     def casted = List.Map (elements, fun (x) {&lt;[ ($x :> object) ]>});
     &lt;[ array [.. $casted] ]>
  | _ => e
}
</code>
              <p>
                If exact number of expressions in tuple / sequence is known during
                writing of quotation, then it can be expressed with
              </p>
<code>
&lt;[ $e_1; $e_2; $e_3; x &lt;- 2; f () ]&gt;
</code>
              <p>
                The <tt>..</tt> syntax is used when there are <tt>e_i : Expr</tt> for
                <tt>1 &lt;= i &lt;= n</tt>.
              </p>
            </body>
        </subsection>
    </body>
  </section>
  <section id="defining_syntax">
    <title>Adding new syntax to compiler</title>
      <body>
        <p>
          After we have written <tt>for</tt> macro, we would like compiler
          to understand some changes to its syntax. Especially C-like notation
        </p>
<code>
for (mutable i &lt;- 0; i &lt; n; i &lt;- i + 1) {
  printf ("%d\n", i);
  sum &lt;- sum + i;
}
</code>
        <p>  
          In order to do that, we have to define which tokens and grammar
          elements may form call of <tt>for</tt> macro. We do that by changing
          its header to
        </p>
<code>
macro for (init, cond, change, body)
syntax ("for", "(", init, ";", cond, ";", change, ")", body)
</code>
        <p>
          <tt>syntax</tt> keyword it used here to define list of elements forming
          syntax of macro call. First token must always be an unique identifier
          (from now on it is treated as special keyword triggering parsing of
          defined sequence). It is followed by tokens composed of operators or
          identifiers passed as string literals or names of parameters of macro.
          Every parameter must occur exactly once.
        </p>
        <p>
          Parsing of syntax rule is straightforward - tokens from input
          program must match those from definition, parameters are parsed
          according to their type. Default type of parameter is 
          <tt>Expr</tt>, which is just an ordinary expression (consult Nemerle
          grammar in <link>reference.html</link>). All allowed types of parameter
          will be described in extended version of reference manual corresponding
          to macros.
        </p>  
      </body>
  </section>      
  <section id="reference">
    <title>Reference to more advanced aspects</title>
      <body>
        <subsection id="hygiene">
          <title>Hygiene and alpha-renaming of identifiers</title>
            <body>
              <subsubsection id="capture">
                <title>Problem with names capture</title>
                  <body>
                    <p>
                      Identifiers in quoted code (object code) must be treated
                      in a special way, because we usually do not know in which
                      scope they would appear. Especially they shouldn't mix
                      with variables with the same names from macro-use site.
                    </p>
                    <p>
                      Consider following macro defining local function <tt>f</tt>
                    </p>
<code>
macro identity (e) { &lt;[ def f (x) { x }; f($e) ]&gt; }
</code>
                    <p>
                      Calling it with <tt>identity (f(1))</tt> might generate 
                      confusing code like
                    </p>
<code>
def f (x) { x }; f (f (1))
</code>
                    <p>
                      To preserve names capture, all macro generated variables 
                      should be renamed to their unique counterparts, like in
                    </p>
<code>
def f_42 (x_43) { x_43 }; f_42 (f (1))
</code>
                  </body>
              </subsubsection>
              <subsubsection id="hygiene_details">
                <title>Hygiene of macros</title>
                  <body>
                    <p>
                      Idea of separating variables introduced by macro from 
                      those defined in plain code (or other macros) is called 
                      ``hygiene'' after Lisp and Scheme languages. In Nemerle 
                      we define it as putting identifiers created during single 
                      macro execution into unique namespace. Variables from
                      different namespaces cannot bind to each other.
                    </p>
                    <p>
                      In other words, macro cannot create identifiers capturing
                      any external variables or visible outside of its own 
                      generated code. This means, that one doesn't have to care
                      about locally used names.
                    </p>
                    <p>
                      Hygiene is obtained by encapsulating identifiers in special
                      <tt>Name</tt> class. Compiler uses it to distinguish names
                      from different macro executions and scopes (for details of
                      implementation consult <link>metaprogramming.pdf</link>).
                      Variables with appropriate informations are created 
                      automatically by quotation.
                    </p>
<code>
def definition = &lt;[ def y = 4 ]&gt;;
&lt;[ def x = 5; $definition; x + y ]&gt;
</code>
                    <p>
                      When macro creates above code, identifiers <tt>y</tt> and 
                      <tt>x</tt> are tagged with the same unique mark. Now they
                      cannot be captured by any external variables (with 
                      different mark). We operate on <tt>Name</tt> class, when
                      quoted code is composed or decomposed and we use 
                      <tt>&lt;[ $(x : var) ]&gt;</tt> construct. Here <tt>x</tt> 
                      is bound to object of type <tt>Name</tt>, which we can use
                      in other place, to create somewhere exactly the same 
                      identifier.
                    </p>
                    <p>
                      Identifier can be also created by calling method
                      <tt>Macros.NewSymbol()</tt>, which returns <tt>Name</tt>
                      with unique identifier, tagged with current mark.
                    </p>
<code>
def x = Macros.NewSymbol ();
&lt;[ def $(x : var) = 5; $(x : var) + 4 ]&gt;
</code>
                  </body>
              </subsubsection>
              <subsubsection id="breaking_hygiene">
                <title>Controlled breaking of hygiene</title>
                  <body>
                    <p>
                      Sometimes it is useful to generate identifiers, which
                      bind to variables visible in place where macro is used.
                    </p>
                  </body>
              </subsubsection>
            </body>
        </subsection>
      </body>
  </section>      
</document>
