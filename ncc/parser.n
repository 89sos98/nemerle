/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

/*
   From now on usage of Util.locate() in this file is prohibited. We
   have location_here() always at the top of the stack, which assigns
   mostly proper location to things. We fix is here and there, in most
   cases it is redundant now, and should be fixed.
 */

namespace Nemerle.Compiler {

public module Parser {
  public variant Result {
    | Fail { message : string; }
    | Succeeded { result : SyntaxElement; }
    | Processing      
  }
  
  [Record]
  public class ParenCallback {
    public opening_paren : string;
    public closing_paren : string;
    public parsing_function : void -> Expr;
  }

  [Record]
  public class KeywordCallback {
    public name : string;
    public parsing_function : void -> Expr;
  }

  [Record]
  public class CTX {
    public mutable lexer : LexerBase;
    public mutable last_token1 : Token; // most recent token
    public mutable last_token2 : Token; // one token before
    public mutable last_token3 : Token; // two tokens before
    public mutable push_back : int; // position in last_token{1,2} or 0
    public parens : Hashtable <string, ParenCallback>;
    public closing_parens : Hashtable <string, int>;
    public keywords : Hashtable <string, KeywordCallback>;
  }

  public mutable ctx : CTX;
  private mutable pending_comment : string;
  private tok_semicolon : Token;

  this () 
  {
    ctx = CTX (lexer = null,
                last_token1 = null, 
                last_token2 = null, 
                last_token3 = null,
                push_back = 0,
                keywords = Hashtable (),
                parens = Hashtable (),
                closing_parens = Hashtable ());
    init_parens ();
    tok_semicolon = Tok_operator (";", 0);
  }

  last_token () : Token
  {
    match (ctx.push_back) {
      | 0 => ctx.last_token1
      | 1 => ctx.last_token2
      | 2 => ctx.last_token3
      | _ => assert (false)
    }
  }

  get_token () : Token
  {
    match (ctx.push_back) {
      | 1 =>
        ctx.push_back = 0;
        ctx.last_token1
      | 2 =>
        ctx.push_back = 1;
        ctx.last_token2
      | _ =>
        def get_token () {
          def tok = 
            try {
              ctx.lexer.GetToken ()
            } catch { e : LexerBase.Error =>
              Message.error (ctx.lexer.Location, "lexing problem: " + e.name);
              get_token ()
            };
          match (tok) {
            | Tok_comment (c) => pending_comment = c; get_token ()
            | t => t
          }
        };
        ctx.last_token3 = ctx.last_token2;
        ctx.last_token2 = ctx.last_token1;
        ctx.last_token1 = get_token ();
        ctx.last_token1
    }
  }

  peek_token () : Token {
    def tok = get_token ();
    push_back ();
    tok
  }
  
  push_back () : void {
    match (ctx.push_back) {
      | 1 => ctx.push_back = 2
      | 2 => Util.ice ()
      | _ => ctx.push_back = 1
    }
  }

  push_back (tok : Token) : void {
    match (ctx.push_back) {
      | 1 => ctx.push_back = 2; ctx.last_token2 = tok
      | 2 => Util.ice ()
      | _ => ctx.push_back = 1; ctx.last_token1 = tok
    }
  }
  
  shift () : void {
    ignore (get_token ()) 
  }

  location_here () : Location {
    ignore (peek_token ());
    def loc = location ();
//    loc.comment = pending_comment;
//    pending_comment = null;
    loc
  }

  location () : Location {
    ctx.lexer.Location
  }

  public token_name (t : Token) : string {
    match (t) {
      | Tok_keyword (x) => "keyword `" + x + "'"
      | Tok_identifier (x) => "identifier `" + x + "'"
      | Tok_operator (x, _) => "operator `" + x + "'"
      | Tok_string_literal => "string literal"
      | Tok_byte_literal => "byte literal"
      | Tok_sbyte_literal => "signed byte literal"        
      | Tok_short_literal => "short literal"
      | Tok_ushort_literal => "unsigned short literal"        
      | Tok_integer_literal => "integer literal"
      | Tok_uinteger_literal => "unsigned integer literal"        
      | Tok_long_literal => "long literal"
      | Tok_ulong_literal => "unsigned long literal"        
      | Tok_float_literal => "float literal"
      | Tok_double_literal => "double literal"
      | Tok_decimal_literal => "decimal literal"        
      | Tok_char_literal => "character literal"
      | Tok_EOF => "end of file"
      | Tok_comment => "documentation comment"
    }
  }

  describe () : string {
    when (ctx.push_back != 2) {
      push_back ()
    };
    def name = token_name (peek_token ());
    "parse error near " + name + ": "
  }

  fatal_error<'a> (msg : string) : 'a {
    Message.fatal_error (location (), describe () + msg)
  }

  error (msg : string) : void {
    Message.error (location (), describe () + msg)
  }

  get_qid (first : list <string>) : list <string> {
    def loop (acc) {
      match (get_token ()) {
        | Tok_operator (".", _) =>
          match (get_token ()) {
            | Tok_identifier (x) => loop (x :: acc)
            | _ => fatal_error ("expecting identifier after dot in qualified ID")
          }
        | _ =>
          push_back ();
          List.Rev (acc)
      }
    };

    match (get_token ()) {
      | Tok_identifier (x) =>
        // reversed accumulator
        loop (x :: first)
      | _ => fatal_error ("expecting qualified identifier")
    }
  }

  get_splicable_qid () : Splicable_string {
    match (peek_token ()) {
      | Tok_identifier => SS_string (Name (get_qid ([])))
        
      | Tok_operator ("$", _) => get_splicable_id ()
        
      | _ => fatal_error ("expecting qualified identifier")
    }
  }
    
  get_splicable_id () : Splicable_string {
    def loc = location_here ();
    match (get_token ()) {
      | Tok_identifier (n) => SS_string (loc, Name ([n]))
      | Tok_operator ("$", _) =>
        match (get_token ()) {
          | Tok_identifier (id) =>
              SS_spliced_expr (loc, E_ref (location (), Name ([id])))
              
          | Tok_operator ("(", _) =>
            def expr = parse_expr ();
            expect_operator (")");
            match (expr) {
              | E_type_enforcement =>
                SS_spliced_expr (loc, E_spliced (expr))

              | x => SS_spliced_expr (loc, x); 
            }

          | Tok_keyword ("_") =>
              SS_spliced_expr (loc, E_Underscore (location ()))
              
          | _ => fatal_error ("expecting identifier or '(' after '$'")
        }
      | Tok_keyword ("_") => 
        SS_string (loc, Name ([Util.tmpname ("u")]))
      | _ => fatal_error ("expecting identifier")
    }
  }

  get_tyvar () : string * int {
    match (get_token ()) {
      | Tok_identifier (tv) => (tv, TypingContext.MacroColor)
      | _ => fatal_error ("expecting type variable")
    }
  }

  expect_operator (op : string) : void {
    match (get_token ()) {
      | Tok_operator (o, _) when op == o => ()
      | Tok_operator (o, _) when o.StartsWith (op) =>
        push_back (Tok_operator (o.Substring (op.Length), 0))
      | Tok_operator (o, _) =>
        match (peek_token ()) {
          | Tok_operator (o', _) when op == o + o' => shift (); ()
          | _ => fatal_error ("expecting operator `" + op + "'");
        }
      | _ =>
        fatal_error ("expecting operator `" + op + "'");
    }
  }

  expect_keyword (op : string) : void {
    match (get_token ()) {
      | Tok_keyword (o) when op == o => ()
      | _ =>
        fatal_error ("expecting keyword `" + op + "'");
    }
  }

  flag_keyword (kw : string) : bool {
    match (get_token ()) {
      | Tok_keyword (n) when n == kw => true
      | _ => push_back (); false
    }
  }

  parse_funparm (allow_inference : bool) : Fun_parm {
    def (atts, _) = get_attrs (System.AttributeTargets.Parameter, System.AttributeTargets.Parameter);
    match (peek_token ()) {
      | Tok_keyword ("params") =>
        shift ();
        atts.custom_attrs = <[ System.ParamArrayAttribute ]> :: atts.custom_attrs;
      | _ => ()
    };
    def id = get_splicable_id ();
    def loc = location ();
    def t =
      match (get_token ()) {
        | Tok_operator (":", _) => parse_type ()
        | _ when allow_inference => push_back (); T_infer ()
        | _ => fatal_error ("expecting typing constraint after parameter name")
      };
    match (peek_token ()) {
      | Tok_operator ("=", _) => 
        shift ();
        def e = parse_expr ();
        atts.custom_attrs = <[ System.ComponentModel.DefaultValueAttribute ($e)
                            ]> :: atts.custom_attrs;
      | _ => ()
    };
    Fun_parm (loc = loc, name = id, ty = t, modifiers = atts)
  }

  // `splicing_type' is for noting, that there are spliced tyvars
  // if yes, it's T_spliced with expression describing their list
  // else it's T_void ()
  parse_tyvars () : list <string * int> * Type
  {
    match (get_token ()) {
      | Tok_operator ("<", _) =>
        match (peek_token ()) {
          | Tok_operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | SS_string =>
                fatal_error ("expected spliced expression")
              | SS_spliced_expr (e) =>
                expect_operator (">");                    
                ([], T_spliced (e))
            }
          | _ =>
            def tyvars = operator_separated_list (",", get_tyvar);
            expect_operator (">");
            (tyvars, T_void ())
        }
      | _ => push_back (); ([], T_void ())
    };
  }
  
  /** eats exactly header with [name], [(parameters)] and inferencable [: type] */
  parse_fun_header (allow_inference : bool, 
                    allow_ctor : bool,
                    is_lambda : bool, 
                    knownname : option <Splicable_string>) : Fun_header
  {
    mutable is_ctor = false;
    def loc = location_here ();
    
    def name = 
      match (knownname) {
        | None =>
          match (peek_token ()) {
            | Tok_keyword ("this") when allow_ctor => 
              shift ();
              is_ctor = true; SS_string (Name ([".ctor"]))
            | Tok_keyword ("fun") when is_lambda =>
              shift (); SS_string (Name ([]))
            | _ when is_lambda => fatal_error ("expecting `fun'")
            | Tok_identifier  
            | Tok_operator ("$", _) => get_splicable_id ()
            | _ => fatal_error ("expecting function name")
          }
        | Some (n) => n
      };
    def (tyvars, splicing_type) = parse_tyvars ();
    expect_operator ("(");
    def parse_parm () { parse_funparm (allow_inference) };
    def parms =
      match (peek_token ()) {
        | Tok_operator (")", _) => []
        | Tok_operator (".", _) =>
          expect_operator ("..");
          match (get_splicable_id ()) {
            | SS_spliced_expr (e) =>
                [Fun_parm (e.loc, SS_string (Name ([])), <[ type: void ]>, 
                           Modifiers (NemerleAttributes.None, [E_spliced (e)]))]
            | SS_string =>
              fatal_error ("expected spliced expression")
            }
        | _ => operator_separated_list (",", parse_parm)
      };
    expect_operator (")");
    
    def ret_type =
      match (get_token ()) {
        | _ when is_ctor => push_back (); T_void ()
        | Tok_operator (":", _) => parse_type ()
        | _ when allow_inference => push_back (); T_infer ()
        | _ => fatal_error ("expecting typing constraint on function return value")
      };

    def typarms = parse_where_constraints (tyvars, splicing_type);

    Fun_header (loc,
                name = name,
                ret_type = ret_type, 
                parms = parms, 
                typarms = typarms)
  }

  parse_literal () : option <Literal>
  {
    match (get_token ()) {
      | Tok_keyword ("null") => Some (L_null ())
      | Tok_keyword ("true") => Some (L_bool (true))        
      | Tok_keyword ("false") => Some (L_bool (false))
      | Tok_operator ("(", _) =>
        match (get_token ()) {
          | Tok_operator (")", _) => Some (L_void ())
          | _ => push_back (); push_back (); None ()
        }
      | Tok_string_literal (s) => Some (L_string (s))
      | Tok_byte_literal (n) => Some (L_byte (n))
      | Tok_sbyte_literal (n) => Some (L_sbyte (n))
      | Tok_short_literal (n) => Some (L_short (n))
      | Tok_ushort_literal (n) => Some (L_ushort (n))
      | Tok_integer_literal (n) => Some (L_int (n))
      | Tok_uinteger_literal (n) => Some (L_uint (n))
      | Tok_long_literal (n) => Some (L_long (n))
      | Tok_ulong_literal (n) => Some (L_ulong (n))
      | Tok_float_literal (n) => Some (L_float (n))
      | Tok_double_literal (n) => Some (L_double (n))
      | Tok_decimal_literal (n) => Some (L_decimal (n))                
      | Tok_char_literal (c) => Some (L_char (c))
      | _ => push_back (); None ()
    }
  }

  // builds an E_match expression for the 'is' keyword
  build_match_for_is (loc : Location, expr : Expr, ty : Type) : Expr
  {
    def id = SS_string (Name ("_N_is"));
    def pat = E_As (loc, E_type_enforcement (loc, E_Underscore (loc), ty), id);
    
    build_match_for_isp (loc, expr, pat)
  }
  
  // builds an E_match expression for the 'isp' keyword
  build_match_for_isp (loc : Location, expr : Expr, pat : Expr) : Expr
  {
    E_Match (loc, expr,
             [MatchCase ([(pat, None ())], E_literal (loc, L_bool (true))),
              MatchCase ([(E_Underscore (loc), None ())], E_literal (loc, L_bool (false)))])
  }
  
  parse_closed_prim_expr () : Expr {
    def loc = location_here ();
    match (parse_literal ()) {
      | Some (l) => E_literal (loc, l)
      | None =>
        def problem () {
          Message.fatal_error (loc, describe () + "expecting primary expression")
        };
        
        match (get_token ()) {
          | Tok_keyword ("this") => E_this (loc)
          | Tok_keyword ("base") => E_base (loc)
          | Tok_keyword ("_") => E_Underscore (loc)
          | Tok_keyword ("typeof") => 
            expect_operator ("(");
            def type_expr = parse_type ();
            expect_operator (")");
            E_typeof (loc, type_expr)
            
          | Tok_identifier (n) => E_ref (loc, Name ([n]))
          | Tok_operator ("(", _) =>
            def expr = parse_expr ();
            match (get_token ()) {
              | Tok_operator (":>", _) =>
                def t = parse_type ();
                expect_operator (")");
                E_type_conversion (loc, expr, t)

              | Tok_operator (":", _) =>
                def t = parse_type ();
                expect_operator (")");
                E_type_enforcement (loc, expr, t)

              | Tok_operator (",", _) =>
                def exprs = expr :: operator_separated_list (",", parse_expr);
                expect_operator (")");
                E_tuple (loc, exprs)
                
              | Tok_operator (")", _) => 
                match (expr) {
                  | E_expr_list => E_tuple (loc, [expr])
                  | _ => expr
                }              

              | _ => Message.fatal_error (loc, describe () + "unbalanced `('")
            }

          | Tok_operator ("$", _) =>
            match (peek_token ()) {
              | Tok_string_literal (str) =>
                shift ();
                <[ Nemerle.IO.sprint ($(str : string)) ]>
              | _ =>
                push_back ();
                parse_spliced_expr ();
            }

          | Tok_operator (o, _) =>
            def parse_paren (p : ParenCallback) {
              def expr = p.parsing_function ();
              expect_operator (p.closing_paren);
              expr
            };

            def loop (i, o : string) {
              if (i > 0)
                match (ctx.parens.Get (o.Substring (0, i))) {
                  | Some (x)  => (i, Some (x))
                  | _ => loop (i - 1, o)
                }
              else
                (0, None ())
            };
            
            match (ctx.parens.Get (o)) {
              | Some (p) => parse_paren (p)
              | None =>
                match (loop (o.Length - 1, o)) {
                  | (i, Some (p)) =>
                    push_back (Tok_operator (o.Substring (i), 0));
                    parse_paren (p)
                  | (_, None) =>
                    match (get_token ()) {
                      | Tok_operator (o', _) =>
                        match (ctx.parens.Get (o + o')) {
                          | Some (p) => parse_paren (p)
                          | None => push_back (); problem ()
                        }
                      | _ => push_back (); problem ()
                    }
                }
            }
            
          | _ => problem ()
        }
    }
  }

  parse_spliced_expr () : Expr {
    match (get_splicable_id ()) {
      | SS_spliced_expr (e) =>
        match (e) {
          | E_spliced (E_type_enforcement) => e
          | _ => E_spliced (e)
        }
      | SS_string => Util.ice ("expected spliced expression")
    }
  }

  parse_prim_expr (expr : Expr) : Expr {
    match (get_token ()) {
      | Tok_operator ("[", _) =>
        def exprs = operator_separated_list (",", parse_expr);
        expect_operator ("]");
        parse_prim_expr (E_indexer (expr.loc, expr, exprs))
          
      | Tok_operator (".", _) => 
        def id = get_splicable_id ();
        parse_prim_expr (E_member (expr.loc, expr, id))
          
      | Tok_operator ("(", _) =>
        def parms =
          match (peek_token ()) {
            | Tok_operator (")", _) => shift (); []
            | _ => 
              def parms = operator_separated_list (",", parse_expr);
              expect_operator (")");
              parms
          };
        parse_prim_expr (E_call (expr.loc, expr, parms))

      | Tok_operator ("{", _) =>
        push_back ();
        E_Application (expr.loc, expr, parse_expr ())

      | Tok_keyword ("_") =>
        E_Application (expr.loc, expr, E_Underscore ())

      | _ => push_back (); expr
    }
  }

  parse_unary_expr () : Expr {
    match (peek_token ()) {
      | Tok_operator ("(", _)
      | Tok_operator ("$", _) => parse_prim_expr (parse_closed_prim_expr ())

      | Tok_operator (".", _) =>
        expect_operator ("..");
        match (get_splicable_id ()) {
          | SS_spliced_expr (e) =>
            E_expr_list (e.loc, E_spliced (e))                
          | SS_string =>
            fatal_error ("expected spliced expression")
        }

      | Tok_operator (o, pri) =>
        def loc = location ();
        def unary () {
          when (pri == 0) {
            fatal_error ("operator `" + o + "' cannot be used in unary context")
          };
          shift ();
          E_call (loc, E_ref (loc, Name ([o])), [parse_unary_expr ()])
        };
        
        if (ctx.parens.Contains (o))
          parse_prim_expr (parse_closed_prim_expr ())
        else {
          shift ();
          def tok = peek_token ();
          push_back ();
          match (tok) {
            | Tok_operator (o', _) =>
              if (ctx.parens.Contains (o + o'))
                parse_prim_expr (parse_closed_prim_expr ())
              else unary ()
            | _ => unary ()
          }
        }
      | _ => parse_prim_expr (parse_closed_prim_expr ())
    }
  }

  parse_case_guard () : Expr * option <Expr> {
    def pat = parse_expr ();
    if (flag_keyword ("when"))
      (pat, Some (parse_expr ()))
    else (pat, None ());
  }


  parse_match_case () : MatchCase {
    def loop2 (acc) {
      def res = parse_case_guard ();
      match (get_token ()) {
        | Tok_operator ("=>", _) => List.Rev (res :: acc)
        | Tok_operator ("|", _) => loop2 (res :: acc)
        | _ => fatal_error ("found junk after pattern")
      }
    };
    
    // eat pattern part and '=>'
    def pats = 
      match (peek_token ()) {
        | Tok_operator ("|", _) => 
          shift ();
          match (peek_token ()) {
            | Tok_operator (".", _) =>
              expect_operator ("..");
              match (get_splicable_id ()) {
                | SS_spliced_expr (e) =>
                  expect_operator ("=>");
                  [(E_expr_list (e.loc, E_spliced (e)), None ())]                  
                | SS_string =>
                  fatal_error ("expected spliced expression")
              }
            | _ => loop2 ([])
          }
        | _ => loop2 ([])
      };

    def loc' = location_here ();
    def expr =
      match (parse_expr_sequence ()) {
        | [x] => x
        | l => E_sequence (loc', l)
      };

    MatchCase (pats, expr)
  }

  parse_toplevel_expr () : Expr
  {
    def loc = location_here ();
    def tok = get_token ();
    //Message.debug ("pse " + token_name (tok));
    match (tok) {
      | Tok_operator ("{", _) =>
        def loc = location ();
        def res = E_sequence (loc, parse_maybe_null_expr_sequence ());
        expect_operator ("}");
        res

      | Tok_keyword (k) when ctx.keywords.Contains (k) =>
        def k = Option.UnSome (ctx.keywords.Get (k));
        k.parsing_function ()

      | Tok_keyword ("ref") =>
        E_parm_by_ref (loc, parse_expr ())
        
      | Tok_keyword ("out") =>
        E_parm_out (loc, parse_expr ())
        
      | Tok_keyword ("match") =>
        expect_operator ("(");
        def expr = parse_expr ();
        expect_operator (")");
        match (get_token ()) {
          | Tok_operator ("{", _) =>
            match (peek_token ()) {
              | Tok_operator (".", _) =>
                expect_operator ("..");
                match (get_splicable_id ()) {
                  | SS_spliced_expr (e) =>
                    expect_operator ("}");                  
                    E_Match (loc, expr, 
                             [MatchCase ([], E_expr_list (e.loc, E_spliced (e)))]);
                  | SS_string =>
                    fatal_error ("expected spliced expression")
                }
              | _ =>
                push_back ();
                def cases = collect_braced_list (parse_match_case);
                E_Match (loc, expr, cases)
            }
          | _ =>
            fatal_error ("expecting '{' after 'match (e)'")
        }
        
      | Tok_keyword ("throw") =>
        E_raise (loc, parse_expr ())

      | Tok_keyword ("try") =>
        def body = parse_block ([]);
        match (get_token ()) {
          | Tok_keyword ("catch") =>
            def parse_with () {
              match (peek_token ()) {
                | Tok_operator ("|", _) => shift ()
                | _ => ()
              };
              def id = get_splicable_id ();
              expect_operator (":");
              def t = parse_type ();
              expect_operator ("=>");
              match (parse_expr_sequence ()) {
                | [x] => (id, t, x)
                | l => (id, t, E_sequence (loc, l))
              }
            };

            def mktry (h, body) {
              def (id, t, handler) = h;
              E_try_with (loc, body, id, t, handler)
            };
            
            def res = List.FoldLeft (collect_braced_list (parse_with), 
                                     body, mktry);

            match (get_token ()) {
              | Tok_keyword ("finally") =>
                def handler = parse_block ([]);
                E_try_finally (loc, res, handler)
                
              | _ => push_back (); res
            }
            
          | Tok_keyword ("finally") =>
            def handler = parse_block ([]);
            E_try_finally (loc, body, handler)

          | _ => fatal_error ("expecting `catch' or `finally'")
        }

      | Tok_keyword ("array") =>
        match (peek_token ()) {
          | Tok_operator ("[", _) | Tok_operator ("$", _) =>
            E_mkarray (loc, <[ 1 ]>, parse_expr ())

          | Tok_operator (o, _) when o.StartsWith ("<") =>
            expect_operator ("<");
            def rank = match (get_token ()) {
                         | Tok_integer_literal (i) when i > 0 => <[ $(i : int) ]>
                         | Tok_integer_literal =>
                           fatal_error ("array rank must be positive");
                         | Tok_operator ("$", _) =>
                           push_back ();
                           parse_spliced_expr ();
                         | _ => fatal_error ("expected integer array rank");
            }
            expect_operator (">");
            match (peek_token ()) {
              | Tok_operator ("[", _) | Tok_operator ("$", _) =>
                 E_mkarray (loc, rank, parse_expr ());
              | _ =>
                fatal_error ("expected [ ... elements of array ] after `array <rank>'")
            }

          | Tok_operator ("(", _) =>
            shift ();
            def exprs = operator_separated_list (",", parse_expr);
            expect_operator (")");
            E_empty_array (loc, exprs)

          | _ => fatal_error ("expected [ ... elements of array ], ( ... "
                              "sizes of empty array )  or <rank> after `array'")
        }

      | Tok_keyword ("fun") =>
        push_back ();
        def h = parse_fun_header (allow_ctor = false,
                                  allow_inference = true, 
                                  is_lambda = true, 
                                  knownname = None ());
        def expr = parse_block (h.parms);
        E_lambda (loc, Function_decl (h, expr))

      | Tok_keyword ("mutable") =>
        def id = get_splicable_id ();
        match (get_token ()) {
          | Tok_operator ("<-", _) =>
            Message.warning ("<- assignment operator is obsolete");
            E_let (loc, true, id, parse_expr ())
          | Tok_operator ("=", _) =>
            E_let (loc, true, id, parse_expr ())
          | _ =>
            fatal_error ("expected assignment operator =")
        };

      | Tok_keyword ("def") =>
        def parse_val (id) {
          expect_operator ("=");
          E_let (loc, false, id, parse_expr ())
        };
        def parse_pat (idopt) {
          def pat =
            match (idopt) {
              | None => parse_closed_prim_expr ()
              | Some (SS_string (id)) => parse_prim_expr (E_ref (loc, id))
              | Some (SS_spliced_expr (e)) => parse_prim_expr (E_spliced (e.loc, e))
            };
          expect_operator ("=");
          def expr = parse_expr ();
          E_DefPattern (loc, pat, expr)
        };
        def parse_funs (acc, idopt) {
          def h = parse_fun_header (allow_ctor = false, 
                                    allow_inference = true, 
                                    is_lambda = false, knownname = idopt);
          def fd = Function_decl (h, parse_block (h.parms));
          match (peek_token ()) {
            | Tok_keyword ("and") =>
              shift ();
              parse_funs (fd :: acc, None ())
            | _ => E_letfun (loc, List.Rev (fd :: acc))
          }
        };
        
        match (peek_token ()) {
          | Tok_keyword ("_")
          | Tok_operator ("$", _) 
          | Tok_identifier =>
            def id = get_splicable_id ();
            match (peek_token ()) {
              | Tok_operator ("(", _) 
              | Tok_operator ("<", _) => 
                parse_funs ([], Some (id))
                
              | Tok_operator ("=", _) =>
                parse_val (id)
              
              | _ => parse_pat (Some (id))
            }

          | Tok_operator (".", _) =>
            shift ();
            expect_operator (".");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                E_letfun (loc, [Function_decl (Fun_header (), 
                                               E_expr_list (E_spliced (e)))])
              | SS_string =>
                fatal_error ("expected spliced expression")
            }
          | _ => parse_pat (None ())
        }
      
      | _ => push_back (); parse_operator_expr ()
    }
  }

  parse_operator_expr () : Expr
  {
    def is_paren (s) {
      ctx.parens.Contains (s) || ctx.closing_parens.Contains (s)
    };

    def make_bin (loc, op, e1, e2) {
      match (op) {
        | "=" =>
          E_assign (loc, e1, e2)
        | "<-" =>
          Message.warning ("<- assignment operator is obsolete");
          E_assign (loc, e1, e2)
        | "::" =>
          E_call (loc, E_ref (loc, Name (["Cons"])), [e1, e2])
        | _ =>
          E_call (loc, E_ref (loc, Name ([op])), [e1, e2])
      }
    };
    def make_cast_expr (loc, op, e, ty) {
      match (op) {
        | ":" => E_type_enforcement (loc, e, ty)
        | ":>" => E_type_conversion (loc, e, ty)
        | _ => Util.ice ("wrong operator with 9 priority")
      }
    }
    
    def parse_pri (pri) : Expr {
      def loop_left (expr) {
        def loc = location_here ();
        match (get_token ()) {
          | Tok_keyword ("is") when pri == 9 =>
            def ty = parse_type ();
            loop_left (build_match_for_is (loc, expr, ty))
            
          | Tok_keyword ("matches") when pri == 9 =>
            def pat = parse_expr ();
            loop_left (build_match_for_isp (loc, expr, pat))

          | Tok_keyword ("as") when pri == 9 =>
            def id = get_splicable_id ();
            loop_left (E_As (expr, id))
            
          | Tok_operator (s, 9) when 9 == pri =>
            def ty' = parse_type ();
            loop_left (make_cast_expr (loc, s, expr, ty'))

          | Tok_operator (s, p) when p == pri && !is_paren (s) =>
            def expr' = parse_pri (pri - 1);
            loop_left (make_bin (loc, s, expr, expr'))
          | _ => 
            push_back (); 
            expr
        }
      };

      def loop_right () {
        def loc = location_here ();
        def expr = parse_pri (pri - 1);
        match (get_token ()) {
          | Tok_operator (s, p) when p == pri && !is_paren (s) =>
            make_bin (loc, s, expr, loop_right ())
          | _ => push_back (); expr
        }
      };
     
      match (pri) {
        | 0 => parse_unary_expr ()
        | 1 | 8 => loop_right ()
        | _ => loop_left (parse_pri (pri - 1))
      }
    };

    parse_pri (9)
  }

  parse_expr () : Expr
  {
    def expr = parse_toplevel_expr ();
    match (get_token ()) {
      | Tok_operator ("<-", _) =>
        Message.warning ("<- assignment operator is obsolete");
        def expr' = parse_toplevel_expr ();
        E_assign (expr.loc, expr, expr')
                
      | Tok_operator ("=", _) =>
        def expr' = parse_toplevel_expr ();
        E_assign (expr.loc, expr, expr')
      | _ => push_back (); expr
    }
  }

  parse_expr_sequence () : list <Expr> {
    def loop (acc) {
      def last = last_token ();
      match (get_token ()) {
        | Tok_operator (";", _) =>
          match (peek_token ()) {
            | Tok_operator ("}", _) 
            | Tok_operator ("|", _) 
            | Tok_operator ("]", _) 
              => List.Rev (acc)
            | _ => loop (parse_expr () :: acc)
          }
        | Tok_operator ("}", _) 
        | Tok_operator ("|", _) 
        | Tok_operator ("]", _) 
          => push_back (); List.Rev (acc)
        | _ =>
          match (last) {
            | Tok_operator ("}", _) =>
              push_back ();
              loop (parse_expr () :: acc)
            | _ =>
              fatal_error ("expecting the `;' separator after an expression in a sequence")
          }
      }
    };

    loop ([parse_expr ()])
  }

  parse_maybe_null_expr_sequence () : list <Expr> {
    match (peek_token ()) {
      | Tok_operator ("}", _) 
      | Tok_operator ("]", _) => []
      | _ => parse_expr_sequence ()
    }
  }

  parse_block (parms : list <Fun_parm>) : Expr 
  {
    def loc = location ();
    match (peek_token ()) {
      // entire function body may be spliced
      | Tok_operator ("$", _) =>
        parse_expr ()

      // standard body enclosed by { ... }
      | Tok_operator ("{", _) =>
        shift ();
        match (peek_token ()) {
          | Tok_operator ("}", _) => 
            shift (); E_sequence (location (), [])
          | Tok_operator ("|", _) =>
            // convert function's parameters to tuple to be matched
            def parms_to_tupl (prs : list <Fun_parm>, acc) {
              match (prs) {
                | [] => E_tuple (List.Rev (acc))
                | ({name = SS_string (x); loc = l}) :: xs => 
                  parms_to_tupl (xs, E_ref (l, x) :: acc)
                | _ => fatal_error ("illegal spliced parameter?")
              }
            };
            push_back ();
            def cases = collect_braced_list (parse_match_case);
            match (parms) {
              | [{name = SS_string (x)}] => 
                E_Match (loc, E_ref (loc, x), cases)
              | _::_::_ => 
                def tup = parms_to_tupl (parms, []);
                tup.loc = loc;
                E_Match (loc, tup, cases)
              | [] =>             
                fatal_error ("functions with direct matching must have parameters")
              | _ => fatal_error ("illegal spliced parameter?")
            }
          | _ => 
            def r = E_sequence (loc, parse_expr_sequence ());
            expect_operator ("}");
            r
        }
      | _ =>
        fatal_error ("expected `{' at the beginning of function body")
    }
  }
  
  parse_type () : Type {
    def prim_type () {
      def get_args () {
        match (get_token ()) {
          | Tok_operator ("<", _) =>
            def args = operator_separated_list (",", parse_type);
            expect_operator (">");
            args
          | _ =>
            push_back ();
            []
        }
      };
      match (get_token ()) {
        | Tok_identifier
        | Tok_operator ("$", _) =>
          push_back ();
          def id = get_splicable_id ();
          def id = 
            match (peek_token ()) {
              | Tok_operator (".", _) =>
                shift ();
                match (id) {
                  | SS_string ({ idl = n }) => SS_string (Name (get_qid (n)))
                  | _ =>
                    fatal_error ("mixing spliced names with regular ids isn't allowed")
                }
              | _ => id;
            };
          match (peek_token ()) {
            | Tok_operator ("<", _) => 
              T_app (id, get_args ())
            | _ =>
              match (id) {
                | SS_string => T_app (id, [])
                | SS_spliced_expr (E_spliced ((E_type_enforcement) as tenf)) =>
                  T_spliced (tenf)

                | SS_spliced_expr (expr) =>
                  T_spliced (expr)
              }
          }

        | Tok_operator (".", _) =>
          expect_operator (".");
          match (get_splicable_id ()) {
            | SS_spliced_expr (e) =>
              T_type_list (T_spliced (e))
            | SS_string =>
              fatal_error ("expected spliced expression")
          }
          
        | Tok_keyword ("array") => 
          match (get_token ()) {
            | Tok_operator ("<", _) =>
              def rank = match (peek_token ()) {
                | Tok_integer_literal (i) => 
                  shift ();
                  expect_operator (",");
                  SI_int (i)
                | Tok_operator ("$", _) =>
                  match (get_splicable_id ()) {
                    | SS_spliced_expr (e) => 
                      expect_operator (",");
                      SI_spliced_expr (e)
                    | _ => Util.ice ("strange spliced")
                  }

                | _ => SI_int (1)
              }
              def t = T_array (parse_type (), rank);
              expect_operator (">");
              t

            | _ =>
              fatal_error ("expecting < after array")
          }
        
        | Tok_keyword ("ref") => T_ref (prim_type ())
        
        | Tok_keyword ("out") => T_out (prim_type ())

        | Tok_keyword ("void") => T_void ()

        | Tok_operator ("(", _) =>
          def t = parse_type ();
          expect_operator (")");
          t

        | _ =>
          fatal_error ("expecting type expression")
      }
    }

    and prod_type () {
      def loop (acc) {
        match (get_token ()) {
          | Tok_operator ("*", _) =>
            loop (prim_type () :: acc)
          | _ => 
            push_back ();
            match (acc) {
              | [x] => x
              | acc => T_prod (List.Rev (acc))
            }
        }
      };

      loop ([prim_type ()])
    };

    def fun_type () {
      def t = prod_type ();
      match (get_token ()) {
        | Tok_operator ("->", _) =>
          T_fun (t, fun_type ())
        | _ => 
          push_back ();
          t
      }
    };

    fun_type ()
  }

  /** allowed targets are:
        assembly: assembly 
        module:  module   (not supprted currently)
        class, struct, interface, enum: type 
        delegate: type, return
        method: method, return
        parameter: param 
        field: field 
        property indexer: property 
        property get accessor: method, return
        property set accessor: method, param, return
        event field: event, field, method
        event property: event, property (what is this?)
        event add: method, param
        event remove: method, param
  */
  get_attrs (main_target : System.AttributeTargets, allowed_targets : System.AttributeTargets) 
  : Modifiers * Hashtable <System.AttributeTargets, list <Expr>> 
  {
    mutable other_atts = null;
    def distribute_attributes (current_target, exps : list <Expr>) {
      if (current_target == System.AttributeTargets.All ||
          current_target == main_target)
        exps
      else {
        unless (current_target %&& allowed_targets)
          match (current_target) {
            | System.AttributeTargets.Assembly => 
              error ("[assembly: ...] custom attribute not allowed here");
            | System.AttributeTargets.Module  => 
              error ("[module: ...] custom attribute not allowed here");
            | System.AttributeTargets.Class =>
              error ("`type' target is here forbidden")     
            | System.AttributeTargets.Method  => 
              error ("`method' target is here forbidden")     
            | System.AttributeTargets.Property => 
              error ("`property' target is here forbidden")     
            | System.AttributeTargets.Field => 
              error ("`field' target is here forbidden")     
            | System.AttributeTargets.Event => 
              error ("`event' target is here forbidden")     
            | System.AttributeTargets.Parameter => 
              error ("`param' target is here forbidden")     
            | System.AttributeTargets.ReturnValue  => 
//              error ("`return' target is here forbidden") 
              Message.warning ("`return' target is not supported because of SRE limitations") 
            | x => Util.ice ("who set complex attribute? (" + x.ToString () + ")")
          }

        when (other_atts == null) other_atts = Hashtable ();
        match (other_atts.Get (current_target)) {
          | Some (l) => other_atts.Set (current_target, l + exps)
          | None => other_atts.Add (current_target, exps)
        };
        []
      }
    }

    def loop (acc, attrs) {
      def add_and_loop (attr : NemerleAttributes, attr_name : string) {
        when (attr %&& acc)
          Message.error ("attribute '" + attr_name + "' specified more than once");

        loop (attr %| acc, attrs)
      }
                        
      match (get_token ()) {
        | Tok_keyword ("mutable") => add_and_loop (NemerleAttributes.Mutable, "mutable")
        | Tok_keyword ("public") => add_and_loop (NemerleAttributes.Public, "public")
        | Tok_keyword ("private") => add_and_loop (NemerleAttributes.Private, "private")
        | Tok_keyword ("static") => add_and_loop (NemerleAttributes.Static, "static")
        | Tok_keyword ("new") => add_and_loop (NemerleAttributes.New, "new")
        | Tok_keyword ("protected") => add_and_loop (NemerleAttributes.Protected, "protected")
        | Tok_keyword ("internal") => add_and_loop (NemerleAttributes.Internal, "internal")
        | Tok_keyword ("abstract") => add_and_loop (NemerleAttributes.Abstract, "abstract")
        | Tok_keyword ("sealed") => add_and_loop (NemerleAttributes.Sealed, "sealed")
        | Tok_keyword ("override") => add_and_loop (NemerleAttributes.Override, "override")
        | Tok_keyword ("virtual") => add_and_loop (NemerleAttributes.Virtual, "virtual")
        | Tok_keyword ("volatile") => add_and_loop (NemerleAttributes.Volatile, "volatile")
        | Tok_operator ("[", _) =>
          def target = 
            match (get_token ()) {
              | Tok_identifier ("assembly") => System.AttributeTargets.Assembly
              | Tok_identifier ("field") => System.AttributeTargets.Field
              | Tok_keyword ("event") => System.AttributeTargets.Event
              | Tok_identifier ("method") => System.AttributeTargets.Method
              | Tok_keyword ("module") => System.AttributeTargets.Module
              | Tok_identifier ("param") => System.AttributeTargets.Parameter
              | Tok_identifier ("property") => System.AttributeTargets.Property
              | Tok_identifier ("return") => System.AttributeTargets.ReturnValue
              | Tok_keyword ("type") => System.AttributeTargets.Class
              | _ => 
                push_back ();
                System.AttributeTargets.All
            };
          when (target != System.AttributeTargets.All)
            expect_operator (":");

          def exps = operator_separated_list (",", parse_expr);
          expect_operator ("]");
          def main_attrs = distribute_attributes (target, exps);
          loop (acc, attrs + main_attrs)
        | _ =>
          push_back ();
          Modifiers (acc, attrs)
      }
    };

    def mods =
      match (peek_token ()) {
        | Tok_operator (".", _) =>
          expect_operator ("..");
          match (get_splicable_id ()) {
            | SS_spliced_expr (e) =>
              Modifiers (NemerleAttributes.None, [E_expr_list (E_spliced (e))])
            | SS_string =>
              fatal_error ("expected spliced expression")
          }
        | _ =>
          loop (NemerleAttributes.None, [])
      }

    // perform some sanity checks on the declared attributes
    when (mods.mods %&& NemerleAttributes.Virtual &&
          mods.mods %&& NemerleAttributes.Override)
      Message.warning ("the `virtual' attribute is redundant, `override' implies `virtual'");

    (mods, other_atts)
  }

  take_attributes_out (from : Hashtable <System.AttributeTargets, list <Expr>>, 
                       what : System.AttributeTargets,
                       comply_on_other : bool) : list <Expr>
  { 
    if (from != null) {
      def result = 
        match (from.Get (what)) {
          | Some (l) =>
            from.Remove (what);
            l
          | None => []
        };
      when (comply_on_other && from.Count > 0) {
        from.Iter (fun (x, y : list <Expr>) { 
          match (y) { 
            | expr :: _ =>  Message.error (expr.loc, "unexpected attribute target: " + x.ToString ());
            | _ => Util.ice ("targetted attribute without attribute")
          }
        });
      }
      result
    }
    else []
  }
  
  operator_separated_list<'a> (op : string, f : void -> 'a) : list <'a> {
    def loop (acc) {
      match (get_token ()) {
        | Tok_operator (o, _) when o == op => loop (f () :: acc)
        | _ => push_back (); List.Rev (acc)
      }
    };

    loop ([f ()])
  }

  parse_where_constraints (tyvars : list <string * int>, splicing_type : Type) 
  : Typarms 
  {
    def loop (acc) {
      if (flag_keyword ("where")) {
        match (peek_token ()) {
          | Tok_operator (".", _) =>
            shift ();
            expect_operator (".");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                (List.Rev (acc), T_spliced (e))
              | _ =>
                fatal_error ("expected spliced expression")
            }
          | _ =>
            def tv = get_tyvar ();
            expect_operator (":");
            def types = operator_separated_list (",", parse_type);
            def acc = List.FoldLeft (types, acc, fun (t, acc) { 
              Constraint (tv, t) :: acc 
            });
            loop (acc)
        }
      } else (List.Rev (acc), T_void ())
    };
    def (where_cts, where_spl_t) = loop ([]);
    match ((splicing_type, where_spl_t)) {
      | (T_void, T_void) =>
        Typarms (tyvars, where_cts)
      | _ =>
        Typarms (tyvars, Constraint (("", 0), T_prod ([splicing_type, where_spl_t])) 
                 :: where_cts)
    }
  }

  parse_property (name : Splicable_string, ret_ty : Type, prop_ty : Type,
                  attrs : Modifiers, dims : list<Fun_parm>) : Class_member
  {
    def parse_bd (p) {
      match (peek_token ()) {
        | Tok_operator (";", _) =>
          shift ();
          (FK_method ([]), FB_abstract ())
        | _ =>
          def bl = parse_block (p);
          (FK_method ([]), FB_parsed_expr (bl))
      };
    };

    mutable valid_targets = System.AttributeTargets.Method %| System.AttributeTargets.Field %|
      System.AttributeTargets.Parameter %| System.AttributeTargets.ReturnValue;
    mutable default_attrs = null;
    mutable other_attrs = null;

    def collect_attrs (main) {
      def (x, y) = get_attrs (main, valid_targets);
      default_attrs = x;
      other_attrs = y;
    }

    def plain_name = match (name) { | SS_string (n) => n.Id | _ => "" };
    
    mutable set = None (); mutable get = None ();
    def loc = location_here ();
    
    // parse embedded fields and add PropertyEmbeddedField macros to attributes
    collect_attrs (0 :> System.AttributeTargets);
    while (match (peek_token ()) { 
      | Tok_identifier (i) when i != "set" && i != "get" => true 
      | _ => false }) 
    {
      def nm = get_splicable_id ();
      match (parse_field (loc, nm, (default_attrs, other_attrs), false, None ())) {
        | M_field { loc = loc; ty = t} =>
          def funparm = [Fun_parm (loc, nm, t, default_attrs)];
          attrs.custom_attrs = <[ $(Name (["PropertyEmbeddedField"]) : name) (fun (..$funparm) {}) ]> 
            :: attrs.custom_attrs;
        | _ =>
          fatal_error ("only plain fields can be embedded into the property")
      }
      collect_attrs (0 :> System.AttributeTargets);
    }

    valid_targets &= ~System.AttributeTargets.Field;
    
    def take_get () {
      def (kind, bd) = parse_bd (dims);
      def name = SS_string (Name ("get_" + plain_name));
      def fh = Fun_header (loc, name, ret_ty, dims);
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      get = Some (M_function (loc, fh.name, default_attrs, fh, kind, bd));
    }
    def take_set () {
      def par_atts = Modifiers (NemerleAttributes.None, 
        take_attributes_out (other_attrs, System.AttributeTargets.Parameter, false));
      def setter_parms = dims + [Fun_parm (SS_string (Name (["value"])), ret_ty, par_atts)];
      def (kind, bd) = parse_bd (setter_parms);
      def name = SS_string (Name ("set_" + plain_name));
      def fh = Fun_header (loc, name, T_void (), setter_parms);
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      set = Some (M_function (loc, fh.name, default_attrs, fh, kind, bd));
      valid_targets &= ~System.AttributeTargets.Parameter;
    }

    match (get_token ()) {
      | Tok_identifier ("get") =>
        take_get ();
        collect_attrs (System.AttributeTargets.Method);

        match (get_token ()) {
          | Tok_identifier ("set") =>
            take_set ();
            expect_operator ("}");

          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `set' section of property or `}'")
        }

      | Tok_identifier ("set") =>
        take_set ();
        collect_attrs (System.AttributeTargets.Method);   
        match (get_token ()) {
          | Tok_identifier ("get") =>
            take_get ();
            expect_operator ("}");

          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `get' section of property or `}'")
        }
      | _ => fatal_error ("expecting `set' of `get' section of property")
    };

    M_property (loc = loc, name = name, modifiers = attrs, ty = ret_ty,
                prop_ty = prop_ty, set = set, get = get, dims = dims)
  }

  parse_event (name : Splicable_string, t : Type,
               attrs : Modifiers) : Class_member
  {
    def parse_bd (p) {
      match (peek_token ()) {
        | Tok_operator (";", _) =>
          shift ();
          (FK_method ([]), FB_abstract ())
        | _ =>
          def bl = parse_block (p);
          (FK_method ([]), FB_parsed_expr (bl))
      };
    };

    mutable valid_targets = System.AttributeTargets.Method %| System.AttributeTargets.Field %|
      System.AttributeTargets.Parameter %| System.AttributeTargets.ReturnValue;
    mutable default_attrs = null;
    mutable other_attrs = null;

    def collect_attrs (main) {
      def (x, y) = get_attrs (main, valid_targets);
      default_attrs = x;
      other_attrs = y;
    }

    def plain_name = match (name) { | SS_string (n) => n.Id | _ => "" };
    mutable add = None (); mutable remove = None ();
    def loc = location_here ();

    // parse embedded fields and add EventEmbeddedField macros to attributes
    collect_attrs (0 :> System.AttributeTargets);
    while (match (peek_token ()) { 
      | Tok_identifier (i) when i != "remove" && i != "add" => true 
      | _ => false }) 
    {
      def nm = get_splicable_id ();
      match (parse_field (loc, nm, (default_attrs, other_attrs), false, None ())) {
        | M_field { loc = loc; ty = t} =>
          def funparm = [Fun_parm (loc, nm, t, default_attrs)];
          attrs.custom_attrs = <[ EventEmbeddedField (fun (..$funparm) {}) ]> 
            :: attrs.custom_attrs;
        | _ =>
          fatal_error ("only plain fields can be embedded into the event")
      }
      collect_attrs (0 :> System.AttributeTargets);
    }

    valid_targets &= ~System.AttributeTargets.Field;
    def value_parm = Fun_parm (SS_string (Name (["value"])), t, Modifiers.Empty);

    def take_remove () {
      def (kind, bd) = parse_bd ([value_parm]);
      def name = SS_string (Name ("remove_" + plain_name));
      def fh = Fun_header (loc, name, T_void (), [value_parm]);
      value_parm.modifiers = Modifiers (NemerleAttributes.None, 
        take_attributes_out (other_attrs, System.AttributeTargets.Parameter, false));
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      remove = Some (M_function (loc, name, default_attrs, fh, kind, bd));
    }
    def take_add () {
      def (kind, bd) = parse_bd ([value_parm]);
      def name = SS_string (Name ("add_" + plain_name));
      def fh = Fun_header (loc, name, T_void (), [value_parm]);
      value_parm.modifiers = Modifiers (NemerleAttributes.None, 
        take_attributes_out (other_attrs, System.AttributeTargets.Parameter, false));
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      add = Some (M_function (loc, name, default_attrs, fh, kind, bd));
    }
    
    match (get_token ()) {
      | Tok_identifier ("remove") =>
        take_remove ();
        collect_attrs (System.AttributeTargets.Method);

        match (get_token ()) {
          | Tok_identifier ("add") =>
            take_add ();
            expect_operator ("}");
                                                
          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `add' section of event or `}'")
        }

      | Tok_identifier ("add") =>
        take_add ();
        collect_attrs (System.AttributeTargets.Method);

        match (get_token ()) {
          | Tok_identifier ("remove") =>
            take_remove ();
            expect_operator ("}");

          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `remove' section of event or `}'")
        }
      | _ => fatal_error ("expecting `add' or `remove' section of event")
    };
    M_event (loc = loc, name = name, modifiers = attrs, ty = t,
             add = add, remove = remove)
  }
  
  parse_indexer (loc : Location, name : Splicable_string, attrs : Modifiers) : Class_member
  {
    match (get_token ()) {
      | Tok_operator ("[", _) =>
        def parse_parm () { parse_funparm (false) };
        def parms =
        match (peek_token ()) {
          | Tok_operator ("]", _) => fatal_error ("indexer without indices")
          | Tok_operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                [Fun_parm (e.loc, SS_string (Name ([])), <[ type: void ]>, 
                           Modifiers (NemerleAttributes.None, [E_spliced (e)]))]
              | SS_string =>
                fatal_error ("expected spliced expression")
            }
          | _ => operator_separated_list (",", parse_parm)
        };
        expect_operator ("]");
        parse_field (loc, name, (attrs, null), false, Some (parms))
        
      | _ =>
        Util.ice ("parse_indexer")
    }
  }

  parse_field (loc : Location, name : Splicable_string, 
               rich_mods : Modifiers * Hashtable <System.AttributeTargets, list <Expr>>,
               is_event : bool, indexer_parms : option <list <Fun_parm>>) : Class_member
  {      
    def (attrs, other_attrs) = rich_mods;
    expect_operator (":");
    def t = parse_type ();

    match (get_token ()) {
      | Tok_operator (";", _) =>
        when (Option.IsSome (indexer_parms))
          Message.error (loc, "unexpected token `;' in indexer property declaration");
          
        if (is_event) {
          // FIXME: hack for embedded field and method targeted attributes in events
          def hacking_insert_field (x) {
            <[ ("field", $x) ]>
          }
          def hacking_insert_method (x) {
            <[ ("method", $x) ]>
          }
          attrs.custom_attrs += List.Map (take_attributes_out (other_attrs, System.AttributeTargets.Field, false),
                                          hacking_insert_field);
          attrs.custom_attrs += List.Map (take_attributes_out (other_attrs, System.AttributeTargets.Method, true),
                                          hacking_insert_method);

          M_event (loc = loc, name = name, modifiers = attrs, ty = t,
                   add = None (), remove = None ())
        }
        else {
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Field, true);
          M_field (loc = loc, name = name, modifiers = attrs, ty = t)
        }

      | Tok_operator ("{", _) =>
        if (is_event) {
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Event, false);
          parse_event (name, t, attrs)
        }
        else
        {
          def (prop_ty, indexer_parms) =
            match (indexer_parms) {
              | Some ([parm]) =>
                (T_fun (parm.ty, t), [parm])
                
              | Some (parms) =>
                def parms_prod_type =
                  T_prod (List.Map (parms, fun (fp : Fun_parm) { fp.ty }));
                  
                (T_fun (parms_prod_type, t), parms)
                
              | _ =>
                (t, [])
            }

          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Property, true);
          parse_property (name, t, prop_ty, attrs, indexer_parms)
        }

      | Tok_operator ("=", _) =>
        when (Option.IsSome (indexer_parms))
          Message.error (loc, "unexpected token `=' in indexer property declaration");
        
        def val = parse_expr ();
        expect_operator (";");
        def initializer = <[ $(Name (["StaticInitializer"]) : name) ]>;
        attrs.custom_attrs = <[ $initializer ($val) ]> :: attrs.custom_attrs;
        if (is_event)
          M_event (loc = loc, name = name, modifiers = attrs, ty = t,
                   add = None (), remove = None ())
        else
          M_field (loc = loc, name = name, modifiers = attrs, ty = t)

      | _ =>
        if (is_event)
          fatal_error ("expecting `;' finishing event declaration or `{'"
                       " for its body")
        else if (Option.IsSome (indexer_parms))
          fatal_error ("expecting `{' for indexer property declaration")
        else
          fatal_error ("expecting `;' finishing field declaration or `{'"
                       " for property declaration")
    }
  }

  parse_method (loc : Location, id : option <Splicable_string>,
                attrs : Modifiers) : Class_member
  {
    def parse_extern () {
      expect_keyword ("extern");
      match (get_token ()) {
        | Tok_string_literal (s) => 
          expect_operator (";");
          s
        | _ => fatal_error ("found some junk after extern (expecting string)")
      }
    };
    
    def ctr = 
      match (peek_token ()) {
        | Tok_keyword ("this") => true
        | _ => false
      };
    def h = parse_fun_header (allow_ctor = ctr, 
                              allow_inference = false,
                              is_lambda = false,
                              knownname = id);
    def impl =
      match (get_token ()) {
        | Tok_keyword ("implements") =>
          match (peek_token ()) {
            | Tok_operator (".", _) =>
              expect_operator ("..");
              match (get_splicable_id ()) {
                | SS_spliced_expr (e) =>
                  [SS_spliced_expr (E_expr_list (E_spliced (e)))]
                | _ =>
                  fatal_error ("expected spliced expression after `..'")
              }
            | _ =>
              operator_separated_list (",", get_splicable_qid)
          }
        | _ => push_back (); []
      };
    def body =
      match (peek_token ()) {
        | Tok_operator ("=", _) =>
          shift ();
          FB_extern (parse_extern ())
        | Tok_operator ("{", _) =>
          FB_parsed_expr (parse_block (h.parms))
        | Tok_operator (";", _) =>
          shift ();
          FB_abstract ()
        | Tok_operator ("$", _) =>
          match (get_splicable_id ()) {
            | SS_spliced_expr (e) =>
              FB_parsed_expr (E_spliced (e))
            | _ => Util.ice ("get_splicable_id returned impossible value")
          }
        | _ => fatal_error ("expecting method body")
      };

    M_function (header = h, 
                name = h.name, 
                modifiers = attrs, 
                loc = loc, 
                body = body, 
                kind = FK_method (impl))
  }

  parse_option (loc : Location, attrs : Modifiers) : Class_member {
    def id = get_splicable_id ();
    match (peek_token ()) {
      | Tok_operator ("{", _) =>
        def parse_field () {
          ignore (peek_token ());
          def loc = location_here ();
          def (attrs, _) = get_attrs (System.AttributeTargets.Field, System.AttributeTargets.Field);
          def id = get_splicable_id ();
          expect_operator (":");
          def ty = parse_type ();
          expect_operator (";");
          M_field (loc,
                   name = id,
                   modifiers = attrs,
                   ty = ty)
        };
        def members = collect_braced_list (parse_field);
        def td =
          TD_variant_option (name = id, modifiers = attrs, decls = members);
        td.loc = loc;
        M_type (loc = loc,
                name = td.name, 
                modifiers = td.modifiers, 
                td = td)

      | Tok_operator ("=", _) =>
        shift ();
        
        M_enum (loc = loc, name = id, modifiers = attrs, value = Some (parse_expr ()))

      | _ =>
        M_enum (loc = loc, name = id, modifiers = attrs, value = None ())
    };
  }
  
  parse_type_member () : Class_member {
    def loc = location_here ();
    def (attrs, other_atts) = get_attrs (0 :> System.AttributeTargets, System.AttributeTargets.Method %|
      System.AttributeTargets.Field %| System.AttributeTargets.Property %| System.AttributeTargets.Event %|
      System.AttributeTargets.Class);
    
    match (peek_token ()) {
      | Tok_operator ("$", _) | Tok_identifier =>
        def id = get_splicable_id ();
        match (peek_token ()) {
          | Tok_operator ("(", _)
          | Tok_operator ("<", _) => 
            attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Method, true);
            parse_method (loc, Some (id), attrs)
          | Tok_operator ("[", _) =>
            attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Property, true);
            parse_indexer (loc, id, attrs)            
          | _ =>
            parse_field (loc, id, (attrs, other_atts), false, None ())
        }
        
      | Tok_keyword ("this") =>
        attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Method, true);
        parse_method (loc, None (), attrs)

      | Tok_keyword ("event") =>
        shift ();
        attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Event, false);
        def id = get_splicable_id ();
        parse_field (loc, id, (attrs, other_atts), true, None ())

      | Tok_operator ("|", _) =>
        shift ();
        when (other_atts != null) error ("custom attributes not allowed on options");
        parse_option (loc, attrs)
        
      | _ =>
        def td = parse_type_decl ();
        attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Class, true);
        td.modifiers.mods |= attrs.mods;
        td.modifiers.custom_attrs += attrs.custom_attrs;
        M_type (loc = loc, 
                name = td.name, 
                modifiers = td.modifiers, 
                td = td)
    }
  }

  parse_type_decl () : TopDeclaration {
    def parse_header () {
      match (peek_token ()) {
        | Tok_identifier
        | Tok_operator ("$", _) =>
          def name = get_splicable_id ();
          def (tyvars, splicing_type) = parse_tyvars ();
            
          def t_extends =
            match (get_token ()) {
              | Tok_operator (":", _) =>
                match (peek_token ()) {
                  | Tok_operator (".", _) =>
                    expect_operator ("..");
                    match (get_splicable_id ()) {
                      | SS_spliced_expr (e) =>
                        [T_type_list (T_spliced (e))]
                      | SS_string =>
                        fatal_error ("expected spliced expression")
                    };
                  | _ =>
                    operator_separated_list (",", parse_type)
                }
              | _ => 
                push_back ();
                []
            };

          def typarms = parse_where_constraints (tyvars, splicing_type);
            
          (name, typarms, t_extends)
          
        | _ => fatal_error ("expecting type name")
      }
    };

    def parse_members () { collect_braced_list (parse_type_member) };
    
    def (attrs, other_attrs) = get_attrs (System.AttributeTargets.Class, 
                                          System.AttributeTargets.Class);
    def tok = get_token ();
    def loc = location_here ();
    def res =
      match (tok) {
        | Tok_keyword ("type")
        | Tok_keyword ("class")
        | Tok_keyword ("struct")
        | Tok_keyword ("module")
        | Tok_keyword ("interface")
        | Tok_keyword ("enum")
        | Tok_keyword ("variant") =>
          def (name, typarms, t_extends) = parse_header ();
          def td =
            match (tok) {
              | Tok_keyword ("class") =>
                TD_class (typarms, t_extends, parse_members ())
                
              | Tok_keyword ("struct") =>
                attrs.mods |= NemerleAttributes.Struct;
                TD_class (typarms, t_extends, parse_members ())
                
              | Tok_keyword ("module") =>
                attrs.mods |= NemerleAttributes.Module;
                TD_class (typarms, t_extends, parse_members ())
                
              | Tok_keyword ("type") =>
                expect_operator ("=");
                def t = parse_type ();
                expect_operator (";");
                TD_alias (typarms, t)
                
              | Tok_keyword ("interface") =>
                TD_interface (typarms, t_extends, parse_members ())
                
              | Tok_keyword ("variant") =>
                TD_variant (typarms, t_extends, parse_members ())

              | Tok_keyword ("enum") =>
                TD_enum (t_extends, parse_members ())
                
              | _ => Util.ice ()
            };
            
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Class, true);
          td.modifiers = attrs;
          
          td.name = name;
          td

        | Tok_keyword ("delegate") =>
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Class, true);
          def td = TD_delegate (parse_fun_header (false, false, false, None ()));
          expect_operator (";");
          td.modifiers = attrs;
          td

        | Tok_keyword ("macro") => 
          def header = parse_fun_header (true, false, false, None ());
          def synt = 
            match (peek_token ()) {
              | Tok_keyword ("syntax") =>
                shift ();
                expect_operator ("(");
                def parse_elems (acc) {
                  match (peek_token ()) {
                    | Tok_operator (")", _) =>
                      shift ();
                      List.Rev (acc)
                    | Tok_operator (",", _) =>
                      shift ();
                      parse_elems (parse_prim_expr (parse_closed_prim_expr ()) :: acc)
                    | _ =>
                      fatal_error ("expected comma separated expressions in "
                                   + "syntax description")
                  }
                };
                parse_elems ([parse_closed_prim_expr ()])
              | _ => []
            };
          def expr = parse_block ([]);
          def res = TD_macro (header, synt, expr);
          res.modifiers = attrs;
          res
       
        | _ => fatal_error ("expecting type declaration")
      };

    res.loc = loc;
    res
  }
  
  parse_topdecl () : TopDeclaration {
    def tok = get_token ();
    def loc = location_here ();
    def res =
      match (tok) {
        | Tok_keyword ("using") =>
          def id = get_splicable_qid ();
          match (get_token ()) {
            | Tok_operator ("=", _) =>
              def id = 
                match (id) {
                  | SS_string ({ idl = [x] }) => x
                  | SS_string ({ idl = x :: _ }) =>
                    Message.error ("namespace alias cannot contain dots");
                    x
                  | SS_spliced_expr =>
                    Message.fatal_error ("namespace alias cannot contain spliced expr");
                  | _ => Util.ice ("empty list")
                };
              def id' = get_splicable_qid ();
              expect_operator (";");
              TD_namespace_alias (id', Modifiers.Empty, id)
           
            | Tok_operator (";", _) =>
              /// FIXME: pass list
              MacroRegistry.LoadSyntaxExtensions (Nemerle.Utility.NString
                                                    .Concat (".", Macros.UnSString (id)));
              TD_open (id, Modifiers.Empty)

            | _ => fatal_error ("expecting `;' or `='")
          }
          
        | Tok_keyword ("namespace") =>
          def id = get_splicable_qid ();
          match (get_token ()) {
            | Tok_operator ("=", _) =>
              Message.warning ("`namespace ID = QID;' construct is obsolete, use `using ID = QID'");
              def id = 
                match (id) {
                  | SS_string ({ idl = [x] }) => x
                  | SS_string ({ idl = x :: _ }) =>
                    Message.error ("namespace alias cannot contain dots");
                    x
                  | SS_spliced_expr =>
                    Message.fatal_error ("namespace alias cannot contain spliced expr");
                  | _ => Util.ice ("empty list")
                };
              def id' = get_splicable_qid ();
              expect_operator (";");
              TD_namespace_alias (id', Modifiers.Empty, id)
              
            | Tok_operator ("{", _) =>
              // FIXME: pass list
              MacroRegistry.LoadSyntaxExtensions (Nemerle.Utility.NString
                                                    .Concat (".", Macros.UnSString (id)));
              push_back ();
              def decls = collect_braced_list (parse_topdecl);
              TD_namespace (id, Modifiers.Empty, decls)

            | _ => fatal_error ("expecting '}'")
          }

        | Tok_operator ("[", _) =>
          match (peek_token ()) {
            | Tok_identifier ("assembly") =>
              shift ();
              expect_operator (":");
              def body = parse_expr ();
              expect_operator ("]");
              TD_attribute (null, Modifiers.Empty, body)
            | _ =>
              push_back ();
              parse_type_decl ()
          }

        | _ =>
          push_back ();
          parse_type_decl ()
      };

    res.loc = loc;
    res
  }

  parse_quotation () : Expr {
    def tok = get_token ();
    def loc = location ();
    
    E_quoted (loc,
      match (get_token ()) {
        | Tok_operator (":", _) =>
          match (tok) {
            | Tok_keyword ("type") =>
              SyntaxType (parse_type ())

            | Tok_identifier ("ttype") =>
              SyntaxTType (parse_type ())
            
            | Tok_identifier ("case") =>
              SyntaxCase1 (parse_match_case ())

            | Tok_identifier ("caseguard") =>
              SyntaxCaseGuard1 (parse_case_guard ())

            | Tok_identifier ("fundecl") =>
              def h = parse_fun_header (allow_ctor = false, 
                                        allow_inference = true, 
                                        is_lambda = false, knownname = None ());
              SyntaxFunDecl (Function_decl (h, parse_block (h.parms)))

            | Tok_identifier ("funparm") =>
              SyntaxFunParm (parse_funparm (allow_inference = true))

            | Tok_identifier ("decl") =>
              SyntaxDeclaration (parse_type_member ())
              
            | _ =>
              fatal_error ("bad quotation type")
          }
        | _ =>
          push_back (); 
          push_back ();
          def expr =
            match (parse_expr_sequence ()) {
              | [x] => x
              | l => E_sequence (loc, l)
            };
          SyntaxExpr (expr)
      }
    )
  }
  
  collect_braced_list<'a> (f : void -> 'a) : list <'a> {
    expect_operator ("{");
    def r = collect_list (f);
    expect_operator ("}");
    r
  }
  
  collect_list<'a> (f : void -> 'a) : list <'a> {
    def loop (acc) {
      match (peek_token ()) {
        | Tok_operator ("}", _) | Tok_EOF => List.Rev (acc)
        | _ =>
          loop (f () :: acc)
      }
    };
    loop ([])
  }

  public variant GrammarElement {
    | GE_operator { name : string; }
    | GE_keyword { name : string; }
    | GE_expression
    | GE_funparm
    | GE_expression_list { separator : string; }
    | GE_optional { body : GrammarElement; }
  }

  parse_wrt_rule (rule : list <GrammarElement>) : list <SyntaxElement> {
    def loop (acc, lst) {
      match (lst) {
        | GE_operator (n) :: xs =>
          expect_operator (n);
          loop (acc, xs)

        | GE_keyword (n) :: xs =>
          expect_keyword (n);
          loop (acc, xs)

        | GE_expression :: xs =>
          def expr = parse_expr ();
          loop (SyntaxExpr (expr) :: acc, xs)

        | GE_expression_list (sep) :: xs =>
          def exprs = operator_separated_list (sep, parse_expr);
          loop (List.RevAppend (List.Map (exprs, fun (e) { SyntaxExpr (e) }), 
                                 acc), xs)

        | GE_funparm :: xs =>
          def p = parse_funparm (allow_inference = true);
          loop (SyntaxFunParm (p) :: acc, xs)

        | GE_optional (GE_operator (n)) :: xs =>
          match (peek_token ()) {
            | Tok_operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
              expect_operator (n)
            | _ => ()
          };
          loop (acc, xs)

        | GE_optional (GE_keyword (n)) :: xs =>
          match (peek_token ()) {
            | Tok_keyword (o) when o == n => shift ();
            | _ => ()
          };
          loop (acc, xs)

        | GE_optional (GE_expression) :: GE_keyword (n) :: xs =>
          match (peek_token ()) {
            | Tok_keyword (o) when o == n =>
              shift ();
              loop (SyntaxExpr (null) :: acc, xs)
            | _ =>
              def expr = parse_expr ();
              expect_keyword (n);
              loop (SyntaxExpr (expr) :: acc, xs)
          };
          
        | GE_optional (GE_expression) :: GE_operator (n) :: xs =>
          match (peek_token ()) {
            | Tok_operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
              shift ();
              loop (SyntaxExpr (null) :: acc, xs)
            | _ =>
              def expr = parse_expr ();
              expect_operator (n);
              loop (SyntaxExpr (expr) :: acc, xs)
          };

        | _ :: _ => Message.fatal_error ("syntax definition of macro is ambiguous")
          
        | [] => List.Rev (acc)
      }
    };

    loop ([], rule)
  }

  internal make_parsing_function (macro_ns : GlobalEnv.NamespaceND,
                                rule : list <GrammarElement>, 
                                perm : list <SyntaxElement> -> list <SyntaxElement>) 
                                : void -> Expr 
  {
    fun () {
      def loc = location ();
      def parms = parse_wrt_rule (rule);
      E_macrocall (loc, Name ([]), macro_ns, perm (parms))
    }
  }

  parse_list () : list <Expr>
  {
    def parse_list () {
      match (peek_token ()) {
        | Tok_operator ("]", _) => []
        | Tok_operator (",", _) =>
          shift ();
          parse_expr () :: parse_list ()
        | _ =>
          fatal_error ("expecting expression in list literal")
      }
    };
    match (peek_token ()) {
      | Tok_operator ("]", _) => []
      | _ =>
        def expr = parse_expr ();
        expr :: parse_list ()
    }
  }

  init_parens () : void {
    def add (o, c, f) {
      ctx.parens.Add (o, ParenCallback (o, c, f));
      ctx.closing_parens.Add (c, 0);
    };
    add ("<[", "]>", parse_quotation);
    
    add ("[", "]", fun () {
      def loc = location ();
      def make_list (exps : list <Expr>) {
        match (exps) {
          | [] => E_call (loc, E_ref (loc, Name (["Nil"])), [])
          | x :: xs => E_call (x.loc, E_ref (x.loc, Name (["Cons"])), 
                               [x, make_list (xs)])
        }
      };
      make_list (parse_list ())
    });
  }

  public parse (lexer : LexerBase) : list <TopDeclaration>
  {
    ctx.lexer = lexer;
    ctx.last_token1 = null;
    ctx.last_token2 = null;
    ctx.push_back = 0;
    MacroRegistry.RemoveSyntaxExtensions ();
    Location_stack.push_fn (location_here);
    def r = collect_list (parse_topdecl);
    Location_stack.pop ();
    match (peek_token ()) {
      | Tok_EOF => r
      | _ => fatal_error ("expecting EOF")
    }
  }

  public ParseExpr (expr : string) : Expr
  {
    ctx.lexer = LexerString (expr, Location_stack.top ());
    ctx.last_token1 = null;
    ctx.last_token2 = null;
    ctx.push_back = 0;
    MacroRegistry.RemoveSyntaxExtensions ();
    def r = parse_expr ();
    match (peek_token ()) {
      | Tok_EOF => r
      | _ => fatal_error ("expecting EOF")
    }
  }
  
} // end module
} // end namespace
