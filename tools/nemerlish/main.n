#if READLINE
using Mono.ReadLine;
#endif
using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility.NString;
using SC = System.Console;
using System.IO;
using System.Text;
using System.Text.RegularExpressions.Regex;
using Interp = Nemerle.Evaluation.Interpreter.Internals;
  
namespace Nemerle.Evaluation.Interpreter
{  
  module MainClass
  {
    Main () : void {
      def histfile = "hist.txt";

      def print_welcome () : void {
        SC.WriteLine ("Welcome to Nemerle interpreter.\n");
        SC.WriteLine ("Please enter expressions appended with \";;\".");
        SC.WriteLine ("To add open namespaces, reference libraries or set "
                      "various preferences, use");
        SC.WriteLine ("properties from the Interp namespace. Their list is "
                      "available via \"Interp.Help;;\"\n");
      }
      print_welcome ();
  
      def e = Nemerle.Evaluation.Evaluator ();
      def printev (c) {
        try { 
          def (nmnvts) = e.Eval (Interp.RefParsed, 
                                 Interp.UsingParsed, c);
          Iter (nmnvts, fun (x) {
            def (newvar, mut, name, val, ty) = x;
            when (newvar) 
              match ((mut, val, ty)) {
                | (false, null, _) =>
                  SC.WriteLine ($"def $name : $ty")
                | (_, null, _) =>
                  SC.WriteLine ($"mutable $name : $ty")
                | (_, _, <[ $_ -> $_ ]>) =>
                  SC.WriteLine ($"def $name : $ty")
                | (false, _, _) => 
                  SC.WriteLine ($"def $name = $val : $ty")
                | _ => 
                  SC.WriteLine ($"mutable $name = $val : $ty")
            }
          })
        } 
        catch {
          | e is System.Exception =>
            unless (Nemerle.Compiler.Message.SeenError) {
              SC.WriteLine (e.Message + e.StackTrace);
              SC.WriteLine (e.ToString ())
            }
        } 
      }

#if READLINE
      def rl = GnuReadLine ();
      HistoryFile.RecreateHistory (100, rl, histfile);
#endif
      def readinput (code : string) : void {
#if READLINE
        def line = rl.ReadLine (Interp.Prompt);
#else
        SC.Write (Interp.Prompt);
        def line = SC.ReadLine ();
#endif
        match (line) {
          | null => ()
          | _ => 
#if READLINE
            rl.AddHistory (line);
            HistoryFile.AddHistory (histfile, line);
#endif
            regexp match (line) {
              | @"^\s*$" => readinput (code)
              | _ =>  { 
                def l = line.TrimEnd ();
                if (l.EndsWith (";;")) {
                  def m = code + l.TrimEnd (array [';',' ','\t']);
                  regexp match (m) {
                    | @"(?<beg>.*([;}]\s*|^\s*))using\s+(?<use>[a-zA-Z0-9]+((\.[a-zA-Z0-9]+)*(\s*=\s*[a-zA-Z0-9]+)*)*)[\s;]*(?<end>.*)$" => 
                      if (Interp.Using != "") 
                        Interp.Using = use + ", " + Interp.Using
                      else 
                        Interp.Using = use;
                      def c = beg + end;
                      when (c != "")
                        printev (c)
                    | @"^\s*!(?<input>.*)$" => 
                      def p = System.Diagnostics.Process ();
                      match (input) {
                        //FIXME: Windows users
                        | "" => 
                          if (System.Environment.GetEnvironmentVariable ("SHELL") != "")
                            p.StartInfo.FileName = "$SHELL"
                          else
                            p.StartInfo.FileName = "cmd.exe"
                        | _ => p.StartInfo.FileName = input
                      }
                      p.StartInfo.UseShellExecute = true;
                      _ = p.Start();    
                      p.WaitForExit()
                    | _ => printev (m)
                  }
                  Interp.Prompt = Interp.PS1;
                  readinput ("") 
                }
                else { 
                  Interp.Prompt = Interp.PS2;
                  readinput (code + line + " ") 
                }
              }
            }
        }
      }
  
      //FIXME: this is a temporary workaround, to be removed later
      Interp.Ref = "";
      Interp.Using = "";
  
      readinput ("")
    }
  }

  module HistoryFile {
    public AddHistory (filename: string, line : string) : void {
      def sw = File.AppendText (filename);
      sw.WriteLine (line);
      sw.Close ();
    }

    public RecreateHistory (ln : int, rl : GnuReadLine, filename : string) : void {
      def sr = File.OpenText (filename);
      def loop (i, prev) {
        def l = sr.ReadLine ();
        when (l != null && i < ln) {
          when (l != prev) 
            rl.AddHistory (l);
          loop (i + 1, l)
        }
      }

      loop (0, "");
      sr.Close ();
    }
  }
} 
