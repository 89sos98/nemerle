using System.Xml;
using Nemerle.Collections;
using Nemerle.IO;
using NSokoban.Macros;

namespace NSokoban
{
    public struct MapCollection
    {
	private mutable maps : list[Map]; 
	private doc : XmlDocument;
	
	public this (file_name : string)
	{
	    maps = [];
	    doc = XmlDocument ();
	    def reader = XmlTextReader (file_name);
	    doc.Load (reader);
	    translate_xml ();
	}

	private translate_xml () : void
	{
	    def nodes = doc.SelectNodes("SokobanLevels/LevelCollection/Level");
	    for(mutable i=0 ; i<nodes.Count ; i+=1)
	    {
		def lines = nodes[i].SelectNodes("L");

		def width = System.Int32.Parse(nodes[i].Attributes["Width"].Value);
		def height = System.Int32.Parse(nodes[i].Attributes["Height"].Value);

		mutable er = 0;

		mutable xpos = None ();
		mutable ypos = None ();

		def sarray = array(height);
		
		for (mutable j=0; j<lines.Count ; j+=1 )
		{
		    sarray[j] = lines[j].InnerText;
		    for(mutable k=0; k < lines[j].InnerText.Length ; k+=1 )
			match(lines[j].InnerText[k])
			{
			    | '@' => 
				xpos = Some(k);
				ypos = Some(j);
				def chars = sarray[j].ToCharArray();
				chars[k] = ' ';
				sarray[j] = System.String(chars);
			    | '%' => 
				xpos = Some(k);
				ypos = Some(j);
				def chars = sarray[j].ToCharArray();
				chars[k] = '.';
				sarray[j] = System.String(chars);
			    | '$' => ++er;
			    | _ => ()				
			}
		}
		def map = Map(width,height,Option.UnSome(xpos),Option.UnSome(ypos),sarray,"",er);
		maps = map :: maps;
	    }
	    maps = List.Rev(maps);
	}

	public override ToString () : string
	{
	    def buffer = System.Text.StringBuilder ("");
	    List.Iter(List.Rev(maps),fun(map : Map){ ignore (buffer.Append(map.ToString() + "\n\n"))  });

	    buffer.ToString ();
	}

	public Nth (n : int) : Map
	{
	    List.Nth(maps,n)    
	}

    }

    public class Map
    {
	private xsize : int;			// width of the map
	private ysize : int;			// height of the map

	public mutable xpos : int;	// x position of worker
	public mutable ypos : int;	// y position of worker
	
	private mutable error : int;
	
	private mutable map : array [string];	
	
	public mutable moves_so_far : string;	// moves made so far

	public this(xsize : int , ysize : int,xpos : int,ypos : int, map : array[string],moves : string,error : int)
	{
	    this.xsize = xsize;
	    this.ysize = ysize;
	    this.map = (map.Clone() :> array[string]);	    	    	    
	    this.xpos = xpos;
	    this.ypos  = ypos;
	    this.moves_so_far = moves;
	    this.error = error;
	}

	public IncError () : void
	{
	    ++error;
	}

	public DecError () : void
	{
	    --error;    
	}

	public Error : int
	{
	    get
	    {
		error	
	    }
	}
    
	public AddMove (move : string) : void
	{
	    moves_so_far = moves_so_far + move;    
	}

	public override ToString () : string
	{
	    def buffer = System.Text.StringBuilder ("");
	    for (mutable i = 0 ; i < ysize ; i+=1)
	    {
		for(mutable k=0;k < map[i].Length;k+=1)	
		    if(k == xpos && i == ypos)
			ignore(buffer.Append("@"));	
		    else
			ignore(buffer.Append(map[i][k]));
		ignore(buffer.Append("\n"));
	    }	    

	    buffer.ToString () + " " + moves_so_far;
	}

	public Id : string
	{
	    get
	    {
		def buffer = System.Text.StringBuilder ("");
		for (mutable i = 0 ; i < ysize ; i+=1)	    
		    for(mutable k=0;k < map[i].Length;k+=1)	
			if(k == xpos && i == ypos)
			    ignore(buffer.Append("@"));	
			else
			    ignore(buffer.Append(map[i][k]));	    	    

		buffer.ToString ();		
	    }
	}

	public GoalTest () : bool
	{
	    error == 0
	}

	public NextStates () : list[Map] // trying to move to all directions
	{
	    def moves = array["U","D","L","R"];
	    mutable result = [];
	    
	    foreach(move : string in moves)
	    {
		def (nx,ny) = NextMove(xpos,ypos,move);
		
		match(map[ny][nx])
		{
		    | '.' => 			
			def new_map = Map(xsize,ysize,nx,ny,this.map,moves_so_far + move,error);
			
			result = new_map :: result;
		    
		    | ' '  => 
			def new_map = Map(xsize,ysize,nx,ny,this.map,moves_so_far + move,error);		

			result = new_map :: result;
		

		    | '$' =>
			def (nnx,nny) = NextMove(nx,ny,move);
	    
			def new_map = Map(xsize,ysize,nx,ny,this.map,moves_so_far + move,error);

			def chars = new_map.map[ny].ToCharArray();
			chars[nx] = ' ';
			new_map.map[ny] = System.String(chars);
			
			match(map[nny][nnx])
			{
			    | '.' => 			    
				def chars = new_map.map[nny].ToCharArray();
				chars[nnx] = '*';
				new_map.map[nny] = System.String(chars);
				
				new_map.error -= 1;
				result = new_map :: result;
		
			    | ' ' =>
				def chars = new_map.map[nny].ToCharArray();
				chars[nnx] = '$';
				new_map.map[nny] = System.String(chars);
				result = new_map :: result;
		
			    | _ => ()
			}
		    
		    | '*' =>
			def (nnx,nny) = NextMove(nx,ny,move);
			
			def new_map = Map(xsize,ysize,nx,ny,this.map,moves_so_far + move,error);
			
			def chars = new_map.map[ny].ToCharArray();
			chars[nx] = '.';
			new_map.map[ny] = System.String(chars);

			match(map[nny][nnx])
			{
			    | '.' => 			    
				def chars = new_map.map[nny].ToCharArray();
				chars[nnx] = '*';
				new_map.map[nny] = System.String(chars);

				result = new_map :: result;
		
			    | ' ' =>
				def chars = new_map.map[nny].ToCharArray();
				chars[nnx] = '$';
				new_map.map[nny] = System.String(chars);
				new_map.error += 1;
				result = new_map :: result;
		
			    | _ => ()
			}
		    | _ => ()
		}
	    }
    
	    result	    
	}
	
    }
}
