(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public variant Decl_kind
  {
    | D_local_fun {
        header : Fun_header; 
        uses_closure_of : list (Fun_header); 
      }
    | D_fun_parm
    | D_local_value
    | D_exn
    | D_pattern_variable
    | D_closurised_this_ptr
  }
  
public variant Symbol {
  | Sym_local { decl : Decl; }
  | Sym_type { tycon : Tycon; }
  | Sym_type_member { member : IMember; }
}

public class Decl 
  {
    public loc : Location;
    public name : string;
    public mutable is_ref : bool;
    public mutable ty : Type;
    public id : int;
    public kind : Decl_kind;
    
    public mutable parent_fun : option (Fun_header);
    public mutable in_closure : bool;
    (**
     * Used for pattern variables. True iff variable is used in body of match,
     * not only in guard. 
     *)
    public mutable is_pattern_outcome : bool;
    
    public this (n : string, k : Decl_kind, ty : Type, par : Fun_header)
      {
        this.loc <- Location_stack.top();
        this.name <- n;
        this.ty <- ty;
        this.kind <- k;
        this.is_ref <- false;
        this.parent_fun <- Some (par);
        this.id <- Util.next_id();
      }
      
(*
    public fun_header () : Fun_header {
      match (this.kind) {
        | (D_local_fun) as x => x.header
        | D_class_member ((M_function) as x) => x.header
        | _ => Util.ice ()
      }
    }*)

    public kind_as_string () : string {
      match (this.kind) {
        | D_local_fun => "a local function"
        | D_fun_parm => "a function parameter"
        | D_local_value => "a local value"
        | D_exn => "a caught exception"
        | D_pattern_variable => "a value bound in pattern"
        | D_closurised_this_ptr => "a 'this' pointer" // not reached?
      }
    }
  }

public class Env 
  {
    static mutable types : Hashtable (string, Tycon);

    static this () {
      types <- Hashtable (2000);
    }

    mutable open_namespaces : list (string);
    public mutable current_namespace : string; // FIXME: make non-public
    mutable namespace_aliases : String_map (string);
    mutable locals : String_map (Decl);

    public static AddType (name : string, t : Tycon) : void {
      match (types.Get (name)) {
        | Some (t') when t'.SameAs (t) => ()
        | Some (t') =>
          Message.error (t.GetLocation (), "redefinition of type `" + name + "'");
          Message.error (t'.GetLocation (), "first defined here")
        | None => 
          types.Add (name, t)
      }
    }
    
    expand_namespace_aliases (sym : string) : string {
      def ns = Util.get_ns (sym);
      if (ns == "") sym
      else
        match (namespace_aliases.find (ns)) {
          | Some (r) => r + "." + sym.Substring (sym.LastIndexOf ('.') + 1)
          | None => sym
        }
    }

    public static LookupInternalType (name : string) : Tycon {
      match (LookupExactType (name)) {
        | Some (t) => t
        | None => Util.ice ("unbound internal type " + name)
      }
    }

    public static LookupExactType (name : string) : option (Tycon) {
      //Message.debug ("let " + name);
      match (types.Get (name)) {
        | (Some) as r => r
        | None =>
          def res = LibraryReferenceManager.LookupType (name);
          // this is just speed cache
          match (res) {
            | Some (tc) => types.Add (name, tc)
            | None => ()
          };
          res
      }
    }

    public GetType (name : string) : Tycon {
      match (LookupType (name)) {
        | Some (r) => r
        | _ =>
          Message.fatal_error ("unbound type name `" + name + "'")
      }
    }

    public LookupType (name : string) : option (Tycon) {
      def name = expand_namespace_aliases (name);
      match (LookupExactType (name)) {
        | (Some) as r => r
        | None =>
          def collect (res, pref) {
            match ((res, LookupExactType (pref + "." + name))) {
              | (x, None) | (None, x) => x
              | (Some (x), Some (y)) when x.SameAs (y) => res
              | (Some (x), Some (y)) =>
                Message.error ("type name `" + name + "' is ambiguous, it could be:");
                Message.error (x.GetLocation (), "   this declaration");
                Message.error (y.GetLocation (), "   or this declaration");
                res
            }
          };
          List.fold_left (collect, None (), current_namespace :: open_namespaces)
      }
    }
    
    public LookupLocal (name : string) : option (Decl) {
      locals.find (name)
    }

    public LookupSymbol (name : string) : list (Symbol) {
      match (locals.find (name)) {
        | Some (d) => [Sym_local (d)]
        | None =>
          def visited = Hashtable (10);
          def lookup_members (acc, pref) {
            match (LookupExactType (pref)) {
              | Some (t) when ! visited.Contains (t.GetId ()) => 
                def encapsulate (acc, m : IMember) {
                  match (m.GetKind ()) {
                    | MK_type => acc // nested types already added
                    | _ => Sym_type_member (m) :: acc
                  }
                };
                def members = t.LookupMember (name, LF_all ());
                visited.Add (t.GetId (), null);
                List.fold_left (encapsulate, acc, members)
              | _ => acc
            }
          };
          def types =
            match (LookupType (name)) {
              | Some (t) => [Sym_type (t)]
              | None => []
            };
          List.fold_left (lookup_members, types, open_namespaces);
      }
    }

    // FIXME: make following methods UpperCase
    public add_open (ns : string) : void {
      open_namespaces <- List.append (open_namespaces, [ns]);
    }

    public add_namespace_alias (short_name : string, long_name : string) : void {
      this.namespace_aliases <- this.namespace_aliases.add(short_name, long_name)
    }
    
    public add_local (name : string, kind : Decl_kind, ty : Type, parent_fun : Fun_header) : (Env * Decl)
      {
        def c = this.copy();
        def d = Decl(name, kind, ty, parent_fun);
        c.locals <- c.locals.replace(name, d);
        (c, d)
      }

    public add_local (d : Decl) : Env
      {
        def c = this.copy();
        c.locals <- c.locals.replace (d.name, d);
        c
      }
      
    public in_prefix (pref : string) : Env
      {
        def env' = this.copy ();
        env'.current_namespace <- this.current_namespace + pref + ".";
        env'
      }

    public copy () : Env
      {
        def c = Env ();
        c.open_namespaces <- this.open_namespaces;
        c.current_namespace <- this.current_namespace;
        c.namespace_aliases <- this.namespace_aliases;
        c.locals <- this.locals;
        c
      }

    public this () 
      {
        this.current_namespace <- "";
        this.open_namespaces <- [];
        this.locals <- Map.string_map();
        this.namespace_aliases <- Map.string_map();
      }
  }


} // ns
