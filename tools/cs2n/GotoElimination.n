// Copyright (c) 2003-2005 The University of Wroclaw.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. The name of the University may not be used to endorse or promote
//       products derived from this software without specific prior
//       written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
// NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

#if GOTO_ELIMINATION

using Nemerle.Collections;

namespace Nemerle.CSharp
{
    public partial variant STree
    {
	private mutable mod_by_ge : bool;

	private set_mod_by_ge () : void
	{
	    mod_by_ge = true;    
	}

	private mutable labels_inside : list [string];
	private mutable gotos_inside : list [string];

	private add_condition (cond : string, op : string) : STree
	{
	    match (this)
	    {
		| Statement("WHEN",[ when_st , lp , TokS(old_cond) , rp , st ] ) =>
		    Statement("WHEN",[ when_st , lp , TokS(old_cond + " " + op + " " + cond) , rp , st ] )
		    
		| Statement("WHEN",[ when_st , lp , Tok(old_cond) , rp , st ] ) =>
		    Statement("WHEN",[ when_st , lp , TokS(ExtendedToken.getTextOnly(old_cond) + " " + op + " " + cond) , rp , st ] )

		| Statement("DO",[d,block,w,lp,Tok(old_cond),rp,s]) =>
		    Statement("DO",[d,block,w,lp,TokS(ExtendedToken.getTextOnly(old_cond) + " " + op + " " + cond),rp,s])

		| Statement("DO",[d,block,w,lp,TokS(old_cond),rp,s]) =>
		    Statement("DO",[d,block,w,lp,TokS(old_cond + " " + op + " " + cond),rp,s])

		| x => x
	    }
	}

	private _add_and_condition (cond : string) : STree {add_condition (cond , "&&");}
	
	private _add_or_condition (cond : string) : STree {add_condition (cond , "||");}		
	
	public this ()
	{
	    labels_inside = [];
	    gotos_inside = [];

	    mod_by_ge = false;
	}
	
	private add_label (label : string) : void
	{
	    labels_inside = label :: labels_inside
	}

	private add_goto (goto : string) : void
	{
	    gotos_inside = goto :: gotos_inside    
	}
	
	//FIXME: change internal -> private later
	/**
	 *  returns: init_vars * changed_tree * lifted_gotos
	 */
	internal eliminate_gotos (/*depth : int*/) : list [STree] * STree * list [STree]
	{
	    def get_labels_and_gotos (lst , acc1 , acc2 )
	    {
		match(lst)
		{
		    | [] => ( acc1 , acc2 )
		    | Statement( "LABEL" , Tok(id) :: _) :: tail=>
		    	
			get_labels_and_gotos (tail , ExtendedToken.getTextOnly (id) :: acc1 , acc2 )

		    | Statement("WHEN", [ _ , _ , _ , _ , Statement( "GOTO" , [_ , Tok (id), _] ) ] )  :: tail =>
		    
			get_labels_and_gotos (tail , acc1 , ExtendedToken.getTextOnly (id) :: acc2 )
		
		    | _ :: tail=>
		     
			get_labels_and_gotos (tail , acc1, acc2)
		}
	    }

	    def lift_up_gotos ( labels , statements , acc1 , acc2 , acc3)
	    {
		match(statements)
		{
		    | [] => (acc1 , List.Rev(acc2) , acc3)
		    
		    | Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , Statement( "GOTO" , [ Tok(b) , Tok (id), s] ) ] ) as goto_st :: tail=>


			if ( List.Member (labels , ExtendedToken.getTextOnly (id) ))
			    lift_up_gotos ( labels , tail, acc1 , goto_st :: acc2 , acc3);
			else
			{
			    def ws = ExtendedToken.getWhitespaces (when_tok);
			    
			    def ( vars , block , gotos ) = Statement ("BLOCK" , 
				Tok (ExtendedToken (ws , "{")) :: tail + [Tok (ExtendedToken(ws , "}"))]).eliminate_gotos ();
			    
			    def gs = new_goto_symbol ();
			    def es = TokS (ws + gs + " = true;");
			    
			    def if_st = Statement ("IF" , [Tok (ExtendedToken (ws, "if")) , lp , cond , rp , es ,
							   Tok (ExtendedToken (ws, "else")) , block ]);

			    (if_st : STree).set_mod_by_ge ();

			    def when_st = Statement ( "WHEN" , [ Tok(ExtendedToken(ws,"when")),
							TokS("("), TokS(gs), TokS(")"), Statement( "GOTO" , [ Tok(b) , Tok (id), s] )] );
			   
			    lift_up_gotos ( labels , [] , when_st :: gotos + acc1 , if_st :: acc2 , 
					    Tok (ExtendedToken(ws , "mutable " + gs + " = false")) :: acc3 + vars)
			}
		    | head :: tail => 

			lift_up_gotos ( labels , tail, acc1 , head :: acc2 , acc3);
		}
	    }	    

	    def search (statements , goto , label , acc ) 
	    {
		match(statements)
		{
		    | [] => (acc , None () , []) 
			// FIXME: should be error
			//assert (false)

		    | Statement("WHEN", [ _ , _ , cond , _ , Statement( "GOTO" , [ _ , Tok (id), _] ) ] ) as goto_st :: tail when goto =>
			if (ExtendedToken.getTextOnly (id) == label)
			    (List.Rev (acc) , Some (cond) , tail) //second argument passes condition for do
			else
			    search ( tail , goto , label , goto_st :: acc )
			    
		    | Statement ("LABEL", [Tok(id), _ , st ] ) as label_st :: tail when !goto =>
			if (ExtendedToken.getTextOnly (id) == label)
			    (List.Rev (acc) , Some (st) , tail ) //second argument passes labelled statement
			else
			    search ( tail , goto , label , label_st :: acc )

		    | head :: tail =>

			    search ( tail , goto , label , head :: acc )
		}
	    }

	    def eliminate_in_one_level ( statements , acc)
	    {
		match(statements)
		{
		    | [] => List.Rev (acc)
		    | Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , Statement( "GOTO" , [ _ , Tok (id), _] ) ] ) :: tail =>
		    
			def ws = ExtendedToken.getWhitespaces (when_tok);
		    
			def (crossed, st , rest )= search ( tail , false , ExtendedToken.getTextOnly (id) , []);

									    //FIXME:
			def block = Statement ("BLOCK" , TokS (ws + "{") :: eliminate_in_one_level (crossed , []) + [TokS (ws + "}")]);

			def new_when = Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , block ] );

			(new_when : STree).set_mod_by_ge ();

			eliminate_in_one_level (rest, Option.UnSome (st) :: new_when :: acc);

		    | Statement ("LABEL", [Tok(id), _ , st ] ) :: tail =>

			def ws = ExtendedToken.getWhitespaces (id);

			def (crossed , cond , rest) = search ( tail , true , ExtendedToken.getTextOnly (id) , []);

			def block = Statement ("BLOCK" ,		    //FIXME:
			    TokS (ws + "{") :: st :: eliminate_in_one_level (crossed , []) + [TokS (ws + "}")]);

			def new_do = Statement("DO",[Tok (ExtendedToken (ws , "do")) , block , 
					Tok ( ExtendedToken (ws , "while")) , TokS("(") , Option.UnSome (cond) , TokS(")") , TokS(";")]);

			(new_do : STree).set_mod_by_ge ();

			eliminate_in_one_level (rest , new_do :: acc);

		    | head :: tail =>
			eliminate_in_one_level (tail , head :: acc);
		}
		    
	    }

	    match(this)
	    {
		//
		// BLOCK statement
		//
		| Statement ("BLOCK", xs ) => 
		    def (lb , sts , rb ) = cut_off_braces ( xs );
		
		    def end_whitespaces = 
		    match(rb)
		    {
			| Tok (r) => ExtendedToken.getWhitespaces (r);
			| _ => "\n";
		    }
		    
		    def begin_whitespaces = 
		    match(lb)
		    {
			| Tok (l) => ExtendedToken.getWhitespaces (l);
			| _ => "\n";
		    }

		    mutable all_init_vars = [];

		    def triple_to_list ( x , y , z)
		    {
			all_init_vars = x + all_init_vars;
			[y] + z
		    }
		    
		    mutable sts_eliminated = List.Flatten (List.Map (sts , 
			fun (x) { def (a , b ,c) = x.eliminate_gotos (); triple_to_list (a , b , c) } 
		    ));
		    
		    def (labels, gotos ) = get_labels_and_gotos (sts_eliminated , [] , []);

		    List.Iter ( labels , add_label );
		    List.Iter ( gotos , add_goto );

		    def ( lifted , sts_el , init_vars) = lift_up_gotos ( labels , sts_eliminated , [] , [] , []);

		    def equal_statement (st)
		    {
			| Statement ("WHEN" , Tok(when_st) :: rest ) =>			    
			    Statement ("WHEN" , Tok(ExtendedToken(end_whitespaces, "when")) :: rest)

			| Tok (t) =>
			    Tok ( ExtendedToken ( end_whitespaces , ExtendedToken.getTextOnly (t) ))
			
			| x => x
		    }

		    ( List.Map (all_init_vars + init_vars , equal_statement), 
			Statement ("BLOCK" , lb :: eliminate_in_one_level(sts_el , []) + [rb]) , 
			    List.Map (lifted , equal_statement))
		
		| x => ( [] , x , [])
	    }	    
	}
	
	internal transform_gotos_to_conditionals () : STree
	{
	    match(this)
	    {
		| Statement ("WHEN",[when_,lp,cond,rp,maybe_goto]) as when_st=>
		    if(maybe_goto matches Statement ("GOTO",_))
			when_st
		    else
			Statement ("WHEN",[when_,lp,cond,rp,maybe_goto.transform_gotos_to_conditionals ()])
			
		| Statement ("GOTO", goto :: _ ) as goto_st=>
		    
		    def ws = get_first_whitespace (goto);

		    Statement("WHEN", [ Tok(ExtendedToken (ws,"when")), TokS(" ("), TokS(" true ") , TokS (")"), goto_st])

		| Statement ( name , children) =>
    
		    Statement (name , List.Map ( children , fun (x) { x.transform_gotos_to_conditionals () } ) )

		| x => x
		    
	    }
	}

	private new_goto_symbol () : string
        {
            new_symbol ("_goto_")
        }
    }
}

#endif
