<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Rationale of design decisions</title>
  
  <motto from="wizard">
    To light a candle is to cast a shadow.
  </motto>

  
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        We'll try here to answer some of controversial thoughts you might 
        have after looking on Nemerle feature set.
      </p>
    </body>
  </section>
  <section id="why">
    <title>Why?</title>
    <qa id="why-cil">
      <title>Platform</title>
      <question>
        Why use CLI/.NET?
      </question>
      <answer>
        <p>
          Mainly for interop reasons. There are number of CLI libraries
          and bindings out there already. There is going to be more and
          more.
        </p>
        <p>
          Surely we'll loose WRT to compiled OCaml in terms of
          performance, at least until JIT's are made perfect, but it is
          easily possible to write a Gtk, GNOME, Windows GUI or even KDE
          application, we can embed Nemerle into ASP.NET web pages and
          there are more and more applications and libraries supporting
          .NET now.  It is also possible to write libraries for other
          .NET languages, like C# or VB.NET.
        </p>
        <p>
          We have also avoided significant development costs, because
          of this decision (no need for low-level compiler, JIT, the runtime
          library).
        </p>
      </answer>
    </qa>
    <qa id="csharp">
      <title>Comparing to C#...</title>
      <question>
        Why use Nemerle and not C#?
      </question>
      <answer>
        <p>
          Nemerle is probably going to be used in some applications,
          where C# would be otherwise chosen. Why one would use Nemerle
          and not established, well described C#?
        </p>
        <p>
          In Nemerle you can do mostly everything you would have done in C#.
          ,,mostly'' refers to unsafe code and maybe some C-interfacing
          tricks. But of course you can do more:
        </p>
        <ul>
          <li>
            Program in a functional style.  It is sometimes very handy,
            once you get used to it.  Functions are first class values
            so you can pass them to other functions easily (this is much
            like delegates but with better syntax and used more widely).
          </li>
          <li>
            Variants with pattern matching. This feature is very useful when 
            describing tree-like structures like arithmetic expressions or XML.
            This tends to be much shorter and clearer than in C#, and thanks
            to the warning about non-exhaustive matching -- much safer.
          </li>
          <li>
            Language extensions. This feature allows skilled programmers to extend
            Nemerle itself, and saves everyone typing the same methods for the Nth
            time for the Nth class.
          </li>
          <li>
            Macros allow you to add compile-time executed code to your program.
            This gives wide range of possibilities to verify Domain-specific
            languages (like SQL, regular expressions) employed by project, using
            Aspects-oriented programming, etc.
          </li>
          <li>
            Nemerle saves you typing using type inference:
            instead of:
<code>
Foo.Bar_long_name&lt;Baz.Qux> x = 
  new Foo.Bar_long_name&lt;Baz.Qux> (10)
</code> 
            you write:
<code>
def x = Foo.Bar_long_name (10)
</code>
          </li>
        </ul>
      </answer>
    </qa>
    <qa id="fsharp">
      <title>Comparing to F# and SML.NET...</title>
      <question>
        Why use Nemerle and not F# or SML.NET?
      </question>
      <answer>
        <p>
          <a
          ref="http://research.microsoft.com/projects/ilx/fsharp.aspx">F#</a>
          is a .NET port of subset of <a
          ref="http://caml.inria.fr">OCaml</a>.  <a
          ref="http://www.cl.cam.ac.uk/Research/TSG/SMLNET/">SML.NET</a>
          is <a ref="http://en.wikipedia.org/wiki/SML">Standard ML</a>
          '97 implementation for the .NET.  Both are languages from the <a
          ref="http://en.wikipedia.org/wiki/ML_programming_language">ML</a>
          family.
        </p>
        <p>
          We believe Nemerle is far easier to grasp for programmer
          who has not been exposed to ML-like languages before (due to more
          bracy syntax and a few other design choices). At the
          same time the functional capabilities provided by the three
          languages are mostly the same.
        </p>
        <p>
          Nemerle is a new language. We had CLS interop in mind since
          the very beginning. OTOH both SML.NET and F# are ports of existing
          languages, with a retrofitted CLS layer. In our opinion
          this does not play that well together.
        </p>
      </answer>
    </qa>
    <qa id="why-rtti">
      <title>Dynamic types</title>
      <question>
        Why dynamic types? Don't they impact performance?
      </question>
      <answer>
        <p>
          Probably yes. But dynamic types are inherent part of CLI so
          there is no <b>performance</b> reason to ban them (we would
          have to pay performance cost anyway). Additionally, dynamic
          types are useful in some contexts, like dynamic loading of
          classes (or rather dynamic construction of objects).
        </p>
        <p>
          For example
          what static type would you give to polymorphic de-serialization
          function? In OCaml it has type <tt>in_channel -> 'a</tt> which
          is obviously wrong.
        </p>
        <p>
          Of course there are several <a 
          ref="http://www.catb.org/~esr/jargon/html/R/religious-issues.html">
          religious issues</a> about dynamic typing. Our answer is very simple:
          you don't need dynamic types -- don't use them.
        </p>
      </answer>
    </qa>
    <qa id="why-macros">
      <title>Macros and language extensions</title>
      <question>
        What language extensions are good for? Programmers are writing <i>in
        languages</i> not <i>writing languages</i>.
      </question>
      <answer>
        <p>
          That's not true :-) Everyone programming in <meta>X</meta>
          had an idea how to change this funny little annoying thing
          in <meta>X</meta>. 
        </p>
        <p>
          Of course not everybody is going to do it, but we intend to
          provide a library of useful language extensions along with Nemerle.
          For interesting examples see <a ref="macrouse.html">this</a> page.
        </p>
        <p>
          Macros gives you powerful tool for research in programming languages 
          design and implementation of new ideas like 
          <a ref="http://research.microsoft.com/~nick/polyphony/">
           Join Calculus</a>.
          You need not to create entire compiler from scratch, but simple write
          a function transforming code and include <tt>using My.NewLanguageFeature;</tt>
          directive in final program.
        </p>
        <p>
          It is possible to define functions that we're unable
          to encode in our type-system. Ordinary example is C-like, but type-safe
          <tt>printf</tt> function.
        </p>
        <p>
          We also allow extending language syntax to some degree. However, it is
          quite difficult to do this 
          <a ref="http://www.catb.org/~esr/jargon/html/entry/Right-Thing.html">
          The Right Way</a>. Currently extending syntax in Nemerle is quite limited, 
          but it gives great possibilities by ability to invoke an arbitrary macro.
        </p>
      </answer>
    </qa>
  </section>
  <section id="syntax-questions">
    <title>Syntax questions</title>
    <body>
      <p>
        This section will try to answer a few questions about the Nemerle syntax,
        and sometimes semantics behind it.
      </p>
    </body>
    <qa id="call-parens">
      <title>Function call requires <tt>()</tt></title>
      <question>
        Why does function call require <tt>()</tt>? <tt>f x</tt> looks
        much better than <tt>f(x)</tt>, and in ML you can use both forms.
      </question>
      <answer>
        <p>
          Function call requires <tt>()</tt>. It looks like this:
        </p>
<code>
f (x, y, z);
f (x);
f ();
</code>
        <p>
          Form without <tt>()</tt> (i.e. <tt>f x</tt>) is not allowed.
        </p>
        <p>
          There are some good reasons for that. The main one is that it 
          allows for better overloading resolution (simply when looking
          at <tt>f (x, y)</tt> you know you need a function with 2 parameters,
          and it's not a partial application). Overloading is likely
          to occur quite frequently in CLI. Another reason is that following code
          will give you a parse error, not a weird typing error:
        </p>
<code>
f (x)  /* forgot ';' here */
g (x)
</code>
        <p>
          Using this syntax it is not possible to do partial application,
          but see <a ref="#partial-application">below</a>.
        </p>
      </answer>
    </qa>
    <qa id="null">
      <title><tt>null</tt> value</title>
      <question>
        There is a special <tt>'a option</tt> type in ML, which can be
        <tt>Some x</tt> or <tt>None</tt> and is used where a pointer, that
        can be null, would have been used in C-like languages.  So what
        is <tt>null</tt> value good for? You can have <tt>option</tt>
        type in Nemerle too.
      </question>
      <answer>
        <p>
          Of course you can, you even have it in standard library.
          It's the suggested way of handling this matter. 
        </p>
        <p>
          <b>But</b> think about external functions that can
          return references.  By CLI standards they can also
          return <tt>null</tt>. Thus it would require to have
          all functions returning <tt>foo</tt> in CLI to return
          <tt>option (foo)</tt> in Nemerle, and you would end up using
          <tt>val_of</tt> function over and over again, resulting in
          <tt>None_value</tt> (or something) exceptions instead of
          <tt>Null_pointer_exception</tt>.
        </p>
        <p>
          This is why we have <tt>null</tt> in the language. In fact it
          is quite common in Nemerle to have a feature just for interop
          reasons.
        </p>
      </answer>
    </qa>
    <qa id="sequence">
      <title>Sequence in <tt>{}</tt></title>
      <question>
        Why a sequence needs to be enclosed in <tt>{}</tt>? Wouldn't it
        be possible to assign some priority to the <tt>;</tt> operator
        and treat this as an expression?
      </question>
      <answer>
        <p>
          It would be possible, but it's quite error-prone and misleading.
          In simple examples it's OK:
        </p>
<code>
let x = 3 in g x; h x       /* Caml */
{ def x = 3; g (x); h (x) }     /* Nemerle */
</code>
        <p>
          But consider the following snippet of Caml:
        </p>
<code>
  /* Correct */
  if x > y then
    let x = 3 in
    f x;
    g x
  else
    h ()

  /* Parse error */
  if x > y then
    f 3;
    g 3
  else 
    h ()
</code>
        <p>
          Thanks to <tt>;</tt> being used only in clear context it is not
          possible in Nemerle.
        </p>
        <p>
          This issue is resolved in similar manner in OCaml Revised Syntax.
        </p>
      </answer>
    </qa>
    <qa id="if-else">
      <title><tt>if</tt> requires <tt>else</tt></title>
      <question>
        Why does <tt>if</tt> require <tt>else</tt>? In OCaml one doesn't
        need to write <tt>else ()</tt>.
      </question>
      <answer>
        <p>
          To avoid confusing grammar ambiguities. Besides, this
          is a <b>functional</b> language, what is <tt>if</tt>
          <b>expression</b> without <tt>else</tt>?
        </p>
        <p>
          You can also use <tt>when</tt> and <tt>unless</tt> macros for
          <tt>if</tt> without <tt>else</tt> or <tt>else</tt> without
          <tt>if</tt>.
        </p>
      </answer>
    </qa>
  </section>
  <section id="where">
    <title>Where did <meta>X</meta> go?</title>
    <body>
      <p>
        A few explanations about how to do various things in Nemerle.
      </p>
    </body>
    <qa id="partial-application">
      <title>Partial application</title>
      <question>
        How to make a partial function application?
      </question>
      <answer>
        <p>
          You simply need to use the so called eta-long form:
        </p>
<code>
def f (x, y) { ... };
def g (x) { fun (y) { f (x, y) } };

def plus5 (x) { fun (x) { 5 + x } };
</code>
        <p>
          This prevents partial application bugs, which would be common
          in presence of overloading.
        </p>
      </answer>
    </qa>
  </section>
  
    <!-- 
    <qa id="">
      <title></title>
      <question>
      </question>
      <answer>
        <p>
        </p>
      </answer>
    </qa>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
