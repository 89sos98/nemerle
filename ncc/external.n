/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler 
{
  using Nemerle.Collections;
  using Nemerle.Utility;
  using Nemerle.IO;

  using Nemerle.Compiler;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Compiler.Tyops;

  namespace SR = System.Reflection;
  namespace PT = Nemerle.Compiler.Parsetree;  

  /**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   */
  public class LibraryReferenceException : System.Exception 
  {
    public this () {}
  }


  /**
   * Manager for the referenced libraries
   */
  public class LibraryReferenceManager
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */
  
    /**
     * Static constructor. Always load the Framework core library.
     */
    public static this () {
      namespace_nodes = Hashtable (300);

      def assembly_dir (t) {
        DirectoryOfCodebase ((t : System.Type).Assembly.CodeBase)
      };
      
      _libraries = [];

      // include current directory and directories where 
      // mscorlib.dll, System.dll and Nemerle.dll reside
      _lib_path = [".",
                    assembly_dir (typeof (Nemerle.Core.AssertionException)),
                    assembly_dir (typeof (System.Text.RegularExpressions.Match)),
                    assembly_dir (typeof (System.Object))];

      _loaded_assemblies_by_name = Hashtable (20);
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */
  
    /**
     * Stores the referenced library for later lookup by the namespaces. Also
     * add transitive closure of libraries needed by given assembly.
     */
    public static AddLibrary (name : string) : void 
    {
      def assembly =
        match (name) {
          | "mscorlib" when Flags.use_loaded_corlib =>
            typeof (System.Object).Assembly
          | "System" when Flags.use_loaded_corlib =>
            typeof (System.Text.RegularExpressions.Match).Assembly
          | name => LookupAssembly (name)
        };
      if (assembly == null) {
        Message.error ("cannot find assembly `" + name + "'");
        throw AssemblyFindException ()
      }
      else if (_loaded_assemblies_by_name.Contains (assembly.FullName))
        Message.warning ("assembly `" + name + "' already loaded")
      else
        AddAssembly (assembly)
    }

    public static AddAssembly (assembly : SR.Assembly) : void
    {
      unless (_loaded_assemblies_by_name.Contains (assembly.FullName)) {
        _libraries = LibraryReference (assembly) :: _libraries;
        _loaded_assemblies_by_name.Set (assembly.FullName, assembly);
        def refs = assembly.GetReferencedAssemblies ();
        NArray.Iter (refs, fun (name : SR.AssemblyName) {
          def asm =
            try {
              SR.Assembly.Load (name)
            } catch { _ : System.IO.FileNotFoundException => 
              try {
                SR.Assembly.LoadFrom (name.CodeBase)
              } catch { _ : System.Exception => 
                LookupAssembly (name.Name)
              }
            };
          if (asm == null)
            Message.warning ("cannot load library '" + name.Name + 
                             "' referenced by `" + assembly.GetName ().Name + "'")
          else
            AddAssembly (asm)
        })
      }
    }
      
    public static AddSearchDirectory (name : string) : void
    {
      _lib_path = name :: _lib_path;
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    /**
     * Remove assembly file name from URL returned by Assembly.CodeBase.
     */
    private static DirectoryOfCodebase (path : string) : string
    {
      def path =
        if (path.LastIndexOf ('/') > path.LastIndexOf ('\\'))
          path.Substring (0, path.LastIndexOf ('/'));
        else
          path.Substring (0, path.LastIndexOf ('\\'));

      // hack for mono 0.91 returning location in the GAC
      def mono_gac = path.IndexOf ("mono/gac");
      def path =
        if (mono_gac != -1)
          path.Substring (0, mono_gac + 5) + "1.0/"
        else path;

      path
    }


    private static LookupAssembly (name : string) : SR.Assembly
    {
      def name =
        if (name.EndsWith (".dll")) name
        else name + ".dll";

      def assembly_by_name (path) {
        try {
          SR.Assembly.LoadFrom (path)
        } catch { _ : System.IO.FileNotFoundException => null };
      };

      if (name.IndexOf ('/') != -1 || name.IndexOf ('\\') != -1) {
        assembly_by_name (name)
      } else {
        def lookup (libs) {
          | lib :: libs =>
            def ret = assembly_by_name (System.IO.Path.Combine (lib, name));
            if (ret == null) lookup (libs)
            else ret
          | [] => null
        };

        lookup (_lib_path);
      }
    }


    private static load_macro (lib : SR.Assembly, macro_name : string) : void
    {
      def macro_type = lib.GetType (macro_name.Replace ("&", "\\&"));
      if (macro_type == null) {
        Message.warning ("failed to lookup macro `" + macro_name + "' in assembly " + 
                         lib.FullName);
      } else {
        def ctor = macro_type.GetConstructor (System.Type.EmptyTypes);
        if (ctor == null) {
          Message.warning ("failed to lookup constructor in macro `" + macro_name + 
                           "' from assembly " + lib.FullName);
        } else {
          def macro_object = ctor.Invoke (null);
          if (macro_object == null) {
            Message.warning ("failed to construct instance of macro `" + macro_name + 
                             "' from assembly " + lib.FullName);
          } else {
            def casted_macro =
              try {
                (macro_object :> IMacro)
              } catch {
                | _ : System.InvalidCastException =>
                  Message.warning ("instance of macro `" + macro_name + 
                                   "' from assembly " + lib.FullName + 
                                   " does not implement IMacro interface");
                  null
              };
              when (casted_macro != null)
                MacroRegistry.register_macro (casted_macro);
          }
        }
      }
    }

    
    public static LoadMacrosFrom (lib : SR.Assembly) : void
    {
      def maybe_load_macro (attribute : System.Object) {
        def attribute_type = (attribute :> System.Attribute).GetType ();
        when (attribute_type.FullName == "Nemerle.Internal.ContainsMacroAttribute") {
          def meth = attribute_type.GetMethod ("GetName");
          def macro_name = (meth.Invoke (attribute, null) :> string);
          load_macro (lib, macro_name)
        }
      };

      NArray.Iter (lib.GetCustomAttributes (true), maybe_load_macro)
    }
    
    
    public static LoadMacrosFrom (name : string) : void
    {
      def assembly = LookupAssembly (name);
      if (assembly == null)
        Message.error ("cannot load assembly with macros `" + name + "'")
      else
        LoadMacrosFrom (assembly);
    }
      
    
    /* -- PRIVATE VARIABLES ------------------------------------------------ */
    
    /**
     * The referenced library list
     */
    private static mutable _libraries : list <LibraryReference>;

    /**
     * List of directories we look for assemblies in.
     */
    private static mutable _lib_path : list <string>;

    private static _loaded_assemblies_by_name : Hashtable <string, SR.Assembly>;

    private static namespace_nodes : Hashtable <string, GlobalEnv.NamespaceND>;


    /* -- TYPE CACHE ----- */

    [Record]
    public class ExternalType {
      internal system_type : System.Type;
      internal library : LibraryReference;
      internal mutable tycon : Tycon;
      internal mutable message : string;
    }

    internal static LoadTypesFrom (lib : LibraryReference) : void
    {
      def assembly = lib.GetAssembly ();
      def types = assembly.GetExportedTypes ();
      def codebasens = GlobalEnv.ExactPath ([assembly.CodeBase]);

      mutable i = 0;
      for (; i < types.Length; ++i) {
        def t = types[i];
        def name = t.FullName;
        def e = ExternalType (t, lib, null, null);
        def notcached = GlobalEnv.NotLoaded (e);

        def (ns_node, path_to_type) = framework_nesting (t);
        def mainnode = ns_node.Path (path_to_type);
        def fullnode = codebasens.Path (name.Replace ('+', '.'));

        // check if we have met such type before
        def ambiguous_other = 
          match ((mainnode.Value, fullnode.Value))
          {
            | (GlobalEnv.NotLoaded (x), _)
            | (_, GlobalEnv.NotLoaded (x)) => x
            | _ => null
          };

        when (ambiguous_other != null) {
          // such type was there somewhere, so create verbose message
          // for the case of ambiguous use
          assert (ambiguous_other.tycon == null);

          e.message = 
            "[" + assembly.FullName + "], " + 
            (if (ambiguous_other.message == null)
               "[" + ambiguous_other.library.GetAssembly ().FullName + "]"
             else 
               ambiguous_other.message);
        };
        
        // assign wrappers for future loading of typecons
        mainnode.Value = notcached;
        fullnode.Value = notcached;
      }
    }

    internal static CacheTycon (t : System.Type, tc : Tycon) : void
    {
      def codebase = GlobalEnv.ExactPath ([t.Assembly.CodeBase]); 
      def (ns_node, path_to_type) = framework_nesting (t);
      def ns = codebase.Path (ns_node.Name).Path (path_to_type);
      match (ns.Value) {
        | GlobalEnv.NotLoaded (e) =>
          e.tycon = tc;
          ns.Value = GlobalEnv.Cached (tc)
        | GlobalEnv.No =>
          ns.Value = GlobalEnv.Cached (tc)
        | _ =>
          Util.ice ("wanted to cache cached value " + t.FullName)
      }
    }

    internal static GetInternalType (lib : LibraryReference, t : System.Type) : Tycon
    {
      def codebase = GlobalEnv.ExactPath ([t.Assembly.CodeBase]);
      def (ns_node, path_to_type) = framework_nesting (t);
      def ns = codebase.Path (ns_node.Name).Path (path_to_type);
      match (ns.Value) {
        | GlobalEnv.Cached (tc) => tc
        | GlobalEnv.No =>
          def tc = lib.ConstructTycon (t);
          ns.Value = GlobalEnv.Cached (tc);
          tc

        | GlobalEnv.MacroCall | GlobalEnv.NotLoaded =>
          Util.ice ("not loaded internal type... " + t.Assembly.CodeBase
                    + ":" + t.FullName)
      }
    }

    internal static framework_nesting (t : System.Type)
    : GlobalEnv.NamespaceND * list <string>
    {
      def loop (t : System.Type, acc) {
        def dt = t.DeclaringType;
        if (dt != null)
          loop (dt, dt.Name :: acc)
        else {
          def namespc = if (t.Namespace != null) t.Namespace else "";
          match (namespace_nodes.Get (namespc)) {
            | Some (nd) => (nd, acc)
            | None =>
              def nd = GlobalEnv.ExactPath (NString.Split (namespc, array ['.']));
              namespace_nodes.Add (namespc, nd);
              (nd, acc)
          }
        }
      };
      loop (t, [t.Name])
    }
  }


  /**
   * This class stores information extracted from a referenced external library.
   */
  public class LibraryReference
  {
    /**
     * The assembly associated with this object
     */
    private mutable _library : SR.Assembly;

    /**
     * The location of this library
     */
    private mutable _location : Location;
    
    /**
     * The assembly's custom attributes
     */
    private mutable _assembly_attributes : list <System.Object>;
       
    /**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     */
    private mutable _is_generated_by_nemerle : bool;

    /**
     * Load an assembly. Extracts and processes the custom attributes array.
     */
    public this (assembly : SR.Assembly) 
    {
      _library = assembly;

      _location = Location("[library:" + (_library.GetName ()).Name + "]", 0, 0, null);
      _assembly_attributes = List.FromArray (_library.GetCustomAttributes (true));
      process_assembly_attributes ();

      LibraryReferenceManager.LoadTypesFrom (this);
      LibraryReferenceManager.LoadMacrosFrom (_library);
    }



    /**
     * Scans the assembly custom attributes looking for something interesting...
     */
    private process_assembly_attributes () : void
    {
      def loop (attributes : list <System.Object>) : void {
        match (attributes) {
          | [] => ()
          | attribute :: rest =>
            def attribute_type = (attribute :> System.Attribute).GetType ();
            match (attribute_type.FullName) {
              | "System.Reflection.AssemblyConfigurationAttribute" =>
                def configuration_attribute =
                  (attribute :> SR.AssemblyConfigurationAttribute);
                
                when (configuration_attribute.Configuration ==
                      "ContainsNemerleTypes") {
                  //Message.debug ("Loaded assembly " + this._library.FullName
                  //                 + " contains Nemerle types...");
                  this._is_generated_by_nemerle = true
                }
              | _ => ()
            };
            
            loop (rest)
        }
      };
      
      loop (this._assembly_attributes);
    }

    /**
     * Turns a Framework type into something edible by Nemerle's type system
     */
    private TypeOfType (framework_type : System.Type) : Type
    {
      // FIXME: ref and out types, anyone?
      if (framework_type.Name == "Void" && framework_type.Namespace == "System")
        T_void ()
      else
        if (framework_type.IsArray)
          T_array (TypeOfType (framework_type.GetElementType ()), framework_type.GetArrayRank ())
        else 
          if (framework_type.IsByRef)
            T_ref (TypeOfType (framework_type.GetElementType ()))
          else {
            def (ns_node, path_to_type) =
              LibraryReferenceManager.framework_nesting (framework_type);

            match (ns_node.LookupType (path_to_type)) {
              | Some (tc) => T_app (tc, [])
              | None =>
                def full = framework_type.FullName;
                match (LookupInternalType (full)) {
                  | Some (tc) => T_app (tc, [])
                  | None =>
                    def path = NString.Split (full, array ['.', '+']);
                    match (GlobalEnv.LookupExactType (path)) {
                      | Some (tc) => T_app (tc, [])
                      | None =>
                        Message.fatal_error ("unbound external type `" +
                                             framework_type.FullName + 
                                             "' referenced from library `" +
                                             _library.CodeBase + "'")
                    }
                }
            }
          }
    } 

    private TyconOfType (framework_type : System.Type) : Tycon
    {
      match (TypeOfType (framework_type)) {
        | T_app (tc, []) => tc
        | _ => Util.ice ()
      }
    } 

    /**
     * If true, the library seems to have been generated by the Nemerle compiler
     */
    internal IsGeneratedByNemerle () : bool 
    {
      this._is_generated_by_nemerle
    }

    internal GetAssembly () : SR.Assembly
    {
      this._library
    }
    
    /**
     * Construct Tycon object from given type in current assembly.
     */
    internal ConstructTycon (reflected_type : System.Type) : Tycon
    {
      if (_is_generated_by_nemerle && 
          has_attribute ("Nemerle.Internal.TypeAttribute",
                         reflected_type.GetCustomAttributes (false)))
        (TypeInfo (this, reflected_type) : Tycon)
      else
        (NetType (this, reflected_type) : Tycon)
    }

    /**
     * Looks for type named [name] that is internal to current assembly. Used
     * by type attribute decoder.
     */
    internal LookupInternalType (name : string) : option <Tycon>
    {
      def st = _library.GetType (name);
      if (st == null)
        None ()
      else
        Some (LibraryReferenceManager.GetInternalType (this, st))
    }

    private MethodOfMethodInfo (self : IMember, meth : SR.MethodInfo) : NetMethod
    {
      if (meth == null)
        null
      else
        if (IsGeneratedByNemerle ())
          MethodInfo ((self.DeclaringType :> TypeInfo).tenv, 
                      this, meth)
        else
          NetMethod (this, meth)
    }

    /* -----------------------------------------------------------------
     * .NET types
     * ----------------------------------------------------------------- 
     */
    private class NetType : Tycon
    {
      protected handle : System.Type;
      protected library : LibraryReference;
      protected id : int;
      protected members : Hashtable <string, list <IMember>>;
      protected attributes : NemerleAttributes;

      public this (lib : LibraryReference, h : System.Type)
      {
        // first cache ourself to avoid loops
        LibraryReferenceManager.CacheTycon (h, this);
        id = Util.next_id ();
        library = lib;
        handle = h;
        members = Hashtable (2);

        when (IsDelegate ()) {
          def pref = "problem with delegate type `" + GetFullName () + "': ";
          match (LookupMember (".ctor")) {
            | [ctor] =>
              def meth = (ctor :> IMethod);
              def fh = meth.GetHeader ();
              match (fh.parms) {
                | [_, p2] =>
                  match (LookupMember ("Invoke")) {
                    | [inv] => 
                      def ty = (inv :> IMethod).GetMemType ();
                      fh.parms = [p2];
                      p2.ty = ty
                    | invs =>
                      Message.warning (pref + sprintf ("invoke count %d",
                                                       List.Length (invs)))
                  }
                | parms =>
                  Message.warning (pref + sprintf ("ctor has %d parms",
                                                   List.Length (parms)))
              }
            | ctors => Message.warning (pref + sprintf ("%d constructors",
                                                        List.Length (ctors)))
          }
        }
        
        attributes = NemerleAttributes.None;

        when (handle.IsAbstract) attributes |= NemerleAttributes.Abstract;
        when (handle.IsSealed)   attributes |= NemerleAttributes.Sealed;
        when (handle.IsValueType) attributes |= NemerleAttributes.Struct;

        if (handle.DeclaringType == null) {
          if (handle.IsPublic) attributes |= NemerleAttributes.Public
          else attributes |= NemerleAttributes.Internal;
        } else {
          when (handle.IsNestedPrivate)  attributes |= NemerleAttributes.Private;
          when (handle.IsNestedPublic)   attributes |= NemerleAttributes.Public;
          when (handle.IsNestedFamily)   attributes |= NemerleAttributes.Protected;
          when (handle.IsNestedAssembly) attributes |= NemerleAttributes.Internal;
        }
      }

      /** Checks if underlaying .NET type is value type */
      public IsValueType : bool {
        get { handle.IsValueType }
      }

      public MemberType : MemberTypes
      { get { handle.MemberType } }

      public Name : string
      { get { handle.Name } }
      
      public GetLibraryReference () : LibraryReference
      { library }
      
      public IsDelegate () : bool
      {
        handle.IsSubclassOf (SystemType.MulticastDelegate)
      }
      
      public GetHandle () : SR.MemberInfo
      { handle }

      public virtual GetMemType () : Type
      {
        T_app (this, [])
      }

      public GetKind () : MemberKind
      {
        MK_type (this)
      }

      public virtual GetConstantObject () : option <IField>
      {
        None ()
      }

      public DeclaringType : Tycon {
        get {
          if (handle.DeclaringType == null)
            null
          else
            library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public GetLocation () : Location
      {
        library._location
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetCustomAttributes () : list <PT.Expr>
      { [] }

      public GetMacroAttributes () : list <string * PT.Expr>
      { [] }
      
      public SetCustomAttributes (_ : list <PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }

      public SetMacroAttributes (_ : list <string * PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }
      
      public GetAccessibility () : Accessibility
      {
        if (handle.IsPublic || handle.IsNestedPublic)
          A_public ()
        else if (handle.IsNestedFamily)
          A_protected ()
        else {
          Message.debug ("non public, non prot " + GetFullName ());
          assert (false)
        }
      }
      
      public IsStatic () : bool
      {
        true
      }

      public GetId () : int
      {
        id
      }

      public GetFullName () : string
      {
        handle.FullName.Replace ('+', '.')
      }

      public virtual GetTyconKind () : TyconKind
      {
        TK_ExternalNetType (handle)
      }

      public virtual GetTydecl () : Type_decl
      {
        if (handle.IsInterface)
          TD_interface ()
        else if (handle.IsEnum)
          TD_enum ()
        else
          TD_class ()
      }

      public virtual MakeSubst (parms : list <Type>) : Subst
      {
        match (parms) {
          | [] => ()
          | _ =>
            Message.error ("framework type `" + GetFullName () +
                           "' supplied with type arguments")
        };
        SystemMap ()
      }

      public virtual FreshSubst () : Subst
      {
        SystemMap ()
      }

      public virtual SuperType (tc : Tycon) : option <list <Type>>
      {
        match (tc.GetTyconKind ()) {
          | TK_ExternalNetType (t) when t.IsAssignableFrom (handle)
          | TK_ExternalNemerleType (t) when t.IsAssignableFrom (handle) => Some ([])
          | _ => None ()
        }
      }

      public virtual SubtypingSubst (_ : Tycon) : Subst
      {
        SystemMap ()
      }

      public virtual SuperClass () : option <Tycon>
      {
        if (handle.BaseType == null)
          None ()
        else
          Some (library.TyconOfType (handle.BaseType))
      }

      public virtual GetSuperTypes () : list <Type>
      {
        def supertypes = Hashtable (30);
        def add_bt (t : Type) {
          match (t) {
            | T_app (tc, []) =>
              if (supertypes.Contains (tc.GetId ())) ()
              else {
                supertypes.Add (tc.GetId (), t);
                match (tc.SuperClass ()) {
                  | Some (tc) => add_bt (T_app (tc, []))
                  | None => ()
                }
              }
            | _ => Util.ice ()
          }
        };
        List.Iter (GetDirectSuperTypes (), add_bt);
        supertypes.Fold ([], fun (_, tc, acc) { tc :: acc })
      }

      public virtual GetDirectSuperTypes () : list <Type>
      {
        def ifaces = List.Map (List.FromArray (handle.GetInterfaces ()), 
                               library.TypeOfType);
        match (SuperClass ()) {
          | Some (r) => T_app (r, []) :: ifaces
          | None => ifaces
        }
      }

      public SameAs (tc : Tycon) : bool 
      {
        GetId () == tc.GetId ()
      }

      public GetMembers () : list <IMember>
      {
        LookupMember ("")
      }
      
      public GetMembers (bindingAttr : BindingFlags) : list <IMember>
      {
        def check (x : IMember) {
          if (bindingAttr %&& BindingFlags.DeclaredOnly)
            this.SameAs (x.DeclaringType) &&
            TypeBuilder.constrain_member (x, bindingAttr)
          else
            TypeBuilder.constrain_member (x, bindingAttr)
        };
        List.Filter (GetMembers (), check)
      }

      public GetFields (bindingAttr : BindingFlags) : list <IField> 
      {
        def check (x : IMember) {
          if (TypeBuilder.constrain_member (x, bindingAttr))
            match (x.GetKind ()) {
              | MK_field => true
              | _ => false
            }
          else
            false
        };
        (List.Filter (GetMembers (bindingAttr), check) :> list <IField>)
      }

      public GetConstructors (bindingAttr : BindingFlags) : list <IMethod> 
      {
        def check (x : IMember) {
          if (TypeBuilder.constrain_member (x, bindingAttr))
            match (x.GetKind ()) {
              | MK_method (m) =>
                match (m.GetFunKind ()) {
                  | FK_ctor | FK_static_ctor => true
                  | _ => false
                }
              | _ => false
            }
          else
            false
        };
        (List.Filter (GetMembers (bindingAttr), check) :> list <IMethod>)
      }
      
      private is_internal (m : SR.MemberInfo) : bool
      {
        def x = m.MemberType;

        if (x %&& (MemberTypes.Constructor %| MemberTypes.Method)) {
          def meth = (m :> SR.MethodBase);
          meth.IsPrivate || meth.IsAssembly
        } else if (x %&& MemberTypes.Field) {
          def field = (m :> SR.FieldInfo);
          field.IsPrivate || field.IsAssembly
        } else if (x %&& MemberTypes.Property) {
          def prop = (m :> SR.PropertyInfo);
          prop.GetGetMethod (false) == null &&
          prop.GetSetMethod (false) == null
        } else if (x %&& MemberTypes.NestedType) {
          def ty = (m :> System.Type);
          ty.IsNestedAssembly || ty.IsNestedPrivate
        } else if (x %&& MemberTypes.Event) {
          (m :> SR.EventInfo).GetAddMethod (false) == null
        } else
          true
      }

      protected virtual imember_of_memberinfo (m : SR.MemberInfo) : option <IMember>
      {
        def ret (x : IMember) { Some (x) };
        def x = m.MemberType;

        if (x %&& (MemberTypes.Constructor %| MemberTypes.Method))
          ret (NetMethod (library, (m :> SR.MethodBase)))
        else if (x %&& MemberTypes.Field)
          ret (FieldInfo (library, (m :> SR.FieldInfo)))
        else if (x %&& MemberTypes.Property)
          ret (NetProperty (library, (m :> SR.PropertyInfo)))
        else if (x %&& MemberTypes.Event)
          ret (NetEvent (library, (m :> SR.EventInfo)))
        else if (x %&& MemberTypes.NestedType)
          ret (library.TyconOfType ((m :> System.Type)))
        else
          None ()
      }

      private collect_members (name : string) : list <IMember> 
      {
        def fields_to_shadow = Hashtable ();
        
        def add_member (m : SR.MemberInfo, acc) {
          if (is_internal (m))
            acc
          else {
            def tc = library.TyconOfType (m.DeclaringType);
            if (this.SameAs (tc)) {
              match (imember_of_memberinfo (m)) {
                | Some (r) =>
                  match (r.GetKind ()) {
                    | MK_field
                    | MK_property =>
                      fields_to_shadow.Set (r.Name, null)
                    | _ => ()
                  };
                  r :: acc
                | None => acc
              }
            }
            else if (handle.IsInterface) acc
            else {
              def fullname = m.ToString ();
              def proper_name (m2 : IMember) {
                m2.DeclaringType.SameAs (tc) &&
                m2.GetHandle ().ToString () == fullname
              };
              match (List.Filter (tc.LookupMember (m.Name), proper_name)) {
                | [] => Util.ice ("no match for " + fullname)
                | [x] => x :: acc
                | _ =>  Util.ice ("2+ matches for " + fullname)
              }
            }
          }
        };
        
        def flags = SR.BindingFlags.Public     %|
                    SR.BindingFlags.NonPublic  %|
                    SR.BindingFlags.Static     %|
                    SR.BindingFlags.Instance   ;

        def member_array = 
          if (name == "")
            handle.GetMembers (flags) 
          else 
            handle.GetMember (name, flags);

        def ret = NArray.Fold (member_array, [], add_member);

        def filter_shadowed (acc, lst) {
          match (lst) {
            | x :: xs =>
              if (!(x : IMember).DeclaringType.SameAs (this) &&
                  fields_to_shadow.Contains (x.Name))
                filter_shadowed (acc, xs)
              else
                filter_shadowed (x :: acc, xs)
            | [] => acc
          }
        };

        def ret = filter_shadowed ([], ret);
         
        // for some reason Framework API doesn't lookup members in interfaces inherited
        // by other interfaces, so we do it ourselves
        if (handle.IsInterface) {
          def ret =
            NArray.Fold (handle.GetInterfaces (), ret, 
              fun (st, acc) {
                List.Append (library.TyconOfType (st).LookupMember (name), acc)
              });
          // it also doesn't return members of system.object
          List.Append (InternalType.Object_tc.LookupMember (name), ret)
        } else
          ret
      }

      public LookupMember (name : string) : list <IMember> 
      {
        match (members.Get (name)) {
          | Some (r) => r
          | None =>
            def lst = collect_members (name);
            members.Set (name, lst);
            lst
        }
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || handle.IsNestedPublic ||
          (handle.DeclaringType != null &&
           Option.IsSome (source.SuperType (DeclaringType)) &&
           handle.IsNestedFamily)
      }

      public GetSystemType () : System.Type
      {
        handle
      }
    }
    
    private class FieldInfo : IField
    {
      protected handle : SR.FieldInfo;
      protected library : LibraryReference;
      protected id : int;
      protected mutable tt_type : Type;
      protected mutable attributes : NemerleAttributes;

      public this (lib : LibraryReference, h : SR.FieldInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        tt_type = null;
        set_attributes ();
      }

      public this (tenv : SystemMap <int, Tyvar.T>, lib : LibraryReference,
                   h : SR.FieldInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        tt_type = TyCodec.DecodeType (lib, tenv, attr_str);
        set_attributes ();
      }

      set_attributes () : void
      {
        attributes = NemerleAttributes.None;
        when (!handle.IsInitOnly) attributes |= NemerleAttributes.Mutable;
        when (handle.IsStatic)    attributes |= NemerleAttributes.Static;
       
        when (handle.IsPrivate)  attributes |= NemerleAttributes.Private;
        when (handle.IsPublic)   attributes |= NemerleAttributes.Public;
        when (handle.IsFamily)   attributes |= NemerleAttributes.Protected;
        when (handle.IsAssembly) attributes |= NemerleAttributes.Internal;
      }

      public DeclaringType : Tycon {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string {
        get { handle.Name }
      }

      public MemberType : MemberTypes {
        get { MemberTypes.Field }
      }

      public GetFieldInfo () : SR.FieldInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        when (tt_type == null)
          tt_type = library.TypeOfType (handle.FieldType);
        tt_type
      }

      public GetKind () : MemberKind
      {
        MK_field (this)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetCustomAttributes () : list <PT.Expr>
      { [] }

      public GetMacroAttributes () : list <string * PT.Expr>
      { [] }
      
      public SetCustomAttributes (_ : list <PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }

      public SetMacroAttributes (_ : list <string * PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }

      public IsStatic () : bool
      {
        handle.IsStatic
      }

      public IsLiteral : bool
      {
        get { handle.IsLiteral }
      }

      public GetValue () : object
      {
        assert (IsLiteral);
        handle.GetValue (null)
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        ! handle.IsInitOnly
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (DeclaringType)) &&
           handle.IsFamily)
      }
    }

    class NetEvent : IEvent
    {
      protected handle : SR.EventInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected adder : NetMethod;
      protected remover : NetMethod;
      protected mutable mem_type : Type;

      public this (lib : LibraryReference, h : SR.EventInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        
        def add_method = handle.GetAddMethod ();
        def remove_method = handle.GetRemoveMethod ();

        is_static =
          (add_method != null && add_method.IsStatic) ||
          (remove_method != null && remove_method.IsStatic);

        adder = library.MethodOfMethodInfo (this, add_method);
        remover = library.MethodOfMethodInfo (this, remove_method);

        assert (adder != null);
        assert (remover != null);

        match (adder.GetMemType ()) {
          | T_fun (t, _) => mem_type = t
          | _ => assert (false)
        }
      }

      public DeclaringType : Tycon {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string {
        get { handle.Name }
      }

      public MemberType : MemberTypes {
        get { MemberTypes.Event }
      }

      public GetAdder () : IMethod
      {
        adder
      }

      public GetRemover () : IMethod
      {
        remover
      }

      public GetEventInfo () : SR.EventInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public GetKind () : MemberKind
      {
        MK_event (this)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public Attributes : NemerleAttributes
      {
        get { adder.Attributes }
      }

      public GetCustomAttributes () : list <PT.Expr>
      { [] }

      public GetMacroAttributes () : list <string * PT.Expr>
      { [] }
      
      public SetCustomAttributes (_ : list <PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }

      public SetMacroAttributes (_ : list <string * PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }
      
      public IsStatic () : bool
      {
        is_static
      }

      public GetId () : int
      {
        id
      }

      public CanAccess (_source : Tycon) : bool
      {
        // FIXME: this is broken... we need to check method attributes
        true
      }
    }
    
    class NetProperty : IProperty
    {
      protected handle : SR.PropertyInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected getter : NetMethod;
      protected setter : NetMethod;
      protected any_method : NetMethod;
      protected mutable mem_type : Type;

      public this (lib : LibraryReference, h : SR.PropertyInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        
        def get_method = handle.GetGetMethod ();
        def set_method = handle.GetSetMethod ();

        getter = library.MethodOfMethodInfo (this, get_method);
        setter = library.MethodOfMethodInfo (this, set_method);

        if (getter == null)
          any_method = setter;
        else
          any_method = getter;

        assert (any_method != null);

        is_static = any_method.Attributes %&& NemerleAttributes.Static;
        
        def ret_type = library.TypeOfType (handle.PropertyType);

        def fun_args (t) {
          | T_fun (t, _) => Tyutil.fun_args (t)
          | _ => Util.ice ()
        };

        def args =
          if (getter != null)
            fun_args (getter.GetMemType ())
          else if (setter != null)
            List.Rev (List.Tail (List.Rev (fun_args (setter.GetMemType ()))))
          else
            [];
        
        mem_type =
          match (args) {
            | [] => ret_type
            | [x] => T_fun (x, ret_type)
            | lst => T_fun (T_prod (lst), ret_type)
          };
      }

      public DeclaringType : Tycon {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string {
        get { handle.Name }
      }

      public MemberType : MemberTypes {
        get { MemberTypes.Property }
      }

      public GetGetter () : IMethod
      {
        getter
      }

      public GetSetter () : IMethod
      {
        setter
      }

      public GetPropertyInfo () : SR.PropertyInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public GetKind () : MemberKind
      {
        MK_property (this)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public Attributes : NemerleAttributes
      {
        get { any_method.Attributes }
      }

      public GetCustomAttributes () : list <PT.Expr>
      { [] }

      public GetMacroAttributes () : list <string * PT.Expr>
      { [] }
      
      public SetCustomAttributes (_ : list <PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }

      public SetMacroAttributes (_ : list <string * PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }
      
      public IsStatic () : bool
      {
        is_static
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        handle.CanWrite
      }

      public CanAccess (source : Tycon) : bool
      {
        any_method.CanAccess (source)
      }
    }
    
    class NetMethod : IMethod
    {
      protected handle : SR.MethodBase;
      protected library : LibraryReference;
      protected id : int;
      protected fun_header : Fun_header;
      protected attributes : NemerleAttributes;

      public this (lib : LibraryReference, h : SR.MethodBase)
      {
        library = lib;
        handle = h;
        def mkparm (p : SR.ParameterInfo) {
          def ty =
            match (library.TypeOfType (p.ParameterType)) {
              | T_ref (t) when p.IsOut => T_out (t)
              | t => t
            };
          Fun_parm (
            loc = library._location,
            name = p.Name,
            color = 0,
            ty = ty,
            decl = null,
            modifiers = Modifiers.Empty // FIXME?
          )
        };
        def ret_type =
          if (handle.Name == ".ctor" || handle.Name == ".cctor")
            T_void ()
          else
            library.TypeOfType ((handle :> SR.MethodInfo).ReturnType);
            
        fun_header =
          Fun_header (
            loc = library._location,
            name = Name,
            ret_type = ret_type,
            parms = List.Map (List.FromArray (handle.GetParameters ()), 
                              mkparm),
            typarms = [],
            tenv = null
          );

        id = fun_header.id;

        attributes = NemerleAttributes.None;
        when (handle.IsAbstract) attributes |= NemerleAttributes.Abstract;
        when (handle.IsVirtual)  attributes |= NemerleAttributes.Virtual;
        when (handle.IsFinal)    attributes |= NemerleAttributes.Sealed;
        when (handle.IsStatic)   attributes |= NemerleAttributes.Static;
       
        when (handle.IsPrivate)  attributes |= NemerleAttributes.Private;
        when (handle.IsPublic)   attributes |= NemerleAttributes.Public;
        when (handle.IsFamily)   attributes |= NemerleAttributes.Protected;
        when (handle.IsAssembly) attributes |= NemerleAttributes.Internal;
      }
      
      public DeclaringType : Tycon {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string {
        get { handle.Name }
      }

      public MemberType : MemberTypes {
        get { MemberTypes.Method }
      }

      public virtual GetExternName () : string
      {
        null
      }

      public GetMethodBase () : SR.MethodBase
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        Tyutil.fun_type (GetHeader ())
      }

      public GetKind () : MemberKind
      {
        MK_method (this)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetCustomAttributes () : list <PT.Expr>
      { [] }

      public GetMacroAttributes () : list <string * PT.Expr>
      { [] }
      
      public SetCustomAttributes (_ : list <PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }

      public SetMacroAttributes (_ : list <string * PT.Expr>) : void
      {
        Util.ice ("cannot set attributes of external type - OO model is screwed,"
                  " this method belongs to Builder not Info")
      }
      
      public IsStatic () : bool
      {
        handle.IsStatic 
      }

      public GetId () : int
      {
        id
      }

      public virtual GetFreshType () : Type
      {
        GetMemType ()
      }

      public GetFunKind () : Fun_kind
      {
        if (handle.DeclaringType.IsInterface)
          FK_iface_method ()
        else
          if (handle.IsConstructor)
            if (handle.IsStatic)
              FK_static_ctor ()
            else
              FK_ctor ()
          else
            if (handle.IsStatic)
              FK_function ()
            else
              FK_bound_method ([])
      }

      public GetConstructorInfo () : SR.ConstructorInfo
      {
        assert (handle.IsConstructor);
        (handle :> SR.ConstructorInfo)
      }

      public GetMethodInfo () : SR.MethodInfo
      {
        assert (!handle.IsConstructor);
        (handle :> SR.MethodInfo)
      }

      public GetHeader () : Fun_header
      {
        fun_header
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (DeclaringType)) &&
           handle.IsFamily)
      }
    }
   
    /* -----------------------------------------------------------------
     * External Nemerle types
     * ----------------------------------------------------------------- 
     */
     
    private static get_string_attribute (attr_name : string, meth_name : string,
                                         attributes : array <object>) : string
    {
      def loop (i) {
        if (i >= attributes.Length) null
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == attr_name) {
            def meth = attr_ty.GetMethod (meth_name);
            (meth.Invoke (attr, null) :> string)
          } else loop (i + 1)
        }
      };
      loop (0)
    }

    private static get_encoded_type (attributes : array <object>) : string
    {
      get_string_attribute ("Nemerle.Internal.TypeAttribute", "GetEncodedType", attributes)
    }

    private static get_variant_options (attributes : array <object>) : list <string>
    {
      def str = get_string_attribute ("Nemerle.Internal.VariantAttribute", 
                                      "GetVariantOptions", attributes);
      NString.Split (str, array [','])
    }

    private static has_attribute (name : string, attributes : array <object>) : bool
    {
      def loop (i) {
        if (i >= attributes.Length) false
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == name) true
          else loop (i + 1)
        }
      };
      loop (0)
    }
    
    private class TypeInfo : NetType
    {
      internal tenv : SystemMap <int, Tyvar.T>;
      typarms : list <Tyvar.T>;
      direct_supertypes : list <Type>;
      supertypes : list <Type>;
      supertype_map : SystemMap <int, Type>;
      tydecl : Type_decl;
      constant_object : option <IField>;
      
      public this (lib : LibraryReference, h : System.Type)
      {
        base (lib, h);
        
        def tenv =
          if (handle.DeclaringType != null)
            (library.TyconOfType (handle.DeclaringType) :> TypeInfo).tenv
          else SystemMap ();

        def type_attrs = h.GetCustomAttributes (false);

        def attr_str = get_encoded_type (type_attrs); 
        def (typarms, tenv, dst, st) = TyCodec.DecodeTypeBuilder (lib, tenv, attr_str);

        this.typarms = typarms;
        this.tenv = tenv;
        direct_supertypes = dst;
        supertypes = st;

        def add (t, m : SystemMap <int, Type>) {
          match (t) {
            | T_app (tc, _) => m.Add (tc.GetId (), t)
            | _ => Util.ice ("invalid supertype")
          }
        };

        supertype_map = List.FoldLeft (supertypes, SystemMap (), add);
        constant_object = None ();

        if (has_attribute ("Nemerle.Internal.VariantAttribute", type_attrs)) {
          def names = get_variant_options (type_attrs);
          def get_opt (name : string) {
            match (GlobalEnv.LookupExactType (NString.Split (name, array ['.', '+']))) {
              | Some (tc) => tc
              | None => Util.ice ("cannot find variant option named " + name)
            }
          };
          tydecl = TD_variant (List.Map (names, get_opt))
        } else if (has_attribute ("Nemerle.Internal.VariantOptionAttribute", type_attrs)) {
          tydecl = TD_variant_option ()
        } else if (has_attribute ("Nemerle.Internal.ConstantVariantOptionAttribute",
                                  type_attrs)) {
          tydecl = TD_variant_option ();
          match (LookupMember ("_N_constant_object")) {
            | [fld] =>
              constant_object = Some ((fld :> IField))
            | _ => Util.ice ("cannot find _N_constant_object")
          }
        } else if (has_attribute ("Nemerle.Internal.TypeAliasAttribute", type_attrs)) {
          def type_string = 
            get_string_attribute ("Nemerle.Internal.TypeAliasAttribute",
                                  "GetAliasedType", type_attrs);
          tydecl = TD_alias (TyCodec.DecodeType (lib, tenv, type_string))
        } else if (handle.IsInterface)
          tydecl = TD_interface ()
        else if (handle.IsEnum)
          tydecl = TD_enum ()
        else
          tydecl = TD_class ()
      }
      
      public override GetMemType () : Type
      {
        T_app (this, List.Map (typarms, fun (tv) { T_var (tv) }))
      }

      public override GetTyconKind () : TyconKind
      {
        TK_ExternalNemerleType (handle)
      }

      public override GetTydecl () : Type_decl
      {
        tydecl
      }

      public override GetConstantObject () : option <IField>
      {
        constant_object
      }

      public override MakeSubst (parms : list <Type>) : Subst
      {
        TypeBuilder.ConstructSubst (this, typarms, parms)
      }

      public override FreshSubst () : Subst
      {
        Tyvar.fresh_subst (typarms)
      }

      public override SuperType (tc : Tycon) : option <list <Type>>
      {
        match (supertype_map.Find (tc.GetId ())) {
          | Some (T_app (_, args)) => Some (args)
          | Some => Util.ice ()
          | None => None ()
        }
      }

      public override SubtypingSubst (tc : Tycon) : Subst
      {
        if (tc.GetId () == GetId ())
          SystemMap () // current type, no substitution
        else
          tc.MakeSubst (Option.UnSome (SuperType (tc)));
      }

      public override GetSuperTypes () : list <Type>
      {
        supertypes
      }

      public override GetDirectSuperTypes () : list <Type>
      {
        direct_supertypes
      }

      protected override imember_of_memberinfo (m : SR.MemberInfo) : option <IMember>
      {
        def ty = m.MemberType;
        def is_nem (x : SR.MemberInfo) {
          has_attribute ("Nemerle.Internal.TypeAttribute", x.GetCustomAttributes (false))
        };
        def ret (x : IMember) { Some (x) };
        
        if (ty %&& MemberTypes.Constructor || ty %&& MemberTypes.Method) {
          if (is_nem (m))
            ret (MethodInfo (tenv, library, (m :> SR.MethodBase)))
          else
            ret (NetMethod (library, (m :> SR.MethodBase)))
        } else if (ty %&& (MemberTypes.Field)) {
          if (is_nem (m))
            ret (FieldInfo (tenv, library, (m :> SR.FieldInfo)))
          else
            ret (FieldInfo (library, (m :> SR.FieldInfo)))
        } else if (ty %&& MemberTypes.Property)
          ret (NetProperty (library, (m :> SR.PropertyInfo)))
        else if (ty %&& MemberTypes.NestedType)
          ret (library.TyconOfType ((m :> System.Type)))
        else
          Util.ice ("unknown object in nemerle type " + m.Name + " in "
                    + GetFullName ())
      }
    }
    
    class MethodInfo : NetMethod
    {
      public this (tenv : SystemMap <int, Tyvar.T>, lib : LibraryReference,
                   h : SR.MethodBase)
      {
        base (lib, h);
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        TyCodec.FixupFunctionHeader (lib, tenv, fun_header, attr_str);
      }
      
      public override GetExternName () : string
      {
        null
      }

      public override GetFreshType () : Type
      {
        GetMemType () /- Tyvar.fresh_subst (fun_header.typarms)
      }
    }
  }
} /* namespace */
