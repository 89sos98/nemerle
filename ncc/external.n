(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Collections;
  open Nemerle.Compiler.Parsetree;
  open Nemerle.Compiler;

  (**
   * We can specify libraries either by using assembly or file names
   *)
  variant LibraryName {  
    | AssemblyName { name : string; }
    | FileName { name : string; }
  }


  (**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   *)
  public class LibraryReferenceException extends System.Exception 
  {
    public this () {}
  }


  (**
   * Manager for the referenced libraries
   *)
  class LibraryReferenceManager
  {
    (* -- CONSTRUCTORS ----------------------------------------------------- *)
  
    (**
     * Static constructor. Always load the Framework core library.
     *)
    public static this () {

      _libraries <- [];
      
      AddLibrary (LoadCoreLibrary ())
    }


    (* -- PUBLIC METHODS --------------------------------------------------- *)
  
    (**
     * Stores the referenced library for later lookup by the namespaces.
     *)
    public static AddLibrary (library : LibraryReference) : void {
    
      _libraries <- library :: _libraries;
    }
  
  
    (**
     * Searches for a type name in all referenced external libraries
     * keeping in mind the list of all the open namespaces.
     *)
    public static Lookup (env : Env, path : list (string), type_name : string) : list (Decl)
    {
      match (path) {
        | [] =>
          LookupCollect (env, type_name, _libraries)
        | "" :: rest => 
          Lookup (env, rest, type_name)
        | path :: rest =>
          def looked_up = LookupCollect (env, path + type_name, _libraries);
          
          List.append (looked_up, Lookup (env, rest, type_name))
      }
    }
    

    (* -- PRIVATE METHODS -------------------------------------------------- *)

    (**
     * Scans through all the referenced external libraries looking for a type name.
     *)
    private static LookupCollect (env : Env, type_name : string, 
                                  libraries : list (LibraryReference)) : list (Decl) 
    {
      match (libraries) {
        | [] => []
        | library :: rest =>
          def looked_up = library.Lookup (env, type_name);
          
          List.append (looked_up, LookupCollect (env, type_name, rest))
      }
    }


    (**
     * Tries to load the core framework library using both 
     * the .NET Framework and Mono naming conventions.
     *)
    private static LoadCoreLibrary () : LibraryReference {

      def mscorelib = try LibraryReference (AssemblyName ("mscorlib.dll"))
                      with { e : System.IO.FileNotFoundException => null };
          
      if (mscorelib == null) {
      
        def corlib = try LibraryReference (AssemblyName ("corlib.dll"))
                     with { 
                       e : System.IO.FileNotFoundException =>
                         raise LibraryReferenceException ()
                     };
        
        corlib
      }
      else
        mscorelib    
    }
      
    
    (* -- PRIVATE VARIABLES ------------------------------------------------ *)
    
    (**
     * The referenced library list
     *)
    private static mutable _libraries : list (LibraryReference);
  }


  (**
   * This class stores information extracted from a referenced external library.
   *)
  class LibraryReference
  {
    (**
     * The assembly associated with this object
     *)
    private mutable _library : System.Reflection.Assembly;

    (**
     * The location of this library
     *)
    private mutable _location : Location;
    
    (**
     * The environment of this library
     *)
    private mutable _env : Env;
    
    (**
     * The assembly's custom attributes
     *)
    private mutable _assembly_attributes : list (System.Object);
       
    (**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     *)
    private mutable _is_generated_by_nemerle : bool;
       
       
    (**
     * Loads an assembly given it's file or assembly name. 
     * Extracts and processes the custom attributes array.
     *)
    public this (library_name : LibraryName) 
    {
      match (library_name) {
        | AssemblyName (name) =>
          this._library <- System.Reflection.Assembly.Load (name)
        | FileName (name) =>
          this._library <- System.Reflection.Assembly.LoadFrom (name)
      };

	    this._location <- Location("[library:" + (this._library.GetName ()).Name + "]", 0, 0);

      this._assembly_attributes <- List.from_array (this._library.GetCustomAttributes (true));
      this.process_assembly_attributes ()
    } 

    (**
     * Scans the assembly custom attributes looking for something interesting...
     *)
    private process_assembly_attributes () : void
    {
      def loop (attributes : list (System.Object)) : void {
        match (attributes) {
          | [] => ()
          | attribute :: rest =>
            def attribute_type = (attribute :> System.Attribute).GetType ();
            when (attribute_type.FullName == "System.Reflection.AssemblyConfigurationAttribute") {
              def configuration_attribute = (attribute :> System.Reflection.AssemblyConfigurationAttribute);
              
              when (configuration_attribute.Configuration == "ContainsNemerleTypes") {
                Message.debug ("Loaded assembly " + this._library.FullName + " contains Nemerle types...");
                this._is_generated_by_nemerle <- true
              };
            };
            
            loop (rest)
        }
      };
      
      loop (this._assembly_attributes)
    }

    (**
     * Creates a public constructor declaration
     *)
    private make_ctor (class_name : string, param_list : list (Fun_parm)) : Class_member
    {
      // FIXME: what about abstract constructors?
      def header = Fun_header (this._location, ".ctor", Type.T_void (), param_list);
      Class_member.M_function (loc = this._location,
                               name = ".ctor",
                               modifiers = [Mod_public ()],
                               header = header,
                               kind = FK_ctor (), 
                               body = FB_extern (class_name + "..ctor"))
    }
  

    (**
     * Creates a public static method declaration
     *)
    private make_static_method (class_name : string, method_name : string, 
                                return_type : Type, param_list : list (Fun_parm)) : Class_member
    {
      // FIXME: what about abstract static methods?
      def header = Fun_header (this._location, method_name, return_type, param_list);
      Class_member.M_function (loc = this._location,
                               name = method_name, 
                               modifiers = [Mod_public ()], 
                               header = header, 
                               kind = FK_function (), 
                               body = FB_extern (class_name + "." + method_name))
    }

  
    (**
     * Creates a public method declaration
     *)
    private make_method (class_name : string, method_name : string, 
                         return_type : Type, param_list : list (Fun_parm)) : Class_member
    {
      // FIXME: what about abstract methods?
      def header = Fun_header (this._location, method_name, return_type, param_list);
      Class_member.M_function (loc = this._location, 
                               name = method_name,
                               modifiers = [Mod_public ()],
                               header = header, 
                               kind = FK_method ([]), 
                               body = FB_extern (class_name + "." + method_name))
    }


    (**
     * Creates a public property declaration
     *)
    private make_property (class_name : string, property_name : string, 
                           property_type : Type, is_readable : bool, is_writeable : bool,
                           is_static : bool, indexer_parameters : list (list (Fun_parm))) : Class_member
    {
      def build_accessors (prefix : string, indexer_parameters : list (list (Fun_parm))) {
        def walk_parameters (indexer_parameters) {
          match (indexer_parameters) {
            | parameters :: rest =>
              (FB_extern (class_name + "." + prefix + "_" + property_name), parameters) ::
                walk_parameters (rest)
            | [] => []
          }
        };
        
        match (indexer_parameters) {
          | [] => [(FB_extern (class_name + "." + prefix + "_" + property_name), [])]
          | indexer_parameters => walk_parameters (indexer_parameters)
        }          
      };
      
      // FIXME: what about the location?
      def get_methods = if (is_readable) build_accessors ("get", indexer_parameters) else [];
      def set_methods = if (is_writeable) build_accessors ("set", indexer_parameters) else [];      
      Class_member.M_property (loc = this._location,
                               name = property_name,
                               modifiers =
                                 if (is_static) [Mod_public (); Mod_static ()] 
                                 else [Mod_public ()],
                               ty = property_type, 
                               get_methods = get_methods, 
                               set_methods = set_methods, 
                               is_static = is_static)
    }


    (**
     * Creates a public field declaration
     *)
    private make_field (class_name : string, field_name : string, 
                        field_type : Type, is_static : bool) : Class_member
    {
      Class_member.M_field (loc = this._location,
                            modifiers =
                              if (is_static) [Mod_public (); Mod_static ()]
                              else [Mod_public ()],
                            name = field_name,
                            ty = field_type, 
                            is_ref = true, 
                            kind = Val_normal ())
    }


    (**
     * Turns a Framework type into something edible by Nemerle's type system
     *)
    private process_framework_type (framework_type : System.Type) : Type
    {
      // FIXME: ref and out types, anyone?
      def framework_type_as_string = framework_type.ToString ();
    
      if (framework_type_as_string == "System.Void")
        T_void ()
      else
        if (framework_type.IsArray)
          T_array (this.process_framework_type (framework_type.GetElementType ()))
        else
          if (framework_type.IsByRef)
            T_ref (this.process_framework_type (framework_type.GetElementType ()))
          else
            T_app (SS_string (framework_type_as_string), []);    
    } 


    (**
     * Scans a list of attributes, returns a Nemerle type if an appropriate
     * NemerleType attribute has been associated with the type member...
     *)
    private extract_type_from_attributes (attributes : list (System.Object)) : option (Type) {
    
      match (attributes) {
        | [] => None ()
        | attribute :: rest =>      
          def attribute_type = attribute.GetType ();
            
          if ((attribute.GetType ()).FullName == "Nemerle.TypeAttribute") {

            def get_encoded_type = attribute_type.GetMethod ("GetEncodedType");
            def encoded_type = (get_encoded_type.Invoke (attribute, null) :> string);
            
            Some (Tyutil.decode_type (this._env, encoded_type))
          } 
          else this.extract_type_from_attributes (rest)
      }
    }


    (**
     * Returns true if a Nemerle.VariantAttribute exists in the attributes list.
     *)
    private check_variant_attributes (attributes : list (System.Object)) : bool {
    
      match (attributes) {
        | [] => false
        | attribute :: rest =>      
          def attribute_type = attribute.GetType ();
            
          if ((attribute.GetType ()).FullName == "Nemerle.VariantAttribute")
            true
          else            
            this.check_variant_attributes (rest)
      }
    }


    (**
     * Returns the encoded variant option type if a Nemerle.VariantOptionAttribute 
     * exists in the attributes list.
     *
     * FIXME: decode the type...
     *)
    private check_variant_option_attributes (attributes : list (System.Object)) : option (string) {
    
      match (attributes) {
        | [] => None ()
        | attribute :: rest =>      
          def attribute_type = attribute.GetType ();
            
          if ((attribute.GetType ()).FullName == "Nemerle.VariantOptionAttribute") {
          
            def get_encoded_type = attribute_type.GetMethod ("GetEncodedType");
            def encoded_type = (get_encoded_type.Invoke (attribute, null) :> string);
            
            Some (encoded_type)
          } 
          else            
            this.check_variant_option_attributes (rest)
      }
    }

    (**
     * Builds a parameter list for a constructor, method or indexer
     *)
    private build_params (parameters : list (System.Reflection.ParameterInfo)) : list (Fun_parm)
    {
      match (parameters) {
        | param :: rest =>          
          def parameter_type = this.process_framework_type (param.ParameterType);
          
          Fun_parm (this._location, param.Name, parameter_type) ::
            this.build_params (rest)
        | [] => []
      } 
    }


    (**
     * Builds a list of constructors of a type
     *)
    private build_constructors (class_name : string,
                                type_constructors : list (System.Reflection.ConstructorInfo)) 
                                : list (Class_member)
    {        
      match (type_constructors) {
        | constructor :: rest =>
          def constructor_params = List.from_array (constructor.GetParameters ());
          def parameters = this.build_params (constructor_params);

          this.make_ctor (class_name, parameters) ::
            this.build_constructors (class_name, rest)
        | [] => []
      }
    }
    

    (**
     * Builds a list of methods of a type
     *)
    private build_methods (current_type : System.Type,
                           class_name : string,
                           methods : list (System.Reflection.MethodInfo))
                           : list (Class_member) 
    {
      match (methods) {
        | method :: rest =>        
          def attributes = method.GetCustomAttributes (true);
          
          when (this.IsGeneratedByNemerle ()) {          
            def nemerle_type = this.extract_type_from_attributes (List.from_array (attributes));
          
            match (nemerle_type) {
              | Some (nemerle_type) =>
                Message.debug ("Method " + class_name + "." + method.Name +
                               " exposes a Nemerle type.") // FIXME
              | None => 
                Message.debug ("Method " + class_name + "." + method.Name + 
                               " does not expose a Nemerle type.") // FIXME
            }
          };
          
          def method_params = this.build_params (List.from_array (method.GetParameters ()));
          def method_rettype = this.process_framework_type (method.ReturnType);

          // woraround for mono bug #52182
          if (method.IsStatic && method.DeclaringType != current_type)
            this.build_methods (current_type, class_name, rest)
          else {
            def member = 
              if (method.IsStatic) 
                this.make_static_method (class_name, method.Name, 
                                         method_rettype, method_params)
              else
                this.make_method (class_name, method.Name, 
                                  method_rettype, method_params);
            member.loc <- this._location;
            member :: this.build_methods (current_type, class_name, rest)
          }

        | [] => []
      }
    }


    (**
     * Builds a list of properties of a type
     *)
    private build_properties (class_name : string,
                              properties : list (System.Reflection.PropertyInfo))
                              : list (Class_member)
    {
      def is_static (property : System.Reflection.PropertyInfo) : bool {
            
        def get_method = property.GetGetMethod ();
        def set_method = property.GetSetMethod ();
        
        if (get_method != null && get_method.IsStatic) true
        else if (set_method != null && set_method.IsStatic) true
        else false
      };

      def ungroup_parameters (group : list (System.Reflection.PropertyInfo)) {
        match (group) {
          | property :: rest =>
            def parameters =
              this.build_params (List.from_array (property.GetIndexParameters ()));
            parameters :: ungroup_parameters (rest)
          | [] => []
        }
      };

      def walk_groups (groups : list (list (System.Reflection.PropertyInfo))) : list (Class_member) {            
        match (groups) {
          | group :: rest =>
                  
            def property = List.head (group);
                                      
            def property_type = this.process_framework_type (property.PropertyType);

            def index_parameters = ungroup_parameters (group);
                      
            def member = this.make_property (class_name,
                                            property.Name, property_type,
                                            property.CanRead, property.CanWrite,
                                            is_static (property),
                                            index_parameters);
      
            member :: walk_groups (rest)
              
          | [] => []
        }      
      };
      
      def compare_properties_by_name (l : System.Reflection.PropertyInfo, r : System.Reflection.PropertyInfo) : int {
        System.String.Compare (l.Name, r.Name)
      };

      def grouped_properties = List.group (compare_properties_by_name, properties);

      walk_groups (grouped_properties)
    }


    (**
     * Builds a list of the fields of a type
     *)
    private build_fields (current_type : System.Type,
                          class_name : string,
                          fields : list (System.Reflection.FieldInfo))
                          : list (Class_member)
    {      
      match (fields) {
        | field :: rest =>
          
          def field_type = this.process_framework_type (field.FieldType);

          // woraround for mono bug #52182
          if (field.IsStatic && field.DeclaringType != current_type)
            this.build_fields (current_type, class_name, rest)
          else {
            def member = this.make_field (class_name,
                                          field.Name, field_type,
                                          field.IsStatic);
      
            member :: this.build_fields (current_type, class_name, rest)
          }

        | [] => []
      }
    }


    (**
     * If true, the library seems to have been generated by the Nemerle compiler
     *)
    public IsGeneratedByNemerle () : bool 
    {
      this._is_generated_by_nemerle
    }
    
    
    (**
     * Imports a System.Type, inserting it into the Nemerle type system.
     *)
    private ProcessType (reflected_type : System.Type) : Decl
    {
      def name = reflected_type.FullName; // FIXME: what about the + marks?
      
      def type_attributes = List.from_array (reflected_type.GetCustomAttributes (false));
          
      if (this.check_variant_attributes (type_attributes))
        Message.debug ("type '" + name + "' is a variant...") else ();
        
      if (Option.is_some (this.check_variant_option_attributes (type_attributes)))
        Message.debug ("type '" + name + "' is a variant option...") else ();
                          
      def is_class = reflected_type.IsClass;
    
      def base_type = reflected_type.BaseType;

      def type_constructors = List.from_array (reflected_type.GetConstructors ());
      def type_methods = List.from_array (reflected_type.GetMethods ());
      def type_properties = List.from_array (reflected_type.GetProperties ());
      def type_fields = List.from_array (reflected_type.GetFields ());
      def subtypes = List.from_array (reflected_type.GetNestedTypes ());

      // FIXME: handle the subtypes here

      def constructors = this.build_constructors (name, type_constructors);
      def methods = this.build_methods (reflected_type, name, type_methods);
      def properties = this.build_properties (name, type_properties);
      def fields = this.build_fields (reflected_type, name, type_fields);

    	def members = 
    	  List.append (List.append (List.append (constructors, methods), properties), fields);
      
  	  def declaration = TD_class (members);
	    declaration.name <- name;
	    declaration.loc <- this._location;
      declaration.typarms <- Typarms ([], []);
  
      if (reflected_type.IsEnum)
        declaration.t_extends <- Some (T_app (SS_string ("System.Enum"), []))
      else
        declaration.t_extends <- None ();
        
      declaration.t_implements <- []; 
      declaration.modifiers <- [Mod_public ()];

      def type_info = Tyinfo (None (), this._env, declaration, true);

      when (this._is_generated_by_nemerle) {
        Message.debug ("adding Nemerle type: '" + name + "'")
      };

      def decl = Env.add_type (type_info);

      Env.externals.Add (name, decl);

      Tyinfo.make_external (this._env, type_info);

      decl    
    }
    
    
    (**
     * Looks up a type name in this assembly. The type name is expected
     * to be full, i.e. containing the full namespace qualifier.
     *)
    public Lookup (env : Env, name : string) : list (Decl) {

      (* always first check if such a type is defined in the current library *)
      def reflected_type = this._library.GetType (name);

      if (reflected_type != null) {

        (* need to check that again, as the same type could be found using different paths before *)
        def cached_type = (Env.externals [name] :> Decl);
      
        if (cached_type == null) {
        
          this._env <- env.copy ();
          this._env.current_namespace <- "";

          [this.ProcessType (reflected_type)]
        }
        else {
        
          [cached_type]
        }
      }
      else []
    }
  }
} (* namespace *)
