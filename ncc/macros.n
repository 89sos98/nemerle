(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Macros {

  // some tool methods
  public unsstring (x : Splicable_string) : string {
    match (x) {
      | SS_string (x) => x
      | _ => raise Invalid_argument ("Macros.unsstring")
    }
  }

  // QUOTATION HANDLING SECTION

  (** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => <[ [] ]>
        | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
      }
    }

  (** this method treats expression as syntax tree of list containing 
      expressions, which are arguments of variable argument constructs
      (sequence, tuple, etc.)
      it also apply given function to each argument
   *)
  decompose_list (f : Expr -> Expr, ex : Expr) : Expr
    {
      match (ex) {
        | <[ $h :: $t ]> =>
          <[ $(f (h)) :: $(decompose_list (f, t)) ]>
        | <[ [] ]> => ex
        | E_spliced (e) => e
        | E_spliced_patt => ex
        | _ => 
          print_tree(ex, "");
          Message.fatal_error ("Bad expression in quoted variable arguments list: ")
          
      }
    }

  decompose_pattern_list (f : Pattern -> Expr, pa : Pattern) : Expr
    {
      match (pa) {
        | <[ pattern: Cons ($h, $t) ]> => 
          <[ $(f (h)) :: $(decompose_pattern_list (f, t)) ]>
        | <[ pattern: [] ]> => <[ [] ]>
        | P_spliced (e) => e
        | _ => Message.error ("Bad pattern in quoted variable arguments list: "); 
          print_pattern(pa, ""); f (pa)
      }
    }

  decompose_type_list (f : Type -> Expr, ty : Type) : Expr
    {
      match (ty) {
        | T_prod (types) => 
          make_quoted_list (f, types)
        | T_spliced (e) => e
        | _ => Message.error ("Bad type in quoted variable arguments list: "); 
          f (ty)
      }
    }

  quoted_sstring (st : Splicable_string) : Expr
    { match (st) {
        | SS_string (str) => 
          <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($(str : string)) ]>
        | SS_spliced_expr (E_spliced_special ("var", e)) => 
          <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($e) ]>
        | SS_spliced_expr (e) => e
      }
    }

  quoted_location (loc : Location) : Expr
    {
      <[ Nemerle.Compiler.Location ($(loc.file : string), $(loc.line : int),
 	                            $(loc.column : int)) ]>
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  public quoted_type (t : Type) : Expr
  {
    match (t) {
      | <[ type: $tycon (.. $args) ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)),
                                                 $(decompose_type_list (quoted_type, ar))) ]>
	  | _ =>
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)), 
                                                 $(make_quoted_list (quoted_type, args))) ]>
        }

      | <[ type: $(name : var) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_var ($(name : string)) ]>
        
      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ty))) ]>
	
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ty))) ]>
	
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (from)),
                                             $(quoted_type (to))) ]>
	
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Parsetree.T_void () ]>
	
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quoted_type, args))) ]>

      | <[ type: array ($ty) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_array ($(quoted_type (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.T_var ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer =>
        <[ Nemerle.Compiler.Parsetree.T_infer () ]>

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(decompose_type_list (quoted_type, ar))) ]>
    }	
  }

  /// create construction tree of given call parameter
  public quoted_param (p : Parm) : Expr
    {
      match (p) {
        | <[ parameter: $name = $expr ]> =>
          <[ Nemerle.Compiler.Parsetree.Parm (false, 
                                              $(quoted_expr (expr)), 
                                              $(quoted_sstring (name))) ]>
        | <[ parameter: ref $name = $expr ]> =>
          <[ Nemerle.Compiler.Parsetree.Parm (true, 
                                              $(quoted_expr (expr)), 
                                              $(quoted_sstring (name))) ]>
      }
    }

  public quoted_case_guard (pair : Pattern * option (Expr)) : Expr
    {
      match (pair) {
        | <[ caseguard: $pat when $gu ]> => 
          <[ ($(quoted_pattern (pat)), Nemerle.Core.Some ($(quoted_expr (gu)))) ]>
        | <[ caseguard: $pat ]> =>
          <[ ($(quoted_pattern (pat)), Nemerle.Core.None ()) ]>
      }
    }

  public quoted_case (cas : Match_case) : Expr
    {
      def <[ case: | ..$guards => $expr ]> = cas;

      match (guards) {
        | [(P_patt_list (args), None)] =>
          <[ Nemerle.Compiler.Parsetree.Match_case ($(decompose_pattern_list (quoted_pattern,
             args)), $(quoted_expr (expr))) ]>
        | _ =>
          <[ Nemerle.Compiler.Parsetree.Match_case ($(make_quoted_list (quoted_case_guard, 
            guards)), $(quoted_expr (expr))) ]>
      }
    }

  public quoted_fparam (p : Fun_parm) : Expr
  {
    match (p) {
      | <[ funparm: $name : $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ty)),
                                                Nemerle.Compiler.Parsetree.FP_normal ()) ]>
      | <[ funparm: params $name : $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ty)),
                                                Nemerle.Compiler.Parsetree.FP_params ()) ]>
      | <[ funparm: $name : $ty = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ty)),
                         Nemerle.Compiler.Parsetree.FP_default ($(quoted_expr (expr)))) ]>
    }
  }

  public quoted_fundecl (d : Function_decl) : Expr
  {
    def quoted_tparms (t : Typarms) : Expr
    {
      def quoted_constraint (c : Constraint) {
        <[ Nemerle.Compiler.Parsetree.Constraint ($(c.tyvar : string),
                                                  $(quoted_type (c.ty))) ]>
      };
      def quoted_string (s) { <[ $(s : string) ]> };

      <[ Nemerle.Compiler.Parsetree.Typarms ($(make_quoted_list (quoted_string, t.tyvars)),
           $(make_quoted_list (quoted_constraint, t.constraints))) ]>
    };

    match (d) {
      | <[ fundecl: $name (..$fparms) : $ty { ..$bodyseq } ]> =>
        def body = quoted_expr (<[ {..$bodyseq} ]>);
        match (fparms) {
          | [{ name = SS_string (""); ty = <[ type: void ]>; attr = FP_default (e); }] =>
            <[ Nemerle.Compiler.Parsetree.Function_decl 
                (Nemerle.Compiler.Parsetree.Fun_header ($(quoted_tparms (d.header.typarms)),
                 $(quoted_sstring (name)), $(quoted_type (ty)),
                 $(decompose_list (quoted_expr, e))),
                 $body) ]>
          | _ =>
              <[ Nemerle.Compiler.Parsetree.Function_decl 
                 (Nemerle.Compiler.Parsetree.Fun_header ($(quoted_tparms (d.header.typarms)),
                    $(quoted_sstring (name)), $(quoted_type (ty)),
                    $(make_quoted_list (quoted_fparam, fparms))),
                  $body) ]>
        }
      | _ => Message.fatal_error ("such quoted function declaration is not supported")
    }
  }

  public quoted_expr (expr : Expr) : Expr 
    {
      match (expr) {
        | <[ $(id : var) ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_ref ($(id : string)) ]>

        | <[ $obj . $mem ]> => 
          <[ Nemerle.Compiler.Parsetree.E_member ($(quoted_expr (obj)),
                                                  $(quoted_sstring (mem))) ]>

        | <[ $func (.. $parms) ]> =>
          match (parms) {
            | [ { expr = E_expr_list (args) }] =>
              <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)),
                                                    $(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)), 
                                                    $(make_quoted_list (quoted_param, parms))) ]>
          }

        | <[ $target <- $source ]> =>
          <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (target)), 
                                                  $(quoted_expr (source))) ]>

        | <[ def $name = $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(false : bool), 
                                               $(quoted_sstring (name)), 
                                               $(quoted_expr (val))) ]>

        | <[ mutable $name <- $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(true : bool),
                                               $(quoted_sstring (name)),
                                               $(quoted_expr (val))) ]>

	| <[ def (.. $elems) = $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (P_tuple (elems))), 
                                                  $(quoted_expr (val))) ]>

        | <[ def .. $funs ]> =>
          match (funs) {
            | [(_, E_expr_list (args))] =>
              <[ Nemerle.Compiler.Parsetree.E_letfun ($(decompose_list (quoted_expr, args))) ]>
            | _ =>
  	      <[ Nemerle.Compiler.Parsetree.E_letfun ($(make_quoted_list (quoted_fundecl, funs))) ]>
          }

        | <[ fun (..$args) : $ty { ..$bodyseq } ]> =>
          // we have to rebuild sequence, which is here decomposed
          def body = quoted_expr (<[ {..$bodyseq} ]>);
          match (args) {
            | [{ name = SS_string (""); ty = <[ type: void ]>; attr = FP_default (e); }] =>
              <[ Nemerle.Compiler.Parsetree.E_lambda (Nemerle.Compiler.Parsetree.Function_decl 
                  (Nemerle.Compiler.Parsetree.Fun_header (Nemerle.Compiler.Parsetree.Typarms([],[]),
                    Nemerle.Compiler.Parsetree.Splicable_string.SS_string (""), $(quoted_type (ty)),
                    $(decompose_list (quoted_expr, e))),
                   $body)) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.E_lambda (Nemerle.Compiler.Parsetree.Function_decl 
                 (Nemerle.Compiler.Parsetree.Fun_header (Nemerle.Compiler.Parsetree.Typarms([],[]),
                    Nemerle.Compiler.Parsetree.Splicable_string.SS_string (""), $(quoted_type (ty)),
                    $(make_quoted_list (quoted_fparam, args))),
                  $body)) ]>
          };

        | <[ match ($expr) {.. $cases } ]> =>
          match (cases) {
            | [cas] when match (cas.patterns) { | [] => true | _ => false } =>
              match (cas.body) {
                | E_expr_list (e) =>
   	          <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                       $(decompose_list (quoted_expr, e))) ]>
                | _ =>
                  Util.ice ("parser generated strange match_case")
              }
            | _ =>
   	      <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                                                     $(make_quoted_list (quoted_case, cases))) ]>
          }

	| <[ raise $exc ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (exc))) ]>

	| <[ try $body with { $exn : $exn_ty => $handler } ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_try_with ($(quoted_expr (body)), 
                                                    $(quoted_sstring (exn)),
                                                    $(quoted_type (exn_ty)), 
                                                    $(quoted_expr (handler))) ]>

        | <[ try $body finally $handler ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (body)), 
                                                       $(quoted_expr (handler))) ]>

        | <[ () ]> => 
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ null ]> => 
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_null ()) ]>

        | <[ $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ $(_val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float (0 (* $(val : float) *))) ]> // FIXME

        | <[ $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ this ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_this () ]>

        | <[ base ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_base () ]>

        | <[ typeof ($t) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_typeof ($(quoted_type (t))) ]>

        | <[ ( $expr :> $ty ) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (expr)),
	                                                   $(quoted_type (ty))) ]>

        | <[ ( $expr : $ty ) ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (expr)),
	                                                    $(quoted_type (ty))) ]>

	| <[ {.. $seq } ]> =>
          match (seq) {
            | [E_expr_list (seq)] =>
              <[ Nemerle.Compiler.Parsetree.E_sequence ($(decompose_list (quoted_expr, seq))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_sequence ($(make_quoted_list (quoted_expr, seq))) ]>
          }

	| <[ (.. $args) ]> =>
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_tuple ($(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quoted_expr, args))) ]>
          }

    	| <[ mkarray [.. $args] ]> =>
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_mkarray ($(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_mkarray ($(make_quoted_list (quoted_expr, args))) ]>
          }
	
        | <[ $obj [.. $args] ]> =>  
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_indexer ($(quoted_expr (obj)),
                                                       $(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_indexer ($(quoted_expr (obj)),
                                                       $(make_quoted_list (quoted_expr, args))) ]>
          }

        // rest of constructs must be in not quoted form, because they define
        // internal data structures
	| E_spliced (e) => e

        | E_spliced_patt => expr

        | E_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.E_ref ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($val)) ]>
            | "typed" => 
              <[ Nemerle.Compiler.Parsetree.E_typed_expr ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in expression")
          }

	| E_quoted => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_typed_expr => 
	  Util.ice ("You've got beer from me for generating such a code...");
        | E_expr_list =>
          // print location
	  Message.debug ("list of expression parameters outside of any construct");
          Util.ice ("List of expression parameters outside of any construct")
        | E_letpat => Util.ice ("Bad construction of E_letpat")
        | E_lambda => Util.ice ("Bad construction of E_lambda")
      };
    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction
      tree 
   *)	  
  public quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | <[ pattern: _ ]> => <[ Nemerle.Compiler.Parsetree.P_underscore () ]>

        | <[ pattern: $(name : var) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_variable ($(name : string)) ]>

        | <[ pattern: ($pat) as $name ]> => 
          <[ Nemerle.Compiler.Parsetree.P_as ($(quoted_pattern (pat)), 
                                              $(quoted_sstring (name))) ]>

(* it seems to be impossible to be done, because we would have to write pattern, 
   which matches terms like Cons(x, Cons(y, Cons(z, xs))) into [x;y;z; ?]
        | <[ pattern: [..$elems] ]> =>
          match (elems) {
            | [P_patt_list (args)] => decompose_pattern_list (quoted_pattern, args)
            | _ =>
              make_quoted_list (quoted_pattern, elems)
          }
        | <[ pattern: [$elems] ]> =>
          match (elems) {
            | P_patt_list (args) => quoted_pattern (args)
            | _ =>
              def nl = <[ pattern : [] ]>;
              <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (SS_string ("Cons"))), 
                 $(quoted_pattern (P_tuple ([elems; nl])))) ]>
          }
*)// <[ pattern: Cons ($elems, Nil) ]>

        | <[ pattern: (.. $args) ]> =>
          match (args) {
            | [P_patt_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(decompose_pattern_list (quoted_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(make_quoted_list (quoted_pattern, args))) ]>
          }
        
        | <[ pattern: {.. $args } ]> =>
          def quoted_named_pattern (patt : string * Pattern) : Expr
            {
              def (name, pat) = patt;
              <[ ($(name : string), $(quoted_pattern (pat))) ]>
            };
             
          match (args) {
            | [(_, P_patt_list (args))] =>
              <[ Nemerle.Compiler.Parsetree.P_record 
                   ($(decompose_pattern_list (quoted_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_record
                   ($(make_quoted_list (quoted_named_pattern, args))) ]>
          }

        | <[ pattern: $name (.. []) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                         Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        | <[ pattern: $name (.. $args) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (P_tuple (args)))) ]>

        | <[ pattern: $name {.. $args} ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (P_record (args)))) ]>

        | <[ pattern: $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ pattern: $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ pattern: $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ pattern: $(val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

        | <[ pattern: $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ pattern: () ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ pattern: null ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_null ()) ]>

        | <[ pattern: $name _ ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
             Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        // rest of constructs must be in not quoted form, because they define
        // internal data structures
	| P_spliced (e) => e

        | P_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.P_variable ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($val)) ]>
            | "name" => 
              <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in pattern")
          }

        | P_quoted =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_patt_list =>
//          decompose_pattern_list (quoted_pattern, args)
          Message.fatal_error 
            ("Variable pattern arguments list appears outside of proper construct")
        | P_cons (_, p) =>
          print_string("name "); print_pattern(p, "");
          Util.ice ("Bad constructed P_cons")
      } 
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  public expr_to_pattern (exp : Expr) : Pattern 
    {
      def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
        match (pars) {
          | [] => 
            match (acc) {
	      | [] => P_underscore ()
	      | _ => P_tuple (List.rev (acc))
            }
          | <[ parameter: $expr ]> :: xs => 
            convert_params (xs, expr_to_pattern (expr) :: acc)
          | _ => Util.ice ("strange parameters generated from quoting")
        }
      };

      def flat_member (obj) {
        def collect_member (obj : Expr, acc) {
          match (obj) {
            | <[ $(id : var) ]> => id :: acc
            | <[ $head.$(id : var) ]> => collect_member (head, id :: acc)
            | _ => Util.ice ("Corrupted member while flatting member expr -> pattern")
          }
        };
        match (collect_member (obj, [])) {
          | x :: xs =>
            def inter = List.fold_left (
              fun (sb : System.Text.StringBuilder, s : string) : System.Text.StringBuilder 
                { sb.Append ("." + s) }, 
              System.Text.StringBuilder (x), xs);
            inter.ToString ()
          | _ =>
            Util.ice ("collect_member returned empty list")
        }
      };

      match (exp) {
        | <[ $(id : var) ]> => <[ pattern: $(id : var) _ ]>
        | <[ $constr (.. $pars) ]> =>
          def con = flat_member (constr);
          match (GlobalEnv.LookupExactType (con)) {
            | Some (tcon) =>
              match (tcon.GetTydecl ()) {
                | Typedtree.TD_variant_option =>
                  P_cons (SS_string (con), convert_params (pars, []))                  
                | Typedtree.TD_class  =>
                  // we lose informations about constructor here, but as it's 
                  // compiler internal computation we can ignore it
                  convert_params (pars, [])
                | _ =>
                  Util.ice ("expression generated from quotation has nor variant"
                            + " neither class constructor")
              }
            | None =>
              Util.ice ("expression generated from quotation has broken constructor")
          }

        | <[ (..$elems) ]> => <[ pattern: (..$(List.map (expr_to_pattern, elems))) ]>

        | E_literal (lit) => P_literal (lit)
          
	| E_spliced_patt (p) => p
        
        | _ => 
          print_tree (exp, "");
          Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
      }
    }

  // GENERATION OF MACRO CLASSES SECTION

  public GenerateMacroClass (ctx : Parser.CTX, attrs : list(Modifier), 
                             header : Fun_header, synt : list(Expr), 
                             expr : Expr) : Type_decl 
  {
    def name = 
      match (header.name) {
        | SS_string (n) => n
        | _ => Message.fatal_error ("spliced name in macro name is not allowed")
      };

    // walk through parameters given to macro, extract their names,
    // note type names, control if they correspond to Nemerle grammar,
    // handle variable amount of parameters and default values
    // create code decomposing passed parameters if needed
    def analyze_params (pars : list (Fun_parm), acc, accs, defaults,
                        types : System.Text.StringBuilder) 
                        : list (Pattern) * list (Expr) 
    {
      // build pattern for list from list of patterns
      def roll (li, bu) {
        match (li) {
          | [] => bu
          | x::xs => roll (xs, <[ pattern: $x :: $bu ]>)
        }
      };
      // build expression for list from list of expressions
      def roll_expr (li, bu) {
        match (li) {
          | [] => bu
          | (va, d)::xs => roll_expr (xs, <[ { def $(va : var) = $d; $bu } ]>)
        }
      };
      // handle case of standard (not params or with default value) parameter
      // decompose handled types, note them and build pattern matching
      // parameter's expression
      def normal_parm (t, va) {
        match (t) {
          | T_infer 
          | <[ type: expr ]> => 
            (<[ pattern: { expr = $(va : var) } ]>, types.Append (" expr"))
          | <[ type: parm ]> =>
            (<[ pattern: $(va : var) ]>, types.Append (" parm"))
          | <[ type: string ]> =>
            (<[ pattern: { expr = Nemerle.Compiler.Parsetree.E_literal 
                             (Nemerle.Compiler.L_string ($(va : var))) } ]>,
             types.Append (" string"))
          | <[ type: int ]> =>
            (<[ pattern: { expr = Nemerle.Compiler.Parsetree.E_literal 
                            (Nemerle.Compiler.L_int ($(va : var))) } ]>,
             types.Append (" string"))
          | <[ type: bool ]> =>
            (<[ pattern: { expr = Nemerle.Compiler.Parsetree.E_literal 
                            (Nemerle.Compiler.L_bool ($(va : var))) } ]>,
             types.Append (" bool"))
          | _ =>
            Message.fatal_error ("type not supported")
        }
      };
      // create list of match cases (patterns and expressions) containing
      // cases for default values of parameters, add expressions defining
      // missed parameters according to those default values
      def traverse_patterns (pattss, defaults, defsrest, accpat, accexp) {
        match ((pattss, defaults)) {
          | ([], _) => (accpat, accexp)
          | (patts :: xss, []) =>
            traverse_patterns (xss, [], [], roll (patts, <[ pattern: [] ]>) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
          | (patts :: xss, d :: ds) =>
            def newdrest = d :: defsrest;
            traverse_patterns (xss, ds, newdrest, 
                               roll (patts, <[ pattern: [] ]>) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
        }
      };

      // iterate through parameters
      match (pars) {
        | [] => 
          // we have fixed amount of parameters, so there is always
          // case, which triggers error, handle it
          def warn = <[ Nemerle.Compiler.Message.fatal_error ("macro `" 
            + $(name : string) + "' expects following list of arguments: " + 
            $(types.ToString () : string)) ]>;
          traverse_patterns (acc :: accs, defaults, [], [ <[ pattern: _ ]> ], [warn])
        | { name = SS_string (va); ty = t; attr = at } :: xs =>
          match (at) {
            // variable amount of parameters is handled here
            | FP_params =>
              def (initpat, initex) =
                match (acc) {
                  // if there are some elemnts other than out 'va', then this
                  // pattern won't be exchaustive, and we must supply error msg
                  | _ :: _ => 
                    def types = types.Append (" params array");
                    def warn = <[ Nemerle.Compiler.Message.fatal_error ("macro `"
                      + $(name : string) + "' expects following list of arguments: "
                      + $(types.ToString () : string)) ]>;
                    ([ <[ pattern: _ ]> ], [warn])
                  | _ =>
                    ([], [])
                };
              match (t) {
                | <[ type: array (parm) ]> =>
                  traverse_patterns (accs, defaults, [], 
                                     roll (acc, <[ pattern: $(va : var) ]>) :: initpat, 
                                     expr :: initex)

                | <[ type: array (expr) ]> =>
                  traverse_patterns (accs, defaults, [], 
                                     roll (acc, <[ pattern: $("_N_" + va : var) ]>) :: 
                                           initpat,
                                           <[ { def $(va : var) = 
                                             List.map (fun (p : Nemerle.Compiler.Parsetree.Parm) 
                                                         { p.expr }, 
                                                       $("_N_" + va : var));
                                             $expr } ]> :: initex)
                | _ =>
                  Message.fatal_error ("only array of expr or parm are supported in params")
              }
            // parameter with default value
            | FP_default (e) =>
              def (p, str) = normal_parm (t, va);
              analyze_params (xs, p :: acc, acc :: accs, (va, e) :: defaults, 
                              str.Append ("(opt)"))
          
            | FP_normal =>
              match (defaults) {
                | [] =>
                  def (p, str) = normal_parm (t, va);
                  analyze_params (xs, p :: acc, accs, defaults, str)
                | _ =>
                  Message.fatal_error ("parameters with default values must not"
                                       + " be mixed with normal")
              }
          }
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro parameters")
      }    
    };

    // creates match caces from pairs of pattern and expression
    def consolide_cases (pats, exps, acc) {
      match ((pats, exps)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => 
          consolide_cases (xs, ys, <[ case: $x => $y ]> :: acc)
        | _ => Util.ice ()
      }
    };

    // build method Run running macro's body
    def (macro_patts, macro_exprs) = 
      analyze_params (header.parms, [], [], [], System.Text.StringBuilder ());
    def macro_cases = List.rev (consolide_cases (macro_patts, macro_exprs, []));

    def mapparams (pars : list (Fun_parm), n, hash : Hashtable (string, int)) {
      match (pars) {
        | [] => hash
        | { name = SS_string (x) } :: xs => 
          if (hash.Contains (x)) 
            Message.fatal_error ("parameter names cannot repeat")
          else
            hash.Add (x, n); mapparams (xs, n + 1, hash)
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro params")
      }
    };
    def paramsmap = mapparams (header.parms, 0, Hashtable ());

    def analyze_syntax (toks, acc, positacc) {
      match (toks) {
        | [] => 
          match (List.rev (acc)) {
            | Parser.GE_keyword (key) :: rules =>
              def len = List.length (header.parms);
              def positions = List.rev (positacc);

              def permute (li) {
                def take_first (n, l, acc) {
                  match ((n, l)) {
                    | (0, _) => (List.rev (acc), l)
                    | (_, []) => Util.ice ("too few parameters")
                    | (n, x :: xs) =>
                      take_first (n - 1, xs, x :: acc)
                  }
                };
                def pararr = (System.Array.CreateInstance ((<[ parameter: () ]> : 
                              System.Object).GetType (), len) :> array (Parm));
                mutable m <- 0;
                def loop (l, ps) {
                  match ((l, ps)) {
                    | (x :: xs, [p]) =>
                      pararr[p] <- x;
                      loop (xs, [])
                    | (x :: xs, p :: pp) =>
                      if (p == len - 1) {
                        def (rtail, rfront) = take_first (len - m - 1, 
                                                          List.rev (xs), []);
                        pararr[p] <- x;
                        loop (List.append (List.rev (rtail), List.rev (rfront)), pp)
                      }
                      else {
                        pararr[p] <- x;
                        m <- m + 1;
                        loop (xs, pp)
                      }
                    | (xs, []) => List.append (List.from_array (pararr), xs)
                    | ([], _) => Util.ice ("too few parameters")
                  }
                };
                loop (li, positions)
              };
(*
              DEBUG for future... ;) ?
              mutable numbers <- [];
              for (mutable i <- List.length (positions); i >= 1; i <- i - 1)
                numbers <- Parm(<[ $(i : int) ]>) :: numbers;
              List.iter (fun (x : Parm) { def <[ $(y:int) ]> = x.expr; printf ("%d ", y); },
                         permute (numbers));
              printf ("\n");
              List.iter (fun (x) { printf ("%d ", x); }, positions);
              printf ("\n");

              printf ("registering macro %s %s %s\n", key, key, "_N_" + name + "_call");
*)
              def callname = "_N_" + name + "_call";
              ctx.keywords.Set (key, Parser.KeywordCallback (key, 
                Parser.make_parsing_function (callname, rules, permute)));
              callname
            | [] => name
            | _ => Message.fatal_error 
                     ("first token of syntax definition must be keyword")
          }
        | <[ $(x : string) ]> :: xs when Lexer.IsKeyword (x) =>
          Lexer.AddKeyword (x);
          analyze_syntax (xs, Parser.GE_keyword (x) :: acc, positacc)

        | <[ $(x : string) ]> :: xs when Lexer.IsOperator (x) =>
          analyze_syntax (xs, Parser.GE_operator (x) :: acc, positacc)

        | <[ $(x : var) ]> :: xs =>
          match (paramsmap.Get (x)) {
            | Some (pos) =>
              paramsmap.Remove (x);
              analyze_syntax (xs, Parser.GE_expression () :: acc, pos :: positacc)
            | None =>
              Message.fatal_error ("parameters from syntax description doesn't match macro's")
          }
        | _ => Message.fatal_error ("unsupported syntax token")
      }
    };
    def callname = analyze_syntax (synt, [], []);

    def run_header =
      Fun_header (header.loc, SS_string ("Run"), <[ type: Nemerle.Compiler.Parsetree.Expr ]>,
                  [Fun_parm (header.loc, SS_string ("_N_ctx"), 
                             <[ type: Nemerle.Compiler.Tyexpr.CTX ]>,
                             FP_normal ());
                   Fun_parm (header.loc, SS_string ("_N_parms"), 
                             <[ type: list (Nemerle.Compiler.Parsetree.Parm) ]>,
                             FP_normal ())]);

//    PrintExpr (<[ match (_N_parms) { ..$macro_cases } ]>, "");
//    printf("\n");
    def run_body = <[ match (_N_parms) { ..$macro_cases } ]>;

    def runFunc = M_function (header = run_header, 
                              name = "Run",
                              modifiers = [],
                              loc = header.loc,
                              kind = FK_method (["Nemerle.Compiler.IMacro.Run"]), 
                              body = FB_parsed_expr (run_body));

    // build GetName fuction for macro class
    def getnameFunc = 
      M_function (header = Fun_header (header.loc, SS_string ("GetName"), 
                                       <[ type: string ]>, []),
                  name = "GetName",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.GetName"]),
                  body = FB_parsed_expr (<[ $(callname : string) ]>));

    def thisFunc =
      M_function (header = Fun_header (header.loc, SS_string (".ctor"), <[ type: void ]>, []), 
                  name = ".ctor",
                  modifiers = [Mod_public ()],
                  loc = header.loc,
                  kind = FK_ctor (), 
                  body = FB_parsed_expr (<[ () ]>));

    def td = TD_class ([runFunc; thisFunc; getnameFunc]);
    td.modifiers <- Mod_macro () :: attrs;
    td.name <- "_N_" + name + "_class";
    td.t_implements <- [ <[ type: Nemerle.Compiler.IMacro ]> ];
    td.typarms <- Typarms ([],[]);
    td.t_extends <- None ();
    td
  }

  // PRETTY PRINTING TOOLS SECTION

  public PrintExpr (expr : Expr, empty : string) : void 
  {
    match (expr) {
      | <[ $(id : var) ]> => 
        printf ("%s", id)

      | <[ $obj . $(mem : var) ]> => 
        PrintExpr (obj, empty); printf (".%s", mem)

      | <[ [] ]> => printf ("[]")

      | <[ $x :: $xs ]> =>
        PrintExpr (x, empty);  printf (" :: "); PrintExpr (xs, empty)

      | <[ $func (.. $parms) ]> =>
        def print_params (pars) {
          def print_parm (p : Parm) {
            match (p) {
              | <[ parameter: $(name : var) = $expr ]> =>
                unless (name == "") printf ("%s = ", name);
                PrintExpr (expr, empty + "  ")
              | <[ parameter: ref $(name : var) = $expr ]> =>
                unless (name == "") printf ("%s = ", name);
                PrintExpr (expr, empty + "  ")
              | _ => Message.error ("spliced in PrintExpr")
            }
          };
          match (pars) {
            | [] => ()
            | [x] => print_parm (x)
            | x :: xs =>
              print_parm (x); printf (", "); print_params (xs)
          }
        };

        PrintExpr (func, empty); printf (" (");
        print_params (parms); printf (")");

      | <[ $target <- $source ]> =>
        PrintExpr (target, empty); printf (" <- ");
        PrintExpr (source, empty);

      | <[ def $(name : var) = $val ]> =>
        printf ("def %s = ", name);
        PrintExpr (val, empty)

      | <[ mutable $(name : var) <- $val ]> =>
        printf ("mutable %s = ", name); PrintExpr (val, empty)

      | <[ def (.. $elems) = $val ]> =>
        printf ("def ("); 
        List.iter (fun (x) { PrintPattern (x); printf ("; ") }, elems);
        printf (") = ");
        PrintExpr (val, empty);

      | <[ match ($expr) {.. $cases } ]> =>
        def print_case (c : Match_case) {
          def print_guard (g : Pattern * option (Expr)) {
            match (g) {
              | <[ caseguard: $pat when $e ]> =>
                printf ("\n%s| ", empty + "  ");
                PrintPattern (pat);
                printf (" when ");
                PrintExpr (e, empty + "    ")
              | <[ caseguard: $pat ]> =>
                printf ("\n%s| ", empty + "  "); 
                PrintPattern (pat);
            }
          };

          def <[ case: | ..$guards => $expr ]> = c;
          List.iter (print_guard, guards);
          printf (" => \n%s", empty + "    ");
          PrintExpr (expr, empty + "    ")
        };

        printf ("match ("); PrintExpr (expr, empty); printf (") {");
        List.iter (print_case, cases);
        printf ("\n%s}", empty)

      | <[ raise $exc ]> =>
        printf ("raise "); PrintExpr (exc, empty);

      | <[ try $body with { $(exn : var) : $exn_ty => $handler } ]> => 
        printf ("try\n%s  ", empty);
        PrintExpr (body, empty + "  ");
        printf ("\n%swith {\n%s", empty, empty + "  ");
        printf ("%s : ", exn);
        PrintType (exn_ty); printf ("=>\n%s", empty + "    ");
        PrintExpr (handler, empty + "    ")

      | <[ try $body finally $handler ]> =>
        printf ("try\n%s  ", empty);
        PrintExpr (body, empty + "  ");
        printf ("\n%sfinally\n%s  ", empty, empty);
        PrintExpr (handler, empty + "  ")

      | <[ () ]> => 
        printf ("()")

      | <[ null ]> => 
        printf ("null")

      | <[ $(val : int) ]> =>
        printf ("%d", val)

      | <[ $(val : string) ]> =>
        printf ("\"%s\"", val)

(*
      | <[ $(val : float) ]> =>
        printf ("%f", val)
*)

      | <[ $(val : bool) ]> =>
        if (val) printf ("true") else printf ("false")

      | <[ $(val : char) ]> =>
        printf ("%c", val);

      | <[ this ]> =>
        printf ("this")

      | <[ base ]> => 
        printf ("base")

      | <[ typeof ($t) ]> =>
        printf ("typeof ("); PrintType (t); printf (")")

      | <[ ( $expr :> $ty ) ]> =>
        printf ("("); PrintExpr (expr, empty); printf (" :> ");
        PrintType (ty); printf (")")

      | <[ ( $expr : $ty ) ]> =>
        printf ("("); PrintExpr (expr, empty); printf (" : ");
        PrintType (ty); printf (")")

      | <[ {.. $seq } ]> =>
        printf ("{");
        List.iter (fun (x) { printf ("\n%s", empty + "  "); 
                             PrintExpr (x, empty + "  "); 
                             printf (";"); }, seq);
        printf ("\n%s}", empty)

      | <[ (.. $args) ]> =>
        printf ("(");
        List.iter (fun (x) { printf (", "); PrintExpr (x, empty) }, args);
        printf (")")

      | <[ mkarray [.. $args] ]> =>
        printf ("mkarray [");
        List.iter (fun (x) { printf ("; "); PrintExpr (x, empty) }, args);
        printf ("]")

      | <[ $obj [.. $args] ]> =>
        PrintExpr (obj, empty);
        printf ("[");
        List.iter (fun (x) { printf ("; "); PrintExpr (x, empty) }, args);
        printf ("]")

//      | <[ 
      // FIXME: lambda, funs

      | _ => print_tree (expr, empty)
    }
  }

  public PrintPattern (patt : Pattern) : void
  {
    match (patt) {
      | <[ pattern: _ ]> =>
        printf ("_")

      | <[ pattern: $(name : var) ]> =>
        printf ("%s", name)

      | <[ pattern: ($pat) as $(name : var) ]> => 
        printf ("("); PrintPattern (pat); 
        printf (") as %s", name)

      | <[ pattern: [] ]> => printf ("[]")

      | <[ pattern: $x :: $xs ]> => 
        PrintPattern (x); printf (" :: "); PrintPattern (xs)

      | <[ pattern: (.. $args) ]> =>
        printf ("(");
        List.iter (fun (x) { PrintPattern (x); printf (", ") }, args);
        printf (")")

      | <[ pattern: {.. $args } ]> =>
        def print_named_pattern (patt : string * Pattern) : void
          {
            def (name, pat) = patt;
            printf ("%s = ", name); PrintPattern (pat);
            printf ("; ")
          };
        printf ("{");
        List.iter (print_named_pattern, args);
        printf ("}")

      | <[ pattern: $(name : var) (.. []) ]> =>
        printf ("%s", name)

      | <[ pattern: $(name : var) (.. $args) ]> =>
        printf ("%s (", name);
        List.iter (fun (x) { PrintPattern (x); printf (", ") }, args);

      | <[ pattern: $(name : var) {.. $args} ]> =>
        printf ("%s {", name);
        def print_named_pattern (patt : string * Pattern) : void
          {
            def (name, pat) = patt;
            printf ("%s = ", name); PrintPattern (pat);
            printf ("; ")
          };
        List.iter (print_named_pattern, args);
        printf ("}")

      | <[ pattern: $(val : int) ]> =>
        printf ("%d", val)

      | <[ pattern: $(val : string) ]> =>
        printf ("\"%s\"", val)

      | <[ pattern: $(val : bool) ]> =>
        if (val) printf ("true") else printf ("false")

(*
      | <[ pattern: $(val : float) ]> =>
        printf ("%f", val)
*)

      | <[ pattern: $(val : char) ]> =>
        printf ("%c", val)

      | <[ pattern: () ]> =>
        printf ("()")

      | <[ pattern: null ]> =>
        printf ("null")

      | <[ pattern: $(name : var) _ ]> =>
        printf ("%s", name)

      | _ => printf ("other")
    }
  }

  public PrintType (ty : Type) : void 
  {
    match (ty) {
      | <[ type: $(tycon : var) (.. $args) ]> =>
        printf ("%s", tycon);
        def loop (l) {
          match (l) {
            | [x] => PrintType (x)
            | x::xs => PrintType (x); printf (" * "); loop (xs)
            | [] => Util.ice()
          }
        };
        match (args) {
          | [] => ()
          | _ => printf (" ("); loop (args); printf (")");
        }

      | <[ type: $(name : var) ]> =>
        printf ("%s", name);

      | <[ type: ref $ty ]> =>
        printf ("ref "); PrintType (ty);

      | <[ type: out $ty ]> =>
        printf ("out "); PrintType (ty);

      | <[ type: $from -> $to ]> =>
        PrintType (from); printf (" -> "); PrintType (to);

      | <[ type: void ]> =>
        printf ("void");

      | <[ type: .. $args ]> =>
        List.iter (fun (x) { PrintType (x); printf (" * ") }, args)

      | <[ type: array ($ty) ]> =>
        printf ("array ("); PrintType (ty); printf (")")

      | _ => printf ("other")
    }
  }

  // DEBUG SECTION

  public print_tree (exp : Expr, empty : string) : void
    {
      def convert_params (pars : list (Parm)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_tree (x.expr, empty + "  "); convert_params (xs )
        }
      };

      print_string (empty);

      def print_literal (lit : Literal ) : void
        {
	  match (lit) {
	    | L_string (s) => print_string (s)
            | L_int (i) => print_string (string_of_int (i))
	    | _ => print_string ("some literal")
          }
        };

      match (exp) {
        | E_ref (id) => print_string ("E_ref ("); print_string (id); print_endline (")")
        | E_call (E_ref (constr), parms) => 
          print_string ("E_call (E_ref ("); print_string (constr); print_endline ("),");
          convert_params (parms);
          print_string (empty);
	  print_endline (")")
        | E_call (constr, parms) => 
          printf("E_call (\n"); print_tree(constr, empty + "  "); convert_params(parms);
          printf("%s)\n", empty)
        | E_literal (lit) => print_string ("E_literal ("); print_literal (lit); print_endline (")")
	| E_sequence (seq) =>
	  print_endline("E_sequence ("); 
	  def pr (e : Expr ) : void { print_tree (e, empty + "  "); };
	  List.iter (pr, seq);
	  print_endline(empty + ")")

	| E_tuple (_) =>
	  print_endline ("tuple")
        | E_member (o, SS_string (x)) =>
          printf("E_member (\n"); print_tree (o, empty + "  ");
	  print_endline (empty + "  " + x + ")");
        | E_member (o, _) =>
	  print_endline ("member spliced");
          print_tree (o, empty)
    	| E_assign => 
	  print_endline ("assign ")
    	| E_let  => 
	  print_endline ("let ")
    	| E_letpat  => 
	  print_endline ("letpat ")
    	| E_letfun => 
	  print_endline ("letfun ")
    	| E_lambda => 
	  print_endline ("lambda ")
    	| E_match  => 
	  print_endline ("match ")
    	| E_raise  => 
	  print_endline ("raise ")
    	| E_try_with => 
	  print_endline ("Bad constructed quoted expression in print - try_with ")
    	| E_try_finally => 
	  print_endline ("Bad constructed quoted expression in print - try_finally ")
    	| E_this => 
	  print_endline ("Bad constructed quoted expression in print - this ")
    	| E_typeof => 
	  print_endline ("Bad constructed quoted expression in print - typeof ")
    	| E_type_conversion => 
	  print_endline ("Bad constructed quoted expression in print - type_conversion ")
    	| E_type_enforcement => 
	  print_endline ("Bad constructed quoted expression in print - type_enforc ")
    	| E_quoted => 
	  print_endline ("Bad constructed quoted expression in print - quoted ")
    	| E_spliced => 
	  print_endline ("Bad constructed quoted expression in print - spliced ")
    	| E_mkarray => 
	  print_endline ("Bad constructed quoted expression in print - mkarray ")
    	| E_indexer => 
	  print_endline ("Bad constructed quoted expression in print - indexer ")
    	| E_base => 
	  print_endline ("Bad constructed quoted expression in print - base ")
    	| E_spliced_patt => 
	  print_endline ("Bad constructed quoted expression in print - spliced_patt ")
    	| E_expr_list => 
	  print_endline ("Bad constructed quoted expression in print - expr_list ")
    	| E_spliced_special => 
	  print_endline ("spliced_special ")
        | _ =>
         print_endline ("other")
      }
    }

  public print_pattern (pat : Pattern, empty : string) : void
    {
      def convert_params (pars : list (Pattern)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_pattern (x, empty + "  "); convert_params (xs)
        }
      };

      def print_args (args : list (string * Pattern)) : void {
	match (args) {
	  | [] => ()
	  | x::xs => 
            def (name, pat) = x;
            print_string (empty + "  "); print_string (name); print_endline(" = "); 
            print_pattern (pat, empty + "    "); print_args (xs)
 	}  
      };

      print_string (empty);

      match (pat) {
        | P_cons (SS_string (id), arg) => print_string ("P_cons ("); print_string (id); 
          print_endline (","); print_pattern (arg, empty + "  "); print_string (empty); 
          print_endline (")")
        | P_underscore => print_endline ("P_under")
        | P_record (args) => 
	   print_endline ("P_record (");
	   print_args (args); print_string (empty); print_endline (")")
        | P_tuple (args) => print_endline ("P_tuple ("); convert_params (args); 
            print_string (empty); print_endline (")")
        | _ => 
	   print_endline ("other")
      }
    }

}
} // end ns
