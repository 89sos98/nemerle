open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;
namespace TT = Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {
(*
  Also setup local environment for each expression and populate it
  with local values.
*)

  class Tyexpr
    {
      fun run(decls : list (Type_decl)) : void =

        letfun ty_expr(env : Env, expr : PT.Expr) : TT.Expr =
          let ret = Util.locate (expr#loc, fun () : TT.Expr =>
            letfun self (e : PT.Expr) : TT.Expr = ty_expr (env, e) in
            match expr with [
              | PT.E_letfun (?fs, ?b) =>
                letfun add_fun (env : Env, d : PT.Function_decl) : Env =
                  let (?env', _) =
                    env#add_local(d#fun_header#name, D_local_fun(), 
                                  Tyutil.fun_type (d#fun_header)) 
                  in env'
                in
                let env' = List.fold_left(add_fun, env, fs) in
                letfun do_fun (d : PT.Function_decl) : TT.Function_decl =
                  let body' = do_function_expr (env', d#fun_header, d#body) in
                  TT.Function_decl (body = body', fun_header = d#fun_header)
                in
                let fs' = List.map (do_fun, fs) in
                let b' = ty_expr(env', b) in
                TT.E_letfun (fs', b')
                  
              | PT.E_lambda (?d) =>
                let body' = do_function_expr (env, d#fun_header, d#body) in
                TT.E_lambda (TT.Function_decl (body = body', fun_header = d#fun_header))
                  
              | PT.E_try_with ?x =>
                let b = ty_expr(env, x#body) in
                let (?env', ?decl) = env#add_local(x#exn, D_exn(), x#exn_ty) in
                let h = ty_expr(env', x#handler) in
                TT.E_try_with (b, decl, h)

              | PT.E_try_finally (?e1, ?e2) =>
                TT.E_try_finally (ty_expr (env, e1), ty_expr (env, e2))

              | PT.E_let ?x =>
                let val = ty_expr(env, x#val) in
                let (?env', ?decl) = env#add_local(x#name, D_local_value(x#is_ref)) in
                let body = ty_expr(env', x#body) in
                TT.E_let (decl, val, body)

              | PT.E_type_conversion (?e, ?t) =>
                TT.E_type_conversion (ty_expr (env, e), t)
                
              | PT.E_type_enforcement (?e, ?t) => 
                TT.E_type_enforcement (ty_expr (env, e), t)

              | PT.E_ref (?n) =>
                match env#bare_lookup (n) with [
                  | Nil =>
                    {
                      Message.error ("unbound symbol `" + n + "'");
                      raise Recovery ()
                    }
                  | Cons (?x, _) =>
                    // FIXME
                    TT.E_ref (x)
                ]

              | PT.E_member (?o, ?fld) =>
                // FIXME
                TT.E_field_ref (ty_expr (env, o), null)

              | PT.E_call (?fnc, ?parms) =>
                letfun fp (p : PT.Parm) : TT.Parm =
                  let ex = ty_expr (env, p#expr) in
                  TT.Parm (p#is_ref, ex, p#name)
                in TT.E_call (ty_expr (env, fnc), List.map (fp, parms))

              | PT.E_assign (?e1, ?e2) =>
                TT.E_assign (ty_expr (env, e1), ty_expr (env, e2))

              | PT.E_raise (?e) =>
                TT.E_raise (ty_expr (env, e))

              | PT.E_if (?e1, ?e2, ?e3) =>
                TT.E_if (ty_expr (env, e1), ty_expr (env, e2), ty_expr (env, e3))

              | PT.E_literal (?l) => TT.E_literal (l)

              | PT.E_this => TT.E_this ()

              | PT.E_sequence (?l) =>
                TT.E_sequence (List.map (self, l))

              | PT.E_tuple (?l) =>
                TT.E_tuple (List.map (self, l))

              | PT.E_match (?ex, ?mcs) =>
                letfun do_case (c : PT.Match_case) : TT.Match_case =
                  let ref pat_env = env in
                  letfun f (p : PT.Pattern) : TT.Pattern =
                    match p with [
                      | PT.P_variable (?n) =>
                        // FIXME: report error for duplicate variables
                        let (?env', ?decl) = pat_env#add_local(n, D_pattern_variable()) in
                        let _ = pat_env <- env' in
                        TT.P_variable (decl)
                      | PT.P_underscore => TT.P_underscore ()
                      | PT.P_tuple (?l) => TT.P_tuple (List.map (f, l))
                      | PT.P_record (?l) =>
                        letfun fn (np : PT.Named_pattern) : TT.Named_pattern =
                          TT.Named_pattern (name = np#name, pat = f (np#pat))
                        in TT.P_record (List.map (fn, l))
                      | PT.P_cons (?n, ?p) =>
                        match pat_env#lookup_type (n) with [
                          | TD_variant_option ?o =>
                            TT.P_cons (o, f (p))
                          | _ =>
                            {
                              Message.error ("`" + n + "' isn't variant case");
                              TT.P_underscore ()
                            }
                        ]
                    ]
                  in
                  Util.locate (c#loc, fun () : TT.Match_case =>
                    let pat = f (c#pattern) in
                    let body = ty_expr (pat_env, c#body) in
                    TT.Match_case (c#loc, pat, body))
                in  
                let ex' = ty_expr (env, ex) in
                let mcs' = List.map (do_case, mcs) in
                TT.E_match (ex', mcs')
            ])
          in {
            ret#loc <- expr#loc;
            ret
          }

        and do_function(env : Env, h : Fun_header, b : Fun_body) : Fun_body =
          letfun add_parm (env : Env, p : Fun_parm) : Env =
            Util.locate(p#loc, fun () : Env => 
                                  let (?env, ?d) = env#add_local(p#name, D_fun_parm(), p#ty) in
                                  let _ = p#decl <- d in env)
          in
          let env' = List.fold_left(add_parm, env, h#parms) in
          match b with [
            | FB_expr (?e) => FB_typed_expr (ty_expr(env', e))
            | FB_typed_expr => Util.ice ()
            | FB_extern => b
          ]
          
        and do_function_expr(env : Env, h : Fun_header, b : PT.Expr) : TT.Expr =
          match do_function (env, h, FB_expr (b)) with [
            | FB_typed_expr (?e) => e
            | _ => Util.ice ()
          ]
        
        and do_tydecl(_ : int, _ : Type_decl) : int = 0
        and do_decl(_ : int, decl : Class_member) : void =
          match decl with [
            | M_function ?f =>
              f#body <- do_function (decl#env, f#fun_header, f#body)
            | _ => ()
          ]
        in 
        Treeutil.decl_walk(do_tydecl, do_decl, 0, decls);
    }
  
} // end ns
