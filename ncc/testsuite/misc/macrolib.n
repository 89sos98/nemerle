
using Nemerle.Collections;
using Nemerle.Compiler;
using System;

macro forp (i, n : int, m : int, body)
syntax ("forpermutation", "(", i, "in", n, "to", m, ")", body)
{
  def a = array (m - n + 1);
  for (mutable j <- 0; j < m - n + 1; j <- j + 1)
    a[j] <- j + n;
  mutable p <- [];
  def r = System.Random ();
  for (mutable k <- m - n; k >= 0; k <- k - 1) {
    def rand = r.Next (k + 1);
    p <- <[ $(a[rand] : int) ]> :: p;
    a[rand] <-> a[k];
  };
  <[
    def p = array [..$p];
    for (mutable j <- 0; j < $(m - n + 1 : int); j <- j + 1) {
      $i <- p[j];
      $body
    }
  ]>
}

namespace A {
  macro gg (a)
  syntax ("ggg", a) { a }
}

macro ala()
{
  def c = Nemerle.Macros.ImplicitCTX ().env.DefineClass(NemerleAttributes.Public,
                                                        ["haha"], []);
  c.DefineMember(<[ field: x : int; ]>);
  c.DefineMember(<[ method: public this(){}]>);
  <[ Console.WriteLine ("proba") ]>;
}

public interface ISerializable {
  Serialize () : void;
}

postscan macro Serializable (t : TypeDecl)
{
  t.AddImplementedInterface (<[ type: ISerializable ]>)
}

postadd macro Serializable (t : TypeDecl)
{
  /// here we list its fields and choose only those, which are not derived
  /// or static
  def fields = t.GetFields (BindingFlags.Instance %| BindingFlags.Public %|
                            BindingFlags.NonPublic %| BindingFlags.DeclaredOnly);

  /// now create list of expressions which will print object's data  
  mutable serializers <- [];

  /// traverse through fields, taking their type constructors  
  foreach (x : IField in fields) {
    def tc = Tyutil.GetTypeTycon (x.GetMemType ());
    def nm = Macros.UseSiteSymbol (x.Name);
    if (tc != null)
      if (tc.IsValueType ())
        /// we can safely printf value types as strings        
        serializers <- <[
                         Nemerle.IO.printf ("<%s>", $(x.Name : string));
                         System.Console.Write ($(nm : name));
                         Nemerle.IO.printf ("</%s>\n", $(x.Name : string));
                       ]>
                       :: serializers
      else
        /// we can try to check, if type of given field also implements ISerializable
        if (Tyutil.subtypes (x.GetMemType (), <[ ttype: ISerializable ]>))
          serializers <- <[
                           Nemerle.IO.printf ("<%s>\n", $(x.Name : string));      
                           if ($(nm : name) != null)
                             $(nm : name).Serialize ()
                           else
                             Nemerle.IO.printf ("<null/>\n");
                           Nemerle.IO.printf ("</%s>\n", $(x.Name : string));
                         ]>
                         :: serializers
        else
          /// and finally, we encounter case when there is no easy way to serialize 
          /// given field
          Message.fatal_error ("field `" + x.Name + "' cannot be serialized")
    else
      Message.fatal_error ("field `" + x.Name + "' cannot be serialized")
  };
  // after analyzing fields, we create method in our type, to execute created
  // expressions
  t.DefineMember (<[ method: public Serialize () : void
                             implements ISerializable.Serialize {
                               .. $serializers
                             }
                  ]>)
}
