(*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Compiler;
  open Nemerle.Compiler.Tyops;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Collections;
  
  open System.Reflection;
  open System.Reflection.Emit;

  (**
   * An IL code generator
   *)
  public class CGIL
  {
    (* -- PUBLIC CONSTRUCTORS ---------------------------------------------- *)
    
    (** 
     * Outputs objects from cgtree.n as IL code. 
     *)
    public this (decls : list (CM_class))
    {
      (* create a weak assembly name and define a dynamic assembly *)
      this._assembly_name <- AssemblyName ();
      this._assembly_name.Version <- System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name <- "CGILTest"; // FIXME

      this._assembly_builder <- 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      (* create a dynamic module *)
      this._module_builder <- this._assembly_builder.DefineDynamicModule ("CGILTest", "cgil-test.dll");      

      (* iterate the top declarations, adding them to the newly created assembly *)
      def emit_decl (decl : CM_class) : void {
        this.process_top_level_declaration (decl)
      };
      List.iter (emit_decl, decls);
      
      (* save the assembly *)
      this._assembly_builder.Save ("cgil-test.dll"); // FIXME
    }


    (* -- PRIVATE METHODS -------------------------------------------------- *)
    
    (**
     * Outputs a top level class
     *)
    private process_top_level_declaration (decl : CM_class) : void
    {
      Message.debug ("processing class " + decl.ns + decl.name);

      def attrs = TypeAttributes.Class + TypeAttributes.Public;

      def tb = this._module_builder.DefineType (decl.ns + decl.name, attrs);
      
      this.flat_member (decl, tb);
      
      ()
    }

    (**
     * Builds a Nemerle type attribute
     *)
     (*
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = typeof ("Nemerle.TypeAttribute");
      def constructor_param_types = mkarray [typeof ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, constructor_params);
      attr_builder    
      null
    }

    private nemerle_to_framework_type (ty : Type) : System.Type
    {
      typeof ("System.Object") // FIXME
    }
    
    private nemerle_field_to_framework_attrs (attrs : list (Modifier)) : FieldAttributes
    {
      FieldAttributes.Private // FIXME
    }
    *)

    (**
     * Outputs a type member
     *)  
    flat_member (m : CG_member, tb : TypeBuilder) : void 
    {
      match (m) {
        | (CM_class) as m => ()

(*        
          def variant_attribute =
            match (m.kind) {          
              | CK_variant => "[Nemerle.VariantAttribute()]\n"
              | CK_variant_option (encoded_type) => 
                "[Nemerle.VariantOptionAttribute(\"" + encoded_type + "\")]\n"
              | _ => ""
            };
          def k = 
            match (m.kind) { 
              | CK_class => "class" 
              | CK_struct => "struct" 
              | CK_interface => "interface"
              | CK_variant => "class"
              | CK_variant_option (_) => "class"
            };
          def inh =
            match (m.inheritance) {
              | [] => ST_leaf ("")
              | _ => " : " ++ st_concat (", ", List.map (flat_ty, m.inheritance))
            };
          print_st (ST_leaf (variant_attribute) ++ s_concat (" ", m.attrs) ++ " " ++ k ++ 
                    " " ++ m.name ++ inh ++ " {\n");
          List.iter (flat_member, m.decls);
          print_st (ST_leaf ("} // end of ") ++ k ++ " " ++ m.name ++ "\n")
*)

      | (CM_field) as m =>
        Message.debug ("emitting field " + m.name);
        (*
        def fb = tb.DefineField (m.name, 
                                 this.nemerle_to_framework_type (m.ty), 
                                 this.nemerle_field_to_framework_attrs (m.attrs));
        fb.SetCustomAttribute (this.make_nemerle_type_attr (m.encoded_type));
        *)

(*      
        print_st (emit_nemerle_type_attr (m.encoded_type) ++ s_concat (" ", m.attrs) ++ " " ++ flat_ty (m.ty) ++ 
                  " " ++ m.name ++ ";\n")
*)  
                   
      | (CM_property) as p =>
        Message.fatal_error ("emitting properties is not supported yet")
                          
      | (CM_method) as m => ()

(*      
        CGopt.tail_call_optimize (m);
        def mkparm (v : CG_val) : String_tree {
          flat_ty (v.ty) ++ " " ++ v.name
        };
        def rett = 
          match (m.ret_type) {
            | CT_unreached => ST_leaf ("")
            | _ => flat_ty (m.ret_type)
          };

        print_st (emit_nemerle_type_attr (m.encoded_type) ++ s_concat (" ", m.attrs) ++ " " ++ rett ++ "\n" ++ 
                  m.name ++ "(" ++ st_concat (", ", List.map (mkparm, m.parms)) ++ ")");

        match (m.body) {
          | CE_none => print_st (ST_leaf (";\n"))
          | _ =>
            def (pref, r) = make_complex (flat (m.body));
            def ret =
              if (is_dummy_type (m.ret_type))
                side_effect_run (r)
              else
                if (is_dummy_type (type_of (m.body)))
                  side_effect_run (r) ++ "return null;\n"
                else
                  "return " ++ r ++ ";\n";
                   
            when (base_class_ctor != null) {
              print_st (" : " ++ base_class_ctor ++ "\n");
              base_class_ctor <- null
            };
           
            print_st ("\n{\n" ++ pref ++ ret ++ "} // end of fun " ++ m.name ++ "\n")
        }
*)      
      }
    }


    (* -- PRIVATE FIELDS --------------------------------------------------- *)

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : System.Reflection.Emit.AssemblyBuilder;
    private mutable _module_builder : System.Reflection.Emit.ModuleBuilder;
    
  } (* end of the module *)
  
} (* end of the namespace *)
