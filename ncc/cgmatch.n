/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Matching
 */
namespace Nemerle.Compiler 
{
  using Nemerle.Collections;

  using Nemerle.Compiler;
  using Nemerle.Compiler.CGexpr;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;

  using System.Reflection;
  using System.Reflection.Emit;


  /**
   * Description of a match pattern:
   *
   * | [pattern] when [guard] => [effect]
   *
   * Additionally, we hold an ordered list of guards that 
   * could possibly override this match.
   */
  internal class MatchPattern
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, pattern : Pattern, 
                 guard : int, effect : int, guard_is_always_true : bool,
                 as_pattern_val : option (CG_val))
    {
      this.guard_is_always_true <- guard_is_always_true;
      this.match_descriptor <- match_descriptor;
      this.as_pattern_val <- as_pattern_val;
      this.pattern <- pattern;
      this.guard <- guard;
      this.effect <- effect;
      overriden_by <- [];
    }
    

    /* -- PUBLIC METHODS --------------------------------------------------- */
    
    public PossiblyOverrides (match_pattern : MatchPattern) : bool
    {
      compare_patterns (pattern, match_pattern.pattern)
    }
        
    public AlwaysOverrides (match_pattern : MatchPattern) : bool
    {
      PossiblyOverrides (match_pattern) && guard_is_always_true
    }
    
    public AddOverridingPattern (match_pattern : MatchPattern) : void
    {
      overriden_by <- match_pattern :: overriden_by
    }
    
    public ReverseOverridingList () : void
    {
      overriden_by <- List.Rev (overriden_by)
    }
    
    public NeedExtraMatchChecks () : bool
    {
      !guard_is_always_true || List.Length (overriden_by) != 0
    }

    public GetEffectIndex () : int
    {
      effect
    }

    public GetPattern () : Pattern
    {
      pattern
    }

    public GetOverridingPatterns () : list (MatchPattern)
    {
      overriden_by
    }    
    
    public SetOverridingPatterns (overriden_by : list (MatchPattern)) : void
    {
      this.overriden_by <- overriden_by
    }
        
    public GetLocation () : Location
    {
      pattern.loc
    }
    
    public IsUnderscore () : bool
    {
      match (pattern) {
        | P_underscore => true
        | P_as (P_underscore, _) => true
        | _ => false
      }
    }

    public MakeGuardExpr (continuation : option (CG_expr)) : CG_expr
    {
      match (match_descriptor.GetGuard (guard)) {
        | Some (guard) => 
          assert (Option.IsSome (continuation), "need to have a continuation if guards can fail");
          
          CE_if (match_descriptor.GetResultType (), guard,
                match_descriptor.GetEffect (effect), Option.UnSome (continuation))              
        | None => 
          match_descriptor.GetEffect (effect)
      }    
    }


    /**
     * Comparison function that can be used by the List.Sort function
     */
    public static Compare (l : MatchPattern, r : MatchPattern) : int
    {
      def get_literal (pattern : MatchPattern) : int {        
        match (pattern.GetPattern ()) {
          | P_literal (L_int (literal)) => literal
          | P_literal (L_char (literal)) => (literal :> int)
          | P_as (P_literal (L_int (literal)), _) => literal
          | P_as (P_literal (L_char (literal)), _) => (literal :> int)
          | _ => Util.ice ("invalid pattern type")
        }
      };
      
      get_literal (r) - get_literal (l)
    }


    public MakeMatchExpr (compare_to : CG_expr, continuation : CG_expr) : CG_expr
    {
      match (pattern) {
        | P_literal (literal) =>
          def eq_expr = 
            CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                    [compare_to, CE_literal (literal)]);

          def guard_expr =
            match (match_descriptor.GetGuard (guard)) {
              | Some (guard) => 
                CE_if (match_descriptor.GetResultType (), guard, 
                       match_descriptor.GetEffect (effect), continuation)
              | None =>
                match_descriptor.GetEffect (effect)
            };

          def overriding_expr =
            collect_overriding_patterns (overriden_by, guard_expr);
            
          CE_if (match_descriptor.GetResultType (), eq_expr, overriding_expr, continuation)

        | P_underscore =>
          def guard_expr =
            match (match_descriptor.GetGuard (guard)) {
              | Some (guard) => 
                CE_if (match_descriptor.GetResultType (), guard,
                       match_descriptor.GetEffect (effect), continuation)              
              | None => 
                match_descriptor.GetEffect (effect)
            };

          collect_overriding_patterns (overriden_by, guard_expr)
              
        | P_as (subpattern, _) =>
          def subpattern = 
            MatchPattern (match_descriptor, subpattern, guard, 
                          effect, true, None ());
  
          subpattern.SetOverridingPatterns (GetOverridingPatterns ());
          
          CE_let (Option.UnSome (as_pattern_val), 
                  subpattern.MakeMatchExpr (compare_to, continuation))
          
          /*
          match (subpat) {
            | P_cons =>
              match (cgpat (val, subpat)) {
                | (CE_if (c, e_then, e_else)) as e =>
                  CE_if (e.ty, c, CE_sequence ([ass; e_then]), e_else)
                | _ => Util.ice ()
              }
            | _ =>
              CE_sequence ([ass; cgpat (val, subpat)])
          }
          */
          
        | _ => 
          Util.ice ("pattern type not supported in MakeMatchExpr")
      }
    }
    
    
    public MakeLessThanCondition (compare_to : CG_expr) : CG_expr
    {
      match (pattern) {
        | P_literal (L_string) =>
          Util.ice ("constant string patterns not supported in MakeLessThanCondition")
        | P_literal (L_bool) =>
          Util.ice ("constant boolean patterns not supported in MakeLessThanCondition")
        | P_literal (literal) =>
          CE_call (typeof (System.Boolean), CE_opcode ("<"), [compare_to, CE_literal (literal)])
        | _ => 
          Util.ice ("non-literal patterns not supported in MakeLessThanCondition")
      }    
    }

    public Dump () : void
    {
      def message =
        match (pattern) {
          | P_literal (L_string (literal)) => "P_literal L_string '" + literal + "'"
          | P_literal (L_int (literal)) => "P_literal L_int " + literal.ToString ()
          | P_literal (L_char (literal)) => "P_literal L_char " + 
            (literal :> int).ToString ()
          | P_underscore => "P_underscore"
          | P_as (P_underscore, _) => "P_as/P_underscore"
          | _ => "other"
        };
        
      Message.debug (message)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    private collect_overriding_patterns (overriden_by : list (MatchPattern), 
                                         continuation : CG_expr) : CG_expr
    {
      match (overriden_by) {
        | [] => continuation
        | pattern :: rest =>
          // Message.debug (pattern.GetLocation (), "this pattern is sometimes overriding");
          def continuation = pattern.MakeGuardExpr (Some (continuation));
          collect_overriding_patterns (rest, continuation)
      }
    }
    
    
    private compare_literals (l : Literal, r : Literal) : bool
    {
      match ((l, r)) {
        | (L_null, L_null) => true
        | (L_int (l), L_int (r)) => l == r
        | (L_string (l), L_string (r)) => l == r
        | (L_float (l), L_float (r)) => l == r
        | (L_char (l), L_char (r)) => l == r
        | (L_bool (l), L_bool (r)) => l == r
        | _ => false
      }
    } 
    
    private compare_tuples (l : list (Pattern), r : list (Pattern)) : bool
    {
      def walk_tuples (l : list (Pattern), r : list (Pattern)) : bool {
        match ((l, r)) {
          | ([], []) => true
          | (l :: ls, r :: rs) => 
            if (compare_patterns (l, r)) walk_tuples (ls, rs) else false
          | _ => false
        }
      };
      
      walk_tuples (l, r)
    }
    
    private compare_records (l : list (IField * Pattern), r : list (IField * Pattern)) : bool
    {
      // FIXME
      List.Length (l) != List.Length (r)
    }
    
    private compare_conses (_ln : Tycon, _la : Pattern, _rn : Tycon, _ra : Pattern) : bool
    {
      // FIXME
      false
    }
    
    private compare_patterns (l : Pattern, r : Pattern) : bool
    {
      match ((l, r)) {
        | (P_underscore, _) => true
        | (P_as (P_underscore, _), _) => true
        | (P_literal (l), P_literal (r)) => compare_literals (l, r)      
        | (P_tuple (l), P_tuple (r)) => compare_tuples (l, r)
        | (P_record (l), P_record (r)) => compare_records (l, r)
        | (P_cons (ln, la), P_cons (rn, ra)) => compare_conses (ln, la, rn, ra)       
        | _ => false
      }
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable pattern : Pattern;
    private mutable guard : int;
    private mutable effect : int;
    private mutable as_pattern_val : option (CG_val);
    private mutable overriden_by : list (MatchPattern);
    private mutable guard_is_always_true : bool;
  }


  /**
   * Search for a matching pattern is optimized within
   * pattern blocks only.
   */
  internal class MatchBlock
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (patterns : list (MatchPattern))
    {
      this.patterns <- patterns;
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public RemoveOverridenPatterns () : void
    {
      def walk_patterns (patterns : list (MatchPattern)) : list (MatchPattern) {
        match (patterns) {
          | [] => []
          | head :: tail =>
            def overrides (pattern : MatchPattern) : bool {
              if (head.AlwaysOverrides (pattern)) {
                Message.warning (head.GetLocation (), "this pattern overrides pattern:");
                Message.warning (pattern.GetLocation (), "pattern is redundant");
                false
              }
              else true              
            };
            head :: walk_patterns (List.Filter (overrides, tail))
        }
      };
      
      patterns <- walk_patterns (patterns)
    }


    public DecidePatternOverriding () : void
    {
      mutable current_pattern_can_be_skipped <- false;
      
      def decide_pattern_overriding (head : MatchPattern, 
                           patterns : list (MatchPattern)) : list (MatchPattern)
      {        
        match (patterns) {
          | pattern :: rest =>
            // Message.debug (pattern.GetLocation (), "comparing to this pattern");
            if (head.PossiblyOverrides (pattern)) {
              // add overriding information for possibly hidden patterns
              pattern.AddOverridingPattern (head);
              unless (head.IsUnderscore ()) current_pattern_can_be_skipped <- true;
              pattern :: decide_pattern_overriding (head, rest)
            }
            else {
              // leave the rest as is
              pattern :: decide_pattern_overriding (head, rest)
            }
          | [] => []
        }
      };  
      
      def walk_patterns (patterns : list (MatchPattern)) : list (MatchPattern) {
        match (patterns) {
          | pattern :: rest =>
            current_pattern_can_be_skipped <- false;
            // Message.debug (pattern.GetLocation (), "deciding overriding for this pattern");
            def rest = decide_pattern_overriding (pattern, rest);
            pattern.ReverseOverridingList ();
            if (!current_pattern_can_be_skipped) {
              // Message.debug (pattern.GetLocation (), "keeping this pattern");
              pattern :: walk_patterns (rest)
            }
            else {
              // Message.debug (pattern.GetLocation (), "skipping this pattern");
              walk_patterns (rest)
            }
          | [] => []
        }
      };
      
      patterns <- walk_patterns (patterns)
    }

    public GetMatchPatterns () : list (MatchPattern) 
    {
      patterns
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable patterns : list (MatchPattern);
  }


  /**
   * A match construct consists of a number of blocks, 
   * guards and effects.
   */
  internal class MatchDescriptor
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    /**
     * Initializes the match descriptor. 
     * Builds the initial patterns block.
     */    
    internal this (context : CTX, result_type : System.Type, 
                   matched_expr : CG_expr, match_cases : list (Match_case))
    {
      vals <- New.SystemMap ();
      guards <- New.SystemMap ();
      effects <- New.SystemMap ();
            
      current_guard <- -1;
      current_effect <- -1;
      
      this.context <- context;
      this.result_type <- result_type;
      this.matched_expr <- matched_expr;

      matched_expr_type <- type_of (matched_expr);
      match_over_value_type <- matched_expr_type.IsValueType;
      
      build_first_block (match_cases)
    }

    
    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetResultType () : System.Type
    {
      result_type
    }
    
    public DecidePatternOverriding () : void
    {
      def decide_pattern_overriding (block : MatchBlock) : void {
        block.DecidePatternOverriding ()
      };
      
      List.Iter (decide_pattern_overriding, blocks)
    }

    public GetMatchBlocks () : list (MatchBlock) 
    {
      blocks
    }

    public GetMatchedExpr () : CG_expr
    {
      matched_expr
    }

    public GetEffect (index : int) : CG_expr
    {
      effects.Get (index)
    }

    public GetGuard (index : int) : option (CG_expr)
    {
      if (index == -1) None () else guards.Get (index)
    }

    public MakeAsPatternAssignment (decl : LocalValue) : CG_expr * CG_val
    {      
      mutable as_pattern_val <- null;
      
      unless (decl.in_closure) {
        match (vals.Find (decl.id)) {
          | Some (val) =>
            as_pattern_val <- val
          | None =>
            def (context, val) = store_local (context, decl, CE_none ());
            this.context <- context;
            as_pattern_val <- val;
            vals <- vals.Add (decl.id, val);
        }
      };
      
      def assign_expr =
        CE_assign (local_ref (context, decl), 
                   maybe_cast (context, cg_type (context, decl.ty), 
                               matched_expr));
                               
      (assign_expr, as_pattern_val)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    /**
     * Builds the first block of patterns. This block will have to be either
     * split or the overriding guards information will have to be updated.
     */
    private build_first_block (match_cases : list (Match_case)) : void
    {
      mutable patterns <- [];

      def process_pattern (pattern : Pattern, guard : Expr) : void {
        current_guard <- current_guard + 1;
        mutable previous_as_pattern_val <- None ();
     
        // FIXME: 'as' nesting   
        def guard =
          match (pattern) {
            | P_as (_, decl) =>
              def (assign_expr, as_pattern_val) = MakeAsPatternAssignment (decl); 
              previous_as_pattern_val <- Some (as_pattern_val);
              CE_sequence ([assign_expr, cg_expr (context, guard)])
            | _ => 
              cg_expr (context, guard)
          };
          
        def guard_is_always_true =
          match (guard) {
            | CE_literal (L_bool (true)) =>
              guards <- guards.Add (current_guard, None ());
              true
            | _ =>
              guards <- guards.Add (current_guard, Some (guard));
              false
          };
          
        def pattern =
          MatchPattern (this, pattern, current_guard, current_effect, 
                        guard_is_always_true, previous_as_pattern_val);

        patterns <- pattern :: patterns
      };
      
      def walk_match_cases (match_cases : list (Match_case)) : void {
        match (match_cases) {
          | [] => ()
          | match_case :: rest =>
            current_effect <- current_effect + 1;
            List.Iter (process_pattern, match_case.patterns);
            effects <- effects.Add (current_effect, cg_expr (context, match_case.body));
            walk_match_cases (rest)
        }
      };
      
      walk_match_cases (match_cases);
      patterns <- List.Rev (patterns);
      def block = MatchBlock (patterns);
      block.RemoveOverridenPatterns ();
      block.DecidePatternOverriding ();
      blocks <- [block]
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable blocks : list (MatchBlock);
    private mutable guards : New.SystemMap (int, option (CG_expr));
    private mutable effects : New.SystemMap (int, CG_expr);
    private mutable current_guard : int;
    private mutable current_effect : int;
    private mutable vals : New.SystemMap (int, CG_val);
    
    private mutable context : CTX;
    private mutable result_type : System.Type;
    private mutable matched_expr : CG_expr;

    private mutable matched_expr_type : System.Type;
    private mutable match_over_value_type : bool;
  }
  

  /**
   * Builds an expression that performs a binary search 
   * over a value type (that'd mainly be ints and chars).
   */
  internal class MatchBinarySearch
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, 
                 patterns : list (MatchPattern),
                 continuation : option (CG_expr))
    {
      assert (List.Length (patterns) > 0);
      
      this.match_descriptor <- match_descriptor;
      this.patterns <- patterns;
      this.matched_expr <- match_descriptor.GetMatchedExpr ();
      this.continuation <- continuation;
      
      binary_search_expr <- make_binary_search_top_level (patterns)
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetBinarySearchExpr () : CG_expr
    {
      binary_search_expr
    }
    
    public DumpMatchPatterns (patterns : list (MatchPattern)) : void {
      def walk_patterns (patterns : list (MatchPattern)) : void {
        match (patterns) {
          | [] => ()
          | pattern :: rest =>
            pattern.Dump ();
            walk_patterns (rest)
        }
      };
      
      Message.debug (" -- dumping " + (List.Length (patterns)).ToString () + " patterns --");
      walk_patterns (patterns)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    private split_patterns (patterns : list (MatchPattern)) 
      : list (MatchPattern) * MatchPattern * list (MatchPattern)
    {
      assert (List.Length (patterns) > 2);
      
      def split (patterns : list (MatchPattern), acc : list (MatchPattern), length : int) 
        : list (MatchPattern) * MatchPattern * list (MatchPattern)
      {
        if (length == 0) (List.Rev (acc), List.Head (patterns), List.Tail (patterns))
        else split (List.Tail (patterns), List.Head (patterns) :: acc, length - 1)      
      };
      
      split (patterns, [], List.Length (patterns) / 2)
    }


    private split_patterns_by_sign (patterns : list (MatchPattern)) 
      : list (MatchPattern) * list (MatchPattern)
    {
      def split (patterns : list (MatchPattern), acc_neg : list (MatchPattern),
                 acc_pos : list (MatchPattern)) : list (MatchPattern) * list (MatchPattern)
      {
        match (patterns) {
          | [] => (List.Rev (acc_neg), List.Rev (acc_pos))
          | pattern :: rest =>
            match (pattern.GetPattern ()) {
              | P_literal (L_int (k)) =>
                if (k < 0) split (rest, pattern :: acc_neg, acc_pos)
                else split (rest, acc_neg, pattern :: acc_pos)
              | _ => Util.ice ("split_patterns_by_sign: expected P_literal L_int patterns only")
            };
        }            
      };
      
      split (patterns, [], [])
    }


    private get_effect (pattern : MatchPattern) : CG_expr
    {
      match_descriptor.GetEffect (pattern.GetEffectIndex ())
    }

    
    private make_last_match (pattern : MatchPattern) : CG_expr
    {
      match (continuation) {
        | Some (continuation) =>
          pattern.MakeMatchExpr (matched_expr, continuation)          
        | None => 
          get_effect (pattern)
      }
    }


    private make_switched_block (patterns : list (MatchPattern)) : CG_expr 
    {
      def get_literal (pattern : MatchPattern) : int {        
        match (pattern.GetPattern ()) {
          | P_literal (L_int (literal)) => literal
          | P_literal (L_char (literal)) => (literal :> int)
          | P_as (P_literal (L_int (literal)), _) => literal
          | P_as (P_literal (L_char (literal)), _) => (literal :> int)
          | _ => Util.ice ("invalid pattern type")
        }
      };

      def walk_patterns (patterns : list (MatchPattern)) : list (int * CG_expr) {
        match (patterns) {
          | pattern :: rest =>
            (get_literal (pattern), pattern.MakeGuardExpr (continuation)) :: walk_patterns (rest)
          | [] => []
        }            
      };

      CE_switch (matched_expr, continuation, walk_patterns (patterns))
    }

    
    private make_binary_search (patterns : list (MatchPattern)) : CG_expr
    {
      match (patterns) {
        | [l] => make_last_match (l)

        | [l, r] =>
          l.MakeMatchExpr (matched_expr, make_last_match (r))
                                   
        | patterns =>
          def literal_span = 
            MatchPattern.Compare (List.Head (patterns), List.Last (patterns));

          if (literal_span > 24) {
            def (l, m, r) = split_patterns (patterns);

            CE_if (match_descriptor.GetResultType (), m.MakeLessThanCondition (matched_expr),
                   make_binary_search (l), make_binary_search (m :: r))
          }
          else
            make_switched_block (patterns)
      }          
    }


    /**
     * Handle the special case when some of the patterns have negative
     * literals and some positive -- it could disrupt the CE_switch emitter
     */
    private make_binary_search_top_level (patterns : list (MatchPattern)) : CG_expr
    {      
      def can_be_negative =
        match (List.Head (patterns).GetPattern ()) {
          | P_literal (L_int) => true
          | _ => false
        };

      if (can_be_negative) {        
        def (negative, positive) = split_patterns_by_sign (patterns);

        if (List.Length (negative) == 0) 
          make_binary_search (positive)
        else if (List.Length (positive) == 0) 
          make_binary_search (negative)
        else {
          def less_than_zero_expr = 
            CE_call (typeof (System.Boolean), CE_opcode ("<"),
                    [matched_expr, CE_literal (L_int (0))]);

          CE_if (match_descriptor.GetResultType (), less_than_zero_expr,
                 make_binary_search (negative), make_binary_search (positive))
        }
      }
      else
        make_binary_search (patterns)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable patterns : list (MatchPattern);
    private mutable continuation : option (CG_expr);
    private mutable matched_expr : CG_expr;
    private mutable binary_search_expr : CG_expr;
  }
  
  
  /**
   * The matching module
   */
  module CGmatch 
  {
    /**
     * Matching over ordinal types (integers, chars, etc.)
     */
    cg_match_over_ordinals (match_over_type : System.Type, 
                            context : CTX, 
                            matched_expr : CG_expr, 
                            match_cases : list (Match_case)) : CG_expr
    {
      def match_descriptor = 
        MatchDescriptor (context, match_over_type, matched_expr, match_cases);
      
      def literal_pattern (pattern : MatchPattern) : bool {
        match (pattern.GetPattern ()) {
          | P_underscore => false
          | P_as (P_underscore, _) => false
          | P_as (P_literal (L_int), _) => true
          | P_as (P_literal (L_char), _) => true
          | P_literal (L_int) => true
          | P_literal (L_char) => true
          | _ => Util.ice ("invalid pattern type")
        }
      };
            
      def match_failure_expr = {
        def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.MatchFailureException");
        def match_failure = get_default_ctor (context, tc);
        CE_raise (CE_call (CE_ctor_ref (match_failure), []))
      };      
              
      def make_continuation (continuation : option (CG_expr), patterns : list (MatchPattern)) : option (CG_expr) {      
        match (patterns) {
          | [] => continuation
          | pattern :: rest =>
            // Message.debug (pattern.GetLocation (), "make_continuation");
            
            def continuation =
              match (continuation) {
                | Some (continuation) =>
                  pattern.MakeMatchExpr (matched_expr, continuation)
                | None =>
                  pattern.MakeMatchExpr (matched_expr, match_failure_expr)
              };
            make_continuation (Some (continuation), rest)
        }
      };
      
      def process_block (block : MatchBlock, continuation : option (CG_expr)) : CG_expr {
        def (literal_patterns, non_literal_patterns) = 
          List.Partition (literal_pattern, block.GetMatchPatterns ());

        def continuation = make_continuation (continuation, List.Rev (non_literal_patterns));

        match (literal_patterns) {
          | [] => Option.UnSome (continuation)
          | _ =>
            def sorted_literal_patterns = 
              List.Sort (MatchPattern.Compare, literal_patterns);
  
            def binary_search = 
              MatchBinarySearch (match_descriptor, sorted_literal_patterns, continuation);

            binary_search.GetBinarySearchExpr ()
        }
      };
    
      def walk_blocks (blocks : list (MatchBlock)) : CG_expr {
        match (blocks) {
          | [block] =>
            process_block (block, None ())
          | block :: rest =>            
            def continuation = walk_blocks (rest);
            process_block (block, Some (continuation))
          | _ => 
            Util.ice ("no blocks in match descriptor")
        }
      };
    
      walk_blocks (match_descriptor.GetMatchBlocks ())
    }  
  
  
    cg_pattern (ctx : CTX, val : CG_expr, pats : list (Pattern * Expr)) : CG_expr * bool * CTX * list (CG_val)
    {
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;
      mutable always_matches <- true;
      
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_literal (L_bool (true))
          
          | P_as (subpat, d) =>
            if (d.in_closure) ()
            else
              match (vals.find (d.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, CE_none ());
                  rctx <- ctx;
                  vals <- vals.add (d.id, v);
              };
            def ass = CE_assign (local_ref (rctx, d), maybe_cast (ctx, cg_type (ctx, d.ty), val));
            match (subpat) {
              | P_cons =>
                match (cgpat (val, subpat)) {
                  | (CE_if (c, e_then, e_else)) as e =>
                    CE_if (e.ty, c, CE_sequence ([ass, e_then]), e_else)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([ass, cgpat (val, subpat)])
            }
            
          | P_tuple (args) =>
            def len = List.Length (args);
            def f (acc, arg)
              {
                def (pos, ex) = acc;
                def cond = cgpat (tuple_ref (CE_cast (val, tuple_type (len)), pos, len), arg);
                (pos - 1, CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false))))
              };
            def ini = (len, CE_literal (L_bool (true)));
            def (_, ex) = List.FoldLeft (f, ini, List.Rev (args));
            ex

          | P_literal (lit) =>
            def litexpr = CE_literal (lit);
            CE_call (typeof (System.Boolean), 
                    CE_opcode ("=="), 
                    [CE_cast (val, type_of (litexpr)), litexpr])
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (ctx, pat.ty));
            def f (ex, np) {
              def (name, pat) = np;
              def cond = cgpat (CE_field_ref (val, (name : IField).GetFieldInfo ()), pat);
              CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false)))
            };
            List.FoldLeft (f, CE_literal (L_bool (true)), List.Rev (args))
          
          | P_cons (n, a) =>
            always_matches <- false;
            def tyname = n.GetSystemType ();
            def ex = CE_has_type (val, tyname);
            CE_if (typeof (System.Boolean), ex, 
                    cgpat (CE_cast (val, tyname), a), 
                    CE_literal (L_bool (false)))
        }
      };

      mutable global_always_matches <- false;

      def loop (pats) {
        match (pats) {
          | (pat, expr) :: rest =>
            always_matches <- true;
            def cond = cgpat (val, pat);
            def cond =
              match (expr) {
                | E_literal (L_bool (true)) => cond
                | _ =>
                  always_matches <- false;
                  CE_if (typeof (System.Boolean), cond, cg_expr (rctx, expr), CE_literal (L_bool (false)))
              };
            global_always_matches <- global_always_matches || always_matches;
            CE_if (typeof (System.Boolean), cond, CE_literal (L_bool (true)), loop (rest))
          | [] =>
            CE_literal (L_bool (false))
        }
      };

      def r = loop (pats);
      def collect_vals (acc : list (CG_val), _ : int, v : CG_val) : list (CG_val) { v :: acc };
      (r, global_always_matches, rctx, vals.fold (collect_vals, []))
    }

    
    /**
     * Matching over arbitrary types
     */
    cg_match_over_any_type (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr 
    {
      match (mcs) {
        | [] =>
          // FIXME: cache it
          def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.MatchFailureException");
          def match_failure = get_default_ctor (ctx, tc);
          CE_raise (CE_call (CE_ctor_ref (match_failure), []))

        | m :: ms =>
          // FIXME: do something with always_matches
          def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
          def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) };
          def then_part = cg_expr (ctx', m.body);
          def else_part = cg_match (t, ctx, val, ms);
          List.FoldLeft (mklet, CE_if (t, cond, then_part, else_part), vals)
      }
    }


    /**
     * Matching over booleans.
     */
    cg_match_over_booleans (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
    {
      def type_of_bool = typeof(System.Boolean); // FIXME: how to reflect types here?
      
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;

      mutable true_handled <- false;
      mutable false_handled <- false;
      mutable last_pattern_always_matches <- false;

      def is_always_true (expr : Expr) : bool {
        match (expr) {
          | E_literal (L_bool (true)) => true
          | _ => false
        }    
      };

      def make_cond (patterns : list (Pattern * Expr)) : CG_expr {
        match (patterns) {        
          | (P_underscore, when_expr) :: _ when is_always_true (when_expr) =>
            last_pattern_always_matches <- true;          
            CE_literal (L_bool (true))
        
          | (P_underscore, when_expr) :: rest =>
            CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))

          | (P_literal (L_bool (literal)), when_expr) :: rest when is_always_true (when_expr) =>
            def literal_already_handled = if (literal) true_handled else false_handled;          
            when (literal_already_handled) Message.warning ("unreachable pattern in matching");
            
            if (literal) true_handled <- true else false_handled <- true;
                      
            if (true_handled && false_handled) {
              last_pattern_always_matches <- true;          
              CE_literal (L_bool (true))
            }
            else {
              def literal_eq_expr =
                CE_call (type_of_bool, CE_opcode ("=="), 
                        [val, CE_literal (L_bool (literal))]);

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), make_cond (rest))
            }

          | (P_literal (L_bool (literal)), when_expr) :: rest =>
            def literal_already_handled = if (literal) true_handled else false_handled;          
            when (literal_already_handled) Message.warning ("unreachable pattern in matching");

            def opposite_handled = if (literal) false_handled else true_handled;

            if (opposite_handled) {
              CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))          
            }
            else {
              def literal_eq_expr =
                CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                        [val, CE_literal (L_bool (literal))]);

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), 
                CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), 
                  make_cond (rest)))
            }

          | (P_as (subpat, decl), _) :: rest =>
            if (decl.in_closure) ()
            else
              match (vals.find (decl.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, decl, CE_none ());
                  rctx <- ctx;
                  vals <- vals.add (decl.id, v);
              };
            def assign_expr = 
              CE_assign (local_ref (rctx, decl), maybe_cast (rctx, cg_type (ctx, decl.ty), val));
            match (subpat) {
              | P_cons =>
                match (make_cond (rest)) {
                  | CE_if (cond_expr, then_expr, else_expr) =>
                    CE_if (type_of_bool, cond_expr, CE_sequence ([assign_expr, then_expr]), else_expr)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([assign_expr, make_cond (rest)])
            }

          | [] => CE_literal (L_bool (false))

          | (P_tuple, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_tuple")
          | (P_record, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_record")
          | (P_cons, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_cons")

          | _ :: _ => 
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
        }      
      };

      def walk_match_cases (mcs : list (Match_case)) : CG_expr {
        match (mcs) {
          | [] =>
            def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.MatchFailureException");
            def match_failure = get_default_ctor (rctx, tc);
            CE_raise (CE_call (CE_ctor_ref (match_failure), []))

          | mc :: rest =>
            def cond = make_cond (mc.patterns);
            def body = cg_expr (rctx, mc.body);
            
            if (true_handled && false_handled || last_pattern_always_matches) {
              when (List.Length (rest) > 0) Message.warning ("unreachable match cases");
              body
            }
            else
              CE_if (cond, body, walk_match_cases (rest))
        }
      };

      // handle the special cases for the if/when/unless macros
      match (mcs) {
        | [then_case, else_case] =>
          match ((then_case.patterns, else_case.patterns)) {
            | ([(P_literal (L_bool (literal)), then_case_when_expr)], [(P_underscore, else_case_when_expr)]) 
                when is_always_true (then_case_when_expr) && is_always_true (else_case_when_expr) =>
                
              def literal_eq_expr =
                CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                        [val, CE_literal (L_bool (literal))]);

              CE_if (t, literal_eq_expr, cg_expr (ctx, then_case.body), cg_expr (ctx, else_case.body))         
            | _ => walk_match_cases (mcs)
          }
        | _ => walk_match_cases (mcs)
      }
    }


    /**
     * Matching
     */
    internal cg_match (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
    {
      match (type_of (val).FullName) {
        | "System.Boolean" when Flags.constant_boolean_matching_opt => 
          cg_match_over_booleans (t, ctx, val, mcs)
        | "System.Char"
        | "System.Int32" when Flags.constant_ordinal_matching_opt => 
          cg_match_over_ordinals (t, ctx, val, mcs)
        | _ => cg_match_over_any_type (t, ctx, val, mcs)
      }
    }
    
  } // end of the module

} // end of the namespace
