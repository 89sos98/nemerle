using System.Console;
using Nemerle.IO;
using Bug1054;

module Bug_1102_A
{
  public f[T] (x : T, f : T * int -> bool) : bool { f (x, 0) } //1
  public f[T] (x : T, f : T -> bool) : bool { f (x) } //2
  public Test() : void
  {
    def y = f((1, 0.0), p => p[0] == 1);
    System.Console.WriteLine($"$y");
  }
}

module Bug_1102_B
{
  public f[T] (x : T, f : T -> bool) : bool { f (x) } //2
  public f[T] (x : T, f : T * int -> bool) : bool { f (x, 0) } //1
  public Test() : void
  {
    def y = f((1, 0.0), p => p[0] == 1);
    System.Console.WriteLine($"$y");
  }
}

class A {}
class B : A {}
class C : B { public this () {} }

class StaticOverride {
    static new ToString () : string {
        "bla"
    }

    public static Run () : void { 
        System.Console.WriteLine (StaticOverride.ToString ());
//        def x = StaticOverride ();
//        printf ("%s\n", x.ToString ());
    }
}

namespace CtorVsMethodOut {
  using System;

  enum AEnum { | a | b }

  public class T {
       private static Convert ( a : out AEnum) : void
        {
                a = AEnum.a;
                printf ("called Convert\n");
        }
        public static Run () : void
        {
                mutable a = ( 0 :> AEnum);
                Convert (out a);
        }
  }
}

namespace PolymorphicPlusFunctionals {
  using Nemerle.Collections;

  module M {
    f (x : int) : int { x }
    f (_x : string) : int { 1 }
    g['a] (l : list['a], f : 'a -> int) : void {
      Nemerle.IO.printf ("%s\n", List.Map (l, f).ToString ())
    }

    public Run () : void {
      def l = [1,2,3];
      g (l, f);
      def l = ["a","b","c"];
      g (l, f)
    }
  }
}

namespace AssignmentLValue {
  using System;

  class X {
      static mutable Int32 : Int32;

      public static Run () : void
      {
         Int32 = ( 0 : Int32);
      }
  }
}


public class Bug743
{
  public this (_ : string) { printf("743.string\n"); }
  public this (_ : object, _ = "a") { printf("743.object\n"); }
}

public class Bug743x
{
  public this (_ : string, _ = "a") { printf("743x.string\n"); }
  public this (_ : object) { printf("743x.object\n"); }
}

namespace Bug723 {
class X1
{
  public M() : void {}
}

class X2
{
  public X1 : X1 = X1();
  public K() : void
  {
    X1.M()
  }
}
}

module Bug770 {
    test(_ : object) : void { }
    test(_ : array[object]) : void { }
    foo() : void {
        def z(x,y){x+y}
        test(z(1,2));
    }
}

class Bug1054
{
 public static Last[T] (this _ : list[T]) : list[string] {
  ["hello"]
 }
}

module M {
  foo (_ : array [string]) : void { }
  foo (_ : array [object]) : void { assert (false) }

  
  quxx (_ : A) : void { printf ("A\n"); }
  quxx[T] (_ : T) : void where T : A { printf ("poly\n"); }

  bar (s : string, i : int) : void {
    _ = s;
    _ = i;
  }
  
  bar (i : int, s : object) : void {
    _ = s;
    _ = i;
    assert (false);
  }
  
  f (_ : A, _ : B) : void {}
  f (_ : B, _ : B) : void { printf ("OK\n") }

  public Main () : void {
    f (C (), C ());
    StaticOverride.Run ();
    CtorVsMethodOut.T.Run ();
    PolymorphicPlusFunctionals.M.Run ();
    AssignmentLValue.X.Run ();

    bar (s = "foo", i = 42);
    bar (i = 42, s = "foo");
    foo (array ["foo"]);

    quxx (A ());
    // FIXME: poly should be chosen
    // quxx (B ()); 

    _ = Bug743("");
    _ = Bug743("", "");
    _ = Bug743x("");
    _ = Bug743x("", "");
    System.Console.WriteLine ([(1, 2)].Last [0]); //Bug1054
    def _r = Met(1, _ToStr);
    Bug_1102_A.Test();
    Bug_1102_B.Test();
  }

  public Main (_args : string) : void // W: has the wrong signature to be an entry point
  {  }

  public _ToStr[T](x : T)      : string { WriteLine("_ToStr[T](x : T)"); x.ToString() }
  public _ToStr[T](x : object) : string { WriteLine("_ToStr[T](x : object)"); x.ToString() }
  public _ToStr(x : int)       : string { WriteLine("_ToStr(x : int)"); x.ToString() }
  
  public Met[T](value : T, _f : T -> string) : string { _ = _f(value); null }
}


/*
BEGIN-OUTPUT
OK
bla
called Convert
[1, 2, 3]
[1, 1, 1]
A
743.string
743.object
743x.string
743x.string
1
_ToStr(x : int)
True
True
END-OUTPUT
*/
