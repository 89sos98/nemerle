
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

class M {
  class StagedMacro : IMacro {
    public GetName () : string { "stagedmacro" }
    public GetNamespace () : string { "" }

    public Run (_ctx : TypingContext, _ : list [SyntaxElement]) : PExpr {
      <[ def x = 5; x ]>
    }

    public CallTransform (_ : list [PExpr]) : list [SyntaxElement] { [] }
    public SyntaxExtension () : string * list [Parser.GrammarElement] * list [int]
    { ("", [], []) }
    public IsTailRecursionTransparent : bool { get { false } }
  }

  
  static DoTheStuff (_ : list [Parsetree.TopDeclaration]) : void {
    def staged = StagedMacro ();
    MacroRegistry.register_macro (staged);
    
    def tb = GlobalEnv.DefineExact (<[ decl:
      public class A { }
    ]>);
    
    tb.Define (<[ decl: public static Run () : int { stagedmacro () } ]>);
    tb.Compile ();
  }
  
  static Main () : void {
    Message.InitOutput (System.Console.Out);         

    Options.Sources = [""];
    Options.CompileToMemory = true;
    Options.ProgressBar = false;
    
    Passes.LexingPipeline = fun (_) { null };
    Passes.ParsingPipeline = fun (_) { [] };
    Passes.ScanningPipeline = DoTheStuff;
    Passes.Run ();
    
    def ass = Passes.GeneratedAssembly;
    def meth = ass.GetTypes()[0].GetMethod("Run");
    def res = meth.Invoke (null, null);
    System.Console.WriteLine (res);
  }
}
