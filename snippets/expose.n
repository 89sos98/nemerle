
/*

class WithInvariant
{
  mutable x : int;
  
  invariant x >= 0;
  
  public Assign (y : int) : void
  {
    expose (this) {
      x <- y
    }
  }
  
  public Retrieve () : int
  {
    x
  }
}

class WithInvariant
{
  private mutable _N_invariant_lock : int;
  
  private _N_invariant () : void
  {
    when (_N_invariant_lock == 0)
      assert (x >= 0);
  }
  
  public Assign (y : int) : void
  {
    lock (this)
      ++_N_invariant_lock;    

    $body;

    lock (this) {
      --_N_invariant_lock;
      _N_invariant ()
    }
  }
}

*/



namespace Plzen {  
  postadd macro Invariant (ty : TypeBuilder, body) {
    ty.Define ( <[ decl:
      public mutable _N_invariant_lock : bool;
    ]> );
    ty.Define ( <[ decl:
      public _N_invariant () : void
      {
        assert ($body)
      }
    ]> );
  }

  macro @expose (exposed, body) 
  syntax ("expose", "(", exposed, ")", body) {
    <[ 
      def e = $exposed;

      lock (e) {
        when (e._N_invariant_lock)
          throw System.Exception ();
      
        e._N_invariant_lock <- true
      };

      mutable need_to_check <- false;
            
      try {
        try {
          $body;
    	  need_to_check <- true
        }
        catch {
        /*
          | e : IChecked => need_to_check <- true; rethrow
         */ 
          | e : System.Exception => ()	  
        }
      }
      finally {
        lock (e) {
          e._N_invariant_lock <- false;
	  when (need_to_check)
	    e._N_invariant ()        
        }
      }
    ]>     
  }
}
