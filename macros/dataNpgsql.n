/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Data;
using System.Text.RegularExpressions;
using Npgsql;

namespace Nemerle.Data {
module Npgsql {
  mutable connection : NpgsqlConnection;

  type_representant (t : Nemerle.Compiler.Typedtree.Type) : object
  {
    match (t) {
      | Nemerle.Compiler.Typedtree.T_app (tc, []) =>
        match (tc.GetFullName ()) {
          | "System.String" =>
            ("test string" : object)
          | "System.Int32" =>
            234
          | x =>
            Nemerle.Compiler.Message.fatal_error (x + " type not supported")
        }
      | _ =>
        Nemerle.Compiler.Message.fatal_error ("only basic types supported in sql query")
    }
  }
  
  macro CreateCompileTimeConnection (con_str : string)
  {
    connection <- NpgsqlConnection (con_str);
    connection.Open ();
    <[ () ]>
  }

  macro SqlLoop (query : string, conn, body)
  {
    // take names after $
    def namesreg = Regex (@"(([^\$]*)\$(\w+))|(.+)", RegexOptions.Singleline);
    mutable m <- namesreg.Match (query);
    def fquery = System.Text.StringBuilder (query);
    def pars = Nemerle.Collections.Hashtable ();

    // extract names and prefix them with Npgsql parameter delimiter `:'
    while (m.Success) {
      when (m.Groups[1].Success) {
        pars.Set (m.Groups[3].ToString (), null);
        fquery[m.Groups[3].Index - 1] <- ':';
      };
      m <- m.NextMatch ();
    };

    // initializers of sql command parameters
    def tpars = Nemerle.Collections.Hashtable ();    
    mutable pars_init <- [];
    pars.Iter (fun (x, _) {
      def varname = Nemerle.Compiler.Macros.UseSiteSymbol (x);
      def tvar = Nemerle.Compiler.Tyexpr.ty_expr (_N_ctx, <[ $(varname : var) ]>);
      tpars.Set (x, tvar);
      pars_init <- <[ ignore (querycmd.Parameters.Add ($(x : string), 
                                                       $(tvar : typed))) ]> 
                   :: pars_init;
    });

    // try to execute query chcecking its syntax and aquiring names of columns
    mutable bodyseq <- [body];
    def mycmd = NpgsqlCommand (fquery.ToString (), connection);
    tpars.Iter (fun (name, typed : Nemerle.Compiler.Typedtree.Expr) {
      ignore (mycmd.Parameters.Add (name, type_representant (typed.expr_ty)))
    });
    try {
      def myreader = mycmd.ExecuteReader(CommandBehavior.SchemaOnly);
      def table = myreader.GetSchemaTable ();
      foreach(myRow : DataRow in table.Rows){
        def col = myRow["ColumnName"].ToString ();
        def col_type = Nemerle.Compiler.Macros.UseSiteSymbol (myRow["DataType"].ToString ());
        def col_name = Nemerle.Compiler.Macros.UseSiteSymbol (col);
        bodyseq <- <[ def $(col_name : var) = (reader[$(col : string)] 
                                              :> $(col_type : var)) ]> :: bodyseq;
      }
    }
    catch {
      | e : NpgsqlException =>
        Nemerle.Compiler.Message.fatal_error ("sql query error: " + e.Message)
    };

    <[
      def querycmd = NpgsqlCommand ($(fquery.ToString () : string), $conn);
      { .. $pars_init };
      def reader = querycmd.ExecuteReader ();
      while (reader.Read ()) { ..$bodyseq };
      reader.Close ();
      querycmd.Dispose ();
    ]>
  }

}
}
