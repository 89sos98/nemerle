/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public partial class Typer
  {
    class CallTyper {
      function_called : TExpr;
      mutable call_parms : list [Parm];
      imethod : IMethod;
      mutable header : Fun_header;
      expected_type : TyVar;
      typer : Typer;
      messenger : Messenger;
      solver : Solver;

      mutable result_type : TyVar;
      mutable formals_types : list [TyVar];
      mutable is_delegate_constructor : bool;
      mutable argument_number : int;

      public mutable is_var_args : bool;
      public mutable is_final : bool;
      public mutable result : TExpr;


      public this (typer : Typer, fnc : TExpr, parms : list [Parm], expected : TyVar)
      {
        this.typer = typer;
        solver = typer.solver;
        messenger = typer.messenger;

        function_called = fnc;
        call_parms = parms;
        expected_type = expected;
        
        imethod =
          match (function_called) {
            | TExpr.StaticRef (meth is IMethod)
            | TExpr.MethodRef (_, meth, _)
            | TExpr.Base (meth) => meth
            | _ => null
          };

        header =
          if (imethod == null)
            match (fnc) {
              | TExpr.LocalRef (decl) =>
                match (decl.ValKind) {
                  | LocalValue.Kind.Function (hd, _) => hd
                  | _ => null
                }
              | _ => null
            }
          else
            imethod.GetHeader ();
      }


      DeduceFunctionType () : void
      {
        // check if we are dealing with a delegate constructor
        is_delegate_constructor =
          imethod != null && 
          imethod.DeclaringType.IsDelegate &&
          imethod.GetFunKind () matches FunKind.Constructor;

        def fun_ty = typer.TypeOf (function_called);

        assert (!messenger.LocalError);
          
        match (fun_ty.Hint) {
          | Some (MType.Fun (from, res)) =>
            result_type = res;
            formals_types =
              match (from.Hint) {
                | Some (MType.Tuple (lst)) => lst
                | Some (MType.Void) => []
                | _ when List.Length (call_parms) > 1 =>
                  def formals_types =
                    List.Map (call_parms, fun (_) { 
                        typer.FreshTyVar () 
                    });
                  def fun_ty = typer.ConstructFunctionType (formals_types, result_type);

                  def err = !function_called.Type.TryRequire (fun_ty);
                  
                  if (err) {
                    [from]
                  } else {
                    // Message.Debug ($ "fun_ty: $fun_ty REQ $(function_called.Type)");
                    def ok = function_called.Type.Require (fun_ty);
                    // Message.Debug ($ "fun_ty-->: $fun_ty");
                    assert (ok); 
                    formals_types
                  }

                | _ => [from]
              }
          
          | _ when Option.IsSome (fun_ty.Hint) =>
            ReportError (messenger, 
                         $ "the value called has non-functional type $fun_ty")
          
          | _ =>
            formals_types =
              List.Map (call_parms, fun (_) { 
                  typer.FreshTyVar () 
              });
            result_type = typer.FreshTyVar ();
            def fun_ty = typer.ConstructFunctionType (formals_types, result_type);
            def real_fun_ty = typer.TypeOf (function_called);
            unless (real_fun_ty.Require (fun_ty))
              ReportError (messenger,
                           $ "functional value was required to have type "
                             "$fun_ty while it has $real_fun_ty");
        }

        when (is_delegate_constructor) {
          // get the arguments for delegate constructor from the Invoke method
          match (imethod.DeclaringType.LookupMember ("Invoke")) {
            | [invoke is IMethod] =>
              formals_types = [invoke.GetMemType () : TyVar];
            | _ => assert (false)
          }
        }
      }


      RequireType (fparm : Fun_parm, ftype : TyVar, parm : Parm) : void
      {
        // Message.Debug ($ "$(parm.expr.Type) <<< $ftype");
        def msg =
          if (messenger.NeedMessage)
            $ "needed a $ftype, got $(parm.expr.Type)"
          else "";

        def is_ok =
          if (fparm != null && fparm.kind != ParmKind.Normal)
            parm.expr.Type.Unify (ftype)
          else {
            def expr = typer.TryAddCastTo (parm.expr, ftype);
            if (expr == null) {
              when (messenger.NeedMessage)
                // make sure a proper error message is stored
                _ = parm.expr.Type.Require (ftype);
              false
            } else {
              when (is_final)
                parm.expr = expr;
              true
            }
          }
           
        unless (is_ok) {
          def name =
            if (messenger.NeedMessage)
              if (fparm == null)
                $ "argument #$argument_number"
              else
                $ "argument #$argument_number ($(fparm.name))"
            else "";
              
          ReportError (messenger, $ "in $name, $msg")
        }
      }
      

      TypeParmsArray (arrayty : TyVar, aparms : list [Parm]) : void
      {
        def regular_parms = call_parms.FirstN (argument_number - 1);

        def tv = 
          match (arrayty.Hint) {
            | Some (MType.Array (tv, 1)) => tv
            | _ => assert (false)
          }

        mutable expr_list = [];
              
        foreach (aparm in aparms) {
          when (!messenger.LocalError) {
            when (aparm.kind != ParmKind.Normal)
              ReportError (messenger,
                           "ref/out parameters are not allowed with `parms'");
            when (aparm.name != "")
              ReportError (messenger,
                           "named parameters are not allowed with `parms'");
           
            RequireType (null, tv, aparm);
            expr_list = aparm.expr :: expr_list;
            ++argument_number;
          }
        }

        unless (messenger.LocalError) {
          def dimensions =
            [TExpr.Literal (InternalType.Int32,
                            Literal.Int (List.Length (expr_list)))];
          def mkarray = 
            TExpr.Array (function_called.loc, arrayty, List.Rev (expr_list), dimensions);
          call_parms = regular_parms + [Parm (mkarray)];
        }
      }

      
      LoopWithHeader () : void
      {
        def loop (fparms, ftypes, aparms) {
          | ([_], [arrayty], aparms) when is_var_args =>
            TypeParmsArray (arrayty, aparms)

          | ([], [], []) when !is_var_args => {}

          | ((fparm : Fun_parm) :: fparms, ftype :: ftypes, (aparm : Parm) :: aparms) =>
            if (fparm.kind == aparm.kind) {
              RequireType (fparm, typer.StripRefOut (ftype), aparm);
              ++argument_number;
              unless (messenger.LocalError)
                loop (fparms, ftypes, aparms);
            } else 
              ReportError (messenger,
                           $ "in argument #$argument_number ($(fparm.name)), needed a "
                             "$(fparm.kind) parameter, got $(aparm.kind)")
            
          | x =>
            Message.Warning ("oops");
            assert (false, x.ToString ())
        }

        loop (header.parms, formals_types, call_parms)
      }


      LoopWithoutHeader () : void
      {
        def loop (ftypes, aparms) {
          | ([], []) => {}

          | (ftype :: ftypes, (aparm : Parm) :: aparms) =>
            if (aparm.kind == ParmKind.Normal) {
              RequireType (null, ftype, aparm);
              ++argument_number;
              unless (messenger.LocalError)
                loop (ftypes, aparms);
            } else 
              ReportError (messenger,
                           $ "in argument #$argument_number, ref/out parameters "
                             "are not supported here")
            
          | _ => assert (false)
        }

        assert (!is_var_args);
        loop (formals_types, call_parms)
      }


      LoopOverArgs () : void
      {
        when (header != null &&
              List.Length (header.parms) != List.Length (formals_types))
          header = null;

        argument_number = 1;

        if (header == null)
          LoopWithoutHeader ()
        else
          LoopWithHeader ();

        unless (messenger.LocalError) {
          _ = typer.Expect (expected_type, result_type, "call result");
          unless (messenger.LocalError)
            result = TExpr.Call (result_type, function_called, call_parms);
        }
      }


      public Run () : void
      {
        messenger.CleanLocalError ();

        when (is_var_args)
          assert (imethod != null && imethod.IsVarArgs);

        def has_named = List.Exists (call_parms, 
                                     fun (parm : Parm) { parm.name != "" });

        when (has_named)
          if (header == null) {
            ReportError (messenger,
                         "named parameters given but formals' names cannot" 
                         " be inferred");
          } else {
            def names = List.Map (header.parms, 
                                  fun (p : Fun_parm) { p.name });
            ReorderNamedParms (names)
          }

        unless (messenger.LocalError) {
          DeduceFunctionType ();
          unless (messenger.LocalError) {
            def formal_count = List.Length (formals_types);
            def actual_count = List.Length (call_parms);

            if (is_var_args) {
              if (formal_count > actual_count + 1)
                ReportError (messenger, "not enough parameters")
              else {
                LoopOverArgs ();
              }
            } else {
              if (formal_count == actual_count) {
                LoopOverArgs ();
              } else if (formal_count > 1 && actual_count == 1) {
                formals_types = [MType.Tuple (formals_types) : TyVar];
                LoopOverArgs ();
              } else {
                // the case formal_count == 1 && actual_count > 1 has been
                // handled already in DeduceFunctionType
                ReportError (messenger, $ "wrong number of parameters in "
                                          "call, needed $formal_count, got "
                                          "$actual_count");
              }
            }
          }
        }
      }


      // TODO: merge this into the other overload 
      ReorderNamedParms (top_names : list [string]) : void
      {
        call_parms = ReorderNamedParms (top_names, call_parms);
      }
      

      /** Given list of formal parms names and actual parms names, reorder
          actuals to match formals.
          
          The named parameters can be preceded by a series of unnamed
          parameters:
       
            [bar (e_0, e_1, x_2 = e_2, x_3 = e_3, ..., x_k = e_k)]
       
          where x_i are the named parameter references and e_i are some
          expressions.  */
      ReorderNamedParms (top_names : list [string],
                         top_parms : list [Parm]) : list [Parm]
      {
        // lookup tables for names, named and unnamed parameters
        def valid_names = Hashtable (16);
        def seen_named_parms = Hashtable (16);
        def seen_unnamed_parms = Hashtable (16);

        // we will need a way to lookup the valid parameter names
        foreach (name in top_names) {
          assert (name != null);
          assert (!valid_names.ContainsKey (name));
          valid_names.Add (name, name)
        }

        // failure handler
        def fail (msg) {
          ReportError (messenger, msg);
          false
        }

        // the correctness verifier
        def check_names_and_parms (names : list [string], parms : list [Parm]) : bool
        {
          | ([], []) =>
            true

          | (_, []) =>
            def unresolved_names =
              List.Filter (top_names, fun (name : string) {
                !(seen_named_parms.Contains (name) || seen_unnamed_parms.Contains (name))
              });

            def unresolved_names =
              List.Map (unresolved_names, fun (name : string) { "`" + name + "'" });

            fail ("unresolved named parameters: " +
                  NString.Concat (", ", unresolved_names))

          | (name :: rest_of_names, parm :: rest_of_parms) when parm.name == "" =>
            // the case for an unnamed parameter
            if (seen_named_parms.Count > 0) {
              // seen a named parameter before, error...
              fail ("unnamed parameter found after a named parameter")
            }
            else {
              // otherwise, this is an element of the leading unnamed parameters
              seen_unnamed_parms.Add (name, parm);
              check_names_and_parms (rest_of_names, rest_of_parms)
            }

          | (_ :: rest_of_names, parm :: rest_of_parms) =>
            // a named parameter, check if no unnamed parameter has covered it before
            if (seen_unnamed_parms.ContainsKey (parm.name)) {
              // this parameter name was covered by an unnamed parameter
              fail ("keyword parameter `" + parm.name + "' already specified as an unnamed parameter")
            }
            else if (seen_named_parms.ContainsKey (parm.name)) {
              // the case for repeating parameters
              fail ("keyword parameter `" + parm.name + "' already specified")
            }
            else if (!valid_names.ContainsKey (parm.name)) {
              // whoops, no such parameter for this method :]
              fail ("no such keyword parameter `" + parm.name + "' among valid parameter names")
            }
            else {
              // OK, this has to be right...
              seen_named_parms.Add (parm.name, parm);
              check_names_and_parms (rest_of_names, rest_of_parms)
            }

          | ([], parm :: _) =>
            fail ($ "too much parameters specified, first one causing "
                    "the problem is `$(parm.name)'")
        }

        // reordering is a matter of simple names list walk now:
        def reorder_parms (names : list [string], acc : list [Parm]) : list [Parm]
        {
          | (name :: rest_of_names, _) =>
            if (seen_unnamed_parms.Contains (name))
              reorder_parms (rest_of_names,
                             Option.UnSome (seen_unnamed_parms.Get (name)) :: acc)
            else if (seen_named_parms.Contains (name))
              reorder_parms (rest_of_names,
                             Option.UnSome (seen_named_parms.Get (name)) :: acc)
            else
              Util.ice ("reorder_named_parms: reorder")

          | ([], _) =>
            List.Rev (acc)
        }

        if (check_names_and_parms (top_names, top_parms))
          reorder_parms (top_names, [])
        else
          null
      }
    }
  }
}

