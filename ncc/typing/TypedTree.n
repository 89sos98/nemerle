/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler.Typedtree
{
  public variant TypeDeclaration
  {
    | Class
    | Alias         { ty : MType; }
    | Interface
    | Variant       { members : list [TypeInfo]; }
    | VariantOption
    | Enum
  }

  [Record]
  public class Fun_parm : Located
  {
    public name : string;
    public color : int;
    public mutable ty : TyVar;
    public mutable decl : LocalValue;
    public modifiers : Modifiers;
    public kind : ParmKind;

    public mutable cg_val : CG_val;

    public SystemType : System.Type
    {
      get {
        ty.Fix ().GetSystemType ();
      }
    }
  }

  public enum FunctionUsage 
  {
    | NotUsed
    | UsedJustOnce
    | Used
    | UsedAsFirstClass
  }
  
  public class Fun_header : Located, Nemerle.IComparable [Fun_header]
  {
    public mutable name : string;
    public id : int;
    public mutable ret_type : TyVar;
    public mutable parms : list [Fun_parm];
    public mutable typarms : list [StaticTyVar];
    public tenv : TyVarEnv;

    public mutable usage : FunctionUsage;
    public mutable body : FunBody;

    /// local values defined in this function, which are closurised (used by children) 
    public mutable closure_vars : list [LocalValue] = [];
    /// local value, which is declaring this function (valid for local funs)
    public mutable decl : LocalValue;
    public mutable all_locals : list [LocalValue] = [];
    internal mutable children_funs : list [Fun_header] = [];

    internal mutable static_method : IMethod;
    internal mutable closure_type : TypeInfo;

    public CompareTo (other : Fun_header) : int
    {
      id - other.id
    }

    public this (loc : Location, 
                 name : string, 
                 ret_type : TyVar, 
                 parms : list [Fun_parm], 
                 typarms : list [StaticTyVar], 
                 tenv : TyVarEnv)
    {
      base (loc);
      this.name = name;
      this.ret_type = ret_type;
      this.parms = parms;
      this.typarms = typarms;
      this.tenv = tenv;

      id = Util.next_id ();
      usage = FunctionUsage.NotUsed;
    }
    
    /**
     *  Retrieves functions in which current function is nested. Empty list if
     *  this is a plain method of some class.
     */
    public GetParents () : list [Fun_header]
    {
      if (decl != null)
        match (decl.ValKind) {
          | LocalValue.Kind.Function (_, pars) => pars
          | _ => Util.ice ("invalid value kind for function")
        }
      else []
    }
    
    public override ToString () : string 
    {
      name
    }
  }

  
  [Record]
  public variant Pattern : Located
  {
    | Wildcard
    | As          { pat : Pattern; decl : LocalValue; }
    | HasType     { tycon : TypeInfo; }
    | Tuple       { args : list [Pattern]; }
    | Record      { args : list [IMember * Pattern]; }
    | Application { name : TypeInfo; arg : Pattern; }
    | Enum        { fld : IField; val : Nemerle.Compiler.Literal; }
    | Literal     { lit : Nemerle.Compiler.Literal; }
    | Error

    public mutable ty : TyVar;
    
    public this () { }

    public GetSystemType () : System.Type
    {
      assert (ty != null);
      ty.Fix ().GetSystemType ()
    }

    public StripEnums () : Pattern
    {
      Walk (fun (_) {
        | Enum (_, l) => Literal (l)
        | _ => null
      })
    }


    /** Walk [this] with the function [f].

        The function is applied to each and every pattern node.
        
        If [f] returns a value different than [null], the value is
        returned, from this [Walk] function.

        If it returns [null], the walking function descends into tree
        elements in a map-like fashion.

        If the type of pattern returned was to be [null], it is set to
        the type of the original pattern.

        This function implements the visitor pattern.  */
    public Walk (f : Pattern -> Pattern) : Pattern
    {
      def do_walk (pat) {
        | Enum 
        | Pattern.Literal
        | Error
        | HasType
        | Wildcard => pat
        
        | As (pat, decl) =>
          As (walk (pat), decl)

        | Tuple (args) =>
          Tuple (args.Map (walk))
          
        | Record (args) =>
          Record (args.Map (fun (f, p) { (f, walk (p)) }))
          
        | Application (c, a) =>
          Application (c, walk (a))
      } and walk (pat) {
        def res = Util.locate (pat.loc, {
          def res = f (pat);
          if (res == null) do_walk (pat) else res;
        });
        when (res.ty == null)
          res.ty = pat.ty;
        res
      }

      walk (this)
    }


    public override ToString () : string
    {
      PrettyPrint.SprintPattern (this)
    }
  }

  [Record]
  public class Match_case
  {
    public mutable patterns : list [Pattern * TExpr];
    public mutable body : TExpr;
  }

  public variant ConversionKind
  {
    | MethodCall { meth : IMethod; }
    | IL { is_checked : bool; }
    | UpCast
    | DownCast
    | Implicit
    | IgnoreValue // generates a warning in Typer2
    | Unspecified // like DownCast, but avoid warnings

    // Boxing and Nop are to be unused when cgexpr is killed
    | Boxing
    | Nop
  }

  [Record]
  public variant TExpr : Located
  { 
    | LocalRef              { decl : LocalValue; }
    | StaticRef             { mem : IMember; }
    | ImplicitValueTypeCtor { tc : TypeInfo; }
    | FieldMember           { obj : TExpr; fld : IField; }
    | ConstantObjectRef     { mem : IField; }
    | PropertyMember        { obj : TExpr; prop : IProperty; }
    | StaticPropertyRef     { prop : IProperty; }
    | EventMember           { obj : TExpr; ev : IEvent; }
    | StaticEventRef        { ev : IEvent; }
    | MethodRef             { obj : TExpr; meth : IMethod; notvirtual : bool; }
    | Call                  { mutable func : TExpr; mutable parms : list [Parm]; }
    | TailCall              { func : TExpr; parms : list [Parm]; }
    | SelfTailCall          { parms : list [Parm]; }
    | Assign                { target : TExpr; source : TExpr; }
    | DefValIn              { name : LocalValue; val : TExpr; mutable body : TExpr; }
    | DefFunctionsIn        { funs : list [Fun_header]; mutable body : TExpr; }
    | Match                 { expr : TExpr; cases : list [Match_case]; }
    | Throw                 { exn : TExpr; }
    | TryWith               { body : TExpr; exn : LocalValue; handler : TExpr; }
    | TryFinally            { body : TExpr; handler : TExpr; }
    | Literal               { val : Nemerle.Compiler.Literal; }
    | This
    | Base                  { base_ctor : IMethod; }
    | TypeConversion        { mutable expr : TExpr; target_type : TyVar; kind : ConversionKind; }
    | Sequence              { e1 : TExpr; mutable e2 : TExpr; }
    | Tuple                 { args : list [TExpr]; }
    | Array                 { args : list [TExpr]; dimensions : list [TExpr]; }
    | TypeOf                { target_type : TyVar; }
    | ArrayIndexer          { over_type : TyVar; obj : TExpr; args : list [TExpr]; }
    | OpCode                { name : string; }

    | Delayed               { susp : Typer.DelayedTyping; }
    | Error

    // new CG-related stuff
    | MethodAddress         { meth : IMethod; }
    | MultipleAssign        { assigns : list [LocalValue * TExpr]; }
    | Label                 { mutable body : TExpr; mutable cgexpr_label : CExpr.Label; }
    | Goto                  { target : TExpr.Label; }
    
    public mutable ty : TyVar;

    public Type : TyVar
    {
      get {
        assert (ty != null, $ "type is null for $loc, $this");
        ty 
      }
    }

    public this () { }

    public override ToString () : string {
      PrettyPrint.SprintTyExpr (this)
    }


    /** Walk [this] with the function [f].

        The function is applied to each and every expression node.
        
        If [f] returns a value different than [null], the value is
        returned, from this [Walk] function.

        If it returns [null], the walking function descends into tree
        elements in a map-like fashion.

        If the type of expression returned was to be [null], it is set
        to the type of the original expression.

        This function implements the visitor pattern.  */
    public Walk (f : TExpr -> TExpr) : TExpr
    {
      def walk (expr) {
        def res = Util.locate (expr.loc, {
          def res = f (expr);
          if (res == null) do_walk (expr) else res;
        });
        when (res.ty == null)
          res.ty = expr.ty;
        res
      } 
      and walks (exprs) {
        exprs.Map (walk)
      }
      and do_walk (expr) {
        | Delayed
        | PropertyMember
        | StaticPropertyRef
        | EventMember
        | StaticEventRef =>
          // this is supposed to be run after Typer2
          Message.Warning (expr.loc, 
                           $ "invalid expr in walk: $(expr.GetType()): $expr");
          assert (false)
          

        | This
        | LocalRef
        | StaticRef 
        | Error
        | OpCode 
        | TypeOf
        | TExpr.Literal
        | Base
        | ImplicitValueTypeCtor
        | MethodAddress
        | Goto
        | ConstantObjectRef =>
          expr
          

        | DefFunctionsIn (funs, body) =>
          foreach (fn in funs)
            match (fn.body) {
              | FunBody.Typed (e) =>
                fn.body = FunBody.Typed (walk (e))
              | _ => {}
            }
          DefFunctionsIn (funs, walk (body))
          
          
        | MethodRef (obj, meth, notvirt) =>
          MethodRef (walk (obj), meth, notvirt)


        | FieldMember (obj, fld) =>
          FieldMember (walk (obj), fld)
          
          
        | TailCall (func, parms) =>
          def func = walk (func);
          foreach (p in parms)
            p.expr = walk (p.expr);
          TailCall (func, parms)

          
        | Call (func, parms) =>
          def func = walk (func);
          foreach (p in parms)
            p.expr = walk (p.expr);
          Call (func, parms)

        
        | SelfTailCall (parms) =>
          foreach (p in parms)
            p.expr = walk (p.expr);
          expr
        

        | Assign (target, source) =>
          Assign (walk (target), walk (source))


        | MultipleAssign (assigns) =>
          MultipleAssign (assigns.Map (fun (s, t) { (s, walk (t)) }))
          
   
        | DefValIn (name, val, body) =>
          DefValIn (name, walk (val), walk (body))
          
          
        | Match (matched_value, cases) =>
          foreach (case in cases) {
            mutable pats = [];
            foreach ((pat, expr) in case.patterns) {
              pats = (pat, walk (expr)) :: pats
            }
            case.patterns = pats.Rev ();
            case.body = walk (case.body);
          }
          Match (walk (matched_value), cases)
          

        | Throw (exn) =>
          // exception can be null for `throw;' rethrow expression
          if (exn != null)
            Throw (walk (exn))
          else
            expr

        | TryWith (body, exn, handler) =>
          TryWith (walk (body), exn, walk (handler))
          
          
        | TryFinally (body, handler) =>
          TryFinally (walk (body), walk (handler))
          

        | TypeConversion (expr, t, kind) =>
          TypeConversion (walk (expr), t, kind)
          
          
        | Sequence (e1, e2) =>
          Sequence (walk (e1), walk (e2))
          
          
        | Tuple (args) =>
          Tuple (walks (args))
          
          
        | Array (args, dimensions) =>
          Array (walks (args), walks (dimensions))
          
          
        | ArrayIndexer (t, obj, args) =>
          ArrayIndexer (t, walk (obj), walks (args))


        | Label (body, cg) =>
          Label (walk (body), cg)
      }

      walk (this)
    }
  }

  public enum ParmKind {
    | Normal
    | Ref
    | Out
  }

  [Record]
  public class Parm
  {
    public kind : ParmKind;
    public mutable expr : TExpr;
    public name : string;  // "" if no name given

    public this (expr : TExpr)
    {
      kind = ParmKind.Normal;
      this.expr = expr;
      name = "";
    }
  }
} // Nemerle.Compiler.Typedtree
