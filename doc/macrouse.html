<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Most interesting features we implemented using macros</title><link rel="stylesheet" href="styles/style.css" /><link rel="icon" href="styles/nemerle-icon.png" type="image/png" /></head><body><table class="outer-menu"><tr><td><table class="menu"><tr><td align="left"><a href="index.html">Home</a> :: <a href="download.html">Download</a> :: <a href="documentation.html">Documentation</a> :: <a href="contact.html">Contact</a> :: <a href="poll1.html">Poll</a> :: <a href="blog/">Blog</a> :: <a href="bugs/">Bugs</a></td><td align="right"><a href="#top-of-page">Top</a> :: <a href="#bottom-of-page">Bottom</a></td></tr></table></td></tr></table><a name="top-of-page" id="top-of-page"></a><h1>Most interesting features we implemented using macros</h1><ul class="toc"><li>1. <a href="#intro"><b>Intro</b></a></li><li>2. <a href="#designbycontract"><b>Design by Contract</b></a></li><li>3. <a href="#checkedsql"><b>Compile-time validation of embedded SQL queries</b></a></li><li>4. <a href="#aspects"><b>Aspects-Oriented programming</b></a></li></ul><h2><a name="intro" id="intro"></a>1. Intro</h2><p>
        This page is dedicated to features of Nemerle and its library, which
        was implemented using our <a href="macros.html">meta-programming facilities</a>.
      </p><p>
        Understanding how macros work is not necessary for using any of
        them. It would be useful only for knowing that those examples
        are only tip of iceberg called meta-programming and that you can easily
        implement even nicer things.
      </p><h2><a name="designbycontract" id="designbycontract"></a>2. Design by Contract</h2><p>
          Languages like 
          <a href="http://en.wikipedia.org/wiki/Eiffel_programming_language">Eiffel</a> 
          or 
          <a href="http://research.microsoft.com/~leino/papers/krml136.pdf">Spec#</a> 
          incorporate methodology called 
          <a href="http://en.wikipedia.org/wiki/Design_by_contract">Design by Contract</a>
          to reason about programs, libraries, methods. It helps people write more
          secure and correct software and specify its behavior.
        </p><p>
          Language following this design must support writing explicit requirements 
          about values on which program operates. It contains:
        </p><ul><li>preconditions - some fact (boolean condition) that must be 
            satisfied in order to call a method, it mostly concerns passed
            parameters, but necessary
          </li><li>postconditions - fact that must be satisfied after calling a method,
            for example about its return value
          </li><li>invariants - property of program, which doesn't change in time (like
            nondecreasing order of elements in list, etc.)
          </li><li>other restrictions in behavior of some part of program (like for example
            fact that method do not change state of class)
          </li></ul><p>
          We are currently on the way to add ability to define most of those features
          to Nemerle. In following subsections we present their current state, design
          and plans for future.
        </p><h3><a name="requires" id="requires"></a>2.1. Preconditions - Requires attribute</h3><p>
                If we want to state some condition, which must be satisfied when 
                calling a method, we write a special <tt class="code">Requires</tt> attribute
                before it. It takes as a parameter an expression, which define
                the precondition.
              </p><table cellpadding="0" cellspacing="0" class="code"><tr><td><pre class="code">

class String {
  [Requires (startIdx &gt;= 0 &amp;&amp; startIdx &lt;= this.Length)]
  public Substring (startIdx : int) : string 
  { ... }
}
</pre></td></tr></table><p>
                Using this attribute we can add arbitrary assertion, keeping
                body of method clean and verbose. Compiler automatically adds
                runtime checks at the beginning of method. If condition is
                violated, then <tt class="code">AssertionException</tt> is being thrown with 
                an appropriate message containing this expression.
              </p><p>
                Requires and other attributes can occur many times before a single
                method. They can be also defined directly on parameters.
              </p><table cellpadding="0" cellspacing="0" class="code"><tr><td><pre class="code">
ConnectTrees ([Requires (!tree1.Cyclic ())] tree1 : Graph,
              [Requires (!tree2.Cyclic ())] tree2 : Graph, 
              e : Edge) : Graph 
{ ... }
</pre></td></tr></table><h3><a name="ensures" id="ensures"></a>2.2. Postconditions - Ensures attribute</h3><p>
                Following the same design we can define postconditions which
                method must satisfy. This is an assertion, that must be true
                after execution of method. If method returns a value, then
                symbol <tt class="code">value</tt> is available inside the expression
                stating an assertion.
              </p><table cellpadding="0" cellspacing="0" class="code"><tr><td><pre class="code">
class LinkedList {
  [Ensures (IsEmpty ())]
  public Clear () : void
  { ... }

  [Ensures (value &gt;= 0)]
  public Length () : int
  { ... }
}
</pre></td></tr></table><h3><a name="invariants" id="invariants"></a>2.3. Class invariants - Invariant attribute</h3><p>
                Even more powerful feature is to give a conditions, which
                must be true all the time during execution of program.
                We can attach invariant to any class by writing <tt class="code">Invariant</tt>
                attribute before its definition.
              </p><table cellpadding="0" cellspacing="0" class="code"><tr><td><pre class="code">

[Invariant (position &gt;= 0 &amp;&amp; position &lt;= arr.Length)]
class Vector &lt;T&gt; {
  private mutable position : int = 0;
  private arr : array &lt;T&gt; = array [];

  public push_back (x : T) : void 
  { ... }
</pre></td></tr></table><p>
                This way we can control that our object it in some set of valid
                states.
              </p><p>
                This naturally brings the problem with changing variables,
                which are dependent on each other in invariant. Suppose we have 
                an assertion <tt class="code">x == y + 5</tt>, we cannot change any of the variables.
                Thus we need some mechanism for making transactions, within which
                invariants are temporarily ''turned off''.
              </p><p>
                We follow the design of Spec# and add special construct to expose 
                the object to changes.
              </p><table cellpadding="0" cellspacing="0" class="code"><tr><td><pre class="code">
expose (this) {
  x += 3;
  y += 3;
}
</pre></td></tr></table><p>
                <tt class="code">expose</tt> takes reference to the object to be exposed and
                executes given code.
              </p><p>
                In the matter of fact invariants are not checked all the time during
                execution. It would be too expensive to validate them at any assignment
                or call to external function. We again follow design of Spec# and 
                run assertions at the end of <tt class="code">expose</tt> blocks and after execution
                of all public methods.
              </p><h3><a name="dsc-future" id="dsc-future"></a>2.4. Future work</h3><p>
                There are few more things which we want to implement in more or
                less distant future:
              </p><ul><li> 
                  better syntax for those attributes 
<table cellpadding="0" cellspacing="0" class="code"><tr><td><pre class="code">
class V { 
  invariant pos &gt; 0; 

  Add (x : int) : void 
  requires x &lt; 0; 
  { ... } 
}
</pre></td></tr></table>
                </li><li> 
                  Make these attributes inherited in classes deriving from those decorated
                  with assertions. For example we define an interface with preconditions
                  and postconditions and we can be sure, that every class implementing this
                  interface will comply to them.
                </li><li>
                  Plug theorem prover designed for Spec# into Nemerle, so we can check
                  assertions not only in the runtime, but also statically at compile-time.
                </li><li>
                  Invariant attribute needs much work to follow all functionality of
                  its Spec# counterpart.
                </li></ul><h2><a name="checkedsql" id="checkedsql"></a>3. Compile-time validation of embedded SQL queries</h2><p>
          As for now see 
          <a href="http://nemerle.org/svn/nemerle/trunk/snippets/sql.n">this</a>.
	</p><h2><a name="aspects" id="aspects"></a>4. Aspects-Oriented programming</h2><p>
          As for now see 
          <a href="http://nemerle.org/svn/nemerle/trunk/ncc/testsuite/trace.n">this</a>.
	</p><hr width="90%" size="1" noshade="noshade" /><div class="copyright"><a href="/license.html">Copyright &#xA9;
 2003, 2004 University of Wroclaw</a><br /><a href="http://validator.w3.org/check/referer">Valid XHTML1</a> :: <a href="http://jigsaw.w3.org/css-validator/">Valid CSS2</a></div><a name="bottom-of-page" id="bottom-of-page"></a></body></html>
