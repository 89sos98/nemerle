(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler.Tyvar;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

  module Tyvar
    {
      ref tyvars : Int_map (T);

      store_tv (t : T) : void =
        tyvars <- tyvars.add (t.id, t);
      
      private class T
        {
          name : string;
          ref constraints : list (Type);
          ref is_free : bool;
          ref is_fixed : bool;
          id : int;

          this (n : string)
            {
              this.name <- n;
              this.constraints <- Nil ();
              this.is_free <- false;
              this.is_fixed <- false;
              this.id <- Util.next_id ();
              store_tv (this);
            }

          this (t : T)
            {
              this.name <- t.name;
              this.constraints <- t.constraints;        // to be is_fixed
              this.is_fixed <- true;       // not sure
              this.is_free <- true;
              this.id <- Util.next_id ();
              store_tv (this);
            }

          this ()
            {
              this.id <- Util.next_id ();
              this.name <- "_N_fv" + string_of_int (this.id);
              this.constraints <- Nil ();
              this.is_fixed <- true;       // not sure
              this.is_free <- true;
              store_tv (this);
            }

          add_constraint (ty : Type) : void
            {
              if this.is_fixed then
                Message.error ("this type variable cannot get any new constraints here")
              else ();
              this.constraints <- Cons (ty, this.constraints)
            }
        }

      private class TEnv
        {
          tyvars : String_map (T);
          
          private this (tv : String_map (T))
            {
              this.tyvars <- tv;
            }

          this ()
            {
              this.tyvars <- Map.string_map ();
            }
          
          bind (env : Env, t : PT.Type) : Type
            {
              def f (t : PT.Type) : Type =
                match t with [
                  | PT.T_ref (t) => T_ref (f (t))
                  | PT.T_out (t) => T_out (f (t))
                  | PT.T_fun (x, y) => T_fun (f (x), f (y))
                  | PT.T_void => T_void ()
                  | PT.T_prod (a) => T_prod (List.map (f, a))
                  | PT.T_var (v) =>
                    match this.tyvars.find (v) with [
                      | Some (tv) => T_var (tv)
                      | None =>
                        Message.fatal_error ("unbound type variable `" + v + "'")
                    ]
                  | PT.T_app (n, a) =>
                    def ti = env.lookup_type (n);
                    def len_tp = List.length (ti.typarms);
                    def len_ac = List.length (a);
                    if len_tp == len_ac  then ()
                    else
                      Message.error ("type `" + ti.name + "' takes " +
                                     string_of_int (len_tp) +
                                     " arguments while " +
                                     string_of_int (len_ac) +
                                     " were supplied");
                    def args = List.map (f, a);
                    check_constraints (ti, args);
                    T_app (ti, args)
                ];
              f (t)
            }
          
          add_typarms (env : Env, tp : PT.Typarms) : TEnv * list (T)
            {
              def loop (acc : String_map (T) * list (T), tv : string) : String_map (T) * list (T)
                {
                  def (m, l) = acc;
                  def tv = T (tv);
                  (m.replace (tv.name, tv), Cons (tv, l))
                };
              def (m, l) = List.fold_left (loop, (this.tyvars, Nil ()), tp.tyvars);
              def tenv = TEnv (m);
              def add_constraint (c : PT.Constraint) : void =
                match m.find (c.tyvar) with [
                  | Some (tv) =>
                    tv.add_constraint (tenv.bind (env, c.ty))
                  | None =>
                    Message.error ("unbound type variable `" + c.tyvar + "' in constraint")
                ];
              List.iter (add_constraint, tp.constraints);
              def fixate (tv : T) : void = tv.is_fixed <- true;
              List.iter (fixate, l);
              (tenv, List.rev (l))
            }
        }

      ref global_subst : Subst;

      private lookup (id : int) : T =
        match tyvars.find (id) with [
          | Some (x) => x
          | None => Util.ice ()
        ];

      global_store (s : Subst) : void 
        {
          if global_subst == null then
            global_subst <- Map.int_map () else ();
          def f (s : Subst, id : int, t : Type) : Subst 
            {
              (lookup (id)).is_free <- false;
              s.add (id, t)
            };
          global_subst <- s.fold (f, global_subst)
        }

      global_expand (t : Type) : Type =
        if global_subst == null then t
        else t /- global_subst;
      
      fresh_subst (parms : list (T)) : Subst
        {
          def loop (ctx : Subst * list (T), proto : T) : Subst * list (T)
            {
              def (sub, vars) = ctx;
              def tv = Tyvar.T (proto);
              (sub.add (proto.id, T_var (tv)), Cons (tv, vars))
            };
          def (sub, vars) = List.fold_left (loop, (Map.int_map (), Nil ()), parms);
          def sub_constraints (tv : T) : void =
            tv.constraints <- List.map (fun (t : Type) : Type => t /- sub, tv.constraints);
          List.iter (sub_constraints, vars);
          sub
        }

      free_variable () : Type = T_var (T ());

      is_free (tv : T) : bool = tv.is_free;

      constraints (tv : T) : list (Type) = tv.constraints;

      check_constraints (ti : Tyinfo, args : list (Type)) : void =
        if Tyinfo.can_check_constraints then
          {
            def sub = ti.make_subst (args);
            def check_constraints (tv : T, t : Type) : void
              {
                def check_constraint (c : Type) : void
                  {
                    if t >> (c /- sub) then ()
                    else {
                        Message.error ("typing constraint '" + tv.name + 
                                       " :> " + c.as_string () + " is not satisfied");
                        Message.error ("by " + t.as_string () + " :> " + (c /- sub).as_string ());
                        Message.error (ti.loc, "upon instantiation of " + ti.fullname())
                    };
                  };
                List.iter (check_constraint, constraints (tv))
              };
            List.iter2 (check_constraints, ti.typarms, args)
          }
       else ();

     this ()
       {
         tyvars <- Map.int_map ();
       }

   } // module Tyvar

} // end ns
