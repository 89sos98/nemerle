open Nemerle.Compiler;
open Nemerle.Collections;

namespace Nemerle.Compiler {

  class Treeutil
    {
      fun ('a) decl_walk(tydecl_f : 'a * Type_decl -> 'a,
                         decl_f : 'a * Class_member -> void,
                         ctx : 'a,
                         tydecls : list (Type_decl)) : void =

        letfun do_tydecl(ctx : 'a, decl : Type_decl) : void =
          let ctx' = tydecl_f(ctx, decl) in
          match decl with [
            | TD_class (?ds) => do_decls(ctx', ds)
            | TD_interface (?ds) => do_decls(ctx', ds)
            | TD_variant (?ds) => do_decls(ctx', ds)
            | TD_alias => ()
            | TD_external => ()
          ]
        and do_decls(ctx : 'a, decls : list (Class_member)) : void =
          letfun do_decl (decl : Class_member) : void =
            match decl with [
              | M_type (?t) => do_tydecl(ctx, t)
              | M_variant_option (?ds) => do_decls(ctx, ds)
              | M_iface_method => ()
              | M_function => ()
              | M_field => ()
              | M_value => ()
            ]
          in List.iter(do_decl, decls)
        in
        List.iter(fun (d : Type_decl) : void => tydecl_f(ctx, d), tydecls);
    }

  class Passes
    {
      fun run(decls : list (list (Top_decl))) : void =
        let _ = Env.globals <- Map.string_map() in
        let dd = List.map(Scan_globals.run, List.rev(decls)) in
        let decls = List.concat(dd) in ();
    }

} // N.C
