/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;
using Nemerle.Assertions;
using System.IO;

using Nemerle.Compiler.Typedtree;

using SR = System.Reflection;
using SRE = System.Reflection.Emit;
using PT = Nemerle.Compiler.Parsetree;  

namespace Nemerle.Compiler 
{
  /**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   */
  public class LibraryReferenceException : System.Exception 
  {
  }


  /**
   * LibRefManager for the referenced libraries
   */
  [ManagerAccess]
  class LibraryReferenceManager
  {
    public NameTree : NamespaceTree;

    // a little hack to prevent AddBuildins() calling in NetType
    internal mutable add_buildins : bool = false;
    
    /* -- CONSTRUCTORS ----------------------------------------------------- */
  
    /**
     * constructor. Always load the Framework core library.
     */
    public this (man : ManagerClass, 
                 [NotNull] lib_paths : list [string]) 
    {
      this.NameTree = man.NameTree;
      Manager = man;
      
      def assembly_dir (t) {
        DirectoryOfCodebase (System.Uri(t.Assembly.CodeBase).LocalPath);
      };
      
      // include current directory and directories where 
      // mscorlib.dll, System.dll and Nemerle.dll reside
      _lib_path = System.Environment.CurrentDirectory ::
                  assembly_dir (typeof (Nemerle.Core.AssertionException)) ::
                  assembly_dir (typeof (System.Text.RegularExpressions.Match)) ::
                  assembly_dir (typeof (LibraryReferenceManager)) ::
                  assembly_dir (typeof (System.Object)) :: lib_paths;
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    /**
     * Stores the referenced library for later lookup by the namespaces. Also
     * add transitive closure of libraries needed by given assembly.
     */
    public AddLibrary (name : string) : void 
    {
      def assembly =
        match (name) {
          | "mscorlib" when Manager.Options.UseLoadedCorlib =>
            typeof (System.Object).Assembly
          | "System" when Manager.Options.UseLoadedCorlib =>
            typeof (System.Text.RegularExpressions.Match).Assembly
          | name => LookupAssembly (name)
        };
      if (assembly == null) {
        Message.Error ("cannot find assembly `" + name + "'");
        throw AssemblyFindException ()
      }
      else if (_loaded_assemblies_by_name.Contains (assembly.FullName)) {
        when (_assemblies_loaded_by_hand.Contains (assembly.FullName)
              && !Manager.Options.PersistentLibraries)
          Message.Warning ("assembly `" + name + "' already loaded");
        _assemblies_loaded_by_hand [assembly.FullName] = null;
      } else {
        _assemblies_loaded_by_hand [assembly.FullName] = null;
        AddAssembly (assembly)
      }
    }

    public AddAssembly (assembly : SR.Assembly) : void
    {
      unless (_loaded_assemblies_by_name.Contains (assembly.FullName)) {
        _ = LibraryReference (this, assembly);
        when (AllowLoadingExtensions)
          LoadExtensions ();
        _loaded_assemblies_by_name.Set (assembly.FullName, assembly);
        
        when (Manager.Options.GreedyReferences) {
          def refs = assembly.GetReferencedAssemblies ();
          foreach (name : SR.AssemblyName in refs) {
            def asm =
              try {
                SR.Assembly.Load (name)
              } catch { _ is FileNotFoundException => 
                try {
                  SR.Assembly.LoadFrom (name.CodeBase)
                } catch { _ is System.Exception => 
                  LookupAssembly (name.Name)
                }
              };
            when (asm != null)
              AddAssembly (asm)
          }
        }
      }
    }
      
    public GetExtensionMethods (name : string, env : GlobalEnv) : list [IMethod]
    {
      if (_extension_methods.Contains (name))
        _extension_methods [name].FoldLeft ([], fun (meth, acc) {
          if (env.IsOpenNamespace (meth.DeclaringType.NamespaceNode.Parent))
            meth :: acc
          else acc
        })
      else []
    }
    
    public AddExtensionMethod (m : IMethod) : void
    {
      if (_extension_methods.Contains (m.Name))
        _extension_methods [m.Name] ::= m;
      else
        _extension_methods [m.Name] = [m];
    }

    /**
     * Remove assembly file name from URL returned by Assembly.CodeBase.
     */
    public static DirectoryOfCodebase (mutable path : string) : string
    {
      path = Path.GetDirectoryName (path);

      // hack for mono returning location in the GAC
      def mono_gac = path.IndexOf ("mono/gac");
      path =
        if (mono_gac != -1)
          if (path.LastIndexOf ("Nemerle") > mono_gac)
            path.Substring (0, mono_gac + 5) + "nemerle/"
          else
            if (path.LastIndexOf ("/2.0.") > mono_gac)
              path.Substring (0, mono_gac + 5) + "2.0/"
            else
              path.Substring (0, mono_gac + 5) + "1.0/"
        else path;

      path
    }

    /* -- PRIVATE METHODS -------------------------------------------------- */

    private LookupAssembly (name : string) : SR.Assembly
    {
      def assembly_by_name (path : string) {
        try {
          def ext = Path.GetExtension (path);
          def path =
            match (ext.ToLower ()) {
              | ".dll" | ".exe" => path
              | _ => path + ".dll" 
            }

          if (File.Exists(path))
            SR.Assembly.LoadFrom (path)
          else
            null
        } catch {
          | _ is FileNotFoundException => null
          | _ is System.ArgumentException => null
        };
      };

      match (name) {
        | x when x.IndexOf ('/') != -1 || x.IndexOf ('\\') != -1 =>
          assembly_by_name (x)

        | x when x.IndexOf (',') != -1 =>
          try {
            SR.Assembly.Load (x)
          }
          catch {
            | _ is FileNotFoundException => null
            | _ is System.BadImageFormatException =>
              Message.Error ("passed strong name is invalid or assembly was not found");
              null
          }

        | _ =>
          def lookup (libs) {
            | lib :: libs =>
              def ret = assembly_by_name (Path.Combine (lib, name));
              if (ret == null) lookup (libs)
              else ret
            | [] => null
          };

          lookup (_lib_path);
      }
    }


    private load_macro (lib : SR.Assembly, macro_name : string) : void
    {
      def macro_type = lib.GetType (macro_name.Replace ("&", "\\&"));
      if (macro_type == null) {
        Message.Warning ($"failed to lookup macro `$(macro_name)' in assembly $(lib.FullName)");
      } 
      else {
        def ctor = macro_type.GetConstructor (System.Type.EmptyTypes);
        if (ctor == null) {
          Message.Warning ("failed to lookup constructor in macro `" + macro_name + 
                           "' from assembly " + lib.FullName);
        } 
        else {
          match (ctor.Invoke (null)) {
            | null =>
              Message.Warning ("failed to construct instance of macro `" + macro_name + 
                               "' from assembly " + lib.FullName);
            | casted_macro is IMacro =>
              def ns = casted_macro.GetNamespace ();
              when (namespace_nodes.Get (ns).IsNone)
                _ = cache_namespace_node (ns);

              Manager.MacrosRegistry.RegisterMacro (casted_macro);

            | _ =>
              Message.Warning ("instance of macro `" + macro_name + 
                               "' from assembly " + lib.FullName + 
                               " does not implement IMacro interface");
          }
        }
      }
    }

    public LoadMacrosFrom (lib : SR.Assembly) : void
    {
      // if we already loaded the assembly, then macros are also loaded
      // this might happen when referencing lib, like Nemerle.Macros
      when (_loaded_assemblies_by_name.Contains (lib.FullName))
        Nemerle.Imperative.Return ();
    
//      assert (lib != null);
//      assert (_loaded_assemblies_by_name != null);
      foreach (attribute in lib.GetCustomAttributes (typeof (Nemerle.Internal.ContainsMacroAttribute), false))
      {
        def meth = attribute.GetType ().GetMethod ("GetName");
        def macro_name = (meth.Invoke (attribute, null) :> string);
        load_macro (lib, macro_name)
      }
      foreach (attribute :> Nemerle.Internal.OperatorAttribute
               in lib.GetCustomAttributes (typeof (Nemerle.Internal.OperatorAttribute), false))
      {
        def node = NameTree.ExactPath (NString.Split (attribute.env, '.'));
        def od = OperatorDefinition (node, attribute.name, attribute.left,
                                     attribute.right, attribute.IsUnary);
        Manager.MacrosRegistry.AddOperatorDefinition (od);
      }
    }
    
    
    public LoadMacrosFrom (name : string, strongPart : string = null) : void
    {
      mutable assembly = LookupAssembly (name);
      
      // If assembly not loaded try load it by partial name (may be it in GAC).
      // It's a hack!!! LoadWithPartialName is obsolete!
      when (assembly == null)
        assembly = SR.Assembly.LoadWithPartialName (if (strongPart == null) name else name + strongPart);

      if (assembly == null)
        Message.Error ("cannot load assembly with macros `" + name + "'")
      else
        LoadMacrosFrom (assembly);
    }
      
    
    /* -- PRIVATE VARIABLES ------------------------------------------------ */
    
    /**
     * List of directories we look for assemblies in.
     */
    private _lib_path : list [string];

    private _loaded_assemblies_by_name : Hashtable [string, SR.Assembly] = Hashtable (20);
    
    private _assemblies_loaded_by_hand : Hashtable [string, object] = Hashtable (20);
    
    private namespace_nodes : Hashtable [string, NamespaceTree.Node] = Hashtable (300);
    private mutable _construct_right_away : list [NamespaceTree.Node] = [];
    // extension method name -> list of extension methods
    private _extension_methods : Hashtable [string, list [IMethod]] = Hashtable ();


    /* -- TYPE CACHE ----- */

    internal mutable AllowLoadingExtensions : bool;

    internal LoadExtensions () : void
    {
      foreach (n in _construct_right_away)
        _ = n.LookupValue ();
      _construct_right_away = [];
    }

    internal LoadTypesFrom (lib : LibraryReference) : void
    {
      def assembly = lib.GetAssembly ();
      def types = assembly.GetExportedTypes ();

      when (SystemTypeCache.ExtensionAttribute == null)
        SystemTypeCache.ExtensionAttribute = assembly.GetType ("Nemerle.Internal.ExtensionAttribute");
      when (SystemTypeCache.SQ_ExtensionAttribute == null)
        SystemTypeCache.SQ_ExtensionAttribute = assembly.GetType ("System.Runtime.CompilerServices.ExtensionAttribute");

      mutable i = 0;
      for (; i < types.Length; ++i) {
        def t = types[i];

//        Message.Debug (name);
        def e = ExternalType (t, lib, null);

        def (ns_node, path_to_type) = framework_nesting (t);

        def mainnode = ns_node.Path (path_to_type);

        when (SystemTypeCache.ExtensionAttribute != null &&
              t.IsDefined (SystemTypeCache.ExtensionAttribute, false) ||
              SystemTypeCache.SQ_ExtensionAttribute != null &&
              t.IsDefined (SystemTypeCache.SQ_ExtensionAttribute, false))
          _construct_right_away ::= mainnode;

        mutable tinfo_cache = null;
        
        // check if we have met such type before
        match (mainnode.Value)
        {
          | NotLoaded (x) =>
            tinfo_cache = NamespaceTree.TypeInfoCache.NotLoadedList ([e, x]);

          | NotLoadedList (xs) =>
            tinfo_cache = NamespaceTree.TypeInfoCache.NotLoadedList (e :: xs);

          | _ =>
            tinfo_cache = NamespaceTree.TypeInfoCache.NotLoaded (e);
        }

        // assign wrappers for future loading of typecons
        mainnode.Value = tinfo_cache;
      }
    }

    internal static CacheTypeInfo (t : System.Type, tc : TypeInfo, node : NamespaceTree.Node) : void
    {
      match (node.Value) {
        | NamespaceTree.TypeInfoCache.NotLoaded (e) =>
          e.tycon = tc;

        | NamespaceTree.TypeInfoCache.NotLoadedList (es) =>
          brk: {
            foreach (e in es)
              when (e.system_type.Equals (t)) {
                e.tycon = tc;
                brk ();
              }
          }

        // this happens when we load external protected type in GetInternalType
        // we need to cache to prevent looping
        | NamespaceTree.TypeInfoCache.No =>
          node.Value = NamespaceTree.TypeInfoCache.Cached (tc)

        | NamespaceReference | MacroCall => 
          Util.ice ("wanted to cache in wrong place - value " + t.FullName)
        | Cached | CachedAmbiguous =>
          Util.ice ("wanted to cache cached value " + t.FullName)
      }
    }

    internal static GetInternalType (lib : LibraryReference, t : System.Type,
                              node : NamespaceTree.Node) : TypeInfo
    {
      match (node.Value) {
        | NamespaceTree.TypeInfoCache.Cached (tc) => tc
        | NamespaceTree.TypeInfoCache.No =>
          lib.ConstructTypeInfo (t, node);

        | _ =>
          Util.ice ("not loaded internal type... " + t.Assembly.CodeBase
                    + ":" + t.FullName)
      }
    }

    internal cache_namespace_node (namespc : string) : NamespaceTree.Node
    {
      def nd = NameTree.ExactPath (NString.Split (namespc, array ['.']));
      mutable assigned = nd;
      while (assigned != null) {
        when (assigned.Value is NamespaceTree.TypeInfoCache.No)
          assigned.Value = NamespaceTree.TypeInfoCache.NamespaceReference ();
        assigned = assigned.Parent;
      }
      namespace_nodes.Add (namespc, nd);
      nd
    }

    internal framework_nesting (t : System.Type)
    : NamespaceTree.Node * list [string]
    {
      def loop (t : System.Type, acc) {
        def dt = t.DeclaringType;
        if (dt != null)
          loop (dt, Util.StripGenericMark (dt.Name) :: acc)
        else {
          def namespc = if (t.Namespace != null) t.Namespace else "";
          match (namespace_nodes.Get (namespc)) {
            | Some (nd) => (nd, acc)
            | None =>
              (cache_namespace_node (namespc), acc)
          }
        }
      }
      // workaround mono bug #63768
      if (t.IsPointer) {
        def find_name (acc, t : System.Type) {
          if (t.IsPointer)
            find_name (acc + "*", t.GetElementType ())
          else
            loop (t, [t.Name + acc])
        }
        find_name ("", t)
      } else {
        loop (t, [Util.StripGenericMark (t.Name)])
      }
    }
  }


  [Record]
  public class ExternalType {
    internal system_type : System.Type;
    internal library : LibraryReference;
    internal mutable tycon : TypeInfo;

    internal ConstructTypeInfo (node : NamespaceTree.Node, fix_node : bool) : void {
      when (tycon == null)
        tycon = library.ConstructTypeInfo (system_type, node);
      when (fix_node)
        node.Value = NamespaceTree.TypeInfoCache.Cached (tycon);
    }
  }

  /**
   * This class stores information extracted from a referenced external library.
   */
  [ManagerAccess]
  public class LibraryReference
  {
    /**
     * The assembly associated with this object
     */
    private mutable _library : SR.Assembly;

    /**
     * The location of this library
     */
    private mutable _location : Location;
    
    /**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     */
    internal mutable _is_generated_by_nemerle : bool;

    
    internal LibRefManager : LibraryReferenceManager;

    /**
     * Load an assembly. Extracts and processes the custom attributes array.
     */
    internal this (mgr : LibraryReferenceManager, assembly : SR.Assembly) 
    {
      LibRefManager = mgr;
      Manager = mgr.Manager;
      _library = assembly;
      _location = Location (Location.GetFileIndex (
        System.Uri (assembly.CodeBase).LocalPath), 0, 0);

      // Scans the assembly custom attributes looking for something interesting...
      foreach (x :> SR.AssemblyConfigurationAttribute in
               _library.GetCustomAttributes (
               typeof (SR.AssemblyConfigurationAttribute), false))
      {
        _is_generated_by_nemerle = _is_generated_by_nemerle 
          || x.Configuration == "ContainsNemerleTypes";
      }

      LibRefManager.LoadTypesFrom (this);
      LibRefManager.LoadMacrosFrom (_library);
    }


    /**
     * Turns a Framework type into something edible by Nemerle's type system
     */
    internal TypeOfType (_tenv : Map [string, StaticTyVar],
                         framework_type : System.Type) : MType
    {
      // Message.Debug (framework_type.ToString ());
      if (framework_type.Equals (SystemTypeCache.Void))
        InternalType.Void
      else
        if (framework_type.IsArray)
          MType.Array (TypeOfType (_tenv, framework_type.GetElementType ()),
                       framework_type.GetArrayRank ())
        else 
          if (framework_type.IsByRef) {
            Message.Error ($ "ref type referenced $framework_type");
            TypeOfType (_tenv, framework_type.GetElementType ())
          }
          else if (framework_type.IsGenericParameter) {
            match (_tenv.Find (framework_type.Name)) {
              | Some (tv) => MType.TyVarRef (tv)
              | None =>
//                _tenv.Iter (fun (x,y) { Message.Debug ($"$x - $y") });
                Util.ice ($"$framework_type from $(framework_type.DeclaringType)")
            }
          }
          else {
            def tc = TypeInfoOfType (framework_type);
//            Message.Debug ($"tinfo $tc contains generic framework_type.ToString ());
            def parms = 
              if (framework_type.IsGenericType)
                List.MapFromArray (framework_type.GetGenericArguments (),
                                   fun (t) { TypeOfType (_tenv, t) });
              else
                [];

            if (framework_type.Namespace == "Nemerle.Builtins") {
              def make_tupl (l) {
                | [x] => x
                | [] => InternalType.Void
                | _ => MType.Tuple (l)
              }

              if (tc.Name == "Tuple")
                MType.Tuple (parms)
              else if (tc.Name == "FunctionVoid")
                MType.Fun (make_tupl (parms), InternalType.Void)
              else {
                def (front, last) = parms.DivideLast ();
                MType.Fun (make_tupl (front), last)
              }
            }
            else
              MType.Class (tc, parms);
          }
    } 

    internal TypeInfoOfType (framework_type : System.Type) : TypeInfo
    {
      def (ns_node, path_to_type) =
        LibRefManager.framework_nesting (framework_type);
      def ns_node = ns_node.Path (path_to_type);

      match (ns_node.LookupType ([], framework_type.GetGenericArguments ().Length)) {
        | Some (tc) => tc
          // protected external types are not fetched automatically from external assembly
          // so sometimes we must load them by hand
        | None => LibraryReferenceManager.GetInternalType (this, framework_type, ns_node)
      }
    } 

    internal GetAssembly () : SR.Assembly
    {
      this._library
    }
    
    /**
     * Construct TypeInfo object from given type in current assembly.
     */
    internal ConstructTypeInfo (reflected_type : System.Type,
                                ns_node : NamespaceTree.Node) : TypeInfo
    {
      if (_is_generated_by_nemerle &&
          // we could use IsDefined, after fixing bug http://bugzilla.ximian.com/show_bug.cgi?id=76150
          reflected_type.GetCustomAttributes (SystemTypeCache.NemerleAttribute, false).Length > 0)
        NetTypeInfo (this, reflected_type, ns_node)
      else
        NetType (this, reflected_type, ns_node)
    }

    /**
     * Looks for type named [name] that is internal to current assembly. Used
     * by type attribute decoder.
     */
    internal LookupInternalType (name : string) : option [TypeInfo]
    {
    //  Message.Debug ($"looking `$(name)'");
      def st = _library.GetType (name);
      if (st == null)
        None ()
      else {
        def (ns_node, path_to_type) = LibRefManager.framework_nesting (st);
        def ns = ns_node.Path (path_to_type);
        Some (LibraryReferenceManager.GetInternalType (this, st, ns))
      }
    }

    private MethodOfMethodInfo (tenv : Map [string, StaticTyVar], meth : SR.MethodInfo) : MethodInfo
    {
      if (meth == null)
        null
      else
        MethodInfo (tenv, this, meth)
    }



    /* -----------------------------------------------------------------
     * .NET types
     * ----------------------------------------------------------------- 
     */
    internal class NetType : TypeInfo
    {
      protected library : LibraryReference;
      protected attributes : NemerleAttributes;

      internal tenv : Map [string, StaticTyVar] = Map ();
      protected direct_supertypes : list [MType.Class];
      protected supertypes : list [MType.Class];
      protected supertype_map : Map [TypeInfo, MType.Class] = Map ();

      mutable implicit_conversion_initialized : bool;

      public this (lib : LibraryReference, h : System.Type, ns_node : NamespaceTree.Node)
      {
        base (ns_node, lib.Manager);
        
        // first cache ourself to avoid loops
        LibraryReferenceManager.CacheTypeInfo (h, this, ns_node);
        library = lib;
        system_type = h;

        when (system_type.DeclaringType != null)
          tenv = (lib.TypeInfoOfType (system_type.DeclaringType) :> NetType).tenv;

        // init typarms and self_type
        (typarms, tenv, direct_supertypes, supertypes) =
          TyCodec.ReflectTypeBuilder (library, tenv, system_type);

        when (h.Namespace == "Nemerle.Builtins" && h.Name.StartsWith ("Array")) {
          direct_supertypes = [InternalType.Array];
          supertypes ::= InternalType.Array;
        }

        foreach (t in supertypes)
          supertype_map = supertype_map.Add (t.tycon, t);

        fullname = Util.StripGenericMark (system_type.FullName.Replace ('+', '.'));
          
        def parms = List.Map (typarms, fun (x) { MType.TyVarRef (x) });
        self_type = MType.Class (this, parms);
        
        attributes = NemerleAttributes.None;

        when (system_type.IsAbstract) attributes |= NemerleAttributes.Abstract;
        when (system_type.IsSealed)   attributes |= NemerleAttributes.Sealed;
        when (system_type.IsValueType) attributes |= NemerleAttributes.Struct;

        if (system_type.DeclaringType == null) {
          if (system_type.IsPublic) attributes |= NemerleAttributes.Public
          else attributes |= NemerleAttributes.Internal;
        } else {
          when (system_type.IsNestedPrivate)  attributes |= NemerleAttributes.Private;
          when (system_type.IsNestedPublic)   attributes |= NemerleAttributes.Public;
          when (system_type.IsNestedFamily)   attributes |= NemerleAttributes.Protected;
          when (system_type.IsNestedAssembly) attributes |= NemerleAttributes.Internal;
        }

        def attrs = system_type.GetCustomAttributes (
                      SystemTypeCache.Reflection_DefaultMemberAttribute, true);
        default_indexer =
          if (attrs.Length > 0) {
            def dma = attrs [0] :> System.Reflection.DefaultMemberAttribute;
            Some (dma.MemberName)
          } else
            // there can be indexer in the base type, let DefaultIndexer
            // property handle it
            null;
        
        when (lib.LibRefManager.add_buildins) AddBuiltins ();
//        else Message.Debug ($"omiititng $FullName");

        decode_extension_methods (lib.LibRefManager, SystemTypeCache.ExtensionAttribute);
        decode_extension_methods (lib.LibRefManager, SystemTypeCache.SQ_ExtensionAttribute);
      }

      #region Special numeric overloads
      variant NumericKind
      {
        | Signed
        | Unsigned
        | Float
        | Char
      }

      static numeric_types : Hashtable [string, NumericKind];
      
      static this ()
      {
        numeric_types = Hashtable ();
        numeric_types.Add ("SByte", NumericKind.Signed ());
        numeric_types.Add ("Int16", NumericKind.Signed ());
        numeric_types.Add ("Int32", NumericKind.Signed ());
        numeric_types.Add ("Int64", NumericKind.Signed ());
        numeric_types.Add ("Byte", NumericKind.Unsigned ());
        numeric_types.Add ("UInt16", NumericKind.Unsigned ());
        numeric_types.Add ("UInt32", NumericKind.Unsigned ());
        numeric_types.Add ("UInt64", NumericKind.Unsigned ());
        numeric_types.Add ("Single", NumericKind.Float ());
        numeric_types.Add ("Double", NumericKind.Float ());
        numeric_types.Add ("Char", NumericKind.Char ()); 
      }

     
      FixupEquality (name : string) : void
      {
        FixupCompare (name);
        #if 0
        match (special_members [name]) {
          | [elem : IMethod] =>
            def tv = StaticTyVar ("'a");
            tv.Constraints = [];
            def hd = elem.GetHeader ();
            hd.typarms = [tv];
            match (hd.parms) {
              | [parm1, parm2] =>
                parm1.ty = MType.TyVarRef (tv);
                parm2.ty = MType.TyVarRef (tv);
              | _ => assert (false)
            }
          | _ => assert (false)
        }
        #endif
      }

      FixupShift (name : string) : void
      {
        match (special_members [name]) {
          | [elem is IMethod] =>
            match (elem.GetParameters ()) {
              | [_, parm2] =>
                assert (InternalType.Int32 != null);
                parm2.ty = InternalType.Int32;
              | _ => assert (false)
            }
          | _ => assert (false)
        }
      }

      AddConversions () : void
      {
        mutable is_numeric = true;
        def name = system_type.Name;
        
        def targets =
          if (!system_type.IsPrimitive) {
            is_numeric = false;
            []
          } else
            match (name) {
              | "SByte" => ["Int16", "Int32", "Int64", "Single", "Double"]
              | "Int16" => ["Int32", "Int64", "Single", "Double"]
              | "Int32" => ["Int64", "Single", "Double"]
              | "Int64" => ["Single", "Double"]
              
              | "Byte" => 
                ["Int16", "Int32", "Int64", "UInt16", "UInt32", "UInt64", 
                 "Single", "Double"]
              | "UInt16" => 
                ["Int32", "Int64", "UInt32", "UInt64", "Single", "Double"]
              | "UInt32" => ["Int64", "UInt64", "Single", "Double"]
              | "UInt64" => ["Single", "Double"]
              
              | "Single" => ["Double"]
              | "Double" => []
              | "Char" => []
              | _ =>
                is_numeric = false;
                []
            }

        when (is_numeric) {
          foreach (target in targets) {
            def t = library.LibRefManager.NameTree.LookupInternalType (["System", target]);
            AddConversion ("op_Implicit", t);
          }

          // add remaining as explicit
          def numeric_types =
            array ["SByte", "Int16", "Int32", "Int64", "Byte", "UInt16", "UInt32", 
             "UInt64", "Single", "Double", "Char"];

          foreach (target in numeric_types) {
            when (name != target && ! List.Contains (targets, target)) {
              def t = library.LibRefManager.NameTree.LookupInternalType (["System", target]);
              AddConversion ("op_Explicit", t);
            }
          }
        }
      }

      internal AddBuiltins () : void
      {
        InitBuiltinMembers ();
        when (system_type.IsPrimitive || system_type.Equals (SystemTypeCache.Object) ||
              system_type.Equals (SystemTypeCache.String)) {
          def name = system_type.Name;
          if (name == "String") {
            // == and != are surprisingly properly overloaded
            // and this is done in LookupMemberImpl, because otherwise
            // we would use uninitialized InternalType.String_Concat
            // AddBuiltin ("op_Addition", InternalType.String_Concat);
          } else if (name == "Boolean") {
            AddBuiltin ("op_LogicalNot", "bool.!");
            MakeSingleParm ("op_LogicalNot");
            AddBuiltin ("op_Equality", "==");
            AddBuiltin ("op_Inequality", "!=");
            // FixupEquality not needed here -- return type is already correct
            // and InternalType.Boolean is here null
          } else if (name == "Object") {
            AddBuiltin ("op_Equality", "==.ref");
            AddBuiltin ("op_Inequality", "!=.ref");
            FixupEquality ("op_Equality");
            FixupEquality ("op_Inequality");
          } else if (numeric_types.Contains (name)) {
            def kind = numeric_types [name];
            def suff =
              match (kind) {
                | NumericKind.Float => ".f"
                | NumericKind.Char
                | NumericKind.Signed => ".s"
                | NumericKind.Unsigned => ".u"
              }
            def is_small_type =
              name == "SByte" || name == "Byte" ||
              name == "Int16" || name == "UInt16";

            unless (kind is NumericKind.Char) {
              // checked/unchecked:
              AddBuiltin ("op_Addition", "+" + suff, "+.f");
              AddBuiltin ("op_Subtraction", "-" + suff, "-.f");
              AddBuiltin ("op_Multiply", "*" + suff, "*.f");
              
              // no checked version:
              AddBuiltin ("op_Division", "/" + suff);
              AddBuiltin ("op_Modulus", "%" + suff);

              // unary
              AddBuiltin ("op_UnaryPlus", "unary.+" + suff);
              MakeSingleParm ("op_UnaryPlus");

              when (is_small_type) {
                ForceIntType ("op_Addition");
                ForceIntType ("op_Subtraction");
                ForceIntType ("op_Multiply");
                ForceIntType ("op_Division");
                ForceIntType ("op_Modulus");
                ForceIntType ("op_UnaryPlus");
              }

              def one_size =
                if (name == "Int64" || name == "UInt64")
                  "i8"
                else if (name == "Float")
                  "r4"
                else if (name == "Double")
                  "r8"
                else
                  "i4";

              def incdec_suff =
                match (name) {
                  | "Byte" => ".u.i1"
                  | "SByte" => ".s.i1"
                  | "Int16" => ".s.i2"
                  | "UInt16" => ".u.i2"
                  | _ => suff
                }

              AddBuiltin ("op_Increment", "++." + one_size + incdec_suff, 
                                          "++." + one_size + ".f");
              AddBuiltin ("op_Decrement", "--." + one_size + incdec_suff, 
                                          "--." + one_size + ".f");
              MakeSingleParm ("op_Increment");
              MakeSingleParm ("op_Decrement");
            }

            when (kind is NumericKind.Signed ||
                  kind is NumericKind.Unsigned) {
              AddBuiltin ("op_BitwiseAnd", "&" + suff);
              AddBuiltin ("op_BitwiseOr", "|" + suff);
              AddBuiltin ("op_ExclusiveOr", "^" + suff);
              
              AddBuiltin ("op_LeftShift", "<<" + suff);
              AddBuiltin ("op_RightShift", ">>" + suff);
              when (Name != "Int32") {
                FixupShift ("op_LeftShift");
                FixupShift ("op_RightShift");
              }
              when (is_small_type) {
                ForceIntType ("op_LeftShift");
                ForceIntType ("op_RightShift");
                ForceIntType ("op_BitwiseAnd");
                ForceIntType ("op_BitwiseOr");
                ForceIntType ("op_ExclusiveOr");
              }
              
              AddBuiltin ("op_OnesComplement", "unary.~" + suff);
              MakeSingleParm ("op_OnesComplement");
              when (is_small_type)
                ForceIntType ("op_OnesComplement");
            }

            unless (kind is NumericKind.Unsigned || 
                    kind is NumericKind.Char) {
              AddBuiltin ("op_UnaryNegation", "unary.-" + suff, "unary.-.f");
              MakeSingleParm ("op_UnaryNegation");
              when (is_small_type)
                ForceIntType ("op_UnaryNegation");
            }

            // comparisions
            AddBuiltin ("op_Equality", "==");
            AddBuiltin ("op_Inequality", "!=");
            AddBuiltin ("op_LessThan", "<" + suff);
            AddBuiltin ("op_LessThanOrEqual", "<=" + suff);
            AddBuiltin ("op_GreaterThan", ">" + suff);
            AddBuiltin ("op_GreaterThanOrEqual", ">=" + suff);

            FixupCompare ("op_Equality");
            FixupCompare ("op_Inequality");
            FixupCompare ("op_LessThan");
            FixupCompare ("op_LessThanOrEqual");
            FixupCompare ("op_GreaterThan");
            FixupCompare ("op_GreaterThanOrEqual");
          } else {}
        }
      }
      #endregion

      /** Checks if underlying .NET type is value type */
      public override IsValueType : bool {
        get { system_type.IsValueType }
      }

      public override IsInterface : bool {
        get { system_type.IsInterface }
      }
      
      public override MemberType : MemberTypes
      { get { system_type.MemberType } }

      public override Name : string
      {
        [Nemerle.Memoize (InvalidValue = null)]
        get { Util.StripGenericMark (system_type.Name) }
      }
      
      internal override GetLibraryReference () : LibraryReference
      { library }

      public override IsSealed : bool
      { get { system_type.IsSealed } }
      
      public override IsDelegate : bool
      {
        [Nemerle.Memoize]
        get { system_type.IsSubclassOf (SystemTypeCache.MulticastDelegate) }
      }

      public override GetConstantObject () : IField
      {
        null
      }

      public override DeclaringType : TypeInfo
      {
        [Nemerle.Memoize]
        get {
          if (system_type.DeclaringType == null)
            null
          else
            library.TypeInfoOfType (system_type.DeclaringType)
        }
      }
      
      public override Location : Location
      {
        get { library._location }
      }

      public override Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public override GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }

      public override AttributeTargets : System.AttributeTargets
      {
        get {
          def usage = system_type.GetCustomAttributes (typeof (System.AttributeUsageAttribute), false);
          if (usage.Length > 0) {
            assert (usage.Length == 1);
            (usage[0] :> System.AttributeUsageAttribute).ValidOn
          }
          else
            System.AttributeTargets.All
        }
      }
      
      public override HasAttribute (attribute : TypeInfo) : bool
      {
        def t = attribute.SystemType;
        system_type.IsDefined (t, false)
      }
      
      public override Accessibility : Accessibility
      {
        get {
          match (system_type.Attributes %& SR.TypeAttributes.VisibilityMask) {
            | SR.TypeAttributes.NestedAssembly => Accessibility.Internal
            | SR.TypeAttributes.NestedFamANDAssem => Accessibility.ProtectedAndInternal
            | SR.TypeAttributes.NestedFamily => Accessibility.Protected
            | SR.TypeAttributes.NestedFamORAssem => Accessibility.ProtectedOrInternal
            | SR.TypeAttributes.Public
            | SR.TypeAttributes.NestedPublic => Accessibility.Public
            | SR.TypeAttributes.NestedPrivate              
            | SR.TypeAttributes.NotPublic => Accessibility.Private
            | _ => Util.ice ("system type returned invalid attributes")
          }
        }
      }

      public override IsExternallyAccessible : bool
      {
        // if it wasn't, we wouldn't have reflected it?
        get { true }
      }
      
      public override HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }
      
      public override GetTydecl () : TypeDeclaration
      {
        if (system_type.IsInterface)
          TypeDeclaration.Interface ()
        else if (system_type.IsEnum)
          TypeDeclaration.Enum ()
        else
          TypeDeclaration.Class ()
      }

      public override GetSuperTypes () : list [MType.Class]
      {
        supertypes
      }

      public override GetDirectSuperTypes () : list [MType.Class]
      {
        direct_supertypes
      }
      
      public override SuperType (tc : TypeInfo) : option [list [MType]]
      {
        if (tc : object == this)
          Some (Solver.FixedValues (self_type.args))
        else if (tc : object == InternalType.Object_tc) Some ([])
        else
          match (supertype_map.Find (tc)) {
            | Some (ti) => Some (Solver.FixedValues (ti.args))
            | None => None ()
          }
      }

      internal override SubtypingSubst (tc : TypeInfo) : Subst
      {
        if (this.Equals (tc))
          Subst (Manager) // current type, no substitution
        else
          tc.MakeSubst1 (Option.UnSome (SuperType (tc)));
      }

      public override BaseType : TypeInfo
      {
        [Nemerle.Memoize]
        get {
          if (system_type.BaseType == null) null
          else library.TypeInfoOfType (system_type.BaseType)
        }
      }
      
      public override SuperClass () : option [TypeInfo]
      {
        match (direct_supertypes) {
          | MType.Class (tc, _) :: _ => Some (tc)
          | [] => None ()
          | _ => Util.ice ()
        }
      }

      public override GetMembers () : list [IMember]
      {
        LookupMemberImpl ("")
      }
      
      public override GetMembers (bindingAttr : BindingFlags) : list [IMember]
      {
        def check (x : IMember) {
          if (bindingAttr %&& BindingFlags.DeclaredOnly)
            this.Equals (x.DeclaringType) &&
            TypeBuilder.constrain_member (x, bindingAttr)
          else
            TypeBuilder.constrain_member (x, bindingAttr)
        };
        List.RevFilter (GetMembers (), check)
      }

      public override GetFields (bindingAttr : BindingFlags) : list [IField] 
      {
        List.FoldLeft (GetMembers (bindingAttr), [], fun (x : IMember, acc) {
          if (TypeBuilder.constrain_member (x, bindingAttr))
            match (x) {
              | f is IField => f :: acc
              | _ => acc
            }
          else acc
        })
      }

      public override GetConstructors (bindingAttr : BindingFlags) : list [IMethod] 
      {
        List.FoldLeft (GetMembers (bindingAttr), [], fun (x : IMember, acc) {
          if (TypeBuilder.constrain_member (x, bindingAttr))
            match (x.GetKind ()) {
              | MemberKind.Method (m) =>
                match (m.GetFunKind ()) {
                  | FunKind.Constructor | FunKind.StaticConstructor => m :: acc
                  | _ => acc
                }
              | _ => acc
            }
          else acc
        })
      }
      
      private static is_internal (m : SR.MemberInfo) : bool
      {
        def x = m.MemberType;
        if (x %&& (MemberTypes.Constructor | MemberTypes.Method)) 
        {
          def meth = m :> SR.MethodBase;
          meth.IsPrivate || meth.IsAssembly || meth.IsFamilyAndAssembly ||
          meth.CallingConvention == SR.CallingConventions.VarArgs
        } 
        else if (x %&& MemberTypes.Field) 
        {
          def field = m :> SR.FieldInfo;
          field.IsPrivate || field.IsAssembly || field.IsFamilyAndAssembly
        } 
        else if (x %&& MemberTypes.Property) 
        {
          def prop = m :> SR.PropertyInfo;
          def accessors = prop.GetAccessors (true);
          def propMeth = NArray.Fold (accessors, null, fun (x : SR.MethodInfo, acc) { 
            if (x == null || x.IsPrivate || x.IsAssembly || x.IsFamilyAndAssembly) acc 
            else x
          });
          propMeth == null
        }
        else if (x %&& MemberTypes.NestedType) 
        {
          def ty = m :> System.Type;
          ty.IsNestedAssembly || ty.IsNestedPrivate || ty.IsNestedFamANDAssem
        }
        else if (x %&& MemberTypes.Event) 
        {
          // we lookup nonpublic method here, because it can be protected and we want to
          // access it from derived class
          // (I just hope it won't trigger any authorization exceptions)
          def evMeth = (m :> SR.EventInfo).GetAddMethod (true);
          evMeth == null || evMeth.IsPrivate || evMeth.IsAssembly || evMeth.IsFamilyAndAssembly
        } 
        else true
      }

      protected imember_of_memberinfo (m : SR.MemberInfo) : IMember
      {
        match (m.MemberType) {
          | MemberTypes.Constructor 
          | MemberTypes.Method => MethodInfo (tenv, library, m :> SR.MethodBase) : IMember
          | MemberTypes.Field => FieldInfo (tenv, library, m :> SR.FieldInfo)
          | MemberTypes.Property => NetProperty (tenv, library, m :> SR.PropertyInfo)
          | MemberTypes.Event => NetEvent (library, m :> SR.EventInfo)
          | MemberTypes.NestedType => library.TypeInfoOfType (m :> System.Type)
          | _ => null
        }
      }

      private collect_members () : void
      {
        member_map = Hashtable ();
        
        def flags = SR.BindingFlags.Public     |
                    SR.BindingFlags.NonPublic  |
                    SR.BindingFlags.Static     |
                    SR.BindingFlags.Instance   |
                    SR.BindingFlags.DeclaredOnly;

        def member_array = system_type.GetMembers (flags);

        //Message.Debug ($"{collect_members, '$name' in $this len=$(member_array.Length)");
        mutable collected_now = [];

        for (mutable i = member_array.Length - 1; i >= 0; i--) {
          def m = member_array [i];
//          Message.Debug ($"adding $m from $this $(this.GetHashCode ())");
          if (is_internal (m)) {}
          else {
//            Message.Debug ($ "add_member: $m to $(this) [$(GetHashCode ())]");
            match (imember_of_memberinfo (m)) {
              | null => ()
              | r =>
//                    Message.Debug ($ "add_member: $r to $(this) [$(GetHashCode ())]");
                collected_now ::= r;
                add_member_by_name (r);
            }
          }
        }

        def res =
          if (IsInterface) {
            def supertypes = GetDirectSuperTypes ();
            (if (supertypes.IsEmpty)
               [InternalType.Object_tc.GetMembers ()]
             else
               supertypes.Map (fun (t) { t.tycon.GetMembers () }))
            + [collected_now]
          } else
            match (SuperClass ()) {
              | Some (ti) => [ti.GetMembers (), collected_now]
              | None => [collected_now]
            }
        collected_now = RemoveHiddenMembers (res);

        member_map [""] = collected_now;
     }

      public override LookupMemberImpl (name : string) : list [IMember] 
      {
        if (this.Equals (InternalType.String_tc) && 
            name == "op_Addition") {
          assert (InternalType.String_Concat != null);
          AddBuiltin ("op_Addition", InternalType.String_Concat);
          LookupMember (name)
        } else if (!implicit_conversion_initialized && 
                   (name == "op_Implicit" || name == "op_Explicit")) {
          implicit_conversion_initialized = true;
          AddConversions ();
          LookupMember (name)
        } else {
          when (member_map == null)
            collect_members ();

          if (member_map.Contains (name))
            member_map [name]
          else {
            member_map [name] = [];
            []
          }
        }
      }

      public override CanAccess (source : TypeInfo) : bool
      {
        system_type.IsPublic || system_type.IsNestedPublic ||
          (system_type.DeclaringType != null &&
           Option.IsSome (source.SuperType (DeclaringType)) &&
           (system_type.IsNestedFamily || system_type.IsNestedFamORAssem))
      }

      public override UnderlyingType : TypeInfo
      {
        [Nemerle.Memoize (InvalidValue = null)]
        get {
          assert (system_type.IsEnum);
          library.TypeInfoOfType (system_type.GetField ("value__").FieldType)
        }
      }

      decode_extension_methods (mgr : LibraryReferenceManager, t : System.Type) : void
      {
        when (t != null) {
          when (system_type.IsDefined (t, false)) {
            foreach (m is IMethod in GetMembers ())
              when (m.IsStatic && m.GetHandle ().IsDefined (t, false))
                mgr.AddExtensionMethod (m);
          }
        }
      }
    }
   
    [ManagerAccess (library.Manager)]
    private class FieldInfo : IField
    {
      protected handle : SR.FieldInfo;
      protected library : LibraryReference;
      protected id : int;
      protected mutable tt_type : MType;
      protected mutable attributes : NemerleAttributes;

      public this (tenv : Map [string, StaticTyVar], lib : LibraryReference,
                   h : SR.FieldInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
       
        tt_type = library.TypeOfType (tenv, handle.FieldType);
        set_attributes ();
      }

      set_attributes () : void
      {
        attributes = NemerleAttributes.None;
        when (!handle.IsInitOnly) attributes |= NemerleAttributes.Mutable;
        when (handle.IsStatic)    attributes |= NemerleAttributes.Static;
       
        when (handle.IsPrivate)  attributes |= NemerleAttributes.Private;
        when (handle.IsPublic)   attributes |= NemerleAttributes.Public;
        when (handle.IsFamily)   attributes |= NemerleAttributes.Protected;
        when (handle.IsAssembly) attributes |= NemerleAttributes.Internal;
        when (handle.IsFamilyAndAssembly) attributes |=
          NemerleAttributes.Internal %| NemerleAttributes.Protected;
      }

      public DeclaringType : TypeInfo
      {
        [Nemerle.Memoize (InvalidValue = null)]
        get {
          library.TypeInfoOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public override ToString () : string
      {
        MemberBuilder.DescribeMember (this)
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Field }
      }

      public GetFieldInfo () : SR.FieldInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : MType
      {
        tt_type
      }
      
      [Nemerle.OverrideObjectEquals]
      public Equals (o : IMember) : bool
      {
        //Message.Debug ($ "$(this).Equals($o)");
        GetHashCode () == o.GetHashCode ()
      }

      public GetKind () : MemberKind
      {
        MemberKind.Field (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }

      public IsStatic : bool
      {
        get { handle.IsStatic }
      }

      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }

      public HasBeenAssigned : bool
      {
        get { true }
        set { ignore (value) }
      }
      
      public IsLiteral : bool
      {
        get { handle.IsLiteral }
      }

      public GetValue () : Literal
      {
        assert (IsLiteral);
        def fval = handle.GetValue (null);
        def lit = 
          match (fval) {
            | val is ulong => Literal.Integer (val, false, null).WithProperType ()
            | val is double => Literal.Double (val)
            | val is float => Literal.Float (val)
            | val is string => Literal.String (val)
            | val is char => Literal.Char (val)
            | val is bool => Literal.Bool (val)
            | val =>
              def val = System.Convert.ToInt64 (val);
              if (val == long.MinValue)
                Literal.Integer (0x8000000000000000UL, true, InternalType.Int64)
              else
                Literal.Integer (System.Math.Abs (val) :> ulong, val < 0, null).WithProperType ()
          }
        if (handle.FieldType.IsEnum)
          Literal.Enum (lit :> Literal.Integer, library.TypeInfoOfType (handle.DeclaringType))
        else
          lit
      }

      public override GetHashCode () : int
      {
        id
      }

      public IsMutable : bool
      {
        get
        {
          // shouldn't we use InternalType here?
          !handle.IsInitOnly && 
          !handle.IsDefined (typeof (Nemerle.Internal.ImmutableAttribute), false)
        }
      }

      public IsVolatile : bool
      {
        get
        {
          handle.IsDefined (typeof (System.Runtime.CompilerServices.IsVolatile), false) ||
          handle.IsDefined (typeof (Nemerle.Internal.VolatileModifier), false);
        }
      }
      
      public CanAccess (source : TypeInfo) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (DeclaringType)) &&
           (handle.IsFamily || handle.IsFamilyOrAssembly))
      }
    }

    [ManagerAccess (library.Manager)]
    class NetEvent : IEvent
    {
      protected handle : SR.EventInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected adder : MethodInfo;
      protected remover : MethodInfo;
      protected mutable mem_type : MType;

      public this (lib : LibraryReference, h : SR.EventInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        
        def add_method = handle.GetAddMethod (true);
        def remove_method = handle.GetRemoveMethod (true);

        is_static =
          (add_method != null && add_method.IsStatic) ||
          (remove_method != null && remove_method.IsStatic);

        def tenv = (DeclaringType :> NetType).tenv;
        adder = library.MethodOfMethodInfo (tenv, add_method);
        remover = library.MethodOfMethodInfo (tenv, remove_method);

        assert (adder != null);
        assert (remover != null);

        match (adder.GetMemType ()) {
          | MType.Fun (t, _) => mem_type = t.FixedValue
          | _ => assert (false)
        }
      }

      public DeclaringType : TypeInfo
      {
        [Nemerle.Memoize (InvalidValue = null)]
        get {
          library.TypeInfoOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public override ToString () : string
      {
        MemberBuilder.DescribeMember (this)
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Event }
      }

      public GetAdder () : IMethod
      {
        adder
      }

      public GetRemover () : IMethod
      {
        remover
      }

      public GetEventInfo () : SR.EventInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : MType
      {
        mem_type
      }

      [Nemerle.OverrideObjectEquals]
      public Equals (o : IMember) : bool
      {
        GetHashCode () == o.GetHashCode ()
      }

      public GetKind () : MemberKind
      {
        MemberKind.Event (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { adder.Attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }

      public IsStatic : bool
      {
        get { is_static }
      }

      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }
      
      public override GetHashCode () : int
      {
        id
      }

      public CanAccess (_source : TypeInfo) : bool
      {
        // FIXME: this is broken... we need to check method attributes
        true
      }
    }
    
    [ManagerAccess (library.Manager)]
    class NetProperty : IProperty
    {
      protected handle : SR.PropertyInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected getter : MethodInfo;
      protected setter : MethodInfo;
      protected any_method : MethodInfo;
      protected mutable mem_type : MType;

      public this (tenv : Map [string, StaticTyVar], lib : LibraryReference, h : SR.PropertyInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        
        def get_method = handle.GetGetMethod (true);
        def set_method = handle.GetSetMethod (true);

        getter = library.MethodOfMethodInfo (tenv, get_method);
        setter = library.MethodOfMethodInfo (tenv, set_method);

        if (getter == null)
          any_method = setter;
        else
          any_method = getter;

        assert (any_method != null);

        is_static = any_method.Attributes %&& NemerleAttributes.Static;
        
        def ret_type = library.TypeOfType (tenv, handle.PropertyType);

        def (args, ret_type) =
          if (getter != null)
            match (getter.GetMemType ()) {
              | MType.Fun (t, r) =>
                (t.FixedValue.GetFunctionArguments (), r.FixedValue)
              | _ => assert (false)
            }
          else if (setter != null)
            match (setter.GetMemType ()) {
              | MType.Fun (t, _) =>
                def (args, r) = List.DivideLast (t.FixedValue.GetFunctionArguments ());
                (args, r)
              | _ => assert (false)
            }
          else
            ([], ret_type);

        if (args.IsEmpty)
          mem_type = ret_type
        else
          mem_type = MType.ConstructFunctionType (args, ret_type);
      }

      public DeclaringType : TypeInfo
      {
        [Nemerle.Memoize (InvalidValue = null)]
        get {
          library.TypeInfoOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Property }
      }

      public override ToString () : string
      {
        MemberBuilder.DescribeMember (this)
      }

      public GetGetter () : IMethod
      {
        getter
      }

      public GetSetter () : IMethod
      {
        setter
      }

      public GetPropertyInfo () : SR.PropertyInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : MType
      {
        mem_type
      }

      [Nemerle.OverrideObjectEquals]
      public Equals (o : IMember) : bool
      {
        GetHashCode () == o.GetHashCode ()
      }

      public GetKind () : MemberKind
      {
        MemberKind.Property (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { any_method.Attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }

      public IsStatic : bool
      {
        get { is_static }
      }
      
      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }

      public override GetHashCode () : int
      {
        id
      }

      public IsMutable : bool
      {
        get { handle.CanWrite }
      }

      public CanAccess (source : TypeInfo) : bool
      {
        any_method.CanAccess (source)
      }

      public IsIndexer : bool
      {
        [Nemerle.Memoize]
        get
        {
          def index_parms = handle.GetIndexParameters ();

          index_parms.Length > 0
        }
      }
    }
    
    [ManagerAccess (library.Manager)]
    class MethodInfo : IMethod
    {
      protected handle : SR.MethodBase;
      protected library : LibraryReference;
      protected id : int;
      protected fun_header : Fun_header;
      protected attributes : NemerleAttributes;
      protected is_var_args : bool;
      
      public this (tenv : Map [string, StaticTyVar], lib : LibraryReference, h : SR.MethodBase)
      {
        library = lib;
        handle = h;

        def (tyvars, tenv) = TyCodec.ReflectTyparms (lib, tenv, h);
        
        def mkparm (p : SR.ParameterInfo) {
          def (parmkind, ty) =
            if (p.ParameterType.IsByRef) {
              def ty = library.TypeOfType (tenv, p.ParameterType.GetElementType ());
              if (p.IsOut)
                (ParmKind.Out, MType.Out (ty))
              else
                (ParmKind.Ref, MType.Ref (ty))
            } else
              (ParmKind.Normal, library.TypeOfType (tenv, p.ParameterType));
          def fp = Fun_parm (
            loc = lib._location,
            name = p.Name,
            color = 0,
            ty = ty,
            kind = parmkind,
            modifiers = Modifiers.Empty // FIXME?
          );
          def deflt = p.DefaultValue;
          when (deflt != System.DBNull.Value)
            fp.default_value = Some (Literal.FromObject (deflt));
          fp
        };
        def ret_type =
          if (handle.Name == ".ctor" || handle.Name == ".cctor")
            InternalType.Void
          else
            library.TypeOfType (tenv, (handle :> SR.MethodInfo).ReturnType);
        
        def parms = handle.GetParameters ();

        when (parms.Length > 0) {
          is_var_args = parms [parms.Length - 1].IsDefined (SystemTypeCache.ParamArrayAttribute, false);
        }

        fun_header =
          Fun_header (
            loc = library._location,
            name = Name,
            ret_type = ret_type,
            parms = List.MapFromArray (parms, mkparm),
            typarms = tyvars,
            tenv = null
          );

        id = fun_header.id;

        attributes = NemerleAttributes.None;
        when (handle.IsAbstract) attributes |= NemerleAttributes.Abstract;
        when (handle.IsVirtual)  attributes |= NemerleAttributes.Virtual;
        when (handle.IsFinal)    attributes |= NemerleAttributes.Sealed;
        when (handle.IsStatic)   attributes |= NemerleAttributes.Static;
       
        when (handle.IsPrivate)  attributes |= NemerleAttributes.Private;
        when (handle.IsPublic)   attributes |= NemerleAttributes.Public;
        when (handle.IsFamily || handle.IsFamilyOrAssembly) attributes |= NemerleAttributes.Protected;
      }
      
      public DeclaringType : TypeInfo
      {
        [Nemerle.Memoize (InvalidValue = null)]
        get {
          library.TypeInfoOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public MemberType : MemberTypes
      {
         get { handle.MemberType }
      }

      public override ToString () : string
      {
        MemberBuilder.DescribeMember (this)
      }

      public IsVarArgs : bool
      {
        get { is_var_args }
      }

      public GetMethodBase () : SR.MethodBase
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      [Nemerle.Memoize (InvalidValue = null)]
      public GetMemType () : MType
      {
        MType.ConstructFunctionType (GetHeader ())
      }

      [Nemerle.OverrideObjectEquals]
      public Equals (o : IMember) : bool
      {
        GetHashCode () == o.GetHashCode ()
      }

      public GetKind () : MemberKind
      {
        MemberKind.Method (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }

      public IsFinal : bool
      { get { handle.IsFinal } }
      
      public IsStatic : bool
      {
        get { handle.IsStatic }
      }
      
      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }

      public override GetHashCode () : int
      {
        id
      }

      public GetFreshType () : MType * list [TyVar]
      {
        if (fun_header.typarms.IsEmpty)
          (GetMemType (), [])
        else {
          def (subst, vars) = Subst.Fresh (fun_header.typarms);
          (subst.MonoApply (GetMemType ()), vars)
        }
      }

      public GetFunKind () : FunKind
      {
        if (handle.IsConstructor)
          if (handle.IsStatic)
            FunKind.StaticConstructor ()
          else
            FunKind.Constructor ()
        else
          if (handle.IsStatic)
            FunKind.Function ()
          else
            FunKind.BoundMethod ([])
      }

      public GetConstructorInfo () : SR.ConstructorInfo
      {
        assert (handle.IsConstructor);
        (handle :> SR.ConstructorInfo)
      }

      public GetMethodInfo () : SR.MethodInfo
      {
        assert (!handle.IsConstructor);
        (handle :> SR.MethodInfo)
      }

      public GetHeader () : Fun_header
      {
        fun_header
      }

      public GetParameters () : list [Fun_parm]
      {
        fun_header.parms
      }

      public ReturnType : TyVar
      {
        get {
          fun_header.ret_type
        }
      }
            
      public CanAccess (source : TypeInfo) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (DeclaringType)) &&
           (handle.IsFamily || handle.IsFamilyOrAssembly))
      }
      
      public BuiltinKind : BuiltinMethodKind
      {
        get { BuiltinMethodKind.NotBuiltin () }
      }
    }
   
    /* -----------------------------------------------------------------
     * External Nemerle types
     * ----------------------------------------------------------------- 
     */
     
    private static get_string_attribute (defined_on : System.Type, attr_type : System.Type, 
                                         meth_name : string) : string
    {
      def attr_obj = defined_on.GetCustomAttributes (attr_type, false) [0];      
      def meth = attr_type.GetMethod (meth_name);
      meth.Invoke (attr_obj, null) :> string
    }


    private get_variant_options (system_type : System.Type) : list [string]
    {
      def str = get_string_attribute (system_type, SystemTypeCache.VariantAttribute, "GetVariantOptions");
      NString.Split (str, array [','])
    }

    private class NetTypeInfo : NetType
    {
      tydecl : TypeDeclaration;
      constant_object : IField;

      public this (lib : LibraryReference, h : System.Type, ns_node : NamespaceTree.Node)
      {
        base (lib, h, ns_node);

        if (system_type.IsDefined (SystemTypeCache.VariantAttribute, false)) {
          def names = lib.get_variant_options (system_type);
          def get_opt (name : string) {
            match (lib.LibRefManager.NameTree.LookupExactType (NString.Split (name, array ['.', '+']))) {
              | Some (tc) => tc
              | None =>
                //Message.Debug (GlobalEnv.Core.ToString ());
                Util.ice ("cannot find variant option named " + name)
                
            }
          };
          tydecl = TypeDeclaration.Variant (List.Map (names, get_opt))
        } 
        else if (system_type.IsDefined (SystemTypeCache.VariantOptionAttribute, false)) {
          tydecl = TypeDeclaration.VariantOption ()
        } 
        else if (system_type.IsDefined (SystemTypeCache.ConstantVariantOptionAttribute, false)) {
          tydecl = TypeDeclaration.VariantOption ();
          match (LookupMember ("_N_constant_object")) {
            | [fld] => constant_object = fld :> IField
            | _ => Util.ice ("cannot find _N_constant_object")
          }
        } 
        else if (system_type.IsDefined (SystemTypeCache.TypeAliasAttribute, false)) {
          def type_string = 
            get_string_attribute (system_type, SystemTypeCache.TypeAliasAttribute, "GetAliasedType");
          tydecl = TypeDeclaration.Alias (TyCodec.DecodeType (lib, tenv, type_string))
        } 
        else if (system_type.IsInterface)
          tydecl = TypeDeclaration.Interface ()
        else if (system_type.IsEnum)
          tydecl = TypeDeclaration.Enum ()
        else
          tydecl = TypeDeclaration.Class ();

        decode_extension_patterns ();
      }

      public override GetTydecl () : TypeDeclaration
      {
        tydecl
      }

      public override GetConstantObject () : IField
      {
        constant_object
      }

      decode_extension_patterns () : void
      {
        def t = SystemTypeCache.ExtensionPatternEncodingAttribute;
        def attrs = system_type.GetCustomAttributes (t, false);
        when (attrs.Length > 0) {
          def get_ids = t.GetMethod ("get_Identifiers");
          def get_pat = t.GetMethod ("get_Pattern");
          def get_name = t.GetMethod ("get_Name");
          foreach (attr_obj in attrs) {
            def ids = get_ids.Invoke (attr_obj, null) :> string;
            def pat = get_pat.Invoke (attr_obj, null) :> string;
            def name = get_name.Invoke (attr_obj, null) :> string;
            def ext = ExtensionPattern (parent = this,
                                        identifiers = NString.Split (ids, [',']),
                                        pattern = MainParser.ParseExpr (Manager.CoreEnv, pat),
                                        name = name);
                                        
            AddExtensionPattern (ext);
          }
        }
      }
    }
  }
} /* namespace */
