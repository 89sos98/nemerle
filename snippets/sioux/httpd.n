using Nemerle.Utility;

using System.Net;
using System.Net.Sockets;

namespace Sioux
{

    variant Request
    {
        | Invalid
        | Get {fname : string;}
        | Post {fname : string;}
    }

    variant File_type
    {
        | Html
        | Other
    }
    
    class Httpd
    {
        private static mutable logger : Logger;
        private static mutable config : Config;
    
        private static read_text (fp : System.IO.TextReader) : string
        {
            def     sb = System.Text.StringBuilder ();
            mutable c <- fp.Read ();

            while (c != -1 && c != 10){
                def _ = sb.Append ((c :> System.Char));
                c <- fp.Read ();
            };

            sb.ToString ()
        }

        private static check (str : string) : string
        {
            if (str.IndexOf ("/..") != -1)
                ""
            else
                str
        }
        
        private static find_name (str : string) : string
        {
            def     buf = System.Text.StringBuilder ();
            def     len = str.Length;
            mutable i  <- 0;

            while (i < len && ! System.Char.IsWhiteSpace (str[i])){
                ignore (buf.Append (str[i]));
                i <- i + 1;
            };

            buf.ToString ()
        }
        
        private static local_name (str : string) : string
        {
            def s = config.get ("server/root") + check (str);

            if (s.EndsWith ("/"))
                s + "index.html"
            else
                s
        }
        
        private static parse_request (str : string) : Request
        {
            if (str.StartsWith ("GET ") || str.StartsWith ("get "))
                Get (find_name (str.Substring (4)))
            else if (str.StartsWith ("POST ") || str.StartsWith ("post "))
                Post (find_name (str.Substring (5)))
            else
                Invalid ()
        }
    
        private static write_string (stream : NetworkStream, s : string) : void
        {
            def buf = System.Text.Encoding.ASCII.GetBytes (s);

            stream.Write (buf, 0, buf.Length)
        }
        
        private static write_endline (stream : NetworkStream, s : string) : void
        {
            write_string (stream, s + "\r\n")
        }
        
        private static write_invalid (stream : NetworkStream) : void
        {
            write_endline (stream, "HTTP/1.0 403 Error");
            write_endline (stream, "Server: " + config.get ("server/name"));
            write_endline (stream, "");
            write_endline  (stream, config.get ("replies/invalid"));
        }


        private static write_not_found (stream : NetworkStream) : void
        {
            write_endline (stream, "HTTP/1.0 404 Not found");
            write_endline (stream, "Server: " + config.get ("server/name"));
            write_endline (stream, "");
            write_endline (stream, config.get ("replies/not_found"));
        }
    
    
        private static write_type (fname : string, stream : NetworkStream) : void
        {
            def b = System.IO.File.Exists (fname);
        
            if (! b)
                ()
            else {
                if (fname.EndsWith (".htm") || fname.EndsWith (".html"))
                    write_endline (stream, "Content-Type: text/html")
                else if (fname.EndsWith (".gif"))
                    write_endline (stream, "Content-Type: image/gif")
                else
                    write_endline (stream, "Content-Type: application/octet-stream")
            }
        }
    
        private static write_file_content (fname : string, stream : NetworkStream) : void
        {
            def fp = System.IO.BinaryReader (System.IO.File.Open (fname, System.IO.FileMode.Open));

            try 
                while (true){
                    def tmp = fp.ReadByte ();
                    stream.WriteByte (tmp)
                }
            catch {
                _ : System.IO.EndOfStreamException => ()
            };

            fp.Close ()
        }
    
        private static write_file (fname : string, stream : NetworkStream) : void
        {
            if (! System.IO.File.Exists (fname))
                write_not_found (stream)
            else {
                try {
                    write_endline (stream, "HTTP/1.0 200 OK");
                    write_type (fname, stream);
                    write_endline (stream, "Server: " + config.get ("server/name"));
                    write_endline (stream, "");
                    write_file_content (fname, stream);
                }
                catch {
                    e : System.Exception =>
                        logger.log ("Couldn't read file " + fname
                                    + " " + e.Message);
                }
            }
        }
    
        private static open_connection () : TcpListener
        {
            def addr_s = config.get ("server/address");
            def addr   = if (addr_s != null)
                             IPAddress.Parse (config.get ("server/address"))
                         else
                             null;
            def port   = try System.Int32.Parse (config.get ("server/port"))
                         catch {
                             _ : System.Exception => 80
                         };
            def server = if (addr != null) TcpListener (addr, port)
                         else TcpListener (port);

            server.Start ();
            server
        }
        
        private static read_data (stream : NetworkStream) : string
        {
            def sb     = System.Text.StringBuilder ();
            mutable ch <- stream.ReadByte ();

            while (ch != -1 && (ch :> char) != '\n') {
              ignore (sb.Append ((ch :> char)));
              ch <- stream.ReadByte ()
            };

            sb.ToString ()
        }

        private static run () : void
        {
            def server = open_connection ();

            while (true){
                def client = server.AcceptTcpClient ();

                def handle_request () {
                  def stream = client.GetStream ();
                  def str    = read_data (stream);

                  printf ("%s\n", str);

                  match (parse_request (str)){
                      | Invalid     => write_invalid (stream);
                      | Get (fname) => 
                        logger.log ("GET '" + fname + "'");
                        def app = HelloApp ();
                        app.HandleRequest (fname, client, false);
                      | Post (fname) => 
                        logger.log ("POST '" + fname + "'");
                        def app = HelloApp ();
                        app.HandleRequest (fname, client, true);
                  };

                  client.Close ()
                };

                def th = System.Threading.Thread (System.Threading.ThreadStart (handle_request));
                th.Start ();
            }
        }
    
        public static Main (_args : array (string)) : void
        {
            mutable logfile <- None ();
            mutable confile <- None ();

            def opts = [
                Getopt.String (name    = "-config",
                               aliases = ["-c"],
                               help    = "Alternative configuration file.",
                               handler = fun (s) { confile <- Some (s); }),
                Getopt.String (name    = "-logfile",
                               aliases = ["-l"],
                               help    = "Alternative log file.",
                               handler = fun (s) { logfile <- Some (s); })
            ];

            Getopt.Parse (opts);
            
            logger <- Logger (logfile);
            config <- Config (confile);
            run ();
            logger.destroy ();
        }
    }
}
