(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections.Tree;
open Nemerle.Collections;


variant option ('a) =
  [
    | None
    | Some { val : 'a; }
  ]

namespace Nemerle.Collections {

interface I_comparable_to ('a)
  {
    compare(_ : 'a) : int;
  }

interface I_comparator ('a)
  {
    compare(_ : 'a, _ : 'a) : int;
  }

class Impossible extends System.Exception
  {
    this () {}
  }

variant node ('a) where 'a :> I_comparable_to('a) =
  [
    | R { l : node ('a); e : 'a; r : node ('a); }
    | B { l : node ('a); e : 'a; r : node ('a); }
    | T
  ]

class Tree
  {
    static ('a) where 'a :> I_comparable_to('a) 
      balance (left : node('a), elem : 'a, right : node('a)) : node('a) =
      // this could be or pattern, but it's 10 times better then
      // it used to be anyway :-)
      match (left, elem, right) with [
        | (R (R (?a, ?x, ?b), ?y, ?c), ?z, ?d) =>
          R (B (a, x, b), y, B (c, z, d))
        | (R (R (?a, ?x, ?b), ?y, ?c), ?z, ?d) =>
          R (B (a, x, b), y, B (c, z, d))
        | (R (?a, ?x, R (?b, ?y, ?c)), ?z, ?d) =>
          R (B (a, x, b), y, B (c, z, d))
        | (?a, ?x, R (R (?b, ?y, ?c), ?z, ?d)) =>
          R (B (a, x, b), y, B (c, z, d))
        | (?a, ?x, R (?b, ?y, R (?c, ?z, ?d))) =>
          R (B (a, x, b), y, B (c, z, d))
        | _ => 
          R (left, elem, right)
      ];

    static ('a) where 'a :> I_comparable_to('a) 
      insert (t : node('a), x : 'a) : node('a) =
      letfun ins (t : node ('a)) : node('a) =
        match t with [
          | T => R (T (), x, T ())
          | B ?y =>
            let res = y#e#compare (x) in
            if res > 0 then balance (ins (y#l), y#e, y#r)
            else if res < 0 then balance (y#l, y#e, ins (y#r))
            else B (y#l, x, y#r) // replace
          | R ?y =>
            let res = y#e#compare (x) in
            if res > 0 then R (ins (y#l), y#e, y#r)
            else if res < 0 then R (y#l, y#e, ins (y#r))
            else R (y#l, x, y#r)
        ] in 
          let t = ins (t) in
          match t with [
            | B => t
            | R ?x => B(x#l, x#e, x#r)
            | _ => raise Impossible()
          ];

    static ('a) where 'a :> I_comparable_to('a) 
      find (t : node('a), x : 'a) : option('a) =
      letfun f (t : node('a)) : option('a) =
        match t with [
          | R ?y =>
            //let _ = print_string (".") in
            let res = y#e#compare (x) in
            if res > 0 then f (y#l)
            else if res < 0 then f (y#r)
            else option.Some(y#e)
          | B ?y =>
            //let _ = print_string ("+") in
            let res = y#e#compare (x) in
            if res > 0 then f (y#l)
            else if res < 0 then f (y#r)
            else option.Some(y#e)
          | T => option.None()
        ]
      in f(t);
  }

  class map_node ('a, 'b) implements I_comparable_to(map_node('a, 'b))
    {
      key : 'a;
      val : 'b;
      cmp : I_comparator('a);
      
      compare(x : map_node('a, 'b)) : int 
        implements I_comparable_to.compare
        = this#cmp#compare(this#key, x#key);

      this (c : I_comparator('a), k : 'a, v : 'b) 
        { 
          this#cmp <- c;
          this#key <- k; 
          this#val <- v;
        }

      this (c : I_comparator('a), k : 'a) 
        {
          this#cmp <- c;
          this#key <- k;
        }
    }

  class Int_comparator implements I_comparator(int)
    {
      compare (x : int, y : int) : int 
        implements I_comparator.compare
        = x - y;
      this () {}
    }

  class String_comparator implements I_comparator(string)
    {
      compare (x : string, y : string) : int 
        implements I_comparator.compare
        = compare_strings(x, y);
      this () {}
    }

  class Map ('a, 'b, 'c) where 'c :> I_comparator('a)
    {
      root : node(map_node('a, 'b));
      cmp : I_comparator('a);
      
      this(c : I_comparator('a))
        {
          this#root <- T();
          this#cmp <- c;
        }

      private this(c : I_comparator('a), r : node(map_node('a, 'b))) 
        {
          this#cmp <- c;
          this#root <- r;
        }
      
      add (k : 'a, v : 'b) : Map('a, 'b, 'c) =
        Map(this#cmp, Tree.insert(this#root, map_node(this#cmp, k, v)));
        
      find (k : 'a) : option('b) =
        match Tree.find(this#root, map_node(this#cmp, k)) with [
          | option.Some ?n => option.Some(n#val#val) 
          | option.None => option.None()
        ];

      static ('d) int_map () : Int_map('d)
        = Map(Int_comparator());
      static ('d) string_map () : String_map('d)
        = Map(String_comparator());
    }

    type Int_map ('a) = Map(int, 'a, Int_comparator);
    type String_map ('a) = Map(string, 'a, String_comparator);

}

class C {
  static Main () : void =
    let cnt = 50 in
    letfun ins (n : int, m : String_map(int)) : String_map(int) =
      if n < 0 then m
      else ins (n - 1, m#add(string_of_int(n), n))
    in 
    let m = ins (cnt, Map.string_map()) in
    letfun check (n : int) : void =
      if n < 0 then ()
      else
        match m#find(string_of_int(n)) with [
          | option.Some ?x => 
            if x#val != n then
              print_string ("oops\n")
            else
              check(n - 1)
          | option.None =>
              print_string ("oops2\n")
        ]
    in check(cnt);
}

(*
BEGIN-OUTPUT
END-OUTPUT
*)
