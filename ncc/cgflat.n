(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

module CGflat {
  // string in tree for fast concatenation
  variant String_tree = [
    | ST_leaf { data : string; }
    | ST_node { left : String_tree; right : String_tree; }
  ]

  variant CS_code = [
    | CS_simple { val : String_tree; }
    | CS_complex { pre : String_tree; val : String_tree; }
  ]

  is_complex (c : CS_code) : bool = 
    match c with [ CS_complex => true | _ => false ];

  add_st (s1 : String_tree, s2 : String_tree) : String_tree =
    ST_node (s1, s2);
  
  add_st (s1 : string, s2 : String_tree) : String_tree =
    ST_node (ST_leaf (s1), s2);
  
  add_st (s1 : String_tree, s2 : string) : String_tree =
    ST_node (s1, ST_leaf (s2));
  
  `++` (s1 : String_tree, s2 : String_tree) : String_tree = 
    extern "Nemerle.Compiler.CGflat.add_st";

  `++` (s1 : string, s2 : String_tree) : String_tree =
    extern "Nemerle.Compiler.CGflat.add_st";

  `++` (s1 : String_tree, s2 : string) : String_tree =
    extern "Nemerle.Compiler.CGflat.add_st";

  class_type (c : CM_class) : CG_type =
    CT_ref (c.ns + c.name);

  csref (c : CS_code) : String_tree =
    match c with [
      | CS_simple (s) => s
      | CS_complex (_, s) => s
    ];

  mono (e : CS_code, rf : String_tree) : CS_code =
    match e with [
      | CS_simple (_) => CS_simple (rf)
      | CS_complex (p, _) => CS_complex (p, rf)
    ];

  tmp () : string =
    "_N_t" + string_of_int (Util.next_id ());
  
  is_dummy_type (t : CG_type) : bool =
    match t with [
      | CT_void => true
      | CT_unreached => true
      | _ => false
    ];

  st_concat (sep : string, nodes : list (String_tree)) : String_tree =
    match nodes with [
      | Nil => ST_leaf ("")
      | Cons (x, Nil) => x
      | Cons (x, xs) => x ++ sep ++ st_concat (sep, xs)
    ];
  
  s_concat (sep : string, nodes : list (string)) : String_tree =
    match nodes with [
      | Nil => ST_leaf ("")
      | Cons (x, xs) => ST_leaf (x) ++ sep ++ s_concat (sep, xs)
    ];
  
  flat_ty (t : CG_type) : String_tree
    { 
      def s =
        match t with [
          | CT_ref (n) => n
          | CT_void => "void"
          | CT_object => "object"
          | CT_bool => "bool"
          | CT_unreached => "unreached"
          | CT_tuple (n) => "Nemerle.Tuple" + string_of_int (n)
          | CT_fun (n) => "Nemerle.Func" + string_of_int (n)
        ];
      ST_leaf (s);
    }

  operator_name (_ : string) : string =
    extern "Nemerle.Compiler.CS_glue.operator_name";

  // only for short strings (like function name)
  st_flatten (s : String_tree) : string =
    match s with [
      | ST_leaf (x) => x
      | ST_node (l, r) => st_flatten (l) + st_flatten (r)
    ];

  flat_call (pref : String_tree, es : list (CG_expr)) : CS_code
    {
      def es' = List.map (flat, es);
      def (pre, es) =
        if List.exists (is_complex, es') then {
          mutable pre <- ST_leaf ("");
          def f (x : CG_expr, fx : CS_code) : CS_code
            {
              def (p, r) = make_complex (fx);
              def n = tmp ();
              def df = flat_ty (type_of (x)) ++ " " ++ n ++ " = " ++ r ++ ";\n";
              pre <- pre ++ p ++ df;
              CS_simple (ST_leaf (n))
            };
          // r needs to be in def, since computing it triggers pre update
          def r = List.map2 (f, es, es');
          (Some (pre), r)
        } else (None (), es');
        
      def opname = operator_name (st_flatten (pref));
      def body = 
        if opname == "" then
          pref ++ "(" ++ st_concat (", ", List.map (csref, es)) ++ ")"
        else
          match List.map (csref, es) with [
            | Cons (e1, Cons (e2, Nil)) =>
              "(" ++ e1 ++ " " ++ opname ++ " " ++ e2 ++ ")"
            | Cons (e, Nil) =>
              "(" + opname + " " ++ e ++ ")"
            | _ => Util.ice ()
          ];

      match pre with [
        | None => CS_simple (body)
        | Some (x) => CS_complex (x, body)
      ];
    }

  make_complex (ex : CS_code) : String_tree * String_tree =
    match ex with [
      | CS_complex (x, y) => (x, y)
      | CS_simple (x) => (ST_leaf (""), x)
    ];

  quote (s : string) : string = 
    extern "Nemerle.Compiler.CS_glue.quote";

  flat (ex : CG_expr) : CS_code =
    match ex with [
      | CE_ref (d) => CS_simple (ST_leaf (d.name))
      | CE_global_ref (m) =>
        def n = if m.extern_name != "" then m.extern_name else m.name;
        CS_simple (ST_leaf (n))
      | CE_field_ref (e, f) =>
        def e = flat (e);
        mono (e, csref (e) ++ "." ++ f.name)

      | CE_tuple_ref (e, n) => 
        def e = flat (e);
        mono (e, csref (e) ++ ".field" ++ string_of_int (n + 1))

      | CE_call (e, es) => 
        match flat (e) with [
          | CS_simple (s) => flat_call (s, es)
          | _ => Util.ice ()
        ]
          
      | CE_assign (e1, e2) =>
        def (p1, r1) = make_complex (flat (e1));
        def (p2, r2) = make_complex (flat (e2));
        CS_complex (p1 ++ p2, r1 ++ " = " ++ r2)
        
      | CE_let (v, e) =>
        match v.val with [
          | CE_none =>
            def (p, r) = make_complex (flat (e));
            CS_complex (flat_ty (v.ty) ++ " " ++ v.name ++ ";\n" ++ p, r)
          | _ =>
            def (p, r) = make_complex (flat (v.val));
            def pref = 
              if is_dummy_type (v.ty) then
                p ++ side_effect_run (r)
              else
                p ++ flat_ty (v.ty) ++ " " ++ v.name ++ " = " ++ r ++ ";\n";
            def (p, r) = make_complex (flat (e));
            CS_complex (pref ++ p, r)
        ]
        
      | CE_has_type (e, t) =>
        def e = flat (e);
        mono (e, "(" ++ csref (e) ++ " is " ++ flat_ty (t) ++ ")")
        
      | CE_raise (x) =>
        def (p, r) = make_complex (flat (x));
        CS_complex (p ++ "throw " ++ r ++ ";\n", ST_leaf ("null"))
        
      | CE_if (_, CE_true, e, _) => flat (e)
      | CE_if (_, CE_false, _, e) => flat (e)
      
      | CE_if (t, c, e1', e2') =>
        def (p1, c) = make_complex (flat (c));
        def (p2, e1) = make_complex (flat (e1'));
        def (p3, e2) = make_complex (flat (e2'));
        if is_dummy_type (t) then
          CS_complex (p1 ++ 
                      "if (" ++ c ++ ") {\n" ++
                        p2 ++
                        side_effect_run (e1) ++
                      "} else {\n" ++
                        p3 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf ("null"))
        else {
          def tmpname = tmp ();
          def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
          CS_complex (p1 ++ df ++ 
                      "if (" ++ c ++ ") {\n" ++
                        p2 ++
                        tmpname ++ " = " ++ e1 ++ ";\n" ++
                      "} else {\n" ++
                        p3 ++
                        tmpname ++ " = " ++ e2 ++ ";\n" ++
                      "}\n", ST_leaf (tmpname))
        }
        
      | CE_true => CS_simple (ST_leaf ("true"))

      | CE_false => CS_simple (ST_leaf ("false"))
      
      | CE_try_with (e1', v, e2') =>
        def (p1, e1) = make_complex (flat (e1'));
        def (p2, e2) = make_complex (flat (e2'));
        def t = type_of (e1');
        if is_dummy_type (t) then
          CS_complex ("try {\n" ++
                        p1 ++
                        side_effect_run (e1) ++
                      "} catch (" ++ flat_ty (v.ty) ++ " " ++ v.name ++ ") {\n" ++
                        p2 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf ("null"))
        else {
          def tmpname = tmp ();
          def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
          CS_complex (df ++
                      "try {\n" ++
                        p1 ++
                        tmpname ++ " = " ++ e1 ++ ";\n" ++
                      "} catch (" ++ flat_ty (v.ty) ++ " " ++ v.name ++ ") {\n" ++
                        p2 ++
                        tmpname ++ " = " ++ e2 ++ ";\n" ++
                      "}\n", ST_leaf (tmpname))
        }
                    
      | CE_try_finally (e1', e2') =>
        def (p1, e1) = make_complex (flat (e1'));
        def (p2, e2) = make_complex (flat (e2'));
        def t = type_of (e1');
        if is_dummy_type (t) then
          CS_complex ("try {\n" ++
                        p1 ++
                        side_effect_run (e1) ++
                      "} finally {\n" ++
                        p2 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf ("null"))
        else {
          def tmpname = tmp ();
          def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
          CS_complex (df ++
                      "try {\n" ++
                        p1 ++
                        tmpname ++ " = " ++ e1 ++ ";\n" ++
                      "} finally {\n" ++
                        p2 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf (tmpname))
        }
                    
      | CE_literal (l) =>
        def s =
          match l with [
            | L_void => "null"
            | L_null => "null"
            | L_int (k) => string_of_int (k)
            | L_string (s) => "\"" + quote (s) + "\""
            | L_float (v) => Util.ice ("FIXME: cgfloat")
          ];
        CS_simple (ST_leaf (s))
        
      | CE_this => CS_simple (ST_leaf ("this"))
      | CE_skip => CS_simple (ST_leaf ("null"))
      
      | CE_cast (e, CT_void) => flat (e) // C# doesn't like (void)foo
      
      | CE_cast (e, t) =>
        def e = flat (e); 
        mono (e, "((" ++ flat_ty (t) ++ ")" ++ csref (e) ++ ")")
        
      | CE_sequence (Nil) => CS_simple (ST_leaf ("null"))

      | CE_sequence (e) =>
        def serialize (e : CG_expr) : String_tree
          {
            def (pre, r) = make_complex (flat (e));
            pre ++ side_effect_run (r)
          };
        def concat (acc : String_tree, es : list (CG_expr)) : CS_code =
          match es with [
            | Cons (x, Nil) => 
              def (pre, r) = make_complex (flat (x));
              CS_complex (acc ++ pre, r)
            | Cons (CE_skip, xs) =>
              concat (acc, xs)
            | Cons (x, xs) =>
              concat (acc ++ serialize (x), xs)
          ];

        concat (ST_leaf (""), e)
      
      | CE_tuple_ctor (es) =>
        flat_call (ST_leaf ("new Nemerle.Tuple") ++ string_of_int (List.length (es)), es)
      
      | CE_ctor_ref (c) => 
        if c.extern_name == "" then 
          Util.ice ("empty extern name " + c.ns + ":" + c.name)
        else
          CS_simple (ST_leaf ("new " + c.extern_name))
      
      | CE_method_ref (e, f) => 
        def e = flat (e); 
        mono (e, csref (e) ++ "." ++ f.name)

      | CE_none => Util.ice ()
    ];

  type_of (ex : CG_expr) : CG_type = 
    match ex with [
      | CE_ref (d) => d.ty
      | CE_global_ref (CM_field f) => f.ty
      | CE_field_ref (_, f) => f.ty
      | CE_tuple_ref => CT_object ()
      | CE_call (CE_global_ref (CM_method m), _) => m.ret_type
      | CE_call (CE_method_ref (_, m), _) => m.ret_type
      | CE_call (CE_ctor_ref (c), _) => class_type (c)
      | CE_call => Util.ice ()
      | CE_assign => CT_void ()
      | CE_let (_, b) => type_of (b)
      | CE_has_type => CT_bool ()
      | CE_raise => CT_unreached ()
      | CE_if (t, _, _, _) => t
      | CE_true => CT_bool ()
      | CE_false => CT_bool ()
      | CE_try_with (e, _, _) => type_of (e)
      | CE_try_finally (e, _) => type_of (e)
      | CE_literal (l) => 
        match l with [
          | L_void => CT_void ()
          | L_null => CT_object ()
          | L_int => CT_ref ("Nemerle.Core.int")
          | L_string => CT_ref ("Nemerle.Core.string")
          | L_float => CT_ref ("Nemerle.Core.float")
        ]
      | CE_this => CT_object () // cheat a bit
      | CE_skip => CT_void ()
      | CE_cast (_, t) => t
      | CE_sequence (b) => type_of (List.last (b))
      | CE_tuple_ctor (es) => CT_tuple (List.length (es))
      // can't tell
      | CE_none => Util.ice ()
      // these are supported only as part of call
      | CE_global_ref (CM_method) => Util.ice ()
      | CE_ctor_ref => Util.ice ()
      | CE_method_ref => Util.ice ()
    ];

  write_string (s : string) : void = extern "CS_glue.write_string";

  print_st (s : String_tree) : void =
    match s with [
      | ST_leaf (d) => write_string (d)
      | ST_node (l, r) => { print_st (l); print_st (r) }
    ];

  side_effect_run (x : String_tree) : String_tree =
    match x with [
      | ST_leaf (s) => 
        if s == "null" then ST_leaf ("")
        else x ++ ";\n"
      | _ => x ++ ";\n"
    ];

  flat_member (m : CG_member) : void =
    match m with [
      | CM_class m =>
        def k = 
          match m.kind with [ 
            | CK_class => "class" 
            | CK_struct => "struct" 
            | CK_interface => "interface"
          ];
        def inh =
          match m.inheritance with [
            | Nil => ST_leaf ("")
            | _ => " : " ++ st_concat (", ", List.map (flat_ty, m.inheritance))
          ];
        print_st (s_concat (" ", m.attrs) ++ " " ++ k ++ 
                  " " ++ m.name ++ inh ++ " {\n");
        List.iter (flat_member, m.decls);
        print_st (ST_leaf ("} // end of ") ++ k ++ " " ++ m.name ++ "\n")

     | CM_field m =>
       print_st (s_concat (" ", m.attrs) ++ " " ++ flat_ty (m.ty) ++ 
                 " " ++ m.name ++ ";\n")
     | CM_method m =>
       def mkparm (v : CG_val) : String_tree =
         flat_ty (v.ty) ++ " " ++ v.name;
       def rett = 
         match m.ret_type with [
           | CT_unreached => ST_leaf ("")
           | _ => flat_ty (m.ret_type)
         ];
         
       print_st (s_concat (" ", m.attrs) ++ " " ++ rett ++ "\n" ++ 
                 m.name ++ "(" ++ st_concat (", ", List.map (mkparm, m.parms)) ++ ")");

       match m.body with [
         | CE_none => print_st (ST_leaf (";\n"))
         | _ =>
           def (pref, r) = make_complex (flat (m.body));
           def ret =
             if is_dummy_type (m.ret_type) then
               side_effect_run (r)
             else
               if is_dummy_type (type_of (m.body)) then
                 side_effect_run (r) ++ "return null;\n"
               else
                 "return " ++ r ++ ";\n";
           print_st ("\n{\n" ++ 
                          pref ++ 
                          ret ++ 
                     "} // end of fun " ++ m.name ++ "\n")
       ]
   ];
  
  run (decls : list (CM_class)) : void
    {
      def flat_top_member (x : CM_class) : void =
        if x.ns != "" then {
          print_st (ST_leaf ("namespace " + CSglue.get_ns (x.ns) + " {\n"));
          flat_member (x);
          print_st (ST_leaf ("} // end ns\n"))
        } else flat_member (x);
      List.iter (flat_top_member, decls);
    }

} // end module
} // end namespace
