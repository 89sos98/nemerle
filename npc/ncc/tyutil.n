open Nemerle.Compiler;
open Nemerle.Compiler.Tyutil;
open Nemerle.Compiler.Tyops;
open Nemerle.Collections;

namespace Nemerle.Compiler {

class Tyops
  {
    fun `/-` (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
  }
  
type Subst = Int_map(Type);

class Tyutil
  {
    fun subst (t : Type, s : Subst) : Type =
      letfun self (t : Type) : Type = subst (t, s) in
      match t with [
        | T_ref (?t) => T_ref (self (t))
        | T_out (?t) => T_out (self (t))
        | T_fun (?tl, ?t) => T_fun (List.map (self, tl), t)
        | T_void => t
        | T_prod (?tl) => T_prod (List.map (self, tl))
        | T_app (?tc, ?args, ?ref_to) =>
          T_app (tc, List.map (self, args), ref_to)
        | T_var (_, ?id) =>
          match s#find(id) with [
            | Some (?t') => t'
            | None => t
          ]
      ];
    
    fun make_subst (ini : Subst, parms : list (int), args : list (Type)) : Subst =
      match (parms, args) with [
        | (Cons (?p, ?ps), Cons (?a, ?args)) =>
          make_subst (ini#add (p, a), ps, args)
        | (Nil, Nil) => ini
        | _ => Util.ice ()
      ];
      
    fun make_subst (parms : list (int), args : list (Type)) : Subst =
       make_subst (Map.int_map (), parms, args);
    
    fun top_expand (t : Type) : Type =
      match t with [
        | T_app (_, ?args, ?ref_to) =>
          let td = (Tyinfo.lookup(ref_to))#tydecl in
          match td with [
            | TD_alias (?t) =>
              let sub = make_subst (Tyvars.get_parms (td#id), args) in
              top_expand (t /- sub)  // fixpoint iteration
            | _ => t
          ]
        | _ => t
      ];
  }

} // ns
