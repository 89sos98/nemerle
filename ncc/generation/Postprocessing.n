/*
 * Copyright (c) 2004, 2005 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler
{
  using Nemerle.Compiler;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Collections;
  using Nemerle.Utility;

  /**
   * Executed between cgexpr and cgil
   */
  internal class CGpost
  {
    internal Run (expr : CExpr) : CExpr
    {
      transform_try_blocks (true, expr);
      walk (expr, CgExprFlags.None)
    }
    
    internal static Postprocess (cgm : CG_method) : void
    {
      def th = CGpost ();
      def res = th.Run (cgm.body);
      unless (res == null)
        cgm.body = res;
    }


    /** 
        Walk given expression, requiring [flags]. If the expression cuts
        control flow, a new expression is returned (and the surrounding
        tree is rebuild accordingly, for example CExpr.Call(...) is
        transformed into cut down CExpr.Sequence). Otherwise (the normal
        case) null is returned.
     */
    walk (expr : CExpr, flags : CgExprFlags) : CExpr
    {
      //Message.debug ($ "walk ($expr)");
      def simple_walk (e) {
        walk (e, CgExprFlags.None)
      }

      def cannot_addr () {
        if (flags %&& CgExprFlags.NeedAddress &&
            expr.SystemType.IsValueType)
          Message.error (expr.loc, "cannot load value type address for this expression")
        else if (flags %&& CgExprFlags.NeedLValue)
          Message.error (expr.loc, "this expression is not a proper lvalue")
        else ()
      }
      
      def can_addr () {
        when (flags %&& (CgExprFlags.NeedAddress %| CgExprFlags.WishAddress))
          expr.flags |= CgExprFlags.WishGranted;
      }
      
      expr.flags = flags;

      def transform (e) {
        def e' = walk (e, CgExprFlags.None);
        if (e' == null) e
        else e'
      }

      def res =
        match (expr) {
          | CExpr.This
          | CExpr.Ref
          | CExpr.GlobalRef
          | CExpr.VolatileGlobalRef =>
            can_addr ();
            null

          | CExpr.Loop (e, _)
          | CExpr.Cast (e, _, _)
          | CExpr.HasType (e, _) 
          | CExpr.NotNull (e)
          | CExpr.MethodRef (e, _, _)
          | CExpr.Ignore (e) =>
            cannot_addr ();
            simple_walk (e)

          | CExpr.InitValueType 
          | CExpr.Literal =>
            cannot_addr (); // ??
            null

          | CExpr.Nop
          | CExpr.BaseCtorRef
          | CExpr.TypeOf
          | CExpr.ConstructorRef
          | CExpr.MethodAddress
          | CExpr.Opcode =>
            cannot_addr ();
            null

          | CExpr.Call (CExpr.MethodRef (e, _, _), xs)
          | CExpr.TailCall (CExpr.MethodRef (e, _, _), xs) =>
            // FIXME: this is a bit wrong, null.Foo (throw Exception ())
            // will throw exception, and not null ref
            cannot_addr ();
            if (e.SystemType.IsValueType) {
              def e' =
                walk (e, flags %| CgExprFlags.WishAddress);
              if (e' != null)
                e'
              else {
                def seq = walk_seq (expr, xs, "call");
                if (seq != null)
                  match (seq) {
                    | CExpr.Sequence (xs) =>
                      CExpr.Sequence (e' :: xs).WithCtx (seq)
                    | _ => assert (false)
                  }
                else null
              }
            } else
              walk_seq (expr, e :: xs, "call")
          
          | CExpr.Call (x, xs)
          | CExpr.TailCall (x, xs) =>
            cannot_addr ();
            walk_seq (expr, x :: xs, "call")

          | CExpr.VolatileFieldRef (e, _)
          | CExpr.FieldRef (e, _) =>
            can_addr ();
            // wishaddr etc should be propagated only to value types
            def flags' = flags %& ~(CgExprFlags.NeedLValue %| 
                                    CgExprFlags.NeedAddress %| 
                                    CgExprFlags.WishAddress);
            if (e.SystemType.IsValueType)
              if (flags %&& CgExprFlags.NeedLValue)
                walk (e, flags' %| CgExprFlags.NeedAddress)
              else
                walk (e, flags' %| CgExprFlags.WishAddress)
            else
              walk (e, flags')

          | CExpr.ArrayAccess (x, xs) =>
            can_addr ();
            walk_seq (expr, x :: xs, "array indexer")
          
          | CExpr.Array (_, xs, _) =>
            cannot_addr ();
            walk_seq (expr, xs, "array [...] constructor")

          | CExpr.SelfTailCall (xs) =>
            cannot_addr ();
            walk_seq (expr, xs, "self tail call")
          
          | CExpr.Assign (target, source) =>
            cannot_addr ();
            def target = walk (target, flags %| CgExprFlags.NeedLValue);
            if (target != null) {
              Message.warning (target.loc, "`throw' in assignment target");
              target.flags = CgExprFlags.None;
              target
            } else {
              def source = walk (source, CgExprFlags.None);
              if (source != null) {
                Message.warning (source.loc, "`throw' in assignment source");
                target.flags = CgExprFlags.None;
                CExpr.Sequence ([side_effect_run (target), source]).WithCtx (expr)
              } else
                null
            }
            
          | CExpr.Define (name, body) =>
            def val = walk (name.val, CgExprFlags.None);
            if (val != null) {
              Message.warning (val.loc, "`throw' in initial `def' value");
              val
            } else {
              def body = walk (body, flags);
              if (body == null)
                null
              else {
                //Message.debug ($ "body: $body");
                CExpr.Define (name, body).WithCtx (expr)
              }
            }
            
          | CExpr.Throw (e) =>
            // we can take address of throw... 
            can_addr ();
            def e' = walk (e, CgExprFlags.None);
            if (e' == null) {
              expr // cutoff here
            } else {
              Message.warning (e'.loc, "`throw' in `throw'");
              e'
            }
            
          | (CExpr.If (e, e1, e2)) as rec =>
            cannot_addr (); // maybe we can, but I guess it would be risky
            def e' = walk (e, CgExprFlags.None);
            if (e' != null) {
              Message.warning (e'.loc, "`throw' in `if' condition");
              e'
            } else {
              def e1 = walk (e1, flags);
              def e2 = walk (e2, flags);
              when (e1 != null)
                rec.e_then = e1;
              when (e2 != null)
                rec.e_else = e2;
              if (e1 != null && e2 != null)
                expr
              else
                null
            }
            
          | (CExpr.TryWith) as rec =>
            cannot_addr ();
            def body = walk (rec.body, CgExprFlags.None);
            def handler = walk (rec.handler, CgExprFlags.None);
            when (body != null)
              rec.body = body;
            when (handler != null)
              rec.handler = handler;
            if (body != null && handler != null)
              expr
            else
              null
            
          | (CExpr.TryFinally) as rec =>
            cannot_addr ();
            rec.body = transform (rec.body);
            def handler = walk (rec.handler, CgExprFlags.None);
            if (handler == null) {
              null
            } else {
              rec.handler = handler;
              rec
            }
            
          | CExpr.Sequence (lst) =>
            walk_seq (expr, lst, null)
          
          | CExpr.Address (e) =>
            cannot_addr ();
            walk (e, flags %| CgExprFlags.NeedAddress)
            
          | CExpr.Indirect (e) =>
            // can take address
            can_addr ();
            simple_walk (e)
            
          | CExpr.ContinueLoop =>
            can_addr ();
            expr

          | CExpr.MultipleAssign (lst) =>
            cannot_addr ();
            def loop (acc, lst) {
              match (lst) {
                | (((v, e)) as x) :: xs  =>
                  def e' = walk (e, CgExprFlags.None);
                  if (e' == null)
                    loop (x :: acc, xs)
                  else {
                    Message.warning (e.loc, "`throw' in self tail call");
                    CExpr.MultipleAssign (List.Rev ((v, e') :: acc))
                      .WithCtx (expr)
                  }
                | [] => null
              }
            }
            loop ([], lst)
            
          | (CExpr.Switch (idx, default, cases)) as rec =>
            // optimize switch here?
            cannot_addr (); // maybe we can, but I guess it would be risky
            def idx' = walk (idx, CgExprFlags.None);
            if (idx' != null) {
              Message.warning (idx'.loc, "`throw' in `switch' condition");
              idx'
            } else {
              mutable seen_normal = false;
              match (default) {
                | Some (expr) =>
                  def expr = walk (expr, flags);
                  if (expr == null) seen_normal = true;
                  else rec.default = Some (expr)
                | None => ()
              }
              rec.cases =
                List.Map (cases, fun (id, e) {
                  def e' = walk (e, flags);
                  if (e' == null) {
                    seen_normal = true;
                    (id, e)
                  } else {
                    (id, e')
                  }
                });
              if (seen_normal)
                null
              else
                expr
            }
        };
      when (res != null)
        res.flags |= CgExprFlags.Throws;
      res
    }

    /** Helper for walk(). */
    walk_seq (parent_expr : CExpr,
              exprs : list [CExpr], 
              warning_object : string) : CExpr
    {
      mutable len = 0;
      
      def loop (lst) {
        | e :: es =>
          def res =
            if (warning_object == null && es.IsEmpty) walk (e, parent_expr.flags)
            else walk (e, CgExprFlags.None);
          if (res != null) {
            def blah = "has been skipped in code emission, due to `throw' "
                       "usage";
            match (es) {
              | [] =>
                when (warning_object != null)
                  Message.warning (parent_expr.loc, 
                                   $ "this $warning_object $blah");
              | e :: _ =>
                def middle =
                  if (warning_object == null)
                    ""
                  else
                    $" (an argument of the $warning_object)";
                Message.warning (e.loc, $ "this expression$middle $blah");
            }
            
            def exprs' = 
              if (warning_object == null)
                exprs.FirstN (len) // sequence
              else
                List.Map (exprs.FirstN (len), side_effect_run);
            CExpr.Sequence (exprs' + [res]).WithCtx (parent_expr)
          } else {
            ++len;
            loop (es)
          }
        | [] => null
      }

      loop (exprs)
    }

    /** Run given expression for side effects only. */
    side_effect_run (expr : CExpr) : CExpr
    {
      def res =
        match (expr) {
          | CExpr.BaseCtorRef
          | CExpr.Literal
          | CExpr.This
          | CExpr.Nop
          | CExpr.Ref 
          | CExpr.GlobalRef 
          | CExpr.ConstructorRef
          | CExpr.InitValueType
          | CExpr.MethodAddress
          | CExpr.TypeOf
          | CExpr.Opcode =>
            CExpr.Sequence ([]).WithCtx (expr)
          
          | CExpr.ContinueLoop => assert (false)
          | CExpr.SelfTailCall => assert (false)
          
          | CExpr.Address
          | CExpr.Indirect
          | CExpr.HasType
          | CExpr.NotNull
          | CExpr.If
          | CExpr.TryWith
          | CExpr.TryFinally
          | CExpr.Sequence
          | CExpr.Array
          | CExpr.Loop
          | CExpr.Switch
          | CExpr.VolatileGlobalRef 
          | CExpr.FieldRef
          | CExpr.VolatileFieldRef
          | CExpr.MethodRef 
          | CExpr.ArrayAccess
          | CExpr.Call
          | CExpr.TailCall 
          | CExpr.Define
          | CExpr.Cast => CExpr.Ignore (expr)

          | CExpr.Throw
          | CExpr.MultipleAssign
          | CExpr.Ignore
          | CExpr.Assign => expr
        };
      res.WithCtx (expr)
    }


    // marge with walk()
    transform_try_blocks (allow_try : bool, expr : CExpr) : void
    {
      def false_iter (lst : list [CExpr]) {
        foreach (x in lst)
          transform_try_blocks (false, x)
      }
      def same_iter (lst : list [CExpr]) {
        foreach (x in lst)
          transform_try_blocks (allow_try, x)
      }

      //Message.debug ($"walk $expr [$allow_try]");
      
      match (expr) {
        | CExpr.BaseCtorRef
        | CExpr.Literal
        | CExpr.This
        | CExpr.Nop
        | CExpr.Ref 
        | CExpr.GlobalRef 
        | CExpr.VolatileGlobalRef 
        | CExpr.ConstructorRef
        | CExpr.InitValueType
        | CExpr.MethodAddress
        | CExpr.TypeOf
        | CExpr.ContinueLoop 
        | CExpr.Opcode => ()

        | CExpr.FieldRef (o, _)
        | CExpr.VolatileFieldRef (o, _)
        | CExpr.MethodRef (o, _, _)
        | CExpr.Ignore (o) => transform_try_blocks (allow_try, o)

        | CExpr.ArrayAccess (o, os)
        | CExpr.Call (o, os)
        | CExpr.TailCall (o, os) => false_iter (o :: os)
        
        | CExpr.SelfTailCall (os) => false_iter (os)
            
        | CExpr.Assign (CExpr.Ref, o) => transform_try_blocks (allow_try, o)
        
        | CExpr.Assign (o1, o2) => false_iter ([o1, o2])
        
        | CExpr.Define (v, b) =>
          transform_try_blocks (allow_try, v.val);
          transform_try_blocks (allow_try, b)
          
        | CExpr.Cast (e, _, _) =>
          transform_try_blocks (allow_try, e)

        | CExpr.Address (e)
        | CExpr.Indirect (e)
        | CExpr.HasType (e, _)
        | CExpr.NotNull (e)
        | CExpr.Throw (e) =>
          // are we a bit too conservative here?
          transform_try_blocks (false, e)

        | CExpr.If (e1, e2, e3) =>
          transform_try_blocks (allow_try, e1);
          transform_try_blocks (allow_try, e2);
          transform_try_blocks (allow_try, e3)
        
        | CExpr.TryWith (b, _, h)
        | CExpr.TryFinally (b, h) =>
          unless (allow_try)
            Message.error (expr.loc, "try block is not allowed inside expressions");
          transform_try_blocks (true, b);
          transform_try_blocks (true, h)
        
        | CExpr.Sequence (body) => same_iter (body)

        | CExpr.Array (_, initializers, _) => false_iter (initializers)
        
        | CExpr.Loop (body, _) => transform_try_blocks (allow_try, body)
        
        | CExpr.MultipleAssign (assigns) =>
          foreach ((_, e) in assigns) transform_try_blocks (allow_try, e)

        | CExpr.Switch (idx, default, cases) =>
          transform_try_blocks (allow_try, idx);
          match (default) {
            | Some (e) => transform_try_blocks (allow_try, e)
            | None => ()
          }
          foreach ((_, e) in cases) transform_try_blocks (allow_try, e)
      }
    }
  } /* end of the class */

} /* end of the namespace */
