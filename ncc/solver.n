/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;
using Nemerle.Collections;

namespace Nemerle.Compiler 
{
  public enum DiagnosticKind
  {
    | Debug
    | Hint
    | Warning
    | Error
  }

  
  
  // to be moved somewhere else
  /** Represent a compiler diagnostic message. */
  public class Diagnostic
  {
    public Message : string
    {
      get {
      }
    }
    

    public Location : Location
    {
      get {
      }
    }


    public Kind : DiagnosticKind
    {
      get {
      }
    }
  }
  
  
  
  /** A constraint solver. */
  public class Solver
  {
    /** Store current constraint state.
        
        Called before some speculative type checking fragment, like
        overload resolution. */
    public PushState () : void
    {
    }


    /** Go one constraint state back.
        
        This function rollbacks all constraints made in current state,
        and also clear the error state if it was in */
    public PopState () : void
    {
    }


    /** Check if the solver has encountered an error in the current of
        parent state. */
    public InErrorState : bool
    {
      get {
      }
    }
    

    /** The first error encountered in the current (or parent) state, or 
        [null] if not [InErrorState]. */
    public ErrorMessage : Diagnostic
    {
      get {
      }
    }
    

    /** Make sure all TyVars created so far won't go anywhere.
        
        Called when the type checking process for a method is finished (or
        for a class, if we decide to go with inferred private types). */
    public FixateAll () : void
    {
    }


    /** Generate a new type variable. */
    public FreshTyVar () : TyVar
    {
    }


    /** Increment current type variable rank.

        Called before typing of a local function. */
    public PushRank () : void
    {
    }

    
    /** Restore previous type variable rank.

        Called after typing of a local function. */
    public PopRank () : void
    {
    }
  }



  /** Represent top-level type constructor for a given type. */
  public variant MType
  {
    | Class {
        tycon : TypeInfo;
        args : list <TyVar>;
      }
    | TyVar {
        tyvar : StaticTyVar;
      }
    | Fun {
        from : TyVar;
        to : TyVar;
      }
    | Tuple {
        args : list <TyVar>;
      }
    | Array {
        t : TyVar;
        rank : int;
      }
    | Void
  }



  /** Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types. */
  public class StaticTyVar
  {
  }


  
  /** Represents a node in constraint graph. Used during type
      inference. */
  public class TyVar
  {
    /** Require [this] to be at least [t].
    
        To be called when we require some lower constraint on type
        variable. */
    public Require (t : TyVar) : void
    {
    }
    

    /** Require [this] to have the member [name].
        
        Return type of the member. */
    public RequireMember (name : string) : TyVar
    {
    }
    

    /** Provide type [t] as the maximal type for [this].
        
        To be called when value of type [t] is assigned to cell of type
        [this]. Symmetric to [Require]. */
    public Provide (t : TyVar) : void
    {
    }


    /** Make sure [t] and [this] will from now on always represent the 
        same type. */
    public Unify (t : TyVar) : void
    {
    }


    /** Return type associated with [this] in current solution.
    
        Warning: this type may change later! */
    public CurrentValue : TyVar
    {
      get {
      }
    }
    

    /** Make sure [CurrentValue] won't change anymore. Return [CurrentValue].
    
        Don't use this function unless absolutely necessary. */
    public Fixate () : TyVar
    {
    }


    /** Check if [this] is an array. If it is so, make sure it will remain
        an array type and return element type along with the rank. */
    public GetArrayType () : option <int * TyVar>
    {
    }


    /** Check if [this] is a function type. If it is so, make sure it
        will remain a function type and return the argument's types and
        the return type. */
    public GetFunctionType () : option <list <TyVar> * TyVar>
    {
    }
    

    /** Check if [this] is a product type. If it is so, make sure it
        will remain a product type and return the argument's types. */
    public GetProductType () : option <list <TyVar>>
    {
    }
  }

}
