(*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Compiler;
  open Nemerle.Compiler.Tyops;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Collections;
  
  open System.Reflection;
  open System.Reflection.Emit;


  (**
   * An IL code generator
   *)
  public class CGIL
  {
    (* -- PUBLIC CONSTRUCTORS ---------------------------------------------- *)
    
    (** 
     * Outputs objects from cgtree.n as IL code. 
     *)
    public this (decls : list (CM_class))
    {
      (* create the type builder queue *)
      this._type_builder_queue <- Queue ();
      
      (* create a weak assembly name and define a dynamic assembly *)
      this._assembly_name <- System.Reflection.AssemblyName ();
      this._assembly_name.Version <- System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name <- "CGILTest"; // FIXME

      this._assembly_builder <- 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      (* create a dynamic module *)
      this._module_builder <- this._assembly_builder.DefineDynamicModule ("CGILTest", "cgil-test.dll");      

      (* iterate the top declarations, adding them to the newly created assembly *)
      def emit_decl (decl : CM_class) : void {
        this.flat_member (decl, null)
      };
      List.iter (emit_decl, decls);
      
      (* execute the type builder queue *)
      def create_type (tb : TypeBuilder) : void {
        def _ = tb.CreateType ();
        ()
      };      
      this._type_builder_queue.iter (create_type);
            
      (* save the assembly *)
      this._assembly_builder.Save ("cgil-test.dll"); // FIXME
    }


    (* -- PRIVATE METHODS -------------------------------------------------- *)
    
    (**
     * Builds a Nemerle type attribute
     *)
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = typeof (Nemerle.TypeAttribute);
      def constructor_param_types = mkarray [typeof (System.String)];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     * Builds a Nemerle variant attribute
     *)
    private make_nemerle_variant_attribute () : CustomAttributeBuilder
    {
      def attr_type = typeof (Nemerle.VariantAttribute);
      def constructor_info = attr_type.GetConstructor (mkarray []);
      def attr_builder = CustomAttributeBuilder (constructor_info, (mkarray [] :> array (System.Object)));
      attr_builder
    }
    

    (**
     * Builds a Nemerle variant option attribute
     *)
    private make_nemerle_variant_option_attribute (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = typeof (Nemerle.VariantOptionAttribute);
      def constructor_param_types = mkarray [typeof (System.String)];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     *
     *)
    private nemerle_to_framework_type (ty : CG_type) : System.Type
    {
      typeof (System.Object) // FIXME
    }
    
    
    (**
     *
     *)
    private nemerle_field_modifiers_to_framework_attrs (attrs : list (Modifier)) : FieldAttributes
    {
      def process_modifier (modifier : Modifier) : FieldAttributes {
        match (modifier) {
          | Mod_public => FieldAttributes.Public
          | Mod_private => FieldAttributes.Private
          | Mod_new => Util.ice ("Mod_new is not supported for fields")
          | Mod_protected => FieldAttributes.Family
          | Mod_internal => FieldAttributes.FamORAssem
          | Mod_abstract => Util.ice ("Mod_abstract is not supported for fields")
          | Mod_virtual => Util.ice ("Mod_virtual is not supported for fields")
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for fields")
          | Mod_static => FieldAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for fields")
          | Mod_module => Util.ice ("Mod_module is not supported for fields")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) + this.nemerle_field_modifiers_to_framework_attrs (rest)
        | [] =>
          FieldAttributes.PrivateScope
      }
    }


    (**
     *
     *)
    private make_method_attributes (attrs : list (Modifier)) : MethodAttributes
    {
      def process_modifier (modifier : Modifier) : MethodAttributes {
        match (modifier) {
          | Mod_public => MethodAttributes.Public
          | Mod_private => MethodAttributes.Private
          | Mod_new => MethodAttributes.NewSlot
          | Mod_protected => MethodAttributes.Family
          | Mod_internal => MethodAttributes.FamORAssem
          | Mod_abstract => MethodAttributes.Abstract
          | Mod_virtual => MethodAttributes.Virtual
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for methods")
          | Mod_static => MethodAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for methods")
          | Mod_module => Util.ice ("Mod_module is not supported for methods")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) + this.make_method_attributes (rest)
        | [] =>
          MethodAttributes.PrivateScope
      }
    }


    (**
     *)  
    private type_list_to_type_array (x : list (System.Type)) : array (System.Type) {

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), List.length (x)) :> array (System.Type));
      
      def loop (index : int, x : list (System.Type)) : void {        
        match (x) {
          | head :: tail =>
            result [index] <- (head :> System.Type);
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }


    private make_method (type_builder : TypeBuilder, m : CM_method) : void
    {
      // Message.debug ("making a method");
      
      def mkparm (v : CG_val) : System.Type {
        this.nemerle_to_framework_type (v.ty)
      };
      
      def return_type = this.nemerle_to_framework_type (m.ret_type);
              
      def parameter_types = this.type_list_to_type_array (List.map (mkparm, m.parms));

      def method_builder = 
        type_builder.DefineMethod (m.name, this.make_method_attributes (m.modifiers),
                                   return_type, parameter_types);

      def il_generator = method_builder.GetILGenerator ();
      
      il_generator.Emit (OpCodes.Ldstr, "Hello world!");

      def system_console = typeof(System.Console);

      def method_info =
        system_console.GetMethod ("WriteLine", (mkarray [typeof(string)] :> array (System.Type)));

      il_generator.Emit (OpCodes.Call, method_info);
      il_generator.Emit (OpCodes.Ret);
    }


    private make_constructor (type_builder : TypeBuilder, m : CM_method) : void
    {
      // Message.debug ("making a constructor");
      
      ()
    }

    (**
     * Outputs a type member
     *)  
    flat_member (m : CG_member, type_builder : TypeBuilder) : void 
    {
      match (m) {
        | (CM_class) as m =>
          // Message.debug ("processing class " + m.ns + m.name);

          (* create optional custom attributes for this type *)
          def custom_attribute =
            match (m.kind) {          
              | CK_variant => 
                this.make_nemerle_variant_attribute ()
              | CK_variant_option (encoded_type) =>
                this.make_nemerle_variant_option_attribute (encoded_type)
              | _ => null
            };

          (* decide the new type attributes and inheritance rules *)
          def type_kind_attrs = 
            match (m.kind) { 
              | CK_class => TypeAttributes.Class
              | CK_struct => Util.ice ("CK_struct")
              | CK_interface => TypeAttributes.Interface + TypeAttributes.Abstract
              | CK_variant => TypeAttributes.Class
              | CK_variant_option (_) => TypeAttributes.Class
            };
            
(*            
          def inh =
            match (m.inheritance) {
              | [] => ST_leaf ("")
              | _ => " : " ++ st_concat (", ", List.map (flat_ty, m.inheritance))
            };
*)

          def attrs = type_kind_attrs + TypeAttributes.Public;

          (* create the type builder for a top-level or nested class declaration *)
          def tb = 
            if (type_builder == null)
              this._module_builder.DefineType (m.ns + m.name, attrs)
            else
              type_builder.DefineNestedType (m.name, TypeAttributes.NestedPublic + attrs);

          when (custom_attribute != null) {
            tb.SetCustomAttribute (custom_attribute);
          };

          this._type_builder_queue.add (tb);

          (* populate the newly created type builder *)
          def walk_members (decls : list (CG_member)) : void {
            match (decls) {
              | decl :: rest => 
                this.flat_member (decl, tb);
                walk_members (rest)
              | [] => ()
            }
          };                
          walk_members (m.decls)


      | (CM_field) as m =>
        assert (type_builder != null);
        
        // Message.debug ("emitting field " + m.name);
        def fb = type_builder.DefineField (m.name, 
                                           this.nemerle_to_framework_type (m.ty), 
                                           this.nemerle_field_modifiers_to_framework_attrs (m.modifiers));
        fb.SetCustomAttribute (this.make_nemerle_type_attr (m.encoded_type));

                   
      | (CM_property) as p =>
        Message.fatal_error ("emitting properties is not supported yet")

                          
      | (CM_method) as m =>
        assert (type_builder != null);

        CGopt.tail_call_optimize (m);

        match (m.ret_type) {
          | CT_unreached => this.make_constructor (type_builder, m)
          | _ => this.make_method (type_builder, m)
        }

(*      
        def mkparm (v : CG_val) : String_tree {
          flat_ty (v.ty) ++ " " ++ v.name
        };
        def rett = 
          match (m.ret_type) {
            | CT_unreached => ST_leaf ("")
            | _ => flat_ty (m.ret_type)
          };

        print_st (emit_nemerle_type_attr (m.encoded_type) ++ s_concat (" ", m.attrs) ++ " " ++ rett ++ "\n" ++ 
                  m.name ++ "(" ++ st_concat (", ", List.map (mkparm, m.parms)) ++ ")");

        match (m.body) {
          | CE_none => print_st (ST_leaf (";\n"))
          | _ =>
            def (pref, r) = make_complex (flat (m.body));
            def ret =
              if (is_dummy_type (m.ret_type))
                side_effect_run (r)
              else
                if (is_dummy_type (type_of (m.body)))
                  side_effect_run (r) ++ "return null;\n"
                else
                  "return " ++ r ++ ";\n";
                   
            when (base_class_ctor != null) {
              print_st (" : " ++ base_class_ctor ++ "\n");
              base_class_ctor <- null
            };
           
            print_st ("\n{\n" ++ pref ++ ret ++ "} // end of fun " ++ m.name ++ "\n")
        }
*)      
      }
    }


    (* -- PRIVATE FIELDS --------------------------------------------------- *)

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _type_builder_queue : Queue (TypeBuilder);
    
  } (* end of the module *)
  
} (* end of the namespace *)
