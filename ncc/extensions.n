(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler.Extensions;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Extensions {

  public implicit_ctor (par : Tyinfo) : Class_member
    {
      def collect (acc : list (PT.Expr) * list (Fun_parm), decl : Class_member) 
                  : list (PT.Expr) * list (Fun_parm)
        {
          match (decl) {
            | M_field (t, _) =>
              def n = decl.name;
              def fp = Fun_parm (loc = par.loc, name = n, ty = t, decl = null);
              def ex = PT.E_assign (PT.E_member (PT.E_this (), PT.SS_string (n)), 
                                    PT.E_ref (n));
              def (es, ps) = acc;
              (ex :: es, fp :: ps)
            | _ => acc
          }
        };
      def (assigns, parms) = List.fold_left (collect, ([], []), par.member_list);
      def fh = Fun_header (loc = par.loc, 
                           name = ".ctor", 
                           id = Util.next_id (),
                           ret_type = T_void (), 
                           parms = List.rev (parms),
                           typarms = [],
                           tenv = par.tenv,
                           closure_vars = []);
      def body = PT.E_sequence (assigns);
      body.loc <- par.loc;
      def f = M_function (fh, FK_ctor (), FB_parsed_expr (body));
      f.modifiers <- [Mod_public ()];
      f.name <- fh.name;
      f.loc <- fh.loc;
      f.id <- fh.id;
      f
    }

  get_params (pa : list (PT.Parm)) : list (PT.Expr)
    {
      def get_parm (p : PT.Parm) : PT.Expr { p.expr };
      List.map (get_parm, pa)
    }
        
  private class WhileMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ { def _N_whileloop () : void {
                    if ($cond) { $body; _N_whileloop() } 
                    else () 
                 }; 
                 _N_whileloop (); 
               } ]>

        | _ => 
          Message.fatal_error ("while macro expects two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_while" }
    
    public this () {}
  }


  private class UnlessMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ if ($cond) () else $body ]>
        | _ => 
          Message.fatal_error ("unless macro expects two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_unless" }
    
    public this () {}
  }

  private class WhenMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ if ($cond) $body else () ]>
        | _ => 
          Message.fatal_error ("when macro expects two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_when" }
    
    public this () {}
  }

  private class UsingMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      def store_exprs (args : list(PT.Parm), acc : list (PT.Expr) * list (PT.Expr)) : 
        list (PT.Expr) * list (PT.Expr)
      {
        def (preexprs, postexprs) = acc;

        match (args) {
          | [] => acc
          | {is_ref = false; name = ""; expr = ex } :: xs =>
            store_exprs (xs, (preexprs, <[ $ex . Dispose () ]> :: postexprs))
          | {is_ref = false; name = str; expr = ex } :: xs =>
            def name = PT.SS_string (str);
            store_exprs (xs, (<[ def $name = $ex ]> :: preexprs, 
                              <[ $(PT.E_ref (str)) . Dispose () ]> :: postexprs))

          | _ => Message.fatal_error ("Invalid parameters in 'using' macro")
        }
      };

      match (args) {
        | {is_ref = false; name = ""; expr = body } :: xs =>
          def (preexps, postexps) = store_exprs (xs, ([], [body]));
          def all_exps = List.append (List.rev (preexps), List.rev (postexps));
          <[ {.. $all_exps } ]>
        | _ =>
          Util.ice ("'using' macro have zero parameters")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_using" }
    
    public this () {}
  }

  private class PrintfMacro implements IMacro 
  {
    public variant FormatToken {
      | Text { body : string; }
      | TextNewline { body : string; }
      | Number
      | Str
      | Chr
    }

    public static parse_format (form : string) : list(FormatToken)
    {
      mutable i <- 0;
      mutable buf <- System.Text.StringBuilder ();
      mutable result <- [];
      def n = form.Length;
      
      while (i < n) { 
        match (form[i]) {
          | '%' =>
            // % occured, first dump text from buffer
            when ( buf.Length > 0 ) {
              result <- Text (buf.ToString ()) :: result;
              buf <- buf.Remove (0, buf.Length);
            };
            // now analyze next character
            i <- i + 1;
            if ( i < n ) {
              match (form[i]) {
                | 'd' => result <- Number () :: result
                | 's' => result <- Str () :: result
                | 'c' => result <- Chr () :: result
                | _ => 
                  Message.error ("Unsupported formatting sequence after % character")
              }
            }
            else
              Message.error ("Unexpected end of format after % character")
          | '\n' =>
            result <- TextNewline (buf.ToString ()) :: result;
            buf <- buf.Remove (0, buf.Length)
          | c =>
            buf <- buf.Append (c)
        };
        i <- i + 1;
      };

      // the result is reversed, but function using it will reverse it again
      result
    }

    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | PT.E_literal (L_string (format)) :: parms =>
          def make_expressions (toks : list(FormatToken), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.Write ($(PT.E_literal (L_string (t)))) ]> :: acc)
              | (TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.WriteLine ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (Number :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : int)) ]> :: acc)

              | (Str :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : string)) ]> :: acc)

              | (Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : char)) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for printf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for printf macro");
                acc
            }
          };
          
          def seq = make_expressions (parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("printf macro expects formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "printf" }
    
    public this () {}
  }

  public class ScanfMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | PT.E_literal (L_string (format)) :: parms =>
          def make_expressions (toks : list(PrintfMacro.FormatToken), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, <[ Nemerle.Input.CheckInput 
                  ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, <[ Nemerle.Input.CheckInput 
                  ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadInt () ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadString () ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- System.Char.ToChar (System.Console.Read ()) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for scanf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for scanf macro");
                acc
            }
          };
          
          def seq = <[ Nemerle.Input.EatWhiteSpace () ]> ::
            make_expressions (PrintfMacro.parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("scanf macro expects formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "scanf" }
    
    public this () {}
  }

  private class AssertMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond } ] =>             
            <[ if ($cond) () else 
               raise Assertion_failed ($(PT.E_literal (L_string (cond.loc.file))), 
                                       $(PT.E_literal (L_int (cond.loc.line))), "") ]>
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = message } ] =>
            <[ if ($cond) () else 
               raise Assertion_failed ($(PT.E_literal (L_string (cond.loc.file))), 
                                       $(PT.E_literal (L_int (cond.loc.line))), 
                                       $message) ]>
        | _ => 
          Message.fatal_error ("assert macro expects one or two arguments" +
           " (the condition and an optional message)")
      }
    }

    GetName () : string implements IMacro.GetName { "assert" }
    
    public this () {}
  }

  /// always register standard macros when compiler starts
  static this () {
    MacroRegistry.register_macro (WhileMacro ());
    MacroRegistry.register_macro (UsingMacro ());
    MacroRegistry.register_macro (WhenMacro ());
    MacroRegistry.register_macro (UnlessMacro ());
    MacroRegistry.register_macro (PrintfMacro ());
    MacroRegistry.register_macro (ScanfMacro ());
    MacroRegistry.register_macro (AssertMacro ())
  }
  
} // end module Extensions
} // end ns
