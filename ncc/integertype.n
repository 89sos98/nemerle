/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

namespace Nemerle.Compiler {

public interface INumericType {
  Zero : object { get; }
  One : object { get; }
  IsSigned : bool { get; }
  IsInteger : bool { get; }
  SystemType : System.Type { get; }
  Binary (op : string, x : object, y : object) : object;
  Unary (op : string, x : object) : object;
  //ConvertToSelf (from : object) : option <object>;
  FromLiteral (_ : Literal) : object;
  ToLiteral (_ : object) : Literal;
}

module NumericType {
  types : Hashtable <string, INumericType>;
  
  public ByName (name : string) : option <INumericType>
  {
    types.Get (name)
  }

  public ByLiteral (lit : Literal) : option <INumericType>
  {
    def name =
      match (lit) {
        | L_int => "System.Int32"
        | L_long => "System.Int64"
        | L_sbyte => "System.SByte"
        | L_byte => "System.Byte"
        | L_short => "System.Int16"
        | L_ushort => "System.UInt16"
        | L_uint => "System.UInt32"
        | L_ulong => "System.UInt64"
        | _ => ""
      };
    types.Get (name)
  }

  int_to_long (x : object) : option <long>
  {
    match (x.GetType ().FullName) {
      | "System.Int16" => Some (((x :> System.Int16) :> long))
      | "System.Int32" => Some (((x :> System.Int32) :> long))
      | "System.Int64" => Some (((x :> System.Int64) :> long))
      | "System.UInt16" => Some (((x :> System.UInt16) :> long))
      | "System.UInt32" => Some (((x :> System.UInt32) :> long))
      | "System.UInt64" => Some (((x :> System.UInt64) :> long))
      | "System.Byte" => Some (((x :> System.Byte) :> long))
      | "System.SByte" => Some (((x :> System.SByte) :> long))
      | "System.Char" => Some (((x :> System.Char) :> long))
      | _ => None ()
    }
  }

  int_to_ulong (x : object) : option <ulong>
  {
    if (x.GetType ().FullName == "System.UInt64")
      Some ((x :> ulong))
    else
      match (int_to_long (x)) {
        | Some (x) => Some ((x :> ulong))
        | None => None ()
      }
  }

  

  this ()
  {
    def type_list = [
      ("System.Int16", (Int16 () : INumericType)),
      ("System.UInt16", (UInt16 () : INumericType)),
      ("System.Int32", (Int32 () : INumericType)),
      ("System.UInt32", (UInt32 () : INumericType)),
      ("System.Int32", (Int64 () : INumericType)),
      ("System.UInt32", (UInt64 () : INumericType)),
      ("System.Double", (Double () : INumericType)),
      ("System.Single", (Single () : INumericType)),
      ("System.Byte", (Byte () : INumericType)),
      ("System.SByte", (SByte () : INumericType))
    ];
    types <- Hashtable ();
    List.Iter (type_list, fun (name, ty) { types.Set (name, ty) })
  }

// Begin generated code
  class SByte : INumericType {
    public Zero : object
    {
      get { 0B } 
    }
    
    public One : object
    {
      get { 1B }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { typeof (System.SByte) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.SByte);
      def y = (y :> System.SByte);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid sbyte operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.SByte);
      match (name) {
        | "+" => (+x :> object)
        | "-" => (-x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid sbyte operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_sbyte (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_sbyte ((x :> System.SByte))
    }

    public this () {}
  }


  class Byte : INumericType {
    public Zero : object
    {
      get { 0UB } 
    }
    
    public One : object
    {
      get { 1UB }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { typeof (System.Byte) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.Byte);
      def y = (y :> System.Byte);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid byte operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.Byte);
      match (name) {
        | "+" => (+x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid byte operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_byte (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_byte ((x :> System.Byte))
    }

    public this () {}
  }


  class Int16 : INumericType {
    public Zero : object
    {
      get { 0S } 
    }
    
    public One : object
    {
      get { 1S }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { typeof (System.Int16) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.Int16);
      def y = (y :> System.Int16);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid short operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.Int16);
      match (name) {
        | "+" => (+x :> object)
        | "-" => (-x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid short operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_short (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_short ((x :> System.Int16))
    }

    public this () {}
  }


  class UInt16 : INumericType {
    public Zero : object
    {
      get { 0US } 
    }
    
    public One : object
    {
      get { 1US }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { typeof (System.UInt16) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.UInt16);
      def y = (y :> System.UInt16);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid ushort operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.UInt16);
      match (name) {
        | "+" => (+x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid ushort operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_ushort (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_ushort ((x :> System.UInt16))
    }

    public this () {}
  }


  class Int32 : INumericType {
    public Zero : object
    {
      get { 0 } 
    }
    
    public One : object
    {
      get { 1 }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { typeof (System.Int32) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.Int32);
      def y = (y :> System.Int32);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid int operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.Int32);
      match (name) {
        | "+" => (+x :> object)
        | "-" => (-x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid int operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_int (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_int ((x :> System.Int32))
    }

    public this () {}
  }


  class UInt32 : INumericType {
    public Zero : object
    {
      get { 0U } 
    }
    
    public One : object
    {
      get { 1U }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { typeof (System.UInt32) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.UInt32);
      def y = (y :> System.UInt32);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid uint operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.UInt32);
      match (name) {
        | "+" => (+x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid uint operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_uint (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_uint ((x :> System.UInt32))
    }

    public this () {}
  }


  class Int64 : INumericType {
    public Zero : object
    {
      get { 0L } 
    }
    
    public One : object
    {
      get { 1L }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { typeof (System.Int64) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.Int64);
      def y = (y :> System.Int64);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid long operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.Int64);
      match (name) {
        | "+" => (+x :> object)
        | "-" => (-x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid long operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_long (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_long ((x :> System.Int64))
    }

    public this () {}
  }


  class UInt64 : INumericType {
    public Zero : object
    {
      get { 0UL } 
    }
    
    public One : object
    {
      get { 1UL }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { typeof (System.UInt64) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.UInt64);
      def y = (y :> System.UInt64);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | "%&" => (x %& y :> object)
        | "%|" => (x %| y :> object)
        | _ => 
          null
          // Util.ice ("invalid ulong operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.UInt64);
      match (name) {
        | "+" => (+x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid ulong operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_ulong (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_ulong ((x :> System.UInt64))
    }

    public this () {}
  }


  class Single : INumericType {
    public Zero : object
    {
      get { 0.0F } 
    }
    
    public One : object
    {
      get { 1.0F }
    }

    public IsInteger : bool
    {
      get { false }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { typeof (System.Single) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.Single);
      def y = (y :> System.Single);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | _ => 
          null
          // Util.ice ("invalid float operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.Single);
      match (name) {
        | "+" => (+x :> object)
        | "-" => (-x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid float operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_float (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_float ((x :> System.Single))
    }

    public this () {}
  }


  class Double : INumericType {
    public Zero : object
    {
      get { 0.0 } 
    }
    
    public One : object
    {
      get { 1.0 }
    }

    public IsInteger : bool
    {
      get { false }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { typeof (System.Double) }
    }
    
    public Binary (name : string, x : object, y : object) : object
    {
      def x = (x :> System.Double);
      def y = (y :> System.Double);
      match (name) {
        | "+" => (x + y :> object)
        | "-" => (x - y :> object)
        | "*" => (x * y :> object)
        | "/" => (x / y :> object)
        | "%" => (x % y :> object)
        | _ => 
          null
          // Util.ice ("invalid double operator `" + name + "'")
      }
    }

    public Unary (name : string, x : object) : object
    {
      def x = (x :> System.Double);
      match (name) {
        | "+" => (+x :> object)
        | "-" => (-x :> object)
        //| "~" => (~x :> object)
        | _ =>
          null
          // Util.ice ("invalid double operator `" + name + "'")
      }
    }

    public FromLiteral (lit : Literal) : object
    {
      | L_double (x) => (x :> object) // HACK! HACK! HACK! this is a bug in the compiler
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      L_double ((x :> System.Double))
    }

    public this () {}
  }


// End generated code

}
} // end namespace
