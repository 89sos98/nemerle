/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.Tyvar;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

  public module Tyvar
    {
      mutable tyvars : SystemMap <int, T>;

      store_tv (t : T) : void {
        tyvars <- tyvars.Add (t.id, t)
      }
      
      public class T
        {
          public name : string;
          public mutable constraints : list <Type>;
          public mutable is_free : bool;
          public mutable is_fixed : bool;
          public mutable is_from_null : bool;
          public id : int;

          public this (n : string)
            {
              this.name <- n;
              this.constraints <- [];
              this.is_free <- false;
              this.is_fixed <- false;
              this.is_from_null <- false;
              this.id <- Util.next_id ();
              store_tv (this);
            }

          public this (t : T)
            {
              this.name <- t.name;
              this.constraints <- t.constraints;        // to be is_fixed
              this.is_fixed <- true;       // not sure
              this.is_free <- true;
              this.is_from_null <- false;
              this.id <- Util.next_id ();
              store_tv (this);
            }

          public this ()
            {
              this.id <- Util.next_id ();
              this.name <- "_N_fv" + this.id.ToString ();
              this.constraints <- [];
              this.is_fixed <- true;       // not sure
              this.is_free <- true;
              this.is_from_null <- false;
              store_tv (this);
            }

          public add_constraint (ty : Type) : void
            {
              if (this.is_fixed)
                Message.error ("this type variable cannot get any new constraints here")
              else ();
              this.constraints <- ty :: this.constraints
            }
        }

      public class TEnv
        {
          tyvars : SystemMap <string, T>;
          
          private this (tv : SystemMap <string, T>)
            {
              this.tyvars <- tv;
            }

          public this ()
            {
              this.tyvars <- SystemMap ();
            }
          
          public bind (env : GlobalEnv, curtc : Tycon, t : PT.Type, check_parms : bool) : Type
          {
            def f (t : PT.Type) : Type {
              match (t) {
                | PT.T_ref (t) => T_ref (f (t))
                | PT.T_out (t) => T_out (f (t))
                | PT.T_array (t) => T_array (f (t))
                | PT.T_fun (x, y) => T_fun (f (x), f (y))
                | PT.T_void => T_void ()
                | PT.T_prod (a) => T_prod (List.Map (a, f))
                | PT.T_app (PT.SS_string ({ id = n }), args) =>
                  match (this.tyvars.Find (n)) {
                    | Some (tv) =>
                      match (args) {
                        | [] => ()
                        | _ => Message.error ("type variable `" + n + 
                                              "' supplied with arguments")
                      };
                      T_var (tv)
                    | None =>
                      def ti = env.GetType (n, curtc);
                      def args = List.Map (args, f);

                      when (check_parms) {
                        ignore (ti.MakeSubst (args))
                      };
                      
                      T_app (ti, args)
                  }

                | PT.T_infer =>
                  // this is our entire type inference... 
                  free_variable ()

                | PT.T_app (_, _) =>
                  Util.ice ("Spliced string survived to typing")
                | PT.T_spliced | PT.T_spliced_special =>
                  Util.ice ("Spliced type survived to typying.")
                | PT.T_type_list =>
                  Util.ice ("Type arguments list survived to typying.")
              }
            };
            f (t)
          }
          
          public add_typarms (env : GlobalEnv, tp : PT.Typarms,
                              curtc : Tycon, check_parms : bool) : TEnv * list <T>
          {
            def loop (tv : string, acc) {
              def (m, l) = acc;
              def tv = T (tv);
              ((m : SystemMap <string, T>).Replace (tv.name, tv), tv :: l)
            };
            def (m, l) = List.FoldLeft (tp.tyvars, (this.tyvars, []), loop);
            def tenv = TEnv (m);
            def add_constraint (c : PT.Constraint) {
              match (m.Find (c.tyvar)) {
                | Some (tv) =>
                  tv.add_constraint (tenv.bind (env, curtc, c.ty, check_parms))
                | None =>
                  Message.error ("unbound type variable `" + c.tyvar + "' in constraint")
              }
            };
            List.Iter (tp.constraints, add_constraint);
            def fixate (tv : T) : void { tv.is_fixed <- true };
            List.Iter (l, fixate);
            (tenv, List.Rev (l))
          }
      }

      public mutable global_subst : Subst;

      private lookup (id : int) : T 
      {
        match (tyvars.Find (id)) {
          | Some (x) => x
          | None => Util.ice ()
        }
      }

      public global_store (s : Subst) : void 
      {
        if (global_subst == null)
          global_subst <- SystemMap () else ();
        def f (id : int, t : Type, s : Subst) : Subst 
          {
            (lookup (id)).is_free <- false;
            s.Add (id, t)
          };
        global_subst <- s.Fold (f, global_subst)
      }

      public global_expand (t : Type) : Type
      {
        if (global_subst == null) t
        else t /- global_subst
      }
      
      public fresh_subst (parms : list <T>) : Subst
      {
        def loop (proto : T, ctx : Subst * list <T>) : Subst * list <T>
          {
            def (sub, vars) = ctx;
            def tv = Tyvar.T (proto);
            (sub.Add (proto.id, T_var (tv)), tv :: vars)
          };
        def (sub, vars) = List.FoldLeft (parms, (SystemMap (), []), loop);
        def sub_constraints (tv : T) : void {
          tv.constraints <- List.Map (tv.constraints, fun (t : Type) : Type { t /- sub })
        };
        List.Iter (vars, sub_constraints);
        sub
      }

      public free_variable () : Type { T_var (T ()) }

      public is_free (tv : T) : bool { tv.is_free }

      public constraints (tv : T) : list <Type> { tv.constraints }

     this ()
       {
         tyvars <- SystemMap ();
       }

   } // module Tyvar

} // end ns
