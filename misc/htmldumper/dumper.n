using System.Globalization;

using Nemerle.Compiler;
using Nemerle.IO;

class LexerDumper : LexerFile {
  mutable last_dump_loc : Location = Location.Default;
  mutable last_dump_length : int = 0;

  public this (file : string) {
    base (file);
    store_comments = true;
  }

  private Escape (str : string) : string {
    str.Replace ("&", "&amp;").Replace ("<", "&lt;").Replace (">", "&gt;")
  }
  
  public override GetToken () : Token {
    def tok = base.GetToken ();
    def (token_len, token_str) = 
      match (tok) {
        | Token.Identifier (name) => (name.Length, Escape (name))

        | Token.Keyword (name) =>
          (name.Length, $"<span class='key'>$name</span>")

        | Token.Operator (name, _) =>
          (name.Length, $"<span class='op'>$(Escape (name))</span>")

        | Token.StringLiteral (value) =>
          def value = Escape (value.Replace ("\n", "\\n"));
          (value.Length + 2, $"<span class='str'>\"$value\"</span>")

        | Token.CharLiteral (value) =>
          (3, $"<span class='char'>'$(value)'</span>")

        | Token.SByteLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 2, $"<span class='num'>$(value)SB</span>")

        | Token.ByteLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)B</span>")

        | Token.ShortLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)S</span>")

        | Token.UShortLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 2, $"<span class='num'>$(value)US</span>")

        | Token.IntLiteral (value) =>
          def str = value.ToString ();
          (str.Length, $"<span class='num'>$(value)</span>")

        | Token.UIntLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)U</span>")

        | Token.LongLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)L</span>")

        | Token.ULongLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 2, $"<span class='num'>$(value)UL</span>")

        | Token.FloatLiteral (value) =>
          def str = value.ToString (CultureInfo.InvariantCulture);
          (str.Length + 1, $"<span class='num'>$(value)f</span>")

        | Token.DoubleLiteral (value) =>
          def str = value.ToString (CultureInfo.InvariantCulture);
          (str.Length, $"<span class='num'>$(value)</span>")

        | Token.DecimalLiteral (value) =>
          def str = value.ToString (CultureInfo.InvariantCulture);
          (str.Length + 1, $"<span class='num'>$(value)M</span>")

        | Token.Comment (value) =>
          def value = value.TrimEnd (array [' ', '\n']);
          def height_loop (i, sum) {
            if (i < value.Length)
              if (value [i] == '\n') height_loop (i + 1, sum + 1)
              else height_loop (i + 1, sum)
            else
              sum
          }
          if (height_loop (0, 1) > 1)
            (value.Length + 6, $"<span class='comment'>/* $(value) */\n</span>")
          else
            (value.Length + 3, $"<span class='comment'>// $(value)\n</span>")

        | Token.EndOfFile => (0, "")
      }
    unless ((tok matches Token.EndOfFile) || (defines.Get ("OMMIT") matches Some (true))) {
      def cur_loc = this.Location;
      when (cur_loc != Location.Default) 
        if (cur_loc.Line != last_dump_loc.Line) {
          repeat (cur_loc.Line - last_dump_loc.Line) print ("\n");
          repeat (cur_loc.Column) print (" ");
        }
        else
          repeat (cur_loc.Column - last_dump_loc.Column - last_dump_length)
            Nemerle.IO.print (" ");

      // dump current token string            
      print (token_str);

      // remember current location as the previous one
      if (tok matches Token.Comment) {
        // we must treat comment in a special way, because they have broken location
        repeat (this.CurrentLocation.Column) Nemerle.IO.print (" ");        
        last_dump_loc = this.CurrentLocation;
      }
      else
        last_dump_loc = cur_loc;
      last_dump_length = token_len;
    }
    tok
  }
}

module Dumper {
  Main (args : array [string]) : void {
    if (args.Length < 1) printf ("usage: dumper.exe filename.n DEF1 DEF2 ...\n");
    else {
      def filename = args [0];
      LibraryReferenceManager.LoadMacrosFrom ("Nemerle.Macros");
      MacroRegistry.LoadSyntaxExtensions ("Nemerle.Core");
      Location.AddFiles ([filename]);
      for (mutable i = 1; i < args.Length; ++i)
        LexerDumper.command_defines.Set (args [i], true);

      def lex = LexerDumper (filename);
      print ("<pre class='code'>\n");
      _ = Parser.parse (lex);
      print ("\n</pre>\n");
    }
  }
}

