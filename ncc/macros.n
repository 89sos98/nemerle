/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Transformations of quoted expressions into syntax trees
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler.Parsetree;
namespace TT = Nemerle.Compiler.Typedtree;
using System.Text;

namespace Nemerle.Compiler {

public module Macros
{
  /// PUBLIC API FOR USAGE IN MACROS

  /** generates new unique symbol, which can be safely used
      as name of quoted variables, functions, etc.
   */
  public NewSymbol () : Name
  {
    Name (Util.tmpname (""), TypingContext.MacroColor, null)
  }

  /** controlled hygiene breaking - generates symbol, which
      placed in generated code would bind to variables
      at macro-use site
   */
  public UseSiteSymbol (id : string) : Name
  {
    Name (id, TypingContext.MacroUseColor, TypingContext.MacroUseContext)
  }

  /** Checks if given expression describes name of a type, like
      [System.Console] (it is a class)
   */
  public IsTypeName (ctx : CTX, e : Expr) : bool
  {
    def collect_member (obj : Expr, acc) {
      match (obj) {
        | <[ $(n : name) ]> =>
          def env = n.GetEnv (ctx.env);
          match (env.LookupType (NString.Concat (".", n.id :: acc))) {
            | Some => true
            | _ => false
          }
        | <[ $head.$(id : dyn) ]> => collect_member (head, id :: acc)
        | _ => false
      }
    };
    collect_member (e, [])
  }
  
  /** Lifts given list of expressions to syntax tree of list containing
      elements, whose syntax trees are defined by those expressions.
      (expressions on the list are not lifted)
   */
  public Lift (l : list<Expr>) : Expr
  {
    | x :: xs => <[ $x :: $(Lift (xs)) ]>
    | [] => <[ [] ]>
  }

  /** Lifts given list to syntax tree of this list, applying
      supplied function to each of its elements. The function
      is used here to lift elements of list, so we can build
      entire syntax trees from them.
   */
  public Lift<'a> (l : list<'a>, f : 'a -> Expr) : Expr
  {
    match (l) {
      | x :: xs => <[ $(f (x)) :: $(Lift (xs, f)) ]>
      | [] => <[ [] ]>
    }
  }

  /** Creates syntax tree of given number (expression building it) */
  public Lift (x : int) : Expr { <[ $(x : int) ]> }

  
  /** Lifts given list of patterns to syntax tree of pattern list
      containing elements, whose syntax trees are defined by those
      patterns.
      (patterns on the list are not lifted)
   */
  public LiftPattern (l : list<Pattern>) : Pattern
  {
    | x :: xs => <[ pattern: $x :: $(LiftPattern (xs)) ]>
    | [] => <[ pattern: [] ]>
  }

  /** Lifts given list to syntax tree of this list, applying
      supplied function to each of its elements. The function
      is used here to lift elements of list, so we can build
      entire syntax trees from them.
   */
  public LiftPattern<'a> (l : list<'a>, f : 'a -> Pattern) : Pattern
  {
    match (l) {
      | x :: xs => <[ pattern: $(f (x)) :: $(LiftPattern (xs, f)) ]>
      | [] => <[ pattern: [] ]>
    }
  }

  
  /// DATA STRUCTURES USED IN QUOTATION AND MACROS
 variant MacroParm 
  {
    | MP_expr
    | MP_parm
    | MP_exprs
    | MP_parms
  }
  
  public type CTX = TypingContext;

  implicit_ctx_name : Name;

  public GetImplicitCTXName () : Name { implicit_ctx_name }
  
  public this () { implicit_ctx_name <- NewSymbol () }
  
  // some tool methods
  public UnSString (x : Splicable_string) : string
  {
    | SS_string ({ id = x }) => x
    | _ => throw System.ArgumentException ("Macros.UnSString")
  }

  public NameOfSString (x : Splicable_string) : Name
  {
    | SS_string (x) => x
    | _ => throw System.ArgumentException ("Macros.NameOfSString")
  }

  // QUOTATION HANDLING SECTION

  /** Lifts up [Splicable_string]. [SS_spliced_expr] is substituted by its
      content and appropriate [SS_string] expression is created.
   */
  quoted_sstring (ctx : CTX, st : Splicable_string) : Expr
  {
    match (st) {
      | SS_string ({ id = str }) =>
        def c = ctx.env.GetMacroContext ();
        <[ SS_string (Name.NameInCurrentColor ($(str : string),
            $("_N_MacroContexts" : dyn).Get ($(c : int)))) ]>
                          
      | SS_spliced_expr (E_spliced_special ("name", e)) => 
        <[ SS_string ($e) ]>

      | SS_spliced_expr (E_spliced_special ("dyn", e)) => 
        <[ SS_string (Name ($e, -1, null)) ]>

      | SS_spliced_expr (e) => e
    }
  }

  /** Lifts up [Name] giving it supplied context number. */
  quoted_name (n : Name, context : int) : Expr
  {
    <[ Name.NameInCurrentColor ($(n.id : string), 
                                $("_N_MacroContexts" : dyn).Get ($(context : int))) ]>
  }

  quoted_string (s : string) : Expr { <[ $(s : string) ]> }
  
  /// create construction tree of given call parameter
  public quoted_param (ctx : CTX, p : Parm) : Expr
  {
    match (p) {
      | <[ parameter: $name = $expr ]> =>
        <[ Parm (false, $(quoted_expr (ctx, expr)), 
                 $(quoted_sstring (ctx, name))) ]>
      | <[ parameter: ref $name = $expr ]> =>
        <[ Parm (true, $(quoted_expr (ctx, expr)), 
                 $(quoted_sstring (ctx, name))) ]>
    }
  }

  public quoted_case_guard (ctx : CTX, pair : Pattern * option <Expr>) : Expr
  {
    match (pair) {
      | <[ caseguard: $pat when $gu ]> => 
        <[ ($(quoted_pattern (ctx, pat)), Some ($(quoted_expr (ctx, gu)))) ]>
      | <[ caseguard: $pat ]> =>
        <[ ($(quoted_pattern (ctx, pat)), None ()) ]>
    }
  }

  public quoted_case (ctx : CTX, cas : Match_case) : Expr
  {
    def <[ case: | ..$guards => $expr ]> = cas;
    def quotedc_case_guard (x) { quoted_case_guard (ctx, x) };
    
    match (guards) {
      | [(P_patt_list (args), None)] =>
        <[ Match_case ($(quoted_pattern (ctx, args)),
                       $(quoted_expr (ctx, expr))) ]>
      | _ =>
        <[ Match_case ($(Lift (guards, quotedc_case_guard)),
                       $(quoted_expr (ctx, expr))) ]>
    }
  }

  public quoted_fparam (ctx : CTX, p : Fun_parm) : Expr
  {
    match (p) {
      | <[ funparm: $name : $ty ]> =>
        <[ Fun_parm ($(quoted_sstring (ctx, name)),
                     $(quoted_type (ctx, ty)), FP_normal ()) ]>
                     
      | <[ funparm: params $name : $ty ]> =>
        <[ Fun_parm ($(quoted_sstring (ctx, name)),
                     $(quoted_type (ctx, ty)), FP_params ()) ]>
                     
      | <[ funparm: $name : $ty = $expr ]> =>
        <[ Fun_parm ($(quoted_sstring (ctx, name)),
                     $(quoted_type (ctx, ty)),
                     FP_default ($(quoted_expr (ctx, expr)))) ]>
    }
  }

  quoted_tparms (ctx : CTX, tyvars : list <string>, 
                 constraints : list <Constraint>) : Expr 
  {
    def quoted_constr (c : Constraint) {
      <[ Constraint ($(c.tyvar : string), $(quoted_type (ctx, c.ty))) ]>
    };

    match (constraints) {
      | [("", T_prod ([T_void,T_spliced (e)]))] =>
        <[ Typarms ($(Lift (tyvars, quoted_string)), $e) ]>

      | [("", T_prod ([T_spliced (e1), T_spliced (e2)]))] =>
        <[ Typarms ($e1, $e2) ]>

      | ("", T_prod ([T_spliced (e), T_void])) :: where_cts =>
        <[ Typarms ($e, $(Lift (where_cts, quoted_constr))) ]>

      | _ =>
        <[ Typarms ($(Lift (tyvars, quoted_string)),
                    $(Lift (constraints, quoted_constr))) ]>
    }
  }

  make_quoted_funheader (ctx : CTX, parms : list<Fun_parm>, qtparms : Expr,
                         ty : Type, qname : Expr) : Expr
  {
    def qparms =
      match (parms) {
        | [{ name = SS_string ({ id = "" }); ty = <[ type: void ]>; 
             attr = FP_default (e); }] =>
          quoted_expr (ctx, e)
        | _ =>
          Lift (parms, fun (x) { quoted_fparam (ctx, x) })
      };
    def qtype = quoted_type (ctx, ty);
    <[ Fun_header ($qtparms, $qname, $qtype, $qparms) ]>
  } 
  
  make_quoted_fundecl (ctx : CTX, parms : list<Fun_parm>, qtparms : Expr,
                       ty : Type, qname : Expr, body : Expr) : Expr
  {
    def qheader = make_quoted_funheader (ctx, parms, qtparms, ty, qname);
    def qbody = quoted_expr (ctx, body);
    <[ Function_decl ($qheader, $qbody) ]>
  }

  quoted_attributes (ctx : CTX, attrs : list<Modifier>) : Expr
  {
    def quoted_modifier (x) {
      | Mod_public => <[ Mod_public () ]>
      | Mod_private => <[ Mod_private () ]>        
      | Mod_new => <[ Mod_new () ]>        
      | Mod_protected => <[ Mod_protected () ]>
      | Mod_internal => <[ Mod_internal () ]>
      | Mod_abstract => <[ Mod_abstract () ]>
      | Mod_virtual => <[ Mod_virtual () ]>
      | Mod_sealed => <[ Mod_sealed () ]>
      | Mod_static => <[ Mod_static () ]>
      | Mod_override => <[ Mod_override () ]>
      | Mod_mutable => <[ Mod_mutable () ]>
      | Mod_module => <[ Mod_module () ]>
      | Mod_struct => <[ Mod_struct () ]>
      | Mod_macro => <[ Mod_macro () ]>
      | Mod_attribute (attrs) =>
        <[ Mod_attribute ($(Lift (List.Map (attrs, fun (x) {
             quoted_expr (ctx, x)
           })))) ]>
    };
    Lift (List.Map (attrs, quoted_modifier))
  }
  
  public quoted_method (ctx : CTX, m : Class_member) : Expr
  {
    def quoted_funbody (x) {
      | FB_parsed_expr (expr) =>
        <[ FB_parsed_expr ($(quoted_expr (ctx, expr))) ]>
      | FB_typed_expr (expr) => <[ FB_parsed_expr ($(expr : typed)) ]>
      | FB_compiled_expr => <[ FB_compiled_expr () ]>
      | FB_extern (name) => <[ FB_extern ($(name : string)) ]> 
      | FB_abstract => <[ FB_abstract () ]> 
    };
    def quoted_funkind (x) {
      | FK_method (impl) =>
        match (impl) {
          | [SS_spliced_expr (E_expr_list (e))] =>
            <[ FK_method ($(quoted_expr (ctx, e))) ]>
          | _ =>
            <[ FK_method ($(Lift (List.Map (impl, fun (x) {
                 quoted_sstring (ctx, x)
               })))) ]>
        }
      | FK_bound_method =>
        // quotation of IMethod? noooo!
        <[ FK_bound_method ([]) ]>
      | FK_ctor => <[ FK_ctor () ]>
      | FK_static_ctor => <[ FK_static_ctor () ]>
      | FK_function => <[ FK_function () ]>
      | FK_iface_method (new_flag) => <[ FK_iface_method ($(new_flag : bool)) ]>
    };
    match (m) {
      | <[ method: ..$attrs $n < ..$tparms> (..$fparms) : $t where ..$cts
                   implements ..$impl $body ]> =>
        def qtparms = quoted_tparms (ctx, tparms, cts);
        def qnm = quoted_sstring (ctx, n);
        def qhd = make_quoted_funheader (ctx, fparms, qtparms, t, qnm);
        def qmodifi =                                      
          match (attrs) {
            | [Mod_attribute ([E_expr_list (e)])] =>
              quoted_expr (ctx, e)
            | _ =>
              quoted_attributes (ctx, attrs)
          };
        <[ M_function (name = $qnm,
                       modifiers = $qmodifi,
                       header = $qhd,
                       kind = $(quoted_funkind (FK_method (impl))),
                       body = $(quoted_funbody (FB_parsed_expr (body)))) ]>
      | _ =>
        Util.ice ("parser in <[ method: .. ]> generated something strange")
    }
  }

  public quoted_field (ctx : CTX, m : Class_member) : Expr
  {
    match (m) {
      | <[ field: ..$attrs $name : $t; ]> =>
        match (attrs) {
          | [Mod_attribute ([E_expr_list (e)])] =>
            <[ M_field (name = $(quoted_sstring (ctx, name)),
                        modifiers = $(quoted_expr (ctx, e)),
                        ty = $(quoted_type (ctx, t))) ]>
          | _ =>     
            <[ M_field (name = $(quoted_sstring (ctx, name)),
                        modifiers = $(quoted_attributes (ctx, attrs)),
                        ty = $(quoted_type (ctx, t))) ]>
        }
      | _ => Util.ice ("parser in <[ field: .. ]> generated something strange")
    }
  }
  
  public quoted_fundecl (ctx : CTX, d : Function_decl) : Expr
  {
    def <[ fundecl: $name < ..$typarms> (..$args) : $ty
                    where ..$tyconstrs $body ]> = d;
    def qtparms = quoted_tparms (ctx, typarms, tyconstrs);
    def qname = quoted_sstring (ctx, name);
    make_quoted_fundecl (ctx, args, qtparms, ty, qname, body)
  }

  /** Creates parse tree of (expression which builds) given typed type. */
  public quoted_ttype (ctx : CTX, t : Type) : Expr
  {
    def quotedc_ttype (x) { quoted_ttype (ctx, x) };

    match (t) {
      | <[ type: $tycon < .. $args > ]> =>
        def tyco = match (tycon) { 
          | SS_string ({ id = s }) => <[ $(s : string) ]>
          | SS_spliced_expr (e) => e
        };
        def findtyco = <[
          match (Nemerle.Macros.ImplicitCTX ().env.LookupType ($tyco)) {
            | Some (x) => x
            | None => Message.fatal_error ("unbound type " + $tyco)
          }
        ]>;
        match (args) {
          | [T_type_list(ar)] => 
            <[ TT.T_app ($findtyco, $(quoted_ttype (ctx, ar))) ]>
          | _ =>
            <[ TT.T_app ($findtyco, $(Lift (args, quotedc_ttype))) ]>
        }

      | <[ type: ref $ty ]> =>
        <[ TT.T_ref ($(quoted_ttype (ctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ TT.T_out ($(quoted_ttype (ctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ TT.T_fun ($(quoted_ttype (ctx, from)), $(quoted_ttype (ctx, to))) ]>
  
      | <[ type: void ]> => <[ TT.T_void () ]>
        
      | <[ type: .. $args ]> =>
        <[ TT.T_prod ($(Lift (args, quotedc_ttype))) ]>

      | <[ type: array < $ty > ]> =>
        <[ TT.T_array ($(quotedc_ttype (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "name" => <[ TT.T_var (Tyvar.T ($val)) ]>
            // it doesn't make much sense here, as it is the same as <[ $v ]>,
            // but we put it here for consistency
            | "typed" => val
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer => <[ TT.T_infer () ]>

      | T_type_list (ar) =>
        <[ TT.T_prod ($(quoted_ttype (ctx, ar))) ]>

      | T_typed => 
        Util.ice ("You've got beer from me for generating such a code...");
    } 
  }

  /** Transforms syntax tree of quoted parsed type to its construction tree
      (expression which builds it). */
  public quoted_type (ctx : CTX, t : Type) : Expr
  {
    def quotedc_type (x) { quoted_type (ctx, x) };

    match (t) {
      | <[ type: $tycon < .. $args> ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ T_app ($(quoted_sstring (ctx, tycon)),
                      $(quoted_type (ctx, ar))) ]>
          | _ =>
            <[ T_app ($(quoted_sstring (ctx, tycon)), 
                      $(Lift (args, quotedc_type))) ]>
        }

      | <[ type: ref $ty ]> =>
        <[ T_ref ($(quoted_type (ctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ T_out ($(quoted_type (ctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ T_fun ($(quoted_type (ctx, from)), $(quoted_type (ctx, to))) ]>
  
      | <[ type: void ]> => <[ T_void () ]>
  
      | <[ type: .. $args ]> =>
        <[ T_prod ($(Lift (args, quotedc_type))) ]>

      | <[ type: array < $ty > ]> =>
        <[ T_array ($(quotedc_type (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "name" => 
              <[ T_app (SS_string ($val), []) ]>
            | "typed" => 
              <[ T_typed ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer => <[ T_infer () ]>

      | T_type_list (ar) => <[ T_prod ($(quoted_type (ctx, ar))) ]>

      | T_typed => 
        Util.ice ("You've got beer from me for generating such a code...");
    } 
  }

  /** transforms syntax tree of quoted pattern to its construction
      tree 
   */   
  public quoted_pattern (ctx : CTX, pat : Pattern) : Expr 
  {
    def quotedc_pattern (x) { quoted_pattern (ctx, x) };

    match (pat) {
      | <[ pattern: _ ]> => <[ P_underscore () ]>

      | <[ pattern: $(n : name) ]> =>
        <[ P_variable ($(quoted_name (n, 0))) ]>

      | <[ pattern: ($pat) as $name ]> => 
        <[ P_as ($(quoted_pattern (ctx, pat)), $(quoted_sstring (ctx, name))) ]>

      | <[ pattern: (.. $args) ]> =>
        match (args) {
          | [P_patt_list (args)] =>
            <[ P_tuple ($(quoted_pattern (ctx, args))) ]>
          | _ =>
            <[ P_tuple ($(Lift (args, quotedc_pattern))) ]>
        }

      | <[ pattern: {.. $args } ]> =>
        def quoted_named_pattern (patt : string * Pattern) : Expr
        {
          | (name, pat) =>
            <[ ($(name : string), $(quoted_pattern (ctx, pat))) ]>
        };

        match (args) {
          | [(_, P_patt_list (args))] =>
            <[ P_record ($(quoted_pattern (ctx, args))) ]>
          | _ =>
            <[ P_record ($(Lift (args, quoted_named_pattern))) ]>
        }

      | <[ pattern: $name (.. $args) ]> =>
        <[ P_cons ($(quoted_sstring (ctx, name)), 
                   $(quoted_pattern (ctx, P_tuple (args)))) ]>

      | <[ pattern: $name {.. $args} ]> =>
        <[ P_cons ($(quoted_sstring (ctx, name)), 
                   $(quoted_pattern (ctx, P_record (args)))) ]>

      | <[ pattern: $(val : int) ]> =>
        <[ P_literal (L_int ($(val : int))) ]>

      | <[ pattern: $(val : uint) ]> =>
        <[ P_literal (L_uint ($(val : uint))) ]>

      | <[ pattern: $(val : byte) ]> =>
        <[ P_literal (L_byte ($(val : byte))) ]>

      | <[ pattern: $(val : sbyte) ]> =>
        <[ P_literal (L_sbyte ($(val : sbyte))) ]>

      | <[ pattern: $(val : short) ]> =>
        <[ P_literal (L_short ($(val : short))) ]>

      | <[ pattern: $(val : ushort) ]> =>
        <[ P_literal (L_ushort ($(val : ushort))) ]>

      | <[ pattern: $(val : long) ]> =>
        <[ P_literal (L_long ($(val : long))) ]>

      | <[ pattern: $(val : ulong) ]> =>
        <[ P_literal (L_ulong ($(val : ulong))) ]>

      | <[ pattern: $(val : string) ]> =>
        <[ P_literal (L_string ($(val : string))) ]>

      | <[ pattern: $(val : bool) ]> =>
        <[ P_literal (L_bool ($(val : bool))) ]>

      | <[ pattern: $(val : float) ]> =>
        <[ P_literal (L_float ($(val : float))) ]>

      | <[ pattern: $(val : double) ]> =>
        <[ P_literal (L_float ($(val : double))) ]>

      | <[ pattern: $(val : decimal) ]> =>
        <[ P_literal (L_float ($(val : decimal))) ]>

      | <[ pattern: $(val : char) ]> =>
        <[ P_literal (L_char ($(val : char))) ]>

      | <[ pattern: () ]> => <[ P_literal (L_void ()) ]>

      | <[ pattern: null ]> => <[ P_literal (L_null ()) ]>

      | <[ pattern: $name _ ]> =>
        <[ P_cons ($(quoted_sstring (ctx, name)), P_underscore ()) ]>

      | P_literal (L_enum (l, _)) =>
        quoted_pattern (ctx, P_literal (l))

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | P_spliced (e) => e

      | P_spliced_special (ty, val) =>
        match (ty) {
          | "name" => <[ P_variable ($val) ]>
          | "typed" => <[ Typedtree.P_typed ($val) ]>

          | "byte" => <[ P_literal (L_byte ($val)) ]>
          | "sbyte" => <[ P_literal (L_sbyte ($val)) ]>
          | "short" => <[ P_literal (L_short ($val)) ]>
          | "ushort" => <[ P_literal (L_ushort ($val)) ]>
          | "int" => <[ P_literal (L_int ($val)) ]>
          | "uint" => <[ P_literal (L_uint ($val)) ]>
          | "long" => <[ P_literal (L_long ($val)) ]>
          | "ulong" => <[ P_literal (L_ulong ($val)) ]>
          | "string" => <[ P_literal (L_string ($val)) ]>
          | "bool" => <[ P_literal (L_bool ($val)) ]>
          | "char" => <[ P_literal (L_char ($val)) ]>
          | "float" => <[ P_literal (L_float ($val)) ]>
          | "double" => <[ P_literal (L_double ($val)) ]>
          | "decimal" => <[ P_literal (L_decimal ($val)) ]>

          | _ => Util.ice ("unsupported type of spliced literal in pattern")
        }

      | P_quoted =>
        Message.fatal_error ("compound of several <[ ... ]> macro scopes is"
                             " not allowed")
      | P_patt_list =>
        Message.fatal_error ("Variable pattern arguments list appears outside"
                             + " of proper construct")
      | P_cons (_, _) =>
        Util.ice ("Bad constructed P_cons")
      | P_typed => 
        Util.ice ("You've got beer from me for generating such a code...");
    } 
  }
  
  public quoted_expr (ctx : CTX, expr : Expr) : Expr 
  {
    def quotedc_expr (x) { quoted_expr (ctx, x) };
    
    match (expr) {
      | <[ $(id : name) ]> =>
        <[ E_ref ($(quoted_name (id, ctx.env.GetMacroContext ()))) ]>
      | <[ $obj . $mem ]> => 
        <[ E_member ($(quotedc_expr (obj)),$(quoted_sstring (ctx, mem))) ]>

      | <[ $func (.. $parms) ]> =>
        match (parms) {
          | [ { expr = E_expr_list (args) }] =>
            <[ E_call ($(quoted_expr (ctx, func)), $(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_call ($(quotedc_expr (func)), 
                       $(Lift (parms, fun (x) { quoted_param (ctx, x) }))) ]>
        }

      | <[ $target <- $source ]> =>
        <[ E_assign ($(quoted_expr (ctx, target)), $(quoted_expr (ctx, source))) ]>

      | <[ def $name = $val ]> =>
        <[ E_let ($(false : bool), $(quoted_sstring (ctx, name)), 
                  $(quoted_expr (ctx, val))) ]>

      | <[ mutable $name <- $val ]> =>
        <[ E_let ($(true : bool), $(quoted_sstring (ctx, name)),
                  $(quoted_expr (ctx, val))) ]>

      | <[ def (.. $elems) = $val ]> =>
        <[ E_letpat ($(quoted_pattern (ctx, P_tuple (elems))), 
                     $(quoted_expr (ctx, val))) ]>;

      | <[ def .. $funs ]> =>
        match (funs) {
          | [(_, E_expr_list (args))] =>
            <[ E_letfun ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_letfun ($(Lift (funs, fun (x) { quoted_fundecl (ctx, x) }))) ]>
        };

      | <[ fun < ..$typarms> (..$args) : $ty where .. $tyconstrs $body ]> =>
        def qtparms = quoted_tparms (ctx, typarms, tyconstrs);
        def qname = <[ SS_string (Name ("")) ]>;
        // lift function declaration from lambda expression
        def fdecl = make_quoted_fundecl (ctx, args, qtparms, ty, qname, body);
        // return syntax tree of lifted lambda
        <[ E_lambda ($fdecl) ]>

      | <[ match ($expr) {.. $cases } ]> =>
        match (cases) {
          | [cas] when match (cas.patterns) { | [] => true | _ => false } =>
            match (cas.body) {
              | E_expr_list (e) =>
                <[ E_match ($(quoted_expr (ctx, expr)), $(quoted_expr (ctx, e))) ]>
              | _ =>
                Util.ice ("parser generated strange match_case")
            }
          | _ =>
            <[ E_match ($(quoted_expr (ctx, expr)), 
                        $(Lift (cases, fun (x) { quoted_case (ctx, x) }))) ]>
        }

      | <[ throw $exc ]> =>
        <[ E_raise ($(quoted_expr (ctx, exc))) ]>

      | <[ try $body catch { $exn : $exn_ty => $handler } ]> => 
        def qbody = quoted_expr (ctx, body);
        <[ E_try_with ($qbody, $(quoted_sstring (ctx, exn)),
                       $(quoted_type (ctx, exn_ty)), 
                       $(quoted_expr (ctx, handler))) ]>

      | <[ try $body finally $handler ]> =>
        <[ E_try_finally ($(quoted_expr (ctx, body)), 
                          $(quoted_expr (ctx, handler))) ]>

      | <[ () ]> => <[ E_literal (L_void ()) ]>

      | <[ null ]> => <[ E_literal (L_null ()) ]>

      | <[ $(val : int) ]> => <[ E_literal (L_int ($(val : int))) ]>

      | <[ $(val : uint) ]> => <[ E_literal (L_uint ($(val : uint))) ]>

      | <[ $(val : byte) ]> => <[ E_literal (L_byte ($(val : byte))) ]>

      | <[ $(val : sbyte) ]> => <[ E_literal (L_sbyte ($(val : sbyte))) ]>
        
      | <[ $(val : short) ]> => <[ E_literal (L_short ($(val : short))) ]>

      | <[ $(val : ushort) ]> => <[ E_literal (L_ushort ($(val : ushort))) ]>

      | <[ $(val : long) ]> => <[ E_literal (L_long ($(val : long))) ]>

      | <[ $(val : ulong) ]> => <[ E_literal (L_ulong ($(val : ulong))) ]>

      | <[ $(val : string) ]> => <[ E_literal (L_string ($(val : string))) ]>

      | <[ $(val : float) ]> => <[ E_literal (L_float ($(val : float))) ]>

      | <[ $(val : double) ]> => <[ E_literal (L_float ($(val : double))) ]>

      | <[ $(val : decimal) ]> => <[ E_literal (L_float ($(val : decimal))) ]>
      
      | <[ $(val : bool) ]> => <[ E_literal (L_bool ($(val : bool))) ]>

      | <[ $(val : char) ]> => <[ E_literal (L_char ($(val : char))) ]>

      | <[ this ]> => <[ E_this () ]>

      | <[ base ]> => <[ E_base () ]>

      | <[ typeof ($t) ]> => <[ E_typeof ($(quoted_type (ctx, t))) ]>

      | <[ ( $expr :> $ty ) ]> =>
        <[ E_type_conversion ($(quoted_expr (ctx, expr)),
                              $(quoted_type (ctx, ty))) ]>

      | <[ ( $expr : $ty ) ]> =>
        <[ E_type_enforcement ($(quoted_expr (ctx, expr)),
                               $(quoted_type (ctx, ty))) ]>

      | <[ {.. $seq } ]> =>
        match (seq) {
          | [E_expr_list (seq)] =>
            <[ E_sequence ($(quoted_expr (ctx, seq))) ]>
          | _ =>
            <[ E_sequence ($(Lift (seq, quotedc_expr))) ]>
        }

      | <[ (.. $args) ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ E_tuple ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_tuple ($(Lift (args, quotedc_expr))) ]>
        }

      | <[ array [.. $args] ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ E_mkarray ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_mkarray ($(Lift (args, quotedc_expr))) ]>
        }

      | <[ array (.. $sizes) ]> =>
        match (sizes) {
          | [E_expr_list (args)] =>
            <[ E_empty_array ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_empty_array ($(Lift (sizes, quotedc_expr))) ]>
        }

      | <[ $obj [.. $args] ]> =>  
        match (args) {
          | [E_expr_list (args)] =>
            <[ E_indexer ($(quotedc_expr (obj)), $(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_indexer ($(quoted_expr (ctx, obj)), $(Lift (args, quotedc_expr))) ]>
        }

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | E_macrocall (name, namespc, parms) =>
        def quoted_syntax (s) {
          | SyntaxExpr (body) =>
            <[ SyntaxExpr ($(quoted_expr (ctx, body))) ]>
            
          | SyntaxPattern (body) =>
            <[ SyntaxPattern ($(quoted_pattern (ctx, body))) ]>
            
          | SyntaxType (body) =>
            <[ SyntaxType ($(quoted_type (ctx, body))) ]>
            
          | SyntaxParm (body) =>
            <[ SyntaxParm ($(quoted_param (ctx, body))) ]>
            
          | SyntaxCase (body) =>
            <[ SyntaxCase ($(quoted_case (ctx, body))) ]>
            
          | SyntaxCaseGuard (body, guard) =>
            <[ SyntaxCaseGuard ($(quoted_case_guard (ctx, (body, guard)))) ]>
            
          | SyntaxFunDecl (body) =>
            <[ SyntaxFunDecl ($(quoted_fundecl (ctx, body))) ]>
            
          | SyntaxFunParm (body) =>
            <[ SyntaxFunParm ($(quoted_fparam (ctx, body))) ]>
            
          | SyntaxField (body) =>
            <[ SyntaxField ($(quoted_field (ctx, body))) ]>
            
          | SyntaxMethod (body) =>
            <[ SyntaxMethod ($(quoted_method (ctx, body))) ]>
            
          | SyntaxTType (body) =>
            <[ SyntaxTType ($(quoted_type (ctx, body))) ]>

          | SyntaxTTycon
          | SyntaxTMethod
          | SyntaxTField
          | SyntaxTFunParm =>
            Util.ice ("syntax elements shouldn't appear in quotations")
        };

        <[ E_macrocall ($(quoted_name (name, ctx.env.GetMacroContext ())),
                        GlobalEnv.types_tr.Path ($(Lift (List.Map (namespc.Name,
                           quoted_string)))),
                        $(Lift (parms, quoted_syntax))) ]>

      | E_spliced (e) => e

      | E_spliced_patt => expr

      | E_spliced_special (ty, val) =>
        match (ty) {
          | "name" => <[ E_ref ($val) ]>
          | "dyn" => <[ E_ref (Name ($val, -1, null)) ]>
          | "byte" => <[ E_literal (L_byte ($val)) ]>
          | "sbyte" => <[ E_literal (L_sbyte ($val)) ]>
          | "short" => <[ E_literal (L_short ($val)) ]>
          | "ushort" => <[ E_literal (L_ushort ($val)) ]>
          | "int" => <[ E_literal (L_int ($val)) ]>
          | "uint" => <[ E_literal (L_uint ($val)) ]>
          | "long" => <[ E_literal (L_long ($val)) ]>
          | "ulong" => <[ E_literal (L_ulong ($val)) ]>
          | "string" => <[ E_literal (L_string ($val)) ]>
          | "bool" => <[ E_literal (L_bool ($val)) ]>
          | "char" => <[ E_literal (L_char ($val)) ]>
          | "float" => <[ E_literal (L_float ($val)) ]>
          | "double" => <[ E_literal (L_double ($val)) ]>
          | "decimal" => <[ E_literal (L_decimal ($val)) ]>

          | "typed" => <[ E_typed_expr ($val) ]>
          | _ =>
            Util.ice ("unsupported type of spliced literal in expression")
        }

      | E_lambda =>
        Util.ice ("this kind of quoted fun () ... is not supported")
      | E_quoted => 
        Message.fatal_error ("compound of several <[ ... ]> macro scopes is"
                             " not allowed");
      | E_literal (L_enum)
      | E_typed_expr => 
        Util.ice ("You've got beer from me for generating such a code (and me to)...");
      | E_expr_list =>
        // print location
        Message.debug ("list of expression parameters outside of any construct");
        Util.ice ("List of expression parameters outside of any construct")
      | E_letpat => Util.ice ("Bad construction of E_letpat")
    }
  } // end quoted_expr

  /** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   */    
  public expr_to_pattern (exp : Expr) : Pattern 
  {
    def flat_member (obj) {
      mutable outer_name <- null;
      def collect_member (obj : Expr, acc) {
        match (obj) {
          | <[ $(nm : name) ]> =>
            outer_name <- nm;
            nm.id :: acc
          | <[ $head.$(id : dyn) ]> => collect_member (head, id :: acc)
          | _ => Util.ice ("Corrupted member while flatting member expr -> pattern")
        }
      };
      def flat_symbol = NString.Concat (".", collect_member (obj, []));
      (outer_name, flat_symbol)
    };

    match (exp) {
      | <[ $(id : name) ]> => <[ pattern: $(id : name) _ ]>
      | <[ $constr (.. $pars) ]> =>
        def (name, con) = flat_member (constr);
        match (name.context.LookupType (con)) {        
          | Some (tcon) =>
            def convert_params (pars : list <Parm>, mems : list<IMember>,
                                acc : list <string * Pattern>) : Pattern {
              match ((pars, mems)) {
                | ([], []) => 
                  match (acc) {
                    | [] => P_underscore ()
                    | _ => P_record (List.Rev (acc))
                  }

                | (<[ parameter: $name = $expr ]> :: xs, ms)
                  when UnSString (name) != "" =>
                  convert_params (xs, ms, (UnSString (name),
                                           expr_to_pattern (expr)) :: acc)
                 
                | (_, m :: ms) when
                  !m.GetDeclaringTycon ().SameAs (tcon) ||
                  match (m.GetKind ()) {
                    | MK_field => false
                    | _ => true
                  }
                  || m.IsStatic ()
                  => convert_params (pars, ms, acc)

                | (<[ parameter: $expr ]> :: xs, m :: ms) =>
                  convert_params (xs, ms, (m.GetName (),
                                           expr_to_pattern (expr)) :: acc)
                  
                | ([], _ :: _) => convert_params ([], [], acc)
                  
                | (_ :: _, []) =>
                  Message.fatal_error ("Number of supplied parameters is too large")
                | _ => Util.ice ("strange parameters generated from quoting")
              }
            };
            
            match (tcon.GetTydecl ()) {
              | Typedtree.TD_variant_option =>
                def pars = if (con.EndsWith ("M_function"))
                  match (pars) {
                    | _ :: xs => xs
                    | _ => Util.ice ("`M_function' has broken parameters")
                  }
                else pars;
                P_cons (SS_string (Name (con, name.color, name.context)),
                        convert_params (pars, tcon.GetMembers (), []))                  
              | Typedtree.TD_class  =>
                // we lose informations about constructor here, but as it's 
                // compiler internal computation we can ignore it
                if (con.EndsWith ("Name"))
                  match (pars) {
                    | <[ parameter: $expr ]> :: _ =>
                      <[ pattern: { id = $(expr_to_pattern (expr)) } ]>
                    | _ =>
                      Util.ice ("wrong or not enough parameters supplied to"
                                " Name class")
                  }
                else
                  convert_params (pars, tcon.GetMembers (), [])
              | _ =>
                Util.ice ("expression generated from quotation has nor variant"
                          + " neither class constructor")
            }

          | None when con.EndsWith ("NameInCurrentColor") =>
            match (pars) {
              | <[ parameter: $expr ]> :: _ =>
                <[ pattern: { id = $(expr_to_pattern (expr)) } ]>
              | _ =>
                Util.ice ("wrong or not enough parameters supplied to "
                          "NameInCurrentColor")
            }

          | None =>
            Util.ice ("expression generated from quotation has broken constructor")
        }

      | <[ (..$elems) ]> => <[ pattern: (..$(List.Map (elems, expr_to_pattern))) ]>

      | E_literal (lit) => P_literal (lit)

      | E_spliced_patt (p) => p

      | _ => 
        Util.ice ("Bad constructed quoted expression in pattern matching")
    }
  }

  // GENERATION OF MACRO CLASSES SECTION

  /** Generate class implementing interface [MacroRegistry.IMacro], which
      encapsulates execution of macro. Created methods are:
      [Run] for running macro,
      [GetName] for retrieving its name,
      [GetNamespace] for retrieving macro's definition site (namespace)
      [SyntaxExtension] for retrieving syntax extension it defines,
      [CallTransform] for transforming supported call parameters to
        description taken by [Run] method
   */
  public GenerateMacroClass (env : GlobalEnv, parent_type : option <Tyinfo>,
                             attrs : list <Modifier>, header : Fun_header, 
                             synt : list <Expr>, expr : Expr) : ITypeModifier
  {
    def name = 
      match (header.name) {
        | SS_string ({ id = n }) => n
        | _ => Message.fatal_error ("spliced name in macro name is not allowed")
      };

    // walk through parameters given to macro, extract their names,
    // note type names, control if they correspond to Nemerle grammar,
    // handle variable amount of parameters and default values
    // create code decomposing passed parameters if needed
    def analyze_params (pars : list <Fun_parm>, acc, accs, accmp,
                        defaults : list<Name * Expr>, types : list<string>) 
                        : list <Pattern> * list <Expr> * list <MacroParm>
    {
      // build pattern for list from list of patterns
      def roll (li, bu) {
        match (li) {
          | [] => bu
          | x::xs => roll (xs, <[ pattern: $x :: $bu ]>)
        }
      };
      // build expression for list from list of expressions
      def roll_expr (li, bu) {
        match (li) {
          | [] => bu
          | (va, d)::xs => roll_expr (xs, <[ { def $(va : name) = $d; $bu } ]>)
        }
      };

      // handle case of standard (not params or with default value) parameter
      // decompose handled types, note them and build pattern matching
      // parameter's expression
      def normal_parm (t, va) {
        match (t) {
          | T_infer 
          | <[ type: expr ]> => 
            (<[ pattern: SyntaxExpr ($(va : name)) ]>, "expr" :: types, MP_expr ())
            
          | <[ type: parm ]> =>
            (<[ pattern: SyntaxParm ($(va : name)) ]>, "parm" :: types, MP_parm ())
            
          | <[ type: funparm ]> =>
            (<[ pattern: SyntaxFunParm ($(va : name)) ]>, "funparm" :: types,
             MP_parm ())
             
          | <[ type: string ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_string ($(va : name)))) ]>,
             "string" :: types, MP_expr ())
             
          | <[ type: int ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_int ($(va : name)))) ]>,
             "int" :: types, MP_expr ())
             
          | <[ type: uint ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_uint ($(va : name)))) ]>,
             "uint" :: types, MP_expr ())

          | <[ type: long ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_long ($(va : name)))) ]>,
             "long" :: types, MP_expr ())
             
          | <[ type: ulong ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_ulong ($(va : name)))) ]>,
             "ulong" :: types, MP_expr ())

          | <[ type: short ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_short ($(va : name)))) ]>,
             "short" :: types, MP_expr ())
             
          | <[ type: ushort ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_ushort ($(va : name)))) ]>,
             "ushort" :: types, MP_expr ())

          | <[ type: byte ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_byte ($(va : name)))) ]>,
             "byte" :: types, MP_expr ())
             
          | <[ type: sbyte ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_sbyte ($(va : name)))) ]>,
             "sbyte" :: types, MP_expr ())

          | <[ type: float ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_float ($(va : name)))) ]>,
             "float" :: types, MP_expr ())
             
          | <[ type: double ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_double ($(va : name)))) ]>,
             "double" :: types, MP_expr ())

          | <[ type: decimal ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_decimal ($(va : name)))) ]>,
             "decimal" :: types, MP_expr ())

          | <[ type: bool ]> =>
            (<[ pattern: SyntaxExpr (E_literal (L_bool ($(va : name)))) ]>,
             "bool" :: types, MP_expr ())
             
          | _ => Message.fatal_error ("type not supported")
        }
      };

      // create list of match cases (patterns and expressions) containing
      // cases for default values of parameters, add expressions defining
      // missed parameters according to those default values
      def traverse_patterns (pattss, defaults, defsrest, accpat, accexp) {
        match ((pattss, defaults)) {
          | ([], _) => (accpat, accexp)
          | (patts :: xss, []) =>
            traverse_patterns (xss, [], [], LiftPattern (List.Rev (patts))
                               :: accpat, roll_expr (defsrest, expr) :: accexp)
          | (patts :: xss, d :: ds) =>
            def newdrest = d :: defsrest;
            traverse_patterns (xss, ds, newdrest,
                               LiftPattern (List.Rev (patts)) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
        }
      };

      // iterate through parameters
      match (pars) {
        | [] => 
          // we have fixed amount of parameters, so there is always
          // case, which triggers error, handle it
          def plist = NString.Concat (", ", List.Rev (types));
          def warn = <[
            Message.fatal_error ("macro `" 
            + $(name : string) + "' expects following list of arguments: (" + 
            $(plist : string) + ")")
          ]>;
          def (pats, exps) =
            traverse_patterns (acc :: accs, defaults, [], 
                               [ <[ pattern: _ ]> ], [warn]);
          (pats, exps, List.Rev (accmp))

        | { name = SS_string (va); ty = t; attr = at } :: xs =>
          match (at) {
            // variable amount of parameters is handled here
            | FP_params =>
              def (initpat, initex) =
                match (acc) {
                  // if there are some elemnts other than out 'va', then this
                  // pattern won't be exchaustive, and we must supply error msg
                  | _ :: _ =>
                    def plist = NString.Concat (", ", List.Rev ("params array"
                                                                :: types));
                    def warn = <[ Message.fatal_error ("macro `" + $(name : string)
                      + "' expects following list of arguments: ("
                      + $(plist : string) + ")") ]>;
                    ([ <[ pattern: _ ]> ], [warn])
                  | _ =>
                    ([], [])
                };
              match (t) {
                | <[ type: array <parm> ]> =>
                  def (pats, exps) =
                    traverse_patterns (accs, defaults, [], 
                                       roll (acc, <[ pattern: parms ]>) :: initpat,
                      <[
                        def $(va : name) = (array (List.Length (parms))
                                           : array <Parm>);
                        mutable i <- 0;
                        List.Iter (parms, fun (p : SyntaxElement) { 
                          | SyntaxParm (e) =>
                            $(va : name)[i] <- e;
                            i <- i + 1
                          | _ => Message.fatal_error ("ice") 
                        });
                        $expr
                      ]> :: initex);
                  (pats, exps, List.Rev (MP_parms () :: accmp))

                | <[ type: array <expr> ]> =>
                  def (pats, exps) =
                    traverse_patterns (accs, defaults, [], 
                                       roll (acc, <[ pattern: exprs ]>) :: initpat,
                      <[
                        def $(va : name) = (array (List.Length (exprs))
                                           : array <Expr>);
                        mutable i <- 0;
                        List.Iter (exprs, fun (p : SyntaxElement) { 
                          | SyntaxExpr (e) =>
                            $(va : name)[i] <- e;
                            i <- i + 1
                          | _ => Message.fatal_error ("ice") 
                        });
                        $expr
                      ]> :: initex);
                  (pats, exps, List.Rev (MP_exprs () :: accmp))
 
                | _ =>
                  Message.fatal_error ("only array of expr or parm are "
                                       "supported in params")
              }

            // parameter with default value
            | FP_default (e) =>
              match (normal_parm (t, va)) {
                | (p, str :: strs, mp) =>
                  analyze_params (xs, p :: acc, acc :: accs, mp :: accmp, 
                    (va, e) :: defaults, str + "(opt)" :: strs)
                | _ => Util.ice ("normal_parm returned empty types list")
              }
            | FP_normal =>
              match (defaults) {
                | [] =>
                  def (p, str, mp) = normal_parm (t, va);
                  analyze_params (xs, p :: acc, accs, mp :: accmp, defaults, str)
                | _ =>
                  Message.fatal_error ("parameters with default values must not"
                                       " be mixed with normal")
              }
          }
        | { name = SS_spliced_expr } :: _ =>
          Util.ice ("spliced in macro parameters")
      }    
    }; // end analize_parms

    // creates match cases from pairs of pattern and expression
    def consolide_cases (pats, exps, acc) {
      match ((pats, exps)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => 
          consolide_cases (xs, ys, <[ case: $x => $y ]> :: acc)
        | _ => Util.ice ()
      }
    };

    // store positions and types of all parameters accessed by their names
    def mapparams (pars : list <Fun_parm>, n,
                   hash : Hashtable <string, int * Type>)
    {
      match (pars) {
        | [] => hash
        | { name = SS_string ({ id = x }); ty = t } :: xs => 
          if (hash.Contains (x)) 
            Message.fatal_error ("parameter names cannot repeat")
          else
            hash.Add (x, (n, t)); mapparams (xs, n + 1, hash)
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro params")
      }
    };
    def paramsmap = mapparams (header.parms, 0, Hashtable ());

    // if syntax extending section of macro exists, analyze all tokens and
    // permutation of parameters in its definition
    def analyze_syntax (toks, acc, positacc) {
      match (toks) {
        | [] => 
          // we have reached end of syntax definition, reverse accumulator
          // and return stored tokens and parameters' positions
          match (List.Rev (acc)) {
            | Parser.GE_keyword (key) :: rules =>
              (key, rules, positacc)

            // if there was no syntax definition
            | [] => ("", [], [])
            | _ => Message.fatal_error 
                     ("first token of syntax definition must be keyword")
          }
        | <[ $(x : string) ]> :: xs when Lexer.IsKeyword (x) =>
          analyze_syntax (xs, Parser.GE_keyword (x) :: acc, positacc)

        | <[ $(x : string) ]> :: xs when Lexer.IsOperator (x) =>
          analyze_syntax (xs, Parser.GE_operator (x) :: acc, positacc)

        | <[ $(x : dyn) ]> :: xs =>
          match (paramsmap.Get (x)) {
            | Some ((pos, ty)) =>
              paramsmap.Remove (x);
              def grammar_token =
                match (ty) {
                  | <[ type: parm ]> => Parser.GE_parm ()
                  | <[ type: funparm ]> => Parser.GE_funparm ()
                  | <[ type: array <parm> ]> => Parser.GE_parm_list (",")
                  | <[ type: array <expr> ]> => Parser.GE_expression_list (",")
                  | _ => Parser.GE_expression ()
                };
              analyze_syntax (xs, grammar_token :: acc, pos :: positacc)
            | None =>
              Message.fatal_error ("parameters from syntax description doesn't"
                                   " match macro's")
          }
        | _ => Message.fatal_error ("unsupported syntax token")
      }
    };

    // lift grammar element
    def lift_ge (x) {
      | Parser.GE_operator (name) => <[ Parser.GE_operator ($(name : string)) ]>
      | Parser.GE_keyword (name) => <[ Parser.GE_keyword ($(name : string)) ]>
      | Parser.GE_expression => <[ Parser.GE_expression () ]>
      | Parser.GE_block => <[ Parser.GE_block () ]>
      | Parser.GE_expression_list (sep) =>
        <[ Parser.GE_expression_list ($(sep : string)) ]>
        
      | Parser.GE_parm_list (sep) =>
        <[ Parser.GE_parm_list ($(sep : string)) ]>
        
      | Parser.GE_parm  => <[ Parser.GE_parm () ]>
      | Parser.GE_funparm => <[ Parser.GE_funparm () ]>
    };

    // create decision tree for transformation of supported call
    // parameters to our SyntaxElement description
    def create_transform_tree (parms) {
      | MP_parm :: xs =>
        <[
          match (trans_p) {
            | x :: trans_p =>
              trans_res <- SyntaxParm (x) :: trans_res;
              $(create_transform_tree (xs))
            | [] => ()
          }
        ]>
      | MP_expr :: xs =>
        <[
          match (trans_p) {
            | { expr = x } :: trans_p =>
              trans_res <- SyntaxExpr (x) :: trans_res;
              $(create_transform_tree (xs))
            | [] => ()
          }
        ]>
      | [MP_exprs] =>
        <[
          def app_expr (l : list <Parm>) {
            | { expr = x } :: xs => 
              trans_res <- SyntaxExpr (x) :: trans_res;
              app_expr (xs)
            | [] => ()
          };
          app_expr (trans_p)
        ]>
      | [MP_parms] =>
        <[
          def app_par (l) {
            | x :: xs => 
              trans_res <- SyntaxParm (x) :: trans_res;
              app_par (xs)
            | [] => ()
          };
          app_par (trans_p)
        ]>

      | [] =>
        <[
          match (trans_p) {
            | x::_ =>
              trans_res <- SyntaxParm (x) :: trans_res
            | [] => ()
          }
        ]>
      | _ => Util.ice ("corrupted macro parameters")
    };

    // build macro class
    def td = 
      match (parent_type) {
        | Some (t) => 
          t.DefineNestedClass (Mod_macro () :: Mod_public () :: attrs,
                               NewSymbol ().id, 
                               Typarms ([], []),
                               [ <[ type: IMacro ]> ]);
        | None =>
          env.DefineClass (Mod_macro () :: Mod_public () :: attrs,
                           NewSymbol ().id, [ <[ type: IMacro ]> ]);
      };
    td.DefineMember (<[ method: public this () { } ]>);

    def (key, rules, positions) = analyze_syntax (synt, [], []);
    
    td.DefineMember (<[ method:
      GetName () : string implements IMacro.GetName { $(name : string) }
    ]>);

    td.DefineMember (<[ method:
      GetNamespace () : string implements IMacro.GetNamespace {
        $(env.GetCurrentNamespace () : string)
      }
    ]>);

    def (macro_patts, macro_exprs, macro_parms) = 
      analyze_params (header.parms, [], [], [], [], []);
                          
    td.DefineMember (<[ method:
      CallTransform (trans_p : list<Parm>) : list<SyntaxElement>
      implements IMacro.CallTransform
      {
        mutable trans_res <- [];
        $(create_transform_tree (macro_parms));
        List.Rev (trans_res);
      }
    ]>);

    def macro_cases = List.Rev (consolide_cases (macro_patts, macro_exprs, []));
                     
    td.DefineMember (<[ method:
      Run ($(implicit_ctx_name : name) : Tyexpr.CTX, parms : list<SyntaxElement>) : Expr
      implements IMacro.Run
      {
        match (parms) { ..$macro_cases }
      }
    ]>);

                                
    td.DefineMember (<[ method:
      SyntaxExtension () : string * list<Parser.GrammarElement> * list<int>
      implements IMacro.SyntaxExtension
      {
        ($(key : string), $(Lift (rules, lift_ge)),
         $(Lift (positions, fun (x) { <[ $(x : int) ]> } )))
      }
    ]>);

    td.Compile ();                                
    td
  }

  public CreatePermutingFunction (positions : list <int>) 
  : list <SyntaxElement> -> list <SyntaxElement>
  {
    def len = List.Length (positions);
    fun (li) {
      def take_first (n, l, acc) {
        match ((n, l)) {
          | (0, _) => (List.Rev (acc), l)
          | (_, []) => Util.ice ("too few parameters")
          | (n, x :: xs) =>
            take_first (n - 1, xs, x :: acc)
        }
      };
      def pararr = (array (len) : array <SyntaxElement>);
      mutable m <- 0;
      def loop (l, ps) {
        match ((l, ps)) {
          | (x :: xs, [p]) =>
            pararr[p] <- x;
            loop (xs, [])
          | (x :: xs, p :: pp) =>
            if (p == len - 1) {
              def (rtail, rfront) =
                take_first (len - m - 1, List.Rev (xs), []);
              pararr[p] <- x;
              loop (List.Append (List.Rev (rtail), List.Rev (rfront)), pp)
            }
            else {
              pararr[p] <- x;
              m <- m + 1;
              loop (xs, pp)
            }
          | (xs, []) => List.Append (List.FromArray (pararr), xs)
          | ([], _) => Util.ice ("too few parameters")
        }
      };
      loop (li, positions)
    }
  }

  // PRETTY PRINTING TOOLS SECTION

  public SprintExpr (ctx : option<CTX>, expr : Expr, empty : string,
                     acc : StringBuilder) : void 
  {
    def add (x : string) { ignore (acc.Append (x)) };
    
    def expr = 
      match (ctx) {
        | Some (c) => MacroRegistry.expand_macro (c, expr)
        | _ => expr
      };

    def print_tparms (pars) {
      add ("<");
      add (NString.Concat (", ", pars));
      add (">")
    };

    def print_tconstraints (cts : list <Constraint>) {
      | [] => ()
      | x :: xs =>
        add (sprintf ("where %s : ", x.tyvar));
        SprintType (x.ty, acc);
        print_tconstraints (xs)
    };

    def print_funparms (fps) {
      def print_funparm (p : Fun_parm) {
        | <[ funparm: $(n : name) : $ty ]> =>
          add (n.id + " : ");
          SprintType (ty, acc)
          
        | <[ funparm: params $(n : name) : $ty ]> =>
          add (sprintf ("params %s : ", n.id));
          SprintType (ty, acc)
          
        | <[ funparm: $(n : name) : $ty = $expr ]> =>
          add (sprintf ("params %s : ", n.id));
          SprintType (ty, acc);
          add (" = ");
          SprintExpr (ctx, expr, empty, acc)

        | _ => add ("spliced funparm name")
      };

      NString.SeparatedCalls (", ", fps, print_funparm, acc)
    };
      
    match (expr) {
      | <[ $(id : name) ]> => 
        add (id.id)

      | <[ $obj . $(mem : name) ]> => 
        SprintExpr (ctx, obj, empty, acc); add ("." + mem.id)

      | <[ [] ]> => add ("[]")

      | <[ $x :: $xs ]> =>
        SprintExpr (ctx, x, empty, acc);  
        add (" :: "); SprintExpr (ctx, xs, empty, acc)

      | <[ $func (.. $parms) ]> =>
        def print_parm (p : Parm) {
          match (p) {
            | <[ parameter: $(n : name) = $expr ]> =>
              unless (n.id == "") add (n.id + " = ");
              SprintExpr (ctx, expr, empty + "  ", acc)
            | <[ parameter: ref $(n : name) = $expr ]> =>
              add ("ref ");
              unless (n.id == "") add (n.id + " = ");
              SprintExpr (ctx, expr, empty + "  ", acc)
            | _ => Message.error ("spliced in PrintExpr")
          }
        };

        SprintExpr (ctx, func, empty, acc); add (" (");
        NString.SeparatedCalls (", ", parms, print_parm, acc);             
        add (")");

      | <[ $target <- $source ]> =>
        SprintExpr (ctx, target, empty, acc); add (" <- ");
        SprintExpr (ctx, source, empty, acc);

      | <[ def $(n : name) = $val ]> =>
        add (sprintf ("def %s = ", n.id));
        SprintExpr (ctx, val, empty, acc)

      | <[ mutable $(n : name) <- $val ]> =>
        add (sprintf ("mutable %s = ", n.id));
        SprintExpr (ctx, val, empty, acc)

      | <[ def (.. $elems) = $val ]> =>
        add ("def (");
        def pp (x) { SprintPattern (x, acc) };
        NString.SeparatedCalls (", ", elems, pp, acc); 
        add (") = ");
        SprintExpr (ctx, val, empty, acc);

      | <[ match ($expr) {.. $cases } ]> =>
        def print_case (c : Match_case) {
          def print_guard (g : Pattern * option <Expr>) {
            | <[ caseguard: $pat when $e ]> =>
              add (sprintf ("\n%s| ", empty + "  "));
              SprintPattern (pat, acc);
              add (" when ");
              SprintExpr (ctx, e, empty + "    ", acc)
            | <[ caseguard: $pat ]> =>
              add (sprintf ("\n%s| ", empty + "  ")); 
              SprintPattern (pat, acc);
          };

          def <[ case: | ..$guards => $expr ]> = c;
          List.Iter (guards, print_guard);
          add (sprintf (" => \n%s", empty + "    "));
          SprintExpr (ctx, expr, empty + "    ", acc)
        };

        add ("match ("); 
        SprintExpr (ctx, expr, empty, acc); add (") {");
        List.Iter (cases, print_case);
        add (sprintf ("\n%s}", empty))

      | <[ throw $exc ]> =>
        add ("throw "); SprintExpr (ctx, exc, empty, acc);

      | <[ try $body catch { $(exn : name) : $exn_ty => $handler } ]> => 
        add (sprintf ("try\n%s  ", empty));
        SprintExpr (ctx, body, empty + "  ", acc);
        add (sprintf ("\n%swith {\n%s", empty, empty + "  "));
        add (exn.id + " : ");
        SprintType (exn_ty, acc);
        add (sprintf ("=>\n%s", empty + "    "));
        SprintExpr (ctx, handler, empty + "    ", acc)

      | <[ try $body finally $handler ]> =>
        add (sprintf ("try\n%s  ", empty));
        SprintExpr (ctx, body, empty + "  ", acc);
        add (sprintf ("\n%sfinally\n%s  ", empty, empty));
        SprintExpr (ctx, handler, empty + "  ", acc)

      | <[ () ]> => 
        add ("()")

      | <[ null ]> => 
        add ("null")

      | <[ $(val : int) ]> =>
        add (val.ToString ())

      | <[ $(val : string) ]> =>
        add (sprintf ("\"%s\"", val))

      | <[ $(val : float) ]> =>
        add (val.ToString ())

      | <[ $(val : bool) ]> =>
        if (val) add ("true") else add ("false")

      | <[ $(val : char) ]> =>
        add (val.ToString ())

      | <[ this ]> =>
        add ("this")

      | <[ base ]> => 
        add ("base")

      | <[ typeof ($t) ]> =>
        add ("typeof ("); SprintType (t, acc); add (")")

      | <[ ( $expr :> $ty ) ]> =>
        add ("("); SprintExpr (ctx, expr, empty, acc); add (" :> ");
        SprintType (ty, acc); add (")")

      | <[ ( $expr : $ty ) ]> =>
        add ("("); SprintExpr (ctx, expr, empty, acc); 
        add (" : "); SprintType (ty, acc); add (")")

      | <[ {.. $seq } ]> =>
        match (seq) {
          | [e] =>
            SprintExpr (ctx, e, empty, acc)
          | _ =>
            add ("{");
            NString.SeparatedCalls (";", seq, fun (x) { 
              add (sprintf ("\n%s", empty + "  ")); 
              SprintExpr (ctx, x, empty + "  ", acc); 
            }, acc);
            add (sprintf ("\n%s}", empty))
        }

      | <[ (.. $args) ]> =>
        add ("(");
        NString.SeparatedCalls (", ", args, fun (x) { 
          SprintExpr (ctx, x, empty, acc) 
        }, acc);
        add (")")

      | <[ array [.. $args] ]> =>
        add ("array [");
        NString.SeparatedCalls (", ", args, fun (x) { 
          SprintExpr (ctx, x, empty, acc) 
        }, acc);
        add ("]")

      | <[ $obj [.. $args] ]> =>
        SprintExpr (ctx, obj, empty, acc);
        add ("[");
        NString.SeparatedCalls (", ", args, fun (x) { 
          SprintExpr (ctx, x, empty, acc) 
        }, acc);
        add ("]")

      | <[ fun < ..$tparms> (..$args) where ..$tconstrs $body ]> =>
        add ("fun "); print_tparms (tparms);
        add (" ("); print_funparms (args); add (") ");
        print_tconstraints (tconstrs); add (" ");
        SprintExpr (ctx, body, empty, acc)

      | <[ def ..$funs ]> =>
        def print_fun (f : Function_decl) {
          | <[ fundecl: $(n : name) < ..$tparms> (..$args)
               where .. $tconstrs $body ]> =>
            add (n.id + " "); print_tparms (tparms);
            add (" ("); print_funparms (args); add (") ");
            print_tconstraints (tconstrs); add (" ");
            SprintExpr (ctx, body, empty, acc)
          | _ => add ("spliced fun name")
        };
        
        add ("def ");
        NString.SeparatedCalls ("\nand ", funs, print_fun, acc)

      | _ => add ("other")
    }
  }

  public PrintExpr (ctx : option<CTX>, expr : Expr) : void
  {
    def result = StringBuilder ();
    SprintExpr (ctx, expr, "", result);
    printf ("%s\n", result.ToString ());
  }

  public SprintPattern (patt : Pattern, acc : StringBuilder) : void
  {
    def add (x : string) { ignore (acc.Append (x)) };
    def print_named_pattern (patt : string * Pattern) : void
    {
      def (name, pat) = patt;
      add (sprintf ("%s = ", name)); SprintPattern (pat, acc);
    };
    
    match (patt) {
      | <[ pattern: _ ]> =>
        add ("_")

      | <[ pattern: $(n : name) ]> =>
        add (n.id)

      | <[ pattern: ($pat) as $(n : name) ]> => 
        add ("("); SprintPattern (pat, acc); 
        add (") as "); add (n.id)

      | <[ pattern: [] ]> => add ("[]")

      | <[ pattern: $x :: $xs ]> => 
        SprintPattern (x, acc); add (" :: "); SprintPattern (xs, acc)

      | <[ pattern: (.. $args) ]> =>
        add ("(");
        NString.SeparatedCalls (", ", args, fun (x) {
          SprintPattern (x, acc);
        }, acc);
        add (")")

      | <[ pattern: {.. $args } ]> =>
        add ("{");
        NString.SeparatedCalls ("; ", args, print_named_pattern, acc);
        add ("}")

      | <[ pattern: $(n : name) (.. $args) ]> =>
        add (n.id); add (" (");
        NString.SeparatedCalls (", ", args, fun (x) {
          SprintPattern (x, acc)
        }, acc);
        add (")");

      | <[ pattern: $(n : name) {.. $args} ]> =>
        add (n.id); add (" {");
        NString.SeparatedCalls ("; ", args, print_named_pattern, acc);          
        add ("}")

      | <[ pattern: $(val : int) ]> =>
        add (val.ToString ())

      | <[ pattern: $(val : string) ]> =>
        add (sprintf ("\"%s\"", val))

      | <[ pattern: $(val : bool) ]> =>
        if (val) add ("true") else add ("false")

      | <[ pattern: $(val : float) ]> =>
        add (val.ToString ())

      | <[ pattern: $(val : char) ]> =>
        add (val.ToString ())

      | <[ pattern: () ]> =>
        add ("()")

      | <[ pattern: null ]> =>
        add ("null")

      | <[ pattern: $(n : name) _ ]> =>
        add (n.id)

      | _ => add ("other");
    }
  }

  public SprintType (ty : Type, acc : StringBuilder) : void 
  {
    def add (x : string) { ignore (acc.Append (x)) };
    
    match (ty) {
      | <[ type: $(tycon : name) < .. $args> ]> =>
       add (tycon.id);
       match (args) {
         | [] => ()
         | _ => add (" <");
           NString.SeparatedCalls (" * ", args, fun (x) {
             SprintType (x, acc)
           }, acc);
           add (">");
       }

      | <[ type: $(n : name) ]> =>
        add (n.id);

      | <[ type: ref $ty ]> =>
        add ("ref "); SprintType (ty, acc);

      | <[ type: out $ty ]> =>
        add ("out "); SprintType (ty, acc);

      | <[ type: $from -> $to ]> =>
        SprintType (from, acc); add (" -> "); SprintType (to, acc);

      | <[ type: void ]> =>
        add ("void");

      | <[ type: .. $args ]> =>
        NString.SeparatedCalls (" * ", args, fun (x) {
          SprintType (x, acc);
        }, acc);

      | <[ type: array < $ty > ]> =>
        add ("array <"); SprintType (ty, acc); add (">")

      | _ => add ("other")
    }
  }
}
} // end ns
