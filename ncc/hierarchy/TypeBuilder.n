/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;
using Nemerle.Utility;
using Nemerle.Collections;

using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/**
  This pass operates on [TypeBuilder] objects created for
  each type declaration found in source files.  These objects are
  already created, but most fields are empty.  The main function of
  this pass is [TypeBuilder.Run].
 */
public class TypeBuilder : TypeInfo
{
  type Subinfo = SystemMap [int, TypeInfo * list [TType]];

  public env : GlobalEnv;

  mutable tydecl : TypeDeclaration;
  mutable self_type : TType.Class;  // memoized by GetMemType ()

  enclosing_type : option [TypeBuilder];  
  mutable parent_type : option [TType.Class];
  mutable t_implements : list [TType.Class];
  mutable contained_types : list [TypeBuilder];
  mutable variant_options : list [TypeBuilder];
  mutable supertypes : SystemMap [int, TypeInfo * list [TType]];
  mutable member_map : SystemMap [string, list [IMember]];
  mutable member_list : list [IMember];
  mutable constant_object : option [IField];
  variant_option_parent : TypeBuilder;
  mutable underlying_enum_type_iface : INumericType;
  mutable underlying_enum_type : TType;

  mutable typarms : list [Tyvar.T];
  mutable tenv : Tyvar.TEnv;

  mutable type_builder : System.Reflection.Emit.TypeBuilder;

  pt_name : PT.Name;
  name : string;
  loc : Location;
  modifiers : Modifiers;
  mutable attributes : NemerleAttributes;
  accessibility : Accessibility;
  
  mutable pt_tydecl : PT.TopDeclaration;
  mutable additional_decls : list [PT.ClassMember];
  
  is_enum : bool;
  mutable is_finalized : bool;
  mutable cannot_finalize : bool;
  mutable m_has_been_used : bool;
  /// if it doesn't, we must add implicit empty constructor  
  mutable instance_ctor_occured : bool;
  /// Marker for [TypeBuilder.Iter].
  internal mutable phase : int;

  /**
   * Defining type if any and transitive closure of base types of this type.
   *
   * Used by [TypeBuilder.Iter] function.
   */
  mutable iterate_first : list [TypeBuilder];

  static mutable infos : list [TypeBuilder];
  static mutable run_phase : int;


  public this (par : option [TypeBuilder], vop : option [TypeBuilder], 
               env : GlobalEnv, td : PT.TopDeclaration)
  {
    variant_options = [];
    contained_types = [];
    
    this.pt_tydecl = td;
    this.pt_name = td.name.GetName ();
    this.env = env;
    this.enclosing_type = par;    
    match (par) {
      | Some (p) => p.contained_types = this :: p.contained_types;
      | _ => ()
    };
    this.name = pt_name.Id;
    this.loc = td.loc;
    modifiers = td.modifiers;
    attributes = modifiers.mods;

    instance_ctor_occured = td is PT.TopDeclaration.Alias;
    match (td) {
      | PT.TopDeclaration.VariantOption =>
        instance_ctor_occured = true;
        match (vop) {
          | Some (ti) =>
            ti.variant_options = this :: ti.variant_options;
            attributes |= NemerleAttributes.Sealed;
            modifiers.macro_attrs = (":type:postadd", <[ Record ]>) :: modifiers.macro_attrs;
            if (ti.IsPublic)
              attributes |= NemerleAttributes.Public
            else
              attributes |= NemerleAttributes.Internal;

          | None => assert (false)
        }
      | PT.TopDeclaration.Enum => is_enum = true;
      | _ => ()
    };

    ++Passes.tyinfo_counter;
    infos = this :: infos;

    if (this.pt_tydecl is PT.TopDeclaration.Interface)
      this.tydecl = TypeDeclaration.Interface ();
    else
      this.tydecl = TypeDeclaration.Class (); // may change later (in bind_types)

    instance_ctor_occured = (attributes %&& (NemerleAttributes.Struct %| NemerleAttributes.Static))
                            || IsModule || instance_ctor_occured || IsInterface || is_enum;
    
    unless (attributes %&& NemerleAttributes.AccessModifiers)
      match (enclosing_type) {
        | Some => attributes |= NemerleAttributes.Private;
        | None => attributes |= NemerleAttributes.Internal;
      }

    accessibility = 
      match (attributes %& NemerleAttributes.AccessModifiers) {
        | NemerleAttributes.Private => Accessibility.Private
        | NemerleAttributes.Protected => Accessibility.Protected
        | NemerleAttributes.Internal => Accessibility.Internal
        | _ =>
          if (attributes %&& (NemerleAttributes.Protected %| NemerleAttributes.Internal))
            Accessibility.ProtectedOrInternal
          else
            Accessibility.Public
      }

    match (enclosing_type) {
      | Some (tc) =>
        accessibility = Tyutil.AccessibilityIntersect (accessibility, tc.Accessibility)
      | None => ()
    }

    match ((vop, pt_tydecl)) {
      | (Some (x), PT.TopDeclaration.VariantOption) => variant_option_parent = x
      | (None, PT.TopDeclaration.VariantOption) => Util.ice ()
      | (Some, _) => Util.ice ()
      | (None, _) => ()
    };

    additional_decls = [];

    CheckTypeAttributes ();

    m_has_been_used = IsExternallyAccessible
  }

  /**
   * Return list of type parameters under which we subtype given type.
   *
   * For example if [A ['a] :> B [int]], then ["A".SuperType ("B")]
   * returns [[int]].
   *
   * This information can be also fetched from [GetDirectSuperTypes()]
   * method but this function is transitive.
   */
  public override SuperType (ti : TypeInfo) : option [list [TType]]
  {
    match (supertypes.Find (ti.GetId ())) {
      | Some ((_, x)) => Some (x)
      | None =>
        if (ti.Equals (InternalType.Object_tc))
          Some ([])
        else if (ti.Equals (this))
          match (GetMemType ()) {
            | TType.Class (_, parms) => Some (parms)
            | _ => assert (false)
          }
        else
          None ()
    }
  }

  /** Return qualified type name. */
  public override FullName : string
  {
    get { env.GetCurrentNamespace () + name }
  }

  public override IsSealed : bool
  {
    get { attributes %&& NemerleAttributes.Sealed }
  } 

  public IsAbstract : bool
  {
    get { attributes %&& NemerleAttributes.Abstract }
  } 

  public IsModule : bool
  {
    get { attributes %&& NemerleAttributes.Static }
  }
  
  public override IsDelegate : bool
  {
    get
    {
      match (parent_type) {
        | Some ({ tycon = tycon; args = []}) =>
          tycon.FullName == "System.MulticastDelegate"

        | _ => false
      }
    }
  }

  public override IsInterface : bool
  {
    get { tydecl matches TypeDeclaration.Interface }
  }

  public IsAlias : bool
  {
    get { tydecl matches TypeDeclaration.Alias }
  }

  public IsStruct : bool
  {
    get { attributes %&& NemerleAttributes.Struct }
  }
  
  public override IsValueType : bool
  {
    get { IsStruct || is_enum }
  }

  public IsPublic : bool
  {
    get { attributes %&& NemerleAttributes.Public }
  }

  public IsInternal : bool
  {
    get { attributes %&& NemerleAttributes.Internal }
  }

  public IsProtected : bool
  {
    get { attributes %&& NemerleAttributes.Protected }
  }

  public IsPrivate : bool
  {
    get { attributes %&& NemerleAttributes.Private }
  }
  
  public override GetModifiers () : Modifiers
  {
    modifiers
  }

  public GetParseName () : PT.Name 
  {
    pt_name
  }

  public ParsedDeclaration : PT.TopDeclaration
  {
    get { pt_tydecl }
  }
  
  /** Return type we were defined in (null for toplevel types). */
  public override DeclaringType : TypeInfo {
    get {
      match (enclosing_type) {
        | Some (ti) => ti
        | None => null
      }
    }
  }

  /** Return name without any dots. */  
  public override Name : string {
    get { name }
  }

  public override MemberType : System.Reflection.MemberTypes {
    get { System.Reflection.MemberTypes.NestedType }
  }
  
  public override Accessibility : Accessibility
  {
    get { accessibility }
  }

  public override Attributes : NemerleAttributes
  {
    get { attributes }
  }

  public override IsExternallyAccessible : bool
  {
    get
    {
      match (accessibility) {
        | Accessibility.Public
        | Accessibility.Protected
        | Accessibility.ProtectedOrInternal => true
        | _ => false
      }
    }
  }

  public override Location : Location
  {
    get { loc }
  }

  public override HasBeenUsed : bool
  {
    get { m_has_been_used }
    set {
      m_has_been_used = m_has_been_used || value;
      match (enclosing_type) {
        | Some (enclosing_type) =>
          enclosing_type.HasBeenUsed = value
        | _ => ()
      }
    }
  }
    
  public override CanAccess (source : TypeInfo) : bool
  {
    IsPublic ||
    (IsInternal &&
      (match (source.GetTypeInfoKind ()) {
        | TypeInfoKind.NemerleType => true
        | _ => false
      })) ||
    (IsProtected &&
        (match (enclosing_type) {
          | Some (tc) => Option.IsSome (source.SuperType (tc))
          | None => false
        })) ||
    (match (enclosing_type) {
          | Some (declaring_type) =>
            def walk_declaring (tc : TypeInfo) {
              tc.Equals (declaring_type) ||
              (tc.DeclaringType != null && walk_declaring (tc.DeclaringType))
            };
            walk_declaring (source)
          | None => false
        })
  }

  public IsFinalized : bool {
    get { is_finalized }
    set { is_finalized = value }
  }

  [Nemerle.Assertions.Requires (run_phase <= 2)] 
  public AddImplementedInterface (t : PT.PExpr) : void
  {
    match (pt_tydecl) {
      | PT.TopDeclaration.Class as td => td.t_extends += [t]
      | PT.TopDeclaration.Interface as td => td.t_extends += [t]
      | PT.TopDeclaration.Variant as td => td.t_extends += [t]
      | _ => Message.error ("cannot add interface to this kind of type")
    }
  }
  
  public DefineNestedType (td : PT.ClassMember) : TypeBuilder
  {
    | PT.ClassMember.TypeDeclaration (td) =>
      def tyinfo = GlobalEnv.AddType (Some (this), None (), env, td);
      tyinfo.FixupDefinedClass ();
      tyinfo
    | _ =>
      Message.error ("expected declaration of nested type");
      null
  }


  /**
   * Adds a definition and returns the new NemerleMember, if available
   */
  public DefineAndReturn (f : PT.ClassMember) : option [NemerleMember]
  {
    if (member_map == null) {
      additional_decls = f :: additional_decls;
      None ()
    }
    else {
      try {
        def mem = bind_and_add_member (f);
        Passes.Emitter.MemberAdded (this, mem);
        Some (mem :> NemerleMember)
      } catch {
        | _ : Recovery => None ()
      }
    }
  }


  /**
   * Adds a definition to this type
   */
  public Define (f : PT.ClassMember) : void
  {
    | PT.ClassMember.TypeDeclaration (td) =>
      def tyinfo = GlobalEnv.AddType (Some (this), None (), env, td);
      tyinfo.FixupDefinedClass ();

    | _ => ignore (DefineAndReturn (f))
  }


  /**
   * Builds this type
   */
  public Compile () : void
  { 
    cannot_finalize = false;
    when (type_builder != null) {
      this.FinalizeType ();
      Passes.MarkTypeBuilderCompiled ();
    }
  }


  public FindAttribute (looking_for : TypeInfo) : option [PT.PExpr]
  {
    mutable result = None ();
    
    // find our attribute
    foreach (expr in GetModifiers ().custom_attrs)
      match (AttributeCompiler.ResolveAttribute (this.env, expr)) {
        | Some ((t, _)) =>
          when (looking_for.Equals (t))
            result = Some (expr)
            
        | _ => ()
      }

    result
  }

  public override HasAttribute (attribute : TypeInfo) : bool
  {
     Option.IsSome (FindAttribute (attribute))
  }

  public DisableImplicitConstructor () : void
  {
    instance_ctor_occured = true;
  }
  
  /**
   * Marks this with the SpecialName attribute, the attribute will
   * be propagated to members and contained types at a later stage.
   */
  public MarkWithSpecialName () : void
  {
    attributes |= NemerleAttributes.SpecialName
  }

  /**
   * Return list of types that we directly subtype.
   *
   * <remarks>
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   */
  public override GetDirectSuperTypes () : list [TType.Class]
  {
    match (parent_type) {
      | Some (t) => t :: t_implements
      | None => t_implements
    }
  }

  public override GetConstantObject () : option [IField]
  {
    constant_object
  }

  /** Return type we extend if any. */
  public override SuperClass () : option [TypeInfo]
  {
    match (parent_type) {
      | Some (tclass) => Some (tclass.tycon)
      | _ => None ()
    }
  }

  /**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * Used mainly with [FreshSubst ()] or [MakeSubst ()].
   */
  public override GetMemType () : TType
  {
    when (self_type == null) {
      def make_tv (tv : Tyvar.T) : TType { TType.Variable (tv) };
      self_type = TType.Class (this, List.Map (typarms, make_tv)) :> TType.Class;
    }
    self_type
  }

  public override GetTypeInfoKind () : TypeInfoKind
  {
    TypeInfoKind.NemerleType (this)
  }

  public override GetTydecl () : TypeDeclaration
  {
    tydecl
  }

  public override LookupMember (name : string) : list [IMember]
  {
    match (member_map.Find (name)) {
      | None =>
        if (IsInterface) InternalType.Object_tc.LookupMember (name)
        else []
      | Some (mems) => mems
    }
  }

  /** Searches for the members defined for the current TypeInfo, using the specified
      binding constraints.
      
      <remarks>
        Members include properties, methods, fields, events, and so on.

        The following BindingFlags filter flags can be used to define which members to
        include in the search: 
        <ul>
          <li>
            You must specify either BindingFlags.Instance or BindingFlags.Static in order to
            get a return.
          </li>
          <li>
            Specify BindingFlags.Public to include public members in the search.
          </li>
          <li>
            Specify BindingFlags.NonPublic to include non-public members (that is, private
            and protected members) in the search.
          </li>
        </ul>

        The following BindingFlags modifier flags can be used to change how the search
        works: 

        BindingFlags.DeclaredOnly to search only the members declared on the TType,
        not members that were simply inherited.

        Calling this method with only the Public flag or only the NonPublic flag will
        return the specified members and does not require any other flags.

        See Nemerle.Compiler.BindingFlags for more information.
      </remarks>
   */
  public override GetMembers (bindingAttr : BindingFlags) : list [IMember]
  {
    get_members (bindingAttr, fun (m : IMember) {
      constrain_member (m, bindingAttr)
    })
  }
  
  public override GetMembers () : list [IMember]
  {
    get_members ((0 :> BindingFlags), fun (_) { true })
  }

  public override GetFields (bindingAttr : BindingFlags) : list [IField]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Field => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list [IField])
  }
    
  public GetFields () : list [IField]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Field => true
        | _ => false
      }
    });
    (mems :> list [IField])
  }


  /** Searches for the methods defined for the current TypeInfo, using the
      specified binding constraints.
  */
  public GetMethods (bindingAttr : BindingFlags) : list [IMethod]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      if (x.MemberType == MemberTypes.Method)
        constrain_member (x, bindingAttr)
      else
        false
    });
    (mems :> list [IMethod])
  }

  public GetMethods () : list [IMethod]
  {
    GetMethods (BindingFlags.Static %| BindingFlags.Instance %|
                BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the constructors defined for the current TypeBuilder, using the
      specified BindingFlags.
  */
  public override GetConstructors (bindingAttr : BindingFlags) : list [IMethod]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      if (x.MemberType == MemberTypes.Constructor)
        constrain_member (x, bindingAttr)
      else
        false
    });
    (mems :> list [IMethod])
  }

  public GetConstructors () : list [IMethod]
  {
    GetConstructors (BindingFlags.Static %| BindingFlags.Instance %|
                     BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the types defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetNestedTypes (bindingAttr : BindingFlags) : list [TypeInfo]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Type (t) =>
          constrain_member (t, bindingAttr %| BindingFlags.Static %|
                            BindingFlags.Instance)
        | _ => false
      }
    });
    (mems :> list [TypeInfo])
  }

  public GetNestedTypes () : list [TypeInfo]
  {
    GetNestedTypes (BindingFlags.Static %| BindingFlags.Instance %|
                    BindingFlags.Public %| BindingFlags.NonPublic)
  }

  public GetProperties (bindingAttr : BindingFlags) : list [IProperty]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Property => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list [IProperty])
  }
    
  public GetProperties () : list [IProperty]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MemberKind.Property => true | _ => false }
    });
    (mems :> list [IProperty])
  }

  public GetEvents (bindingAttr : BindingFlags) : list [IEvent]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Event => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list [IEvent])
  }
    
  public GetEvents () : list [IEvent]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MemberKind.Event => true | _ => false }
    });
    (mems :> list [IEvent])
  }

  /** Return list of all members defined in this very type. */
  public GetDirectMembers () : list [IMember]
  {
    member_list
  }

  public GetTypeBuilder () : System.Reflection.Emit.TypeBuilder
  {
    assert (type_builder != null);
    type_builder
  }

  public GetVariantOptionParent () : TypeBuilder
  {
    assert (variant_option_parent != null);
    variant_option_parent
  }
  
  public GetVariantOptions () : list [TypeBuilder]
  {
    variant_options
  }

  /** Return interfaces [this] needs to implement (that is it says it will
      implement them, but they are not implemented in base class). */
  public InterfacesToImplement () : list [TypeInfo] 
  {
    def base_class =
      match (SuperClass ()) {
        | Some (tc) => tc
        | None => InternalType.Object_tc
      };

    def collect (t : TType.Class, acc) {
      def tc = t.tycon;
      if (tc.IsInterface) {
        match (base_class.SuperType (tc)) {
          | Some => acc
          | None => tc :: acc
        }
      }
      else
        acc
    };
    
    List.FoldLeft (GetSuperTypes (), [], collect);
  }

  //------------ METHODS FOR TYPING --------------------------------------  

  /**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   */
  internal override FreshSubst () : Subst
  {
    Tyvar.fresh_subst (this.typarms)
  }

  /**
   * Helper used also in ExternalNemerleType.
   */
  internal static ConstructSubst (tc : TypeInfo, typarms : list [Tyvar.T],
                                  args : list [TType]) : Subst
  {
    def loop (ini : Subst, parms : list [Tyvar.T], args : list [TType]) : Subst {
      match ((parms, args)) {
        | (p :: ps, a :: args) =>
          match (a) {
            | TType.Variable (p') =>
              if (p.id == p'.id) ini
              else loop (ini.Add (p.id, TvValue.Exactly (a)), ps, args)
            | _ => loop (ini.Add (p.id, TvValue.Exactly (a)), ps, args)
          }
        | ([], []) => ini
        | _ => Util.ice ()
      }
    };

    def len_tp = typarms.Length;
    def len_ac = args.Length;

    if (len_tp == len_ac) {
      def sub = loop (SystemMap (), typarms, args);

      def check_constraints (tv : Tyvar.T, t : TType) : void {
        foreach (c in tv.GetConstraints ()) 
        {
          unless (t >:> (c /- sub)) {
            Message.error ($ "typing constraint $(tv.name) :> $c is not "
                             "satisfied by $t :> $(c /- sub)");
            Message.error (tc.Location, "upon instantiation of " + tc.FullName)
          }
        };
      };
      List.Iter2 (typarms, args, check_constraints);

      sub
    } 
    else {
      Message.error ($"type `$(tc.FullName)' takes $len_tp argument(s) while $len_ac were supplied");
      SystemMap ()
    }
  }

  /**
   * Construct substitution resulting from applying this type constructor
   * to specified arguments.
   *
   * For example assuming our type parameters are are ('a, 'b), then
   * [MakeSubst ([t1, t2])] produces substitution { 'a := t1; 'b := t2 }.
   */
  internal override MakeSubst (args : list [TType]) : Subst
  {
    ConstructSubst (this, typarms, args)
  }

  /**
   * Return substitution to apply to types of members of our supertype [ti]
   * to get types of members in [this].
   *
   * <remarks>
   *    For example consider:
   *    <code>
   *      class A ['a] { f : 'a; }
   *      class B : A [int] { }
   *    </code>
   *    Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
   *    it can be applied to type of [A.f] which is ['a], to obtain type
   *    of [B.f] which is [int].
   * </remarks>
   */
  internal override SubtypingSubst (tc : TypeInfo) : Subst
  {
    if (this.Equals (tc))
      SystemMap () // current type, no substitution
    else
      tc.MakeSubst (Option.UnSome (SuperType (tc)));
  }

  
  internal ReverseChildren () : void {
    contained_types = List.Rev (contained_types);
    variant_options = List.Rev (variant_options);
  }
  
  /**
   * Construct typing environments for each declaration.
   *
   * <remarks>
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   */
  make_tyenvs () : void
  {
    assert (this.tenv == null);
    def tenv = Tyvar.TEnv ();
    match (this.pt_tydecl) {
      | PT.TopDeclaration.Class { typarms = ps; } 
      | PT.TopDeclaration.Alias { typarms = ps; }
      | PT.TopDeclaration.Interface { typarms = ps; } 
      | PT.TopDeclaration.Variant { typarms = ps; } =>
        def (tenv, tyvars) = tenv.add_typarms (this.env, ps,
                                               this, check_parms = false);
        this.tenv = tenv;
        this.typarms = tyvars;
      | _ =>
        this.tenv = tenv;
        this.typarms = [];
    }

    match (pt_tydecl) {
      | PT.TopDeclaration.VariantOption (members) =>
        unless (Util.is_capitalized (name)) {
          Message.error (loc, "variant options names must start with capital letters")
        };
        assert (variant_option_parent.tenv != null);
        this.tenv = variant_option_parent.tenv;
        this.typarms = variant_option_parent.typarms;
       
        foreach (d : PT.ClassMember in members)
          d.Attributes |= NemerleAttributes.Public;
        
      | PT.TopDeclaration.Variant =>  attributes |= NemerleAttributes.Abstract
      | _ => ()
    };

    foreach (x : TypeBuilder in this.contained_types)
      Util.locate (x.loc, x.make_tyenvs ());
  }


  /**
   * Bind type expressions occurring in type declarations. This
   * includes [extends] type, [implements] list, and aliased type
   * in case of type alias declaration.
   *
   * <remarks>
   *   Binding type expression refers to rewriting [Parsetree.Type]
   *   into [Typedtree.TType], which involves resolving names of type
   *   constructors (to [TypeBuilder] objects) and type variables (to [Tyvar.T]
   *   objects).
   *   
   *   This function depends on nested types being processed *before*
   *   parent type (so it should only operate on reversed infos list).
   * </remarks>
   */
  bind_types () : void
  {
    def td = this.pt_tydecl;
    
    this.tydecl =
      match (td) {
        | PT.TopDeclaration.Class => TypeDeclaration.Class ()
        | PT.TopDeclaration.Alias (_, t) =>
          def ttype = this.tenv.bind (this.env, this, t, check_parms = false);
          TypeDeclaration.Alias (ttype)
        | PT.TopDeclaration.Interface => TypeDeclaration.Interface ()
        | PT.TopDeclaration.Delegate => Util.ice ("delegates shouldn't survive to typing")
        | PT.TopDeclaration.Enum => TypeDeclaration.Enum ()
        | PT.TopDeclaration.Variant =>
          TypeDeclaration.Variant (List.Map (variant_options, fun (x : TypeBuilder) : TypeInfo { x }))
        | PT.TopDeclaration.VariantOption => TypeDeclaration.VariantOption ()
        
        | PT.TopDeclaration.Macro | PT.TopDeclaration.Namespace | PT.TopDeclaration.Using 
        | PT.TopDeclaration.UsingAlias | PT.TopDeclaration.Attribute  
          => Util.ice ("this top declaration shouldn't survive to typing")        
      };
      
    match (td) {
      | PT.TopDeclaration.VariantOption =>
        this.parent_type = Some (variant_option_parent.GetMemType () :> TType.Class);
        this.t_implements = [];
      | PT.TopDeclaration.Class { t_extends = hd :: tl }
      | PT.TopDeclaration.Interface { t_extends = hd :: tl }
      | PT.TopDeclaration.Variant { t_extends = hd :: tl } 
      | PT.TopDeclaration.Enum { t_extends = hd :: tl } =>        
        def bind_to_class (t : PT.PExpr) {
          this.tenv.bind (this.env, this, t, check_parms = false) :> TType.Class;
        };
        def hd' = bind_to_class (hd);
        match (hd') {
          | ttc when !ttc.tycon.IsInterface =>
            this.parent_type = Some (ttc); 
            this.t_implements = List.RevMap (tl, bind_to_class);
          | _ =>
            this.t_implements = hd' :: List.RevMap (tl, bind_to_class);
            this.parent_type = None ()
        }
      | _ =>
        this.t_implements = [];
        this.parent_type = None ()
    };

    when (is_enum)  handle_underlying_enum_type ();
    
    // warn about nested value types 
    when ((enclosing_type matches Some) && IsValueType)
      Message.warning (loc, "nested value types fail to compile under .NET Framework v1.1");

    when (IsStruct)
    {      
      // make sure no bogus attributes have been specified
      def access_mask = NemerleAttributes.AccessModifiers %| NemerleAttributes.Struct;
      when ((attributes %& ~access_mask) != NemerleAttributes.None)
        Message.error (loc, "structures are only allowed to have access specifiers as attributes");
        
      // mark the structure as sealed
      attributes |= NemerleAttributes.Sealed;
    }
    
    match (parent_type) {
      | None =>
        unless (IsInterface || IsAlias) {
          def parent = 
            // make the structure inherit from System.ValueType                           
            if (IsStruct)
              InternalType.ValueType;
            else 
              InternalType.Object;

          parent_type = Some (parent)
        }

      | Some (tclass) =>
        when (IsInterface) {
          Message.error (loc, "interfaces are not allowed to inherit from other types");
          parent_type = None ();
        }
        when (IsStruct) {
          Message.error (loc, "structures are not allowed to inherit from other types");
          parent_type = Some (InternalType.ValueType)
        }
        when (tclass.tycon.IsSealed) {
          Message.error (loc, "cannot extend sealed class");
          parent_type = Some (InternalType.Object)
        }
    }
       
    // construct this.iterate_first - enclosing type plus transitive closure of all base types
    def iterate_first = Hashtable ();

    foreach (ty : TType.Class in GetDirectSuperTypes ()) {
      when (ty.tycon != null) {
        match (ty.tycon.GetTypeInfoKind ()) {
          | TypeInfoKind.NemerleType (ti) => iterate_first.Set (ti.GetId (), ti)
          | _ => ()
        }
      }
    }
    def first = match (enclosing_type) {
      | Some (x) => [x]
      | _ => []
    }
    this.iterate_first = iterate_first.Fold (first, fun (_, ti, acc) { ti :: acc });

  }

  construct_subtyping_map () : void
  {
    def add_srs (t : TType.Class, s : Subinfo) {
      add_subtyping_of (s, t.tycon, t.args)
    };
    supertypes = List.FoldLeft (GetDirectSuperTypes (), SystemMap (), add_srs)
  }

  add_subtyping_of (subinfo : Subinfo, tc : TypeInfo, args : list [TType]) : Subinfo
  {
    def add_sr (subinfo : Subinfo, subtyped : TypeInfo, args : list [TType]) {
      match (subinfo.Find (subtyped.GetId ())) {
        | Some ((_, args')) =>
          mutable problem = "";
          def check_eq (t1 : TType, t2 : TType) : bool {
            if (Tyutil.types_eq (t1, t2)) true
            else {
              problem = $ "types $t1 and $t2 are not compatible";
              false
            }
          };
          unless (List.ForAll2 (args, args', check_eq)) {
            Message.error ($ "type `$(subtyped)' is implemented by type "
                             "`$(FullName)' twice under different "
                             "instantiations");
            if (tc.Equals (subtyped))
              Message.error ("second one directly")
            else
              Message.error ("second one through `" + tc.FullName + "'");
            Message.error (problem);
          };
          subinfo
        | None =>
          subinfo.Add (subtyped.GetId (), (subtyped, args))
      }
    };

    def sub = tc.MakeSubst (args);

    def add_srt (t : TType.Class, subinfo : Subinfo) {
      add_sr (subinfo, t.tycon, List.Map (t.args, fun (t) { t /- sub }))
    };

    def subinfo = List.FoldLeft (tc.GetSuperTypes (), subinfo, add_srt);
    def subinfo = add_sr (subinfo, tc, args);
    subinfo
  }

  public override GetSuperTypes () : list [TType.Class]
  {
    if (supertypes == null) []
    else
      supertypes.Fold (fun (_, x, acc) {
                         def (tc, args) = x;
                         (TType.Class (tc, args) :> TType.Class) :: acc
                       }, [])
  }

  add_derived_members () : void
  {
    def get_members (t : TType.Class) {
      t.tycon.GetMembers ()
    };
    def members = 
      if (IsInterface)
        List.Concat (List.RevMap (GetDirectSuperTypes (), get_members))
      else
        match (parent_type) {
          | Some (t) => get_members (t)
          | None => []
        }
      
    def inherit_it (mem : IMember) {
      !(mem.MemberType %&& MemberTypes.Constructor ||
        mem.Attributes %&& NemerleAttributes.Private)
    };

    def add (mem : IMember, map : SystemMap [string, list [IMember]]) {
      if (inherit_it (mem)) {
        def n = mem.Name;
        match (map.Find (n)) {
          | Some (l) => map.Replace (n, mem :: l)
          | None => map.Add (n, [mem])
        }
      }
      else map
    };

    member_map = List.FoldLeft (members, SystemMap (), add);
    member_list = []
  }

  internal ExtendPartialClass (additional : PT.TopDeclaration) : void
  {
    if ((Attributes %& additional.Attributes) %&& NemerleAttributes.Partial) {
      unless (additional.Attributes %&& NemerleAttributes.AccessModifiers)
        match (enclosing_type) {
          | Some => additional.Attributes |= NemerleAttributes.Private;
          | None => additional.Attributes |= NemerleAttributes.Internal;
        }
      when (additional.Attributes != attributes)
        Message.error (additional.loc, $"joined partial classes `$(FullName)' "
                       "must have compatible modifiers");
      
    }
    else {
      Message.error (additional.loc, "you must specify `partial' modifier on all"
                     " declarations of type `" + FullName + "'");
      Message.error (this.Location, "first defined here");
    }

    match (additional) {
      | PT.TopDeclaration.Class { decls = ds } =>
        foreach (x : PT.ClassMember in ds) Define (x);
      | _ =>
        Message.error (additional.loc, "`partial' modifier cannot be used with this type")
    }
    
    modifiers.custom_attrs += additional.GetCustomAttributes ();
    modifiers.macro_attrs += additional.modifiers.macro_attrs;    
  }


  internal static constrain_member (m : IMember, flags : BindingFlags) : bool
  {
    def is_public = m.Attributes %&& NemerleAttributes.Public;
    // if flag is Public then always return all public members
    flags == BindingFlags.Public && is_public ||
    // if flag is NonPublic then always return all nonpublic members
    flags == BindingFlags.NonPublic && !is_public ||
    // masks
    (!m.IsStatic || flags %&& BindingFlags.Static) &&
    (m.IsStatic || flags %&& BindingFlags.Instance) &&
    (!is_public || flags %&& BindingFlags.Public) &&
    (is_public || flags %&& BindingFlags.NonPublic)
  }

  /** Note that [bindingAttr] is used only to check the case for DeclaredOnly
      members, so you have to provide filter function to check other flags */
  private get_members (bindingAttr : BindingFlags, filter : IMember -> bool)
  : list [IMember]
  {
    def maybe_add (m : IMember, acc) {
      if (filter(m)) m :: acc else acc
    };
    def add_few (_, mems, acc) {
      List.FoldLeft (mems, acc, maybe_add)
    };
    if (bindingAttr %&& BindingFlags.DeclaredOnly)
      List.Filter (member_list, filter)
    else
      member_map.Fold (add_few, [])
  }

  internal BindType (t : PT.PExpr) : TType
  {
    BindType (tenv, t)
  }

  [Nemerle.Assertions.Ensures (value != null)]
  internal BindType (other_tenv : Tyvar.TEnv, t : PT.PExpr) : TType
  {
    other_tenv.bind (env, this, t, check_parms = true)
  }

  internal BindTyparms (tp : PT.Typarms) : Tyvar.TEnv * list [Tyvar.T]
  {
    BindTyparms (tenv, tp)
  }

  internal BindTyparms (other_tenv : Tyvar.TEnv, tp : PT.Typarms)
  : Tyvar.TEnv * list [Tyvar.T]
  {
    other_tenv.add_typarms (env, tp, this, check_parms = true)
  }

  BindAndAddMember (class_member : PT.ClassMember) : void
  {
    try { 
      ignore (bind_and_add_member (class_member))
    } catch {
      | _ : Recovery => ()
    }
  }

  internal AddMember (mem : IMember) : void
  {
    // traverse existing members [mems] searching one which match signature
    // with the newly added method [meth]
    // returns new list of members having this name
    def replace_method (acc, meth : IMember, mems) {
      match (mems) {
        // no methods with matching signature found
        | [] =>
          when (mem.Attributes %&& NemerleAttributes.Override)
            Message.error ($"`override' specified on $mem"
                           ", but there is no method with this signature "
                           "in parent to override");
          // we simply add this method to the existing list
          meth :: acc

        // process next member 
        | x :: xs =>
          match ((x : IMember).GetKind ()) {
            | MemberKind.Method (m) =>
              def sub = SubtypingSubst (m.DeclaringType);

              when (m.DeclaringType.Equals (this))
                match ((m.GetMemType () /- sub, meth.GetMemType ())) {
                  | (TType.Function (t1, r1), TType.Function (t2, r2))
                    when Tyutil.types_eq (t1, t2) && ! Tyutil.types_eq (r1, r2) =>
                    Message.error (meth.Location, 
                                   $"attemted return type overload on $meth and $m")
                  | _ => ()
                };

              // if signature of existing method matches the new one
              if (Tyutil.types_eq (m.GetMemType () /- sub, mem.GetMemType ())) {
                // check if new method does not hide or conflict with
                // existing methods in this and base type
                match (m.GetFunKind ()) {
                  | _ when m.DeclaringType.Equals (this) =>
                    Message.error (meth.Location,
                                   "redefinition of " + meth.ToString ())

                  // new method has 'new' modifier, so it's ok to hide old one
                  | _ when meth.Attributes %&& NemerleAttributes.New => ()
                  | _ when meth.Attributes %&& NemerleAttributes.Override =>
                    if (m.Attributes %&& NemerleAttributes.Virtual)
                      if (m.IsFinal)
                        Message.error ($"`override' specified on $meth, but $x is `sealed'")
                      else {}
                    else
                      Message.error ($"`override' specified on $meth"
                                     ", but there is no `virtual' modifier on $x");
                                     
                    when ((x.Attributes %& NemerleAttributes.AccessModifiers) !=
                          (meth.Attributes %& NemerleAttributes.AccessModifiers))
                      Message.error ($"attempt to change the access modifiers of $meth"
                                     " during override of $x");
                  | FunKind.Constructor | FunKind.StaticConstructor => Util.ice ("constructor?")
                  | _ =>
                    Message.error (meth.Location, $"$meth hides $x but `new' is not specified")
                };
                // return list with the new method inside (and without [x], which is hidden now)
                List.RevAppend (xs, meth :: acc)
              }
              else
                // signature do not match, just process remaining members
                replace_method (x :: acc, meth, xs)
                
            | _ => Util.ice ("expecting method, got " + x.ToString ())
          }
      }
    };
/*
    def _meths = GetMethods ();
    Message.debug (FullName);
    foreach (meth in _meths) Message.debug (meth.ToString ());
  */ 

    when (IsValueType && !mem.IsStatic)
      match (mem) {
        | fld : IField =>
          match (fld.GetMemType ()) {
            // enum structs have this special __value field, which is cyclic
            | TType.Class ((tc : TypeBuilder), _) when tc.IsValueType =>
              iterate_first = tc :: iterate_first;
            | _ => ()
          }
        | _ => ()
      }
    
    def new_mems =
      match (member_map.Find (mem.Name)) {
        | Some ([]) => Util.ice ()
        | Some ((x :: _) as old) =>
          if (x.DeclaringType.Equals (this))
            match ((mem.GetKind (), x.GetKind ())) {
              | (MemberKind.Method (m), MemberKind.Method) =>
                replace_method ([], m, old)
                
              | (MemberKind.Property (p1), MemberKind.Property (p2)) when p1.IsIndexer && p2.IsIndexer =>
                // overloading is (hopefully) checked at the get/set method level
                mem :: old
                
              | _ =>
                Message.error (mem.Location, $"$mem redefined in `$(FullName)'");
                Message.error (x.Location, "  first definition here as " + x.ToString ());
                [mem]
            }
          else
            // take a look at current member [mem] and the one found in ancestors [x]
            match ((mem.GetKind (), x.GetKind ())) {
              | (MemberKind.Method (m), MemberKind.Method) => replace_method ([], m, old)
                
              | (MemberKind.Property (new_prop), MemberKind.Property (old)) 
                  when new_prop.Attributes %&& NemerleAttributes.Override =>
                (new_prop :> NemerleProperty).UpdateParentProperty (old);
                [mem]
                
              | _ when mem.Attributes %&& NemerleAttributes.New => [mem]
              | _ =>
                Message.error (mem.Location, $"$mem hides $x but `new' is not specified");
                [mem]
            }

        | None =>
          when (mem.Attributes %&& NemerleAttributes.Override)
            Message.error ($"`override' specified on $mem, "
                           "but there is no such member in parent to override");
          [mem]
      };
    member_map = member_map.Replace (mem.Name, new_mems);
    member_list = mem :: member_list;
  }


  internal ConstructTypeBuilder () : void
  {
    when (system_type == null) {
      type_builder = Passes.Emitter.ConstructTypeBuilder (this);
      system_type = type_builder;
    }
  }

  internal FinalizeType () : void
  {
    when (!cannot_finalize && type_builder != null) {
      system_type = type_builder.CreateType ();
      type_builder = null;
    }
  }
  
  bind_and_add_member (class_member : PT.ClassMember) : IMember
  {
    Util.locate (class_member.loc, {
      // if current class is static (it's a module) then sign its members to static
      when (IsModule)
        class_member.Attributes |= NemerleAttributes.Static;      
        
      when (IsInterface) {
        when (class_member.Attributes != NemerleAttributes.None)
          Message.error ("interface members are not allowed"
                         " to have any attributes specified");
        class_member.Attributes = NemerleAttributes.Virtual %|
          NemerleAttributes.Abstract %| NemerleAttributes.Public;
      }
      
      match (class_member) {
        | PT.ClassMember.EnumOption
        | PT.ClassMember.TypeDeclaration => null
          
        | (PT.ClassMember.Field) as f =>
          def r = NemerleField (this, f);
          r.CheckAttributes ();
          AddMember (r);
          r : NemerleMember
          
        | (PT.ClassMember.Function) as f =>          
          def r = NemerleMethod (this, f);
          r.CheckAttributes ();
          unless (instance_ctor_occured)
            instance_ctor_occured = r.MemberType == MemberTypes.Constructor;
          AddMember (r);
          r
          
        | (PT.ClassMember.Property) as p =>
          def r = NemerleProperty (this, p);
          when (r.IsIndexer && r.Name == "Item") {
            default_indexer = Some ("Item");
            modifiers.AddCustomAttribute (System.AttributeTargets.Class,
                                          <[ System.Reflection.DefaultMemberAttribute ("Item") ]>);
          }
          r.CheckAttributes ();
          AddMember (r);
          r
          
        | (PT.ClassMember.Event) as e =>
          def r = NemerleEvent (this, e);
          r.CheckAttributes ();
          AddMember (r);
          r
      }
    })
  }

  handle_underlying_enum_type () : void
  {
    match (parent_type) {
      | Some (t) =>
        underlying_enum_type = t;
      | None =>
        underlying_enum_type = InternalType.Int32;
    };
    
    parent_type = Some (InternalType.Enum);

    unless (t_implements matches [])
      Message.error ("enum cannot implement anything");

    def oops () {
      Message.error ($ "`$(underlying_enum_type)' is not valid underlying enum type");
    };

    
    match (Tyutil.top_expand (underlying_enum_type)) {
      | TType.Class (tc, []) =>
        match (NumericType.ByName (tc.FullName)) {
          | Some (t) when t.IsInteger =>
            underlying_enum_type_iface = t
          | _ => oops ()
        }
      | _ => oops ()
    }
  }


  /*
   * This methods calculates an enum's field values. We allow constants,
   * references to enum fields of this enum that already have been calculated,
   * arithmetic addition and basic bit-wise operations.
   */
  calculate_enum_value (expr : PT.PExpr, default_value : object,
                        resolved_values : Hashtable [string, object]) : object
  {
    def enum_type = underlying_enum_type_iface;

    def resolve_ref (_, is_post, e) {
      if (is_post) 
        match (e) {
          | <[ $(n : name) ]> when resolved_values.Contains (n.Id) =>
            def val = resolved_values [n.Id];
            match (NumericType.ByName (val.GetType ().FullName)) {
              | Some (nt) =>
                PT.PExpr.Literal (nt.ToLiteral (val))
              | _ =>
                Util.ice ("resolved_values holds nonnumeric type?")
            }

          | <[ $(n : name) ]> when ConstantFolder.is_known_operator (n.Id) => e
            
          | <[ $(n : name) ]> =>
            Message.fatal_error ($"references are allowed only to this enum's fields preceding "
                                 "this one in the source code, while `$(n.Id)' occured");
            null

          | _ => e    
        }
      else e
    }
    def no_refs = 
      Util.locate (expr.loc, {
        Macros.TraverseExpr (None (), expr, false, resolve_ref)
      });
    
    match (ConstantFolder.FoldConstants (env, no_refs)) {
      | PT.PExpr.Literal (lit) =>
        def have_good_literal_type =
          match (lit) {
            | Literal.Byte
            | Literal.SByte
            | Literal.Short
            | Literal.UShort
            | Literal.Int
            | Literal.UInt
            | Literal.Long
            | Literal.ULong =>
              true

            | _ =>
              false
          }

        if (have_good_literal_type)
        {            
          def val = enum_type.FromLiteral (lit);
        
          if (val == null)
          {
            Message.error ($ "underlying type of enum `$(FullName)' "
                           " is $(underlying_enum_type), so enum literal "
                           "need to have this type");
            default_value
          }
          else
            val
        }
        else
        {
          Message.error ("only 8, 16, 32 and 64-bit, signed and unsigned integer "
                         "types are allowed as enum values");
          default_value
        }
          
      | _ =>
        Message.error ("enum definition expression is too complex");
        Message.hint ("  enum definitions are allowed to be expressions taking constants,");
        Message.hint ("  references to this enum's fields preceding this field, checked ");
        Message.hint ("  operations +, <<, >> and -, bit-wise operations %|, %&, %^ and negation");          
        default_value
    }
  }
  
  add_enum_members (decls : list [PT.ClassMember]) : void
  {
    def field_type = PT.PExpr.TypedType (GetMemType ());
    def enum_type = underlying_enum_type_iface;
    def resolved_values = Hashtable (32);
    
    def add_field (ef : PT.ClassMember, default_value) {
      def current_value =
        match (ef) {
          | PT.ClassMember.EnumOption (Some (expr)) =>
            calculate_enum_value (expr, default_value, resolved_values)

          | PT.ClassMember.EnumOption (None) =>
            default_value
            
          | _ =>
            Util.ice ("add_enum_members")
        }
      
      ef.Attributes |= NemerleAttributes.Public %| NemerleAttributes.Static;
      def field = PT.ClassMember.Field (ef.loc, ef.name, ef.modifiers, field_type);
      def field = bind_and_add_member (field);
      (field :> NemerleField).enum_value = current_value;
      resolved_values.Add (ef.name.GetFullId (), current_value);
      enum_type.Binary (false, "+", current_value, enum_type.One)
    };

    assert (underlying_enum_type != null);
    BindAndAddMember (<[ decl: public value__ : $(underlying_enum_type : typed); ]>);
    _ = List.FoldLeft (decls, underlying_enum_type_iface.Zero, add_field);
  }
  

  /**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [TypeBuilder.contained_types]) and store
   * them in [TypeBuilder.member_map] and [TypeBuilder.member_list].
   *
   * <remarks>
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   */
  add_members () : void
  {
    add_derived_members ();
    def decls =
      match (pt_tydecl) {
        | PT.TopDeclaration.Class { decls = ds }
        | PT.TopDeclaration.Interface { methods = ds }
        | PT.TopDeclaration.Variant { decls = ds }
        | PT.TopDeclaration.VariantOption (ds) => ds
        | PT.TopDeclaration.Enum { decls = ds } => add_enum_members (ds); []
        | _ => []
      };

    List.Iter (decls, BindAndAddMember);
    List.Iter (additional_decls, BindAndAddMember);

    contained_types = List.Rev (contained_types);
    List.Iter (contained_types, AddMember);
    
    member_list = List.Rev (member_list);

    /// define implicit instance constructor if none exists
    unless (instance_ctor_occured) {
      match (DefineAndReturn (<[ decl: public this () { } ]>)) {
        | Some (meth) => meth.SetInstanceUsed ();
        | _ => ()
      }
    }

    // we no longer need it, let GC kill it
    pt_tydecl = null;
    additional_decls = null;
  }

  add_constant_object_ctor () : void
  {
    match (member_map.Find (".ctor")) {
      | Some ([ctor]) =>
        def ctor = (ctor :> NemerleMethod);
        def field = <[ decl: public static _N_constant_object : void; ]>;
        field.loc = loc;
        def typed_field = NemerleField (this, (field :> PT.ClassMember.Field));
        typed_field.MarkWithSpecialName ();
        typed_field.ty = variant_option_parent.GetMemType ();
        ctor.Attributes = NemerleAttributes.Private;
        AddMember (typed_field);
        
        constant_object = Some ((typed_field : IField));
        
        def ttf = typed_field.ty;
        
        // use typed trees here to avoid problems during actual typing
        def tbody = TExpr.Assign (loc, TType.Void (),
                              TExpr.StaticRef (loc, ttf, typed_field), 
                              TExpr.Call (loc, ttf,
                                      TExpr.StaticRef (loc, ctor.GetMemType (), ctor), []));
                                      
        def static_ctor = <[ decl: static this () { $(tbody : typed) } ]>;
        BindAndAddMember (static_ctor);

        // add the constant object generator function
        def generator = DefineAndReturn (<[ decl:
          public static _N_constant_object_generator () : $(typed_field.ty : typed)
          {
            _N_constant_object
          }
        ]>);

        assert (Option.IsSome (generator));
        Option.UnSome (generator).MarkWithSpecialName ()
        
      | _ => Util.ice (FullName)
    }
  }

  /**
   * Add special methods to variants and variant options. These methods
   * are used to accelerate matching over variants, allowing us to use
   * a single CExpr.Switch statement to identify a variant options instead of 
   * a series of CExpr.If/HasType instructions.
   *
   */
  private add_special_variant_methods () : void
  {
    match (tydecl) {
      | TypeDeclaration.Variant =>
        def gvc = <[ decl:
          public abstract _N_GetVariantCode () : int ;
        ]>;
        gvc.Attributes |= NemerleAttributes.SpecialName;

        Define (gvc)

      | TypeDeclaration.VariantOption =>
        mutable my_index = 0;
                       
        _ = List.Find (variant_option_parent.GetVariantOptions (), fun (x) {
          (x : object) == (this : object) || ({ ++my_index; false })
        });

        def gvc = <[ decl:
          public override _N_GetVariantCode () : int {
            $(my_index : int)
          }
        ]>;
        gvc.Attributes |= NemerleAttributes.SpecialName;
        
        Define (gvc)

      | _ => ()
    }
  }

  /**
   * Add constant fields with single instance of parameter-less 
   * variant options.
   */
  private add_constant_variant_ctors () : void
  {
    constant_object = None ();
    match ((tydecl, GetFields ())) {
      | (TypeDeclaration.VariantOption, []) =>
        add_constant_object_ctor ()
      | _ => ()
    }        
  }
  
  internal GetTyparms () : list [Tyvar.T]
  {
    typarms
  }

  internal FixupDefinedClass () : void
  {
    // finalization is blocked until call to Compile
    this.cannot_finalize = true;
    this.constant_object = None ();
    
    Util.locate (loc, process_macro_attributes (MacroPhase.BeforeInheritance));
    
    when (run_phase >= 1)
      make_tyenvs ();
    when (run_phase >= 2)
      Util.locate (loc, bind_types ());
    when (run_phase >= 3)
      construct_subtyping_map ();
    when (run_phase >= 4)
      check_bound_types ();
    when (run_phase >= 5) {
      process_macro_attributes (MacroPhase.BeforeTypedMembers);
      add_members ();
      process_macro_attributes (MacroPhase.WithTypedMembers);
      foreach (mem in GetDirectMembers ()) Passes.Emitter.MemberAdded (this, mem);
    }
  }
  
  /**
   * Propagates the SpecialName mark throughout the member hierarchy
   */
  private mark_members_with_special_name () : void
  {
    foreach (member : IMember in member_list)
      match (member) {
        | nm : NemerleMember =>  nm.MarkWithSpecialName ()
        | _ => ()
      }

    foreach (tb : TypeBuilder in contained_types)
      tb.MarkWithSpecialName ();
  }
  

  /**
   * Resolves overrides for the required interface methods
   */
  resolve_method_implements () : void
  {
    check_abstract ();

    def methods = GetMethods (BindingFlags.DeclaredOnly %| BindingFlags.Public %|
                              BindingFlags.Instance %| BindingFlags.NonPublic) :> list [NemerleMethod];
    
    // FIXME: in fact we should only mark some methods as implemented and scream
    // when signature match is ambigious

    // unresolved interface methods, which we must implement
    def iface_methods = Hashtable (30);
  
    foreach (tc : TypeInfo in InterfacesToImplement ())
      foreach (m : IMember in tc.GetMembers (BindingFlags.DeclaredOnly %|
                                             BindingFlags.Public %|
                                             BindingFlags.Instance))
        match (m.GetKind ()) {
          | MemberKind.Method (m) =>
            match (iface_methods.Get (m.Name)) {
              | Some (lst) => iface_methods.Set (m.Name, m :: lst)
              | None => iface_methods.Add (m.Name, [m])
            };
          | _ => ()
        }

    def bind_explicit_implements (meth : NemerleMethod)
    {
      def bind_one (name : PT.Splicable)
      {
        def name = name.GetName ();
        def env = name.GetEnv (this.env);
        def (ns, member) = List.DivideLast (name.idl);
        def ty = env.GetType (ns, this);
        
        match (iface_methods.Get (member)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              iface_meth.DeclaringType.Equals (ty) &&
                meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] =>
                Message.fatal_error ("interface `" + ty.FullName + 
                                     "' does not contain method named `" + member + 
                                     "' with proper signature")
              | [m] =>                
                iface_methods.Set (member, List.Filter (meths, fun (x) { ! is_correct (x) }));
                meth.HasBeenUsed = true;
                m
              | _ =>
                Message.fatal_error ("interface `" + ty.FullName + 
                                     "' contains more then one method named `" + member + 
                                     "' with proper signature")
            }
          | None =>
            Message.fatal_error ("no interface implemented by `" + this.FullName + 
                                 "' contains method named `" + member + 
                                 "' (looking for `" +
                                 Util.qid_of_list (name.idl) + "')")
        }
      };
      match (meth.GetFunKind ()) {
        | FunKind.Method (impl) =>
          def impl' =
            try { List.RevMap (impl, bind_one) }
            catch { _ : Recovery => [] };

          foreach (mem in impl') mem.HasBeenUsed = true;

          meth.SetFunKind (FunKind.BoundMethod (impl'))
        | _ => ()
      }
    };
    List.Iter (methods, bind_explicit_implements);

    // now we can see which methods defined in current class directly match
    // to some of the yet unimlemented interfaces methods
    def bind_implicit_implements (meth : NemerleMethod) {
      def lookup_iface_members () {
        match (iface_methods.Get (meth.Name)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              if (meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this))
                if (meth.Attributes %&& NemerleAttributes.Public &&
                    !(meth.Attributes %&& NemerleAttributes.Static)) 
                  true
                else {
                  Message.error (meth.Location, "method implementing interface"
                                 " member must be public and nonstatic");
                  false
                }
              else false
           };
            match (List.Partition (meths, is_correct)) {
              | ([], _) => [] // none were correct
              | (lst, notcorrect) =>
                iface_methods.Set (meth.Name, notcorrect);
                meth.HasBeenUsed = true;
                lst
            }
          | None => []
        }
      };
      match (meth.GetFunKind ()) {
        | FunKind.BoundMethod (impl) =>
          match (lookup_iface_members ()) {
            | [] => ()
            | impl' =>
              def new_impls = impl' + impl;

              foreach (impl in new_impls)
                impl.HasBeenUsed = true;

              meth.SetFunKind (FunKind.BoundMethod (new_impls));

              unless (meth.Attributes %&& NemerleAttributes.Virtual)
                meth.Attributes |= NemerleAttributes.Sealed %| NemerleAttributes.Virtual;
          }
        | _ => ()
      }
    };
    List.Iter (methods, bind_implicit_implements);

    // create the additional overrides for unresolved interface methods
    // we check if methods derived from base class are actually proper
    // implementators of some unresolved interface methods
    mutable resolved_additionals = [];

    def create_additional_overrides (name : string, mutable meths : list [IMethod])
    {
      unless (meths matches []) {
        // possible implementators from existing methods
        def possible_impls = LookupMember (name);

        // choose only methods from within possible implementors
        foreach (meth : IMethod in possible_impls) {
          def is_correct (iface_meth : IMethod)
          {
            (meth.Attributes %&& NemerleAttributes.Public) &&
            (meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this))
          };

          match (List.Partition (meths, is_correct)) {
            | ([], _) => ()
            | (correct, notcorrect) =>
              meths = notcorrect;

              // create a wrapper in the current type
              def meth_header = meth.GetHeader ();

              def meth_parms = List.Map (meth_header.parms, fun (fp : Fun_parm) {
                <[ funparm : $(fp.name : usesite) : $(fp.ty : typed) ]>
              });
              def meth_call_parms = List.Map (meth_header.parms, fun (fp : Fun_parm) {
                <[ $(fp.name : usesite) ]>
              });
              def mods = 
                if (meth.Attributes %&& NemerleAttributes.Virtual)  NemerleAttributes.Override 
                else NemerleAttributes.New;
              def attrs = Modifiers (NemerleAttributes.Public %| mods, []);

              def wrapper = DefineAndReturn (<[ decl:
                ..$attrs $(meth_header.name : usesite) 
                          (..$(meth_parms)) : $(meth_header.ret_type : typed)
                {
                  base.$(meth_header.name : usesite) (..$meth_call_parms)
                }
              ]>);

              // unpack the new method definition
              def wrapper = Option.UnSome (wrapper) :> NemerleMethod;

              wrapper.MarkWithSpecialName ();
              // not in method definition what we are implementing 
              // (this cannot be automatic because we are currently resolving implements
              wrapper.SetFunKind (FunKind.BoundMethod (correct));
          }
        }
        resolved_additionals = (name, meths) :: resolved_additionals;
      }
    }
    iface_methods.Iter (create_additional_overrides);
    foreach ((name, meths) in resolved_additionals) iface_methods.Set (name, meths);

    // emit error messages for any unbound interface method
    def scream_about_unimplemented (_, meths : list [IMethod])
    {
      foreach (meth in meths)
        Message.error ("unimplemented interface method `" + 
                       meth.DeclaringType.FullName + 
                       "." + meth.Name + "' with signature " +
                       Tyutil.fun_type (meth.GetHeader ()).ToString ())
    }
    
    iface_methods.Iter (scream_about_unimplemented)
  }

  process_macro_attributes (stage : MacroPhase) : void
  {
    def process_attributes (self_parm, suff, mods : Modifiers, meth : IMethod) {
      mutable macro_attrs = mods.macro_attrs;
      // we have to do the assignment here, in case macro has added a new
      // custom attribute
      mods.custom_attrs =
        List.Filter (mods.custom_attrs, fun (expr) {
          match (MacroRegistry.lookup_macro (env, expr, suff)) {
            | None => true
            | Some =>
              macro_attrs = (suff, expr) :: macro_attrs;
              false
          }
        });
      foreach ((_, expr) in macro_attrs)
      {
        match (MacroRegistry.lookup_macro (env, expr, suff)) {
          | None => ()
          | Some ((name, imacro, exprs)) =>
            def meth_header =
              if (meth == null) null else meth.GetHeader ();
            def tenv = 
              if (meth_header == null) this.tenv else meth_header.tenv;
            def in_ctor =
              if (meth != null)
                match (meth.GetFunKind ()) {
                  | FunKind.Constructor => true 
                  | _ => false
                }
              else
                false;
            def ctx =
              TypingContext (in_ctor = in_ctor,
                             this_ptr_decl = None (),
                             env = this.env,
                             tenv = tenv,
                             current_fun = meth_header,
                             locals = null,
                             parent_type = this,
                             in_tail_position = false,
                             is_checked = true);
            TypingContext.PushNewColor (name.color, name.GetEnv (env));

            def parms = 
              List.Append (self_parm, imacro.CallTransform (exprs));
            def res = imacro.Run (ctx, parms);
            TypingContext.PopColor ();

            assert (res == null);
        }
      };
      mods.macro_attrs = macro_attrs;
    };

    def process_member (mem, stage_suff) {
      match (mem) {
        | PT.ClassMember.Field =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                                     ":field" + stage_suff, mem.modifiers, null)

        | (PT.ClassMember.Function) as f =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                              ":method" + stage_suff, mem.modifiers, null);

          foreach (p : PT.Fun_parm in f.header.parms)
            process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                 PT.SyntaxElement.ClassMember (mem),
                                 PT.SyntaxElement.Parameter (p)],
                                ":param" + stage_suff,  p.modifiers, null);

        | PT.ClassMember.EnumOption
        | PT.ClassMember.TypeDeclaration => ()

        | PT.ClassMember.Property =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                              ":property" + stage_suff, mem.modifiers, null)

        | PT.ClassMember.Event => 
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                              ":event" + stage_suff, mem.modifiers, null)
      }
    };

    def iter_decls (stage_suff) {
      def decls =
        match (pt_tydecl) {
          | PT.TopDeclaration.Class { decls = ds }
          | PT.TopDeclaration.Interface { methods = ds }
          | PT.TopDeclaration.Variant { decls = ds }
          | PT.TopDeclaration.VariantOption (ds) => ds
          | _ => []
        };      

      foreach (x in decls) process_member (x, stage_suff);
      foreach (x in additional_decls) process_member (x, stage_suff);
    };

    def process_typed_member (mem : IMember) {
      match (mem.GetKind ()) {
        | MemberKind.Field (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                               PT.SyntaxElement.FieldBuilder ((f :> NemerleField))],
                               ":field:postadd", f.GetModifiers (), null)
        | MemberKind.Method (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                               PT.SyntaxElement.MethodBuilder ((f :> NemerleMethod))],
                               ":method:postadd", f.GetModifiers (), f);

          foreach (p : Fun_parm in f.GetHeader ().parms)
            process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                 PT.SyntaxElement.MethodBuilder ((f :> NemerleMethod)),
                                 PT.SyntaxElement.ParameterBuilder (p)],
                                 ":param:postadd", p.modifiers, f);
                              
        | MemberKind.Property (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                               PT.SyntaxElement.PropertyBuilder ((f :> NemerleProperty))],
                               ":property:postadd", f.GetModifiers (), null)

        | MemberKind.Event (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                               PT.SyntaxElement.EventBuilder ((f :> NemerleEvent))],
                               ":event:postadd", f.GetModifiers (), null)

        | MemberKind.Type => ()
      }
    };

    match (stage) {
      | MacroPhase.BeforeInheritance =>
        process_attributes ([PT.SyntaxElement.TypeBuilder (this)], ":type:postscan", modifiers, null);
        iter_decls (":postscan");

      | MacroPhase.BeforeTypedMembers =>
        process_attributes ([PT.SyntaxElement.TypeBuilder (this)], ":type:preadd", modifiers, null);
        iter_decls (":preadd");
        
      | MacroPhase.WithTypedMembers =>
        process_attributes ([PT.SyntaxElement.TypeBuilder (this)], ":type:postadd", modifiers, null);
        List.Iter (GetDirectMembers (), process_typed_member);

      | _ => Util.ice ("cannot run macros processing with none phase")
    }
  }

  /* ---------------------------------------------------------------------- */
  /* -- GLOBAL PROCESSING OF ALL TYPEBUILDERS------------------------------ */
  /* ---------------------------------------------------------------------- */

  public static Init () : void
  {
    infos = [];
  }

  /**
   * Construct datastructures we use to check subtyping relations.
   *
   * <remarks>
   *   This probably the hardest part of processing type declarations.
   *
   *   Each type directly subtypes types it extends or implements.  This
   *   pass computes transitive closure of direct subtyping relation
   *   and stores it [TypeBuilder.supertypes] map.  .NET generics doesn't allow
   *   same type to be subtyped under different instantiations, so we
   *   use map from (id of) subtyped TypeBuilder object to actual parameters
   *   of subtyped type.
   * </remarks>
   */
  static determine_subtyping () : void
  {
    Iter (fun (ti : TypeBuilder) { 
            ti.construct_subtyping_map () 
          });
  }

  static Iter (builders : list [TypeBuilder], f : TypeBuilder -> void) : void
  {
    def working_on = Util.next_id ();
    def done = Util.next_id ();

    def maybe_f (ti : TypeBuilder) {
      if (ti.phase == done) ()
      else if (ti.phase == working_on)
        Message.error(ti.loc, "type definition for `" + ti.FullName + "' is cyclic")
      else {
        ti.phase = working_on;
        Util.locate (ti.loc, {
          List.Iter (ti.iterate_first, maybe_f);
          f (ti)
        });
        ti.phase = done
      }
    }

    List.Iter (builders, maybe_f)
  }

  /**
   * Iterate over all types defined in source code.
   *
   * Supertypes are always processed before subtypes otherwise
   * source code order is retained.
   */
  public static Iter (f : TypeBuilder -> void) : void
  {
    Iter (List.Rev (infos), f);
  }

  public static IterConditionally (f : TypeBuilder -> void, cond : TypeBuilder -> bool) : void {
    Iter (List.Filter (infos, cond), f);
  }

  /**
   * Iterate over top level types in source code order.
   */
  public static SourceTopIter (f : TypeBuilder -> void) : void
  {
    foreach (x : TypeBuilder in List.Rev (infos))
      when (x.enclosing_type matches None)
        Util.locate (x.loc, f (x))
  }

  /**
   * Iterate over top level types in inheritance order.
   */
  public static TopIter (f : TypeBuilder -> void) : void
  {
    def wrap (x : TypeBuilder) : void {
      when (x.enclosing_type matches None) 
        Util.locate (x.loc, f (x))
    };
    Iter (wrap);
  }

  /**
   * Main function of type declaration handling pass.
   *
   * <remarks>
   *   - constructing typing environments [TypeBuilder.make_tyenvs]
   *   - binding types [TypeBuilder.bind_types]
   *   - determining subtyping relations [TypeBuilder.determine_subtyping]
   *   - checking subtyping constraints on types that are already bound
   *     [TypeBuilder.check_bound_types]
   *   - adding members [TypeBuilder.add_members]
   *   - adding the variant/variant option special matching methods
   * </remarks>
   */
  public static Run () : void
  {
    foreach (x : TypeBuilder in List.Rev (infos))
      Util.locate (x.loc, x.process_macro_attributes (MacroPhase.BeforeInheritance));

    run_phase = 1;
    SourceTopIter (fun (x : TypeBuilder) { 
                      x.make_tyenvs () 
                    });
    
    run_phase = 2;

    foreach (x : TypeBuilder in infos)
      Util.locate (x.loc, x.bind_types ());

    // add the _N_GetVariantCode methods to variants and variant options
    Iter (fun (x : TypeBuilder) { x.add_special_variant_methods () });
    
    run_phase = 3;
    determine_subtyping ();
    
    run_phase = 4;
    Iter (fun (x : TypeBuilder) { x.check_bound_types () });

    run_phase = 5;
    
    Iter (fun (x : TypeBuilder) { x.process_macro_attributes (MacroPhase.BeforeTypedMembers) });

    Iter (fun (x : TypeBuilder) { x.add_members () });

    Iter (fun (x : TypeBuilder) { x.process_macro_attributes (MacroPhase.WithTypedMembers) });

    // add constant object constructors for constant variant options
    Iter (fun (x : TypeBuilder) { x.add_constant_variant_ctors () });

    // propagate the SpecialName attribute if needed
    Iter (fun (x : TypeBuilder) { 
      when (x.Attributes %&& NemerleAttributes.SpecialName)
        x.mark_members_with_special_name ()
    });
    
    def check_method_implements (ti : TypeBuilder) {
      unless (ti.IsInterface) ti.resolve_method_implements ();
    };

    Iter (check_method_implements);

    Iter (fun (x : TypeBuilder) { x.check_ctor_constraints () });
  }


  /* ---------------------------------------------------------------------- */
  /* -- VALIDITY CHECKS --------------------------------------------------- */
  /* ---------------------------------------------------------------------- */

  /**
      Check if types that are already bound are correctly applied.
      Check accessibility.
   */
  check_bound_types () : void
  {
    def check_type (t) {
      | TType.ByRef (t) => check_type (t)
      | TType.Out (t) => check_type (t)
      | TType.Array (t, _) => check_type (t)
      | TType.Function (ts, t) => check_type (ts); check_type (t)
      | TType.Void => ()
      | TType.Product (ts) => List.Iter (ts, check_type)
      | TType.Variable => ()
      | TType.Class (ti, args) =>
        List.Iter (args, check_type);
        _ = ti.MakeSubst (args);
    };

    // check accessibility of type we are aliasing
    match (tydecl) {
      | TypeDeclaration.Alias (t) =>
        Tyutil.CheckAccessibility (this, accessibility, t);
        check_type (t);
      | _ => ()
    };

    // types we are deriving from should be at least as accessible as we
    foreach (deriv_t : TType.Class in GetDirectSuperTypes ()) {
      def is_iface = deriv_t.tycon.IsInterface;

      // access check with exception of interfaces derived / implemented by class
      // which case is not mentioned by http://www.jaggersoft.com/csharp_standard/10.5.4.htm
      when (this.IsInterface || !is_iface)
        Tyutil.CheckAccessibility (this, accessibility, deriv_t);
      check_type (deriv_t);
    }
    
    foreach (tv in typarms)
      foreach (t in tv.GetConstraints ()) {
        Tyutil.CheckAccessibility (this, accessibility, t);
        check_type (t);
      }
  }

  /** Called at the end of the finialization. */
  internal static CheckFinalization () : void
  {
    Iter (fun (x : TypeBuilder) {
      when (x.type_builder != null)
        Message.fatal_error ($ "the type $(x) was not finalized, forgot the "
                               "TypeBuilder.Compile () on it?")
    });
  }

  check_ctor_constraints () : void
  {
    def check_ctors (ty : TypeInfo) {
      def check_ctor (member : IMember, acc) {
        match (member.GetKind ()) {
          | MemberKind.Method (meth) when meth.DeclaringType.Equals (ty) =>
            match (meth.GetFunKind ()) {
              | FunKind.Constructor =>
                def is_default = List.IsEmpty (meth.GetHeader ().parms);
                match (acc) {
                  | (true, _) => (true, true)
                  | _ => (is_default, true)
                }
              | _ => acc
            }
          | _ => acc
        }
      };

      List.FoldLeft (ty.GetMembers (), (false, false), check_ctor)
    };

    match (parent_type) {
      | Some (parent) =>
        def (_, has_ctor) = check_ctors (this);
        def (par_has_default, par_has_ctor) = check_ctors (parent.tycon);
        when (!has_ctor && !par_has_default && par_has_ctor)
          Message.error ("the type `" + FullName + 
                         "' has no constructors and the parent type `" + 
                         parent.tycon.FullName + "' has no default constructor")
      | _ => ()
    }
  }
  
  /**
   * This method iterates through all the known type builders,
   * looking for unused global symbols.
   */
  internal static CheckForUnusedGlobalSymbols () : void
  {
    when (Options.GlobalUnusedSymbolsWarnings)
      Iter (check_for_unused_global_symbols)
  }

  /*
   * This method emits the warnings about unused global symbols.
   */
  private static check_for_unused_global_symbols (tb : TypeBuilder) : void
  {
    unless (tb.IsDelegate)
    {
      def is_variant = !(tb.variant_options matches []);
      
      // first, check if this type has ever been referenced
      when (!(tb.HasBeenUsed || is_variant || tb.IsAlias))
        Message.warning (tb.loc, $ "`$(tb)' is not externally visible and has never been referenced");

      // then, proceed with the members of this type
      foreach (member : IMember in tb.member_list)
        when (!(member.HasBeenUsed || (member is TypeInfo) || (is_variant && member.Name == ".ctor")))
        {
          Message.warning (member.Location,
                           $"$member is not externally visible and has never been referenced")
        }
    }
  }

  /**
   * Checks for abstract method in non-abstract class errors.
   * Marks abstract declaration/implementation pairs as used.
   *
   * FIXME: we should store information about abstract overrides
   *        the same way we store information about interfaces,
   *        this way this code would be linear instead of n^2
   */
  check_abstract () : void
  {
    def override_methods = Hashtable (30);
    def type_members = GetMembers ();

    // first, check for the abstract method/non-abstract class errors
    foreach (m : IMember in type_members)
      match (m.GetKind ()) {
        | MemberKind.Method when m.Attributes %&& NemerleAttributes.Abstract =>
          unless (Attributes %&& NemerleAttributes.Abstract)
          {
            attributes |= NemerleAttributes.Abstract;
            Message.error ($"$m is abstract, but the parent class `$(FullName)' is not");
          }
            
        | _ => ()
      }

    // find all the `override' methods in this type
    foreach (m : IMember in type_members)
      match (m.GetKind ()) {
        | MemberKind.Method when m.Attributes %&& NemerleAttributes.Override =>
          def previous_methods =
            match (override_methods.Get (m.Name)) {
              | Some (methods) => methods
              | _ => []
            }
            
          override_methods.Set (m.Name, (m :> IMethod) :: previous_methods);
          m.HasBeenUsed = true
    
        | _ => ()
      }

    // then, mark abstract declaration/implementation pair as used
    def walk_hierarchy (tycon : TypeInfo)
    {
      // FIXME: this should be defined on Fun_header -- IsCompatible () (?)
      def fun_parms_agree (abstract_parms : list [Fun_parm], impl_parms : list [Fun_parm])
      {          
        | ([], []) => true
          
        | (abstract_parm :: rest_abstract_parms, impl_parm :: rest_impl_parms) =>
          abstract_parm.name == impl_parm.name &&
          Tyutil.types_eq (abstract_parm.ty, impl_parm.ty) &&
          fun_parms_agree (rest_abstract_parms, rest_impl_parms)
          
        | _ => false
      }
      
      override_methods.Iter (fun (name : string, meths : list [IMethod]) {
        foreach (meth : IMethod in meths) 
        {
          def meth_parms = meth.GetHeader ().parms;
        
          def possible_abstract_meths =
            List.Filter (tycon.LookupMember (name), fun (mem : IMember) {            
              mem.Attributes %&& NemerleAttributes.Abstract
            });

          foreach (abstract_meth : IMember in possible_abstract_meths) {
            def abstract_meth = abstract_meth :> IMethod;

            when (fun_parms_agree (abstract_meth.GetHeader ().parms, meth_parms)) {
              abstract_meth.HasBeenUsed = true;
              meth.HasBeenUsed = true
            }
          }
        }
      })
    }
    and recurse (supertypes : list [TType.Class])
    {
      | ty :: rest =>
        walk_hierarchy (ty.tycon);
        recurse (rest)

      | [] => ()
    }

    recurse (GetDirectSuperTypes ())
  }

  /**
   * Performs access attributes related checks. Returns an optional
   * description of the problem.
   */
  internal static CheckAccessAttributes (attrs : NemerleAttributes) : option [string]
  {
    def access_attrs_count =
      (if (attrs %&& NemerleAttributes.Public)    1 else 0) +
      (if (attrs %&& NemerleAttributes.Internal)  1 else 0) +
      (if (attrs %&& NemerleAttributes.Protected) 1 else 0) +
      (if (attrs %&& NemerleAttributes.Private)   1 else 0);

    def is_protected_internal =
      attrs %&& NemerleAttributes.Internal &&
      attrs %&& NemerleAttributes.Protected &&
      access_attrs_count == 2;
       
    if (access_attrs_count <= 1 || is_protected_internal)
      None ()
    else
      Some ("inconsistent access attributes specified")
  }
  
  /**
   * Performs attributes checks for type definitions.
   */
  internal CheckTypeAttributes () : void
  {
    def title () {
      if (IsInterface) "interface" else (if (IsStruct) "struct" else "type");
    }
        
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {      
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for " + title () + ": " + FullName)
    }
    
    check_for_invalid_attr (NemerleAttributes.Virtual, "virtual");
    check_for_invalid_attr (NemerleAttributes.Override, "override");
    check_for_invalid_attr (NemerleAttributes.Mutable, "mutable");
    check_for_invalid_attr (NemerleAttributes.Volatile, "volatile");

    // some extra checks for structs and interfaces
    when (this.IsInterface || this.IsStruct)
    {
      check_for_invalid_attr (NemerleAttributes.Abstract, "abstract");
      check_for_invalid_attr (NemerleAttributes.Sealed, "sealed");
      check_for_invalid_attr (NemerleAttributes.Macro, "macro")
    }
    
    // some extra checks for interfaces
    when (this.IsInterface)
    {
      check_for_invalid_attr (NemerleAttributes.Struct, "struct")
    }
    
    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for type: " + FullName)
      | _ => ()
    }

    def type_is_top_level = enclosing_type matches None;
    
    // top-level classes can only be public or internal
    when (type_is_top_level && accessibility != Accessibility.Public &&
          accessibility != Accessibility.Internal)
      Message.fatal_error (loc, "top level " + title () + "s are only allowed to be public or internal: " +
                           FullName);

    // top-level classes are not allowed to be `new'
    def type_is_new =
      attributes %&& NemerleAttributes.New;
      
    when (type_is_top_level && type_is_new)
      Message.fatal_error (loc, "only nested " + title () +"s are allowed to `new': " + FullName);

    // types cannot be abstract and sealed at the same time
    when (IsAbstract && IsSealed)
      Message.fatal_error (loc, title () + "s are not allowed to be abstract and sealed at the same time: " +
                           FullName)
  }
}

} // ns
