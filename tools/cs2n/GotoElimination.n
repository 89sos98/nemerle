// Copyright (c) 2003-2005 The University of Wroclaw.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. The name of the University may not be used to endorse or promote
//       products derived from this software without specific prior
//       written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
// NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

#if GOTO_ELIMINATION

using Nemerle.Collections;

namespace Nemerle.CSharp
{
    public partial variant STree
    {
	internal divide_block_into_when_sections () : list [STree]
	{
	    def make_when_section (statements) : STree
	    {
		def whitespaces = get_first_whitespace (statements);
		def block = Statement("BLOCK", Tok(ExtendedToken(whitespaces,"{")) :: statements 
					+ [Tok(ExtendedToken(whitespaces , "}"))]);
		Statement("WHEN",Tok(ExtendedToken(whitespaces,"when")) ::
				 TokS("(") :: TokS("true") :: TokS(")") :: [block])
	    }
	    
	    def walk (statements, acc1 : list[STree], acc2 : list[STree]) : list [STree]
	    {
		match(statements)
		{
		    | [] => 
			if(acc1 matches [])
			    List.Rev ( acc2 )
			else
			    List.Rev ( make_when_section (List.Rev (acc1)) :: acc2 )
		    | (Statement("LABEL", _ ) as goto_related_statement) :: tail 
		    | (Statement("GOTO", _ ) as goto_related_statement) :: tail =>
			def when1 = 
			if(acc1 matches [])
			    []
			else
			    [make_when_section (List.Rev (acc1) )];

			def when2 = make_when_section ([goto_related_statement]);

			walk (tail, [] , when2 :: when1 + acc2) 
			
		    | head :: tail =>
			walk(tail , head :: acc1 , acc2)
		}
	    }

	    def (_,sts,_) = 
	    match(this)
	    {
		| Statement("BLOCK",xs)	=> cut_off_braces (xs);
		| _ => assert (false);
	    }

	    walk (sts, [] , []) 
	}

	private get_first_whitespace (tree_list : list[STree]) : string
	{
	    | [] => ""
	    | head :: _ => get_first_whitespace (head)
	}	

	private new_goto_symbol () : string
        {
            new_symbol ("_return_")
        }	
    }
}

#endif
