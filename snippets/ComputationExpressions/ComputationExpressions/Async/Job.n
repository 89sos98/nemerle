using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.ComputationExpressions.Async
{
  public abstract class AsyncJobBase
  {
    public module JobState
    {
      public Ready         = 0;
      public SwitchContext = 1;
      public Wait          = 2;
      public Canceled      = 3;
    }

    public this()
    {
      Threading.Thread.VolatileWrite(ref _state, JobState.Ready);
    }

#pragma warning disable 649  // _state is initialized in ctor

    mutable _state : int; // volatile modifier don't work in current release

#pragma warning restore

    public State : int {
      get { Threading.Thread.VolatileRead(ref _state) }
      set
      {
        def set_state(newState)
        {
          def state = State; // volatile access
          when (state != JobState.Canceled && state != newState)
          {
            def prevState = Threading.Interlocked.CompareExchange(ref _state, newState, state);
            when (prevState != state)
              set_state(newState);
          }
        }
        set_state(value);
      }
    }

    public ExecutionContext : ExecutionContext { get; set; }

    public Cancel() : void
    {
      State = JobState.Canceled;
      Start();
    }

    public IsReady : bool
    {
      get { State == JobState.Ready }
    }

    public ExecWhileReady[A](mutable async : Async[A], res : ref A) : Async[A]
    {
      while (State == JobState.Ready && async != null)
        async = async.Exec(this, ref res);
      async;
    }

    public abstract Start() : void;

    internal mutable NextJob : AsyncJobBase = null;
  }

  internal class AsyncJob[A] : AsyncJobBase
  {
    private mutable async : Async[A];

    [Accessor]
    private result : AsyncPromise[A] = AsyncPromise();
    public RunCache : void -> void;

    public this(executionContext : ExecutionContext, async : Async[A])
    {
      this.async = async;
      ExecutionContext = executionContext;
      RunCache = Run;
    }

    public override Start() : void
    {
      ExecutionContext.Execute(RunCache);
    }

    private syncRoot : object = object();
    private Run() : void
    {
      lock (syncRoot)
      {
        mutable res;
        State = JobState.Ready;
        try
        {
          async = ExecWhileReady(async, ref res);
        }
        catch
        {
          | ex is Exception =>
            result.SetException(ex);
            return;
        }
        match (State)
        {
          | JobState.Ready         =>
            assert2(async == null);
            result.SetValue(res);

          | JobState.SwitchContext => Start();
          | JobState.Wait          => ()
          | JobState.Canceled      =>
            result.SetResult(AsyncResult.Canceled());
            when (async != null)
            {
              async.Cancel();
              async = null;
            }

          | _ =>
            throw NotImplementedException();
        }
      }
    }
  }
}
