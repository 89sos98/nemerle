using System;
using System.Globalization;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Extensions;
using Nemerle.Utility;

namespace LRPEGCC
{

  [StructuralHashCode, StructuralEquality]
  public class RangeSet
  {
    public variant Range
    {
      [StructuralHashCode, StructuralEquality]
      | Plain {
        from : char;
        to : char;

        public override ToString() : string
        {
          def esc(ch)
          {
            | '\0' => @"'\0'"
            | '\t' => @"'\t'"
            | '\n' => @"'\n'"
            | '\r' => @"'\r'"
            | '\\' => @"'\\'"
            | '\'' => @"'\''"
            | x when x == char.MaxValue  => @" char.MaxValue"
            | c when char.IsLetter(c)
            | c when char.IsDigit(c)
            | c when char.IsPunctuation(c)
            | c when char.IsSeparator(c)
            | c when char.IsSymbol(c)      => $"'$c'"
            | c =>
              def c = c : uint;
              string.Format(<#'\u{0,4:X}'#>, c).Replace(' ', '0');
          }
  
          if (from == to) esc(from)
          else            esc(from) + ".." + esc(to)
        }
      }

      [StructuralHashCode, StructuralEquality]
      | UnicodeClass {
        category : UnicodeCategory;
        inverted : bool;

        public override ToString() : string {
          UnicodeCategoryTable.UnicodeCategoryToStr(category)
        }
      }
    }

    [Accessor]
    private _ranges : list[Range] = [];

    public this()
    {}

    private this(ranges : list[Range])
    {
      _ranges = ranges;
    }

    public AddRange(from : char, to : char) : RangeSet
    {
      AddRange(Range.Plain(from, to));
    }

    public AddRange(category : UnicodeCategory) : RangeSet
    {
      AddRange(Range.UnicodeClass(category, false));
    }

    public AddRange(range : Range) : RangeSet
    {
      match(range)
      {
      | Range.Plain as range =>
        unless (range.from <= range.to)
          throw ArgumentException();

        def add(ranges, range)
        {
          match (ranges)
          {
          | [] => [range];
          | (firstRange is Range.Plain) :: ranges =>
            if (firstRange.to + 1 < range.from)
              firstRange :: add(ranges, range);
            else if (range.to + 1 < firstRange.from)
              range :: firstRange :: ranges;
            else
              add(ranges, Range.Plain(Math.Min(range.from, firstRange.from) :> char, Math.Max(range.to, firstRange.to) :> char));
          | firstRange :: ranges =>
            firstRange :: add(ranges, range)
          }
        }
        RangeSet(add(_ranges, range))

      | Range.UnicodeClass as range =>
        def add(ranges)
        {
          match (ranges)
          {
          | [] => [range];
          | (firstRange is Range.UnicodeClass) :: ranges =>
            if(firstRange.category == range.category)
              if(firstRange.inverted == range.inverted)
                firstRange :: ranges
              else
                ranges
            else
              firstRange :: add(ranges)
          | firstRange :: ranges =>
            firstRange :: add(ranges)
          }
        }
        RangeSet(add(_ranges))
      }
    }

    public RemoveRange(from : char, to : char) : RangeSet
    {
      RemoveRange(Range.Plain(from, to));
    }

    public RemoveRange(range : Range) : RangeSet
    {
      match(range)
      {
      | Range.Plain as range =>
        unless (range.from <= range.to)
          throw ArgumentException();

        def remove(ranges)
        {
          match (ranges)
          {
          | [] => [];
          | (firstRange is Range.Plain) :: ranges =>
            if (firstRange.to < range.from)
            {
              firstRange :: remove(ranges);
            }
            else if (firstRange.from > range.to)
            {
              firstRange :: ranges;
            }
            else
            {
              def cat(from : int, to : int, ranges)
              {
                if (from <= to)
                  Range.Plain(from :> char, to :> char) :: ranges;
                else
                  ranges;
              }
              def lo = firstRange.from <= range.from;
              def hi = firstRange.to >= range.to;
              if (lo)
              {
                if (hi)
                {
                  cat(firstRange.from, range.from - 1, cat(range.to + 1, firstRange.to, ranges))
                }
                else
                {
                  cat(firstRange.from, range.from - 1, remove(ranges))
                }
              }
              else
              {
                if (hi)
                {
                  cat(range.to + 1, firstRange.to, ranges)
                }
                else
                {
                  remove(ranges);
                }
              }
            }
          | firstRange :: ranges =>
            firstRange :: remove(ranges)
          }
        }
        RangeSet(remove(_ranges))

      | Range.UnicodeClass as range =>
        def remove(ranges)
        {
          match (ranges)
          {
          | [] => [Range.UnicodeClass(range.category, !range.inverted)]
          | (firstRange is Range.UnicodeClass) :: ranges =>
            if(firstRange.category == range.category)
              if(firstRange.inverted == range.inverted)
                ranges
              else
                firstRange :: ranges
            else
              firstRange :: remove(ranges)
          | firstRange :: ranges =>
            firstRange :: remove(ranges)
          }
        }
        RangeSet(remove(_ranges))
      }
    }

    public Sum(that : RangeSet) : RangeSet
    {
      Ranges.Fold(that, (range, that) => that.AddRange(range));
    }

    public Sub(that : RangeSet) : RangeSet
    {
      that.Ranges.Fold(this, (range, rangeSet) => rangeSet.RemoveRange(range));
    }

    public Invert() : RangeSet
    {
      RangeSet([Range.Plain(char.MinValue, char.MaxValue)]).Sub(this)
    }

    public override ToString() : string { $"..$_ranges" }
  }
}
