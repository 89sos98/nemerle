(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)


(* TYPE DEFINITION *)
public variant list ('a) 
{
  | Cons { hd : 'a; tl : list ('a); }
  | Nil {}
}
	     
public module List
{
  (* CONVERSION OPERATIONS *)

  (**
   * Converts an array into a list
   *)  
  public 'a from_array (x : array ('a)) : list ('a) {
  
    def array_length = (x : System.Array).Length;
    
    def loop (index : int) : list ('a) {
    
      if (index < array_length)
        x [index] :: loop (index + 1)
      else
        []
    };
    
    loop (0)
  }


  (* BASIC LIST OPERATIONS *)
  
  public 'a length (x : list ('a)) : int {
    def loop (acc : int, x : list ('a)) : int {
      match (x) {
	      | _ :: xs => loop (acc + 1, xs)
	      | _ => acc
	    }
    };
    loop (0, x);
  }
    
    
    public 'a head (l : list ('a)) : 'a {
      match (l) {
        | x :: _ => x
        | [] => raise Invalid_argument ("List.head")
      }
    }
    
    public 'a hd (l : list ('a)) : 'a {
      head (l)
    }
    
    public 'a tail (l : list ('a)) : list ('a) {
      match (l) {
	| _ :: tl => tl
	| [] => raise Invalid_argument ("List.tail")
      }
    }
    
    public 'a tl (l : list ('a)) : list ('a) {
      tail (l)
    }
    
    public 'a nth (l : list ('a), n : int) : 'a {
      match (l) {
	| h :: t => 
	    if ( n == 0 )
	      h
	    else
	      nth(t, n-1)
        | [] => raise Invalid_argument ("List.nth")
      }
    }

    public 'a last (l : list ('a)) : 'a {
      match (l) {
        | [x] => x
        | _ :: xs => last (xs)
        | [] => raise Invalid_argument ("List.last")
      }
    }
    
    public 'a rev (l : list ('a)) : list ('a) {
      def loop (acc : list ('a), l : list ('a)) : list ('a) {
        match (l) {
          | x :: xs => loop (x :: acc, xs)
          | [] => acc
        }
      };
      loop ([], l);
    }
    
    public 'a append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
        | [] => y
        | x :: xs => x :: append (xs, y)
      }
    }
    
    public 'a rev_append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
      	| h :: t => rev_append(t, h :: y)
	| [] => y
      }
    }
    
    public 'a concat (l : list (list ('a))) : list ('a) {
      fold_left(append, [], rev(l))
    }    

    public 'a flatten (l : list (list ('a))) : list ('a) {
      concat(l)
    }


    (* ITERATORS *)


    public 'a iter (f : 'a -> void, l : list ('a)) : void {
      match (l) {
        | x :: xs => f (x); iter (f, xs)
        | [] => ()
      }
    }

    public 'a, 'b map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      match (x) {
        | [] => []
        | x :: xs => f (x) :: map (f, xs)
      }
    }

    public 'a, 'b rev_map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      def loop (acc : list ('b), x : list ('a)) : list ('b) {
      	match (x) {
	  | h :: t => loop (f (h) :: acc, t)
	  | [] => acc
	}
      };
      loop ([], x)
    }

    public 'a, 'b fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b {
      match (l) {
        | [] => acc
        | x :: xs => fold_left (f, f (acc, x), xs)
      }
    }

    public 'a, 'b fold_right (f : 'a * 'b -> 'b, l : list ('a), b : 'b) : 'b {
      match (l) {
	| [] => b
	| x :: xs => f (x, fold_right (f, xs, b))
      }
    }
    

    (* ITERATORS ON TWO LISTS *)
    

    public 'a, 'b iter2 (f : 'a  * 'b -> void, a : list ('a), b : list ('b)) : void {
      match ((a, b)) {
        | ([], []) => ()
        | (x :: xs, y :: ys) => f (x, y); iter2 (f, xs, ys)
        | _ => raise Invalid_argument("List.iter2")
      }
    }

    public 'a, 'b, 'c map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      match ((x, y)) {
        | ([], []) => []
        | (x :: xs, y :: ys) => f (x, y) :: map2 (f, xs, ys)
        | _ => raise Invalid_argument("List.map2")
      }
    }

    public 'a, 'b, 'c rev_map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      def loop (acc : list ('c), x : list ('a), y : list ('b)) : list ('c) {
      	match ((x, y)) {
          | ([], []) => []
          | (x :: xs, y :: ys) => loop (f (x, y) :: acc, xs, ys)
          | _ => raise Invalid_argument("List.rev_map2")
      	}
      };
      loop([], x, y)
    }

    public 'a, 'b, 'c fold_left2 (f : 'c * 'a  * 'b -> 'c, acc : 'c, a : list ('a), b : list ('b)) : 'c {
      match ((a, b)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => fold_left2 (f, f (acc, x, y), xs, ys)
        | _ => raise Invalid_argument("List.fold_left2")
      }
    }

    public 'a, 'b, 'c fold_right2 (f : 'a * 'b  * 'c -> 'c, a : list ('a), b : list ('b), c : 'c) : 'c {
      match ((a, b)) {
        | ([], []) => c
        | (x :: xs, y :: ys) => f (x, y, fold_right2 (f, xs, ys, c))
        | _ => raise Invalid_argument("List.fold_right2")
      }
    }


    (* LIST SCANNING *)


    public 'a forall (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | x :: xs => f (x) && forall (f, xs)
        | [] => true
      }
    }

    public 'a for_all (f : 'a -> bool, l : list ('a)) : bool {
      forall(f, l)
    }

    public 'a exists (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | [] => false
        | h :: t => f (h) || exists (f, t)
      }
    }

    public 'a, 'b forall2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a, b)) {
        | ([], []) => true
        | (x :: xs, y :: ys) => f (x, y) && forall2 (f, xs, ys)
        | _ => raise Invalid_argument("List.forall2")
      }
    }

    public 'a, 'b for_all2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      forall2(f,a,b)
    }

    public 'a, 'b exists2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a,b)) {
        | ([], []) => false
        | (x :: xs, y :: ys) => f(x,y) || exists2(f,xs,ys)
        | _ => raise Invalid_argument ("List.exists2")
      }
    }

    // FIXME: we don't have mem, as == is physical equality
    public 'a memq (a : 'a, l : list ('a)) : bool {
      match (l) {
	| h :: t  => h == a || memq (a,t)
	| [] => false
      }
    }

    
    (* LIST SEARCHING *)
    
    
    public 'a find (pred : 'a -> bool, l : list ('a)) : 'a {
      match (l) {
      	| h :: t => if ( pred(h) ) h else find (pred, t)
	| [] => raise Not_found ()
      }
    }

    public 'a filter (f : 'a -> bool, l : list ('a)) : list ('a) {
      match (l) {
        | x :: xs =>
          if (f (x)) x :: filter (f, xs)
          else filter (f, xs)
        | [] => []
      }
    }

    public 'a find_all (f : 'a -> bool, l : list ('a)) : list ('a) {
      filter(f, l)
    }

    public 'a partition ( pred : 'a -> bool, l : list ('a)) : list ('a) * list ('a) {
      def loop (l : list ('a), sat : list ('a), notsat : list ('a)) 
            : list ('a) * list ('a) 
	{
      	  match (l) {
	    | h :: t => 
	        if ( pred (h) ) 
		  loop (t, h :: sat, notsat)
		else 
		  loop (t, sat, h :: notsat)
	    | [] => (rev(sat),rev(notsat))
	  }
      	};
      loop(l,[],[])	
    }


    (* ASSOCIATION LISTS *)
    
    // FIXME: == is physical equality
    public 'a, 'b assoc (key : 'a, l : list ('a * 'b)) : 'b {
      match (l) {
      	| (k,v) :: t =>
	    if ( key == k )
	      v
	    else
	      assoc (key,t)
	| [] => raise Not_found ()
      }
    }

    public 'a, 'b mem_assoc (key : 'a, l : list ('a * 'b)) : bool {
      match (l) {
      	| (k,v) :: t =>
	    if ( key == k )
	      true
	    else
	      mem_assoc (key,t)
	| [] => false
      }
    }

    public 'a, 'b remove_assoc (key : 'a, l : list ('a * 'b)) : list ('a * 'b) {
      def loop (acc : list ('a * 'b), l : list ('a * 'b)) : list ('a * 'b)
	{
	  match (l) {
	    | (k,v) :: t => 
	        if ( key == k )
	          loop (acc,t)
	        else
	          loop ((k,v) :: acc,t)
	    | [] => rev(acc)
	  }
      	};
      loop([],l)	
    }


    (* LISTS OF PAIRS *)

    
    public 'a, 'b split(l : list ('a * 'b)) : list ('a) * list ('b) {
      def loop (acc1 : list ('a), acc2 : list ('b), l : list ('a * 'b)) : list ('a) * list ('b) 
      	{
	  match (l) {
	    | (a,b) :: t => loop(a :: acc1, b :: acc2, t)
	    | [] => (rev(acc1), rev(acc2))
	  }
      	};
      loop([], [], l)
    }

    public 'a, 'b combine(a : list ('a), b : list ('b)) : list ('a * 'b) {
      def loop (acc : list ('a * 'b), a : list ('a), b : list ('b)) : list ('a * 'b) 
	{
      	  match ((a,b)) {
	    | (x :: xs, y :: ys) => loop((x, y) :: acc, xs, ys)
	    | ([],[]) => rev(acc)
	    | _ => raise Invalid_argument("List.combine")
      	  }
      	};
      loop([],a,b)
    }

    (* SORTING *)
  
    'a mergesort(cmp : ('a * 'a) -> int, l : list ('a)) : list ('a) {
      def split (l : list ('a)) : (list ('a) * list ('a)) {
      	def aux (l : list ('a), acc : list ('a), n : int) : (list ('a) * list ('a)) {
	  if ( n == 0 ) 
	    (List.rev (acc),l)
	  else 
	    match (l) {
	      | Nil => aux (l,acc,0)
	      | Cons(x,xs) => aux (xs,Cons(x,acc),(n-1))
	    }
	};
	aux (l,Nil(),(List.length (l) / 2))
      };
      def merge (cmp : ('a * 'a) -> int, l1 : list ('a), l2 : list ('a)) : list ('a) {
	def aux (l1 : list ('a), l2 : list ('a), acc : list ('a)) : list ('a) {
      	  match ((l1,l2)) {
	    | (Nil,_) => List.append(List.rev(acc),l2)
	    | (_,Nil) => List.append(List.rev(acc),l1)
	    | (Cons(x,xs),Cons(y,ys)) => 
	       if ( cmp(x,y) > 0 )
 	         aux(xs,Cons(y,ys),Cons(x,acc))
	       else
	         aux(Cons(x,xs),ys,Cons(y,acc))
	  }
	};
	aux(l1,l2,Nil())
      };
      match (l) {
      	| Nil => l
	| Cons(x,Nil) => l
	| _ =>
	    match (split(l)) {
	      | (l1,l2) => merge(cmp,mergesort(cmp,l1),mergesort(cmp,l2))
	    }
      }
    }

    'a sort (cmp : ('a * 'a) -> int, l : list ('a)) : list ('a) {
      mergesort(cmp,l)
    }

  } (* end of module List *)
