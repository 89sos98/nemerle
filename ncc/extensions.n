(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler.Extensions;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Extensions {

  public implicit_ctor (par : Tyinfo) : list (Class_member) {
    def collect (acc : list (PT.Expr) * list (Fun_parm), decl : Class_member) 
                : list (PT.Expr) * list (Fun_parm)
      {
        match (decl) {
          | M_field (t, _) =>
            def n = decl.name;
            def fp = Fun_parm (loc = par.loc, name = n, ty = t, decl = null);
            def ex = PT.E_assign (PT.E_member (PT.E_this (), PT.SS_string (n)), 
                                  PT.E_ref (n));
            def (es, ps) = acc;
            (ex :: es, fp :: ps)
          | _ => acc
        }
      };

    def make_ctor (base_ctor : Decl) {
      def (ctor_parms, base_call) =
        if (base_ctor == null) ([], PT.E_literal (L_void ()))
        else
          match (base_ctor.kind) {
            | D_class_member (M_function {header = {parms = pp}}) =>
              def callparms = List.map (fun (fp : Fun_parm) { PT.Parm (PT.E_ref (fp.name)) }, pp);
              (List.map (fun (fp : Fun_parm) {
                           Fun_parm (loc = par.loc, name = fp.name, 
                                     ty = fp.ty, decl = null)
                         }, pp),
               PT.E_call (PT.E_base (), callparms))
            | _ => Util.ice ()
          };
        
      
      def (assigns, parms) = List.fold_left (collect, ([], []), par.member_list);
      def fh = Fun_header (loc = par.loc, 
                           name = ".ctor", 
                           id = Util.next_id (),
                           ret_type = T_void (), 
                           parms = List.append (ctor_parms, List.rev (parms)),
                           typarms = [],
                           tenv = par.tenv,
                           closure_vars = []);
      def body = PT.E_sequence (base_call :: assigns);
      body.loc <- par.loc;
      def f = M_function (fh, FK_ctor (), FB_parsed_expr (body));
      f.modifiers <- [Mod_public ()];
      f.name <- fh.name;
      f.loc <- fh.loc;
      f.id <- fh.id;
      f
    };
      
    match (par.superclass ()) {
      | Some (baseti) =>
        def decls = par.env.bare_lookup (baseti.fullname () + "..ctor");
        def is_ctor (d : Decl) {
          match (d.kind) {
            | D_class_member (M_function (_, FK_ctor, _)) => true
            | _ => false
          }
        };
        match (List.filter (is_ctor, decls)) {
          | [] => 
            match (baseti.tydecl) {
              | TD_variant => [make_ctor (null)]
              | _ =>
                Message.fatal_error ("type `" + baseti.fullname () + "' (base of `" + 
                                     par.fullname () + "') has no constructors, cannot " +
                                     "generate default constructor")
            }
          | decls =>
            List.map (make_ctor, decls)
        }
      | None =>
        [make_ctor (null)]
    }
  }

  get_params (pa : list (PT.Parm)) : list (PT.Expr)
    {
      def get_parm (p : PT.Parm) : PT.Expr { p.expr };
      List.map (get_parm, pa)
    }

  
  (* HARD WRITTEN MACROS SECTION ***************************************)

  (** this macro provides convenient way to write simple while loop,
      which perform execution of [body] parameter as long as
      [condition] is true
      <parm>condition</parm>
      <parm>body</body>
      <remarks>
        macro is registered as _N_while, but parser provides syntax
        shotcut [while (condition) { body }] for using while
      </remarks>
    *)
  private class WhileMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ { def _N_whileloop () : void {
                    if ($cond) { $body; _N_whileloop() } 
                    else () 
                 }; 
                 _N_whileloop (); 
               } ]>

        | _ => 
          Message.fatal_error ("while macro expects two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_while" }
    
    public this () {}
  }

  private class ForMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [body; init; cond; change] =>
            <[ { $init;
                 def _N_forloop () : void {
                    if ($cond) { $body; $change; _N_forloop() } 
                    else () 
                 }; 
                 _N_forloop (); 
               } ]>

        | _ => 
          Util.ice ("'for' has invalid arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_for" }
    
    public this () {}
  }

  (** shortcut for [if (condition) () else body] *)
  private class UnlessMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ if ($cond) () else $body ]>
        | _ => 
          Message.fatal_error ("unless macro expects two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_unless" }
    
    public this () {}
  }

  (** shortcut for [if (condition) body else ()] *)
  private class WhenMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ if ($cond) $body else () ]>
        | _ => 
          Message.fatal_error ("when macro expects two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_when" }
    
    public this () {}
  }

  (** macro providing C# 'using' functionality
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vclrfusingstatement.asp
   *)
  private class UsingMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      def store_exprs (args : list(PT.Parm), acc : list (PT.Expr) * list (PT.Expr)) : 
        list (PT.Expr) * list (PT.Expr)
      {
        def (preexprs, postexprs) = acc;

        match (args) {
          | [] => acc
          | {is_ref = false; name = ""; expr = ex } :: xs =>
            store_exprs (xs, (preexprs, <[ $ex . Dispose () ]> :: postexprs))
          | {is_ref = false; name = str; expr = ex } :: xs =>
            def name = PT.SS_string (str);
            store_exprs (xs, (<[ def $name = $ex ]> :: preexprs, 
                              <[ $(PT.E_ref (str)) . Dispose () ]> :: postexprs))

          | _ => Message.fatal_error ("Invalid parameters in 'using' macro")
        }
      };

      match (args) {
        | {is_ref = false; name = ""; expr = body } :: xs =>
          def (preexps, postexps) = store_exprs (xs, ([], [body]));
          def all_exps = List.append (List.rev (preexps), List.rev (postexps));
          <[ {.. $all_exps } ]>
        | _ =>
          Util.ice ("'using' macro have zero parameters")
      }
    }

    GetName () : string implements IMacro.GetName { "_N_using" }
    
    public this () {}
  }

  private class PrintfMacro implements IMacro 
  {
    public variant FormatToken {
      | Text { body : string; }
      | TextNewline { body : string; }
      | Number
      | Str
      | Chr
    }

    public static parse_format (form : string) : list(FormatToken)
    {
      mutable i <- 0;
      mutable buf <- System.Text.StringBuilder ();
      mutable result <- [];
      def n = form.Length;
      
      while (i < n) { 
        match (form[i]) {
          | '%' =>
            // % occured - first, dump text from buffer
            when ( buf.Length > 0 ) {
              result <- Text (buf.ToString ()) :: result;
              buf <- buf.Remove (0, buf.Length);
            };
            // now analyze next character
            i <- i + 1;
            if ( i < n ) {
              match (form[i]) {
                | 'd' => result <- Number () :: result
                | 'i' => result <- Number () :: result
                | 's' => result <- Str () :: result
                | 'c' => result <- Chr () :: result
                | _ => 
                  Message.error ("Unsupported formatting sequence after % character")
              }
            }
            else
              Message.error ("Unexpected end of format after % character")
          | '\n' =>
            result <- TextNewline (buf.ToString ()) :: result;
            buf <- buf.Remove (0, buf.Length)
          | c =>
            buf <- buf.Append (c)
        };
        i <- i + 1;
      };

      when (buf.Length > 0) { result <- Text (buf.ToString ()) :: result; };

      // the result is reversed, but function using it will reverse it again
      result
    }

    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | PT.E_literal (L_string (format)) :: parms =>
          def make_expressions (toks : list(FormatToken), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.Write ($(PT.E_literal (L_string (t)))) ]> :: acc)
              | (TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.WriteLine ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (Number :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : int)) ]> :: acc)

              | (Str :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : string)) ]> :: acc)

              | (Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : char)) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for printf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for printf macro");
                acc
            }
          };
          
          def seq = make_expressions (parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("printf macro expects formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "printf" }
    
    public this () {}
  }

  public class ScanfMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | PT.E_literal (L_string (format)) :: parms =>
          def make_expressions (toks : list(PrintfMacro.FormatToken), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, <[ Nemerle.Input.CheckInput 
                  ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, <[ Nemerle.Input.CheckInput 
                  ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadInt () ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadString () ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- System.Char.ToChar (System.Console.Read ()) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for scanf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for scanf macro");
                acc
            }
          };
          
          def seq = <[ Nemerle.Input.EatWhiteSpace () ]> ::
            make_expressions (PrintfMacro.parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("scanf macro expects formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "scanf" }
    
    public this () {}
  }

  public class SprintfMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | (PT.E_ref (_)) as target ::
          PT.E_literal (L_string (format)) :: parms =>
          def make_expressions (toks : list(PrintfMacro.FormatToken), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ def _ = _N_sb.Append ($(PT.E_literal (L_string (t)))) ]> :: acc)
              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ def _ = _N_sb.Append ($(PT.E_literal (L_string (t)))) ]> :: 
                  <[ def _ = _N_sb.Append ("\n") ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ def _ = _N_sb.Append (($p : int)) ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ def _ = _N_sb.Append (($p : string)) ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ def _ = _N_sb.Append (($p : char)) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for sprintf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for sprintf macro");
                acc
            }
          };
          
          def seq = <[ def _N_sb = System.Text.StringBuilder () ]> ::
                    make_expressions (PrintfMacro.parse_format (format), List.rev (parms), 
                    [ <[ $target <- _N_sb.ToString () ]> ]);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("sprintf macro expects string variable and formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "sprintf" }
    
    public this () {}
  }

  public class SscanfMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | valstr :: PT.E_literal (L_string (format)) :: parms =>
          def make_expressions (toks : list(PrintfMacro.FormatToken), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, <[ Nemerle.Input.CheckInput 
                  ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, <[ Nemerle.Input.CheckInput 
                  ($(PT.E_literal (L_string (t)))) ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadInt () ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadString () ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- System.Char.ToChar (System.Console.Read ()) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for sscanf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for sscanf macro");
                acc
            }
          };
          
          def seq = <[ def _N_sscanf_str = $valstr ]> ::
                    <[ mutable _N_sscanf_pos <- 0 ]> ::
                    <[ def _N_sscanf_len = _N_sscanf_str.Length ]> ::
                    <[ Nemerle.Input.EatWhiteSpace () ]> ::
            make_expressions (PrintfMacro.parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("sscanf macro expects string and formating string as first arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "sscanf" }
    
    public this () {}
  }

  private class AssertMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond } ] =>             
            <[ if ($cond) () else 
               raise Assertion_failed ($(PT.E_literal (L_string (cond.loc.file))), 
                                       $(PT.E_literal (L_int (cond.loc.line))), "") ]>
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = message } ] =>
            <[ if ($cond) () else 
               raise Assertion_failed ($(PT.E_literal (L_string (cond.loc.file))), 
                                       $(PT.E_literal (L_int (cond.loc.line))), 
                                       $message) ]>
        | _ => 
          Message.fatal_error ("assert macro expects one or two arguments" +
           " (the condition and an optional message)")
      }
    }

    GetName () : string implements IMacro.GetName { "assert" }
    
    public this () {}
  }

  (** MACROS, WHICH WE CAN DO BETTER THAN HASKELL *)

  private class SelectFromTupleMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [ PT.E_literal (L_int (k)); PT.E_literal (L_int (n)); tupl ] =>
          mutable tup <- [];
          for (mutable i <- n; i > 0; i <- i - 1) {
//            def pn = PT.SS_string ("_N_tp" + string_of_int (n - i + 1));
//            tup <- <[ match: $pn (.. []) ]> :: tup;
            tup <- PT.P_variable ("_N_tp" + string_of_int (n - i + 1)) :: tup
          };
          <[ { def (.. $tup) = $tupl;
               $(PT.E_ref ("_N_tp" + string_of_int (k))) } ]>
        | _ => 
          Message.fatal_error ("'selectFromTuple' macro expects three arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "selectFromTuple" }
    
    public this () {}
  }

  private class TupleMapMacro implements IMacro 
  {
    Run (args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [ f; <[ (.. $elms) ]> ] =>
	  def call (e : PT.Expr) : PT.Expr {
	    <[ $f ($e) ]>
 	  };
          def mapped = List.map (call, elms);
	  <[ (.. $mapped) ]>
        | _ => 
          Message.fatal_error ("'tupleMap' macro expects function and tuple")
      }
    }

    GetName () : string implements IMacro.GetName { "tupleMap" }
    
    public this () {}
  }


  /// always register standard macros when compiler starts
  static this () {
    MacroRegistry.register_macro (WhileMacro ());
    MacroRegistry.register_macro (UsingMacro ());
    MacroRegistry.register_macro (WhenMacro ());
    MacroRegistry.register_macro (UnlessMacro ());
    MacroRegistry.register_macro (AssertMacro ());
    MacroRegistry.register_macro (ForMacro ());

    MacroRegistry.register_macro (PrintfMacro ());
    MacroRegistry.register_macro (SprintfMacro ());
    MacroRegistry.register_macro (ScanfMacro ());

    MacroRegistry.register_macro (SelectFromTupleMacro ());
    MacroRegistry.register_macro (TupleMapMacro ());
  }
  
} // end module Extensions
} // end ns

