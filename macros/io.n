/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler; // Message, Macros.NewSymbol
 
using Nemerle.Collections;
using System;
using System.Text.RegularExpressions;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle {
module IO {

  variant FormatToken {
    | Text { body : string; }
    | Number { unsigned : bool; longformat : bool; }
    | NumberFloat { longformat : bool; }
    | Str
    | Chr
  }

  /// parse printf-style formatting string
  /// http://www.gnu.org/software/libc/manual/html_node/Formatted-Output.html#Formatted%20Output
  parse_format (form : string) : list <FormatToken>
  {
    def buf = Text.StringBuilder ();
    mutable result = [];
    mutable i = 0;
    def n = form.Length;
/*    
    def parse_percent () : FormatToken {
      match (form [i]) {
        |

      }
     };
*/
    def append_text () {
      match (result) {
        | Text (t) :: rest =>
            result = Text (t + buf.ToString ()) :: rest
        | _ =>
            result = Text (buf.ToString ()) :: result
      }
      ignore (buf.Remove (0, buf.Length));
    };
    
    while (i < n) { 
      match (form[i]) {
        | '%' =>
          // % occured - first, dump text from buffer
          when ( buf.Length > 0 ) append_text ();

          mutable longform = false;

          def next_char () {
            // now analyze next character
            ++i;

            if ( i < n ) {
              match (form[i]) {
                | 'd' | 'i' => result = Number (false, longform) :: result
                | 'u' => result = Number (true, longform) :: result
                | 'f' => result = NumberFloat (longform) :: result
                | 's' => result = Str () :: result
                | 'c' => result = Chr () :: result
                | '%' => ignore (buf.Append ('%'))
                | 'l' => 
                  if (longform) 
                    Message.error ("`l' in printf-format specified twice")
                  else {
                    longform = true; next_char ();
                  }
                | _ => 
                  Message.error ("Unsupported formatting sequence after % character")
              }
            }
            else
              Message.error ("Unexpected end of format after % character")
          }
          next_char ();

        | c => ignore (buf.Append (c))
      };
      ++i;
    };

    when (buf.Length > 0) append_text ();

    // the result is reversed, but function using it will reverse it again
    result
  }
  
  make_evaluation_exprs (toks : list <FormatToken>, parms : array <PT.Expr>) 
  : list <PT.Expr> * list <PT.Expr>
  {
    def make_expressions (toks, i, acc_eval, acc_ref) {
      def continue (x, xs) {
        def sym = Macros.NewSymbol ();
        make_expressions (xs, i - 1, <[ def $(sym : name) = $x ]> :: acc_eval,
                          <[ $(sym : name) ]> :: acc_ref)
      }

      match (toks) {
        | [] when i == 0 => (acc_eval, acc_ref)
        | Text (t) :: xs => 
          make_expressions (xs, i, acc_eval, <[ $(t : string) ]> :: acc_ref)

        | _ when i == 0 =>
          Message.error ("not enough arguments for printf macro");
          (acc_eval, acc_ref)
            
        | Number (false, false) :: xs => continue (<[ $(parms[i - 1]) : int ]>, xs)
        | Number (true, false) :: xs => continue (<[ $(parms[i - 1]) : uint ]>, xs)
        | Number (false, true) :: xs => continue (<[ $(parms[i - 1]) : long ]>, xs)
        | Number (true, true) :: xs => continue (<[ $(parms[i - 1]) : ulong ]>, xs)

        | NumberFloat (false) :: xs =>
          continue (<[ Convert.ToString (($(parms[i - 1]) : float),
                         Globalization.NumberFormatInfo.InvariantInfo) ]>, xs)
        | NumberFloat (true) :: xs =>
          continue (<[ Convert.ToString (($(parms[i - 1]) : double),
                         Globalization.NumberFormatInfo.InvariantInfo) ]>, xs)

        | Str :: xs => continue (<[ $(parms[i - 1]) : string ]>, xs)

        | Chr :: xs => continue (<[ $(parms[i - 1]) : char ]>, xs)

        | [] => 
          Message.error ("too many arguments for printf macro");
          (acc_eval, acc_ref)
      }
    };

    make_expressions (toks, parms.Length, [], []);
  }

  macro printf (format : string, params parms : array <expr>) 
  {
    def (evals, refs) = make_evaluation_exprs (parse_format (format), parms);
    def seq = List.Append (evals, List.Map (refs, fun (x) { 
      <[ Console.Write ($x) ]> 
    }));
    <[ {.. $seq } ]>
  }

  macro sprintf (format : string, params parms : array <expr>)
  {
    def (evals, refs) = make_evaluation_exprs (parse_format (format), parms);
    def seq = List.Append (evals, List.Map (refs, fun (x) { 
      <[ ignore (result.Append ($x)) ]> 
    }));
    <[ 
      def result = Text.StringBuilder ();
      {.. $seq } 
      result.ToString ();
    ]>
  }

  /** Writes output to given System.IO.TextWriter */
  macro fprintf (writer, format : string, params parms : array <expr>)
  {
    def (evals, refs) = make_evaluation_exprs (parse_format (format), parms);
    def seq = List.Append (evals, List.Map (refs, fun (x) { 
      <[ writer_v.Write ($x) ]> 
    }));
    <[ 
      def writer_v = $writer : IO.TextWriter;
      {.. $seq } 
    ]>
  }

  make_scan_expressions (format : string, parms : array <PT.Expr>, 
                         stream : PT.Expr) : list <PT.Expr> {
    def iter_through (toks, i, acc) {                        
      match ((toks, i)) {
        | ([], 0) => acc
        | (Text (t) :: xs, _) => 
          iter_through (xs, i, <[ 
            Nemerle.IO.CheckInput ($(t : string), $stream)
          ]> :: acc)

        | (_, 0) =>
          Message.error ("not enough arguments for scanf-style macro");
          acc
            
        | (Number (false, false) :: xs, _) =>
          iter_through (xs, i - 1, 
            <[ $(parms[i - 1]) = Convert.ToInt32 (Nemerle.IO.ReadIntDigits ($stream)) ]> :: acc)

        | (Number (true, false) :: xs, _) =>
          iter_through (xs, i - 1, 
            <[ $(parms[i - 1]) = Convert.ToUInt32 (Nemerle.IO.ReadIntDigits ($stream)) ]> :: acc)

        | (Number (false, true) :: xs, _) =>
          iter_through (xs, i - 1, 
            <[ $(parms[i - 1]) = Convert.ToInt64 (Nemerle.IO.ReadIntDigits ($stream)) ]> :: acc)

        | (Number (true, true) :: xs, _) =>
          iter_through (xs, i - 1, 
            <[ $(parms[i - 1]) = Convert.ToUInt64 (Nemerle.IO.ReadIntDigits ($stream)) ]> :: acc)

        | (NumberFloat :: _, _) =>
          Message.fatal_error ("scaning floats not supported")

        | (Str :: xs, _) =>
          iter_through (xs, i - 1, 
            <[ $(parms[i - 1]) = Nemerle.IO.ReadString ($stream) ]> :: acc)

        | (Chr :: xs, _) =>
          iter_through (xs, i - 1, 
            <[ $(parms[i - 1]) = Convert.ToChar ($stream.Read ()) ]> :: acc)

        | ([], _) =>
          Message.error ("too many arguments for scanf macro");
          acc
      }
    };
    iter_through (parse_format (format), parms.Length, []);
  }

  macro scanf (format : string, params parms : array <expr>) 
  {
    def seq = make_scan_expressions (format, parms, <[ stdin ]>);
    <[
      def stdin = System.Console.In; 
      Nemerle.IO.ConsumeWhiteSpace (stdin);
      {.. $seq } 
    ]>
  }

  macro fscanf (stream, format : string, params parms : array <expr>) 
  {
    def seq = make_scan_expressions (format, parms, <[ stream_cached ]>);
    <[
      def stream_cached = $stream; 
      Nemerle.IO.ConsumeWhiteSpace (stream_cached);
      {.. $seq } 
    ]>
  }

  macro sscanf (str, format : string, params parms : array <expr>) 
  {
    def seq = make_scan_expressions (format, parms, <[ stream_cached ]>);
    <[
      def stream_cached = StringReader ($str); 
      Nemerle.IO.ConsumeWhiteSpace (stream_cached);
      {.. $seq } 
    ]>
  }

  /** we could extend it to $(..) expressions - in such a case:
      - first evaluate expressions
      - store intermediate results in variables
      - return list of evaluators and reference variables in reverse order
   */
  make_splice_distribution (str : string) : list <PT.Expr>
  {
    def find_end (balance, idx) {
      when (idx >= str.Length)
        Message.fatal_error ("runaway $(...) in format string");
      match (str[idx]) {
        | ')' when balance == 1 => idx
        | ')' => find_end (balance - 1, idx + 1)
        | '(' => find_end (balance + 1, idx + 1)
        | _ => find_end (balance, idx + 1)
      }
    }

    def find_end_normal (idx) {
      if (idx >= str.Length) idx
      else
        match (str[idx]) {
          | '\''
          | '_' 
          | ch when System.Char.IsLetterOrDigit (ch) => find_end_normal (idx + 1)
          | _ => idx
        }
    }
    
    def loop (res, idx) {
      if (idx < 0 || idx >= str.Length)
        res
      else if (str[idx] == '$') {
        when (idx + 1 >= str.Length)
          Message.fatal_error ("lone `$' at the end of the format string");
        if (str[idx + 1] == '(') {
          def end = find_end (1, idx + 2);
          def expr = str.Substring (idx + 1, end - idx);
          TypingContext.PushUseSiteColor ();
          def expr = Parser.ParseExpr (expr + " ");
          TypingContext.PopColor ();
          loop (expr :: res, end + 1)
        } else if (str[idx + 1] == '$') {
          loop (<[$("$" : string)]> :: res, idx + 2)
        } else {
          def end = find_end_normal (idx + 1);
          def variable_name = str.Substring (idx + 1, end - idx - 1);
          loop (<[ $(variable_name : usesite).ToString () ]> :: res, end)
        }
      } else {
        def next_idx = str.IndexOf ('$', idx);
        def next_str =
          if (next_idx == -1) str.Substring (idx)
          else str.Substring (idx, next_idx - idx);
        loop (<[ $(next_str : string) ]> :: res, next_idx)
      }
    }

    loop ([], 0)
  } 

  /** If string literal is supplied, then prints it to System.Console, replacing all
      occurences of $id with id.ToString () invocation
      If any other expression is supplied, it is equivalent to System.Console.Write 
  */
  macro print (value)
  {
    match (value) {
      | <[ $(str : string) ]> =>
        def seq = List.RevMap (make_splice_distribution (str), fun (x) {
          <[ Console.Write ($x) ]> 
        });
        <[ {.. $seq } ]>

      | _ =>
        <[ Console.Write ($value) ]>       
    }
  }

  macro sprint (str : string)
  {
    def seq = List.RevMap (make_splice_distribution (str), fun (x) {
      <[ ignore (result.Append ($x)) ]> 
    });
    <[ def result = Text.StringBuilder (); {.. $seq }; result.ToString () ]>
  }

  /** Writes text to given System.IO.TextWriter */
  macro fprint (writer, str : string)
  {
    def seq = List.RevMap (make_splice_distribution (str), fun (x) {
      <[ writer_v.Write ($x) ]> 
    });
    <[ def writer_v = $writer : IO.TextWriter; {.. $seq }; ]>
  }
}
}

namespace Nemerle.Text {

  /** translation of match on regular expressions to operations on .Net
      regular expressions and its Groups, which allows short and simple
      extraction of regular subpatterns.
      Syntax of this macro is like in following example:
      <code>
        regexp match (str) {
          | "a+.*" => printf ("a\n");
          | @"(?<num : int>\d+)-\w+" => printf ("%d\n", num + 3);
          | "(?<name>(Ala|Kasia))? ma kota" =>
            match (name) {
              | Some (n) => printf ("%s\n", n)
              | None => printf ("noname?\n")
            }
          | _ => printf ("default\n");
        }
      </code>
  */
  macro @regexp (mat)
  syntax ("regexp", mat) 
  {
    /// syntax is [regexp match { .. }], so [mat] must be [match]
    match (mat) {
      | <[ match ($val) { ..$cases } ]> =>
        // final pattern of regular expression for builded match
        mutable pat = Text.StringBuilder ();
        // names of created groups of final regular expression, names
        // of existing named groups in patterns and associated expressions
        // to execute 
        mutable alternatives = [];
        // variable used for valid creation of alternatives [(..)|(..)|(..)] 
        mutable first = true;
        // default matching case if occurred
        mutable default = None ();

        // walks through cases of given match and builds final regular
        // expression in [pat] and stores group names and related expressions
        // to [alternatives]
        def create_regpattern (cass : list <PT.Match_case>) {
          mutable patnames = [];

          // walks thorough guards of single case, collecting names
          // for each created group of regular expression and storing
          // names of existing group names inside in [patnames]
          def walk_guards (gs, acc) {
            match (gs) {
              | <[ caseguard: $(str : string) ]> :: xs =>
                // take names of named groups
                def namesreg = Regex (@"\(\?\<(\w+)\s*(:\s*((\w|\.)+))?");
                mutable m = namesreg.Match (str); 
                // find all occurrenceces of existing gropus inside
                while (m.Success) {
                  mutable end = false;
                  mutable paren = 0;
                  mutable optional = false;
                  // check if this group is optional (it's context information)
                  // so we must count [(] and [)]
                  for (mutable i = m.Index; !end && i < str.Length; ++i) {
                    match (str[i]) {
                      | '(' => paren = paren + 1
                      | ')' => 
                        paren = paren - 1;
                        when (paren == 0 && i + 1 < str.Length && str[i + 1] == '?') {
                          end = true;
                          optional = true;
                        }
                      | _ => ()
                    }
                  };

                  // store this existing named group with its name, information 
                  // if it's optional and name of its enforced type  
                  // - [(?<name : type>..)?]
                  match ((m.Groups[1].Success, m.Groups[3].Success)) {
                    | (true, false) =>
                      patnames = (m.Groups[1].ToString (), optional, 
                                   None ()) :: patnames
                    | (true, true) =>
                      patnames = (m.Groups[1].ToString (), optional,
                                   Some (m.Groups[3].ToString ())) :: patnames;
                    | _ => ()
                  };
                  m = m.NextMatch ();
                };
                def nsymb = Macros.NewSymbol ();
                // add | if it is not first alternative in our pattern
                unless (first) pat = pat.Append ("|");
                first = false;
                def newstr = namesreg.Replace (str, "(?<$1");
                // add current alternative to our pattern
                pat = pat.Append("(?<" + nsymb.Id + ">^" + newstr + "$)");
                walk_guards (xs, nsymb.Id :: acc)

              | [] => acc

              | <[ caseguard: $(_) when $(_) ]> :: _ =>
                Message.fatal_error ("guarded pattern not allowed in regexp macro")
              | _ :: _ =>
                Message.fatal_error ("only string patterns allowed in regexp macro")
            }
          };
          match (cass) {
            // default case it special and we must store it
            | [ <[ case: _ => $expr ]> ] => default = Some (expr)

            | <[ case: | ..$guards => $expr ]> :: xs =>
              alternatives = (walk_guards (guards, []), patnames, expr) 
                              :: alternatives;
              create_regpattern (xs)

            | [] => ()
          }
        };
        create_regpattern (cases);

        // build decision tree, which checks created groups one by one and if
        // some has matched executes corresponding expression
        def build_checking (cass) {
          // build || condition for patterns from one case in initial matching
          def build_alts (alts) {
            match (alts) {
              | [str] => 
                <[ matchobj.Groups[$(str : string)].Success ]>
              | x::xs =>
                <[ 
                  matchobj.Groups[$(x : string)].Success || 
                  $(build_alts (xs)) 
                ]>
                  
              | [] => Message.fatal_error ("empty list of guards?")
            }
          };
          // build expressions containing values of existing named groups
          // converting their type (parsing them from string) if needed
          def build_bindings (patnames, acc) {
            match (patnames) {
              | (name, opt, choosen_type) :: xs =>
                def strin = 
                  <[ matchobj.Groups[$(name : string)].ToString () ]>;
                def value =
                  match (choosen_type) {
                    | None => strin
                    | Some (t) =>
                      <[ $(Nemerle.Macros.Symbol ((t : string)) : name).Parse ($strin) ]>
                  };
                def name_symbol = Macros.UseSiteSymbol (name);
                def binding =
                  if (opt) 
                    <[ 
                      def $(name_symbol : name) = 
                        match (matchobj.Groups[$(name : string)].Success) {
                          | true => Some ($value) | _ => None ()
                        }
                    ]>
                  else
                    <[ def $(name_symbol : name) = $value ]>;
                build_bindings (xs, binding :: acc);
                
              | [] => acc
            }
          };
          match (cass) {
            // creates entire expression checking if one case have succeeded
            | (grds, patnames, expr) :: xs =>
              <[ 
                match ($(build_alts (grds))) { 
                  | true => {
                    .. $(List.Append (build_bindings (patnames, []), [expr])) 
                  }
                  | _ => $(build_checking (xs)) 
                }
              ]>
            
            | [] => <[ throw MatchFailureException () ]>
          }
        };
        //
        def defexpr = 
          match (default) {
            | None =>
              Message.warning ("this pattern might be not exhaustive");
              <[ () ]>
            | Some (defexpr) => defexpr
          };              

        // generation of final code for building regular expression and
        // extracting its groups
        <[ 
          def regobj = Regex ($(pat.ToString () : string), 
                              RegexOptions.ExplicitCapture);

          def matchobj = regobj.Match ($val);

          match (matchobj.Success) {
            | true => $(build_checking (alternatives))
            | _ => $defexpr 
          }
        ]>
      | _ =>
        Message.fatal_error ("regexp macro expects match construct")
    }
  }
}
