using System;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

namespace LRPEGCC
{
  partial internal class Optimizer
  {
    public static CanInline(name : RuleRef, grammar : Grammar) : bool
    {
      def canInline(rule : Rule, recRules : Set[RuleRef]) : bool * int
      {
        def (res, count) = match (rule : Rule)
        {
        | Call(name)               =>
          if (recRules.Contains(name) || recRules.Count > 6)
            (false, 0);
          else
            canInline(grammar.GetRule(name), recRules.Add(name));

        | Choice(rules)
        | Sequence(rules)          =>
          def fn(rule, (res, count))
          {
            def (r, c) = canInline(rule, recRules);
            (res && r, count + c);
          }

          rules.Fold((true, 0), fn);

        | Capture(_, _, _, rule)
        | CaptureNamedTerminalSymbol(_, rule)
        | RepeatMin(_, rule)
        | RepeatMinMax(_, _, rule)
        | Not(rule)
        | And(rule)                => canInline(rule, recRules);

        | Chars
        | ExtensionPoint           => (true, 0);
        }

        (res, count + 1);
      }
      def (res, count) = canInline(grammar.GetRule(name), Set().Add(name));

      res && count < 6;
    }

    public static OptimizeRule(rule : Rule, grammar : Grammar) : Rule
    {
      def removeAllTerminalCpture(_ : Rule) : Rule
      {
        | CaptureNamedTerminalSymbol(_, rule) => rule
        | rule => rule
      }
      def removeNestedTerminalCpture(rule : Rule) : Rule
      {
        | CaptureNamedTerminalSymbol(name, rule) =>
          Rule.CaptureNamedTerminalSymbol(name, rule.Walk(removeAllTerminalCpture))

        | Not(rule) => Rule.Not(rule.Walk(removeAllTerminalCpture))
        | And(rule) => Rule.And(rule.Walk(removeAllTerminalCpture))
        | _ => rule
      }
      def rule1 = rule.Walk(removeNestedTerminalCpture);

      def optimize(_ : Rule)
      {
        | Choice(rules) =>
          def rules = rules.Map(optimize);
          def rules = rules.Map(
            fun(_)
            {
              | Rule.Choice(rules) => rules
              | rule               => [rule]
            });
          def rules = rules.Flatten();
          def catChars(_)
          {
            | Rule.Chars([chars1]) :: Rule.Chars([chars2]) :: rules =>
              catChars(Rule.Chars([chars1.Sum(chars2)]) :: rules)

            | rule :: rules => rule :: catChars(rules)
            | []            => []
          }
          def rules = catChars(rules);

          match (rules)
          {
            | [rule] => rule
            | _      => Rule.Choice(rules)
          }

        | Sequence(rules) =>
          def rules = rules.Map(optimize);
          def rules = rules.Map(
            fun(_)
            {
              | Rule.Sequence(rules) => rules
              | rule                 => [rule]
            });
          def rules = rules.Flatten();
          def catChars(_)
          {
            | Rule.Not(Rule.Chars([chars1])) :: Rule.Chars([chars2]) :: rules =>
              catChars(Rule.Chars([chars2.Sub(chars1)]) :: rules)

            | Rule.And(Rule.Chars([chars1])) :: Rule.Chars([chars2]) :: rules =>
              catChars(Rule.Chars([chars2.Sum(chars1)]) :: rules)

            | Rule.Chars(chars1) :: Rule.Chars(chars2) :: rules =>
              catChars(Rule.Chars(chars1.Append(chars2)) :: rules)

            | rule :: rules => rule :: catChars(rules)
            | [] => []
          }
          def rules = catChars(rules);

          match (rules)
          {
            | [rule] => rule
            | _      => Rule.Sequence(rules)
          }

        | RepeatMin(min, rule)         => Rule.RepeatMin(min, optimize(rule))
        | RepeatMinMax(min, max, rule) => Rule.RepeatMinMax(min, max, optimize(rule))
        | Not(Not(rule))               => optimize(Rule.And(rule))
        | And(Not(rule))               => optimize(Rule.Not(rule))
        | Not(And(rule))               => optimize(Rule.Not(rule))
        | And(And(rule))               => optimize(Rule.And(rule))
        | Not(rule)                    => Rule.Not(optimize(rule))
        | And(rule)                    => Rule.And(optimize(rule))
        | Capture(name, at, rt, rule)  => Rule.Capture(name, at, rt, optimize(rule))
        | CaptureNamedTerminalSymbol(name, rule) => Rule.CaptureNamedTerminalSymbol(name, optimize(rule))
        | Chars as rule                => rule
        | ExtensionPoint as rule       => rule
        | Call(name)                   =>
          if (CanInline(name, grammar))
            optimize(grammar.GetRule(name))
          else
            Rule.Call(name)
      }

      def rule2 = optimize(rule1);
      def rule3 = rule2.Walk(removeNestedTerminalCpture);
      def rule4 = optimize(rule3);
      rule4
    }
  }
}
