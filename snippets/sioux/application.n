/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ 

namespace Sioux
{
  using Nemerle.Collections;
  using Nemerle.Xml;

  using System.Net.Sockets;

  
  /**
   * The exception thrown in case of an irrecoverable error.
   */
  public class DieException : System.Exception
  {
    public this () {}
  }


  /**
   * Describes a Nemerle web application.
   */
  public class Application
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */
    
    /**
     * Creates a new instance of a Nemerle web application.
     */
    public this ()
    {
      PageName = "";
      FormTemplate = None ();
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    /**
     * Handles an HTTP request
     */
    public HandleRequest (request : Request, response : Response) : void
    {
      this.request = request;
      this.response = response;

      match (request.GetRequestInfo ()) {
        | DynamicGet (url, _)
        | Post (url, _) =>
          PageName = url
        | _ =>
          ReportInternalError ("invalid request type in HandleRequest")
      };

      put_get_and_post_vars_into_hashtables ();
            
      try {
        Run ();
        maybe_send_response ();
      } 
      catch {
        | _ : DieException => ()
        | exn : System.Exception =>
          try {
            ReportInternalError ("got a fatal exception " + exn.ToString () + 
                                 "\n\n" + exn.StackTrace)
          } 
          catch {
            | _ : DieException => ()
          }
      }
    }


    /**
     * Reports an internal error and dies
     */
    public virtual ReportInternalError <'a> (msg : string) : 'a
    {
      response.WriteLine ("HTTP/1.0 500 Server Error");
      response.WriteLine ("Content-type: text/plain");
      response.WriteLine ();
      response.WriteLine (msg);

      throw DieException ()
    }


    /* -- PROTECTED METHODS ------------------------------------------------ */

    /**
     * Performs the server-side computations associated with this action.
     */
    protected virtual Run () : void
    {
      // do nothing
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    /**
     * Writes the contents of the form template, if any present
     */
    private maybe_send_response () : void
    {
      match (FormTemplate) {
        | Some (template) => response.WriteXhtml (template.GetDocument ())          
        | _ => ()
      }
    }


    /**
     * We don't really care about the ordering of the GET and POST
     * variables, so put them into hashtables for convenience.
     */
    private put_get_and_post_vars_into_hashtables () : void
    {
      def move_to_hashtable (hashtable : Hashtable <string, string>, parms : list <string * string>) : void
      {
        match (parms) {
          | [] => ()
          | (parameter, value) :: rest =>
            System.Console.WriteLine ("VAR: '{0}' = '{1}'", parameter, value);
            hashtable.Set (parameter, value);
            move_to_hashtable (hashtable, rest)
        }
      };
      
      match (request.GetRequestInfo ()) {
        | DynamicGet (_, parms) =>
          GetVars = Hashtable (List.Length (parms));
          PostVars = null;
          
          request_type_is_get = true;
          
          move_to_hashtable (GetVars, parms)
        
        | Post (_, parms) =>
          PostVars = Hashtable (List.Length (parms));
          GetVars = null;
          
          request_type_is_get = false;
          
          move_to_hashtable (PostVars, parms)
          
        | _ =>
          ReportInternalError ("invalid request type")
      }
    }  


    /* -- PROTECTED FIELDS ------------------------------------------------- */

    protected mutable GetVars : Hashtable <string, string>;
    protected mutable PostVars : Hashtable <string, string>;

    protected mutable request_type_is_get : bool;

    protected mutable PageName : string;
    protected mutable FormTemplate : option <XmlTemplate>;

    protected mutable request : Request;
    protected mutable response : Response;    
  }
}
