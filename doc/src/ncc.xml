<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>High-level <tt>ncc</tt> description</title>
  <section id="main">
    <title>The main file</title>
    <body>
      <p>
        The main compiler file is <file>main.cs</file>, but all it does it
        running parser (<file>parser.jay</file>) and transferring control
        to <tt>Passes.run</tt> function (from <file>passes.n</file>).
      </p>
      <p>
        Main file also catches some exceptions, and defines some auxiliary
        functions (class <tt>CS_glue</tt>, these are later referenced from
        <file>csglue.n</file>).
      </p>
      <p>
        <tt>Passes.run</tt> runs several functions, that are described
        (in order of calling) in later sections of this document.
      </p>
    </body>
  </section>
  <section id="scan_globals">
    <title>Scan globals</title>
    <body>
      <p>
        This is done in <file>scan_globals.n</file>. It changes
        <tt>open</tt>/<tt>namespace</tt> declaration into appropriate
        entries in <tt>Env</tt> class.  It also creates <tt>Tyinfo</tt>
        object for each type and registers it with global name
        environment.
      </p>
    </body>
  </section>
  <section id="tyinfo">
    <title>Type processing</title>
    <body>
      <p>
        This pass operates on <tt>Tyinfo</tt> objects created for each
        type declaration found in source files. These objects are already
        created, but most fields are empty. The main function of this pass
        is <tt>Tyinfo.run</tt>. All function described in this section can
        be found in <file>tyinfo.n</file>.
      </p>
    </body>
    <subsection id="bind_tv">
      <title>Binding type variables</title>
      <body>
        <p>
          The first thing to do is to create typing environment
          <tt>Tyvar.TEnv</tt> for each type declaration. Then typing
          environment is populated with type variables (transformed
          into <tt>Tyvar.T</tt> objects).  Finally constraints (type
          expressions, which are first bound) of each type variable are
          stored in <tt>Tyvar.T</tt>.
        </p>
        <p>
          Typing environment maps names of type variables to
          <tt>Tyvar.T</tt> objects.
        </p>
      </body>
    </subsection>
    <subsection id="bind_tyex">
      <title>Binding type expressions</title>
      <body>
        <p>
          Next we need to bind type expressions occurring in
          type declarations.  This includes <tt>extends</tt> type,
          <tt>implements</tt> list, and aliased type in case of type
          alias declaration.
        </p>
        <p>
          Binding type expression refers to rewriting
          <tt>Parsetree.Type</tt> into <tt>Typedtree.Type</tt>,
          which involves resolving names of type constructors (to
          <tt>Tyinfo</tt> objects) and type variables (to <tt>Tyvar.T</tt>
          objects).
        </p>
      </body>
    </subsection>
    <subsection id="det_subt">
      <title>Determining subtyping relations</title>
      <body>
        <p>
          This probably the hardest part of processing type declarations.
        </p>
        <p>
          Each type directly subtypes types it extends or implements.
          This pass computes transitive closure of direct
          subtyping relation and stores it <tt>Tyinfo.subtypes</tt>
          map. <tt>.NET</tt> generics doesn't allow same type to be
          subtyped under different instantiations, so we use map from
          (id of) subtyped <tt>Tyinfo</tt> object to actual parameters
          of subtyped type.
        </p>
        <p>
          Since this point during type binding we can
          check if subtyping constraints are satisfied upon
          instantiations of types.  This is reflected by setting
          <tt>Tyinfo.can_check_constraints</tt> variable.  We also check
          it for unsatisfied constraints in already bound types in the
          beginning of <tt>Tyinfo.make_member_list</tt> function.
        </p>
      </body>
    </subsection>
    <subsection id="make_member_list">
      <title>Constructing lists of members</title>
      <body>
        <p>
          <tt>Tyinfo.make_member_list</tt> function collects type
          members (fields and methods, but not types, which are already
          collected in <tt>Tyinfo.contained_types</tt>) and stores it
          in <tt>Tyinfo.member_list</tt> fields.
        </p>
        <p>
          Members are first transferred from <tt>Parsetree</tt> into
          <tt>Typedtree</tt> namespace by binding appropriate types.
        </p>
      </body>
    </subsection>
    <subsection id="make_impl_ctor">
      <title>Making implicit constructors</title>
      <body>
        <p>
          <tt>Tyinfo.add_implicit_ctor</tt> adds record-like
          constructor (<tt>this (x, y) { this.x &lt;- x; this.y &lt;-
          y }</tt>) to some classes. Constructor building is in
          <file>extensions.n</file>.
        </p>
      </body>
    </subsection>
    <subsection id="make_member_map">
      <title>Constructing member maps</title>
      <body>
        <p>
          <tt>Tyinfo.make_member_map</tt> constructs maps from names
          to non-static fields and methods in given type (including
          derived ones).  This is used later in typing.
        </p>
      </body>
    </subsection>
  </section>
  <section id="tyexpr">
    <title>Typing</title>
    <body>
      <p>
        After type declaration are dealt with, we can proceed to typing
        expressions. This is done in <file>tyexpr.n</file>, and the main
        function is <tt>Tyexpr.run</tt>. It uses <tt>Tyinfo.iter</tt>
        to walk through all type declarations. It then recurses into
        functional members to do it's work.
      </p>
      <p>
        Typing generally involves rewriting from <tt>Parsetree</tt>
        to <tt>Typedtree</tt> namespace. Also entry point for expression
        is changed from <tt>FB_parsed_expr</tt> to <tt>FB_typed_expr</tt>.
      </p>
      <p>
        During typing we do few things:
      </p>
      <ul>
        <li>
          Infer types and check if they are correct. Store information
          about types in resulting <tt>Typedtree.Expr</tt> objects.
        </li>
        <li>
          Define (generate <tt>Decl</tt> objects) and later resolve
          local values.
        </li>
        <li>
          Rewrite few redundant source language constructs into unambiguous
          equivalents from <tt>Typedtree</tt>.
        </li>
        <li>
          Bind type expressions occurring in source code.
        </li>
        <li>
          Mark which values should go into closures.
        </li>
      </ul>
      <p>
        This is however all done in parallel to improve efficiency.
      </p>
      <p>
        FIXME: overloading resolution, CTX type, more about closures,
        binding method implement list.
      </p>
    </body>
  </section>
  <section id="cg">
    <title>Code generation</title>
    <body>
      <p>
        This is done in <file>cgexpr.n</file> file. We define types and expressions
        flattened to CIL level in <file>cgtree.n</file>.
      </p>
    </body>
    <subsection id="cg_tydecl">
      <title>CG for type declarations</title>
      <body>
        <p>
          This is pretty straightforward, as Nemerle types mostly map to
          CIL types in 1:1 fashion. We just drop type aliases (not sure if
          such a concept exists in CIL).
        </p>
        <p>
          FIXME: describe how variants are compiled.
        </p>
      </body>
    </subsection>
    <subsection id="cg_expr">
      <title>CG for expressions</title>
      <body>
        <p>
          This is done by <tt>CGexpr.cg_expr</tt> function. It takes
          <tt>Typedtree.Expr</tt> and flattens it to <tt>CG_expr</tt>
          and possibly few classes for closures and local functions.
        </p>
      </body>
    </subsection>
  </section>
  <section id="cgflat">
    <title>Flattening CG trees</title>
    <body>
      <p>
        Module <tt>CGflat</tt> is responsible for bringing CG trees to
        C# source code. This module will be replaced by IL assembler or
        byte code generator.
      </p>
      <p>
        It features strings encoded in trees for fast concatenation. It
        ain't any rocket science, but improves performance.
      </p>
    </body>
  </section>
    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
