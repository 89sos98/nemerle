/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler;
using Nemerle.Utility;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public class GlobalEnv 
  {
    public variant TypeInfoCache {
      | No
      | Cached { tycon : TypeInfo; }
      | NotLoaded { e : LibraryReferenceManager.ExternalType; }
      | MacroCall { m : IMacro; }
      | NamespaceReference
    }
    
    public class NamespaceND {
      public Parent : NamespaceND;
      name : string;
      public mutable Value : TypeInfoCache;
      mutable children : Hashtable [string, NamespaceND];
      
      public this (parent : NamespaceND, n : string, v : TypeInfoCache) {
        Parent = parent;
        name = n;
        Value = v;
      }

      public Name : list [string]
      {
        get {
          if (name == null) ["alias"]
          else
            GetNameWithSuffix ([])
        }
      }

      public GetNameWithSuffix (mutable suffix : list [string]) : list [string]
      {
        mutable node = this;
        while ((node : object) != namespace_tree) {
          suffix = node.name :: suffix;
          node = node.Parent;
        }
        suffix
      }

      // some namespace nodes are faked for the need of namespace aliases
      internal IsFromAlias : bool {
        get { name == null }
      }
      
      public Clear () : void
      {
        unless (children == null) children.Clear ();
      }

      /// Walks down the tree begining at current node, spliting given
      /// name to `.' separated parts. The path is created if at some
      /// point it doesn't exist in tree.
      public Path (n : string) : NamespaceND {
        mutable cur_node = this;
        mutable last = 0;
        for (mutable i = 0; i < n.Length; ++i) {
          when (n[i] == '.') {
            cur_node = cur_node.Child (n.Substring (last, i - last));
            last = i + 1;
          }
        };
        when (n.Length > 0 && !n.EndsWith ("."))
          cur_node = cur_node.Child (n.Substring (last, n.Length - last));
        cur_node
      }

      public Path (n : list [string]) : NamespaceND {
        mutable cur_node = this;
        def loop (l) {
          | x :: xs =>
            cur_node = cur_node.Child (x);
            loop (xs)
          | _ => cur_node
        };
        loop (n)
      }
      
      public TryPath (n : list [string]) : TypeInfoCache {
        def loop (l, cur_node : NamespaceND) {
          match (l) {
            | [x] =>
              when (cur_node.children == null)
                cur_node.children = Hashtable (10, 1.0f);
                
              match (cur_node.children.Get (x)) {
                | Some (nd) => nd.Value
                | _ =>
                  match (x [x.Length - 1]) {
                    | '*' | '&' =>
                      def bare_name = x.TrimEnd (array ['*', '&']);
                      def (st, lib) =
                        match (cur_node.children.Get (bare_name)) {
                          | Some (nd) =>
                            match (nd.Value) {
                              | TypeInfoCache.Cached (tc) =>
                                (tc.GetSystemType (), tc.GetLibraryReference ())
                                
                              | TypeInfoCache.NotLoaded (e) =>
                                (e.system_type, e.library)
                                
                              | _ => (null, null)
                            }
                          | _ => (null, null)
                        };
                      if (st != null) {
                        def correct_name = st.FullName + x.Substring (bare_name.Length);
                        def nst = st.Assembly.GetType (correct_name);
                        def correct_name = correct_name.Replace ('+', '.');
                        assert (nst != null);

                        def res = TypeInfoCache.Cached (lib.ConstructTypeInfo (nst));
                        namespace_tree.Path (correct_name).Value = res;
                        namespace_tree.Child (nst.Assembly.CodeBase).
                          Path (correct_name).Value = res;
                        res
                      }
                      else
                        TypeInfoCache.No ()

                    | _ => TypeInfoCache.No ()
                  }
                }

            | x :: xs =>
              when (cur_node.children == null)
                cur_node.children = Hashtable (10, 1.0f);
                
              match (cur_node.children.Get (x)) {
                | Some (nd) => loop (xs, nd)
                | _ => TypeInfoCache.No ()
              }
            // we are at good namespace, so return our own Value
            | _ => Value
          }
        };
        loop (n, this)
      }

      public LookupType (split : list [string]) : option [TypeInfo]
      {
        match (TryPath (split)) {
          | TypeInfoCache.Cached (tc) => Some (tc)
          | TypeInfoCache.NotLoaded (e) =>
            def nd = Path (split);
            when (e.tycon == null) {
              when (e.message != null) {
                Message.Warning ("using type `" + e.system_type.FullName + 
                                 "' that was defined in more then one assembly: " +
                                 e.message + " (the first version was used)")
              };
              e.tycon = e.library.ConstructTypeInfo (e.system_type);
            };
            nd.Value = TypeInfoCache.Cached (e.tycon);
            Some (e.tycon)

          | TypeInfoCache.MacroCall | TypeInfoCache.No
          | TypeInfoCache.NamespaceReference => None ()
        }
      }

      public LookupSystemType (split : list [string]) : option [System.Type]
      {
        match (TryPath (split)) {
          | TypeInfoCache.Cached (tc) => Some (tc.GetSystemType ())
          | TypeInfoCache.NotLoaded (e) => Some (e.system_type)
          | TypeInfoCache.MacroCall | TypeInfoCache.No
          | TypeInfoCache.NamespaceReference            => None ()
        }
      }

      public LookupValue () : option [TypeInfo]
      {
        LookupType ([])
      }


      public LookupMacro (split : list [string]) : option [IMacro]
      {
        match (TryPath (split)) {
          | TypeInfoCache.MacroCall (m) => Some (m)
          | _ => None ()
        }
      }

      internal AddChild (name : string, node : NamespaceND) : void {
        when (children == null) children = Hashtable (16);
        children.Add (name, node);
      }
      
      /// Performs one step down the tree through given edge (name).
      /// String in this edge isn't splited to `.' separated parts.
      /// In case there is no such child in current node, it is created.
      Child (name : string) : NamespaceND {
        when (children == null) children = Hashtable (16);
        match (children.Get (name)) {
          | None =>
            def result = NamespaceND (this, name, TypeInfoCache.No ());
            children.Add (name, result);
            result

          | Some (r) => r
        }
      }

      public override ToString () : string {
        def s = Text.StringBuilder ("( ");
        when (children != null)
          children.Iter (fun (x, y : NamespaceND) {
            ignore (s.Append (x + "-" + y.ToString () + ", "))
          });
        _ = s.Append (")\n");
        s.ToString ();
      }
    }
    
    static mutable macro_context : int;
    static macro_contexts : Hashtable [string, int];
    static mutable macro_context_class : TypeBuilder;
    static namespace_tree : NamespaceND;

    // we store nodes, which were referenced from using / alias to check their existance
    static mutable referenced_namespace_nodes : list [list [NamespaceND] * Location];
    
    static this () {
      macro_contexts = Hashtable (100);
      namespace_tree = NamespaceND (null, "", TypeInfoCache.NamespaceReference ());
      Empty = GlobalEnv ();
    }

    public static Init () : void
    {
      namespace_tree.Clear ();
      macro_contexts.Clear ();
      macro_context = 0;
      referenced_namespace_nodes = [];
      Core = Empty.AddOpenNamespace (["Nemerle", "Core"], Location.Default)
                  .AddOpenNamespace (["Nemerle", "Core", "option"], Location.Default);
    }

    open_namespaces : list [NamespaceND];
    current_namespace : NamespaceND;
    namespace_aliases : list [string * string];
    mutable macro_ctx_cache : int;

    /** Function for adding type to namespace tree.

        It checks if given
        class is already in namespace tree and if it is and has `partial' modifier
        it add members to existing type instead of creating new TypeBuilder.
     */
    [Nemerle.Assertions.Ensures (value != null)]
    internal static AddType (par : TypeBuilder, parent_node : NamespaceND,
                             newdecl : PT.TopDeclaration) : TypeBuilder
    {
      def pname = newdecl.ParsedName;
      def ns_node = parent_node.Path ([pname.Id]);
      
      match (ns_node.Value) {
        | TypeInfoCache.Cached (existing) =>
          match (existing) {
            | tb is TypeBuilder =>
              tb.ExtendPartialClass (newdecl);
              tb
              
            | _ =>
              Message.Error (newdecl.loc, "redefinition of external type `" +
                             existing.FullName + "'");
              Message.Error (existing.Location, "first defined here");
              TypeBuilder (par, newdecl, ns_node)
          }

        | _ =>
          def builder = TypeBuilder (par, newdecl, ns_node);
          ns_node.Value = TypeInfoCache.Cached (builder);
          builder
      }
    }

    public static AddMacro (split : list[string], m : IMacro) : void {
      def ns = namespace_tree.Path (split);
      match (ns.Value) {
        | TypeInfoCache.No => ns.Value = TypeInfoCache.MacroCall (m)
        | TypeInfoCache.NamespaceReference =>
          Message.Error ("cannot define `" + Util.qid_of_list (split) + 
                         "' because the same namespace exists ");
        | _ =>
          Message.Error ("redefinition of `" + Util.qid_of_list (split) + "'");
      }
    }

    public static DefineExact (td : PT.ClassMember) : TypeBuilder
    {
      Core.Define (td)
    }
    
    public Define (td : PT.ClassMember) : TypeBuilder
    {
      | PT.ClassMember.TypeDeclaration (td) =>
        def tyinfo = AddType (null, current_namespace, td);
        tyinfo.FixupDefinedClass ();
        tyinfo
      | _ =>
        Message.Error ("only types can be defined in global namespaces");
        null
    }
    
    public static LookupInternalType (name : list[string]) : TypeInfo {
      match (LookupExactType (name)) {
        | Some (t) => t
        | None => Util.ice ("unbound internal type " + Util.qid_of_list (name))
      }
    }

    public static LookupExactType (name : string) : option [TypeInfo] {
      namespace_tree.LookupType (NString.Split (name, array ['.']))
    }

    public static LookupExactType (name : list [string]) : option [TypeInfo] {
      namespace_tree.LookupType (name)
    }
  
    public static LookupSystemType (name : string) : option [System.Type]
    {
      namespace_tree.LookupSystemType (NString.Split (name, array ['.']))
    }
    
    public GetType (name : list [string], from : TypeBuilder) : TypeInfo
    {
      match (LookupType (name, from)) {
        | Some (r) => r
        | None =>
          Message.FatalError ("unbound type name `" + Util.qid_of_list (name) + "'");
      }
    }

    public static ExactPath (path : list [string]) : NamespaceND
    {
      namespace_tree.Path (path)
    }
    
    public LookupType (name : list [string]) : option [TypeInfo] 
    {
      LookupType (name, null)
    }
    
    public static LookupExactMacro (name : list [string]) : option [IMacro]
    {
      Empty.LookupMacro (name)
    }
    
    public LookupMacro (name : list [string]) : option [IMacro]
    {
      def collect (pref : NamespaceND, res) {
        match ((res, pref.LookupMacro (name))) {  
          | (x, None) | (None, x) => x
          | (Some (x), Some (y)) when (x : object) == (y : object) => res
          | (Some (x), Some (y)) =>
            Message.Error ("name `" + name.ToString (".") + "' is ambiguous, it could be:");
            Message.Error (x.GetNamespace () + "." + x.GetName () + " this macro");
            Message.Error (y.GetNamespace () + "." + y.GetName () + " or this macro");
            res
          }
        };
      List.FoldLeft (namespace_tree :: open_namespaces, None (), collect)
    }
    
    public LookupType (name : list [string], from : TypeBuilder) : option [TypeInfo]
    {
      match (LookupExactType (name)) {
        | (Some (t)) as r when from == null || t.CanAccess (from) => r
        | _ =>
          def non_public_external (t : TypeInfo) {
            match (t.GetTypeInfoKind ()) {
              | TypeInfoKind.NemerleType => false
              | TypeInfoKind.ExternalNemerleType
              | TypeInfoKind.ExternalNetType =>
                t.GetSystemType ().IsNotPublic
            }
          };
          def check_access (x) {
            | Some (t) when non_public_external (t) => None ()
            | Some (t) when from == null || (t : TypeInfo).CanAccess (from) => x
            | _ => None ()
          };
          
          def collect (pref : NamespaceND, res) {
            match ((res, check_access (pref.LookupType (name)))) {  
              | (x, None) | (None, x) => x
              | (Some (x), Some (y)) when x.Equals (y) => res
              | (Some (x), Some (y)) =>
                // make type X = A.X; using A; X not ambiguous
                match ((x.GetTydecl (), y.GetTydecl ())) {
                  // FIXME: remove Some in two lines below and see the
                  // error message. unable to create small testcase now
                  | (TypeDeclaration.Alias (MType.Class (tc, _)), _) when tc.Equals (y) => Some (y)
                  | (_, TypeDeclaration.Alias (MType.Class (tc, _))) when tc.Equals (x) => Some (x)
                  | _ =>
                    Message.Error ("type name `" + name.ToString (".") + "' is ambiguous, it could be:");
                    Message.Error (x.Location, "   this declaration");
                    Message.Error (y.Location, "   or this declaration");
                    res
                }
            }
          };
          mutable result = List.FoldLeft (open_namespaces, None (), collect);
          mutable type_node = if (from == null) null else from.NamespaceNode;
          while (type_node != null && (type_node.Value matches TypeInfoCache.Cached)) { 
            result = collect (type_node, result);
            type_node = type_node.Parent;
          }
          result
      }
    }
  
    
    internal LookupSymbol (name : list [string], _parent : TypeBuilder) : list [IMember]
    {
      // these are really small, so we do linear lookup in list
      mutable visited = [];
      def (type_part, the_name) = List.DivideLast (name);
      // now we have type_part . the_name

      def add_members_from (t : TypeInfo, acc) {
        if (List.ContainsRef (visited, t))
          acc
        else {
          def members = t.LookupMember (the_name);
          visited = t :: visited;
          def acc = List.FoldLeft (members, acc, list.Cons);
          match (t.GetTydecl ()) {
            | TypeDeclaration.Alias (MType.Class (ti, _)) => add_members_from (ti, acc)
            | _ => acc
          }
        }
      };
      
      def lookup_members (pref : NamespaceND, acc) {
        def acc =
          match (pref.LookupType (type_part)) {
            | Some (t) => add_members_from (t, acc)
            | _ => acc
          };
        match (pref.LookupType (name)) {
          | Some (t) when !List.ContainsRef (acc, t : IMember) =>
            (t : IMember) :: acc
            
          | _ =>  acc
        }
      };
      mutable result = List.FoldLeft (namespace_tree :: open_namespaces, [], lookup_members);
      mutable type_node = if (_parent == null) null else _parent.NamespaceNode;
      while (type_node != null && (type_node.Value matches TypeInfoCache.Cached)) {
        result = lookup_members (type_node, result);
        type_node = type_node.Parent;
      }
      result
    }

    public CurrentNamespace : NamespaceND {
      get { current_namespace }
    }
    
      
    public AddOpenNamespace (ns : list [string], loc : Location) : GlobalEnv
    {
      AddOpenNamespace (namespace_tree.Path (ns), loc)
    }

    private AddOpenNamespace (ns : NamespaceND, loc : Location) : GlobalEnv
    {
      mutable all_opened = [ns];
      // in case we are inside some namespace, we must open every namespace path
      // composed of current namespace's parts suffixed with opened one
      def open_nested (curr : NamespaceND) {
        unless (curr : object == namespace_tree) {
          all_opened = curr.Path (ns.Name) :: all_opened;
          open_nested (curr.Parent)
        }
      }
      open_nested (current_namespace);
      
      // we will warn when none of created namespace parts exists as real namespaces
      referenced_namespace_nodes = (all_opened, loc) :: referenced_namespace_nodes;
      // we will warn if some of those namespace are already open
      GlobalEnv (add_open_nodes (open_namespaces, all_opened, loc, true),
                 current_namespace, namespace_aliases)
    }
    
    internal AddNamespaceAlias (short_name : string, long_name : list [string], 
                                loc : Location) : GlobalEnv
    {
      def nodes_with_prefix = add_alias_nodes (short_name, long_name);
      def entered = List.Map (nodes_with_prefix, fun (x : NamespaceND) {
        x.Path ([short_name])
      });
      referenced_namespace_nodes = (entered, loc) :: referenced_namespace_nodes;
                                  
      GlobalEnv (List.RevAppend (nodes_with_prefix, open_namespaces),
                 current_namespace,
                 (short_name, long_name.ToString (".")) :: namespace_aliases)
    }

    internal EnterIntoNamespace (qid : list [string]) : GlobalEnv
    {
      mutable ns = current_namespace;
      mutable result = this;

      // if namespace if complex (namespace N1.N2.N3 { }) we must enter
      // into each of them
      foreach (part in qid) {
        ns = ns.Path ([part]);
        result = result.EnterIntoNamespace (ns);
      }
      result
    }

    internal EnterIntoNamespace (full : NamespaceND) : GlobalEnv
    {
      when (full.Value is TypeInfoCache.No)
        full.Value = TypeInfoCache.NamespaceReference ();

      def new_opened = add_open_nodes (open_namespaces, [full], Location.Default, false);
      GlobalEnv (new_opened, full, namespace_aliases)
    }

    internal ContainsOpenNamespace (ns : list [string]) : bool {
      List.Exists (open_namespaces, fun (x : NamespaceND) {
        x.Name.Equals (ns)
      })
    }

    /** this is the auxiliary function for making set of opened namespaces
        unique and warn if namespaces are opened multiple times by user
     */
    add_open_nodes (old : list [NamespaceND], added : list [NamespaceND],
                    loc : Location, should_warn : bool) : list [NamespaceND]
    {
      List.FoldLeft (added, old, fun (x : NamespaceND, acc) {
        if (List.ContainsRef (old, x)) {
          when (should_warn)
            Message.Warning (105, loc, $ @"namespace `$(x.Name.ToString ("".""))' is already open");
          acc
        }
        else
          x :: acc
      })
    }
    
    /** We substitute
        using Y = X.Z;
        by
        _tmp1.Y.pointed_by_X_Z // for each part in current namespace
        using _tmp1;
     */
    [Nemerle.Assertions.Requires (short_name != "")]
    add_alias_nodes (short_name : string, long_name : list [string]) : list [NamespaceND]
    {
      mutable all_opened = [];
      // in case we are inside some namespace, we must open every namespace path
      // composed of current namespace's parts suffixed with opened one
      def open_nested (curr) {
        unless (curr == null) {
          // this is the faked namespace node, to simulate forwarding of access to SHORT
          // into FULL's node
          def node_with_prefix = NamespaceND (curr, null, TypeInfoCache.No ());
          def full_node = curr.Path (long_name);
          node_with_prefix.AddChild (short_name, full_node);

          all_opened = node_with_prefix :: all_opened;
          open_nested (curr.Parent)
        }
      }
      open_nested (current_namespace);
      all_opened;
    }
    
    this () 
    {
      current_namespace = namespace_tree;
      open_namespaces = [];
      namespace_aliases = [];
      macro_ctx_cache = -1;
    }

    this (o : list [NamespaceND], c : NamespaceND, n : list [string * string])
    {
      open_namespaces = o;
      current_namespace = c;      
      namespace_aliases = n;
      macro_ctx_cache = -1;
    }

   
    /** Creates environment described by given string encoded for purpose
        of storing macro contexts */
    public this (coded : string)
    {
      mutable state = 0;
      mutable last = 0;
      mutable short = "";
      
      current_namespace = namespace_tree;
      open_namespaces = [];
      namespace_aliases = [];
      macro_ctx_cache = -1;
      
      for (mutable i = 0; i < coded.Length; ++i) {
        match ((state, coded[i])) {
          | (0, '&') =>
            current_namespace = namespace_tree.Path (coded.Substring (0, i));
            state = 1;
            last = i + 1;
           
          | (1, '#') =>
            open_namespaces = namespace_tree.Path (coded.Substring (last, i - last))
                               :: open_namespaces;
            last = i + 1;
            
          | (1, '&') =>
            open_namespaces = namespace_tree.Path (coded.Substring (last, i - last))
                               :: open_namespaces;
            state = 2;
            last = i + 1;

          | (_, '=') =>
            short = coded.Substring (last, i - last);
            // we may be here in state == 2, when this is the first '='
            state = 3;
            last = i + 1;

          // we should add aliases only if the first 'short =' occured
          | (3, '#') | (3, '&') =>
            def long_name = coded.Substring (last, i - last);
            def nodes_with_prefix = add_alias_nodes (short, NString.Split (long_name, array ['.']));
            open_namespaces = List.RevAppend (nodes_with_prefix, open_namespaces);
            namespace_aliases = (short, long_name) :: namespace_aliases;
            last = i + 1;

          | _ => ()
        }
      }
    }

    
    public static CheckReferencedNamespaces () : void
    {
      foreach ((all_opened, loc) in referenced_namespace_nodes) {
        mutable scream = true;
        foreach (nd : NamespaceND in all_opened)
          match (nd.Value) {
            | TypeInfoCache.No => nd.Value = TypeInfoCache.NamespaceReference ();
              
            // we could forbid referencing type-style namespaces here if we want
            | _ => scream = false
          }
        when (scream) {
          Message.Error (loc, "referenced namespace `" +
                         Util.qid_of_list (List.Last (all_opened).Name)
                         + "' does not exist")
        }
      }
    }
                 
    // the format is Current.Namespace.&open.ns1#open.ns2&al1=alias.one#al2=alias.two&
    public GetMacroContext () : int
    {
      when (macro_ctx_cache == -1) {
        when (macro_context_class == null)
          prepare_macro_context_class ();
        
        def collect (k, v) {
          k + "=" + v
        };
        def extract (x : NamespaceND, acc) {
          if (x.IsFromAlias)
            acc
          else
            x.Name.ToString (".") :: acc
        };

        def aliases = List.Sort (List.RevMap (namespace_aliases, collect), String.CompareOrdinal);
        def spaces = List.Sort (List.FoldLeft (open_namespaces, [], extract), String.CompareOrdinal);
        def coded_al = aliases.ToString ("#");
        def coded_ns = spaces.ToString ("#");
        def coded = Text.StringBuilder (current_namespace.Name.ToString (".") + "&");
        ignore (coded.Append (coded_ns + "&"));
        ignore (coded.Append (coded_al + "&"));
        match (macro_contexts.Get (coded.ToString ())) {
          | None =>
            ++macro_context;
            macro_contexts.Add (coded.ToString (), macro_context);
            macro_ctx_cache = macro_context  
          | Some (ctx) =>
            macro_ctx_cache = ctx
        }
      };
      macro_ctx_cache
    }

    private static LiftMacroContexts () : Parsetree.PExpr
    {
      def ar = array (macro_context);
      macro_contexts.Iter (fun (k, v) {ar[v - 1] = k});
      def make_expr (s) {
        assert (s != null); 
        <[ $(s : string) ]>
      };
      <[ array [..$(List.Map (List.FromArray (ar), make_expr))] ]>
    }

    private static prepare_macro_context_class () : void
    {
      def ty = DefineExact (<[ decl:
        internal class _N_MacroContexts {
          private this () { }
        }
      ]>);
      ty.MarkWithSpecialName ();      
      // we must define member explicitly here, because they
      // need to be bound and visible early
      ty.Define (<[ decl:       
          private static serialized : array [string];
      ]>);
      ty.Define (<[ decl:       
          private static contexts : array [GlobalEnv];
      ]>);
      ty.Define (<[ decl:
          static internal Get (no : int) : GlobalEnv
          {
            when (_N_MacroContexts.contexts[no - 1] == null)
              _N_MacroContexts.contexts[no - 1] =
                Nemerle.Compiler.GlobalEnv (_N_MacroContexts.serialized[no - 1]);
            _N_MacroContexts.contexts[no - 1]
          }
      ]>);
 
      macro_context_class = ty;
    }

    internal static FinishMacroContextClass () : void
    {
      def ty = macro_context_class;
      when (ty != null) {
        ty.Define (<[ decl:
          static this ()
          {
            _N_MacroContexts.serialized = $(LiftMacroContexts ());
            _N_MacroContexts.contexts = array ($(macro_context : int));
          } 
        ]>);
        ty.Compile ();
      }
    }

    public override ToString () : string
    {
//      def openns = List.Map (open_namespaces, fun (x : NamespaceND) {
//        Util.qid_of_list (x.Name) });
      "GlobalEnv(" + current_namespace.Name.ToString (".") + ": " + ")"
    }

    public static Empty : GlobalEnv;
    public static mutable Core : GlobalEnv;
  }
} // ns
