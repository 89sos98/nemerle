<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Grokking Nemerle</title>

  <friendly>Don't Panic!</friendly>

  <motto from="wizard">
    ,,This is as rock; tolk in the True Speech.''
  </motto>


  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document contains materials used to teach Nemerle during
        the ,,Nemerle Programming Language'' course taught at our
        institute. It should make a good tutorial. For more information
        about the lecture itself please visit <link>lecture.html</link>.
      </p>
      <p>
        There are reference to various languages throughout this document.
        If you don't know much about these languages -- just ignore these
        remarks. As for remarks for the C language -- unless otherwise
        stated they also apply to C# and Java.
      </p>
      <p>
        Some links: <a
        ref="http://en.wikipedia.org/wiki/Grok">grokking?!</a>, <a
        ref="http://en.wikipedia.org/wiki/The_Hitchhiker's_Guide_to_the_Galaxy">don't
        panic</a>.
      </p>
    </body>

  </section>
    
  

  <section id="base-structure-of-programs">
    <title>Base structure of programs</title>
    <body>
      <p>
        This chapter teaches how does the basic program look like
        in Nemerle.
      </p>
    </body>
    
  
    <subsection id="running-compiler">
      <title>Running the compiler</title>
      <body>
        <p>
          In order to run programs written in Nemerle you first need
          to compile them to .NET bytecode. This is done with the
          <tt>ncc</tt> (Nemerle Compiler Compiler) command. Assuming the 
          Nemerle is installed properly on your system, you need to do
          the following:
        </p>
        <ul>
          <li>
            write the program text with your favorite text editor and
            save it in file with extension <file>.n</file>, for example
            <file>myfile.n</file>
          </li>
          <li>
            run the Nemerle compiler by typing <tt>ncc myfile.n</tt>
          </li>
          <li>
            the output goes to <file>out.exe</file>
          </li>
          <li>
            run it by typing <tt>out</tt> (Windows) or <tt>mono
            out.exe</tt> (Linux)
          </li>
        </ul>
      </body>
    </subsection>

    
    <subsection id="classes">
      <title>Classes and modules</title>
      <body>
        <p>
          You cannot define functions nor values at the top level
          in Nemerle. You need to pack them into <b>classes</b> or
          <b>modules</b>.  For C#, Java and C++ programmers: module is
          a class with all members static, there can be no instance of
          module class.
        </p>
        <p>
          For now you should consider module to be form of packing
          related functions together.
        </p>
<code>
class Foo 
{ 
  // ... some comment ... 
}

module Bar
{
  /* ... some comment ... */
}
</code>
        <p>
          The above example also introduces two kinds of <b>comments</b>
          used in Nemerle. Comments starting with <tt>//</tt> are active
          until end of line, while comments starting with <tt>/*</tt> are
          active until <tt>*/</tt>. This is the same as in C (well, C99).
        </p>
      </body>
    </subsection>
    
    
    <subsection id="methods">
      <title>Methods</title>
      <body>
        <p>
          Modules can contain <b>methods</b> (functions) as well as
          <b>fields</b> (values). Both kind of members can be prefixed
          with access attributes likes <tt>private</tt>, <tt>internal</tt>
          or <tt>public</tt>.
        </p>
        <p>
          <tt>public</tt> defines a method or a field that can be accessed
          from outside the module.
        </p>
        <p>
          <tt>private</tt> defines a member that is local to module.
          This is the default.
        </p>
        <p>
          <tt>internal</tt> defines a member that is local to module a
          given library of executable.
        </p>
        <p>
          In method declaration header you first write modifiers, then
          method's name, them parameters with type specification and
          finally a type of values returned from this function.
        </p>
        <p>
          Typing constraint are in general written after colon
          (<tt>:</tt>).
        </p>
<code>
module Foo
{
  public SomeMethod () : void
  {
    // ...
  }
  private some_other_method (x : int) : int
  {
    // ... 
  }
  private Frobnicate (x : int, y : string) : int
  {
    // ... 
  }
  internal foo_bar () : int
  {
    // ...
  }
}
</code>
      </body>
    </subsection>
    

    <subsection id="fields">
      <title>Fields</title>
      <body>
        <p>
          Fields define global values inside module.
        </p>
        <p>
          Fields accept the same access attributes as methods. However
          there is one additional very important attribute for fields --
          <tt>mutable</tt>.
        </p>
        <p>
          By default fields are read only, that is can be assigned
          values only in the module initializer function (codenamed
          <tt>this</tt>; we will talk about it later). If you want to
          assign values to fields in other places you need to mark field
          <tt>mutable</tt>.
        </p>
<code>
module Bar
{
  public mutable qux : int;
  private quxx : int;
  mutable bar : float;
}
</code>
      </body>
    </subsection>


    <subsection id="expr">
      <title>Expressions</title>
      <body>
        <p>
          There is no expression versus statement distinction in
          Nemerle. There are only expressions. In particular there
          are no jump statements like <tt>break</tt>, <tt>goto</tt>
          or <tt>continue</tt>.
        </p>
        <p>
          There is also no <tt>return</tt> statement. The value returned
          from function is the last value computed in sequence expression
          defining function. You can think that there is implicit
          <tt>return</tt> at the beginning of each function. This is the
          same as in ML.
        </p>
        <p>
          Despite all that, the most basic example looks almost like in C#.
          The entry point for a program is function called <tt>Main</tt>.
          It is also possible to take command line arguments and/or return
          integer return code from the <tt>Main</tt> method, consult .NET
          reference for details.
        </p>
        <p>
          Note that unlike in ML function call requires <tt>()</tt>.
        </p>
<code>
module Hello
{
  Main () : void
  {
    System.Console.WriteLine ("Hello cruel world!")
  }
}
</code>
      </body>  
    </subsection>


    <subsection id="simple-fib">
      <title>Simple function</title>
      <body>
        <p>
          However the following example (computing <a
          ref="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci
          sequence</a>) looks somewhat different. You can see usage of a
          <b>conditional expression</b>. Note how the value is returned
          from function without any explicit <tt>return</tt> statement.
        </p>
        <p>
          Note that this example (and following) are not full. To be
          compiled they need to be packed into the module, equipped with
          <tt>Main</tt> function and so on.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  if (n < 2)
    1
  else
    fib (n - 1) + fib (n - 2)
}]]>
</code>
      </body>
    </subsection>


    <subsection id="def-mutable">
      <title>Imperative loops and value definitions</title>
      <body>
        <p>
          It is possible to use regular <b>imperative loops</b> like
          <tt>while</tt> and <tt>for</tt>. Both work as in C. As for
          the <tt>for</tt> case -- first expression is put before loop,
          second expression is the condition (loop is executed as long
          as the condition holds), and last expression is put at the
          end of the loop.
        </p>
        <p>
          However the most important thing about this example is variable
          definition used there. <b>Variables</b> (values that can be
          changed) are defined using <tt>mutable</tt> expression. You
          do not specify type, but you do specify initial value. Type of
          defined variable is inferred based on initial value (for example
          the type of <tt>1</tt> is obviously an <tt>int</tt>). Variable
          introduced with <tt>mutable</tt> is visible till the end of
          the current sequence. Lexical scoping rules apply -- definition
          of next value with the same name hides the previous one.
        </p>
        <p>
          <b>Sequence</b> is a list of expressions enclosed
          in braces (<tt>{}</tt>) and separated with semicolons
          (<tt>;</tt>). Optional semicolon is allowed at the end of
          the sequence.  Note that function definition also introduces
          a sequence (as the function body is written in <tt>{}</tt>).
        </p>
        <p>
          <tt>mutable</tt> defines <b>variables</b> that can be updated
          using the assignment operator (<tt>&lt;-</tt>). This operator
          works much like <tt>=</tt> in C. In contrast <tt>def</tt>
          defines <b>values</b> that cannot be updated -- in our example
          we use <tt>tmp</tt> as such value.
        </p>
        <p>
          Note the semicolon after <tt>for</tt> expression. As it is
          not the last expression in this sequence, the semicolon is
          required. There is no exception for loops and the semicolon
          rule.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  mutable last1 <- 1;
  mutable last2 <- 1;
  
  for (mutable cur <- 1; cur < n; cur <- cur + 1) {
    def tmp = last1 + last2;
    last1 <- last2;
    last2 <- tmp;
  };

  last2
}]]>
</code>
        <p>
          In this example we see no gain from using <tt>def</tt> instead
          of <tt>int</tt> as you would do in C# (both are 3 characters
          long :-).  However in most cases type names are far longer:
        </p>
<code>
FooBarQuxxFactory fact = new FooBarQuxxFactory (); // C#
def fact = FooBarQuxxFactory (); // Nemerle
</code>
      </body>
    </subsection>


    <subsection id="local-functions">
      <title>Local functions</title>
      <body>
        <p>
          Local functions are functions defined within other functions.
          For this reason they are also called <b>nested functions</b>.
        </p>
        <p>
          There are three reasons to define local functions. First one
          is not to pollute class namespace. We have the <tt>private</tt>
          keyword for that, so this doesn't seem any good reason.
        </p>
        <p>
          The second one is that local functions can access variables
          defined in outer function. This allows for somewhat different
          (better?) code structuring than in C. You can have several
          variables and local functions using them defined in a function.
        </p>
        <p>
          The most important reason for local function is however the
          fact that you can pass them to other functions so they can
          be run from there implementing for example iterators for
          data structures. This is explained in more detail
          <a ref="#functional-values">later</a>.
        </p>
        <p>
          Local functions are defined just like other values with
          the <tt>def</tt> keyword.  Local function definition looks
          similar to global one (despite lack of access modifiers,
          leading <tt>def</tt> and trailing semicolon).
        </p>
<code>
sum_cubes (v1 : int, v2 : int, v2 : int) : int
{
  def cube (x : int) : int {
    x * x * x
  };
  cube (v1) + cube (v2) + cube (v3)
}
</code>
        <p>
          Using local functions is one of way of implementing loops in
          Nemerle.
        </p>
<code>
<![CDATA[module Sum {
  public Main () : void
  {
    def sum (x : int) : int {
      if (x <= 0) 
        0
      else
        x + sum (x - 1)
    };
    System.Console.WriteLine ("Sum of numbers from " +
                              "20 to 0 is: {0}", sum (20));
  }
}]]>
</code>
        <p>
          Notice how the local function is used to organize loop. This
          is typical for Nemerle. It is therefore quite important
          for you to grok this concept. Some external links -- <a
          ref="http://en.wikipedia.org/wiki/Tail_recursion">tail
          recursion</a>, <a
          ref="http://en.wikipedia.org/wiki/Recursion">recursion</a>.
        </p>
        <p>
          Here goes another example of loop constructed with local
          function.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  def my_loop (last1 : int, last2 : int, cur : int) : int {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  };
  my_loop (1, 1, 1)
}]]>
</code>
        <p>
          If you are concerned about performance of this form of writing
          loops -- fear you not. When function body ends with call
          to another function -- no new stack frame is created. It is
          called <b>tail call</b>. Thanks to it the example above is as
          efficient as the <tt>for</tt> loop we seen before.
        </p>
      </body>
    </subsection>


    <subsection id="type-inf">
      <title>Type inference</title>
      <body>
        <p>
          You can specify types of parameters as well as return types
          for local functions. However in some (most?) cases compiler can
          guess (infer) the types for you, so you can save your fingers by
          not typing them. This is always safe, that is program shouldn't
          in principle change meaning if type annotations are added.
        </p>
        <p>
          To guarantee this safeness property type inference sometimes
          fail.  Which means that type annotations are required. This
          mostly manifests itself with error message.
        </p>
        <p>
          In the following example we have omitted return type, as well
          as types of <tt>last2</tt> and <tt>cur</tt> parameters. We
          however have given type to the <tt>last1</tt> parameter.
        </p>
        <p>
          If we omit type for the <tt>last1</tt> parameter, then compiler
          would report error in expression <tt>last1 + last2</tt>
          crying about ,,no match for operator +''. This is because
          the <tt>+</tt> operator is defined not only for integers but
          also for floats, chars and so on. It is also possible to add
          new overloads for this operator. Therefore compiler looks
          for it in class of left and right arguments. And if none is
          found -- it bails out.  However after you specify explicitly
          type for <tt>last1</tt>, the overloading is resolved in
          favor of <tt>+</tt> having type <tt>int * int -> int</tt>
          (so <tt>last2</tt> also becomes an <tt>int</tt>).
        </p>
        <p>
          Other typical cases when type annotation is required is
          using the dot (<tt>.</tt>) operator to access members of
          unknown type, as well as overloading resolution errors. These
          manifest themselves with error messages like ,,no constrain of
          _N_fv36_36* provides member `Foo''' or ,,overloading resolution
          ambiguity''.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  def my_loop (last1 : int, last2, cur) {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  };
  my_loop (1, 1, 1)
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="ext-fun">
      <title>External functions</title>
      <body>
        <p>
          One of the best things about Nemerle is that you can use rich
          class libraries that come with the Framework as well as the
          third party libraries. Links to documentation about .NET class
          libraries can be found <a ref="#class-docs">here</a>.
        </p>
        <p>
          New objects are constructed by simply naming the type and
          supplying arguments to its constructor. Note that unlike
          in C# or Java you don't use the <tt>new</tt> keyword to
          construct new objects. Later methods of objects can be
          invoked using the dot operator (<tt>some_object.SomeMethod
          (some_argument)</tt>).  Static methods are invoked using the
          <tt>NameSpace.TypeName.MethodName ()</tt> syntax.  We will
          talk more about this object oriented stuff later.
        </p>
        <p>
          We use two methods of formatting output here. One is
          <tt>System.Console.WriteLine</tt> (a function from the .NET
          Framework). When given more then one argument it replaces
          occurrences of <tt>{N}</tt> with (N+2)-th parameter (counting
          from one).
        </p>
        <p>
          Second is <tt>printf</tt> macro, that works much like the
          <tt>printf(3)</tt> C function, or <tt>Printf.printf</tt>
          in OCaml.
        </p>
        <p>
          For more information about <i>The answer to the Ultimate
          Question of Life, the Universe and Everything</i> please visit <a
          ref="http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything">this
          site</a>. Please note, that this program, run on computer not as powerful as
          Deep Thought, will be right only in 1% of cases.
        </p>
<code>
<![CDATA[the_answer_to_the_universe () : int
{
  // Construct new random number generator.
  def r = System.Random ();
  // Return new random number from [0, 99] range.
  r.Next (100)
}

print_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  System.Console.WriteLine ("The answer to the Ultimate " +
                            "Question of Life, the " +
                            "Universe and Everything " +
                            "is {0}", the_answer)
}

printf_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  printf ("The answer is %d\n", the_answer);
}]]>
</code>
      </body>
    </subsection>


    <subsection id="array">
      <title>Arrays</title>
      <body>
        <p>
          Type of array of <meta>T</meta> is denoted <tt>array
          &lt;<meta>T</meta>></tt>.  This is one-dimensional, zero-based
          array. There are two special expressions for constructing new
          arrays: <tt>array ["foo", "bar", "baz"]</tt> will construct
          3-element array or strings, while <tt>array (100)</tt> creates
          100-element array of something. The ,,something'' is inferred
          later, based on array usage.  The array is initialized with
          <tt>0</tt>, <tt>0.0</tt> or <tt>null</tt> for reference types.
        </p>
        <p>
          One interesting thing about this example is usage of the type
          enforcement operator -- colon (<tt>:</tt>). We use it to enforce
          <tt>left</tt> type to be int. We could have as well write
          <tt>def loop (left : int, right) {</tt>. There are simply two
          ways to achieve this.
        </p>
        <p>
          Another interesting thing is the <tt>when</tt> expression -- it
          is <tt>if</tt> without <tt>else</tt>.  For symmetry we also have
          <tt>if</tt> without <tt>then</tt> called <tt>unless</tt>. As
          you might have already noted <tt>unless</tt> is equivalent to
          <tt>when</tt> with condition negated.
        </p>
        <p>
          In Nemerle the <tt>if</tt> expression always need to have the
          <tt>else</tt> clause. It's done this way to avoid stupid bugs
          with dangling-else:
        </p>
<code>
// C#, misleading indentation hides real code meaning
if (foo)
   if (bar)
     m1 ();
else
   m2 ();
</code>
        <p>
          If you do not want the <tt>else</tt> clause, use
          <tt>when</tt> expression, as seen in the example. There is
          also <tt>unless</tt> expression, equivalent to <tt>when</tt>
          with condition negated.
        </p>
        <p>
          The assignment operator (<tt>&lt;-</tt>) can be also used to
          assign elements in arrays.
        </p>
        <p>
          Note the <tt>ar.Length</tt> expression -- it gets length of
          array <tt>ar</tt>. It looks like a field reference in array
          object but under the hood it is a method call. This mechanism
          is called ,,property''.
        </p>
        <p>
          Our arrays are subtypes of <tt>System.Array</tt> so all methods
          available for <tt>System.Array</tt> are also available for
          <tt>array &lt;<meta>T</meta>></tt>.
        </p>
<code>
<![CDATA[module M {
  reverse_array (ar : array <int>) : void
  {
    def loop (left, right) {
      when ((left : int) < right) {
        def tmp = ar[left];
        ar[left] <- ar[right];
        ar[right] <- tmp;
        loop (left + 1, right - 1)
      }
    };
    loop (0, ar.Length - 1)
  }

  print_array (ar : array <int>) : void
  {
    for (mutable i <- 0; i < ar.Length; i <- i + 1)
      printf ("%d\n", ar[i])
  }

  Main () : void
  {
    def ar = array [1, 42, 3];
    print_array (ar);
    printf ("\n");
    reverse_array (ar);
    print_array (ar);
  }
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="misc_1">
      <title>Miscellaneous information</title>
      <body>
        <p>
          The equality predicate is written <tt>==</tt> and the
          inequality is <tt>!=</tt> as in C.
        </p>
        <p>
          The boolean operators (<tt>&amp;&amp;</tt>, <tt>||</tt> and
          <tt>!</tt>) are all available and works the same as in C.
        </p>
      </body>
    </subsection>
    

    <subsection id="exercises_1">
      <title>Exercises -- List 1</title>
      <body>
        <p>
          <b>1.1.</b> Write a program that prints out to the console:
        </p>
<code>
1 bottle of beer.
2 bottles of beer.
3 bottles of beer.
...
99 bottles of beer.
</code>
        <p>
          With appropriate amount of beer instead of <tt>...</tt>. Program
          source code shouldn't exceed 30 lines.
        </p>
        <p>
          <b>1.2.</b> Implement <a
          ref="http://www.catb.org/~esr/jargon/html/B/bogo-sort.html">bogo
          sort</a> algorithm for array of integers. (WARNING: you
          should not implement ,,destroy the universe'' step). Test it
          by sorting the following array: <tt>[4242, 42, -42, 31415]</tt>.
        </p>
        <p>
          <b>1.3.</b> As 1.2, but don't use the imperative loops --
          rewrite them with recursion.
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="namespaces">
    <title>Namespaces</title>
    <body>
      <p>
      </p>
    </body>

    <subsection id="namespaces-intro">
      <title>Namespaces</title>
      <body>
        <p>
          Classes and modules can be put in namespaces. Namespaces at
          the conceptual level prepend a string to names of objects
          defined within them.
        </p>
<code>
namespace Deep.Thought
{
  module Answer
  {
    public Get () : int
    {
      42
    }
  }
}

namespace Loonquawl
{
  module Brain
  {
    Main () : void
    {
      System.Console.WriteLine ("The answer {0}", 
                                Deep.Thought.Answer.Get ())
    }
  }
}
</code>
        <p>
          As you can see we the name of the <tt>Get</tt> function
          is first prepended with name of the module (<tt>Answer</tt>)
          and then with current namespace (<tt>Deep.Thought</tt>),
          forming it's full name: <tt>Deep.Thought.Answer.Get</tt>.
        </p>
        <p>
          Another example is the <tt>WriteLine</tt> method of the
          <tt>Console</tt> module, defined in the <tt>System</tt>
          namespace.
        </p>
      </body>
    </subsection>


    <subsection id="using">
      <title>Making long names short</title>
      <body>
        <p>
          In order not to write <tt>System.Console.WriteLine</tt> or
          <tt>Deep.Thought.Answer.Get</tt> all the time one can import
          all declarations from the specified namespace into current
          scope with the <tt>using</tt> directive.
        </p>
        <p>
          So the <tt>Loonquawl.Brain</tt> module from the example
          above could be:
        </p>
<code>
<![CDATA[namespace Loonquawl
{
  using System.Console;
  using Deep.Thought.Answer;
  
  module Brain
  {
    Main () : void
    {
      WriteLine ("The answer {0}", Get ())
    }
  }
}
]]>
</code>
        <p>
          While we see not much gain from the <tt>using</tt>
          directive in this example, it can be handy when you use the
          <tt>WriteLine</tt> method 100 times, and/or your classes are
          in <tt>Some.Very.Long.Namespaces</tt>.
        </p>
        <p>
          Note that unlike in C# one can import all methods of a class
          into current namespace. That is <tt>using</tt> is not limited
          to namespaces, but it also works for classes.
        </p>
        <p>
          It is also possible to create (shorter) aliases for
          namespaces and modules. It is sometimes useful in case when
          two namespaces share several types, so they cannot be imported
          with <tt>using</tt> simultaneously.
        </p>
<code>
<![CDATA[namespace Loonquawl
{
  namespace SC = System.Console;
  namespace DTA = Deep.Thought.Answer;
  
  module Brain
  {
    Main () : void
    {
      SC.WriteLine ("The answer {0}", DTA.Get ())
    }
  }
}
]]>
</code>
      </body>
    </subsection>
  </section>


  
  <section id="functionals">
    <title>Functionals</title>
    <body>
      <p>
      </p>
    </body>

    <subsection id="functional-values">
      <title>Functional values</title>
      <body>
        <p>
          In Nemerle one can pass functions as arguments of other
          functions, as well as return them as results. This way functions
          are not worse then any other data types (think about Equal
          Rights for Functions movement :-)
        </p>
        <p>
          In C# one have delegates. This concept is quite similar to
          functional values.  However functional values are far more
          efficient and their types need not be declared before use.
        </p>
        <p>
          As a first example consider:
        </p>
<code>
// C#
delegate int IntFun (int);

class M {
  static int f(int x)
  {
    return x * 2;
  }

  static int run_delegate_twice(IntFun f, int v)
  {
    return f(f(v));
  }
  
  static void Main ()
  {
    System.Console.WriteLine("{0}", 
                   run_delegate_twice(new IntFun (f), 3));
  }
}
</code>
<code>
// Nemerle
module M {
  f (x : int) : int
  {
    x * 2
  }

  run_funval_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }
  
  Main () : void
  {
    System.Console.WriteLine ("{0}", run_funval_twice (f, 3))
  }
}
</code>
        <p>
          In this example delegates seem just like function pointers
          in C.  Functional values don't present any better, except
          maybe shorter syntax.  However real power of delegates comes
          from the fact that one can use methods as delegates (thus
          effectively embedding the <tt>this</tt> pointer in delegate).
          This is much like "functional objects" design pattern in C++.
          We won't show it here, please refer to C# manual for details.
        </p>
        <p>
          Still using methods as delegates doesn't show their full power.
          The funny part begins when we use nested functions as functional
          values.
        </p>
<code>
module M {
  run_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }

  run_adder (x : int) : void
  {
    def f (y : int) : int { x + y };
    System.Console.WriteLine ("{0}", run_twice (f, 1))
  }

  Main () : void
  {
    run_adder (1);
    run_adder (2);
  }
}
</code>
        <p>
          This example prints 3 and 5. Note how <tt>x</tt> is captured in local
          function <tt>f</tt>.
        </p>
        <p>
          Types of functions taking more then one argument are represented
          as tuples. For example the following functions:
        </p>
<code>
some_function (arg_1 : int, arg_2 : string, arg_3 : Foo) : float
{
   // ...
}
</code>
        <p>
          has type <tt>int * string * Foo -> float</tt>. Functions that take no
          arguments pretend to take one argument of type <tt>void</tt>. That is
          function:
        </p>
<code>
other_function () : string { ... }
</code>
        <p>
          posses type <tt>void -> string</tt>.
        </p>
        <!-- TODO: mention iterators -->
      </body>
    </subsection>
    
      
    <subsection id="lambda-expr">
      <title>Lambda expressions</title>
      <body>
        <p>
          Lambda expression are just syntactic sugar to defined unnamed
          local functions. Unnamed local functions are useful when you
          need to pass some function to iterator, so you use it just once.
        </p>
        <p>
          Lambda expression are defined using the <tt>fun</tt> keyword,
          followed by formal parameters, optional return type and
          function body.
        </p>
<code>
def x = List.Map ([1, 2, 3], fun (x) { 2 * x });
def y = List.FoldLeft (x, 0, fun (val : int, acc) { acc + val });
assert (y == 12);
</code>
        <p>
          In general:
        </p>
<code>
fun (<meta>parms</meta>) { <meta>exprs</meta> }
</code>
        <p>
          Is equivalent to:
        </p>
<code>
{ 
  def tmp (<meta>parms</meta>) { <meta>exprs</meta> };
  tmp
}
</code>
        <p>
          This feature is similar to anonymous delegates in C# 2.0.
        </p>
      </body>
    </subsection>


    <subsection id="exercises_2a">
      <title>Exercises</title>
      <body>
        <p>
          <b>2.1</b>. Write a function
        </p>
<code>
string_pow : int * (string -> string) * string -> string
</code>.
        <p>
          The call <tt>string_pow (3, f, "foo")</tt> should result
          in calling <tt>f</tt> three times, i.e. returning result
          of <tt>f (f (f ("foo")))</tt>. When you are done write second
          version of <tt>string_pow</tt> using recursion (if you used
          imperative loop) or imperative loop (otherwise). 
        </p>
        <p>
          Test it by passing function that replaces "42"
          with "42ans". You can try passing the functional
          argument to <tt>string_pow</tt> as lambda expression. <a
          ref="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfSystemStringClassReplaceTopic.asp">This
          method</a> might be useful.
        </p>
      </body>
    </subsection>
  </section>


  
  <section id="various-data-structures">
    <title>Various data structures</title>
    <body>
      <p>
      </p>
    </body>
    
    <subsection id="tuple">
      <title>Tuples</title>
      <body>
        <p>
          Tuples are form of nameless data structures. They are usable
          when you need to return two or three values from function.
        </p>
        <p>
          Tuple is constructed with:
        </p>
<code>
(<meta>expr1</meta>, <meta>expr2</meta>, ..., <meta>exprN</meta>)
</code>
        <p>
          and deconstructed with:
        </p>

<code>
def (<meta>id1</meta>, <meta>id2</meta>, ..., <meta>idN</meta>) = <meta>expr</meta>;
</code>
        <p>
          This <tt>def</tt> thing defines values called <meta>id1</meta>
          through <meta>idN</meta> and puts respective tuple members
          into them.
        </p>
        <p>
          Tuple types are written using the <tt>*</tt> operator. For
          example pair of integers <tt>(42, 314)</tt> has type <tt>int
          * int</tt>, while <tt>("Zephod", 42.0, 42)</tt> has type
          <tt>string * float * int</tt>.
        </p>
        <p>
          An example follows:
        </p>
<code>
/** Parses time in HH:MM format. */
parse_time (time : string) : int * int
{
  def arr = time.Split (array [':']);
  (System.Int32.Parse (arr[0]), System.Int32.Parse (arr[1]))
}

seconds_since_midnight (time : string) : int
{
  def (hours, minutes) = parse_time (time);
  (hours * 60 + minutes) * 60
}

foo () : void
{
  def secs = seconds_since_midnight ("17:42");
  ...
}
</code>
        <p>
          Another example could be:
        </p>
<code>
// split (3.7) => (3, 0.7)
split (x : double) : int * double
{
  def floor = System.Math.Floor (x);
  (System.Convert.ToInt32 (floor), x - floor)
}
</code>
      </body>
    </subsection>
    
        
    <subsection id="list-literals">
      <title>List literals</title>
      <body>
        <p>
          List literals are special forms of writing lists. Lists are data
          structure that is very often used in Nemerle. Often enough to
          get own syntax. Lists in Nemerle are somewhat different then
          the <tt>ArrayList</tt> type in .NET.
        </p>
        <ul>
          <li>
            lists in Nemerle are immutable (cannot be changed once
            created)
          </li>
          <li>
            one can only append items at the beginning (constructing
            new lists)
          </li>
        </ul>
        <p>
          Of course you are free to use .NET <tt>ArrayList</tt>.
        </p>
        <p>
          Anyway to construct list consisting of given head (first element)
          and tail (rest of elements, also a list), write:
        </p>
<code>
<meta>head</meta> :: <meta>tail</meta>
</code>
        <p>
          To construct list with specified elements write:
        </p>
<code>
[ <meta>element_1</meta>, <meta>element_2</meta>, ..., <meta>element_n</meta> ]
</code>
        <p>
          This way you can also construct empty list (<tt>[]</tt>).
        </p>
      </body>
    </subsection>
  </section>
    


  <section id="variants-and-matching">
    <title>Variants and matching</title>
    <body>
      <p>
        Variants (called data types or sum types in
        <a ref="http://www.smlnj.org/">SML</a> and <a
        ref="http://www.ocaml.org">OCaml</a>) are forms of expressing
        data that comes in several different kinds. 
      </p>
      <p>
        Matching is way of destructuring complex data structures,
        especially variants.
      </p>
    </body>
    
    <subsection id="variants">
      <title>Variants</title>
      <body>
        <p>
          Simplest example of variants are enum types known from C.
        </p>
<code>
// C
enum Color {
  Red, 
  Yellow, 
  Green 
}
</code>
<code>
// Nemerle
variant Color {
  | Red 
  | Yellow 
  | Green 
}
</code>
        <p>
          However variant options can carry a value.
        </p>
<code>
variant Color {
  | Red
  | Yellow
  | Green
  | Different { 
      red : float; 
      green : float; 
      blue : float; 
    }
}
</code>
        <p>
          So if color isn't neither red, yellow nor green, it can be
          represented with RGB.
        </p>
        <p>
          You can think about variants as of union with selector in C. In
          OO world one can sometimes see modeling variants with sub classing:
        </p>
<code>
// C#
class Color { }
class Red : Color { }
class Green : Color { }
class Yellow : Color { }
class Different : Color {
  float red;
  float green;
  float blue;
}
</code>
        <p>
          Of course you need to write constructor, mark fields
          <tt>public</tt> and so on. When you're done, using this kind
          of stuff is quite hard -- you need to use lots of runtime type
          checks.
        </p>
        <p>
          On the other hand Nemerle provides easy and convenient method of
          dealing with variants -- pattern matching.
        </p>
      </body>
    </subsection>


    <subsection id="matching">
      <title>Matching</title>
      <body>
        <p>
          <b>Pattern matching</b> is accomplished with the <tt>match</tt>
          expression. Its semantics is to check each pattern in turn,
          from top to bottom, and execute expression after first pattern
          that matched. If no pattern matched, exception is raised.
          This is like the <tt>switch</tt> statement known from C,
          but using large dose of steroids.
        </p>
<code>
string_of_color (color : Color) : string
{
  match (color) {
    | Red => "red"
    | Yellow => "yellow"
    | Green => "green"
    | Different (r, g, b) => 
      System.String.Format ("rgb({0},{1},{2})", r, g, b)
  }
}
</code>
        <p>
          The main idea behind patterns is that they match values that
          look like them. For example Nemerle compiler creates default
          constructor for the <tt>Different</tt> variant option with
          the following body:
        </p>
<code>
<![CDATA[public this (red : float, green : float, blue : float)
{
  this.red <- red;
  this.green <- green;
  this.blue <- blue;
}]]>
</code>
        <p>
          Therefore constructor call <tt>Different (r, g, b)</tt> create
          new variant option instance with specified arguments. The
          pattern looks the same -- it binds actual values of
          <tt>red</tt>, <tt>green</tt> and <tt>blue</tt> fields to
          <tt>r</tt>, <tt>g</tt> and <tt>b</tt> respectively. You can
          also spell the field's names explicitly:
        </p>
<code>
  | Different { red = r; green = g; blue = b; } => 
    System.String.Format ("rgb({0},{1},{2})", r, g, b)
</code>
      </body>
    </subsection>


    <subsection id="other-patterns">
      <title>Other patterns</title>
      <body>
        <p>
          We have already seen a so called ,,<b>constructor pattern</b>''
          in action.  It is used to match over variants. Constructor
          pattern consists of variant option name (it starts with
          uppercase letter) followed by optional tuple or record pattern.
        </p>
<code>
// examples of constructor patterns
// plain one, without sub-pattern:
Red 
// followed by tuple pattern:
Different (r, g, b)
// followed by record pattern:
Different { red = r; green = g; blue = b; }
</code>
        <p>
          The <b>variable pattern</b> matches any value, and binds
          it to specified variable. Variable pattern is an identifier
          starting with lowercase letter. Their are used mostly inside
          other patterns, but here we give (a rather pointless) example
          of using them as the top-level pattern:
        </p>
<code>
// it prints 42
match (42) {
  | x => // here x is bound to 42
    printf ("%d\n", x)
}
</code>
        <p>
          The <b>throw-away pattern</b>, written <tt>_</tt>. It matches
          any value, and has no further effects. It is a way of specifying
          the <tt>default:</tt> case in matching.
        </p>
<code>
match (color) {
  | Red => "red"
  | _ => "other"
}
</code>
        <p>
          The <b>tuple pattern</b> consists of one or more patterns
          separated by commas and surrounded by parens. We have
          already used them in <a ref="#tuple">section about tuples</a>
          above. There they were used in <tt>def</tt> expressions.
        </p>
<code>
// matches any pair, binding its elements
// to specified variables
(first_element, second_element)

// matches a pair whose first element is Foo
(Foo, _) 
</code>
        <p>
          The <b>record pattern</b> consists of zero or more named
          patterns separated by semicolons enclosed in braces. It matches
          a class, values of fields of which are matched by sub-patterns.
        </p>
<code>
class Foo {
  public number : int;
  public name : string;
}

StringOfFoo (f : Foo) : string
{
  if (f.name == "")
    f.number.ToString ()
  else
    f.name
}

// do the same as above
StringOfFooMatch (f : Foo) : string
{
  match (f) {
    | { name = ""; number = k } =>
      k.ToString ()
    | { name = s } => 
      s
  }
}
</code>
        <p>
          It might be doubtful if <tt>string_of_foo_match</tt> is any
          better then <tt>string_of_foo</tt>. Record patterns are mostly
          useful when used inside complex pattern, or when they contain
          complex patterns.
        </p>
        <p>
          The <b>literal pattern</b> is a integer, character or string
          constant. It matches the exact specified value.
        </p>
<code>
StringOfInt (n : int) : string
{
  match (n) {
    | 0 => "null"
    | 1 => "one"
    | 2 => "two"
    | 3 => "three"
    | _ => "more"
  }
}

IntOfString (n : string) : int
{
  | "null" => 0
  | "one" => 1
  | "two" => 2
  | "three" => 3
  | _ => 42
}
</code>
        <p>
          Note lack of <tt>match</tt> in second example. When function
          body starts with <tt>|</tt> -- the <tt>match</tt> expression
          is automagically inserted.
        </p>
        <p>
          The <b>as pattern</b> tries to match value with pattern enclosed
          within it, and in case of success binds value that matched to
          specified variable. We'll see it later.
        </p>
      </body>
    </subsection>
    
        
    <subsection id="variant-trees">
      <title>Using variants as trees</title>
      <body>
        <p>
          The example above, while simple, isn't best usage of
          variants. Variants are best at handling tree-like data
          structures.  A common example of tree data structures are XML
          documents.  However we will first deal with plain binary trees.
        </p>
        <p>
          The following example defines type of trees of integers
          (representing sets).
        </p>
<code>
<![CDATA[variant Tree {
  | Node {
      left  : Tree;
      elem  : int;
      right : Tree;
    }
  | Null
}

// return tree t with element e inserted
Insert (t : Tree, e : int) : Tree
{
  match (t) {
    | Node (l, cur, r) =>
      if (e < cur)
        Node (insert (l, e), cur, r)
      else if (e > cur)
        Node (l, cur, insert (r, e))
      else
        // node already in the tree,
        // return the same tree
        t
    | Null =>
      Node (Null (), e, Null ())
  }
}]]>
</code>
<code>
<![CDATA[// check if specified integer is in the tree
Contains (t : Tree, e : int) : bool
{
  match (t) {
    | Node (l, cur, r) when e < cur => 
      Contains (l, e)
    | Node (l, cur, r) when e > cur => 
      Contains (r, e)
    | Node => true
    | Null => false
  }
}]]>
</code>
      </body>
    </subsection>
    
        
    <subsection id="xml-trees">
      <title>XML trees</title>
      <body>
        <p>
          As you can see binary trees ain't very interesting, so we'll go
          to XML. If XML is interesting remains a doubtful question, but
          at least is somewhat more practical.
        </p>
<code><![CDATA[
variant Node {
  | Text { 
      value : string; 
    }
  | Element {
      name : string; 
      children : list <Node>;
    }
}]]>
</code>
        <p>
          This variant defines simplistic data structure to hold XML trees.
          An XML node is either a text node with specified text inside,
          or an element node, with a name and zero or more children.
          Sequence of children is represented as a Nemerle list data structure
          (Nemerle has even <a ref="#list-literals">special syntax</a> for lists).
          The type is written here <tt>list &lt;Node></tt> -- a list of nodes.
          We will learn about polymorphic variants more later.
        </p>
        <p>
          For example the following tree:
        </p>
<code><![CDATA[<tree>
  <branch>
    <leaf/>
  </branch>
  <branch>
    Foo
  </branch>
</tree>]]>
</code>
       <p>
         would be represented by:
       </p>
<code><![CDATA[Element ("tree", 
  [Element ("branch", [Element ("leaf", [])]),
   Element ("branch", [Text ("Foo")])])]]>
</code>

       <p>
         Of course XML by itself is just a data format. Using data in the
         above form wouldn't be too easy. So we want some different internal
         representation of data, and use XML only to save it or send it over
         the network.
       </p>
<code><![CDATA[class Refrigerator
{
  minimal_temperature : float;
  content : list <RefrigeratorContent>;
}

variant RefrigeratorContent
{
  | Beer { name : string; volume : float; }
  | Chips { weight : int; }
  | Ketchup
}]]>
</code>
       <p>
         Now we'll write simple XML parsing function.
       </p>
<code><![CDATA[ParseRefrigerator (n : Node) : Refrigerator
{
  | Element ("refrigerator", 
      Element ("minimal-temperature", [Text (min_temp)]) 
            :: content) =>
        Refrigerator (System.Float.Parse (min_temp), 
                      ParseRefrigeratorContent (content))
  | _ =>
    throw InvalidArgumentException ()
}

ParseRefrigeratorContent (nodes : list <Node>) 
  : list <RefrigeratorContent>
{
  | [] => []
  
  | node :: rest =>
    def food =
      match (node) {
        | Element ("ketchup", []) =>
          Ketchup ()
          
        | Element ("beer", 
            [Element ("name", [Text (name)]),
             Element ("volume", [Text (volume)])]) =>
          Beer (name, System.Float.Parse (volume))
          
        | Element ("chips",
            [Element ("weight", [Text (weight)])]) =>
          Chips (System.Int32.Parse (weight))
          
        | _ =>
          throw InvalidArgumentException ()
      };
    food :: ParseRefrigeratorContent (rest)
}]]>
</code>
        <p>
          The reader will easily note that a) this code looks a bit
          like a junk, b) it can be generated automatically and c) in C#
          it would be even worse. At some later date we'll learn how to
          write macros to generate this kind of code automatically. 
        </p>
        <p>
          But let's leave the ideology behind. 
          There are probably few interesting things about this example. First is usage of
          list patterns and constructors. We can check if list is empty, and if not deconstruct
          it with the following code:
        </p>
<code>
match (l) {
  | [] => 
    // the list is empty
    // ...
  | head :: rest =>
    // the list isn't empty, the first element 
    // of the list is bound to the 'head' variable
    // and the rest of the list to 'rest'
    // ...
}
</code>
        <p>
          We can also construct new lists with <tt>::</tt> operator --
          it prepends element to existing list. If we know all list
          elements in advance we can use the <tt>[ ... ]</tt> thing in
          both expressions and patterns.
        </p>
        <p>
          The second interesting thing is that we throw an exception in
          case of problems. We'll talk about it later, for now assume, it just
          terminates the program with an error message.
        </p>
      </body>
    </subsection>
    
    <subsection id="exercises_2b">
      <title>Exercises</title>
      <body>
        <p>
          <b>2.2</b> (2 points). Write a function that reads XML 
          from specified files and puts it into the <tt>Node</tt> variant
          defined above. Then write function to dump your data in
          lispy format, something like this:
        </p>
<code><![CDATA[(tree
(branch
(leaf)
)
(branch
($text "Foo")
)
)]]>
</code>
        <p>
          For an extra point implement indentation of output.
        </p>
<code><![CDATA[(tree
  (branch
    (leaf))
  (branch
    ($text "Foo")))]]>
</code>
        <p>
          Then copy the Parser functions from above, fix any errors you'll
          find in them and try to parse the following file:
        </p>
<code><![CDATA[<?xml version='1.0' encoding='utf-8' ?>
<refrigerator>
  <minimal-temperature>-3.0</minimal-temperature>
  <beer>
    <name>Hyneken</name>
    <volume>0.6</volume>
  </beer>
  <beer>
    <name>Bydweisser</name>
    <volume>0.5</volume>
  </beer>
  <beer>
    <name>Plsner</name>
    <volume>0.5</volume>
  </beer>
  <chips>
    <weight>500</weight>
  </chips>
  <ketchup/>
</refrigerator>]]>
</code>
        <p>
          Warning: you don't need to write the
          XML parser. Even you should not do it.  Use the <a
          ref="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemxml.asp">System.Xml</a>
          namespace from the .NET Framework. In order to link with System.Xml library
          you need to compile with <tt>-r System.Xml</tt> option. For example:
        </p>
<code>
ncc -r System.Xml myprogram.n
</code>
        <p>
          should do.
        </p>
      </body>
    </subsection>
  </section>


  <section id="lecture_3">
    <title>The rest</title>

    <subsection id="named-parms">
      <title>Named parameters</title>
      <body>
        <p>
          This feature (in this form) comes from <a
          ref="http://www.python.org/">python</a>.  When you call a
          function you can name some of its parameters (which allows
          putting them in different order then in definition).
        </p>
<code>
<![CDATA[frobnicate (foo : int, do_qux : bool, 
                       do_baz : bool, 
                       do_bar : bool) : int
{
  // The method body doesn't mean anything ;-)
  if (do_qux && !do_baz) foo * 2
  else if (do_bar) foo * 7
  else if (do_baz) foo * 13
  else 42
}

Main () : void
{
  // Parameters' names can be omitted.
  def res1 = frobnicate (7, true, false, true);
  
  // This is the indented usage -- the first 
  // (main) parameter comes without a name
  // and the following flags with names
  def res2 = frobnicate (7, do_qux = true,
                            do_baz = false, 
                            do_bar = true);
                            
  // You can however name every parameter:
  def res3 = frobnicate (foo = 7, do_qux = true, 
                         do_baz = false, do_bar = true);
                         
  // And permute them:
  def res3 = frobnicate (do_qux = true, do_bar = true, 
                         do_baz = false, foo = 7);
                         
  // You can also omit names for any number of leading 
  // parameters and permute the trailing ones.
  def res2 = frobnicate (7, true,
                            do_bar = true,
                            do_baz = false);
  ()
}]]>
</code>
        <p>
          The rules behind named parameters are simple:
        </p>
        <ul>
          <li>
            named parameters must come after all unnamed (positional)
            parameters
          </li>
          <li>
            positional parameters are assigned first
          </li>
          <li>
            the remaining parameters are assigned based on their names
          </li>
        </ul>
        <p>
          Named parameters can be used only when names of parameters are
          known (which basically mean they do not work in conjunction
          with functional values).
        </p>
      </body>
    </subsection>
    
    
    <subsection id="void-value">
      <title>The void literal</title>
      <body>
        <p>
          The void literal is written: <tt>()</tt>.
        </p>
        <p>
          The void literal is quite tricky thing, since it represents
          the only value of type <tt>void</tt>, which judging from the
          name should be ergh... void. In fact in some other functional
          languages this type is called <tt>unit</tt>, but in Nemerle
          the name comes from <tt>System.Void</tt> for which the
          <tt>void</tt> type is alias for.
        </p>
        <p>
          In C# the <tt>void</tt> type is used as return type of
          functions. It doesn't make much sense to use it elsewhere.
          It could be needed however if for example you want to use
          <tt>Hashtable &lt;a, b&gt;</tt> type as a set representation of
          let's say strings. You can use <tt>Hashtable &lt;string, void&gt;</tt>
          then. And this is the place to use the void value -- when you
          call set method, you need to pass something as value to set --
          and you pass the void value.
        </p>
        <p>
          You can also use void value to return it from function -- as you
          remember the return value of function is the last expression
          in its body. However in most cases the last expression will
          already have the right <tt>void</tt> type.
        </p>
      </body>
    </subsection>

    <subsection id="macros">
      <title>Macros</title>
      <body>
        <p>
          Nemerle has very powerful code-generating macros. They are more
          akin to Lisp macros than macros found in C preprocessor. We're not
          going to explain here how to write macros (if you are curious,
          please see <link>macros.html</link>), but will describe few
          often used macros.
        </p>
        <p>
          First of all <tt>if</tt>, <tt>while</tt>, <tt>for</tt>,
          <tt>foreach</tt>, <tt>when</tt>, <tt>using</tt>, <tt>lock</tt>,
          etc are all macros.
        </p>
        <p>
          Other examples of macros:
        </p>
        <ul>
          <li>
            <tt>printf</tt>, <tt>sprintf</tt> -- uses similar syntax to
            the same function in C, but is checked at the compile time
          </li>
          <li>
            <tt>scanf</tt> -- likewise
          </li>
          <li>
            <tt>print</tt> -- it does the $-expansion known from shell
            or perl, we're working on it
          </li>
          <li>
            <tt>assert</tt> -- much like the C macro
          </li>
        </ul>
      </body>
    </subsection>
    
  </section>
  

  <section id="objects">
    <title>Object oriented programming</title>
    <body>
      <p>
        Once again a <a
        ref="http://en.wikipedia.org/wiki/Object-oriented_programming">definition</a>
        from Wikipedia. 
      </p>
      <p>
        OOP is all about <a
        ref="http://en.wikipedia.org/wiki/Object_(computer_science)">objects</a>.
        Objects consists of some data and methods to operate on this data.
        In functional programming one have functions (algorithm) and
        data. The things are separate. One can think about objects as
        of records (structures) with attached functions.
      </p>
      <p>
        Nemerle allows programmers to program in this style. Moreover
        the class library is very deeply object oriented. Therefore OOP
        is unavoidable in Nemerle.
      </p>
    </body>

    
    <subsection id="refrigerator-oop">
      <title>Back in the Refrigerator</title>
      <body>
        <p>
          When <a ref="#xml-trees">talking about XML</a> we have shown
          example of refrigerator. It was a degenerated object --
          a record. Record is a bunch of data, or object without methods.
          Now we will try to extend it a bit.
        </p>
<code><![CDATA[class Refrigerator
{
  public mutable minimal_temperature : float;
  public mutable content : list <RefrigeratorContent>;

  public AddContent (elem : RefrigeratorContent) : void
  {
    this.content <- elem :: this.content
  }
}

variant RefrigeratorContent
{
  | Beer { name : string; volume : float; }
  | Chips { weight : int; }
  | Ketchup
}]]>
</code>
        <p>
          Now, in addition to fields with content and temperature,
          the refrigerator has a method for adding new content.
        </p>
        <p>
          The definition of method looks much like definition of function
          within module.
        </p>
        <p>
          class vs object
        </p>
        <p>
          this
        </p>
        <p>
          no this, public
        </p>
<code><![CDATA[public AddContent (elem : RefrigeratorContent) : void
{
  content <- elem :: content
}]]>
</code>
        <p>
          ctor, default ctor
        </p>
<code><![CDATA[public this ()
{
  minimal_temperature <- -273.15;
  content <- [];
}]]>
</code>
        <p>
          calling ctor and methods
        </p>
<code><![CDATA[module Party {
  Main () : void
  {
    def refr = Refrigerator ();
    refr.AddContent (Beer ("Tiskie", 0.60));
    refr.AddContent (Ketchup ());
  }
}]]>
</code>
        <p>
          Fortunately objects are not just a fancy notation for function
          application on records.
        </p>
      </body>
    </subsection>
    

    <subsection id="inheritance">
      <title>Inheritance</title>
      <body>
        <p>
          Classes can <a
          ref="http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">inherit</a>
          from other classes.
        </p>
        <p>
          call methods from parent, base ctor
        </p>
<code><![CDATA[class RefrigeratorWithRolls : Refrigerator
{
  public mutable position_x : int;
  public mutable position_y : int;

  public MoveBy (dx : int, dy : int) : void
  {
    position_x <- position_x + dx;
    position_y <- position_y + dy;
  }

  public MoveToBedroom () : void
  {
    position_x <- 42;
    position_y <- -42;
  }

  public this ()
  {
    base ();
    
    position_x <- 0;
    position_y <- 0;
  }
}

module TheDayAfter
{
  Main () : void
  {
    def refr = RefrigeratorWithRolls ();
    for (mutable i <- 0; i < 10; i <- i + 1)
      refr.AddContent (Beer ("Liech", 0.5));
    refr.MoveToBedroom ();
    // drink
  }
}]]>
</code>
 
      </body>
    </subsection>
    
    
    <subsection id="callvirt">
      <title>Virtual calls</title>
      <body>
        <p>
          virtual, override
        </p>
<code><![CDATA[class Refrigerator
{
  public mutable minimal_temperature : float;
  public mutable content : list <RefrigeratorContent>;

  public virtual AddContent (elem : RefrigeratorContent) : void
  {
    this.content <- elem :: this.content
  }
  
  public this ()
  {
    minimal_temperature <- -273.15;
    content <- [];
  }
}

class RestrictedRefrigerator : Refrigerator
{
  public override AddContent (elem : RefrigeratorContent) : void
  {
    match (elem) {
      | Ketchup =>
        // don't add!
        printf ("Ketchup is not healthy!\n")
      | _ =>
        content <- elem :: content
    }
  }
  
  public this ()
  {
  }
}]]>
</code>
        <p>
          calls
        </p>
<code><![CDATA[module Shop
{
  AddKetchup (refr : Refrigerator) : void
  {
    refr.AddContent (Ketchup ())
  }

  Main () : void
  {
    def r1 = Refrigerator ();
    def r2 = RestrictedRefrigerator ();
    AddKetchup (r1);
    AddKetchup (r2);
  }
}]]>
</code>
        <p>
          vtable
        </p>
      </body>
    </subsection>
    

    <subsection id="interfaces">
      <title>Interfaces</title>
      <body>
        <p>
          single inheritance => interfaces
        </p>
<code><![CDATA[interface IPrintable {
  Print () : void;
}

class RefrigeratorNG : Refrigerator, IPrintable
{
  public Print () : void
  {
    printf ("I'm the refrigerator!\n")
  }

  public this ()
  {
  }
}

module RP {
  PrintTenTimes (p : IPrintable) : void
  {
    for (mutable i <- 0; i < 10; i <- i + 1)
      p.Print ()
  }
  
  Main () : void
  {
    def refr = RefrigeratorNG ();
    PrintTenTimes (refr)
  }
}]]>
</code>
      </body>
    </subsection>
    
  </section>
  
  
  <section id="poly">
    <title>Parametric polymorphism</title>
    <body>
      <p>
      </p>
    </body>
  </section>
  
  
  <section id="exceptions">
    <title>Exceptions</title>
    <body>
      <p>
      </p>
    </body>
  </section>
  
  
  <section id="class-docs">
    <title>Class library reference</title>
    <body>
      <p>
        Class library reference from Microsoft can be found under
        <link>http://msdn.microsoft.com/library/en-us/cpref/html/cpref_start.asp</link>.
      </p>
    </body>
  </section>

  
  <!--
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>
