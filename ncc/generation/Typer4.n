/*
 * Copyright (c) 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  class Typer4
  {
    current_fun : Fun_header;
    current_type : TypeBuilder;
    messenger : Messenger;
    the_method : NemerleMethod;

    #region Entry points
    public this (meth : NemerleMethod)
    {
      current_fun = meth.GetHeader ();
      the_method = meth;
      messenger = Passes.Solver.CurrentMessenger;
      current_type = meth.DeclaringType :> TypeBuilder;
    }


    public Run () : void
    {
      Util.locate (current_fun.loc, {
        match (current_fun.body) {
          | FunBody.Typed (body) =>
            def body' = Walk (body);
            def body' =
              if (NeedBoxing (current_fun.ret_type.Fix (), body'))
                Box (current_fun.ret_type.Fix (), body')
              else body';
            current_fun.body = FunBody.Typed (body');
            when (Options.ShouldDump (current_fun))
              Message.Debug ($ "after T4: $the_method [$(current_fun.name)] "
                               ":\n$(body')\n");
          | _ => assert (false)
        }
      })
    }


    static NeedBoxing (target_type : MType, expr : TExpr) : bool
    {
      def src = expr.Type.Fix ();

      ((src.IsValueType || src is MType.Void) 
       && !target_type.IsValueType)
      // emit conversions for array types, becasue there is an error for 
      // converting a value type array to non-value type array i ILEmitter
      || (target_type is MType.Array && 
          NeedConversionRec (target_type, src))
    }
    

    static Box (target_type : MType, expr : TExpr) : TExpr
    {
      Typer3.CheckedConversion (expr, target_type)
    }

    static MaybeBoxToObject (expr : TExpr) : TExpr
    {
      if (NeedBoxing (InternalType.Object, expr))
        Box (InternalType.Object, Walk (expr))
      else
        Walk (expr)
    }


    static IsGeneric (t : MType) : bool
    {
      match (t) {
        | MType.TyVarRef => true
        | MType.Class (tc, []) => tc.Equals (InternalType.Object_tc)
        | MType.Array (t, _) => IsGeneric (t.Fix ())
        | _ => false
      }
    }

    static NeedConversionRec (real_type : MType, expr_type : MType) : bool
    {
      (IsGeneric (real_type) && ! IsGeneric (expr_type)) ||
      match (real_type) {
        | MType.Array (real, _) =>
          match (expr_type) {
            | MType.Array (expr, _) =>
              NeedConversionRec (real.Fix (), expr.Fix ())
            | _ => Util.ice ()
          }
        | _ => false
      }
    }

    static NeedConversion (real_type : MType, _expr : TExpr) : bool
    {
      IsGeneric (real_type)
      // Message.Debug ($"maybe convert $real_type to $(expr.Type) (for $expr)");
      // NeedConversionRec (real_type, expr.Type.Fix ())
    }
    #endregion


    #region Top level stuff
    static Walk (expr : TExpr) : TExpr
    {
      expr.Walk (DoWalk)
    }


    static DoWalk (expr : TExpr) : TExpr
    {
      _ = expr.Throws; // make it flag any error here
      // Message.Debug ($ "dowalk: $(expr.GetType()) $(expr)");
      def res =
        match (expr) {
          | FieldMember (obj, fld) 
            when 
              ! expr.IsAssigned && 
              NeedConversion (fld.GetMemType (), expr) =>
            // use address here for better performance
            def obj = Walk (obj);
            when (! obj.NeedAddress && fld.DeclaringType.IsValueType)
              obj.NeedAddress = true;
              
            // Message.Debug ($"field ref: $(fld.GetMemType())");
            TExpr.FieldMember (fld.GetMemType (), obj, fld)
            
          | TupleIndexer (obj, pos, len) when NeedConversion (InternalType.Object, expr) =>
            TExpr.TupleIndexer (InternalType.Object, Walk (obj), pos, len);

          | Assign (e1, e2) =>
            e1.IsAssigned = true;

            def real_type =
              match (e1) {
                | FieldMember (_, fld)
                | StaticRef (fld is IField) => fld.GetMemType ()
                | LocalRef (decl) => decl.Type.Fix ()
                | ArrayIndexer
                | This => e1.Type.Fix ()
                | _ => Util.ice ($ "wrong assignment target $e1")
              }
            def e1 = Walk (e1);
            def e2 = Walk (e2);
            
            if (e1.Type.Fix ().IsValueType && ! e1.IsAddressable)
              Message.Error ("this expression is not a proper lvalue: "
                             "cannot load value type address");
            else
              e1.NeedAddress = true;

            when (e1.Throws)
              Message.Error ("`throw' in assignment target");

            when (e2.Throws)
              if (e1 is TExpr.LocalRef)
                Message.Warning ("bad style: each branch in this block "
                                 "ends with a break")
              else
                Message.Error ("`throw' in assignment source");

            if (NeedBoxing (real_type, e2))
              TExpr.Assign (InternalType.Void, e1, Box (real_type, e2))
            else 
              TExpr.Assign (InternalType.Void, e1, e2)
            
          | TailCall (ImplicitValueTypeCtor, [])
          | Call (ImplicitValueTypeCtor, []) => null
          
          // I hope opcodes don't need boxing ...
          | TailCall (OpCode, parms)
          | Call (OpCode, parms) =>
            foreach (parm in parms)
              when (parm.expr.Throws)
                Message.Error ("`throw' in operand argument");
            null
          
          | TailCall (func, parms)
          | Call (func, parms) =>
            def func = Walk (func);
            when (func.Throws)
              Message.Error ("`throw' in called value");
            def meth =
              match (func) {
                | MethodRef (_, meth, _)
                | Base (meth)
                | StaticRef (meth is IMethod) => meth
                | _ => Util.ice ($ "invalid thing called $func")
              }

            unless (parms.IsEmpty) {
              if (meth.DeclaringType.IsDelegate && meth.Name == ".ctor") {
                def parm = parms.Head;
                when (NeedBoxing (InternalType.Object, parm.expr))
                  parm.expr = Box (InternalType.Object, parm.expr);
              } else {
                mutable formals = meth.GetParameters ();
                
                Util.cassert (formals.Length == parms.Length,
                              $ "call to $meth $parms $formals");
                
                foreach (parm in parms) {
                  match (formals) { 
                    | f :: fs =>
                      def t = f.ty.Fix ();
                      parm.expr = Walk (parm.expr);
                      when (parm.expr.Throws)
                        Message.Error ("`throw' in call parameter");
                      if (parm.kind == ParmKind.Normal) {
                        when (NeedBoxing (t, parm.expr))
                          parm.expr = Box (t, parm.expr);
                      } else {
                        if (parm.expr.IsAddressable)
                          parm.expr.NeedAddress = true;
                        else
                          Message.Error ($ "non-addressable expression passed "
                                           "as a ref/out parameter `$(f.name)'");
                      }
                      formals = fs;
                    | [] => Util.ice ();
                  }
                }
              }
            }

            if (NeedConversion (meth.ReturnType.Fix (), expr))
              TExpr.Call (meth.ReturnType.Fix (), func, parms)
            else
              if (expr is TExpr.TailCall)
                TExpr.TailCall (expr.Type, func, parms)
              else
                TExpr.Call (expr.Type, func, parms)

          | Tuple (exprs) =>
            foreach (expr in exprs)
              when (expr.Throws)
                Message.Error ("`throw' in tuple constructor");
            TExpr.Tuple (expr.Type, exprs.Map (MaybeBoxToObject))

          | Array (parms, dimensions) =>
            def ty =
              match (expr.Type.Fix ()) {
                | MType.Array (t, _) => t.Fix ()
                | _ => Util.ice ()
              }
            mutable res = [];
            foreach (parm in parms) {
              def parm = Walk (parm);
              when (parm.Throws)
                Message.Error ("`throw' in array constructor");
              def parm =
                if (NeedBoxing (ty, parm))
                  Box (ty, parm)
                else parm;
              res = parm :: res;
            }
            foreach (dim in dimensions)
              when (dim.Throws)
                Message.Error ("`throw' in array constructor");
            TExpr.Array (expr.Type, res.Rev (), dimensions)
                
          | DefFunctionsIn
          | Match
          | SelfTailCall =>
            Util.cassert (Message.SeenError);
            null
          
          | _ => null
        }
      // Message.Debug ($"do walk: $expr -> $res");
      if (res == null) null
      else if (res.Type.Equals (expr.Type)) res
      else Typer3.CheckedConversion (res, expr.Type)
    }
    #endregion
  }
}
