/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public class TypingContext
{
  public this_ptr_decl : option (LocalValue);
  public in_ctor : bool;
  public env : GlobalEnv;
  public tenv : Tyvar.TEnv;
  public current_fun : Fun_header;
  public locals : String_map (LocalValue);
  public parent_type : Tyinfo;

  public this (this_ptr_decl : option (LocalValue),
               in_ctor : bool, env : GlobalEnv, tenv : Tyvar.TEnv,
               current_fun : Fun_header,
               locals : String_map (LocalValue),
               parent_type : Tyinfo)
  {
    this.this_ptr_decl <- this_ptr_decl;
    this.in_ctor <- in_ctor;
    this.env <- env;
    this.tenv <- tenv;
    this.current_fun <- current_fun;
    this.locals <- locals;
    this.parent_type <- parent_type;
  }

  register_local (val : LocalValue) : void
  {
    current_fun.all_locals <- val :: current_fun.all_locals
  }

  public WithTEnv (e : Tyvar.TEnv) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, e, current_fun, locals, parent_type)
  }
  
  public WithCurrentFunction (h : Fun_header) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, h, locals, parent_type)
  }

  public WithLocal (val : LocalValue) : TypingContext
  {
    register_local (val);
    TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, locals.replace (val.name, val), parent_type)
  }
  
  public WithLocals (vals : list (LocalValue)) : TypingContext
  {
    List.Iter (register_local, vals);
    TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, 
                   List.FoldLeft (fun (m : String_map (LocalValue), v : LocalValue) 
                                { m.replace (v.name, v) }, locals, vals), parent_type)
  }
  
  public Closurise (val : LocalValue) : bool
  {
    match (val.parent_fun) {
      | Some (head) =>
        if (head.id == current_fun.id) false
        else
          if (val.in_closure) true
          else {
            val.in_closure <- true;
            head.closure_vars <- val :: head.closure_vars;
            true
          }
      | None => false
    }
  }

}

}
