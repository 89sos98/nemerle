/*
 * Copyright (c) 2004, 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Collections;
using Nemerle.Utility;

using System.IO;
using SY = System;

using PT = Nemerle.Compiler.Parsetree;
using SR = System.Reflection;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler 
{
  module AttributeCompiler
  {
    mutable assembly_attributes : list [GlobalEnv * PT.PExpr];
    mutable resolved_assembly_attrs : list [GlobalEnv * TypeInfo * list [PT.PExpr]];

    public Init () : void
    {
      assembly_attributes = [];
      resolved_assembly_attrs = [];
    }

    compile_expr (env : GlobalEnv, ti : TypeBuilder, allow_rec : bool, 
                  expr : PT.PExpr) : object * MType
    {
      match (expr) {
        | <[ $(x : string) ]> => ((x : object), InternalType.String)
        | <[ $(x : bool) ]> => ((x : object), InternalType.Boolean)
        | <[ $(x : char) ]> => ((x : object), InternalType.Char)
        | PT.PExpr.Literal (Literal.Enum (lval, ty)) =>
          def (val, _) = compile_expr (env, ti, allow_rec, PT.PExpr.Literal (lval));
          (val, MType.Class (ty, []))

        | <[ null ]> => (null, InternalType.Type)

        | PT.PExpr.Literal (lit) =>
          match (NumericType.ByLiteral (lit)) {
            | Some (t) => 
              (t.FromLiteral (lit), t.GetNemerleType ())
            | None => assert (false)
          }

        | <[ typeof ($t) ]> when ti != null =>
          match (ti.BindType (t)) {
            | MType.Class (tc, []) => (tc.GetSystemType (), InternalType.Type)
            | _ =>
              Message.fatal_error ("complex type expressions are not allowed in"
                                   " attributes: " + PrettyPrint.SprintExpr (None (), t))
          }

        // FIXME: 
        | <[ typeof ($_) ]> when ti == null =>
          Message.fatal_error ("typeof in assembly attributes not implemented");

        | <[ array [..$elems] ]> when allow_rec =>
          def exprs = List.Map (elems, fun (e) { compile_expr (env, ti, false, e) });
          def array_tc =
            List.FoldLeft (exprs, InternalType.Object_tc, fun (et, curty) {
              match (et) {
                | (_, MType.Class (tc, _)) when !tc.Equals (InternalType.Object_tc) => tc
                | _ => curty
              }
            });
          def allow_null = 
            array_tc.Equals (InternalType.String_tc) ||
            array_tc.Equals (InternalType.Type_tc);
          def objects =
            List.Map (exprs, fun (_) {
              | (e, MType.Class (tc, _)) when tc.Equals (array_tc) => e
              | (x, _) when allow_null && x == null => null
              | (_, t) =>
                Message.fatal_error ($ "custom attribute array shall have "
                                       "type $array_tc while the element "
                                       "has type $t")
            });
          
          // FIXME: this seems wrong, what if there are two mscorlibs?

          // hack for bug with converting list to array 
          //          def arr = NArray.FromList (array_tc.GetSystemType (), objects);
          mutable i = 0;
          def arr = array (List.Length (objects));
          foreach (x in objects) { arr [i] = x; ++i; };

          (arr, MType.Array (MType.Class (array_tc, []), 1))

        | <[ $obj . $(n : name) ]> =>
          Message.fatal_error ($"unbound / non-enum member $(n.Id) in "
                               "$(PrettyPrint.SprintExpr (None (), obj)) at custom attribute parameter")

        | <[ $(n : name) ]> =>
          Message.fatal_error ("unbound symbol (or of non-enum type) in custom attribute parameter: " + n.Id)

        | e =>
          Message.fatal_error ("complex expressions are not allowed in attributes: " + 
                               PrettyPrint.SprintExpr (None (), e))
      }
    }


    do_compile (env : GlobalEnv, ti : TypeBuilder, attr : TypeInfo, parms : list [PT.PExpr]) 
        : SR.Emit.CustomAttributeBuilder
    {
      mutable ctor_parm_types = [];
      mutable ctor_parms = [];
      mutable field_infos = [];
      mutable fields = [];
      mutable property_infos = [];
      mutable properties = [];
      
      def compile_parm (parm : PT.PExpr) {
        | <[ $(n : name) = $expr ]> =>
          def name = n.Id;
          def expr = ConstantFolder.FoldConstants (env, expr);
          def (obj, ty) = compile_expr (env, ti, true, expr);
          def problem () {
            Message.fatal_error ("the type " + attr.FullName + 
                                 " has no field nor property named `" + name + "'")
          };
          def (is_prop, mem) =
            match (attr.LookupMember (name)) {
              | [mem] =>
                match (mem.GetKind ()) {
                  | MemberKind.Field => (false, mem)
                  | MemberKind.Property => (true, mem)
                  | _ => problem ()
                }
              | _ => problem ()
            };
          def handle = mem.GetHandle ();
          assert (handle != null);
          if (mem.GetMemType ().Equals (ty.Fix ()))
            if (is_prop) {
              property_infos = (handle :> SR.PropertyInfo) :: property_infos;
              properties = obj :: properties;
            } else {
              field_infos = (handle :> SR.FieldInfo) :: field_infos;
              fields = obj :: fields;
            }
          else
            Message.fatal_error ($ "the member `$(name)' has type "
                                   "$(mem.GetMemType ()) while the value "
                                   "assigned has type $ty")
                                 
        | _ =>
          def (obj, ty) = compile_expr (env, ti, true, parm);
          ctor_parm_types = ty :: ctor_parm_types;
          ctor_parms = obj :: ctor_parms;
      };

      List.Iter (parms, compile_parm);

      def arr['a] (t, lst : list ['a]) { NArray.FromList (t, List.Rev (lst)) };

      ctor_parm_types = List.Rev (ctor_parm_types);

      mutable proper_ctor = null;
      /// FIXME: we should use general overloading resolving from tyexpr
      foreach (mem : IMember in attr.LookupMember (".ctor"))      
        match (mem.GetKind ()) {
          | MemberKind.Method (meth) =>
            def parms = meth.GetParameters ();
            def check_parm (ty : TyVar, parm : Fun_parm) {
              ty.TryRequire (parm.ty);
            }
            when (ctor_parm_types.Length == parms.Length &&
                  List.ForAll2 (ctor_parm_types, parms, check_parm)) 
            {
              if (proper_ctor == null)
                proper_ctor = meth.GetConstructorInfo ();
              else
                /// FIXME: sometimes it is not ambiguous
                Message.error ("ambiguous call to constructor") 
            }
          | _ => ()
        }
      
      when (proper_ctor == null) 
        Message.fatal_error ("none of the constructors of `" + attr.FullName + 
                             "' matches positional argument types");
                             
      SR.Emit.CustomAttributeBuilder 
          (proper_ctor, 
           arr (typeof (object), ctor_parms), 
           arr (typeof (SR.PropertyInfo), property_infos), 
           arr (typeof (object), properties), 
           arr (typeof (SR.FieldInfo), field_infos), 
           arr (typeof (object), fields))
    }

    
    internal CompileAttribute (env : GlobalEnv, ti : TypeBuilder, expr : PT.PExpr)
        : SR.Emit.CustomAttributeBuilder
    {
      def (_, tc, parms) = CheckAttribute (env, expr);
      do_compile (env, ti, tc, parms);
    }

    internal ResolveAttribute (env : GlobalEnv, expr : PT.PExpr) 
    : option [TypeInfo * list [PT.PExpr]]
    {
      def add_end (l, suff : string) {
        match (l) {
          | [x] => [x + suff]
          | x :: xs => x :: add_end (xs, suff)
          | _ => Util.ice ("empty")
        }
      };

      match (expr) {
        | <[ $(_ : name) ]>
        | <[ $_x . $_y ]> =>
          ResolveAttribute (env, <[ $expr () ]>)

        | <[ $name ( .. $parms ) ]> =>
          match (Util.qidl_of_expr (name)) {
            | Some ((id, name)) =>
              def is_attribute (t : TypeInfo) {
                t.SuperType (InternalType.Attribute_tc) matches Some
              }
              
              def ctx = name.GetEnv (env);
              def plain = ctx.LookupType (id);
              def withattr = ctx.LookupType (add_end (id, "Attribute"));

              match ((plain, withattr)) {
                | (Some (t), None)
                | (None, Some (t)) =>
                  if (is_attribute (t))
                    Some ((t, parms))
                  else
                    Message.fatal_error ($"`$(t.FullName)' is not an attribute class");

                | (Some (t1), Some (t2)) =>
                  if (is_attribute (t1))
                    if (is_attribute (t2))
                      Message.fatal_error ($"ambiguous attribute type name,"
                                           " it could be `$(t1)' or `$(t2)'");
                    else
                      Some ((t1, parms))
                  else
                    if (is_attribute (t2)) Some ((t2, parms))
                    else
                      Message.fatal_error ($"neither `$(t1)' nor `$(t2)' is an attribute class");

                | _ => None ()
              }

            | _ => None ()
          }
        | _ => None ()
      }
    }

    internal CheckAttribute (env : GlobalEnv, expr : PT.PExpr)
    : GlobalEnv * TypeInfo * list [PT.PExpr]
    {
      Util.locate (expr.loc, 
        match (ResolveAttribute (env, expr)) {
          | Some ((t, parms)) =>
            def parms = List.Map (parms, fun (expr) { 
              ConstantFolder.FoldConstants (env, expr);
            });
            (env, t, parms)
          | None =>
            Message.fatal_error ("the custom attribute `" + 
                                 PrettyPrint.SprintExpr (None (), expr) +
                                 "' could not be found or is invalid")
        })
    }
    
    internal AddAssemblyAttribute (env : GlobalEnv, att : PT.PExpr) : void {
      assembly_attributes = (env, att) :: assembly_attributes;
    }

    internal GetCompiledAssemblyAttributes () : list [SR.Emit.CustomAttributeBuilder] {
       List.RevMap (resolved_assembly_attrs, fun (env, tc, parms) {
        do_compile (env, null, tc, parms);      
       });
    }

    public CreateAssemblyName () : SR.AssemblyName
    {
      /* create an assembly name and set its properties according to defined
         global assembly attributes */
      def an = SR.AssemblyName ();
      an.CodeBase = string.Concat("file:///", Directory.GetCurrentDirectory());

      foreach ((env, attr) in List.Rev (assembly_attributes)) {
        /* store resolved attribute */
        def resolved = CheckAttribute (env, attr);
        resolved_assembly_attrs = resolved :: resolved_assembly_attrs;
        
        def (_, tc : TypeInfo, parms) = resolved;
        
        def take_string (pars) {
          | [ <[ $(x : string) ]> ] => x
          | _ =>
            Message.fatal_error (attr.loc, "given attribute must have single string as parameter")
        }
        if (tc.Equals (InternalType.AssemblyVersionAttribute_tc))
        {
          // spec for parsing version is quite interesting
          // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cptools/html/cpgrfassemblygenerationutilityalexe.asp
          def ver = NString.Split (take_string (parms), array ['.']);

          mutable version_object = null;
          try {
            def verint = List.Map (ver, fun (x) {
              if (x == "*") -1
              else (SY.UInt16.Parse (x) :> int)
            });

            version_object = 
              match (verint) {
                | [x1] => SY.Version (x1.ToString ())
                | [x1, x2] => SY.Version (x1, x2)
                | [x1, x2, -1] =>
                  def span = SY.DateTime.Now.Subtract (SY.DateTime (2000, 1, 1));
                  SY.Version (x1, x2, span.Days, span.Seconds / 2)
                | [x1, x2, x3] => SY.Version (x1, x2, x3)
                | [x1, x2, x3, -1] =>
                  def span = SY.DateTime.Now.Subtract (SY.DateTime (2000, 1, 1));
                  SY.Version (x1, x2, x3, span.Seconds / 2)
                | [x1, x2, x3, x4] => SY.Version (x1, x2, x3, x4)
                | _ =>
                  Message.error (attr.loc, "invalid format of version attribute");
                  SY.Version ();
              }
          }
          catch {
            | _ : SY.OverflowException =>
              Message.error (attr.loc, "wrong format of version attribute");
              version_object = SY.Version ();
          }

          an.Version = version_object;
        }
        else if (tc.Equals (InternalType.AssemblyKeyFileAttribute_tc))
        {
          def key = take_string (parms);
          if (an.KeyPair != null)
            Message.error (attr.loc, "AssemblyKeyFile attribute specified twice")
          else
            when (key != "") an.KeyPair = read_keypair (attr.loc, key);
        }
        else when (tc.Equals (InternalType.AssemblyCultureAttribute_tc))
          an.CultureInfo = SY.Globalization.CultureInfo (take_string (parms));
      };
      assembly_attributes = null; // GC kill it
      an
    }

    private read_keypair (loc : Location, name : string) : SR.StrongNameKeyPair 
    {
      try {
        SR.StrongNameKeyPair(File.Open(name, FileMode.Open, FileAccess.Read))
      }
      catch {
        | _ : FileNotFoundException =>
          Message.fatal_error (loc, "could not find file `" + name + "' with key pair for assembly")
      }
    }
  }
}
