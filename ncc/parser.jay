/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

%{
using System;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;


namespace Nemerle.Compiler {

class Parser {
  protected list result;

  class Located_ID : Located {
    public string name;
  }

  class Fun_helper {
    public Fun_header header;
    public bool is_ctor;
    public list implements;
    public Fun_helper(Fun_header h, bool c, list i)
    {
      header = h;
      is_ctor = c;
      implements = i;
    }
  }

  protected Lexer lex;

  string tmp_name()
  {
    return "_N_" + (Util.next_id()).ToString();
  }

  list cons(object h, list t)
  {
    return new list.Cons(h, t);
  }

  list nil()
  {
    return new list.Nil();
  }

  option none()
  {
    return new option.None();
  }

  option some(object x)
  {
    return new option.Some(x);
  }

  void fixup_tydecl(object targ, list mods, Type_decl_base source)
  {
        Type_decl_base target = (Type_decl_base)targ;
      
        target.name = source.name;
        target.loc = source.loc;
        target.typarms = source.typarms;
        target.t_extends = source.t_extends;
        target.t_implements = source.t_implements;

        target.modifiers = mods;
  }
  
  void fixup_decl(object targ, list mods, Located_ID source)
  {
        Decl_base target = (Decl_base)targ;
      
        target.name = source.name;
        target.loc = source.loc;

        target.modifiers = mods;
  }

  Expr make_bin(Expr e1, string op, Expr e2)
  {
    Expr rf = new Expr.E_ref(op);
    Expr cl = new Expr.E_call(rf, cons(new Parm(false, e1, ""), 
                    cons(new Parm(false, e2, ""), nil())));
    locate(rf);
    locate(cl);
    return cl;
  }
  
  Expr make_unary(string op, Expr e)
  {
    Expr rf = new Expr.E_ref(op);
    Expr cl = new Expr.E_call(rf, cons(new Parm(false, e, ""), nil()));
    locate(rf);
    locate(cl);
    return cl;
  }

  Expr biseq(Expr e1, Expr e2)
  {
    locate(e1);
    return new Expr.E_sequence(cons(e1, cons(e2, nil())));
  }
  
  Located locate(Located o1, Located o2)
  {
    o1.loc = o2.loc;
    return o1;
  }

  Located set_location(Located o, Location l)
  {
    o.loc = l;
    return o;
  }

  Located locate(Located o)
  {
    o.loc = lex.get_location();
    return o;
  }
  
  bool is_empty_typarms(Typarms p)
  {
    return (p.constraints is list.Nil) && (p.tyvars is list.Nil);
  }

  Located_ID make_located_id(string name)
  {
      Located_ID i = new Located_ID();
      i.name = name;
      i.loc = lex.get_location();
      return i;
  }

  public list parse(Lexer l)
  {
      lex = l;
      result = nil();
      yyparse(l);
      return result;
  }


%}

%token <int> NUMBER_LITERAL
%token <int> CHAR_LITERAL
%token <string> ID
%token <string> TYVAR
%token <string> STRING_LITERAL
%token <string> OP1
%token <string> OP2
%token <string> OP3
%token <string> OP4
%token <string> OP5
%token <string> OP6
%token <string> OP7

%token KW_ABSTRACT KW_CONST KW_EXTERN KW_INTERNAL KW_NEW KW_PRIVATE
%token KW_PROTECTED KW_SEALED KW_VOLATILE KW_NAMESPACE KW_BASE
%token KW_CLASS KW_ENUM KW_EXTENDS KW_FINALLY KW_IN KW_NULL KW_OUT
%token KW_PUBLIC KW_RAISE KW_REF KW_STRUCT KW_THIS KW_VARIANT
%token KW_INTERFACE KW_IMPLEMENTS KW_WHERE KW_TYPE KW_LET
%token KW_FUN KW_AND KW_TYMATCH KW_WITH KW_TRY KW_OPEN KW_VOID
%token KW_IF KW_THEN KW_ELSE KW_AS KW_MATCH
%token KW_STATIC KW_MUTABLE KW_DEF KW_MODULE
%token KW_ARRAY KW_MKARRAY
%token KW_WHEN KW_UNLESS KW_WHILE KW_USING KW_FOR

%token COLON_MORE LESS_MINUS MINUS_MORE EQ_MORE COLON_COLON
%token LESS_SQBRAC SQBRAC_MORE KW_MACRO KW_PATTERN
%token LAZY_AND LAZY_OR

%token ERROR

%nonassoc KW_RAISE LESS_MINUS KW_IF KW_DEF
%right COLON_COLON
%left LAZY_AND
%left LAZY_OR
%left OP7
%left OP6
%left OP5
%left OP4
%left OP3
%left OP2 '*'
%right OP1
%nonassoc UNARY
%left '.'

%right MINUS_MORE

%type <Located_ID> located_id located_qid located_id_or_dummy
%type <Location> locator
%type <string> qid
%type <Nemerle.Compiler.Parsetree.Type> ty prim_ty args_list_ty maybe_type
%type <bool> maybe_ref maybe_new maybe_mutable
%type <Type_decl> type_decl variant_option
%type <Type_decl_base> type_header
%type <Typarms> typarms ftyparms
%type <Expr> expr args_list_expr
%type <Expr> sequence prim_expr unquoted_expr
%type <Fun_helper> fun_def_head
%type <Fun_body> fun_body
%type <Fun_header> lambda_head
%type <Class_member.M_function> fun_def
%type <Pattern> pattern tuple_pattern record_pattern
%type <Val_kind> maybe_extern
%type <Literal> literal
%type <Top_decl> namespace_or_type_decl
%type <Class_member.M_function> interface_member
%type <Class_member> type_member 
%type <Class_member.M_field> record_member
%type <Constraint> where_constraint
%type <Modifier> attr
%type <Fun_parm> fun_parm local_fun_parm
%type <Parm> parameter maybe_parm
%type <Function_decl> local_fun_def
%type <Match_case> match_case
%type <Named_pattern> record_patt
%type <Pattern> args_list_patt unquoted_patt_expr
%type <Splicable_string> splicable_id splicable_id_or_dummy splicable_qid
%type <Nemerle.Tuple2> guarded_pattern

%type <list> maybe_implements comma_sep_types interface_members variant_options tyvars
%type <list> maybe_where where_constraints type_members attrs maybe_record record
%type <list> record_members non_empty_fun_parms fun_parms maybe_method_implements
%type <list> implemented_methods non_empty_parameters parameters
%type <list> fun_defs match_cases namespace_or_type_decls prod_ty
%type <list> comma_sep_patterns comma_sep_exprs list_exprs list_patterns
%type <list> expr_or_sequence record_patts guarded_patterns
%type <list> non_empty_local_fun_parms local_fun_parms

%type <option> maybe_extends

%start program

%%

locator:
    /* */       { $$ = lex.get_location(); }

located_id:
        ID      { $$ = make_located_id($1); }
  
located_id_or_dummy:
          located_id
        | '_'   { $$ = make_located_id(tmp_name()); }

qid:
          ID            { $$ = $1; }
        | ID '.' qid    { $$ = $1 + "." + $3; }

located_qid:
        qid    { $$ = make_located_id($1); }

program:
        namespace_or_type_decls   { result = $1; }

namespace_or_type_decl:
    KW_OPEN located_qid ';'
    {
      $$ = locate(new Top_decl.TD_open ($2.name), $2);
    }
  | KW_NAMESPACE located_id '=' located_qid ';'
    {
      $$ = locate(new Top_decl.TD_namespace_alias ($2.name, $4.name), $2);
    }
  | KW_NAMESPACE located_qid '{' namespace_or_type_decls '}'
    {
      $$ = locate(new Top_decl.TD_namespace ($2.name, $4), $2);
    }
  | type_decl
    {
      $$ = locate(new Top_decl.TD_type ($1), $1);
    }

namespace_or_type_decls:
          namespace_or_type_decl namespace_or_type_decls
      { $$ = cons($1, $2); }
        | /* */
      { $$ = nil(); }

type_header:
    located_id typarms maybe_extends maybe_implements
    {
      Type_decl_base p = new Type_decl_base ();
      
      p.name = $1.name;
      p.typarms = $2;
      p.t_extends = $3;
      p.t_implements = $4;

      $$ = locate (p, $1);
    }

type_decl:
    attrs KW_TYPE type_header '=' ty ';'
    {
      $$ = new Type_decl.TD_alias($5);
      fixup_tydecl($$, $1, $3);
    }
  | attrs KW_TYPE type_header '=' KW_EXTERN STRING_LITERAL ';'
    {
      $$ = new Type_decl.TD_external($6);
      fixup_tydecl($$, $1, $3);
    }
  | attrs KW_INTERFACE type_header '{' interface_members '}'
    {
      $$ = new Type_decl.TD_interface($5);
      fixup_tydecl($$, $1, $3);
    }
  | attrs KW_CLASS type_header '{' type_members '}'
    {
      $$ = new Type_decl.TD_class($5);
      fixup_tydecl($$, $1, $3);
    }
  | attrs KW_MODULE type_header '{' type_members '}'
    {
      $$ = new Type_decl.TD_class($5);
      fixup_tydecl($$, cons(new Modifier.Mod_module(), $1), $3);
    }
  | attrs KW_STRUCT type_header '{' type_members '}'
    {
      $$ = new Type_decl.TD_class($5);
      fixup_tydecl($$, cons(new Modifier.Mod_struct(), $1), $3);
    }
  | attrs KW_VARIANT type_header '{' maybe_bar variant_options '}'
    {
      $$ = new Type_decl.TD_variant($6);
      fixup_tydecl($$, $1, $3);
    }
  | attrs KW_MACRO fun_def
    {
      $$ = new Type_decl.TD_macro ($3);
      fixup_tydecl ($$, $1, new Type_decl_base());
    }

maybe_extends:
          /* */                 { $$ = none(); }
        | KW_EXTENDS ty         { $$ = some($2); }

maybe_implements:
          /* */                                 { $$ = nil(); }
        | KW_IMPLEMENTS comma_sep_types         { $$ = $2; }

comma_sep_types:
          ty                                  { $$ = cons($1, nil()); }
        | ty ',' comma_sep_types              { $$ = cons($1, $3); }

interface_members:
          /* */                                   { $$ = nil(); }
        | interface_member interface_members      { $$ = cons($1, $2); }

maybe_new:
          /* */   { $$ = false; }
        | KW_NEW  { $$ = true; }

interface_member:
        maybe_new fun_def_head ';'
    {
      Class_member m = new Class_member.M_function($2.header, 
                                new Fun_kind.FK_iface_method ($1), 
                                new Fun_body.FB_abstract ());
                        
      // FIXME: error message for this and implements
      m.name = $2.header.name;
      m.modifiers = nil();
      $$ = locate(m, $2.header);
    }

variant_options:
          variant_option                      { $$ = cons($1, nil()); }
        | variant_option '|' variant_options    { $$ = cons($1, $3); }

variant_option:
    located_id maybe_record
    {
      Type_decl.TD_variant_option o = 
        new Type_decl.TD_variant_option($2);
      o.name = $1.name;
      o.modifiers = nil();
      o.t_extends = none();
      o.t_implements = nil();
      o.typarms = new Typarms(nil(), nil());
      $$ = locate(o, $1);
    }

typarms:
    /* */
    {
      $$ = new Typarms(nil(), nil());
    }
  | '(' tyvars ')' maybe_where
    {
      $$ = new Typarms($2, $4);
    }

ftyparms:
    /* */
    { $$ = new Typarms(nil(), nil()); }
  | tyvars maybe_where
    { $$ = new Typarms($1, $2); }

tyvars:
    TYVAR                                   { $$ = cons($1, nil()); }
  | TYVAR ',' tyvars                        { $$ = cons($1, $3); }

maybe_where:
    /* */                                   { $$ = nil(); }
  | KW_WHERE where_constraints              { $$ = $2; }

maybe_bar:
    /* */
  | '|'

where_constraints:
          where_constraint                              { $$ = cons($1, nil()); }
        | where_constraint ',' where_constraints        { $$ = cons($1, $3); }

where_constraint:
    TYVAR COLON_MORE ty
    {
      $$ = new Constraint($1, $3);
    }

type_members:
          /* */                              { $$ = nil(); }
        | type_member type_members           { $$ = cons($1, $2); }

attrs:
          /* */                              { $$ = nil(); }
        | attr attrs                         { $$ = cons($1, $2); }

attr:
          KW_NEW          { $$ = new Modifier.Mod_new(); }
        | KW_PUBLIC       { $$ = new Modifier.Mod_public(); }
        | KW_PROTECTED    { $$ = new Modifier.Mod_protected(); }
        | KW_INTERNAL     { $$ = new Modifier.Mod_internal(); }
        | KW_PRIVATE      { $$ = new Modifier.Mod_private(); }
        | KW_ABSTRACT     { $$ = new Modifier.Mod_abstract(); }
        | KW_SEALED       { $$ = new Modifier.Mod_sealed(); }
        | KW_STATIC       { $$ = new Modifier.Mod_static(); }

maybe_record:
          /* */   { $$ = nil(); }
        | record

record:
        '{' record_members '}'    { $$ = $2; }

record_members:
          /* */                              { $$ = nil(); }
        | record_member record_members       { $$ = cons($1, $2); }

record_member:
    attrs maybe_mutable located_id ':' ty ';'
    {
      $$ = new Class_member.M_field($5, $2, new Val_kind.Val_normal());
      fixup_decl($$, $1, $3);
    }

maybe_extern:
    '=' KW_EXTERN STRING_LITERAL ';'
    { $$ = new Val_kind.Val_extern($3); }
  | ';'
    { $$ = new Val_kind.Val_normal(); }

type_member:
    attrs maybe_mutable ftyparms located_id ':' ty maybe_extern
      {
      if (!is_empty_typarms($3))
        Message.error($4.loc, "fields cannot have type parameters");
      $$ = new Class_member.M_field($6, $2, $7);
      fixup_decl($$, $1, $4);
    }
  | attrs maybe_mutable fun_def
      {
      if ($2)
        Message.error($3.loc, "methods cannot have 'ref' attribute");
      $$ = $3;
      $3.modifiers = $1;
    }
  | type_decl
    {
      Type_decl td = $1;
      Class_member.M_type t = new Class_member.M_type(td);
      t.modifiers = td.modifiers;
      t.name = td.name;
      $$ = locate(t, $1);
    }

fun_def_head:
    ftyparms located_id '(' fun_parms ')' ':' ty maybe_method_implements
    {
      Fun_header h = new Fun_header();
      
      h.typarms = $1;
      h.name = $2.name;
      h.parms = $4;
      h.ret_type = $7;
      h.loc = $2.loc;

      $$ = new Fun_helper(h, false, $8);
    }
  | ftyparms KW_THIS locator '(' fun_parms ')'
    {
      Fun_header h = new Fun_header();
      
      h.typarms = $1;
      h.name = ".ctor";
      h.parms = $5;
      h.ret_type = new Nemerle.Compiler.Parsetree.Type.T_void();
      h.loc = $3;

      $$ = new Fun_helper(h, true, nil());
    }

fun_body:
    sequence        { $$ = new Fun_body.FB_parsed_expr ($1); }
  | '=' KW_EXTERN STRING_LITERAL ';'  { $$ = new Fun_body.FB_extern ($3); }

fun_def:
    fun_def_head fun_body
    {
      Fun_kind k = new Fun_kind.FK_method($1.implements);
      if ($1.is_ctor)
        k = new Fun_kind.FK_ctor();
      Class_member.M_function f = 
        new Class_member.M_function($1.header, k, $2);
      f.name = $1.header.name;
      f.modifiers = nil();
      $$ = locate(f, $1.header);	
    }

fun_parm:
    located_id_or_dummy ':' ty
    {
      Fun_parm p = new Fun_parm();
      
      p.name = $1.name;
      p.ty = $3;

      $$ = locate(p, $1);
    }

non_empty_fun_parms:
          fun_parm                    { $$ = cons($1, nil()); }
        | fun_parm ',' fun_parms      { $$ = cons($1, $3); }

fun_parms:
          /* */                       { $$ = nil(); }
        | non_empty_fun_parms

local_fun_parm:
    located_id_or_dummy maybe_type
    {
      Fun_parm p = new Fun_parm();
      
      p.name = $1.name;
      p.ty = $2;

      $$ = locate(p, $1);
    }

non_empty_local_fun_parms:
          local_fun_parm                          { $$ = cons($1, nil()); }
        | local_fun_parm ',' local_fun_parms      { $$ = cons($1, $3); }

local_fun_parms:
          /* */                       { $$ = nil(); }
        | non_empty_local_fun_parms

maybe_method_implements:
          /* */                 { $$ = nil(); }
        | KW_IMPLEMENTS implemented_methods   { $$ = $2; }

implemented_methods:
          qid                                   { $$ = cons($1, nil()); }
        | qid ',' implemented_methods           { $$ = cons($1, $3); }

// PRODUCTION RULES FOR TYPES

maybe_ref:
          /* */         { $$ = false; }
        | KW_REF        { $$ = true; }

maybe_mutable:
          /* */         { $$ = false; }
        | KW_MUTABLE    { $$ = true; }

prim_ty:
          qid                               
          { $$ = new Nemerle.Compiler.Parsetree.Type.T_app(new Splicable_string.SS_string($1), nil()); }
        | splicable_qid '(' comma_sep_types ')'
          { $$ = new Nemerle.Compiler.Parsetree.Type.T_app($1, $3); }
        | KW_ARRAY '(' ty ')'               { $$ = new Nemerle.Compiler.Parsetree.Type.T_array($3); }
        | TYVAR                             { $$ = new Nemerle.Compiler.Parsetree.Type.T_var($1); }
        | '(' ty ')'                        { $$ = $2; }
        | KW_VOID                           { $$ = new Nemerle.Compiler.Parsetree.Type.T_void(); }
        | KW_REF prim_ty                    { $$ = new Nemerle.Compiler.Parsetree.Type.T_ref($2); }
        | KW_OUT prim_ty                    { $$ = new Nemerle.Compiler.Parsetree.Type.T_out($2); }
        | '$' ID
          { 
            $$ = new Nemerle.Compiler.Parsetree.Type.T_unquoted(new Expr.E_ref ($2)); 
          }

prod_ty:
          prim_ty                              { $$ = cons($1, nil()); }
        | prim_ty '*' prod_ty                  { $$ = cons($1, $3); }
        | args_list_ty                         { $$ = cons($1, nil()); }

args_list_ty:
    '.' '.' ty
    { $$ = new Nemerle.Compiler.Parsetree.Type.T_type_list($3); }

ty:
    prod_ty
    {
      list.Cons c = (list.Cons)$1;
      if (c.tl is list.Nil)
        $$ = c.hd;
      else
        $$ = new Nemerle.Compiler.Parsetree.Type.T_prod(c);
    }
  | ty MINUS_MORE ty  { $$ = new Nemerle.Compiler.Parsetree.Type.T_fun($1, $3); }

// PRODUCTION RULES FOR EXPRESSIONS

splicable_id:
    located_id 
    { $$ = locate (new Splicable_string.SS_string($1.name), $1); }
  | '$' located_id
    { $$ = locate (new Splicable_string.SS_spliced_expr(new Expr.E_ref($2.name)), $2); }

splicable_id_or_dummy:
    located_id_or_dummy
    { $$ = locate (new Splicable_string.SS_string($1.name), $1); }
  | '$' located_id
    { $$ = locate (new Splicable_string.SS_spliced_expr(new Expr.E_ref($2.name)), $2); }

splicable_qid:
    located_qid 
    { $$ = locate (new Splicable_string.SS_string($1.name), $1); }
  | '$' located_qid
    { $$ = locate (new Splicable_string.SS_spliced_expr(new Expr.E_ref($2.name)), $2); }

literal:
          KW_NULL   { $$ = new Literal.L_null(); }
        | '(' ')'   { $$ = new Literal.L_void(); }
        | STRING_LITERAL  { $$ = new Literal.L_string($1); }
        | NUMBER_LITERAL  { $$ = new Literal.L_int($1); }
        | CHAR_LITERAL    { $$ = new Literal.L_char($1); }

maybe_parm:
  /* */ { $$ = new Parm(false, new Expr.E_sequence(nil()), ""); }
  |  parameter 

expr:
    prim_expr '(' parameters ')'            
    { $$ = locate(new Expr.E_call ($1, $3), $1); }

  | prim_expr LESS_MINUS expr               
    { $$ = locate(new Expr.E_assign ($1, $3), $1); }
    
  | KW_MATCH locator '(' expr ')' '{' maybe_bar match_cases '}'
    { $$ = set_location(new Expr.E_match($4, $8), $2); }
  | KW_RAISE expr                           
    { $$ = locate(new Expr.E_raise($2), $2); }
  | KW_TRY expr KW_WITH splicable_id ':' ty EQ_MORE expr %prec KW_IF
    { $$ = locate(new Expr.E_try_with($2, $4, $6, $8), $2); }
  | KW_TRY expr KW_FINALLY expr %prec KW_IF 
    { $$ = locate(new Expr.E_try_finally($2, $4), $2); }

  | KW_WHILE '(' expr ')' sequence 
    { $$ = locate(new Expr.E_call (new Expr.E_ref ("_N_while"), 
        cons(new Parm(false, $3, ""), cons(new Parm(false, $5, ""), nil()))), $3); }
  | KW_WHEN '(' expr ')' sequence
    { $$ = locate(new Expr.E_call (new Expr.E_ref ("_N_when"), 
        cons(new Parm(false, $3, ""), cons(new Parm(false, $5, ""), nil()))), $3); }
  | KW_UNLESS '(' expr ')' sequence
    { $$ = locate(new Expr.E_call (new Expr.E_ref ("_N_unless"), 
        cons(new Parm(false, $3, ""), cons(new Parm(false, $5, ""), nil()))), $3); }
  | KW_USING locator '(' parameters ')' sequence
    { $$ = set_location(new Expr.E_call (new Expr.E_ref ("_N_using"), 
        cons (new Parm(false, $6, ""), $4)), $2); }
  | KW_FOR locator '(' maybe_parm ';' maybe_parm ';' maybe_parm ')' sequence
    { $$ = set_location(new Expr.E_call (new Expr.E_ref ("_N_for"), 
        cons (new Parm(false, $10, ""), cons($4, cons($6, cons($8, nil()))))), $2); }
  | KW_IF locator '(' expr ')' expr KW_ELSE expr %prec KW_IF
    { $$ = set_location(new Expr.E_call (new Expr.E_ref ("_N_if"), 
        cons(new Parm(false, $4, ""), cons(new Parm(false, $6, ""), 
        cons(new Parm(false, $8, ""), nil())))), $2); }

  | KW_MKARRAY locator '[' expr_or_sequence ']'  
    { $$ = set_location(new Expr.E_mkarray ($4), $2); }

  | expr COLON_COLON expr                   
    { $$ = locate(new Expr.E_list_cons ($1, $3), $1); } 
  | '[' list_exprs maybe_semicolon ']'      
    { $$ = locate(new Expr.E_list (List.rev ($2))); }
  | '[' ']'                                 
    { $$ = locate(new Expr.E_list (nil ())); }

  | expr OP1 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr OP2 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr OP3 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr OP4 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr OP5 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr OP6 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr OP7 expr                           { $$ = locate(make_bin ($1, $2, $3), $1); }
  | expr '*' expr                           { $$ = locate(make_bin ($1, "*", $3), $1); }

  | OP1 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }
  | OP2 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }
  | OP3 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }
  | OP4 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }
  | OP5 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }
  | OP6 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }
  | OP7 expr %prec UNARY                    { $$ = locate(make_unary ($1, $2), $2); }

  | expr LAZY_AND expr                      
    { $$ = locate(new Expr.E_call (new Expr.E_ref ("_N_and"), 
        cons(new Parm(false, $1, ""), cons(new Parm(false, $3, ""), nil()))), $1); }

  | expr LAZY_OR expr                      
    { $$ = locate(new Expr.E_call (new Expr.E_ref ("_N_or"), 
        cons(new Parm(false, $1, ""), cons(new Parm(false, $3, ""), nil()))), $1); }

  | lambda_head sequence   // lambda
    {
      $$ = locate(new Expr.E_lambda(new Function_decl($1, $2)), $1);
    }

  | sequence

  | KW_DEF fun_defs
    { $$ = locate(new Expr.E_letfun($2)); }

  | KW_DEF ftyparms splicable_id_or_dummy '=' expr  %prec KW_DEF
    { $$ = locate(new Expr.E_let(false, $3, $5), $3); }
  | KW_DEF tuple_pattern '=' expr		  %prec KW_DEF
    { $$ = locate(new Expr.E_letpat($2, $4), $2); }
  | KW_MUTABLE splicable_id LESS_MINUS expr	  %prec KW_DEF
    { $$ = locate(new Expr.E_let(true, $2, $4), $2); }

  | prim_expr

prim_expr:
    KW_THIS   { $$ = locate(new Expr.E_this()); }
  | KW_BASE   { $$ = locate(new Expr.E_base()); }
  | literal   { $$ = locate(new Expr.E_literal($1)); }
  | '(' expr COLON_MORE ty ')'
    { $$ = locate(new Expr.E_type_conversion($2, $4), $2); }
  | '(' expr ':' ty ')'
    { $$ = locate(new Expr.E_type_enforcement($2, $4), $2); }
  | prim_expr '.' splicable_id
    { $$ = locate(new Expr.E_member($1, $3), $3); }
  | '(' comma_sep_exprs ')'
    { $$ = locate(new Expr.E_tuple($2)); }
  | prim_expr '[' expr ']'                  
    { $$ = locate(new Expr.E_indexer ($1, cons ($3, nil ())), $1); }
  | prim_expr '[' comma_sep_exprs ']'       
    { $$ = locate(new Expr.E_indexer ($1, $3), $1); }
  | LESS_SQBRAC expr SQBRAC_MORE            
    { $$ = locate(new Expr.E_quoted_expr ($2), $2); }
  | LESS_SQBRAC KW_MATCH ':' pattern SQBRAC_MORE
    { $$ = locate(new Expr.E_quoted_patt ($4), $4); }
  | LESS_SQBRAC KW_TYPE ':' locator ty SQBRAC_MORE
    { $$ = set_location(new Expr.E_quoted_type ($5), $4); }
  | '(' expr ')'      { $$ = $2; }
  | located_id     { $$ = locate(new Expr.E_ref($1.name), $1); }

  | unquoted_expr

unquoted_expr:
    '$' '(' expr ')'
    { $$ = locate(new Expr.E_unquoted ($3), $3); }

  | '$' located_id
    { $$ = locate(new Expr.E_unquoted (new Expr.E_ref ($2.name)), $2);  }

args_list_expr:
    '.' '.' expr
    { $$ = locate(new Expr.E_expr_list($3), $3); }

comma_sep_exprs:
    expr ',' expr     { $$ = cons($1, cons($3, nil())); }
  | expr ',' comma_sep_exprs  { $$ = cons($1, $3); }
  | args_list_expr { $$ = cons($1, nil()); }

expr_or_sequence:
    list_exprs maybe_semicolon
      { $$ = List.rev($1); }
  | args_list_expr { $$ = cons($1, nil()); }

sequence:
    '{' locator '}'
    { $$ = set_location(new Expr.E_sequence(nil()), $2); }
  | '{' locator expr_or_sequence '}'
    { $$ = set_location(new Expr.E_sequence($3), $2); }

list_exprs:
    list_exprs ';' expr { $$ = cons($3, $1); }
  | expr      { $$ = cons($1, nil()); }


maybe_semicolon:
          /* */
        | ';'
  
lambda_head:
    ftyparms KW_FUN locator '(' local_fun_parms ')' maybe_type
    {
      Fun_header h = new Fun_header();
      h.name = tmp_name();
      h.parms = $5;
      h.ret_type = $7;
      h.typarms = $1;
      h.loc = $3;
      $$ = h;
    }

maybe_type:
   /* */	{ $$ = new Nemerle.Compiler.Parsetree.Type.T_infer (); }
 | ':' ty	{ $$ = $2; }
    
local_fun_def:
    ftyparms located_id '(' local_fun_parms ')' maybe_type sequence
    {
      Fun_header h = new Fun_header();
      
      h.typarms = $1;
      h.name = $2.name;
      h.parms = $4;
      h.ret_type = $6;
      h.loc = $2.loc;

      $$ = new Function_decl(h, $7);
    }

non_empty_parameters:
          parameter                       { $$ = cons($1, nil()); }
        | parameter ',' parameters        { $$ = cons($1, $3); }

parameters:
          /* */                           { $$ = nil(); }
        | non_empty_parameters   

parameter:
   maybe_ref expr
   { $$ = new Parm($1, $2, ""); }
 | maybe_ref ID '=' expr
   { $$ = new Parm($1, $4, $2); }

fun_defs:
          local_fun_def                         { $$ = cons($1, nil()); }
        | local_fun_def KW_AND fun_defs         { $$ = cons($1, $3); }


// PRODUCTION RULES FOR PATTERNS

match_cases:
          match_case                        { $$ = cons($1, nil()); }
        | match_case '|' match_cases        { $$ = cons($1, $3); }

list_patterns:
    list_patterns ';' pattern { $$ = cons($3, $1); }
  | pattern     { $$ = cons($1, nil()); }
  
pattern:
    located_qid          
    { $$ = locate(new Pattern.P_cons (new Splicable_string.SS_string($1.name), 
                                      new Pattern.P_underscore ()), $1); }
  |  splicable_qid tuple_pattern           
    { $$ = locate(new Pattern.P_cons ($1, $2), $1); }
  |  splicable_qid record_pattern           
    { $$ = locate(new Pattern.P_cons ($1, $2), $1); }

  | '_'
    { $$ = locate(new Pattern.P_underscore()); }

  | '[' locator ']'
    { $$ = set_location(new Pattern.P_list (nil()), $2); }
  | '[' locator list_patterns maybe_semicolon ']'
    { $$ = set_location(new Pattern.P_list (List.rev($3)), $2); }
  | '(' pattern ')' KW_AS splicable_id
    { $$ = locate(new Pattern.P_as ($2, $5), $5); }

  | pattern COLON_COLON pattern
    { $$ = locate(new Pattern.P_list_cons ($1, $3), $1); }
  | literal
    { $$ = locate(new Pattern.P_literal ($1)); }

  | tuple_pattern
  | record_pattern

  | LESS_SQBRAC expr SQBRAC_MORE
    { $$ = locate(new Pattern.P_quoted_expr ($2), $2); }

  | LESS_SQBRAC KW_MATCH ':' pattern SQBRAC_MORE
    { $$ = locate(new Pattern.P_quoted_patt ($4), $4); }

  | LESS_SQBRAC KW_TYPE ':' locator ty SQBRAC_MORE
    { $$ = set_location(new Pattern.P_quoted_type ($5), $4); }

  | unquoted_patt_expr

tuple_pattern:
  '(' comma_sep_patterns ')'
    { $$ = locate(new Pattern.P_tuple ($2)); }

  | '(' pattern ')'
    { $$ = locate(new Pattern.P_tuple (cons($2, nil())), $2); }

record_pattern:
   '{' record_patts maybe_semicolon '}'
    { $$ = locate(new Pattern.P_record (List.rev ($2))); }

unquoted_patt_expr:
    '$' '(' expr ')'
    { $$ = locate(new Pattern.P_unquoted ($3), $3); }
  | '$' located_id
    { $$ = locate(new Pattern.P_unquoted (new Expr.E_ref($2.name)), $2); }

args_list_patt:
    '.' '.' pattern
    { $$ = locate(new Pattern.P_patt_list($3), $3); }
  
comma_sep_patterns:
          pattern ',' pattern                 { $$ = cons($1, cons($3, nil())); }
        | pattern ',' comma_sep_patterns      { $$ = cons($1, $3); }
        | args_list_patt                      { $$ = cons($1, nil()); }

record_patts:
          record_patts ';' record_patt              { $$ = cons($3, $1); }
        | record_patt                               { $$ = cons($1, nil()); }

record_patt:
    	ID '=' pattern
             { $$ = new Named_pattern($1, $3); }

guarded_pattern:
    pattern KW_WHEN expr
    { $$ = new Nemerle.Tuple2($1, some($3)); }
  | pattern
    { $$ = new Nemerle.Tuple2($1, none()); }

guarded_patterns:
    guarded_pattern '|' guarded_patterns
    { $$ = cons($1, $3); }
  | guarded_pattern
    { $$ = cons($1, nil()); }
    
match_case:
  guarded_patterns EQ_MORE expr_or_sequence
    { $$ = new Match_case($1, new Expr.E_sequence($3)); }

%%

}
