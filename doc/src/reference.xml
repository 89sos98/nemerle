<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle Language Reference</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document presents in a semi-formal way the syntax and semantics
        of the Nemerle language. It is not meant to be a tutorial.
      </p>
      <p>
        We often refer to <tt>.NET</tt> terminology [FIXME: reference it].
      </p>
    </body>
  </section>


  <section id="lexical">
    <title>Lexical Conventions</title>
    <body>
      <p>
        Programs are written using the Unicode character set. Every
        Nemerle source file is reduced to a sequence of lexical units
        (tokens) separated by sequences of white characters (blanks).
      </p>
    </body>
    <subsection id="tokens">
      <title>Tokens</title>
      <body>
        <p>
          There are five classes of lexical tokens: 
        </p>
        <ul>
          <li>identifiers</li>
          <li>type variables</li>
          <li>keywords</li>
          <li>literals</li>
          <li>blanks</li>
        </ul>
<code>
/* A comment. */
// Also a comment

foo               // identifier
foo_bar foo' foo3 // other identifiers
42                // integer literal
1_000_000         // _ can be used for readability
1_42_00           // or unreadability...
0x2a              // hexadecimal integer literal
0o52              // octal integer literal
0b101010          // binary integer literal
'a'               // character literal
'\n'              // also a character literal
"foo\nbar"        // string literal
"foo" "bar"       // same as "foobar"
@"x\n"            // same as "x\\n"
@if               // keyword used as identifier
</code>
<code>
3.14f             // float literal
3.14d, 3.14       // double literal
3.14m             // decimal literal
</code>
<code>
10         // int
10u        // unsigned int
10b        // signed byte
10ub, 10bu // unsigned byte
10L        // long
10UL, 10LU // unsigned long
</code>
      </body>
    </subsection>
    <subsection id="blanks">
      <title>Blanks</title>
      <body>
        <p>
          Spaces, vertical and horizontal tabulation characters,
          new-page characters, new-line characters and comments (called blanks
          altogether) are discarded, but can separate other lexical tokens.
        </p>
        <p>
          A traditional comment begins with a <tt>/*</tt>, and ends with
          <tt>*/</tt>. An end-of-line comment starts with <tt>//</tt>,
          and ends with the line terminator (ASCII LF character).
        </p>
      </body>
    </subsection>
    <subsection id="preprocessing">
      <title>Preprocessing directives</title>
      <body>
        <p>
          There is a set of preprocessing directives used for conditional
          compilation and changing line numbering context. They are the same
          as in <a ref="http://www.jaggersoft.com/csharp_standard/9.5.htm">C#</a>.
          Allowed directives are: 
          <tt>#define</tt>, <tt>#undef</tt>, <tt>#if</tt>, <tt>#elif</tt>, 
          <tt>#else</tt>, <tt>#endif</tt>, <tt>#line</tt>, <tt>#error</tt>,
          <tt>#warning</tt>, <tt>#region</tt> and <tt>#endregion</tt>.
         </p>
      </body>
    </subsection>
    <subsection id="identifiers">
      <title>Identifiers</title>
      <body>
        <p>
          Ordinary identifiers consist of letters, digits, underscores
          and apostrophe, but cannot begin with a digit nor an apostrophe.
          Identifiers may be quoted with the <tt>@</tt> character, which
          is stripped. It removes any lexical and syntactic meaning from
          the following string of characters until blank, thus enabling
          programmer to use keywords as identifiers.
        </p>
        <p>
          There is an important difference between identifiers starting
          with underscore character <tt>_</tt> and the other ones.
          When you define local value with name starting with <tt>_</tt>
          and won't use it, compiler won't complain about it. It will
          warn about other unused values though.
        </p>
        <p>
          Symbolic identifiers consist of following characters: 
          <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>@</tt>,
          <tt>^</tt>, <tt>|</tt>, <tt>&amp;</tt>, <tt>+</tt>, <tt>-</tt>,
          <tt>*</tt>, <tt>/</tt>, <tt>$</tt>, <tt>%</tt>, <tt>!</tt>,
          <tt>?</tt>, <tt>~</tt>, <tt>.</tt>, <tt>:</tt>, <tt>#</tt>.
          Symbolic identifiers are treated as standard identifiers except
          to the fact that they are always treated as infix operators.
        </p>
      </body>
    </subsection>
    <subsection id="keywords">
      <title>Keywords</title>
      <body>
        <p>
          Following identifiers are used as keywords, and may not be
          used in any other context unquoted:
          <tt>_</tt>, <tt>abstract</tt>, <tt>and</tt>, <tt>array</tt>,
          <tt>as</tt>, <tt>base</tt>, <tt>catch</tt>, <tt>class</tt>,
          <tt>def</tt>, <tt>delegate</tt>, <tt>do</tt>, <tt>else</tt>,
          <tt>enum</tt>, <tt>event</tt>, 
          <tt>extern</tt>, <tt>false</tt>, <tt>finally</tt>,
          <tt>for</tt>, <tt>foreach</tt>, <tt>fun</tt>, <tt>if</tt>,
          <tt>implements</tt>, <tt>in</tt>, <tt>interface</tt>,
          <tt>internal</tt>, <tt>lock</tt>, <tt>macro</tt>,
          <tt>match</tt>, <tt>module</tt>, <tt>mutable</tt>,
          <tt>namespace</tt>, <tt>new</tt>, <tt>null</tt>, <tt>out</tt>,
          <tt>override</tt>, <tt>params</tt>, <tt>private</tt>,
          <tt>protected</tt>, <tt>public</tt>, <tt>ref</tt>,
          <tt>sealed</tt>, <tt>static</tt>, <tt>struct</tt>,
          <tt>syntax</tt>, <tt>this</tt>, <tt>throw</tt>, <tt>true</tt>,
          <tt>try</tt>, <tt>type</tt>, <tt>typeof</tt>, <tt>unless</tt>,
          <tt>using</tt>, <tt>variant</tt>, <tt>virtual</tt>,
          <tt>void</tt>, <tt>when</tt>, <tt>where</tt>, <tt>while</tt>,
          <tt>assert</tt>, <tt>ignore</tt>.
        </p>
        <p>
          Following infix identifiers are reserved keywords:
          <tt>=</tt>, <tt>$</tt>, <tt>?</tt>, <tt>|</tt>, <tt>&lt;-</tt>,
          <tt>-&gt;</tt>, <tt>=&gt;</tt>, <tt>&lt;[</tt>, <tt>]></tt>,
          <tt>&amp;&amp;</tt>, <tt>||</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="literals">
      <title>Literals</title>
      <body>
        <p>
          There are few kinds of literals:
            </p>
        <ul>
          <li>
            String literals, enclosed in <tt>""</tt>. Compiler processes
            backslash escapes much like in C#. You can use <tt>$</tt> operator 
            before the string literal to enable string interpolation feature 
            (the `$' operator is now a shorthand to Nemerle.IO.sprint).
<code>
def x = 40;
def y = 42;
System.Console.Write ($ "$(x + 2) == $y\n")
</code>
            Any expression can be used in $(...), but there might be problems
            with embedded strings and so on. It is meant to be used with simple
            expressions like array/field access, method call, etc.
          </li>
          <li>
            Raw string literals, written like ordinary string literals,
            but prefixed with <tt>@</tt>. Escapes are not processed.
          </li>
          <li>
            Character literals, enclosed in <tt>'</tt>. Escapes are
            processed.
          </li>
          <li>
            Numeric literal are allowed have suffix describing their type
            as seen in <a ref="#tokens">tokens</a> section.
          </li>
          <li>
            Integer literals, possibly prefixed with <tt>0x</tt>,
            <tt>0o</tt> or <tt>0b</tt> to denote hexadecimal, octal or
            binary encoding respectively. 
          </li>
          <li>
            Floating point literals, defined as:
            <rule name="floating_point_literal">
              <non-terminal name="digits"/>
              <terminal name="."/>
              <optional>
                 <non-terminal name="digits"/>
              </optional>
              <optional>
                 <non-terminal name="exponential_marker"/>
                 <optional>
                    <non-terminal name="sign"/>
                 </optional>
                 <non-terminal name="digits"/>
              </optional>
            </rule>
            <rule name="digits">
              <nonterminal name="digit"/>
              <repeat>
                <nonterminal name="digit"/>
              </repeat>
            </rule>
            <rule name="exponential_marker">
              <terminal name="e"/>
            </rule>
            <rule name="exponential_marker">
              <terminal name="E"/>
            </rule>
            <rule name="sign">
              <terminal name="+"/>
            </rule>
            <rule name="sign">
              <terminal name="-"/>
            </rule>
          </li>
        </ul>
      </body>
    </subsection>
  </section>


  <section id="compilation-units">
    <title>Compilation units</title>
    <body>
      <rule name="compilation_unit">
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
      </rule>
      <p>
        A Nemerle program consists of one or more compilation
        units. Compilation units are text files with the <tt>.n</tt> 
        extension. A compilation unit consists of namespace-related 
        declarations and types within them.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="using"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Add the specified namespace (which, unlike in C#, can also be a
        type name) to the symbol search path. Every symbol till end of
        current namespace or compilation unit (if not within namespace)
        will be searched also in location specified by this path.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="using"/>
        <special-terminal name="IDENTIFIER"/>
        <terminal name="="/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Define an alias for a namespace or type. After <tt>using Foo =
        Bar.Baz;</tt> any reference to <tt>Foo.bar</tt> will be expanded
        to <tt>Bar.Baz.bar</tt>.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name="{"/>
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
        <terminal name="}"/>
      </rule>
      <p>
        Put declarations within the specified namespace. Namespaces can
        be nested, creating a tree of namespaces. 
      </p>
      <rule name="toplevel_declaration">
        <non-terminal name="type_declaration"/>
      </rule>
      <p>
        Define a new top level type.
      </p>
    </body>
  </section>


  <section id="misc">
    <title>Stuff that doesn't fit anywhere else</title>
    <body>
      <p>
        This section lists grammar rules common to most of other sections.
      </p>
    </body>
    <subsection id="id-or-dummy">
      <title>Identifier or dummy</title>
      <body>
        <rule name="identifier_or_dummy">
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <rule name="identifier_or_dummy">
          <terminal name="_"/>
        </rule>
        <p>
          In several places it is possible to use the <tt>_</tt> keyword to denote 
          the intent to ignore a parameter or a return value. Semantics of <tt>_</tt> 
          in such places is to generate a new temporary name. For example
          assigning to <tt>_</tt> means ignoring returned value of computed expression.
        </p>
      </body>
    </subsection>
    <subsection id="qid">
      <title>Qualified identifier</title>
      <body>
        <rule name="qualified_identifier">
          <special-terminal name="IDENTIFIER"/>
          <repeat>
            <terminal name="."/>
            <special-terminal name="IDENTIFIER"/>
          </repeat>
        </rule>
        <p>
          Identifiers can be qualified with namespaces.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-declarations">
    <title>Type declarations</title>
    <body>
      <p>
        Types are defined at the top level, within namespaces or within
        other types. Top level type names are prefixed with the namespace
        they are defined in. Nested type names are prefixed with the
        parent type name. Nesting affects accessibility of a type.
      </p>
    </body>
    <subsection id="ty-header">
      <title>Type header</title>
      <body>
        <rule name="type_header">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <non-terminal name="type_parameters"/>
          </optional>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
          </optional>
          <non-terminal name="where_constraints"/>
        </rule>
        <p>
          Type header is similar to .NET. The main difference is
          the optional <tt>type_parameters</tt> list, defined below.
        </p>
      </body>
    </subsection>
    <subsection id="ty-parms">
      <title>Type parameters</title>
      <body>
        <rule name="type_parameters">
          <terminal name="["/>
          <non-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <rule name="where_constraints">
          <repeat>
            <terminal name="where"/>
            <non-terminal name="TYPE_VARIABLE"/>
            <terminal name=":"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
          </repeat> 
        </rule>
        <rule name="TYPE_VARIABLE">
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          When defining polymorphic type one has to specify list
          of type variables in declaration. It can have following form:
        </p>
<code>
class Foo [a, b]
</code>
        <p>
          An optional list of <tt>where</tt> parameters can be used to add 
          constraints to the type variables (type coercion).
        </p>
<code>
where a : Nemerle.Collections.IEnumerable, IComparable
where b : Nemerle.Collections.IDictionary
</code>
      </body>
    </subsection>
    <subsection id="type-alias">
      <title>Type alias</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
          This type declaration creates an alias to another type.
        </p>
      </body>
    </subsection>
    <subsection id="interface-def">
      <title>Interface definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="interface"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="interface_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Nemerle interfaces are similar to .NET.
        </p>
      </body>
    </subsection>
    <subsection id="class-def">
      <title>Class definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="class"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Class definition is similar to .NET.
        </p>
      </body>
    </subsection>
    <subsection id="struct-def">
      <title>Structure definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="struct"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
      </body>
    </subsection>
    <subsection id="module-def">
      <title>Module definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="module"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          A module is much like a class, but all module members are
          static. There is no need to place <tt>static</tt> attributes
          on module members. It is also not possible to create instances
          of module types.
        </p>
      </body>
    </subsection>
    <subsection id="variant-def">
      <title>Variant definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="variant"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="variant_option"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          A variant declaration consists of a type name and a list of
          bar-separated constructors enclosed in brackets.
        </p>
        <rule name="variant_option">
          <terminal name="|"/>
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <terminal name="{"/>
            <repeat>
              <non-terminal name="field_definition"/>
            </repeat>
            <terminal name="}"/>
          </optional>
        </rule>
        <p>
          The constructor declaration describes the constructor
          associated to this variant type.  A constructor may take an
          argument. Constructor name must be capitalized.
        </p>
        <rule name="variant_option">
          <non-terminal name="type_member"/>
        </rule>
        <p>
          Variants (unlike variant options) can also have other members
          (methods and fields).
        </p>
      </body>
    </subsection>
    <subsection id="enum-def">
      <title>Enum type definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="enum"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <terminal name="|"/>
            <special-terminal name="IDENTIFIER"/>
            <optional>
              <terminal name="="/>
              <non-terminal name="literal"/>
            </optional>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Nemerle enums are similar to enums in C#.
        </p>
      </body>
    </subsection>
    <subsection id="delegate-def">
      <title>Delegate type definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="delegate"/>
          <non-terminal name="method_header"/>
        </rule>
      </body>
    </subsection>
  </section>


  <section id="attributes">
    <title>Attributes</title>
    <body>
      <p>
        The semantics of attributes is the same as in C#, except for
        <tt>mutable</tt> attribute, meaning lack of <tt>readonly</tt>.
      </p>
      <rule name="attributes">
        <repeat>
          <non-terminal name="attribute"/>
        </repeat>
      </rule>
      <rule name="attribute">
        <terminal name="new"/>
      </rule>
      <rule name="attribute">
        <terminal name="volatile"/>
      </rule>
      <rule name="attribute">
        <terminal name="public"/>
      </rule>
      <rule name="attribute">
        <terminal name="protected"/>
      </rule>
      <rule name="attribute">
        <terminal name="internal"/>
      </rule>
      <rule name="attribute">
        <terminal name="private"/>
      </rule>
      <rule name="attribute">
        <terminal name="abstract"/>
      </rule>
      <rule name="attribute">
        <terminal name="sealed"/>
      </rule>
      <rule name="attribute">
        <terminal name="override"/>
      </rule>
      <rule name="attribute">
        <terminal name="static"/>
      </rule>
      <rule name="attribute">
        <terminal name="mutable"/>
      </rule>
      <rule name="attribute">
        <non-terminal name="custom_attribute"/>
      </rule>
      <rule name="custom_attribute">
        <terminal name="["/>
        <optional>
          <non-terminal name="attribute_target"/>
        </optional>
        <non-terminal name="expr"/>
        <repeat>
          <terminal name=","/>
          <non-terminal name="expr"/>
        </repeat>
        <terminal name="]"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="assembly"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="field"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="event"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="method"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="module"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="param"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="property"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="return"/>
      </rule>
      <rule name="attribute_target">
        <terminal name="type"/>
      </rule>
    </body>
  </section>


  <section id="type-members">
    <title>Declarations within types</title>
    <body>
      <p>
        The following fields are allowed in <a ref="#class-def">class</a> 
        or <a ref="#module-def">module</a> body:
      </p>
      <rule name="type_member">
        <non-terminal name="field_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="property_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="event_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="method_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="type_declaration"/>
      </rule>
    </body>
    <subsection id="field-def">
      <title>Field definition</title>
      <body>
        <rule name="field_definition">
          <non-terminal name="attributes"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <optional>
            <terminal name="="/>
            <non-terminal name="expr"/>
          </optional>
          <terminal name=";"/>
        </rule>
        <p>
          Unless the optional <tt>mutable</tt> attribute is used, the field 
          can be modified only inside the constructor.
        </p>
      </body>
    </subsection>
    <subsection id="property-def">
      <title>Property definition</title>
      <body>
        <rule name="property_definition">
          <non-terminal name="attributes"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name="{"/>
          <non-terminal name="property_body"/>
          <terminal name="}"/>
        </rule>
        <rule name="property_body">
          <repeat>
            <non-terminal name="field_definition"/>
          </repeat>
          <terminal name="get"/>
          <non-terminal name="method_body"/>
          <optional>
          <terminal name="set"/>
          <non-terminal name="method_body"/>
          </optional>
        </rule>
        <rule name="property_body">
          <repeat>
            <non-terminal name="field_definition"/>
          </repeat>
          <terminal name="set"/>
          <non-terminal name="method_body"/>
          <optional>
          <terminal name="get"/>
          <non-terminal name="method_body"/>
          </optional>
        </rule>
        <p>
          The fields defined in a property are local for it, they cannot be 
          referenced outside the property.
        </p>
      </body>
    </subsection>
    <subsection id="event-def">
      <title>Event definition</title>
      <body>
        <rule name="event_definition">
          <non-terminal name="attributes"/>
          <terminal name="event"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name="{"/>
          <non-terminal name="event_body"/>
          <terminal name="}"/>
        </rule>
        <rule name="event_body">
          <terminal name="add"/>
          <non-terminal name="block"/>
          <terminal name="remove"/>
          <non-terminal name="block"/>
        </rule>
        <rule name="event_body">
          <terminal name="remove"/>
          <non-terminal name="block"/>
          <terminal name="add"/>
          <non-terminal name="block"/>
        </rule>
      </body>
    </subsection>
    <subsection id="interface-mem-def">
      <title>Interface member</title>
      <body>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <non-terminal name="method_header"/>
          <terminal name=";"/>
        </rule>
        <p>
          Keyword <tt>new</tt> is necessary when the declared method hides
          the inherited one from another interface.
        </p>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <terminal name="event"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <non-terminal name="property_body"/>
        </rule>
      </body>
    </subsection>
    <subsection id="method-def">
      <title>Method definition</title>
      <body>
        <rule name="method_definition">
          <non-terminal name="attributes"/>
          <non-terminal name="method_header"/>
          <non-terminal name="method_body"/>
        </rule>
        <p>
          This is a definition of method within class or module.
          Program entry point is method static <tt>Main</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="operator-def">
      <title>Operator definition</title>
      <body>
        <rule name="operator_definition">
          <non-terminal name="attributes"/>
          <non-terminal name="method_header"/>
          <non-terminal name="method_body"/>
        </rule>
        <p>
          Operator definitions must have <tt>static</tt> attribute. The name of
          method must be simply any valid <tt>OPERATOR</tt>, which can be then
          used (as a prefix or unary operator) on expressions of type specified
          by parameters.
        </p>
      </body>
    </subsection>
    <subsection id="method-head">
      <title>Method header</title>
      <body>
        <rule name="method_type_parameters">
          <terminal name="["/>
          <non-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <p>
          The declaration of a polymorphic method needs its type
          variables listed after the identifier.
        </p>
        <rule name="method_header">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
          <non-terminal name="method_implements"/>
        </rule>
        <p>
          This is a declaration of method. Unlike in C#, the type is specified after
          the parameters list.
        </p>
        <rule name="method_header">
          <terminal name="this"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
        </rule>
        <p>
          A special method named <tt>this</tt> specifies a constructor.
          This declaration cannot contain the method type and the method has
          to have type <tt>void</tt>.
        </p>
        <rule name="method_implements">
          <optional>
            <terminal name="implements"/>
            <non-terminal name="qualified_identifier"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="qualified_identifier"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-parms">
      <title>Method parameters</title>
      <body>
        <rule name="method_parameter">
          <optional>
            <terminal name="params"/>
          </optional>
          <non-terminal name="identifier_or_dummy"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
        </rule>
        <p>
          A method parameter is a pair consisting of <tt>identifier</tt>
          or <tt>_</tt> and its type specification. Type declaration can be
          omitted in local functions definitions.
        </p>
        <rule name="method_parameters">
          <optional>
            <non-terminal name="method_parameters"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="method_parameter"/>
            </repeat>
          </optional>
        </rule>
        <p>
          Method parameters are comma-separated list of parameter specification.
        </p>
      </body>
    </subsection>
    <subsection id="method-body">
      <title>Method body</title>
      <body>
        <rule name="method_body">
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <p>
          The method body can be linked to an external function, for example:
        </p>
<code>
static ps (s : string) : void = extern "System.Console.Write";
</code>
        <p>
          This feature is used to give meaning to infix operators. It
          is not currently fully supported. It should not be considered
          rock-stable feature.
        </p>
        <rule name="method_body">
          <terminal name=";"/>
        </rule>
        <p>
          Empty method body (a <tt>;</tt>) is a method declaration.
        </p>
        <rule name="method_body">
          <non-terminal name="block"/>
        </rule>
        <p>
          This is a classical method definition.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-expressions">
    <title>Type expressions</title>
    <body>
      <p>
        Type expressions relate to <a ref="#type-declarations">type
        declarations</a> much like function calls relate to function
        and value definitions. Type declarations define ways of constructing types
        and type expressions define actual types.
      </p>
      <p>
        Types are both static and dynamic characterization of values.
        The static type of expression depends on its building blocks and
        is defined in the paragraph describing given expression. The dynamic
        (runtime) type is bound to the value at the moment it is created,
        and remains there until the value is garbage collected.
      </p>
      <p>
        The type system is modeled after .NET Generics design, except
        for tuple and function types, which are new, but can be easily
        simulated using generics.
      </p>
    </body>
    <subsection id="type-app">
      <title>Type constructor application</title>
      <body>
        <rule name="primary_type">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <terminal name="["/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
            <terminal name="]"/>
          </optional>
        </rule>
        <p>
          A type constructor (defined with <a ref="#type-definitions">type
          declaration</a>) can be applied to zero or more arguments
          forming a type expression. The number of type arguments in type
          application must match the number of <a ref="#ty-parms">type
          arguments</a> in definition.  Moreover, actual type arguments
          must solve <a ref="#ty-parms"><tt>where</tt> constraints</a>
          imposed on formal type arguments.
        </p>
      </body>
    </subsection>
    <subsection id="tyvar">
      <title>Type variable reference</title>
      <body>
        <rule name="primary_type">
          <non-terminal name="TYPE_VARIABLE"/>
        </rule>
        <p>
          Refer to the type substituted to a given type variable. The type
          variable has to be defined (bound, quantified) before it is used.
          A type variable can be defined in <a ref="#ty-parms">type
          arguments</a> or <a ref="#method-head">method header</a>
          (of a global or local function).
        </p>
      </body>
    </subsection>
    <subsection id="group-ty">
      <title>Grouping types</title>
      <body>
        <rule name="primary_type">
          <terminal name="("/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          This construct has no semantic meaning -- it exists only to
          enforce particular syntax decomposition.
        </p>
      </body>
    </subsection>
    <subsection id="void-ty">
      <title>Void type</title>
      <body>
        <rule name="primary_type">
          <terminal name="void"/>
        </rule>
        <p>
          This is mostly an alias for <tt>System.Void</tt> -- a type with
          exactly one inhibiting value.  It is, however, a first class value
          -- it can be passed as a function parameter as well as returned
          from functions.
        </p>
        <p>
          The name comes from <tt>System.Void</tt>, but should be in
          fact <tt>unit</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="ref-out-ty">
      <title>Ref and Out types</title>
      <body>
        <rule name="primary_type">
          <terminal name="ref"/>
          <non-terminal name="primary_type"/>
        </rule>
        <rule name="primary_type">
          <terminal name="out"/>
          <non-terminal name="primary_type"/>
        </rule>
        <p>
          These are for parameters passed by reference.
        </p>
      </body>
    </subsection>
    <subsection id="array-ty">
      <title>Array types</title>
      <body>
        <rule name="primary_type">
          <terminal name="array"/>
          <terminal name=".["/>
          <optional>
            <special-terminal name="NUMBER_LITERAL"/>
            <terminal name=","/>
          </optional>
          <non-terminal name="type"/>
          <terminal name="]"/>
        </rule>
        <p>
          Define array type. The number is the rank. It defaults to one.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ty">
      <title>Tuple type</title>
      <body>
        <rule name="type">
          <non-terminal name="primary_type"/>
          <repeat>
            <terminal name="*"/>
            <non-terminal name="primary_type"/>
          </repeat>
        </rule>
        <p>
          Construct product (tuple) type. This operator is not associative, which
          means that each two of following types are different:
        </p>
<code>
int * int * int
(int * int) * int
int * (int * int)
</code>
      </body>
    </subsection>
    <subsection id="function-ty">
      <title>Function type</title>
      <body>
        <rule name="type">
          <non-terminal name="type"/>
          <terminal name="->"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          Construct function type with a specified argument and return
          types respectively. The <tt>-></tt> operator is right
          associative, which means that the following types are equivalent:
        </p>
<code>
int -> int -> int
int -> (int -> int)
</code>
        <p>
          Multi-argument function types are written using tuple notation,
          for example after local declaration:
        </p>
<code>
def some_function (a : int, b : string) : float { ... }
</code>
        <p>
          the expression <tt>some_function</tt> has type <tt>int *
          string -> float</tt>.
        </p>
      </body>
    </subsection>
  </section>

  <section id="literal-exprs">
    <title>Literal expressions</title>
    <body>
      <p>
        These are used in expressions and patterns.
      </p>
    </body>
    <subsection id="boolean-lit">
      <title>Boolean</title>
      <body>
        <rule name="literal">
          <terminal name="true"/>
        </rule>
        <rule name="literal">
          <terminal name="false"/>
        </rule>
        <p>
          These literals have type <tt>bool</tt> and represent respectively
          true (false) boolean value. 
        </p>
      </body>
    </subsection>
    <subsection id="null-lit">
      <title>Null</title>
      <body>
        <rule name="literal">
          <terminal name="null"/>
        </rule>
        <p>
          Represents null reference, one that does not refer to any
          object.  It possesses types of all reference types -- can be
          used in any context reference type is required. It does not,
          however, possess the <tt>void</tt> type nor any value type
          (like <tt>System.Int32</tt> or <tt>System.Single</tt>).
        </p>
      </body>
    </subsection>
    <subsection id="void-lit">
      <title>Void</title>
      <body>
        <rule name="literal">
          <terminal name="("/>
          <terminal name=")"/>
        </rule>
        <p>
          Indicates returning no value. It is the only possible value of type <tt>void</tt>.
          See also <a ref="void-ty">void type</a>.
        </p>
      </body>
    </subsection>
    <subsection id="string-lit">
      <title>String</title>
      <body>
        <rule name="literal">
          <special-terminal name="STRING_LITERAL"/>
        </rule>
        <p>
          Represents <tt>string</tt> constant. Nemerle supports two forms of string:
        </p>
        <ul>
         <li> regular string literals </li>
         <li> verbatim string literals </li>
        </ul>
        
        <p>
          A regular string literal consists of zero or more characters enclosed in double
          quotes and may include both simple escape sequences (such as \n for the newline
          character) and hexadecimal and Unicode escape sequences (See 
          <a ref="character">character literals</a> for details).
        </p>
        <p>
          A verbatim string literal consists of an @ character followed by a double-quote 
          character, zero or more characters, and a closing double-quote character. 
          In a verbatim string literal, the characters between the double-quotes are recognized
          verbatim, the only exception is a sequence <tt>""</tt> (used to indicate <tt>'"'</tt>
          character) (Note that simple escape sequences and hexadecimal and Unicode escape sequences 
          are not recognized in verbatim string literals). A verbatim string literal may span
          multiple lines. 
        </p>
        <p>
          Examples:
        </p>
<code>
def s1 = "Nemerle string !";            // Nemerle string !
def s2 = @"Nemerle string !";           // Nemerle string !
def s3 = "Nemerle\tstring !";           // Nemerle    string !
def s4 = @"Nemerle\tstring !";          // Nemerle\tstring !
def s5 = "I heard \"zonk !\"";          // I heard "zonk !"
def s6 = @"I heard ""zonk !""";         // I heard "zonk !"
def s7 = "\\\\trunk\\ncc\\ncc.exe";     // \\trunk\ncc\ncc.exe
def s8 = @"\\trunk\ncc\ncc.exe";        // \\trunk\ncc\ncc.exe
def s9 = "\"Nemerle\"\nstring\n!";      // "Nemerle"
                                        // string
                                        // !
def s10 = @"""Nemerle""                 // same as s9
rocks
!";
</code>
        <p>
          String s10 is a verbatim string literal that spans 3 lines.
        </p>
      </body>
    </subsection>
    <subsection id="number">
      <title>Number</title>
      <body>
        <rule name="literal">
          <special-terminal name="NUMBER_LITERAL"/>
        </rule>
        <p>
          Represents one of numeric types. See <a ref="literals"> literals </a> for details
          of representing particular numerical types.  
        </p>
      </body>
    </subsection>
    <subsection id="character">
      <title>Character</title>
      <body>
        <rule name="literal">
          <special-terminal name="CHARACTER_LITERAL"/>
        </rule>
        <p>
          A character literal consists of one character enclosed in single-quotes (' ')
          or escape character of form '\X' where X can be one of the following:
          [FIXME: characters with (N) are not implemented yet (will they?)]
        </p>
        <ul>
          <li> \, ', " - this allows representation of (respectively) backslash, single-quote
            double-quote </li> 
          <li> 0X - where X is an octal ASCII code (up to three digits) of the character we want to represent (N)</li>
          <li> xX - where X is an hexadecimal ASCII code (exactly two digits) of the character we want to represent (N) </li>
          <li> uX - where X is an hexadecimal UNICODE code (exactly four digits) of the character we want to represent (N)</li>
          <li> a - matches a bell (alarm) (N)</li>
          <li> b - matches a backspace \u0008 </li>
          <li> r - matches carriage return \u000D </li> 
          <li> v - matches vertical tab \u000B (N)</li>
          <li> f - matches form feed \u000C (N)</li>
          <li> n - matches a new line \u000A </li>
          <li> e - matches an escape \u001B (N)</li>
          <li> cX - matches an ASCII control character; for example \cC represents control-C (N) </li>
        </ul>
        <p>
          It has type <tt>char</tt>.
        </p>
      </body>
    </subsection>
  </section>


  <section id="prim-expressions">
    <title>Primary expressions</title>
    <body>
      <p>
        Primary expressions are a grammar category referring to expressions
        that have a closed structure and are otherwise simple. Primary
        expressions and plain expressions do not differ at the semantic
        level.
      </p>
    </body>
    <subsection id="literal-ref">
      <title>Literal expression</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="literal"/>
        </rule>
        <p>
          The value and type of an expression being literal is the value
          and the type of the respective literal.
        </p>
      </body>
    </subsection>
    <subsection id="variable-ref">
      <title>Variable reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="qualified_identifier"/>
        </rule>
        <p>
          This expression result is a variable itself (not its value).  [[FIXME: hem?!]]
          Type of this expression is <tt>ref 'a</tt> where <tt>'a</tt> is
          a type of variable being referenced.
        </p>
      </body>
    </subsection>
    <subsection id="this-ref">
      <title>this pointer reference</title>
      <body>
        <rule name="primary_expr">
          <terminal name="this"/>
        </rule>
        <p>
          This expression can only be used within non-static methods and indicates
          a reference to the current instance of the class (which posses this method).
        </p>
        <p>
          Expression like <tt>this.foo</tt> can be shortened to
          <tt>foo</tt> unless it would generate an identifier ambiguity
          with some variable being in this lexical scope.
        </p>
        <p>
          The <tt>this</tt> keyword can be also used to call instance
          constructor from another constructor.
        </p>
      </body>
    </subsection>
    <subsection id="base-ref">
      <title>base pointer reference</title>
      <body>
        <rule name="primary_expr">
          <terminal name="base"/>
        </rule>
        <p>
          This expression can only be used within non-static methods
          and indicates a reference to the current instance of the class
          coerced to the type of the base class. Calls made on
          <tt>base</tt> pointer are non virtual.
        </p>
        <p>
          The <tt>base</tt> keyword can be also used to call instance
          constructor of base class from another constructor.
        </p>
      </body>
    </subsection>
    <subsection id="grouping">
      <title>Grouping expression</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
        </rule>
        <p>
          A grouping expression allows to enforce particular syntax
          decomposition of expression.
        </p>
      </body>
    </subsection>
    <subsection id="member-ref">
      <title>Member reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="primary_expr"/>
          <terminal name="."/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          This expression allows referring to the field or method that the
          object represented by <non-terminal name="primary_expr"/>
          contains.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ctor">
      <title>Tuple constructor</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <repeat-plus>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat-plus>
          <terminal name=")"/>
        </rule>
        <p>
          This expression allows creating a tuple of <non-terminal
          name="expr"/> whose types may differ.  The type of that tuple
          is <tt>type_1 * ... * type_n</tt> where type_1 and the following
          are types of corresponding expressions.
        </p>
      </body>
    </subsection>
    <subsection id="indexer-ref">
      <title>Indexer reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="expr"/>
          <terminal name="["/>
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <p>
          This expression allows to refer to indexed (even by multiple
          indexes) fields of objects represented by leftmost <non-terminal
          name="expr"/> where second (and further) <non-terminal
          name="expr"/> are indexes values of the field we want to refer to.
          <non-terminal name="expr"/> must refer to an indexing object.
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="core-expressions">
    <title>Core Expressions</title>
    <body>
       <p>
       </p>
    </body>
    <subsection id="prim-expr-ref">
      <title>Primary expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
        </rule>
        <p>
          The value and type are the same as <non-terminal
          name="primary_expr"/> we are referring to.
        </p>
      </body>
    </subsection>
    <subsection id="call">
      <title>Function call</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="("/>
          <optional>
            <non-terminal name="parameter"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="parameter"/>
            </repeat>
          </optional>
          <terminal name=")"/>
        </rule>
        <p>
          Call a function with given parameters. The type of the function call
          expression is the same as the type of the function return value;
          that is, if the function's type is <tt>'a -> 'b</tt>, then the type of
          the function call expression is <tt>'b</tt>. The value of the whole
          expression is the return value of the function.
        </p>
      </body>
    </subsection>
    <subsection id="assign">
      <title>Assignment</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Assign a value to a variable. The left side of the assignment expression
          must evaluate to a mutable variable. The type of the assignment is
          always <tt>void</tt>.
        </p>
        <p>
          In earlier versions there was <tt>&lt;-</tt> assignment operator,
          which is now (Nemerle 0.2.x) deprecated.
        </p>
      </body>
    </subsection>
    <subsection id="match-expr">
      <title>Match expression</title>
      <body>
        <rule name="expr">
          <terminal name="match"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          <tt>expr</tt> is matched sequentially to the patterns in given
          match cases. If one of the patterns is consistent with the value of
          <tt>expr</tt>, then the corresponding computation branch of the
          match case is evaluated. Patterns in all the match cases must be of
          the same type. Expressions being computation branches in all the
          match cases must be of the same type, as well. The type of the match
          expression is the same as the type of the computation branch in
          all the match cases.
        </p>
      </body>
    </subsection>
    <subsection id="throw-expr">
      <title>Throw expression</title>
      <body>
        <rule name="expr">
          <terminal name="throw"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Throws given exception. The expression given must be of type
          <tt>System.Exception</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="try-catch">
      <title>Try..catch expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="block"/>
          <terminal name="catch"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="try_catch_handler"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="try_catch_handler"/>
          </repeat>
          <terminal name="}"/>
          <optional>
            <terminal name="finally"/>
            <non-terminal name="block"/>
          </optional>
        </rule>
        <p>
          If the evaluation of <tt>expr</tt> does not throw any exception,
          then the result is that of the evaluation of <tt>expr</tt>.
          Otherwise, the runtime type of the exception which was
          thrown is compared against each type description in handlers.
          The first matching handler is executed and its value returned. If
          none of the handlers matches, the exception is propagated.
          The type of the whole expression is the same as type of
          guarded expression. The value is the value of expression or
          launched handler.  Consult <tt>.NET</tt> specification if you
          want to know more about exceptions.
        </p>
        <p>
          The optional <tt>finally</tt> clause has the same meaning as below.
        </p>
      </body>
    </subsection>
    <subsection id="try-finally">
      <title>Try..finally expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="block"/>
          <terminal name="finally"/>
          <non-terminal name="block"/>
        </rule>
        <p>
          Evaluates the first expression and -- regardless of whether the
          evaluation has finished correctly or some exception has been thrown
          during the evaluation -- the second expression is evaluated. The
          value (and thus the type) of the whole expression is the value of
          the first expression.
        </p>
      </body>
    </subsection>
    <subsection id="unary-op">
      <title>Unary operator application</title>
      <body>
        <rule name="expr">
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Unary operator for integer types:
        </p>
        <ul>
          <li><tt>++</tt> prefix increment with <tt>void</tt> return type</li>
          <li><tt>--</tt> prefix decrement with <tt>void</tt> return type</li>
        </ul>
      </body>
    </subsection>
    <subsection id="binary-op">
      <title>Binary operator application</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          There is a number of standard operators, which are predefined for
          arithmetic types (floating point and integer): 
        </p>
        <ul>
          <li><tt>~</tt> bitwise negation</li>
          <li><tt>-</tt> subtraction</li>
          <li><tt>*</tt> multiplication</li>
          <li><tt>/</tt> division</li>
          <li><tt>&lt;</tt> less comparison</li>
          <li><tt>></tt> more comparison</li>
          <li><tt>&lt;=</tt> less-equals</li>
          <li><tt>>=</tt> more-equals</li>
          <li><tt>==</tt> equality</li>
          <li><tt>!=</tt> inequality</li>
          <li><tt>+=</tt> addition with assignment</li>
          <li><tt>-=</tt> subtraction with assignment</li>
          <li><tt>*=</tt> multiplication with assignment</li>
          <li><tt>/=</tt> division with assignment</li>
        </ul>
        <p>
          For integer types only (int, uint, short, ushort, long,
          ulong, byte, sbyte) there are:
        </p>
        <ul>
          <li><tt>&lt;&lt;</tt> left bitwise shift</li>
          <li><tt>>></tt> right bitwise shift</li>
          <li><tt>%</tt> modulus</li>
          <li><tt>%=</tt> modulus with assignment</li>
          <li><tt>&lt;&lt;=</tt> left bitwise shift with assignment</li>
          <li><tt>>>=</tt> right bitwise shift with assignment</li>
          <li><tt>|</tt> bitwise or</li>
          <li><tt>&amp;</tt> bitwise and</li>
          <li><tt>^</tt> bitwise xor</li>
          <li><tt>%||</tt> bitwise `or' returning true iff result of `or' is nonzero</li>
          <li><tt>%&amp;&amp;</tt> bitwise `and' returning true iff result of `and' is nonzero</li>
          <li><tt>%^^</tt>  bitwise `xor' returning true iff result of `xor' is nonzero</li>
          <li><tt>|=</tt> bitwise or with assignment</li>
          <li><tt>&amp;=</tt> bitwise and with assignment</li>
          <li><tt>^=</tt> bitwise xor with assignment</li>
        </ul>
      </body>
    </subsection>
    <subsection id="type-cast">
      <title>Type cast</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          This expression allows dynamic type coercion. It is
          done during runtime and if it cannot be realized then
          <tt>System.InvalidCastException</tt> is thrown. If it
          succeeds, the type of this expression is equal to the type of
          <non-terminal name="type"/>.
        </p>
      </body>
    </subsection>
    <subsection id="type-enf">
      <title>Type enforcement</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          This expression allows static type enforcement. It is checked
          during compile-time and an error is reported if <non-terminal
          name="expr"/> type is not a subtype of <non-terminal
          name="type"/>.  It allows only type widening. If it succeeds, the
          type of this expression is equal to the type of <non-terminal
          name="type"/>.
        </p>
      </body>
    </subsection>
    <subsection id="single-match">
      <title>One-case matching</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <terminal name="matches"/>
          <non-terminal name="pattern"/>
        </rule>
        <p>
          Equivalent to <tt>match (expr) { pattern => true | _ => false }</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="type-check">
      <title>Dynamic type check</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <terminal name="is"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          Equivalent to <tt>match (expr) { _ is type => true | _ => false }</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="checked-unchecked">
      <title>checked/unchecked blocks</title>
      <body>
        <rule name="expr">
          <terminal name="checked"/>
          <non-terminal name="expr"/>
        </rule>
        <rule name="expr">
          <terminal name="unchecked"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Turn on/off overflow checking for arithmetic operators. Checks are
          on by default.
        </p>
      </body>
    </subsection>
    <subsection id="block-ref">
      <title>Block expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="sequence"/>
        </rule>
        <p>
          The value (and thus the type) of the whole expression is the value of
          the last expression in the sequence.
        </p>
      </body>
    </subsection>
    <subsection id="array-ctor">
      <title>Array constructor</title>
      <body>
        <rule name="expr">
          <terminal name="array"/>
          <optional>
            <terminal name=".["/>
            <special-terminal name="NUMBER_LITERAL"/>
            <terminal name="]"/>
          </optional>
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=","/>
            </repeat>
            <non-terminal name="expr"/>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          Create an array consisting of given elements. All elements must be
          of the same type. If the elements are of the type <tt>'a</tt> then
          the whole expression is of the type <tt>array ['a]</tt>.
        </p>
        <p>
          The number in <tt>[]</tt> is array rank. It defaults to 1.
          If rank is specified, rows, columns and so on are specified using
          nested <tt>[]</tt>, like in:
        </p>
<code>
array .[2] [[1, 2], [3, 4], [5, 6]]
array .[3] [[[1, 2], [10, 20]], [[11, 12], [110, 120]]]
</code>
      </body>
    </subsection>
    <subsection id="value-def">
      <title>Value definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="pattern"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Defines the binding between the variables in the pattern and the
          value of the expression <tt>expr</tt> which will be known to all
          subsequent expressions in the current block.
        </p>
      </body>
    </subsection>
    <subsection id="local-fun-def">
      <title>Local function definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="method_header"/>
          <non-terminal name="block"/>
          <repeat>
            <terminal name="and"/>
            <non-terminal name="method_header"/>
            <non-terminal name="block"/>
          </repeat>
        </rule>
        <p>
          Defines the functions which will be known to all subsequent
          expressions in the current block. Names of all defined functions are
          put into the symbol space before their bodies are parsed.
        </p>
      </body>
    </subsection>
    <subsection id="mutable-def">
      <title>Mutable value definition</title>
      <body>
        <rule name="expr">
          <terminal name="mutable"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Defines a new variable, value of which can be changed at any time
          using the assignment expression.
        </p>
      </body>
    </subsection>
  </section>
  

  <section id="macro-expressions">
    <title>Secondary Expressions</title>
    <body>
      <p>
        This section describes expressions that are in fact just syntactic sugar
        over Core Expressions. We just present a translation of Secondary Expressions
        into Core Expressions.
      </p>
    </body>
    <subsection id="if-expr">
      <title>Conditional expression</title>
      <body>
        <rule name="expr">
          <terminal name="if"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
          <terminal name="else"/>
          <non-terminal name="expr"/>
        </rule>
          <p>   
            A standard branch, which executes and returns value of first expression 
            if the condition evaluates to true or second elsewhere.
          </p>
          <p>
            Internally it is translated into
          </p>
<code>
match (cond) {
  | true => expr1
  | false => expr2
}
</code>             
      </body>
    </subsection>
    <subsection id="while-expr">
      <title>While loop</title>
      <body>
        <rule name="expr">
          <terminal name="while"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          A loop, executing body expression as long as the condition is true.
          Its value is always checked before the execution of body and if it
          evaluates to false, then the loop ends.The body must be of type 
          <tt>void</tt>.
        </p>
        <p>
          The loop is translated internally into the following code
        </p>
<code>
def loop () {
  if (cond) 
    { body; loop () }
  else
    ()
};
loop ()
</code>
      </body>
    </subsection>
    <subsection id="do-while-expr">
      <title>do ... while loop</title>
      <body>
        <rule name="expr">
          <terminal name="do"/>          
          <non-terminal name="expr"/>
          <terminal name="while"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
        </rule>
        <p>
          This loop is similar to <tt>while</tt> loop, but body is executed
          before the first time the condition is checked.
        </p>
      </body>
    </subsection>
    <subsection id="when-expr">
      <title>When expression</title>
      <body>
        <rule name="expr">
          <terminal name="when"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          A version of the <tt>if</tt> condition, but having only one branch --
          execution of body only when the condition is satisfied. If its value
          if <tt>false</tt>, then nothing is done (i. e. <tt>()</tt> is 
          returned).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) body else ()
</code>
      </body>
    </subsection>
    <subsection id="unless-expr">
      <title>Unless expression</title>
      <body>
        <rule name="expr">
          <terminal name="unless"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          An opposite version of <tt>when</tt>. It executes and returns value
          of body only if conditions are not satisfied (i. e. evaluates to 
          <tt>false</tt>).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) () else body
</code>
      </body>
    </subsection>
    <subsection id="lambda-expr">
      <title>Lambda expression</title>
      <body>
        <rule name="expr">
          <terminal name="fun"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
          Lambda expressions can be thought as of anonymous local functions.
          This construct defines such a function and returns it as a
          functional value. This value can be used just like the name of 
          a regular local function.
        </p>
        <p>
          Example:
        </p>
<code>
List.Iter (fun (x) { printf ("%d\n", x) }, intList)
</code>
        <p>
          is equivalent to
        </p>
<code>
def tmpfunc (x) { printf ("%d\n", x) };
List.Iter (tmpfunc, intList)
</code>
        <p>
          Lambda expression is actually translated internally to
        </p>
        <rule name="expr">
          <terminal name="def"/>
          <special-terminal name="temporary_name"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
          where <tt>temporary_name</tt> is automatically created by the compiler.
        </p>
      </body>
    </subsection>
    <subsection id="list-expr">
      <title>List constructor</title>
      <body>
        <rule name="expr">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=","/>
            </repeat>
            <non-terminal name="expr"/>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          <tt>[1, 2, 3]</tt> is translated to <tt>list.Cons (1, list.Cons (2, list.Cons
          (3, list.Nil ())))</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="plusplus_op">
      <title>Increment operator</title>
      <body>
        <rule name="expr">
          <terminal name="++"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Prefix operator <tt>++</tt> is used to increment integer value of assignable
          expression.
          It is translated to something similar to <tt>e = e + 1</tt>, except that 
          <tt>e</tt> is evaluated only once, so <tt>++a[x.Next()]</tt> can be used safely.
          The entire expression has type <tt>void</tt> (the incremented value is not returned).
        </p>
      </body>
    </subsection>
    <subsection id="minusminus_op">
      <title>Decrement operator</title>
      <body>
        <rule name="expr">
          <terminal name="--"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Prefix operator <tt>--</tt> is used to decrement integer value of assignable
          expression.
          It is translated to something similar to <tt>e = e - 1</tt>, except that 
          <tt>e</tt> is evaluated only once, so <tt>--a[x.Next()]</tt> can be used safely.
          The entire expression has type <tt>void</tt> (the decremented value is not returned).
        </p>
      </body>
    </subsection>
    <subsection id="swap_op">
      <title>Swap operator</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <terminal name="&lt;->"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Infix operator <tt>&lt;-></tt> is used to swap values of two assignable
          expressions. You can think about it as being translated to 
        </p>
<code>
def temp = e2;
e2 = e1;
e1 = temp
</code>
        <p>
          except that subexpressions of <tt>e1</tt> and <tt>e2</tt> are evaluated only once 
          (there is a special macro to assure this), so <tt>a[x.Next()] &lt;-> a[x.Next()]</tt> 
          can be used safely.
        </p>
      </body>
    </subsection>
  </section>

  <section id="expression-helpers">
    <title>Expression helpers</title>
    <body>
      <p>
        This section describes some constructs used in Expressions
        section.
      </p>
    </body>
    <subsection id="sequence">
      <title>Sequence</title>
      <body>
        <rule name="sequence">
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=";"/>
            <non-terminal name="expr"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
        </rule>
        <p>
          Expressions in the sequence are evaluated sequentially, and the
          value (and thus the type) of the sequence is the value of the last
          expression in the sequence.
        </p>
        <p>
          Values of expression (except for the last one) are ignored,
          and thus if the type of some expression is not <tt>void</tt>
          -- a warning is generated.
        </p>
        <p>
          The <tt>;</tt> is optional after after <tt>}</tt> inside a sequence.
        </p>
      </body>
    </subsection>
    <subsection id="block">
      <title>Block</title>
      <body>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="sequence"/>
          <terminal name="}"/>
        </rule>
        <p>
          This is just a standard execution of a sequence of expressions. The value (and type) of
          this block is the same as the last expression in the sequence.
        </p>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          This syntax is a shortcut for matching parameters of a defined function
          with a given list of patterns. It is equivalent to making a tuple from
          parameters of function and creating <a ref="#match-expr">match expression</a>.
        </p>
<code>
def f (p1, p2, p3) { 
  | (1, 3, "a") => 1
  | _ => 2
}
</code>
        <p>
          translates to
        </p> 
<code>
def f (p1, p2, p3) { 
  match ((p1, p2, p3)) {
    | (1, 3, "a") => 1
    | _ => 2
  }
}
</code>
        <p>
          It is also to note that when a function has only one parameter, the matching goes just
          on this parameter itself (no one-element tuple is created).
        </p>
      </body>
    </subsection>
    <subsection id="try-catch-handler">
      <title>Try..catch handler</title>
      <body>
        <rule name="try_catch_handler">
          <non-terminal name="identifier_or_dummy"/>
          <terminal name="is"/>
          <non-terminal name="type"/>
          <terminal name="=&gt;"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="fun-parm">
      <title>Function parameter</title>
      <body>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <non-terminal name="expr"/>
        </rule>
        <rule name="parameter">
          <optional>
            <terminal name="out"/>
          </optional>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <rule name="parameter">
          <optional>
            <terminal name="out"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          <tt>ref</tt> and <tt>out</tt> are used to denote a parameter
          passed by reference.
        </p>
      </body>
    </subsection>
    <subsection id="match-case">
      <title>Match case</title>
      <body>
        <rule name="guarded_pattern">
          <non-terminal name="pattern"/>
          <optional>
            <terminal name="when"/>
            <non-terminal name="expr"/>
          </optional>
        </rule>
        <p>
          A guarded pattern requires expression <tt>expr</tt> to be of type
          <tt>bool</tt>. An expression <tt>e</tt> satisfies the guarded pattern
          only if it is pattern-matched with   <tt>pattern</tt> and expression 
          <tt>expr</tt> is evaluated to <tt>true</tt>.
        </p>
        <rule name="match_case">
          <non-terminal name="guarded_pattern"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="guarded_pattern"/>
          </repeat>
          <terminal name="=&gt;"/>
          <non-terminal name="sequence"/>
        </rule>
        <p>
          An expression <tt>e</tt> satisfies
          this match case if and only if it satisfies one of the guarded
          patterns in this match case.
        </p>
      </body>
    </subsection>
  </section>


  <section id="patterns">
    <title>Patterns</title>
    <body>
      <p>
        Patterns are a form of accessing data structures, especially trees.
        Patterns can <i>match</i> values. A definition of the term <i>to
        match</i> is given with each pattern construct. However, the
        main idea behind patterns is that they match values that look
        like them.
      </p>
      <p>
        Pattern are used in <a ref="#match-expr">match expression</a>
        and <a ref="#value-def">value definitions</a>.
      </p>
    </body>
    <subsection id="cons-pat">
      <title>Constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <non-terminal name="pattern"/>
          </optional>
        </rule>
        <p>
          The identifier should refer to the name of variant option. This
          pattern matches a value if it is a specified variant option,
          and sub-pattern matches variant option payload.
        </p>
      </body>
    </subsection>
    <subsection id="dummy-pat">
      <title>Throw-away pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="_"/>
        </rule>
        <p>
          This pattern matches any value.
        </p>
      </body>
    </subsection>
    <subsection id="record-pat">
      <title>Record pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="qualified_identifier"/>
          <terminal name="where"/>
          <terminal name="("/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="IDENTIFIER"/>
            <terminal name="="/>
            <non-terminal name="pattern"/>
          </repeat>
          <optional>
            <terminal name=","/>
          </optional>
          <terminal name=")"/>
        </rule>
        <p>
          This pattern matches a value of a class, that has all specified
          fields (this is checked statically), and a value of each field
          matches respective pattern.
        </p>
      </body>
    </subsection>
    <subsection id="as-pat">
      <title>As binding</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <terminal name=")"/>
          <terminal name="as"/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          This pattern matches the same value as an enclosed pattern
          does. However, in addition the value matched by the enclosed pattern
          is bound to a specified variable, which can be used in <tt>when</tt>
          guard or <tt>match</tt> body.
        </p>
      </body>
    </subsection>
    <subsection id="has-type-pat">
      <title>Type check pattern</title>
      <body>
        <rule name="pattern">
          <special-terminal name="IDENTIFIER"/>
          <terminal name="is"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          This pattern matches a value if it possesses a given type.
          In addition, the value matched is bound to a specified variable,
          which gets the given type.
        </p>
        <p>
          This pattern can be used both for checking the type and hinting
          the type checker (if the value is statically known to always have
          given type, compiler issues a warning and no runtime checks are performed).
        </p>
      </body>
    </subsection>
    <subsection id="tuple-pat">
      <title>Tuple pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="pattern"/>
          </repeat>
          <terminal name=")"/>
        </rule>
        <p>
          This pattern matches a tuple with specified contents (each
          tuple member is matched be respective pattern).
        </p>
        <p>
          In addition, when a tuple pattern is seen, where a record pattern
          would be otherwise expected -- the tuple pattern is transformed
          to record pattern by adding field identifiers in order they
          appear in the definition of the given class. A tuple pattern transformed
          to a record pattern cannot match fields inherited from the
          base class.
        </p>
      </body>
    </subsection>
    <subsection id="list-pat">
      <title>List constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="pattern"/>
          <terminal name="::"/>
          <non-terminal name="pattern"/>
        </rule>
        <p>
          The following two lines are equivalent:
        </p>
<code>
<meta>pattern1</meta> :: <meta>pattern2</meta>
list.Cons (<meta>pattern1</meta>, <meta>pattern2</meta>)
</code>
      </body>
    </subsection>
    <subsection id="list-lit-pat">
      <title>List literal pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="pattern"/>
              <terminal name=","/>
            </repeat>
            <non-terminal name="pattern"/>
            <optional>
              <terminal name=","/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          The following are equivalent:
        </p>
<code>
[ <meta>pattern1</meta> , <meta>pattern2</meta> , ... , <meta>patternN</meta> ]
list.Cons (<meta>pattern1</meta>, list.Cons (<meta>pattern2</meta>, ... list.Cons (<meta>pattern2</meta>, list.Nil) ... ))
</code>
      </body>
    </subsection>
    <subsection id="lit-pattern">
      <title>Literal pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="literal"/>
        </rule>
        <p>
          This pattern matches a specified constant value.
        </p>
      </body>
    </subsection>
    <subsection id="type-enf-pat">
      <title>Type enforcement in pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="pattern"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          This construct is used to statically enforce type of subpattern
          to given type. If a matched expression might not have such a type,
          compiler issues an error. It is used mainly for hinting type
          inference engine and improving code clarity.  
        </p>
      </body>
    </subsection>
  </section>


  <section id="macros">
    <title>Macros</title>
    <body>
      <p>
        Please refer to <link>macros.html</link> for now.
      </p>
    </body>
  </section>


    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
