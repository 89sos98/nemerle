/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;

using Nemerle.Compiler.CGexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

using System.Reflection;

using SR = System.Reflection;

namespace Nemerle.Compiler {

public module CGexpr
{
  internal cg_type (ctx : CTX, t : TType) : System.Type
  {
    cg_type (ctx.current_type.GetSystemType (), t)
  }

  internal tuple_type (len : int) : System.Type
  {
    InternalType.GetTupleType (len).SystemType
  }
  
  function_type (len : int) : System.Type
  {
    InternalType.GetFunctionType (len).SystemType
  }

  get_apply_method (parm_cnt : int) : IMethod
  {
    InternalType.GetFunctionType (parm_cnt).ApplyMethod
  }

  internal tuple_ref (val : CExpr, pos : int, len : int) : CExpr
  {
    def fld = InternalType.GetTupleType (len).GetField (pos);
    CExpr.FieldRef (val, fld.GetFieldInfo ())
  }

  tuple_ctor (vals : list [CExpr]) : CExpr
  {
    def len = List.Length (vals);
    def ctor = InternalType.GetTupleType (len).Ctor.GetConstructorInfo ();
    CExpr.Call (CExpr.ConstructorRef (ctor), vals)
  }

  make_ref_type (t : System.Type) : System.Type
  {
    def ty = t.Module.GetType (t.FullName + "&");
    assert (ty != null);
    ty
  }
  
  public cg_type (tybuilder : System.Type, t : TType) : System.Type
  {
    match (Tyutil.top_expand (t)) {
      | TType.Void => SystemType.Void
      | TType.Product (l) =>
        tuple_type (List.Length (l))
      | TType.Function (args, _) => 
        function_type (List.Length (Tyutil.fun_args (args)))
      | TType.Variable (tv) =>
        match (Tyvar.constraints (tv)) {
          | [] => SystemType.Object
          | t :: _ => cg_type (tybuilder, t)
        }

      | TType.Class (ti, _) => 
        def ret = ti.GetSystemType ();
        assert (ret != null);
        ret
        
      | TType.ByRef (et) | TType.Out (et) =>
        make_ref_type (cg_type (tybuilder, et))
        
      | TType.Array (et, rank) =>
        def et = cg_type (tybuilder, et);
        def rankstr = "[" + System.String (',', rank - 1) + "]";
        def ty = tybuilder.Module.GetType (et.FullName + rankstr);
        if (ty == null) {
          def arr = System.Array.CreateInstance (et, (array (rank) : array [int]));
          when (arr == null)
            Util.ice ("unbound array type " + et.FullName + rankstr);
          arr.GetType ()
        } else {
          ty
        }
    }
  }

  [Record]
  public class CTX
  {
    public mutable current_fun : Fun_header;
    public mutable current_fun_or_loop : Fun_header;
    public mutable current_closure : option [CG_val];
    public mutable closure_fields : SystemMap [int, FieldInfo];
    public mutable closure_ptrs : SystemMap [int, FieldInfo];
    public mutable locals : SystemMap [int, CG_val];
    public mutable current_type : TypeBuilder;
    public mutable current_loop : option [CExpr.Loop];
  }

  copy_ctx (c : CTX) : CTX 
  {
    CTX (current_fun = c.current_fun,
         current_closure = c.current_closure,
         closure_fields = c.closure_fields,
         closure_ptrs = c.closure_ptrs,
         locals = c.locals,
         current_type = c.current_type,
         current_loop = c.current_loop,
         current_fun_or_loop = c.current_fun_or_loop)
  }

  empty_ctx (ti : TypeBuilder) : CTX
  {
    CTX (current_fun = null,
         current_fun_or_loop = null,
         current_closure = None (),
         closure_fields = SystemMap (),
         closure_ptrs = SystemMap (),
         locals = SystemMap (),
         current_type = ti,
         current_loop = None ())
  }

  store_in_closure (ctx : CTX, d : LocalValue, val : CExpr) : CExpr
  {
    match (ctx.current_closure) {
      | Some (clo) =>
        def rf = CExpr.FieldRef (CExpr.Ref (clo), ctx.closure_fields.Get (d.id));
        CExpr.Assign (rf, val)
      | None =>
        Message.warning ("no local closure for " + d.name);
        Util.ice ()
    }
  }

  internal store_local (ctx : CTX, d : LocalValue, val : CExpr) : CTX * CG_val
  {
    def var_ty = cg_type (ctx, d.ty);
    def val =
      match (val) {
        | CExpr.Nop => val
        | _ when type_of (val).IsValueType && !var_ty.IsValueType => 
          CExpr.Cast (val, var_ty, true)
        | _ => val
      };
      if (d.in_closure) {
        def assign = store_in_closure (ctx, d, val);
        def cgv = CG_val (loc = d.loc, 
                          name = Util.tmpname ("dummy"),
                          ty = SystemType.Void, 
                          val = assign);
        (copy_ctx (ctx), cgv)
      } else {
        def cgv = CG_val (loc = d.loc, 
                          name = decl_uniq_name(d), 
                          ty = var_ty,
                          val = val);
        def ctx' = copy_ctx (ctx);
        ctx'.locals = ctx.locals.Add (d.id, cgv);
        (ctx', cgv)
      }
  }

  closure_ref (ctx : CTX, fn : Fun_header) : CExpr
  {
    if (ctx.current_fun.id == fn.id)
      CExpr.Ref (Option.UnSome (ctx.current_closure))
    else
      CExpr.FieldRef (CExpr.This (), ctx.closure_ptrs.Get (fn.id))
  }

  public type_of (ex : CExpr) : System.Type
  {
    if (ex.ty != null) ex.ty
    else {
      def ty =
        match (ex) {
          | CExpr.Ref (d) => d.ty
          | CExpr.GlobalRef (obj)
          | CExpr.VolatileGlobalRef (obj) =>
            if (obj.MemberType %&& MemberTypes.Field)
              (obj :> FieldInfo).FieldType
            else if (obj.MemberType %&& MemberTypes.Property)
              (obj :> PropertyInfo).PropertyType
            else
              Util.ice ("strange global ref")
              
          | CExpr.FieldRef (_, f)
          | CExpr.VolatileFieldRef (_, f) => f.FieldType

          | CExpr.MethodAddress => SystemType.IntPtr
          
          | CExpr.TailCall (CExpr.GlobalRef (m), _)
          | CExpr.Call (CExpr.GlobalRef (m), _) => (m :> MethodInfo).ReturnType
          
          | CExpr.TailCall (CExpr.MethodRef (_, m, _), _)
          | CExpr.Call (CExpr.MethodRef (_, m, _), _) => m.ReturnType
          
          | CExpr.TailCall (CExpr.ConstructorRef (c), _)
          | CExpr.Call (CExpr.ConstructorRef (c), _) => c.DeclaringType
          
          | CExpr.TailCall (CExpr.BaseCtorRef, _)
          | CExpr.Call (CExpr.BaseCtorRef, _) => SystemType.Void

          | CExpr.TypeOf => SystemType.Type

          | CExpr.Address (expr) => make_ref_type (type_of (expr))

          | CExpr.Indirect (expr) =>
            def ty = type_of (expr);
            def ety = ty.GetElementType ();
            assert (ty.IsByRef && ety != null);
            ety

          | CExpr.Loop (expr, _) => type_of (expr)
          
          | CExpr.SelfTailCall
          | CExpr.TailCall
          | CExpr.Call => Util.ice ("strange call")
          
          | CExpr.MultipleAssign
          | CExpr.Assign => SystemType.Void
          | CExpr.Define (_, b) => type_of (b)
          | CExpr.HasType => SystemType.Boolean
          | CExpr.NotNull => SystemType.Void
          | CExpr.ContinueLoop
          | CExpr.Throw => SystemType.Void
          | CExpr.If (_, _, _) => Util.ice ("ought to be cached")
          | CExpr.TryWith (e, _, _) => type_of (e)
          | CExpr.TryFinally (e, _) => type_of (e)
          | CExpr.Literal (l) => 
            match (l) {
              | Literal.Void => SystemType.Void
              | Literal.Null => SystemType.Object
              | Literal.Byte => SystemType.Byte
              | Literal.SByte => SystemType.SByte
              | Literal.Short => SystemType.Int16
              | Literal.UShort => SystemType.UInt16                
              | Literal.Int => SystemType.Int32
              | Literal.UInt => SystemType.UInt32                
              | Literal.Long => SystemType.Int64
              | Literal.ULong => SystemType.UInt64                
              | Literal.Char => SystemType.Char
              | Literal.String => SystemType.String
              | Literal.Float => SystemType.Single
              | Literal.Double => SystemType.Double
              | Literal.Decimal => SystemType.Decimal                
              | Literal.Bool => SystemType.Boolean
              | Literal.Enum (l, _) => type_of (CExpr.Literal (l))
            }
          | CExpr.This => SystemType.Object // cheat a bit 
          | CExpr.Cast (_, t, _) => t
          | CExpr.Sequence (b) => type_of (List.Last (b))
          | CExpr.Switch (_, default_expr, switch_cases) =>
            match (default_expr) {
              | Some (expr) => type_of (expr)
              | _ =>
                def (_, expr) = List.Last (switch_cases);
                type_of (expr)
            }
          | CExpr.InitValueType (t) => t

          | CExpr.Array 
          | CExpr.ArrayAccess (_, _) => Util.ice ("should be cached")
          | CExpr.Opcode => Util.ice ("opcode")
          | CExpr.Ignore => SystemType.Void

          // can't tell
          | CExpr.Nop => Util.ice ("none")

          // these are supported only as part of call
          | CExpr.ConstructorRef => Util.ice ("ctorref")
          | CExpr.MethodRef => Util.ice ("methodref")
          | CExpr.BaseCtorRef => Util.ice ("basectorref")
        };
      ex.ty = ty;
      ty
    }
  }

  box_value (body : CExpr) : CExpr 
  {
    if (type_of (body).IsValueType || SystemType.Void.Equals (type_of (body)))
      CExpr.Cast (body, SystemType.Object, true)
    else
      body
  }

  unbox_value (body : CExpr, ty : System.Type) : CExpr 
  {
    if (SystemType.Void.Equals (ty))
      CExpr.Ignore (body)
    else
      CExpr.Cast (body, ty, true)
  }


  /**
   * Matching -- wrapper for the CGmatch module functionality.
   */
  cg_match (t : System.Type, ctx : CTX, val : CExpr, mcs : list [Match_case]) : CExpr
  {
    CGmatch.cg_match (t, ctx, val, mcs)
  }


  set_parm_info (fp : Fun_parm, v : CG_val) : CG_val
  {
    def kind =
      match (fp.ty) {
        | TType.ByRef => ParmKind.Ref
        | TType.Out => ParmKind.Out
        | _ => ParmKind.Normal
      };
    v.parm_info = CG_parm_info (parm_kind = kind, 
                                modifiers = fp.modifiers);
    v
  }
    

  set_parm_info (ty : TType, v : CG_val) : CG_val
  {
    def kind =
      match (ty) {
        | TType.ByRef => ParmKind.Ref
        | TType.Out => ParmKind.Out
        | _ => ParmKind.Normal
      };
    v.parm_info = CG_parm_info (parm_kind = kind, 
                                modifiers = Modifiers.Empty);
    v
  }
    

  // always return a new copy
  build_cg_method (tybuilder : System.Type, header : Fun_header) : CG_method
  {
    def mkparm (p : Fun_parm) : CG_val {
      match (p.ty) {
        | TType.Void =>
          // FIXME: do something about it
          Message.fatal_error (header.loc, "method `" + header.name + "' has void argument")
        | _ => ()
      };
      set_parm_info (p, 
        CG_val (loc = header.loc,
                name = p.name, 
                ty = cg_type (tybuilder, p.ty),
                val = CExpr.Nop ()))
    };
    def m = CG_method ();
    m.name = header.name;
    m.ret_type = cg_type (tybuilder, header.ret_type);
    m.parms = List.Map (header.parms, mkparm);
    m.implemented_methods = [];
    m
  }
  
  build_cg_method (ctx : CTX, header : Fun_header) : CG_method
  {
    build_cg_method (ctx.current_type.GetSystemType (), header)
  }

  fixup_cg_method (meth : IMethod) : void
  {
    def cgm = GetCgMethod (meth);
    cgm.modifiers = meth.Attributes;
  }

  public GetCgMethod (meth : IMethod) : CG_method
  {
    def header = meth.GetHeader ();
    when (header.cg_method == null) {
      def tb = meth.DeclaringType.GetSystemType ();
      header.cg_method = build_cg_method (tb, header);
      fixup_cg_method (meth);
    };
    header.cg_method
  }
  
  build_cg_method (ctx : CTX, meth : IMethod) : CG_method
  {
    build_cg_method (ctx, meth.GetHeader ())
  }

  // return cached copy for given method
  get_cg_method (ctx : CTX, header : Fun_header) : CG_method
  {
    when (header.cg_method == null) {
      header.cg_method = build_cg_method (ctx, header);
    };
    header.cg_method;
  }
  
  make_untupled_parms (tuple_expr : CExpr, parm_cnt : int) : list [CExpr]
  {
    if (parm_cnt == 0)
      []
    else {
      def tup = CExpr.Cast (tuple_expr, tuple_type (parm_cnt), true);
      def mkparm (acc, i) {
        if (i == 0) acc
        else mkparm (tuple_ref (tup, i, parm_cnt) :: acc, i - 1)
      };
      mkparm ([], parm_cnt)
    }
  }

  make_tupled_method (ctx : CTX, parm_cnt : int) : CG_method
  {
    def cgm = build_cg_method (ctx, get_apply_method (1));
    def parms = make_untupled_parms (CExpr.Ref (List.Head (cgm.parms)), parm_cnt);
    def meth = get_apply_method (parm_cnt);
    def multi_apply = CExpr.MethodRef (CExpr.This (), meth.GetMethodInfo (), false);
    cgm.body = CExpr.Call (multi_apply, parms);
    cgm.implemented_methods = [get_apply_method (1)];
    cgm.modifiers = NemerleAttributes.Internal;
    cgm
  }

  make_untupled_method (ctx : CTX, parm_cnt : int) : CG_method
  {
    def cgm = build_cg_method (ctx, get_apply_method (parm_cnt));
    
    def mkparm (v) { CExpr.Ref (v) };
    def parm = 
      match (cgm.parms) {
        | [] => CExpr.Literal (Literal.Null ())
        | _ => maybe_cast (ctx, SystemType.Object, tuple_ctor (List.Map (cgm.parms, mkparm)))
      };

    def meth = get_apply_method (1);
    def single_apply = CExpr.MethodRef (CExpr.This (), meth.GetMethodInfo (), false);
    
    cgm.body = CExpr.Call (single_apply, [parm]);
    cgm.implemented_methods = [get_apply_method (parm_cnt)];
    cgm.modifiers =  NemerleAttributes.Internal;
    cgm
  }

  get_lambda_proxy (ctx : CTX, meth : IMethod) : ConstructorInfo
  {
    def cg_method = GetCgMethod (meth);
    when (cg_method.lambda_ctor == null) {
      // FIXME: we should generate proxies in module *or* in the class depending
      // on permissions
      //def mod = (ctx.current_type.GetSystemType ().Module :> ModuleBuilder);
      def parm_cnt = List.Length (cg_method.parms);
      def impl =
        if (parm_cnt == 1)
          array [function_type (1)]
        else
          array [function_type (parm_cnt), function_type (1)];

      def tb = ctx.current_type.GetTypeBuilder ().
                DefineNestedType (fun_uniq_name (meth.GetHeader ()), 
                                  TypeAttributes.SpecialName %| TypeAttributes.NestedAssembly,
                                  SystemType.Object, impl);
      Passes.ILGenerator.RegisterAuxType (tb);
      cg_method.lambda_ctor = Passes.ILGenerator.AddImplicitCtor (tb);
      
      // get separate copy
      def cgm = build_cg_method (ctx, meth);
      cgm.name = "apply";
      cgm.implemented_methods = [get_apply_method (parm_cnt)];
      cgm.modifiers =  NemerleAttributes.Internal;
      
      def mkparm (v : CG_val) {
        def t = v.ty;
        v.ty = SystemType.Object;
        CExpr.Cast (CExpr.Ref (v), t, true)
      };
      cgm.ret_type = SystemType.Object;
      def fn =
        match (meth.GetFunKind ()) {
          | FunKind.Constructor => CExpr.ConstructorRef (meth.GetConstructorInfo ())
          | _ => CExpr.GlobalRef (meth.GetMethodInfo ())
        };
      cgm.body = box_value (CExpr.Call (fn, List.Map (cgm.parms, mkparm)));

      Passes.ILGenerator.AddMethod (ctx.current_type, cgm, tb);
      when (parm_cnt != 1)
        Passes.ILGenerator.AddMethod (ctx.current_type, make_tupled_method (ctx, parm_cnt), tb);
    };
    
    cg_method.lambda_ctor
  }

  global_ref (ctx : CTX, m : IMember) : CExpr {
    match (m.GetKind ()) {
      | MemberKind.Type => assert (false)
      | MemberKind.Event => assert (false)

      | MemberKind.Field (f) =>
        if (f.IsLiteral) {
          match (ConstantFolder.FieldValueAsLiteral (f)) {
            | Some (lit) =>
              // this is kinda last resort, we should have converted it during
              // constant folding, but if we have missed it, do it here, as cgil
              // will fail to generate proper code for this.
              //Message.debug ("converting literal field `" + f.Name + "' to literal");
              CExpr.Literal (lit)
            | None =>
              if (f.IsVolatile)
                CExpr.VolatileGlobalRef (f.GetFieldInfo ())
              else
                CExpr.GlobalRef (f.GetFieldInfo ())
          }
        } else
          if (f.IsVolatile)
            CExpr.VolatileGlobalRef (f.GetFieldInfo ())
          else
            CExpr.GlobalRef (f.GetFieldInfo ())

      | MemberKind.Property (f) =>
        CExpr.GlobalRef (f.GetPropertyInfo ())
        
      | MemberKind.Method (f) =>
        CExpr.Call (CExpr.ConstructorRef (get_lambda_proxy (ctx, f)), [])
    }
  }

  internal local_ref (ctx : CTX, d : LocalValue, store : bool) : CExpr
  {
    if (d.in_closure) {
      if (!store && ctx.current_fun.decl == null && (d.kind is LocalValueKind.ClosurisedThis))
          CExpr.This ()
      else {
        def defined_in = d.parent_fun;
        CExpr.FieldRef (closure_ref (ctx, defined_in), 
                        ctx.closure_fields.Get (d.id))
      }
    }
    else if (ctx.locals.Member (d.id)) {
      match (d.kind) {
        | LocalValueKind.Parameter (kind) 
          when kind == ParmKind.Out || kind == ParmKind.Ref =>
          def ty = make_ref_type (cg_type (ctx, d.ty));
          CExpr.Indirect (CExpr.Ref (ty, ctx.locals.Get (d.id)))
          
        | _ =>
          CExpr.Ref (ctx.locals.Get (d.id))
      }
    } else {
      match (d.kind) {
        | LocalValueKind.ClosurisedThis => CExpr.This ()
        | _ =>
          Message.debug ("undef " + d.name + " = " + d.id.ToString () + " " + d.kind.ToString ());
          Util.ice ("ref to undef val " + d.name)
      }
    }
  }

  internal maybe_cast (_ctx : CTX, needed_type : System.Type, ex : CExpr) : CExpr
  {
    assert (needed_type != null);
    def current_type = type_of (ex);
    assert (current_type != null);
    if (needed_type.Equals (SystemType.Void))
      if (current_type.Equals (SystemType.Void))
        ex
      else
        CExpr.Ignore (ex)
    else {
/*    
// bug in MS.NET makes it return false for IField[] and IField[]         
      when (needed_type.Equals (current_type) !=
            (needed_type.FullName == current_type.FullName))
        Message.debug (ex.loc, needed_type.Assembly.ToString () + " " + needed_type.ToString () + " " + 
                               current_type.Assembly.ToString () + " " + current_type.ToString ());
*/                               
      if (needed_type.FullName == current_type.FullName ||    
          (needed_type.IsAssignableFrom (current_type) && !current_type.IsValueType))
      ex
      else 
       CExpr.Cast (ex, needed_type, true)
    }
  }

  get_fn_header (fn : LocalValue) : Fun_header
  {
    match (fn.kind) {
      | LocalValueKind.Function (h, _) => h
      | _ => Util.ice ()
    }
  }

  /**
   * Properly format list of expression before being passed in a function
   * call -- box value types, and add needed downcasts.
   */
  casted_exprs (ctx : CTX, formals : list [CG_val], parms : list [CExpr]) : list [CExpr]
  {
    //Message.debug ("formals : " + formals.ToString () + " params : " + parms.ToString ());
    def parms = adjust_tupled_parms (ctx, List.Length (formals), parms);
    List.Map2 (formals, parms, 
      fun (v : CG_val, e) { 
        maybe_cast (ctx, v.ty, e) 
      })
  }

  casted_parms (ctx : CTX, formals : list [Fun_parm], parms : list [Parm]) : list [CExpr]
  {
    def parms = List.Map (parms, fun (p : Parm) { cg_expr (ctx, p.expr) });
    def parms = adjust_tupled_parms (ctx, List.Length (formals), parms);
    List.Map2 (formals, parms, 
      fun (v : Fun_parm, e) { 
        maybe_cast (ctx, cg_type (ctx, v.ty), e) 
      })
  }

  /**
   * Split tuple to parameters or vice versa.
   */
  adjust_tupled_parms (ctx : CTX, formals_cnt : int, parms : list [CExpr]) : list [CExpr]
  {
    match ((formals_cnt, parms)) {
      | (x, [parm]) when x > 1 =>
        make_untupled_parms (parm, formals_cnt)
      | (1, _ :: _ :: _) =>
        def parms = List.Map (parms, 
          fun (e) { 
            maybe_cast (ctx, SystemType.Object, e) 
          });
        [tuple_ctor (parms)]
      | _ => parms
    }
  }

  /**
   * Construct proxy object for delegate invocation. Used when anything except
   * instance or static method is used for delegate construction (local 
   * function, functional value returned from somewhere etc).
   */
  // FIXME: it probably won't work with local delegates because of the delegate
  //        .ctor type hack in external.n
  emit_delegate_proxy (ctx : CTX, ctor : IMethod) : ConstructorInfo * CG_method
  {
    def fh = ctor.GetHeader ();
    match (fh.parms) {
      | [{ty = (TType.Function (parms, ret_type)) as fun_type}] =>
        def loc = fh.loc; // FIXME
        def parms = Tyutil.fun_args (parms);
        def tb = ctx.current_type.GetTypeBuilder ().
                  DefineNestedType (Util.tmpname ("delegate_proxy"),
                                    TypeAttributes.SpecialName %| TypeAttributes.NestedAssembly, 
                                    SystemType.Object, array []);    
        Passes.ILGenerator.RegisterAuxType (tb);

        def fptr = tb.DefineField ("funptr", cg_type (ctx, fun_type), 
                                   FieldAttributes.SpecialName %| FieldAttributes.Assembly);
        def mkparm (ty) { 
          set_parm_info (ty,
                         CG_val (loc = loc,
                                 name = Util.tmpname ("dp"),
                                 ty = cg_type (ctx, ty),
                                 val = CExpr.Nop ()))
        };
        
        def m = CG_method ();
        m.name = "InvokeDelegate";
        m.ret_type = cg_type (ctx, ret_type);
        m.parms = List.Map (parms, mkparm);
        m.modifiers = NemerleAttributes.Internal;
        m.implemented_methods = [];

        def apply = get_apply_method (List.Length (parms)).GetMethodInfo ();
        def meth = CExpr.MethodRef (CExpr.FieldRef (CExpr.This (), fptr), apply, false);
        def mkparmref (v) { CExpr.Cast (CExpr.Ref (v), SystemType.Object, true) };
        def parms' = List.Map (m.parms, mkparmref);
        m.body = unbox_value (CExpr.Call (meth, parms'), m.ret_type);
      
        Passes.ILGenerator.AddMethod (ctx.current_type, m, tb);

        def invoke_cgm = m;

        def m = CG_method ();
        m.name = ".ctor";
        m.ret_type = SystemType.Void;
        def ctor_parm =
          set_parm_info (TType.Void (),
            CG_val (loc = loc,
                    name = Util.tmpname ("dp"),
                    ty = fptr.FieldType,
                    val = CExpr.Nop ()));
        m.parms = [ctor_parm];
        m.modifiers = NemerleAttributes.Internal;
        m.implemented_methods = [];
        def assign = CExpr.Assign (CExpr.FieldRef (CExpr.This (), fptr), CExpr.Ref (ctor_parm));
        m.body = CExpr.Sequence ([call_object_ctor (), assign]);
        
        Passes.ILGenerator.AddConstructorBuilder (m, tb, false);
        Passes.ILGenerator.EmitConstructor (ctx.current_type, m);

        ((m.constructor_builder : ConstructorInfo), invoke_cgm)
        
      | _ => assert (false)
    }
  }

  emit_delegate_ctor (ctx : CTX, m : IMethod, ps : list [Parm]) : CExpr
  {
    def the_problem () {
      Message.fatal_error ("delegate construction not supported for this expression")
    };
    def (this_ptr, cgm) = 
      match (ps) {
        | [{expr = TExpr.StaticRef (mem)}] =>
          match (mem.GetKind ()) { 
            | MemberKind.Method (meth) =>
              (CExpr.Literal (Literal.Null ()), GetCgMethod (meth))
            | _ => 
              the_problem ()
          }
          
        | [{expr = TExpr.MethodRef (obj, mem, _notvirt)}] =>   // FIXME: use non virt?
          (CExpr.Cast (cg_expr (ctx, obj), SystemType.Object, true), GetCgMethod (mem))
          
        | [parm] =>
          def (ctor, invoke_cgm) = emit_delegate_proxy (ctx, m);
          (CExpr.Call (CExpr.ConstructorRef (ctor), [cg_expr (ctx, parm.expr)]), invoke_cgm)
          
        | _ => the_problem ()
      };
    assert (cgm.method_builder != null);
    
    CExpr.Call (CExpr.ConstructorRef (m.GetConstructorInfo ()), 
             [this_ptr, CExpr.MethodAddress (cgm.method_builder)])
  }

  emit_loop (ctx : CTX, h : Fun_header, parms : list [Parm]) : CExpr
  {
    def ctx' = copy_ctx (ctx);
    def parms = casted_parms (ctx, h.parms, parms);
    def parm_vals = List.Map2 (h.parms, parms, fun (fp : Fun_parm, ap) {
      def val = CG_val (loc = fp.decl.loc, 
                        name = fp.name,
                        ty = cg_type (ctx, fp.ty),
                        val = ap);
      ignore (set_parm_info (fp, val));
      ctx'.locals = ctx'.locals.Add (fp.decl.id, val);
      val
    });
    ctx'.current_fun_or_loop = h;
    def loop = (CExpr.Loop (null, None ()) :> CExpr.Loop);
    ctx'.current_loop = Some (loop);
    loop.body = cg_expr (ctx', h.body);
    h.body = null;
    List.FoldLeft (List.Rev (parm_vals), (loop : CExpr), 
                   fun (v, expr) { CExpr.Define (v, expr) })
  }

  with_cached (expr : CExpr, f : CExpr -> CExpr) : CExpr
  {
    match (expr) {
      | CExpr.Ref
      | CExpr.GlobalRef
      | CExpr.VolatileGlobalRef
      | CExpr.ConstructorRef
      | CExpr.MethodAddress
      | CExpr.Opcode
      | CExpr.Literal
      | CExpr.This
      | CExpr.TypeOf 
      | CExpr.Indirect (CExpr.Ref) =>
        f (expr)

      | _ =>
        def v = CG_val (loc = Location_stack.top (),
                        name = Util.tmpname ("cached"),
                        ty = type_of (expr),
                        val = expr);
        CExpr.Define (v, f (CExpr.Ref (v)))
    }
  }

  cg_call (ctx : CTX, is_tail : bool, ret_type : TType, 
           f : TExpr, ps : list [Parm]) : CExpr
  {
    def compile_parm (p : Parm) {
      def ex = cg_expr (ctx, p.expr);
      if (p.kind == ParmKind.Out || p.kind == ParmKind.Ref)
        CExpr.Address (ex)
      else
        ex
    };

    def emit_call (cgm : CG_method, callable) {
      def parms = List.Map (ps, compile_parm);
      def callable =
        match (callable) {
          | CExpr.MethodRef (e, meth, notvirt) when type_of (e).IsValueType && 
                                         !meth.DeclaringType.IsValueType =>
            CExpr.MethodRef (CExpr.Cast (e, meth.DeclaringType, true), meth, notvirt)
          | x => x
        };
      if (cgm == null) {
        def t = cg_type (ctx, ret_type);
        if (is_tail)
          CExpr.TailCall (t, callable, parms)
        else
          CExpr.Call (t, callable, parms)
      } else {
        //Message.debug ("real casted params for " + cgm.name);
        def generate_call (parms) {
          if (is_tail)
            CExpr.TailCall (callable, casted_exprs (ctx, cgm.parms, parms))
          else
            CExpr.Call (callable, casted_exprs (ctx, cgm.parms, parms))
        };
        
        def call =
          match ((parms, cgm.parms)) {
            | ([parm], _ :: _ :: _) =>
              // need to cache it, so casted_parms can untuple it
              with_cached (parm, fun (parm) { generate_call ([parm]) })
            | _ =>
              generate_call (parms)
          };
        maybe_cast (ctx, cg_type (ctx, ret_type), call)
      }
    };
    def plain_call () {
      def len = List.Length (ps);
      def imeth = get_apply_method (len);
      emit_call (GetCgMethod (imeth), CExpr.MethodRef (cg_expr (ctx, f), 
                                                     imeth.GetMethodInfo (), false))
    };
    
    match (f) {
      | TExpr.StaticRef (m) =>
        match (m.GetKind ()) {
          | MemberKind.Method (m) =>
            match (m.GetFunKind ()) {
              | _ when Option.IsSome (m.GetExternName ()) =>
                def opname = Option.UnSome (m.GetExternName ());
                assert (opname.StartsWith ("%op"));
                emit_call (null, CExpr.Opcode (opname.Substring (3)))
              | FunKind.Constructor =>
                if (m.DeclaringType.IsDelegate)
                  Util.locate (f.loc, emit_delegate_ctor (ctx, m, ps))
                else
                  emit_call (GetCgMethod (m), CExpr.ConstructorRef (m.GetConstructorInfo ()))
                  
              | _ =>
                emit_call (GetCgMethod (m), CExpr.GlobalRef (m.GetMethodInfo ()))
            }
          | _ => plain_call ()
        }
      | TExpr.OpCode (name) =>
        emit_call (null, CExpr.Opcode (name))
      
      // check for this invisibly coerced to other type -- encoding for base
      // and force nonvirt then
      | TExpr.MethodRef ((TExpr.LocalRef { 
                         decl = { kind = LocalValueKind.ClosurisedThis; 
                                  ty = TType.Class (ti, _) };
                         ty = TType.Class (ti', _) }) as o, m, false) 
                    when ! ti.Equals (ti') =>
        emit_call (GetCgMethod (m), CExpr.MethodRef (cg_expr (ctx, o), m.GetMethodInfo (), true))
        
      | TExpr.MethodRef (o, m, notvirt) =>   
        emit_call (GetCgMethod (m), CExpr.MethodRef (cg_expr (ctx, o), m.GetMethodInfo (), notvirt))
      | TExpr.Base (m) =>
        emit_call (GetCgMethod (m), CExpr.BaseCtorRef (m.GetConstructorInfo ()))
      | TExpr.LocalRef (d) =>
        match (d.kind) {
          | LocalValueKind.Function (({usage = FunctionUsage.UsedJustOnce}) as h, _) =>
            emit_loop (ctx, h, ps)
          | LocalValueKind.Function (h, _) when h.id == ctx.current_fun.id =>
            assert (h.cg_method.method_builder != null);
            emit_call (get_cg_method (ctx, h),
                       CExpr.MethodRef (CExpr.This (), h.cg_method.method_builder, false))
          | _ => plain_call ()
        }
      | _ => plain_call ()
    }
  }

  raw_cg_expr (ctx : CTX, inex : TExpr) : CExpr
  {
    //Message.debug ("emit");
    def self (e : TExpr) : CExpr { cg_expr (ctx, e) };
    match (inex) {
      | TExpr.LocalRef (d) => 
        local_ref (ctx, d, false)

      | TExpr.StaticRef (d) => 
        global_ref (ctx, d)

      | TExpr.FieldMember (o, f) =>
        def field_ref =
          if (f.IsVolatile)
            CExpr.VolatileFieldRef (self (o), f.GetFieldInfo ())
          else
            CExpr.FieldRef (self (o), f.GetFieldInfo ());
            
        maybe_cast (ctx, cg_type (ctx, inex.ty), field_ref)

      | TExpr.ImplicitValueTypeCtor (t) =>
        CExpr.InitValueType (t.GetSystemType ())

      | TExpr.MethodRef => Util.ice ("MethodRef")
      | TExpr.PropertyMember => Util.ice ("PropertyMember " + PrettyPrint.SprintTyExpr (None (), inex))
      | TExpr.StaticPropertyRef => Util.ice ("StaticPropertyRef")
      | TExpr.ConstantObjectRef (mem) =>
        Message.warning ("using a constant object reference directly");
        Message.warning ("  you probably have meant to write `" +
                         mem.DeclaringType.FullName + " ()'");
        def mems =
          mem.DeclaringType.LookupMember ("_N_constant_object_generator");
        match (mems) {
          | [mem] => global_ref (ctx, mem)
          | _ =>
            Message.error ("  no constant object generator method found");
            CExpr.Nop ()
        }
      
      | TExpr.TypeOf (t) =>
        CExpr.TypeOf (cg_type (ctx, t))

      | TExpr.SelfTailCall (parms) =>
        def fn = ctx.current_fun_or_loop;
        match (fn.usage) {
          | FunctionUsage.UsedJustOnce =>
            def parms = casted_parms (ctx, fn.parms, parms);
            def assigns = 
              List.Map2 (parms, fn.parms, fun (expr, fp : Fun_parm) {
                (ctx.locals.Get (fp.decl.id), expr)
              });
            CExpr.Sequence ([CExpr.MultipleAssign (assigns), 
                          CExpr.ContinueLoop (Option.UnSome (ctx.current_loop))])
          | _ =>
            def parms = List.Map (parms, fun (p : Parm) { self (p.expr) });
            // Message.debug ("self casted params for " + fn.cg_method.name);
            def parms = casted_exprs (ctx, fn.cg_method.parms, parms);
            def t = cg_type (ctx, inex.ty);
            CExpr.SelfTailCall (t, parms)
        }

      | TExpr.Call (f, ps) =>
        cg_call (ctx, false, inex.ty, f, ps)
       
      | TExpr.TailCall (f, ps) =>
        cg_call (ctx, true, inex.ty, f, ps)

      | TExpr.Assign (e1, e2) =>
        def e1 = self (e1);
        def e2 = self (e2);
        def e2 =
          if (type_of (e2).IsValueType && !type_of (e1).IsValueType)
            CExpr.Cast (e2, type_of (e1), true)
          else
            e2;
        CExpr.Assign (e1, e2)
        
      | TExpr.Array (initializers, dimensions) =>
        def element_type =
          match (inex.ty) {
            | TType.Array (t, _) => cg_type (ctx, t)
            | _ => assert (false)
          };
        def elt_is_value = element_type.IsValueType;
        def make_initializer (e) {
          def e = self (e);
          if (!elt_is_value && type_of (e).IsValueType)
            CExpr.Cast (e, element_type, true)
          else
            e
        };
        CExpr.Array (ty = cg_type (ctx, inex.ty), 
                    element_type = element_type, 
                    initializers = List.Map (initializers, make_initializer),
                    dimensions = List.Map (dimensions, fun (x) { self (x) }))

      | TExpr.ArrayIndexer (ty, obj, args) =>
        match (Tyutil.top_expand (obj.ty)) {
          | TType.Array => CExpr.ArrayAccess (cg_type (ctx, ty), self (obj), List.Map (args, self))
          | _ => Util.ice ("ArrayIndexer")
        }

      | TExpr.DefValIn (d, v, b) =>
        if (d.ever_used) {
          def (ctx', cgv) = store_local (ctx, d, self (v));
          CExpr.Define (cgv, cg_expr (ctx', b))
        }
        else
          CExpr.Sequence ([CExpr.Ignore (self (v)), cg_expr (ctx, b)])

      | TExpr.DefFunctionsIn (fs, body) =>
        mutable vals = [];
        def store (f : Function_decl, ctx : CTX) : CTX {
          def fh = get_fn_header (f.header.decl);
          match (fh.usage) {
            | FunctionUsage.UsedJustOnce =>
              ctx
            | _ =>
              def ct = make_lambda_ctor_call (ctx, fh);
              def (ctx, val) = store_local (ctx, f.header.decl, ct);
              vals = val :: vals;
              ctx
          }
        };
        def emit (f : Function_decl) {
          def fh = get_fn_header (f.header.decl);
          match (fh.usage) {
            | FunctionUsage.UsedJustOnce => 
              // used later in emit_loop
              fh.body = f.body
            | _ => emit_lambda_code (ctx, fh, f.body)
          }
        };
        def mklet (val, acc) { CExpr.Define (val, acc) };

        def ctx = List.FoldLeft (fs, ctx, store);
        List.Iter (fs, emit);
        List.FoldLeft (vals, cg_expr (ctx, body), mklet)

      | TExpr.Match (e, mcs) =>
        with_cached (cg_expr (ctx, e), 
          fun (e) { 
            cg_match (cg_type (ctx, inex.ty), ctx, e, mcs)
          });

      | TExpr.Throw (e) =>
        CExpr.Throw (cg_expr (ctx, e))

      | TExpr.TryWith (body, exn, handler) =>
        def body = cg_expr (ctx, body);
        // FIXME: this is broken for exn values to go into closure
        def (ctx', v) = store_local (ctx, exn, CExpr.Nop ());
        def handler = cg_expr (ctx', handler);
        def res = CExpr.TryWith (body, v, handler);
        res.ty = cg_type (ctx, inex.ty);
        res

      | TExpr.TryFinally (e1, e2) =>
        CExpr.TryFinally (cg_expr (ctx, e1), cg_expr (ctx, e2))

      | TExpr.Literal (l) => 
        CExpr.Literal (l)

      | TExpr.This => 
        CExpr.This ()

      | TExpr.TypeConversion (e, t, is_checked) => 
        CExpr.Cast (cg_expr (ctx, e), cg_type (ctx, t), is_checked)

      | TExpr.TypeEnforcement (e, t) =>
        def e' = cg_expr (ctx, e);
        def t' = cg_type (ctx, t);
        if (type_of (e').IsValueType != t'.IsValueType)
          CExpr.Cast (e', t', true)
        else
          e'

      | TExpr.Sequence (e1, e2) =>
        CExpr.Sequence ([cg_expr (ctx, e1), cg_expr (ctx, e2)])

      | TExpr.Tuple (l) =>
        tuple_ctor (List.Map (l, fun (e) { box_value (self (e)) }))

      | TExpr.Base =>
        Util.ice ("stray base")
        
      | TExpr.OpCode =>
        Util.ice ("stray opcode")
    }
  }

  /** 
   * Flatten given [Typedtree.TExpr] object into [CExpr].
   *
   * <remarks>
   *   As a side-effect few classes for closures and local functions
   *   can be generated and stored in current type builder.
   * </remarks>
   */
  internal cg_expr (ctx : CTX, ex : TExpr) : CExpr
  {
    Util.locate (ex.loc, {
        def e = raw_cg_expr (ctx, ex);
        e.loc = ex.loc;
        e
      })
  }

  mangle (s : string) : string
  {
    def p = s.ToCharArray ();
    
    for (mutable i = 0; i < p.Length; ++i)
      unless ((p[i] >= 'a' && p[i] <= 'z') ||
              (p[i] >= 'A' && p[i] <= 'Z') ||
              (p[i] >= '0' && p[i] <= '9'))
        p[i] = '_';

    System.String (p)
  }

  fun_uniq_name (h : Fun_header) : string
  {
    mangle (h.name) + "_" + h.id.ToString ()
  }

  decl_uniq_name (d : LocalValue) : string
  {
    mangle (d.name) + "_" + d.id.ToString ()
  }

  make_closure_class (ctx : CTX, h : Fun_header) : CTX
  {
    def name = fun_uniq_name (h);
    def tb = ctx.current_type.GetTypeBuilder ().DefineNestedType 
                ("_N_cl_" + name, TypeAttributes.SpecialName %| TypeAttributes.NestedAssembly,
                 SystemType.Object, System.Type.EmptyTypes);
    Passes.ILGenerator.RegisterAuxType (tb);
    def ctor = Passes.ILGenerator.AddImplicitCtor (tb);
    
    def mk_clo_fld (d : LocalValue, acc : SystemMap [int, FieldInfo]) {
      def fi = tb.DefineField (decl_uniq_name (d), cg_type (ctx, d.ty),
                               FieldAttributes.SpecialName %| FieldAttributes.FamORAssem);
      //Message.debug ("add " + d.name + " / " + d.parent_fun.name);
      acc.Add (d.id, fi)
    };
    def closure_fields = List.FoldLeft (h.closure_vars, ctx.closure_fields, mk_clo_fld);
    def cloexpr = CExpr.Call (CExpr.ConstructorRef (ctor), []);
    def cloval = CG_val (h.loc, "_N_closure", tb, cloexpr);
    def cgm = get_cg_method (ctx, h);
    cgm.closure_type = tb;
    def ctx = copy_ctx (ctx);
    ctx.closure_fields = closure_fields;
    ctx.current_closure = Some (cloval);
    ctx
  }

  prepare_ctx_for_fun (ctx : CTX, h : Fun_header) : CTX
  {
    def ctx =
      match (h.closure_vars) {
        | [] => 
          def ctx = copy_ctx (ctx);
          ctx.current_closure = None ();
          ctx

        | _ =>
          make_closure_class (ctx, h)
      };
   
    def cgm = get_cg_method (ctx, h);
    ctx.closure_ptrs = cgm.closure_pointers;
    ctx.locals = SystemMap ();
    ctx.current_fun = h;
    ctx.current_fun_or_loop = h;
    ctx
  }

  get_parents_with_closures (_ctx : CTX, h : Fun_header) : list [Fun_header]
  {
    def parents =
      match (h.decl.kind) {
        | LocalValueKind.Function (_, pars) => pars
        | _ => Util.ice ()
      };
    def loop (fh : Fun_header, acc) {
      match (fh.closure_vars) {
        | _ :: _ => fh :: acc
        | [] => acc
      }
    };
    List.FoldLeft (parents, [], loop)
  }

  call_object_ctor () : CExpr
  {
    CExpr.Call (CExpr.BaseCtorRef (SystemType.ObjectCtor), [])
  }

  get_lambda_ctor (ctx : CTX, h : Fun_header) : ConstructorInfo
  {
    def cg_method = get_cg_method (ctx, h);
    when (cg_method.lambda_ctor == null) {
      def name = fun_uniq_name (h);
      def real_parm_cnt = List.Length (cg_method.parms);
      def virtual_parm_cnt =
        match (Tyutil.fun_type (h)) {
          | TType.Function (args, _) => 
            List.Length (Tyutil.fun_args (args))
          | _ => Util.ice ()
        };
      
      // first create type builder
      def impl =
        if (virtual_parm_cnt == 1)
          array [function_type (1)]
        else
          array [function_type (virtual_parm_cnt), function_type (1)];
      def tb = ctx.current_type.GetTypeBuilder ().DefineNestedType 
                  ("_N_lm_" + name, TypeAttributes.SpecialName %| TypeAttributes.NestedAssembly,
                   SystemType.Object, impl);
      Passes.ILGenerator.RegisterAuxType (tb);
      cg_method.lambda_type_builder = tb;

      when (virtual_parm_cnt != real_parm_cnt) {
        assert (real_parm_cnt == 1);
        Passes.ILGenerator.AddMethod (ctx.current_type, make_untupled_method (ctx, virtual_parm_cnt), tb);
      };
      
      // and then constructor
      def mkparm (fh : Fun_header, acc) {
        def (assigns, vals, ptrs) = acc;
        def cgm = get_cg_method (ctx, fh);
        assert (cgm.closure_type != null);
        def name = fun_uniq_name (fh);
        
        def fld = 
          tb.DefineField (name, cgm.closure_type,
                          FieldAttributes.SpecialName %| FieldAttributes.Private);
          
        def val =
          set_parm_info (TType.Void (),
            CG_val (loc = fh.loc, name = name, ty = cgm.closure_type,
                    val = CExpr.Nop ()));
        
        def assign =
          CExpr.Assign (CExpr.FieldRef (CExpr.This (), fld), CExpr.Ref (val));

        (assign :: assigns, val :: vals, (ptrs : SystemMap [int, FieldInfo]).Add (fh.id, fld))
      };

      def (assigns, vals, ptrs) = 
        List.FoldLeft (get_parents_with_closures (ctx, h), ([], [], SystemMap ()), 
                       mkparm);

      def ctor_cgm = CG_method ();
      ctor_cgm.parms = List.Rev (vals);
      ctor_cgm.modifiers = NemerleAttributes.Internal;
      ctor_cgm.body = CExpr.Sequence (call_object_ctor () :: assigns);

      cg_method.closure_pointers = ptrs;
      Passes.ILGenerator.AddConstructorBuilder (ctor_cgm, tb, false);
      Passes.ILGenerator.EmitConstructor (ctx.current_type, ctor_cgm);
      cg_method.lambda_ctor = ctor_cgm.constructor_builder;
    };
    cg_method.lambda_ctor
  }

  emit_lambda_code (ctx : CTX, fh : Fun_header, body : TExpr) : void
  {
    ignore (get_lambda_ctor (ctx, fh));
    def ctx = prepare_ctx_for_fun (ctx, fh);
    def cgm = get_cg_method (ctx, fh);
    foreach (parm : CG_val in cgm.parms) { 
      assert (parm.parm_info != null);
      assert (parm.parm_info.parm_kind == ParmKind.Normal);
      parm.ty = SystemType.Object 
    };
    cgm.ret_type = SystemType.Object;
    
    def parm_cnt = List.Length (cgm.parms);
    cgm.implemented_methods = [get_apply_method (parm_cnt)];
    cgm.modifiers = NemerleAttributes.Internal;

    Passes.ILGenerator.AddMethodBuilder (cgm, cgm.lambda_type_builder, false);

    cg_fun_body (ctx, fh, body, false);
    
    Passes.ILGenerator.EmitMethod (ctx.current_type, cgm);
    
    when (parm_cnt != 1)
      Passes.ILGenerator.AddMethod (ctx.current_type, make_tupled_method (ctx, parm_cnt), cgm.lambda_type_builder);
  }

  make_lambda_ctor_call (ctx : CTX, fh : Fun_header) : CExpr
  {
    def ctor = get_lambda_ctor (ctx, fh);
    def parms = get_parents_with_closures (ctx, fh);
    def parms' = List.Map (parms, fun (x) { closure_ref (ctx, x) });
    CExpr.Call (CExpr.ConstructorRef (ctor), parms')
  }

  /** Generates compiled body of a typed function */
  cg_fun_body (ctx : CTX, hd : Fun_header, mutable body : TExpr, in_ctor : bool) : void
  {
    def ctx' = copy_ctx (ctx);
    
    // assigments of parameters and 'this' to closure fields
    // interleaved with base (..) call in constructor
    mutable initializers = [];
    // local variables which have to be created from parameters' casted values
    // in case their type in not fully specific (lack of generics?)
    mutable vals = [];

    def loadparm (parm_val : CG_val, fp : Fun_parm) {
      def parm = fp.decl;
      def needed_type = cg_type (ctx, parm.ty);

      if (parm.in_closure) {
        def a =
          CExpr.Assign (local_ref (ctx, parm, true), 
                     maybe_cast (ctx, needed_type, CExpr.Ref (parm_val)));
        initializers = a :: initializers
      } else {
        def v =
          if (parm_val.ty.IsByRef || needed_type.Equals (parm_val.ty))
            parm_val
          else {
            def v = CG_val (loc = fp.decl.loc, 
                            name = Util.tmpname (parm_val.name),
                            ty = needed_type, 
                            val = CExpr.Cast (CExpr.Ref (parm_val), needed_type, true));
            vals = v :: vals;
            v
          };
        ctx'.locals = ctx'.locals.Add (parm.id, v)
      }
    };

    def cgm = get_cg_method (ctx, hd);

    // we build the initialization stuff of method:
    // 1. method's closure ctor()
    // 2. store parameters into closure
    // 3. base (..) / this (..) for constructors
    // 4. store 'this' in closure
    // 5. execute raw body of method
    
    List.Iter2 (cgm.parms, hd.parms, loadparm);
    
    // put base () / this () call before storing 'this' in closure inside constructor
    when (in_ctor && !ctx.current_type.IsValueType)
      match (body) {
        | TExpr.Sequence (TExpr.Call as basecall, rest) =>
          initializers = cg_expr (ctx', basecall) :: initializers;
          body = rest;

        // body contains only base call, so rearrangement is not needed
        | TExpr.Call | TExpr.TailCall => ()
          
        | x =>
          Message.debug (body.loc, body.ToString ());
          Util.ice (" constructor body has: " + PrettyPrint.SprintTyExpr (None (), x))
      }

    // store 'this' into closure object
    foreach ((({ kind = LocalValueKind.ClosurisedThis; in_closure = true; } : LocalValue) as d)
             in ctx.current_fun.closure_vars) 
      initializers = CExpr.Assign (local_ref (ctx, d, true), CExpr.This ()) :: initializers;
    
    // compile raw body of method
    mutable cbody = cg_expr (ctx', body);

    // now put the closure initialization stuff before the raw contents
    def buildlet (v : CG_val, e : CExpr) : CExpr { CExpr.Define (v, e) };
    cbody = List.FoldLeft (vals, 
                           CExpr.Sequence (List.Rev (cbody :: initializers)),
                           buildlet);

    match (ctx.current_closure) {
      | Some (v) => cbody = CExpr.Define (v, cbody)
      | _ => ()
    };

    when (cgm.ret_type.Equals (SystemType.Object))
      cbody = box_value (cbody);

    cgm.body = cbody;
  }

  cg_global_fun (ctx : CTX, m : IMethod, body : TExpr) : void
  {
    fixup_cg_method (m);
    def hd = m.GetHeader ();
    def ctx = prepare_ctx_for_fun (ctx, hd);
    cg_fun_body (ctx, hd, body, m.GetFunKind () is FunKind.Constructor)
  }

  internal CompileMethod (meth : NemerleMethod) : void
  {
    match (meth.fun_body) {
      | FunBody.Parsed => Tyexpr.TypeMethod (meth)
      | _ => ()
    };
    
    Util.locate (meth.Location, {
      match (meth.fun_body) {
        | FunBody.Extern => ()
        | FunBody.Compiled => Util.ice ()
        | FunBody.Parsed => Util.ice ()

        | FunBody.Typed when Message.seen_error () =>
          // just skip it
          meth.fun_body = FunBody.Compiled ()
          
        | FunBody.Typed (body) =>
          def current_type = meth.DeclaringType :> TypeBuilder;
          def ctx = empty_ctx (current_type);
          cg_global_fun (ctx, meth, body);
          // release memory for GC
          meth.fun_body = FunBody.Compiled ();
          match (meth.GetFunKind ()) {
            | FunKind.BoundMethod (impl_list) =>
              def cgm = GetCgMethod (meth);

              Passes.ILGenerator.EmitMethod (current_type, cgm);

              def tb = current_type.GetTypeBuilder ();

              def mkparm (ifp : CG_val, methp : CG_val) : CExpr {
                maybe_cast (ctx, methp.ty, CExpr.Ref (ifp))
              };
              
              def make_impl_wrapper (impl_meth : IMethod) {
                def cgm' = build_cg_method (ctx, impl_meth);
                def meth_ref = CExpr.MethodRef (CExpr.This (), meth.GetMethodBuilder (), false);
                def parms = List.Map2 (cgm'.parms, cgm.parms, mkparm);
                cgm'.body = maybe_cast (ctx, cgm'.ret_type, CExpr.Call (meth_ref, parms));
                cgm'.name = impl_meth.DeclaringType.FullName + "." + cgm.name;
                cgm'.implemented_methods = [impl_meth];
                cgm'.modifiers = NemerleAttributes.Private;
                Passes.ILGenerator.AddMethod (current_type, cgm', tb)
              };
              List.Iter (impl_list, make_impl_wrapper)
              
            | FunKind.Constructor =>
              Passes.ILGenerator.EmitConstructor (current_type, GetCgMethod (meth))
              
            | _ => 
              Passes.ILGenerator.EmitMethod (current_type, GetCgMethod (meth));
          }
        | FunBody.Abstract => ()
      }
    })
  }


} // end module
} // end ns
