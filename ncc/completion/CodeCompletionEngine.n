//
// CodeCompletionEngine.n
//
// Author:
//  Alejandro Serrano (trupill at yahoo dot es)
//

/*
 * Copyright (c) 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using System;
using Nemerle.Compiler;
using Nemerle.Utility;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

using Typed = Nemerle.Compiler.Typedtree;
using SR = System.Reflection;

#define DEBUG

namespace Nemerle.Completion
{
    public enum EngineState {
      | Pure
      | LoadedLibs
    }
  
    public class CodeCompletionEngineException : System.Exception
    {
        public mutable ParsingException : System.Exception;
        
        public this (innerException : System.Exception)
        {
            ParsingException = innerException;
        }
    }
    
    internal variant InternalReference
    {
    | Library { path : string }
    | Assembly { assembly : System.Reflection.Assembly }
    }
    
    public class DefineCollection : System.Collections.Generic.IEnumerable [string]
    {
        internal this (eng : Engine)
        {
            defines = [];
            engine = eng;
        }
        
        internal mutable defines : list[string];
        engine : Completion.Engine;
        
        public Add (define : string) : void
        {
            unless (defines.Contains (define))
            {
                defines ::= define;
                engine.Options.DefineConstant (define);
                engine.Sources.set_unparsed_state ();
            }
        }
        
        public Remove (define : string) : void
        {
            when (defines.Contains (define))
            {
                _ = defines.Remove (define);
                engine.Options.UndefineConstant (define);
                engine.Sources.set_unparsed_state ();
            }
        }
        
        public Contains (define : string) : bool
        {
            defines.Contains (define)
        }
        
        public Clear () : void
        {
            unless (defines.Length == 0)
            {
                foreach (define in defines)
                    engine.Options.UndefineConstant (define);
                defines = [];
                engine.Sources.set_unparsed_state();
            }
        }
        
        public GetEnumerator () : Nemerle.Collections.IEnumerator[string]
        {
            Nemerle.Collections.ListEnumerator (defines)
        }
    }
    
    public class ReferenceCollection
    {
        internal this (eng : Engine)
        {
            references = Hashtable ();
            engine = eng;
        }
        
        internal mutable references : Hashtable[string, InternalReference];
        engine : Completion.Engine;
        
        public Add (key : string, path : string) : void
        {
            unless (references.Contains (key))
            {
                references.Add (key, InternalReference.Library (path));
                engine.LibrariesManager.AddLibrary (path);
            }
        }
        
        public Add (key : string, loadedAssembly : System.Reflection.Assembly) : void
        {
            unless (references.Contains (key))
            {
                references.Add (key, InternalReference.Assembly (loadedAssembly));
                engine.LibrariesManager.AddAssembly (loadedAssembly);
            }
        }
        
        public Remove (key : string) : void
        {
            when (references.Contains (key))
            {
                references.Remove (key);
                engine.state = EngineState.Pure;
                engine.Sources.set_unparsed_state ();
                
                foreach (reference in references.Values)
                {
                | Library as l => engine.LibrariesManager.AddLibrary (l.path);
                | Assembly as a => engine.LibrariesManager.AddAssembly (a.assembly);
                }
            }
        }
        
        public Clear () : void
        {
            references = Hashtable ();
            engine.state = EngineState.Pure;
            engine.Sources.set_unparsed_state ();
        }
        
        public ContainsKey (key : string) : bool
        {
            references.ContainsKey (key)
        }
        
        public GetKeys () : System.Collections.Generic.IEnumerable[string]
        {
            references.Keys
        }
    }
    
    internal variant ParsedFile
    {
        | NotParsed { code : string }
        | Parsed { decls : list [TopDeclaration]; code : string; }
    }
    
    public class SourceCollection
    {
        internal this ()
        {
            sources = Hashtable ();
        }
        
        internal mutable sources : Hashtable[string, ParsedFile];

        public Add (file : string, contents : string) : void
        {
            if (sources.ContainsKey (file))
                sources [file] = ParsedFile.NotParsed (contents);
            else
                sources.Add (file, ParsedFile.NotParsed (contents));
        }
        
        public Remove (dile : string) : void
        {
            sources.Remove (dile);
            set_unparsed_state ();
        }
        
        public Clear () : void
        {
            sources = Hashtable ();
            set_unparsed_state();
        }       
        
        internal set_unparsed_state () : void
        {
            mutable fileList : list[string * string] = [];
            foreach (file in sources) {
                match (file.Value) {
                | Parsed as p => fileList ::= (file.Key, p.code);
                | _ => ();
                }
            }
            foreach (item in fileList) {
                sources [item [0]] = ParsedFile.NotParsed (item [1]);
            }
        }
        
        public ContainsKey (file : string) : bool
        {
            sources.ContainsKey (file)
        }
        
        public GetKeys () : System.Collections.Generic.IEnumerable[string]
        {
            sources.Keys
        }
    }
   
    public class Engine : ManagerClass
    {
        public mutable Defines : DefineCollection;
        public mutable References : ReferenceCollection;
        public Sources : SourceCollection;
        
        [Accessor]
        internal mutable state : EngineState;
        
        syncObject : object;

        mutable is_completion : bool;        
        public override IsInCompletionMode : bool {
          get { is_completion }
        }
        
        public this()
        {
            this (CompilationOptions ());
        }
        
        public this (options : CompilationOptions)
        {
            base (options);
            state = EngineState.Pure;
            is_completion = false;
            syncObject = object();
            Defines = DefineCollection (this);
            References = ReferenceCollection (this);
            Sources = SourceCollection ();
            // this.ParsingPipeline = MainParser.Parse;
            // this.ScanningPipeline = ScanTypeHierarchy (this).ProcessDeclaration;
            MessageOccured += process_error_message;
            Options.GreedyReferences = true;
            Options.ColorMessages = false;
            Options.IgnoreConfusion = true;
        }
        
        public Init () : void
        {
          Options.PersistentLibraries = state == EngineState.LoadedLibs; // if we are not in loaded libs state, it will reload them
          
          // we must clean the nodes from current program - note that this behaviour is automatically provided by Run, but completion
          // engine does not use it at the moment.. :(
          when (Options.PersistentLibraries && Hierarchy != null)
            Hierarchy.RemoveProgramTypes();
         
          InitCompiler ();
          LoadExternalLibraries ();
          
          state = EngineState.LoadedLibs; // next time Init is called, we won't rebuild external types
          Sources.set_unparsed_state ();
          listMessages = [];
        }
        
        public LesserInit () : void
        {
            if (shouldCreate (this.NameTree))        
              this.NameTree = NamespaceTree (this);
            else
              this.NameTree.Init ();
            when (shouldCreate (this.LibrariesManager))
              this.LibrariesManager = LibraryReferenceManager (this, Options.LibraryPaths);     

            this.Solver = Solver (this);
      
            this.CoreEnv = GlobalEnv.CreateCore(this.NameTree);
        }
        
        // If you want to recover the messages done by the parser/typer
        public Output : System.IO.TextWriter
        {
            get { Message_output }
            set { Message_output = value }
        }
        
        public CompilerMessages : array[CompilerMessage]
        {
            get
            {
                if (listMessages == null)
                    array(0)
                else
                    listMessages.ToArray ()
            }
        }
        
        public RunCompletionEngine (member : IMember, contents : string) : array[OverloadPossibility]
        {
            // Tell the methods we are in completion mode
            is_completion = true;
            def observed_method = member :> MethodBuilder;
            
            mutable completionList  = null;
            when (observed_method != null) {
                def env = observed_method.DeclaringType.GlobalEnv;
                def my_body = contents.Trim();

                def lexer = LexerCompletion (this, my_body + " ", my_body.Length);
                observed_method.GetHeader ().body =
                    FunBody.Parsed (MainParser.ParseExpr (env, lexer));
            
                try
                {
                    observed_method.RunBodyTyper ();
                }
                catch
                {
                | e is CompletionResult => completionList = e.Overloads;
                | e => System.Console.WriteLine (e.Message);
                }
            }
            
            if (completionList == null)
                array (0)
            else
                completionList.ToArray ()
        }
        
        mutable listMessages : list[CompilerMessage];
        process_error_message (location : Location, message : string) : void
        {
            mutable error = CompilerMessage();
            error.Location = location;
            if (message.IndexOf ("error: ") != -1)
            {
                error.Message = message.Substring (message.IndexOf ("error: ")).Replace ("error: ", "");
                error.MessageKind = MessageKind.Error;
                listMessages ::= error;
            }
            else if (message.IndexOf ("warning: ") != -1)
            {
                error.Message = message.Substring (message.IndexOf ("warning: ")).Replace ("warning: ", "");
                error.MessageKind = MessageKind.Warning;
                listMessages ::= error;
            }
            else when (message.IndexOf ("hint: ") != -1)
            {
                error.Message = message.Substring (message.IndexOf ("hint: ")).Replace ("hint: ", "");
                error.MessageKind = MessageKind.Hint;
                listMessages ::= error;
            }
        }
       
        public GetTypeTree () : NamespaceTree.Node
        {
            Instance = this;
            Init ();
        
            System.Console.WriteLine ("just before lexing");
            mutable trees = [];
            try
            {
                def filenames = Sources.sources.Fold ([], fun (k, _, acc) { k :: acc });
              
                foreach (filename in filenames)
                {
                    match (Sources.sources [filename])
                    {
                    | NotParsed as np =>
                        def contents = np.code;
                        def lexer = LexerString (this, contents, Location (Location.GetFileIndex (filename), 1, 1));
                        def decls = this.ParsingPipeline (lexer);
                        Sources.sources[filename] = ParsedFile.Parsed (decls, contents);
                        trees ::= decls;
                    | Parsed as p => trees ::= p.decls;
                    }
                }
            }
            catch
            {
                | _e => 
                  #if DEBUG
                  System.Console.WriteLine (_e);
                  #endif
                  {}
            }
             
            System.Console.WriteLine ("just before TypesManager");
            this.Hierarchy = TypesManager (this);
    
            // create N.C.TypeBuilders for all parsed types and add them to namespace hierarchy
            System.Console.WriteLine ("just before parsing");
            try
            {
                foreach (group in trees) {
                    List.Iter (group, this.ScanningPipeline);
                }
            }
            catch
            {
                | _e => 
                  #if DEBUG
                  System.Console.WriteLine (_e);
                  #endif
                  {}
            }
            
            System.Console.WriteLine ("just before building the hierarchy");
            try
            {
                this.Hierarchy.Run();
            }
            catch
            {
                | _e => 
                  #if DEBUG
                  System.Console.WriteLine (_e);
                  #endif
                  {}
            }
            
            this.NameTree.namespace_tree
         }
         
         public static GetNameFromType (t : MType) : string
         {
            | Class as c => mutable name = c.tycon.FrameworkTypeName;
                when (c.args.Length > 0)
                {
                    name += "[";
                    foreach (tyvar in c.args)
                    {
                        | x is MType => name += GetNameFromType (x) + ", ";
                        | _ => ();
                    }
                    name = name.Trim(',', ' ') + "]";
                }
                name
                
            | TyVarRef as r => r.tyvar.Name
            | Fun as f => def name = GetNameFromType (f.from :> MType) + " -> " + GetNameFromType (f.to :> MType); name
            | Tuple as tuple => mutable name = "(";
                foreach (tx in tuple.args)
                {
                    | x is MType => name += GetNameFromType (x) + ", ";
                    | _ => ();
                }
                name = name.Trim(',', ' ') + ")";
                name
            | Array as a => def name = "array[" + GetNameFromType (a.t :> MType) + "]"; name
            | Void => "void"
            | _ => ""
         }
                
    } // end class CodeCompletionEngine
} // end namespace

