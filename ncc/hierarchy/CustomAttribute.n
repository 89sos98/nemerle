/*
 * Copyright (c) 2004-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using System.IO;
using SY = System;

using PT = Nemerle.Compiler.Parsetree;
using SR = System.Reflection;
using SRI = System.Runtime.InteropServices;
using SS = System.Security;
using SSP = System.Security.Permissions;
using SCG = System.Collections.Generic;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler
{
  [ManagerAccess]
  public abstract class AttributeCompilerClass
  {
    protected this (man : ManagerClass)
    {
      Manager = man;
    }

    protected CompileExpr(env : GlobalEnv, ti : TypeBuilder, allow_rec : bool, expr : PT.PExpr) : object * FixedType
    {
      def compileType(parsedType, fixedType)
      {
        match (fixedType)
        {
          | FixedType.Class (tc, args) =>
            def is_free (a) { !(a is FixedType) }
            if (args.Exists (is_free))
            {
              when (!args.ForAll (is_free))
                Message.Error(parsedType.Location, "to create open generic type all arguments must be open `_'");

              (tc.SystemType, InternalType.Type)
            }
            else
              (fixedType.GetSystemType(), InternalType.Type)

          | _ => Message.FatalError(parsedType.Location, $"invalid / unbound type `$(parsedType)' in attribute parameter")
        }
      }

      match (expr)
      {
        | <[ $(x : string) ]> => ((x : object), InternalType.String)
        | <[ $(x : bool) ]> => ((x : object), InternalType.Boolean)
        | <[ $(x : char) ]> => ((x : object), InternalType.Char)
        | PT.PExpr.Literal (Literal.Enum (lval, ty, _)) =>
          def (val, _) = CompileExpr(env, ti, allow_rec, PT.PExpr.Literal (lval));
          (val, FixedType.Class (ty, []))

        | <[ null ]> => (null, InternalType.Type)

        | PT.PExpr.Literal (Literal.Decimal) =>
          Message.FatalError(expr.Location, "An attribute argument cannot be number of type decimal");

        | PT.PExpr.Literal (lit) =>
          (lit.AsObject (InternalType), lit.GetInternalType (InternalType))

        | <[ typeof ($t) ]> when ti != null => compileType(t, ti .BindFixedType(t))
        | <[ typeof ($t) ]>                 => compileType(t, env.BindFixedType(t))
        | <[ array [..$elems] ]> when allow_rec =>
          def exprs = elems.Map(e => CompileExpr(env, ti, false, e));
          def array_tc = exprs.FoldLeft(InternalType.Object_tc,
              fun (et, curty)
              {
                match (et)
                {
                  | (_, FixedType.Class (tc, _)) when !tc.Equals (InternalType.Object_tc) => tc
                  | _ => curty
                }
              });
          def allow_null = array_tc.Equals (InternalType.String_tc) || array_tc.Equals (InternalType.Type_tc);
          def objects = exprs.Map(
            fun (_)
            {
              | (e, FixedType.Class (tc, _)) when tc.Equals (array_tc) => e
              | (x, _) when allow_null && x == null => null
              | (_, t) =>
                Message.FatalError(expr.Location, $"custom attribute array shall have type $array_tc while the element has type $t")
            });

          // FIXME: this seems wrong, what if there are two mscorlibs?

          def arr = objects.ToArray ();
          (arr : object, FixedType.Array(FixedType.Class (array_tc, []), 1))

        | <[ $obj . $(n : name) ]> => Message.FatalError(expr.Location, $"unbound / non-enum member $(n.Id) in $obj at custom attribute parameter")

        | e =>
          def typer = Typer(env, ti);
          def tExpr = typer.TypeExpr(expr);
          match (tExpr)
          {
            | TExpr.DebugInfo(TExpr.Error, _) | TExpr.Error => throw Recovery() // the typer already report error
            | TExpr.DebugInfo(TExpr.Literal(lit), _) | TExpr.Literal(lit) => 
              (lit.AsObject(InternalType), lit.GetInternalType(InternalType))

            | _ => Message.FatalError(tExpr.Location, $"only constant expressions allowed in attributes: $e ($(tExpr.Type))")
          }
      }
    }

    public abstract ResolveAttribute (env : GlobalEnv, expr : PT.PExpr, expect_exact : TypeInfo = null)
    : option [TypeInfo * list [PT.PExpr]];
  }

  public abstract partial class TypesManager
  {
    public AddAssemblyAttribute (env : GlobalEnv, attr : Parsetree.PExpr) : void {
      def add (phase) {
        def suff = AttributeMacroExpansion.Suffix (MacroTargets.Assembly, phase);
        match (MacroRegistry.lookup_macro (env, attr, suff)) {
          | None => false
          | Some =>
            def expansion = AssemblyAttributeMacroExpansion (MacroTargets.Assembly, phase,
                                                             attr, [], null, null, env);
            AddMacroExpansion (expansion);
            true
        }
      }
      def b1 = add (MacroPhase.BeforeInheritance);
      def b2 = add (MacroPhase.BeforeTypedMembers);
      def b3 = add (MacroPhase.WithTypedMembers);
      if (b1 || b2 || b3)
        ()
      else
        assembly_attributes.Add (env, attr);
    }
  }

  public partial class Modifiers
  {
    public IsCustomAttributeDefined(attributeFullName : string, env : GlobalEnv) : bool
    {
      FindAttribute(env.Manager.LookupTypeInfo(attributeFullName), env).IsSome
    }

    /// Finds first attribute of specified type
    public FindAttribute (lookingFor : TypeInfo, env : GlobalEnv) : option [PT.PExpr]
    {
      def compiler = env.Manager.AttributeCompiler;
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr, lookingFor) is Some(_))
          Nemerle.Imperative.Return(Some(expr));
      None()
    }

    /// Finds attribute of specified type
    public FindAttributeWithArgs(lookingFor : TypeInfo, env : GlobalEnv) : option[PT.PExpr * list [PT.PExpr]]
    {
      def compiler = env.Manager.AttributeCompiler;
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr, lookingFor) is Some((_, args)))
          Nemerle.Imperative.Return(Some(expr, args));
      None()
    }

    /// Finds all attributes of specified type
    public FindAttributesWithArgs(lookingFor : TypeInfo, env : GlobalEnv) : list[PT.PExpr * list [PT.PExpr]]
    {
      def compiler = env.Manager.AttributeCompiler;
      mutable result = [];
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr, lookingFor) is Some((_, args)))
          result ::= (expr, args);
      result
    }

    public AttributeTypes(env : GlobalEnv) : list[TypeInfo]
    {
      def compiler = env.Manager.AttributeCompiler;
      mutable result = [];
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr) is Some((ti, _)))
          result ::= ti;
      result
    }
  }
}


