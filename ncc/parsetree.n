/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Utility;

namespace Nemerle.Compiler.Parsetree
{
  public variant SyntaxElement {
    | Expression       { body : PExpr; }
    | Type             { body : PType; }
    | MatchCase        { body : Parsetree.MatchCase; }
    | MatchCaseGuard   { body : PExpr; guard : option [PExpr]; }
    | Function         { body : Function_decl; }
    | Parameter        { body : Fun_parm; }
    | TType            { body : PType; }

    | ClassMember      { body : Parsetree.ClassMember; }    
    | TypeBuilder      { body : Nemerle.Compiler.TypeBuilder; }
    | FieldBuilder     { body : NemerleField; }
    | MethodBuilder    { body : NemerleMethod; }
    | PropertyBuilder  { body : NemerleProperty; }
    | EventBuilder     { body : NemerleEvent; }
    | ParameterBuilder { body : Typedtree.Fun_parm; }
  }

  [Record]
  public class DeclarationBase : Located
  {
    public mutable name : Splicable;
    public mutable modifiers : Modifiers;

    public Name : string {
      get { name.GetName ().Id }
    }

    public Attributes : NemerleAttributes {
      get { modifiers.mods }
      set { modifiers.mods = value }
    }
  }

  [Record]
  public class Constraint
  {
    public tyvar : string * int;
    public ty : PType;
  }

  [Record]
  public class Typarms
  {
    public tyvars : list [string * int];
    public constraints : list [Constraint];

    public static Empty : Typarms = Typarms ([], []);
  }

  [Record]
  public variant TopDeclaration : DeclarationBase
  {
    | Namespace { decls : list [TopDeclaration]; }
    | Using 
    | UsingAlias { alias : string; }
    | Attribute { body : PExpr; }

    | Class {
      typarms : Typarms;
      mutable t_extends : list [PType];
      decls : list [ClassMember];
    }
    | Alias {
      typarms : Typarms;
      ty : PType;
    }
    | Interface {
      typarms : Typarms;
      mutable t_extends : list [PType];
      methods : list [ClassMember]; // only iface_member
    } 
    | Variant {
      typarms : Typarms;
      mutable t_extends : list [PType];
      mutable decls : list [ClassMember];
    }
    | VariantOption { decls : list [ClassMember]; }

    | Macro {
      header : Fun_header;
      synt : list [PExpr];
      expr : PExpr;
    }
    | Delegate { header : Fun_header; }
    | Enum {
      t_extends : list [PType];
      decls : list[ClassMember];
    }

    public this () { base (Splicable.Name (Name ([])), Modifiers.Empty) }
  }

  [Record]
  public variant ClassMember : DeclarationBase
  {
    | TypeDeclaration { td : TopDeclaration; }
    | Field { ty : PType; }
    | Function { 
        header : Fun_header;
        kind : FunKind;
        mutable body : FunBody;
      }
    | Property {
        ty : PType;
        prop_ty : PType;
        dims : list [Fun_parm]; // parameters of indexer property
        get : option [ClassMember];
        set : option [ClassMember];
      }
    | Event {
        ty : PType;
        add : option [ClassMember.Function];
        remove : option [ClassMember.Function];
      }
    | EnumOption { value : option [PExpr]; }

    /** accessible only for ClassMember.Function, when its FunBody is not typed or compiled */
    public Body : PExpr {
      get {
        match (this) {
          | ClassMember.Function { body = bd } =>
            match (bd) {
              | FunBody.Parsed (expr) => expr
              | FunBody.Typed =>
                Message.error ("Body of typed method is not accessible");
                null
              | FunBody.Compiled =>
                Message.error ("Body of compiled method is not accessible");
                null
              | FunBody.Extern 
              | FunBody.Abstract => <[ () ]>
            }
          | _ =>
            Message.error ("Body is accessible only for ClassMember.Function variant option");
            null
        }
      }
      set {
        match (this) {
          | ClassMember.Function as fn =>
            fn.body = FunBody.Parsed (value);
          | _ =>
            Message.error ("Body is accessible only for ClassMember.Function variant option")
        }
      }
    }
  }

  /** class encapsulating name of variable for purpose of
      quotation and renaming
   */    
  public class Name : Nemerle.IComparable [Name]
  {
    public idl : list [string];  
    public color : int;
    public context : GlobalEnv;

    public this (idl : list[string])
    {
      this.idl = idl;
      this.color = TypingContext.MacroColor;
      this.context = null; // no global context
    }

    public this (id : string)
    {
      this.color = TypingContext.MacroColor;
      this.context = null; // no global context
      idl = [id]
    }

    public this (id : list [string], color : int, context : GlobalEnv)
    {
      this.color = color;
      this.context = context;
      idl = id;
    }

    static public NameInCurrentColor (id : list [string], context : GlobalEnv) : Name
    {
      Name (id, TypingContext.MacroColor, context)
    }


    /** returns the first part of the name (in most cases it is entime name)
     */
    public Id : string
    {
      get { Nemerle.Collections.List.Head (idl) }
    }

    /** return fully qualified name stored in this instance
        (in most cases it doesn't differ from Id)
     */                                                           
    public FullId : string
    {
      get { Nemerle.Utility.NString.Concat (".", idl) }
    }

    public override ToString () : string
    {
      FullId
    }

    [Nemerle.OverrideObjectEquals]
    public Equals (other : Name) : bool
    {
      color == other.color && lexicographic_compare (idl, other.idl) == 0
    }

    public CompareTo (other : Name) : int
    {
      if (color == other.color || color < 0 || other.color < 0)
        lexicographic_compare (idl, other.idl)
      else
        color - other.color
    }

    lexicographic_compare (my : list [string], oth : list [string]) : int {
      | (x :: xs, y :: ys) =>
        if (x == y) lexicographic_compare (xs, ys)
        else string.CompareOrdinal (x, y)
      | ([], []) => 0
      | (_, []) => 1
      | ([], _) => -1
    }

    public GetEnv (default : GlobalEnv) : GlobalEnv
    {
      if (context != null)
        context
      else
        default
    }
  }

  [Record]
  public variant Splicable : Located 
  {
    | Name { body : Parsetree.Name; }
    | Int { body : int; }    
    | Expression { expr : PExpr; }

    public GetName () : Parsetree.Name {
      match (this) {
        | Splicable.Name (x) => x
        | _ => throw System.ArgumentException ("GetName () called for option " + this.ToString ())
      }
    }

    public GetIdList () : list [string] {
      match (this) {
        | Splicable.Name ({ idl = x }) => x
        | _ => throw System.ArgumentException ("GetIdList () called for option " + this.ToString ())
      }
    }

    public GetFullId () : string {
      match (this) {
        | Splicable.Name ({ idl = x }) => NString.Concat (".", x)
        | _ => throw System.ArgumentException ("GetFullId () called for option " + this.ToString ())
      }
    }
  }

  public variant PType
  {
    | Class     { tycon : Splicable; args : list [PType];  }
    | ByRef     { t : PType; }
    | Out       { t : PType; }
    | Function  { from : PType; to : PType; }
    | Void
    | Product   { args : list [PType]; }
    | Array     { t : PType; rank : Splicable; }
    | Infer

    | Spliced   { expr : PExpr; }
    | Ellipsis  { body: PType; }
    | Typed     { body : Typedtree.TType; }
  }

  public class Fun_parm : DeclarationBase
  {
    public ty : PType;
    public this (name : Splicable, ty : PType, modifiers : Modifiers) 
    {
      base (Location.Default, name, modifiers);
      this.ty = ty;
    }
    public this (loc : Location, name : Splicable, ty : PType,
                 modifiers : Modifiers) 
    {
      base (loc, name, modifiers);      
      this.ty = ty;
    }
  }

  public class Fun_header : Located
  {
    public typarms : Typarms;
    public mutable name : Splicable; // is changed when typing lambda
    public ret_type : PType;
    public parms : list [Fun_parm];

    public this (loc : Location, name : Splicable, ret_type : PType, 
                 parms : list [Fun_parm]) 
    {
      base (loc);
      this.typarms = Typarms.Empty;
      this.name = name;
      this.ret_type = ret_type;
      this.parms = parms;
    }

    public this (typarms : Typarms, 
                 name : Splicable, 
                 ret_type : PType, 
                 parms : list [Fun_parm]) 
    {
      this.typarms = typarms;
      this.name = name;
      this.ret_type = ret_type;
      this.parms = parms;
    }

    public this (loc : Location,
                 typarms : Typarms, 
                 name : Splicable, 
                 ret_type : PType, 
                 parms : list [Fun_parm]) 
    {
      base (loc);
      this.typarms = typarms;
      this.name = name;
      this.ret_type = ret_type;
      this.parms = parms;
    }
  }

  [Record]
  public class Function_decl
  {
    public header : Fun_header;
    public mutable body : PExpr;
  }

  [Record]
  public class MatchCase
  {
    public this (patterns : list [PExpr * option [PExpr]], body : PExpr)
    {
      this (patterns, body, false)
    }

    public patterns : list [PExpr * option [PExpr]];
    public body : PExpr;
    public disable_warnings : bool;
  }

  [Record]
  public variant PExpr : Located 
  {
    | Wildcard
    | As              { pat : PExpr; name : Splicable; }
    | DefPattern      { pattern : PExpr; val : PExpr; }
    | Match           { expr : PExpr; cases : list [MatchCase]; }
    | Application     { func : PExpr; arg : PExpr; }    

    | Ref             { name : Name; }
    | Member          { obj : PExpr; member : Splicable; }
    | Call            { func : PExpr; parms : list [PExpr]; }
    | Assign          { target : PExpr; source : PExpr; }
    | Define          { is_ref : bool; name : Splicable; val : PExpr; }
    | DefFunctions    { funs : list [Function_decl]; }
    | Lambda          { decl : Function_decl; }
    | Throw           { exn : PExpr; }
    | TryWith         { body : PExpr; exn : Splicable; exn_ty : PType; 
                        handler : PExpr; }
    | TryFinally      { body : PExpr; handler : PExpr; }
    | Literal         { val : Nemerle.Compiler.Literal; }
    | This
    | Base
    | Typeof          { ty : PType; }
    | TypeConversion  { expr : PExpr; ty : PType; }  // (expr :> ty)
    | TypeEnforcement { expr : PExpr; ty : PType; } // (expr : ty)
    | Sequence        { body : list [PExpr]; }
    | Tuple           { args : list [PExpr]; }
    | Array           { rank : PExpr; args : PExpr; }
    | EmptyArray      { sizes : list [PExpr]; }
    | Indexer         { obj : PExpr; args : list [PExpr]; }

    | ParmByRef       { parm : PExpr; }
    | ParmOut         { parm : PExpr; }

    // macros stuff    
    | MacroCall       { name : Name; ns : GlobalEnv.NamespaceND;
                        parms : list [SyntaxElement]; }
    | Quoted          { body : SyntaxElement; }
    | Spliced         { body : PExpr; }
    | Ellipsis        { body : PExpr; }
    | Typed           { body : Typedtree.TExpr; }
    | TypedPattern    { body : Typedtree.Pattern; }  
  }
} // Nemerle.Compiler

