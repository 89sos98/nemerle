/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met :
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections.New 
{

 /* Comparision releated definition */

  /* Interfaces */

  public interface IComparable ('a)
  {
    CompareTo (_ : 'a) : int;
  }

  public interface IComparator ('a)
  {
    Compare (_ : 'a, _ : 'a) : int;
  }

/* End of Comparision releated definitions */

/* Functional Red-Black Trees implementation */

  public class BalanceViolation extends System.Exception
  {
    public this () {}
  }

  public module Tree 
  {

    public variant Node ('a) where 'a : > IComparable ('a)
    {
      | Tr {
             key : 'a;
             isBlack : bool;
             lchild : Node ('a);
             rchild : Node ('a); 
           }

      | Leaf
    }

    public 'a where 'a : > IComparable ('a) 
    Get (tree : Node ('a), elem : 'a) : option ('a)
    {
      def get (tree : Node ('a), candidate : option ('a)) : option ('a) 
          { 
            match (tree) {
              | (Tr) as tree => if (tree.key.CompareTo (elem) > 0)
                                  get (tree.lchild, candidate)
                                else
                                  get (tree.rchild, Some (tree.key))
              | Leaf => match (candidate) {
                          | Some (key) => if (elem.CompareTo (key) == 0)
                                            candidate
                                          else 
                                            None ()
                          | None => None ()
                        }
            }
          };
      get (tree, None ())
    }

    public 'a where 'a : > IComparable ('a)
    AckInsert (tree : Node ('a), elem : 'a, replace : bool) : Node ('a) * bool
    {
      def insert (tree : Node ('a)) : Node ('a) * bool
          {
            match (tree) {
              | (Tr (key, false, ltree, rtree)) as node =>
                  if (elem.CompareTo (key) > 0)
                    match (insert (rtree)) {
                      (treee, bl) => 
                        (Tr (key, false, ltree, treee), bl)
                    }
                  else if (elem.CompareTo (key) < 0)
                    match (insert (ltree)) {
                      (treee, bl) =>
                          (Tr (key, false, treee, rtree), bl)
                    }
                  else if (replace)
                    (Tr (elem, false, ltree, rtree), false)
                  else 
                    (node, false)
              | (Tr (key, true, ltree, rtree)) as node =>
                  if (elem.CompareTo (key) > 0)
                    match (insert (rtree)) {
                      (treee, bl) => 
                        (BalanceRight (key, ltree, treee), bl)
                    }
                  else if (elem.CompareTo (key)<0)
                    match (insert (ltree)) {
                      (treee, bl) =>
                        (BalanceLeft (key, treee, rtree), bl)
                    }
                  else if (replace)
                    (Tr (elem, false, ltree, rtree), false)
                  else 
                    (node, false)
              | Leaf => 
                  (Tr (elem, false, Leaf (), Leaf ()), true)
            }
          };
      match (insert (tree)){
        | (Tr (key, _, ltree, rtree), bl) =>
            (Tr (key, true, ltree, rtree), bl)
        | (Leaf, bl) => (Leaf (), bl)
      }
    }

    public 'a where 'a : > IComparable ('a)
    Insert (tree : Node ('a), elem : 'a, replace : bool) : Node ('a)
    {
      match (AckInsert (tree, elem, replace)) {
        (treee, _) => treee
      }
    }

    private 'a where 'a : > IComparable ('a)
    BalanceLeft (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ((elem, lchild, rchild)){
        | (key, Tr (key1, false, ltree1, rtree1), Tr (key2, false, ltree2, rtree2)) =>
            Tr (key, false, Tr (key1, true, ltree1, rtree1), Tr (key2, true, ltree2, rtree2))
        | (key, Tr (key1, false, Tr (key2, false, ltree2, rtree2), rtree1), rtree) =>
            Tr (key1, false, Tr (key2, true, ltree2, rtree2), Tr (key, true, rtree1, rtree))
        | (key, Tr (key1, false, ltree1, Tr (key2, false, ltree2, rtree2)), rtree) =>
            Tr (key2, false, Tr (key1, true, ltree1, ltree2), Tr (key, true, rtree2, rtree))
        | (key, ltree, rtree) =>
            Tr (key, true, ltree, rtree)
      } 
    }

    'a where 'a : > IComparable ('a)
    BalanceRight (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ((elem, lchild, rchild)){
        | (key, Tr (key1, false, ltree1, rtree1), Tr (key2, false, ltree2, rtree2)) =>
            Tr (key, false, Tr (key1, true, ltree1, rtree1), Tr (key2, true, ltree2, rtree2))
        | (key, ltree, Tr (key1, false, ltree1, Tr (key2, false, ltree2, rtree2))) =>
            Tr (key1, false, Tr (key, true, ltree, ltree1), Tr (key2, true, ltree2, rtree2))
        | (key, ltree, Tr (key1, false, Tr (key2, false, ltree2, rtree2), rtree1)) =>
            Tr (key2, false, Tr (key, true, ltree, ltree2), Tr (key1, true, rtree2, rtree1))
        | (key, ltree, rtree) =>
            Tr (key, true, ltree, rtree)
      } 
    } 

    public 'a where 'a : > IComparable ('a)
    AckDelete (tree : Node ('a), elem : 'a) : Node ('a) * bool
    {
      def delete (tree : Node ('a)) : Node ('a) * bool
          {
            match (tree){
              | Tr (key, _, ltree, rtree) =>
                  if (elem.CompareTo (key)>0)
                    match (rtree) {
                      | Tr (_, true, _, _) => 
                          match (delete (rtree)) {
                            (treee, bl) =>
                              (BalRight (key, ltree, treee), bl)
                          }  
                      | _ => 
                          match (delete (rtree)) {
                            (treee, bl) => (Tr (key, false, ltree, treee), bl)
                          }
                    } 
                  else if (elem.CompareTo (key)<0)
                    match (ltree) {
                      | Tr (_, true, _, _) =>   
                          match (delete (ltree)) {
                            (treee, bl) =>
                              (BalLeft (key, treee, rtree), bl)
                          }  
                      | _ =>
                          match (delete (ltree)) {
                            (treee, bl) => (Tr (key, false, treee, rtree), bl)
                          }
                    }
                  else 
                    (GetSubst (ltree, rtree),true)
              | Leaf => (Leaf (), false)
            }
          };
      match (delete (tree)){
        | (Tr (key, _, ltree, rtree), bl) =>
            (Tr (key, true, ltree, rtree), bl)
        | (Leaf, bl) => (Leaf (), bl)
      } 
    }

    public 'a where 'a :> IComparable ('a)
    Delete (tree : Node ('a), elem : 'a) : Node ('a)
    {
      match (AckDelete (tree, elem)) {
        (treee, _) => treee
      }
    }
   
    private 'a where 'a : > IComparable ('a)
    BalRight (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ( (elem, lchild, rchild)){
        | (key, ltree, Tr (key1, false, ltree1, rtree1)) =>
            Tr (key, false, ltree, Tr (key1, true, ltree1, rtree1))
        | (key, Tr (key1, true, ltree1, rtree1), rtree) =>
            BalanceLeft (key, Tr (key1, false, ltree1, rtree1), rtree)
        | (key, Tr (key1, false, Tr (key3, true, ltree3, rtree3), Tr (key2, true, ltree2, rtree2)), rtree) =>
            Tr (key2, false, BalanceLeft (key1, Tr (key3, false, ltree3, rtree3), ltree2), Tr (key, true, rtree2, rtree))
        | _ => raise BalanceViolation ()
      }
    }

    private 'a where 'a : > IComparable ('a)
    BalLeft (elem : 'a, lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ( (elem, lchild, rchild)){
        | (key, Tr (key1, false, ltree1, rtree1), rtree) =>
            Tr (key, false, Tr (key1, true, ltree1, rtree1), rtree)
        | (key, ltree, Tr (key1, true, ltree1, rtree1)) =>
            BalanceRight (key, ltree, Tr (key1, false, ltree1, rtree1))
        | (key, ltree, Tr (key1, false, Tr (key3, true, ltree3, rtree3), Tr (key2, true, ltree2, rtree2))) =>
            Tr (key3, false, Tr (key, true, ltree, ltree3), BalanceRight (key1, rtree3, Tr (key2, false, ltree2, rtree2)))
        | _ => raise BalanceViolation ()
      }
    }

    private 'a where 'a : > IComparable ('a)
    GetSubst (lchild : Node ('a), rchild : Node ('a)) : Node ('a)
    {
      match ( (lchild, rchild)){
        | (Leaf, tree) => tree
        | (tree, Leaf) => tree
        | (Tr (key, false, ltree, rtree), Tr (key1, false, ltree1, rtree1)) =>
            match (GetSubst (rtree, ltree1)){
              | Tr (key2, false, ltree2, rtree2) =>
                  Tr (key2, false, Tr (key, false, ltree, ltree2), Tr (key1, false, rtree2, rtree1))
              | tree => Tr (key, false, ltree, Tr (key1, false, tree, rtree1))
            }
        | (Tr (key, true, ltree, rtree), Tr (key1, true, ltree1, rtree1)) =>
            match (GetSubst (rtree, ltree1)){
              | Tr (key2, false, ltree2, rtree2) =>
                  Tr (key2, false, Tr (key, true, ltree, ltree2), Tr (key1, true, rtree2, rtree1))
              | tree => BalLeft (key, ltree, Tr (key1, true, tree, rtree1))
            }
        | (tree, Tr (key, false, ltree, rtree)) =>
            Tr (key, false, GetSubst (tree, ltree), rtree)
        | (Tr (key, false, ltree, rtree), tree) =>
            Tr (key, false, ltree, GetSubst (rtree, tree))
      }
    }

    public 'a, 'b where 'a : > IComparable ('a) 
    Fold (tree : Node ('a), func : 'b * 'a -> 'b, ini : 'b) : 'b 
    {
      match (tree) {
        | Tr (key, _, ltree, rtree) =>
            Fold (rtree, func, func (Fold (ltree, func, ini), key))
        | Leaf => ini
      }
    } 

    public 'a where 'a :> IComparable ('a) 
    Exists (tree : Node ('a), func : 'a -> bool) : bool
    {
      def exists (tree : Node ('a)) : bool
          {
            match (tree) {
              | Tr (key, _, ltree, rtree) =>
                  if (func (key))
                    true
                  else 
                    if (exists (ltree))
                      true
                    else
                      exists (rtree)
              | Leaf => false
            }
          };
      exists (tree)
    }
    
    public 'a where 'a :> IComparable ('a) 
    ForAll (tree : Node ('a), func : 'a -> bool) : bool
    {
      def forall (tree : Node ('a)) : bool
          {
            match (tree) {
              | Tr (key, _, ltree, rtree) =>
                  if (func (key))
                    if (forall (ltree))
                       forall (rtree)
                    else
                       false
                  else
                    false
              | Leaf => true
            }
          };
      forall (tree)
    }

    public 'a where 'a : > IComparable ('a) 
    Partition (tree : Node ('a), func : 'a -> bool) : Node ('a) * Node ('a)
    {
      match (CountPartition (tree, func)) {
        (ytree, _, ntree, _) =>
          (ytree, ntree)
      }
    }

    public 'a where 'a : > IComparable ('a) 
    CountPartition (tree : Node ('a), func : 'a -> bool) : Node ('a) * int * Node ('a) * int
    {
      def partition (tree : Node ('a), yntree : Node ('a) * int * Node ('a) * int) : Node ('a) * int * Node ('a) * int
          {
            match (tree) {
              | Tr (key, _, ltree, rtree) =>
                  match (yntree) {
                    (ytree, ysize, ntree, nsize) =>
                      if ( func (key) )
                        partition (rtree, partition (ltree, (Insert (ytree, key, false), ysize + 1, ntree, nsize)))
                      else 
                        partition (rtree, partition (ltree, (ytree, ysize, Insert (ntree, key, false), nsize + 1)))
                  }
              | Leaf => yntree
            }
          };
      partition (tree, (Leaf (), 0, Leaf (), 0))
    } 

    public 'a where 'a : > IComparable ('a) 
    Filter (tree : Node ('a), func : 'a -> bool) : Node ('a)
    {
      match (CountFilter (tree, func)) {
        (treee, _) => treee
      }
    }

    public 'a where 'a : > IComparable ('a) 
    CountFilter (tree : Node ('a), func : 'a -> bool) : Node ('a) * int
    {
      def filter (tree : Node ('a), ytree : Node ('a) * int) : Node ('a) * int
          {
            match (tree) {
              | Tr (key, _, ltree, rtree) =>
                  match (ytree) {
                    (ytree, ysize) =>
                      if ( func (key) )
                        filter (rtree, filter (ltree, (Insert (ytree, key, false), ysize + 1)))
                      else 
                        filter (rtree, filter (ltree, (ytree, ysize)))
                  }
              | Leaf => ytree
            }
          };
      filter (tree, (Leaf (), 0))
    } 
  
/*
  FIXME: There is a problem with this function - it doesn't need to do correct tranformation

    public 'a,'b where 'a :> IComparable ('a), 'b :> IComparable ('b)
    Map (tree : Node ('a), func : 'a -> 'b) : Node ('b)
    {
      def map (tree: Node ('a)) : Node ('b)
          {
            match (tree) {
              | Tr (key, color, ltree, rtree) =>
                  Tr (func (key), color, map (ltree), map (rtree))
              | Leaf => Leaf ()
            } 
          };
      map (tree)
    }
*/   
  } 

/* End of Functional Red-Black Trees implementation */

/* Implementation of mapping using Red-Black Trees */

  /* Main (public) module dedicated to create particular instance of Map */

  public module Map ('a, 'b) 
  {
    public 'a, 'b where 'a :> System.IComparable
     MakeSysMap () : IMap ('a, 'b)
    {
      SystemMap ()
    } 
    
    public 'a, 'b where 'a :> IComparable ('a)
     MakeNemMap () : IMap ('a, 'b)
    {
      NemerleMap ()
    }
   
    public 'c IntMap () : IMap (int, 'c)
    { 
       (SystemMap () :> IMap (int, 'c))
    }
   
    public 'c StringMap () : IMap (string, 'c)
    { 
       (SystemMap () :> IMap (string, 'c)) 
    }  
  } 
  
  public class NotFound extends System.Exception
  {
    public this () {}
  }

  /* Interface dedicated to be the only way to interact with Map object */

  public interface IMap ('a, 'b) 
  {
    Add (k : 'a, v : 'b) : IMap ('a, 'b); 
    Clear () : IMap ('a, 'b);
    Copy () : IMap ('a, 'b);
    Exists (func : 'a * 'b -> bool) : bool; 
    Filter (func : 'a * 'b -> bool) : IMap ('a, 'b); 
    Find (k : 'a) : option ('b); 
    First () : 'b;
    'c Fold (func : 'c * 'a * 'b -> 'c, ini : 'c) : 'c;
    ForAll (func : 'a * 'b -> bool) : bool;
    Get (k : 'a) : 'b;
    IsEmpty () : bool;
    Iter (func : 'a * 'b -> void) : void;
    Member (k : 'a) : bool;
    Partition (func : 'a * 'b -> bool) : IMap ('a, 'b) * IMap ('a, 'b); 
    Remove (k : 'a, v : 'b) : IMap ('a, 'b);
    Replace (k : 'a, v : 'b) : IMap ('a, 'b);
    Size () : int;    
  }     

  public class NodeSys ('a, 'b) where 'a :> System.IComparable implements IComparable (NodeSys ('a, 'b)) 
  {
    public key : 'a;
    public val : 'b;
    
    public CompareTo (x : NodeSys ('a, 'b)) : int implements IComparable.CompareTo
    { 
      key.CompareTo (x.key) 
    }

    public this (k : 'a, v : 'b) 
    { 
      this.key <- k; 
      this.val <- v;
    }

    public this (k : 'a) 
    {
      this.key <- k;
    }
  } 

  public class NodeNem ('a, 'b) where 'a :> IComparable ('a) implements IComparable (NodeNem ('a, 'b))
  {
    public key : 'a;
    public val : 'b;
    
    public CompareTo (x : NodeNem ('a, 'b)) : int implements IComparable.CompareTo
    { 
      key.CompareTo (x.key) 
    }

    public this (k : 'a, v : 'b) 
    { 
      this.key <- k; 
      this.val <- v;
    }

    public this (k : 'a) 
    {
      this.key <- k;
    }
  } 

  /* definition of Map class that uses Nemerle.IComparable.CompareTo method of 'a for comparision */
   
  public class NemerleMap ('a, 'b) where 'a :> IComparable ('a) implements IMap ('a, 'b) 
  {
    protected root : Tree.Node (NodeNem ('a, 'b));
    protected size : int;

    // TODO : Make it implement ICollection (problem with names and being functional or imperative - both mb)

    public this ()
    {
      this.root <- Tree.Leaf ();
      this.size <- 0;
    }

    protected this (size : int, r : Tree.Node (NodeNem ('a, 'b))) 
    {
      this.size <- size;
      this.root <- r;
    }

    public Copy () : NemerleMap ('a, 'b) implements IMap.Copy
    {
      this
    }


    public First () : 'b  implements IMap.First
    {
      match (root) {
        | Tree.Leaf => raise Nemerle.Collections.EmptyCollection("Map is empty")
        | Tree.Tr (key, _, _, _) => key.val
      }
    }

    public IsEmpty () : bool implements IMap.IsEmpty
    {
      match (root) {
        | Tree.Leaf => true
        | _ => false
      }
    }

    public Clear () : NemerleMap ('a, 'b) implements IMap.Clear
    {
      NemerleMap ()
    }

    public Add (k : 'a, v : 'b) : NemerleMap ('a, 'b)  implements IMap.Add
    { 
      match (Tree.AckInsert (this.root, NodeNem (k, v), false)) {
        | (treee, true) =>
            NemerleMap (this.size + 1, treee)
        | (treee, false) =>
            NemerleMap (this.size, treee)
      } 
    }

    public Replace (k : 'a, v : 'b) : NemerleMap ('a, 'b)  implements IMap.Replace
    { 
      match (Tree.AckInsert (this.root, NodeNem (k, v), true)) {
        | (treee, true) =>
            NemerleMap (this.size + 1, treee)
        | (treee, false) =>
            NemerleMap (this.size, treee)
      } 
    }

    public Find (k : 'a) : option ('b)  implements IMap.Find
    {
      match (Tree.Get (this.root, NodeNem (k))) {
        | (Some) as n => Some (n.val.val) 
        | None => None ()
      }
    }

    public Get (k : 'a) : 'b  implements IMap.Get
    {
      match (Tree.Get (this.root, NodeNem (k))) {
        | (Some) as n => n.val.val 
        | None => raise (NotFound ())
      }
    }

    public Member (k : 'a) : bool implements IMap.Member
    {
      match (Tree.Get (this.root, NodeNem (k))) {
        | Some => true 
        | None => raise (NotFound ())
      }
    }
 
    public Remove (k : 'a, v : 'b) : NemerleMap ('a, 'b) implements IMap.Remove
    {
      match (Tree.AckDelete (this.root, NodeNem (k, v))) {
        | (tree, true) =>
            NemerleMap (this.size - 1, tree)
        | (tree, false) =>
            NemerleMap (this.size, tree)   
      }      
    }

    public Size () : int implements IMap.Size
    {
      this.size
    }

    public 'd Fold (func : 'd * 'a * 'b -> 'd, ini : 'd) : 'd implements IMap.Fold
    {
      def wrap (ctx : 'd, n : NodeNem ('a, 'b)) : 'd 
          {
            func (ctx, n.key, n.val)
          };
      Tree.Fold (this.root, wrap, ini)
    }

    public Iter (func : 'a * 'b -> void) : void implements IMap.Iter
    {
      def wrap (ctx : int, n : NodeNem ('a, 'b)) : int
          { 
            func (n.key, n.val); 
            ctx 
          };
      def _ = Tree.Fold (this.root, wrap, 0);
      ()
    }
    
    public ForAll (func : 'a * 'b -> bool) : bool implements IMap.ForAll
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.ForAll (this.root, wrap)
    }

    public Exists (func : 'a * 'b -> bool) : bool implements IMap.Exists
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.Exists (this.root, wrap)
    }

    public Filter (func : 'a * 'b -> bool) : NemerleMap ('a, 'b) implements IMap.Filter
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountFilter (this.root, wrap)) {
        (ytree, ycount) =>
          NemerleMap (ycount, ytree) 
      }
    }

    public Partition (func : 'a * 'b -> bool) : NemerleMap ('a, 'b) * NemerleMap ('a, 'b) implements IMap.Partition
    {
      def wrap (keyval : NodeNem ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountPartition (this.root, wrap)) {
        (ytree, ycount, ntree, ncount) =>
          (NemerleMap (ycount, ytree), NemerleMap (ncount, ntree)) 
      }
    }

  }

  /* definition of Map class that uses System.IComparable.CompareTo method of 'a for comparision */

  public class SystemMap ('a, 'b) where 'a :> System.IComparable implements IMap ('a, 'b)
  {
    protected root : Tree.Node (NodeSys ('a, 'b));
    protected size : int;

    // TODO : Make it implement ICollection (problem with names and being functional or imperative - both mb)

    public this ()
    {
      this.root <- Tree.Leaf ();
      this.size <- 0;
    }

    protected this (size : int, r : Tree.Node (NodeSys ('a, 'b))) 
    {
      this.size <- size;
      this.root <- r;
    }

    public Copy () : SystemMap ('a, 'b) implements IMap.Copy
    {
      this
    }


    public First () : 'b  implements IMap.First
    {
      match (root) {
        | Tree.Leaf => raise Nemerle.Collections.EmptyCollection("Map is empty")
        | Tree.Tr (key, _, _, _) => key.val
      }
    }

    public IsEmpty () : bool implements IMap.IsEmpty
    {
      match (root) {
        | Tree.Leaf => true
        | _ => false
      }
    }

    public Clear () : SystemMap ('a, 'b) implements IMap.Clear
    {
      SystemMap ()
    }

    public Add (k : 'a, v : 'b) : SystemMap ('a, 'b)  implements IMap.Add
    { 
      match (Tree.AckInsert (this.root, NodeSys (k, v), false)) {
        | (treee, true) =>
            SystemMap (this.size + 1, treee)
        | (treee, false) =>
            SystemMap (this.size, treee)
      } 
    }

    public Replace (k : 'a, v : 'b) : SystemMap ('a, 'b)  implements IMap.Replace
    { 
      match (Tree.AckInsert (this.root, NodeSys (k, v), true)) {
        | (treee, true) =>
            SystemMap (this.size + 1, treee)
        | (treee, false) =>
            SystemMap (this.size, treee)
      } 
    }

    public Find (k : 'a) : option ('b)  implements IMap.Find
    {
      match (Tree.Get (this.root, NodeSys (k))) {
        | (Some) as n => Some (n.val.val) 
        | None => None ()
      }
    }

    public Get (k : 'a) : 'b  implements IMap.Get
    {
      match (Tree.Get (this.root, NodeSys (k))) {
        | (Some) as n => n.val.val 
        | None => raise (NotFound ())
      }
    }

    public Member (k : 'a) : bool implements IMap.Member
    {
      match (Tree.Get (this.root, NodeSys (k))) {
        | Some => true 
        | None => raise (NotFound ())
      }
    }
 
    public Remove (k : 'a, v : 'b) : SystemMap ('a, 'b) implements IMap.Remove
    {
      match (Tree.AckDelete (this.root, NodeSys (k, v))) {
        | (tree, true) =>
            SystemMap (this.size - 1, tree)
        | (tree, false) =>
            SystemMap (this.size, tree)   
      }      
    }

    public Size () : int implements IMap.Size
    {
      this.size
    }

    public 'd Fold (func : 'd * 'a * 'b -> 'd, ini : 'd) : 'd implements IMap.Fold
    {
      def wrap (ctx : 'd, n : NodeSys ('a, 'b)) : 'd 
          {
            func (ctx, n.key, n.val)
          };
      Tree.Fold (this.root, wrap, ini)
    }

    public Iter (func : 'a * 'b -> void) : void implements IMap.Iter
    {
      def wrap (ctx : int, n : NodeSys ('a, 'b)) : int
          { 
            func (n.key, n.val); 
            ctx 
          };
      def _ = Tree.Fold (this.root, wrap, 0);
      ()
    }
    
    public ForAll (func : 'a * 'b -> bool) : bool implements IMap.ForAll
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.ForAll (this.root, wrap)
    }

    public Exists (func : 'a * 'b -> bool) : bool implements IMap.Exists
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          }; 
      Tree.Exists (this.root, wrap)
    }

    public Filter (func : 'a * 'b -> bool) : SystemMap ('a, 'b) implements IMap.Filter
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountFilter (this.root, wrap)) {
        (ytree, ycount) =>
          SystemMap (ycount, ytree) 
      }
    }

    public Partition (func : 'a * 'b -> bool) : SystemMap ('a, 'b) * SystemMap ('a, 'b) implements IMap.Partition
    {
      def wrap (keyval : NodeSys ('a, 'b)) : bool
          {
            func (keyval.key, keyval.val)
          };
      match (Tree.CountPartition (this.root, wrap)) {
        (ytree, ycount, ntree, ncount) =>
          (SystemMap (ycount, ytree), SystemMap (ncount, ntree)) 
      }
    }

  }

  /* End of Implementation of mapping using Red-Black Trees */
}
