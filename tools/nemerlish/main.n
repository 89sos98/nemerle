using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility.NString;
using SC = System.Console;
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions.Regex;
using Interp = Nemerle.Evaluation.Interpreter.Internals;
  
namespace Nemerle.Evaluation.Interpreter
{  
  module MainClass
  {
    public Main (args : array [string]) : void
    {
      HacksFramework.Run ();

      def profile = Path.Combine (Environment.GetFolderPath (Environment.
                    SpecialFolder.Personal), ".nemerlish_profile");

      def histfile = Path.Combine (Environment.GetFolderPath (Environment.
                     SpecialFolder.Personal), ".nemerlish_history"); 

      def print_welcome () : void {
        SC.WriteLine ("Welcome to Nemerle interpreter " +
                      $"(using ncc $(Interp.nccversion)).\n");
        SC.WriteLine ("Please enter expressions appended with \";;\".");
        SC.WriteLine ("Type \"Help;;\" for more info.\n");
      }
      print_welcome ();
  
      // Get for evaluation from a file.
      def fromfile (filename) {
        def sr = File.OpenText (filename);
        def loop (acc) {
          def l = sr.ReadLine ();
          if (l != null)
            if (acc == "")
              loop (l)
            else
              loop (acc + " " + l)
           else
             acc
        }

        def res = loop ("");
        sr.Close ();
        res
      } 

      // FIXME: Handle speacial situations
      def initialcode = if (args.Length == 2)
                          match ((args [0], args [1])) {
                            | ("-f", filename)
                            | (filename, "-f") => fromfile (filename)
                            | _ => "" 
                          }
                        else 
                          try {
                            fromfile (profile)
                          }
                          catch {
                            | _ is FileNotFoundException => ""
                            | _ => ""
                          }

      def e = Nemerle.Evaluation.Evaluator ();
      def printev (c) {
        try { 
          def (nmnvts) = e.Eval (Interp.RefParsed, 
                                 Interp.UsingParsed, c);
          Iter (nmnvts, fun (x) {
            def (newvar, mut, name, val, ty) = x;
            when (newvar) 
              match ((mut, val, ty)) {
                | (false, null, _) =>
                  SC.WriteLine ($"def $name : $ty")
                | (_, null, _) =>
                  SC.WriteLine ($"mutable $name : $ty")
                | (_, _, <[ $_ -> $_ ]>) =>
                  SC.WriteLine ($"def $name : $ty")
                | (false, _, _) => 
                  try {
                    SC.WriteLine ($"def $name = $val : $ty")
                  } 
                  catch {
                    | _ => 
                      SC.WriteLine ($"Warning: omitting the value of $name, "
                                    "because it contains null(s).");
                      SC.WriteLine ($"def $name : $ty")
                  }
                | _ => 
                  try {
                    SC.WriteLine ($"mutable $name = $val : $ty")
                  }
                  catch {
                    | _ => 
                      SC.WriteLine ($"Warning: omitting the value of $name, "
                                    "because it contains null(s).");
                      SC.WriteLine ($"mutable $name : $ty")
                  }
            }
          })
        } 
        catch {
          | e is Exception =>
            unless (Nemerle.Compiler.Message.SeenError) {
              SC.WriteLine (e.Message + e.StackTrace);
              SC.WriteLine (e.ToString ())
            }
        } 
      }

      def rl = NativeReadLine.GetInstance ();
      def usehist = HistoryFile.RecreateHistory (rl, histfile);

      def readinput (code, line) {
        def readandloop (c) {
          readinput (c, rl.ReadLine (Interp.Prompt))
        }

        match (line) {
          | null => ()
          | _ => 
            rl.AddHistory (line);
            when (usehist)
              HistoryFile.AddHistory (histfile, line);

            regexp match (line) {
              | @"^\s*$" => readandloop (code)
              | _ =>  { 
                def l = line.TrimEnd ();
                if (l.EndsWith (";;")) {
                  def m = code + l.TrimEnd (array [';',' ','\t']);
                  regexp match (m) {
                    | @"^[\s;]*$" => Interp.Prompt = Interp.PS1; readandloop ("")
                    | @"(?<beg>.*([;}]\s*|^\s*))using\s+(?<use>[a-zA-Z0-9]+((\.[a-zA-Z0-9]+)*(\s*=\s*[a-zA-Z0-9]+)*)*)[\s;]*(?<end>.*)$" => 
                      if (Interp.Using != "") 
                        Interp.Using = use + ", " + Interp.Using
                      else 
                        Interp.Using = use;
                      def c = beg + end;
                      regexp match (c) {
                        | @"[\s;]*" => Interp.Prompt = Interp.PS1; readandloop ("")
                        | _ => printev (c)
                      }
                    | @"^\s*!(?<input>.*)$" => 
                      def p = Diagnostics.Process ();
                      regexp match (input) {
                        | @"\s*" => 
                          if (Environment.GetEnvironmentVariable ("SHELL") != "")
                            p.StartInfo.FileName = "$SHELL"
                          else
                            p.StartInfo.FileName = "cmd.exe"
                        | _ => p.StartInfo.FileName = input
                      }
                      p.StartInfo.UseShellExecute = true;
                      _ = p.Start();    
                      p.WaitForExit()
                    | _ => printev (m)
                  }
                  Interp.Prompt = Interp.PS1;
                  readandloop ("")
                }
                else { 
                  Interp.Prompt = Interp.PS2;
                  readandloop (code + " " + line)
                }
              }
            }
        }
      }

      if (initialcode != "") {
        SC.WriteLine ("Please wait while evaluating the config file..");
        readinput (initialcode, ";;")
      } 
      else
        readinput ("", rl.ReadLine (Interp.Prompt))
    }
  }

  module HistoryFile {
    public AddHistory (filename: string, line : string) : void {
      try {
        def sw = File.AppendText (filename);
        sw.WriteLine (line);
        sw.Close ();
      } 
      catch {
        | e => SC.WriteLine (e.Message)
      }
    }

    public RecreateHistory (rl : IReadLine, filename : string) 
    : bool {
      try {
        def sr = File.OpenText (filename);
        def loop (i, prev) {
          def l = sr.ReadLine ();
          when (l != null) {
            when (l != prev) 
              rl.AddHistory (l);
            loop (i + 1, l)
          }
        }

        loop (0, "");
        sr.Close ();
        true
      } 
      catch {
        | _ is FileNotFoundException => _ = AddHistory (filename, ""); true
        | e => SC.WriteLine (e.Message); false
      }
    }
  }
} 
