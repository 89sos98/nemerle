/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Matching
 */
 
namespace Nemerle.Compiler 
{
  using Nemerle.Collections;

  using Nemerle.Compiler;
  using Nemerle.Compiler.CGexpr;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;

  using System.Reflection;
  using System.Reflection.Emit;

  module CGmatch 
  {
    cg_pattern (ctx : CTX, val : CG_expr, pats : list (Pattern * Expr)) : CG_expr * bool * CTX * list (CG_val)
    {
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;
      mutable always_matches <- true;
      
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_literal (L_bool (true))
          
          | P_as (subpat, d) =>
            if (d.in_closure) ()
            else
              match (vals.find (d.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, CE_none ());
                  rctx <- ctx;
                  vals <- vals.add (d.id, v);
              };
            def ass = CE_assign (local_ref (rctx, d), maybe_cast (ctx, cg_type (ctx, d.ty), val));
            match (subpat) {
              | P_cons =>
                match (cgpat (val, subpat)) {
                  | (CE_if (c, e_then, e_else)) as e =>
                    CE_if (e.ty, c, CE_sequence ([ass; e_then]), e_else)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([ass; cgpat (val, subpat)])
            }
            
          | P_tuple (args) =>
            def len = List.length (args);
            def f (acc, arg)
              {
                def (pos, ex) = acc;
                def cond = cgpat (tuple_ref (CE_cast (val, tuple_type (len)), pos, len), arg);
                (pos - 1, CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false))))
              };
            def ini = (len, CE_literal (L_bool (true)));
            def (_, ex) = List.fold_left (f, ini, List.rev (args));
            ex

          | P_literal (lit) =>
            def litexpr = CE_literal (lit);
            CE_call (typeof (System.Boolean), 
                    CE_opcode ("=="), 
                    [CE_cast (val, type_of (litexpr)); litexpr])
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (ctx, pat.ty));
            def f (ex, np) {
              def (name, pat) = np;
              def cond = cgpat (CE_field_ref (val, (name : IField).GetFieldInfo ()), pat);
              CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false)))
            };
            List.fold_left (f, CE_literal (L_bool (true)), List.rev (args))
          
          | P_cons (n, a) =>
            always_matches <- false;
            def tyname = n.GetSystemType ();
            def ex = CE_has_type (val, tyname);
            CE_if (typeof (System.Boolean), ex, 
                    cgpat (CE_cast (val, tyname), a), 
                    CE_literal (L_bool (false)))
        }
      };

      mutable global_always_matches <- false;

      def loop (pats) {
        match (pats) {
          | (pat, expr) :: rest =>
            always_matches <- true;
            def cond = cgpat (val, pat);
            def cond =
              match (expr) {
                | E_literal (L_bool (true)) => cond
                | _ =>
                  always_matches <- false;
                  CE_if (typeof (System.Boolean), cond, cg_expr (rctx, expr), CE_literal (L_bool (false)))
              };
            global_always_matches <- global_always_matches || always_matches;
            CE_if (typeof (System.Boolean), cond, CE_literal (L_bool (true)), loop (rest))
          | [] =>
            CE_literal (L_bool (false))
        }
      };

      def r = loop (pats);
      def collect_vals (acc : list (CG_val), _ : int, v : CG_val) : list (CG_val) { v :: acc };
      (r, global_always_matches, rctx, vals.fold (collect_vals, []))
    }

    
    /**
     * Matching over arbitrary types
     */
    cg_match_over_any_type (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr 
    {
      match (mcs) {
        | [] =>
          // FIXME: cache it
          def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.Match_failure");
          def match_failure = get_default_ctor (ctx, tc);
          CE_raise (CE_call (CE_ctor_ref (match_failure), []))

        | m :: ms =>
          // FIXME: do something with always_matches
          def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
          def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) };
          def then_part = cg_expr (ctx', m.body);
          def else_part = cg_match (t, ctx, val, ms);
          List.fold_left (mklet, CE_if (t, cond, then_part, else_part), vals)
      }
    }


    /**
     * Matching over booleans.
     */
    cg_match_over_booleans (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
    {
      def type_of_bool = typeof(System.Boolean); // FIXME: how to reflect types here?
      
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;

      mutable true_handled <- false;
      mutable false_handled <- false;
      mutable last_pattern_always_matches <- false;

      def is_always_true (expr : Expr) : bool {
        match (expr) {
          | E_literal (L_bool (true)) => true
          | _ => false
        }    
      };

      def make_cond (patterns : list (Pattern * Expr)) : CG_expr {
        match (patterns) {        
          | (P_underscore, when_expr) :: _ when is_always_true (when_expr) =>
            last_pattern_always_matches <- true;          
            CE_literal (L_bool (true))
        
          | (P_underscore, when_expr) :: rest =>
            CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))

          | (P_literal (L_bool (literal)), when_expr) :: rest when is_always_true (when_expr) =>
            def literal_already_handled = if (literal) true_handled else false_handled;          
            when (literal_already_handled) Message.warning ("unreachable pattern in matching");
            
            if (literal) true_handled <- true else false_handled <- true;
                      
            if (true_handled && false_handled) {
              last_pattern_always_matches <- true;          
              CE_literal (L_bool (true))
            }
            else {
              def literal_eq_expr =
                CE_call (type_of_bool, CE_opcode ("=="), 
                        [val; CE_literal (L_bool (literal))]);

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), make_cond (rest))
            }

          | (P_literal (L_bool (literal)), when_expr) :: rest =>
            def literal_already_handled = if (literal) true_handled else false_handled;          
            when (literal_already_handled) Message.warning ("unreachable pattern in matching");

            def opposite_handled = if (literal) false_handled else true_handled;

            if (opposite_handled) {
              CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))          
            }
            else {
              def literal_eq_expr =
                CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                        [val; CE_literal (L_bool (literal))]);

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), 
                CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), 
                  make_cond (rest)))
            }

          | (P_as (subpat, decl), _) :: rest =>
            if (decl.in_closure) ()
            else
              match (vals.find (decl.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, decl, CE_none ());
                  rctx <- ctx;
                  vals <- vals.add (decl.id, v);
              };
            def assign_expr = 
              CE_assign (local_ref (rctx, decl), maybe_cast (rctx, cg_type (ctx, decl.ty), val));
            match (subpat) {
              | P_cons =>
                match (make_cond (rest)) {
                  | CE_if (cond_expr, then_expr, else_expr) =>
                    CE_if (type_of_bool, cond_expr, CE_sequence ([assign_expr; then_expr]), else_expr)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([assign_expr; make_cond (rest)])
            }

          | [] => CE_literal (L_bool (false))

          | (P_tuple, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_tuple")
          | (P_record, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_record")
          | (P_cons, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_cons")

          | _ :: _ => 
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
        }      
      };

      def walk_match_cases (mcs : list (Match_case)) : CG_expr {
        match (mcs) {
          | [] =>
            def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.Match_failure");
            def match_failure = get_default_ctor (rctx, tc);
            CE_raise (CE_call (CE_ctor_ref (match_failure), []))

          | mc :: rest =>
            def cond = make_cond (mc.patterns);
            def body = cg_expr (rctx, mc.body);
            
            if (true_handled && false_handled || last_pattern_always_matches) {
              when (List.length (rest) > 0) Message.warning ("unreachable match cases");
              body
            }
            else
              CE_if (cond, body, walk_match_cases (rest))
        }
      };

      /* handle the special cases for the if/when/unless macros */
      match (mcs) {
        | [then_case; else_case] =>
          match ((then_case.patterns, else_case.patterns)) {
            | ([(P_literal (L_bool (literal)), then_case_when_expr)], [(P_underscore, else_case_when_expr)]) 
                when is_always_true (then_case_when_expr) && is_always_true (else_case_when_expr) =>
                
              def literal_eq_expr =
                CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                        [val; CE_literal (L_bool (literal))]);

              CE_if (t, literal_eq_expr, cg_expr (ctx, then_case.body), cg_expr (ctx, else_case.body))         
            | _ => walk_match_cases (mcs)
          }
        | _ => walk_match_cases (mcs)
      }
    }


    /**
     * Matching
     */
    internal cg_match (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
    {
      def type_of_val = type_of (val);
          
      if (type_of_val.FullName == "System.Boolean") cg_match_over_booleans (t, ctx, val, mcs)
      else cg_match_over_any_type (t, ctx, val, mcs)
    }
    
  } // end of the module

} // end of the namespace
