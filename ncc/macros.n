(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Macros {

  (** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => <[ [] ]>
        | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
      }
    }

  (** create syntax tree for constructing given string and int *)
  quoted_string (st : string) : Expr
    { E_literal (L_string (st)); }

  quoted_int (i : int) : Expr
    { E_literal (L_int (i)) }

  (** tree of string literal, describing constant of given bool value *)
  quoted_bool (va : bool) : Expr
    { E_literal (L_bool (va)) }

  quoted_literal (lit : Literal) : Expr
    {
      match (lit) {
        | L_void => <[ Nemerle.Compiler.L_void ]>

    	| L_null => <[ Nemerle.Compiler.L_null ]>

    	| L_int (val) =>
          <[ Nemerle.Compiler.L_int ($(quoted_int (val))) ]>

    	| L_string (val) =>
          <[ Nemerle.Compiler.L_string ($(quoted_string (val))) ]>

    	| L_float (val) =>
	  <[ Nemerle.Compiler.L_float ($(E_literal (L_float (val)))) ]>

    	| L_char (val) =>
	  <[ Nemerle.Compiler.L_char ($(E_literal (L_char (val)))) ]>

    	| L_bool (val) =>
  	  <[ Nemerle.Compiler.L_bool ($(quoted_bool (val))) ]>
      }	
    }

  quoted_location (loc : Location) : Expr
    {
      <[ Nemerle.Compiler.Location ($(quoted_string (loc.file)), 
                                    $(quoted_int (loc.line)),
 	                            $(quoted_int (loc.column))) ]>
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  quoted_type (t : Type) : Expr
  {
    match (t) {
      | T_app (tycon, args) =>
        <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_string (tycon)), 
                                             $(make_quoted_list (quoted_type, args))) ]>

      | T_var (name) => 
        <[ Nemerle.Compiler.Parsetree.T_var ($(quoted_string (name))) ]>
        
      | T_ref (ty) =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ty))) ]>
	
      | T_out (ty) =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ty))) ]>
	
      | T_fun (from, to) =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (from)), 
                                             $(quoted_type (to))) ]>
	
      | T_void =>
        <[ Nemerle.Compiler.Parsetree.T_void ]>
	
      | T_prod (args) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quoted_type, args))) ]>
    }	
  }

  quoted_expr (expr : Expr) : Expr 
    {
      def quoted_funheader ( h : Fun_header ) : Expr
        {
          def quoted_param (p : Fun_parm) : Expr
            {
    	      <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_location (p.loc)),
                                                      $(quoted_string (p.name)),
	                                              $(quoted_type (p.ty))) ]>
  	    }
    
          <[ Nemerle.Compiler.Parsetree.Fun_header ($(quoted_location (h.loc)),
                                                    $(quoted_string (h.name)),
	    	      				    $(quoted_type (h.ret_type)),
  		      				    $(make_quoted_list (quoted_param, h.parms))) ]>
        }
    
      def quoted_fundecl (d : Function_decl) : Expr
        {
  	  <[ Nemerle.Compiler.Parsetree.Function_decl ($(quoted_funheader (d.header)),
 	                                               $(quoted_expr (d.body))) ]>
	}

      match (expr) {
        | E_ref (id) =>
	  <[ Nemerle.Compiler.Parsetree.E_ref ($(quoted_string (id))) ]>

	| E_member (obj, member) =>
          <[ Nemerle.Compiler.Parsetree.E_member ($(quoted_expr (obj)), 
                                                  $(quoted_string (member))) ]>
	  
	| E_call (func, params) =>
	  // create construction tree of given call parameter
	  def quoted_param (p : Parm) : Expr
	    {
              <[ Nemerle.Compiler.Parsetree.Parm ($(quoted_bool (p.is_ref)), 
                                                  $(quoted_expr (p.expr)), 
                                                  $(quoted_string (p.name))) ]>
	    }
	
          <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)), 
                                                $(make_quoted_list (quoted_param, params))) ]>

	| E_assign (target, source) =>
          <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (target)), 
                                                  $(quoted_expr (source))) ]>

	| E_let (is_ref, name, val) =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(quoted_bool (is_ref)), 
                                               $(quoted_string (name)), 
                                               $(quoted_expr (val))) ]>

	| E_letpat (pat, val) =>
	  <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (pat)), 
                                                  $(quoted_expr (val))) ]>

	| E_letfun (funs) =>
	  <[ Nemerle.Compiler.Parsetree.E_letfun ($(make_quoted_list (quoted_fundecl, funs))) ]>

	| E_lambda (decl) =>
	  <[ Nemerle.Compiler.Parsetree.E_lambda ($(quoted_fundecl (decl))) ]>

	| E_match (expr, cases) =>
	  def quoted_case (cas : Match_case) : Expr
	    {
	      <[ Nemerle.Compiler.Parsetree.Match_case ($(quoted_location (cas.loc)), 
                                                        $(quoted_pattern (cas.pattern)),
                               	                        $(quoted_expr (cas.body))) ]>
	    }
	
    	  <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                                                 $(make_quoted_list (quoted_case, cases))) ]>

	| E_raise (exc) =>
	  <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (exc))) ]>

	| E_if (cond, e_then, e_else) =>
	  def re = <[ Nemerle.Compiler.Parsetree.E_if ($(quoted_expr (cond)), 
                                              $(quoted_expr (e_then)), 
                                              $(quoted_expr (e_else))) ]>;
          print_tree (re, "");
          re

	| E_try_with (body, exn, exn_ty, handler) => 
	  <[ Nemerle.Compiler.Parsetree.E_try_with ($(quoted_expr (body)), 
                                                    $(quoted_string (exn)),
                                                    $(quoted_type (exn_ty)), 
                                                    $(quoted_expr (handler))) ]>

	| E_try_finally (body, handler) =>
	  <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (body)), 
                                                       $(quoted_expr (handler))) ]>

        | E_require (assertions) =>
	  <[ Nemerle.Compiler.Parsetree.E_require ($(quoted_expr (assertions))) ]>
	  
        | E_ensure (assertions) =>
	  <[ Nemerle.Compiler.Parsetree.E_ensure ($(quoted_expr (assertions))) ]>

	| E_literal (l) => 
	  <[ Nemerle.Compiler.Parsetree.E_literal ($(quoted_literal (l))) ]>

	| E_this =>
	  <[ Nemerle.Compiler.Parsetree.E_this ]>

	| E_type_conversion (expr, ty) =>
          <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (expr)),
	                                                   $(quoted_type (ty))) ]>

	| E_type_enforcement (expr, ty) =>
	  <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (expr)),
	                                                    $(quoted_type (ty))) ]>

	| E_sequence (seq) =>
	  <[ Nemerle.Compiler.Parsetree.E_sequence ($(make_quoted_list (quoted_expr, seq))) ]>

	| E_tuple (args) =>
	  <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quoted_expr, args))) ]>

	| E_quoted (e) => 
	  Message.error ("compound of several <[ ... ]> macro scopes is not allowed");
	  e
	| E_unquoted (e) => e

    	| E_list (args) =>
	  // we lift up generated list, because it was designed to be spliced not returned
	  // and it's being evaluated by typechecker
 	  quoted_expr (make_quoted_list (quoted_expr, args))

    	| E_list_cons (hd, tl) =>
	  // here we first compute what compiler should have given us in form of 
          // Cons constructor and then lift it up
          quoted_expr (<[ $(hd) :: $(tl) ]>)

    	| E_array (args) =>
	  <[ E_array ($(make_quoted_list (quoted_expr, args))) ]>
	  
    	| E_indexer (obj, args) =>
	  <[ E_indexer ($(quoted_expr (obj)), $(make_quoted_list (quoted_expr, args))) ]>
      };
    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction 
      tree 
   *)	  
  quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | P_underscore => <[ Nemerle.Compiler.Parsetree.P_underscore ]>

        | P_variable (name) => 
          <[ Nemerle.Compiler.Parsetree.P_variable ($(quoted_string (name))) ]>

        | P_tuple (args) =>
          <[ Nemerle.Compiler.Parsetree.P_tuple ($(make_quoted_list (quoted_pattern, args))) ]>
          
        | P_record (args) => 
          def quoted_named_pattern (patt : Named_pattern) : Expr
            {
              <[ Nemerle.Compiler.Parsetree.Named_pattern ($(quoted_string (patt.name)),
 	                                                   $(quoted_pattern (patt.pat))) ]>
            }
             
           <[ Nemerle.Compiler.Parsetree.
              P_record ($(make_quoted_list (quoted_named_pattern, args))) ]>

        | P_cons (name, arg) =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_string (name)),
                                                $(quoted_pattern (arg))) ]>

        | P_literal (lit) =>
  	  <[ Nemerle.Compiler.Parsetree.P_literal ($(quoted_literal (lit))) ]>

        | P_quoted_expr (e) =>
          Message.error ("compound of several <[ ... ]> macro scopes is not allowed");
          e
(*
        | P_list (args) =>
	  // we lift up generated list, because it was designed to be spliced not returned
	  // and it's being evaluated by typechecker
 	  quoted_expr (make_quoted_list (quoted_pattern, args))

        | P_list_cons (hd, tl) =>
	  // here we first compute what compiler should have given us in form of 
          // Cons constructor and then lift it up
          quoted_expr (<[ $(hd) :: $(tl) ]>)
*)
      } 
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  expr_to_pattern (exp : Expr) : Pattern 
    {
      def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
        match (pars) {
          | [] => 
            match (acc) {
	      | [] => P_underscore ()
	      | _ => P_tuple (List.rev (acc))
            }
          | x::xs => convert_params (xs, expr_to_pattern (x.expr) :: acc)
        }
      }

      def a = match (exp) {
        | E_ref (id) => P_cons (id, P_underscore ())
        | E_call (E_ref ("Nemerle.Compiler.Parsetree.Parm"), 
                  [{ expr = is_ref }; { expr = constr }; { expr = name  }]) => 
          P_record ([Named_pattern ("is_ref", expr_to_pattern (is_ref));
                     Named_pattern ("expr", expr_to_pattern (constr));
                     Named_pattern ("name", expr_to_pattern (name))])
        | E_call (E_ref (constr), params) => 
          P_cons (constr, convert_params (params, []))
        | E_literal (lit) => P_literal (lit)
        | _ => 
          Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
      };

      print_pattern (a, "");
      a
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  print_tree (exp : Expr, empty : string) : void
    {
      def convert_params (pars : list (Parm)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_tree (x.expr, empty + "  "); convert_params (xs )
        }
      }

      print_string (empty);

      def print_literal (lit : Literal ) : void
        {
	  match (lit) {
	    | L_string (s) => print_string (s)
            | L_int (i) => print_string (string_of_int (i))
	    | _ => print_string ("some literal")
          }
        }

      match (exp) {
        | E_ref (id) => print_string ("E_ref ("); print_string (id); print_endline (")")
        | E_call (E_ref (constr), params) => 
          print_string ("E_call (E_ref ("); print_string (constr); print_endline ("),");
          convert_params (params);
          print_string (empty);
	  print_endline (")")
        | E_literal (lit) => print_string ("E_literal ("); print_literal (lit); print_endline (")")
	| E_list (args) =>           
	  def pr (e : Expr ) : void { print_tree (e, empty); }
	  print_endline ("Bad constructed quoted expression in print - list ");
	  def _ = List.map (pr, args);
	  ()
	| E_list_cons _ =>           
	  print_endline ("Bad constructed quoted expression in print - list_cons ")
	| E_sequence (seq) =>
	  print_endline ("Bad constructed quoted expression in print - sequ ")

	| E_tuple (args) =>
	  print_endline ("Bad constructed quoted expression in print - tuple ")
        | _ => 
	   print_endline ("other")
      }
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  print_pattern (pat : Pattern, empty : string) : void
    {
      def convert_params (pars : list (Pattern)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_pattern (x, empty + "  "); convert_params (xs)
        }
      }

      def print_args (args : list (Named_pattern)) : void {
	match (args) {
	  | [] => ()
	  | x::xs => print_string (empty + "  "); print_string (x.name); print_endline(" = "); 
                     print_pattern (x.pat, empty + "    "); print_args (xs)
 	}  
      }

      print_string (empty);

      match (pat) {
        | P_cons (id, arg) => print_string ("P_cons ("); print_string (id); print_endline (",");
                              print_pattern (arg, empty + "  "); print_string (empty); print_endline (")")
        | P_underscore => print_endline ("P_under")
        | P_record (args) => 
	   print_endline ("P_record (");
	   print_args (args); print_string (empty); print_endline (")")
        | P_tuple (args) => print_endline ("P_tuple ("); convert_params (args); 
            print_string (empty); print_endline (")")
        | _ => 
	   print_endline ("other")
      }
    }
  
}
} // end ns
