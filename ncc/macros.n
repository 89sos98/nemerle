(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Macros {

  (** create tree, which constructs variant of given name with
      given list of parameters 
   *) 
  make_call (head : string, exprs : list (Expr)) : Expr
    {
      def encaps_parm (e : Expr) : Parm
        { Parm (e); }
	
      E_call (E_ref ("Nemerle.Compiler.Parsetree." + head),
              List.map (encaps_parm, exprs))
    }
    
  (** create tree, which constructs list of given elements *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => E_ref ("Nemerle.Collections.Nil")
        | x::xs => E_call (E_ref ("Nemerle.Collections.Cons"), 
                           [Parm (f (x)); Parm (make_quoted_list (f, xs))])
      }
    }

  (** create syntax tree for constructing given string *)
  quoted_string (st : string) : Expr
    { E_literal (L_string (st)); }

  quoted_int (i : int) : Expr
    { E_literal (L_int (i)) }

  (** tree of string literal, describing constant of given bool value *)
  quoted_bool (va : bool) : Expr
    {
      if (va) quoted_string ("true")
      else quoted_string ("false");
    }

  quoted_location (loc : Location) : Expr
    {
      E_call (E_ref ("Nemerle.Compiler.Location"), 
              [Parm (quoted_string (loc.file)); Parm (quoted_int (loc.line));
	       Parm (quoted_int (loc.column))])
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  quoted_type (t : Type) : Expr
  {
    match (t) {
      | T_app (tycon, args) =>
        make_call ("T_app", [quoted_string (tycon); 
                             make_quoted_list (quoted_type, args)])

      | T_var (name) => 
        make_call ("T_var", [quoted_string (name)])
        
      | T_ref (ty) =>
        make_call ("T_ref", [quoted_type (ty)])
	
      | T_out (ty) =>
        make_call ("T_ref", [quoted_type (ty)])
	
      | T_fun (from, to) =>
        make_call ("T_fun", [quoted_type (from); quoted_type (to)])
	
      | T_void =>
        E_ref ("Nemerle.Compiler.Parsetree.T_void")
	
      | T_prod (args) =>
        make_call ("T_prod", [make_quoted_list (quoted_type, args)])
    }	
  }

  quoted_expr (expr : Expr) : Expr 
    {
      def quoted_funheader ( h : Fun_header ) : Expr
        {
          def quoted_param (p : Fun_parm) : Expr
            {
    	      make_call ("Fun_parm", 
	                 [quoted_location (p.loc); quoted_string (p.name);
	                  quoted_type (p.ty)])
  	    }
    
          make_call ("Fun_header", 
                     [quoted_location (h.loc); quoted_string (h.name);
	    	      quoted_type (h.ret_type); 
  		      make_quoted_list (quoted_param, h.parms)])
        }
    
      def quoted_fundecl (d : Function_decl) : Expr
        {
  	  make_call ("Function_decl",
	             [quoted_funheader (d.header); quoted_expr (d.body)])
	}
    
      match (expr) {
        | E_ref (id) =>
	  make_call ("E_ref", [quoted_string (id)])

	| E_member (obj, member) =>
	  make_call ("E_member", [quoted_expr (obj); quoted_string (member)])
	  
	| E_call (func, params) =>
	  // create construction tree of given call parameter
	  def quoted_param (p : Parm) : Expr
	    {
	      make_call ("Parm", [quoted_bool (p.is_ref); quoted_expr (p.expr);
	                          quoted_string (p.name)])    
	    }
		
          def transform_params (li : list (Parm), acc : list (Expr)) : list (Expr)
            {
              match (li) {
                | Nil => List.rev (acc)
                | Cons (p, xs) => 
		  transform_params (xs, Cons (quoted_param (p), acc))
              }
            }
          def tparams = transform_params (params, []);
	  make_call ("E_call", 
	             [quoted_expr (func); make_quoted_list (quoted_expr, tparams)])

	| E_assign (target, source) =>
	  make_call ("E_assign", [quoted_expr (target); quoted_expr (source)])

	| E_let (is_ref, name, val) =>
	  make_call ("E_let", [quoted_bool (is_ref); quoted_string (name);
                               quoted_expr (val)])

	| E_letpat (pat, val) =>
          make_call ("E_letpat", [quoted_pattern (pat); quoted_expr (val)])

	| E_letfun (funs) =>
	  make_call ("E_letfun", [make_quoted_list (quoted_fundecl, funs)])

	| E_lambda (decl) =>
	  make_call ("E_lambda", [quoted_fundecl (decl)])

//	| E_match

	| E_raise (exc) =>
	  make_call ("E_raise", [quoted_expr (exc)])

	| E_if (cond, e_then, e_else) =>
	  make_call ("E_if", [quoted_expr (cond); quoted_expr (e_then);
                              quoted_expr (e_else)])

//	| E_try_with

//	| E_try_finally

//      | E_require

//      | E_ensure

	| E_literal (_) => expr

	| E_this =>
	  E_ref ("E_this")

//	| E_type_conversion

//	| E_type_enforcement

	| E_sequence (seq) =>
	  make_call ("E_sequence", [make_quoted_list (quoted_expr, seq)])

	| E_tuple (args) =>
	  make_call ("E_tuple", [make_quoted_list (quoted_expr, args)])

	| E_quoted (e) => 
	  Message.error ("compound of several <[ ... ]> macro scopes is not allowed");
	  e
	| E_unquoted (e) => e
      }
    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction 
      tree 
   *)	  
  quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | P_underscore => E_ref ("P_underscore")

        | P_variable (name) => 
          make_call ("P_variable", [quoted_string (name)])

        | P_tuple (args) =>
          make_call ("P_tuple", [make_quoted_list (quoted_pattern, args)])
          
        | P_record (args) => 
          def quoted_named_pattern (patt : Named_pattern) : Expr
            {
              make_call ("Named_pattern", 
         		     [quoted_string (patt.name); quoted_pattern (patt.pat)])
            }
             
           make_call("P_record", [make_quoted_list (quoted_named_pattern, args)])

        | P_cons (name, arg) =>
            make_call ("P_cons", [quoted_string (name); quoted_pattern (arg)])

        | P_quoted_expr (e) =>
          Message.error ("compound of several <[ ... ]> macro scopes is not allowed");
          e

        | P_list (args) =>
          make_call ("P_list", [make_quoted_list (quoted_pattern, args)])

        | P_list_cons (hd, tl) =>
          make_call ("P_list_cons", [quoted_pattern (hd); quoted_pattern (tl)])
      } 
    }
    
    expr_to_pattern (exp : Expr) : Pattern 
      {
        def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
          match (pars) {
            | Nil => P_tuple (acc)
            | Cons (x, xs) => convert_params (xs, Cons (expr_to_pattern (x.expr), acc))
          }
        }

        match (exp) {
          | E_ref (id) => P_variable (id)
          | E_call (E_ref (constr), params) => 
            P_cons (constr, convert_params (params, []))
          | _ => 
            Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
        }
      }
    
}
} // end ns
