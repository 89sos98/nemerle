//
// NemerleCodeGenerator.cs
//
// Author:
//	Atsushi Enomoto <atsushi@ximian.com>
//
// This derived part of the source code is published as public domain.
//
// Original: CSharpCodeGenerator.cs
//
// Original Author:
//   Daniel Stodden (stodden@in.tum.de)
//
// (C) 2002 Ximian, Inc.
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;
using System.Collections;

namespace Nemerle.Contrib
{
	public class NemerleCodeGenerator : CodeGenerator
	{
        bool dont_write_semicolon = false;

        public NemerleCodeGenerator ()
		{
		}

		protected override string NullToken {
			get {
				return "null";
			}
		}

		// FIXME: Any way to create typed array?
		protected override void GenerateArrayCreateExpression ( CodeArrayCreateExpression expression)
		{
			TextWriter output = Output;

			output.Write( "array " );

			CodeExpressionCollection initializers = expression.Initializers;
			CodeTypeReference createType = expression.CreateType;

			if (initializers.Count > 0) {
				output.WriteLine ("[");
				++Indent;
				OutputExpressionList ( initializers, true );
				--Indent;
				output.Write ("]");

//				output.WriteLine ("<");
//				OutputType (createType);
//				output.WriteLine (">");
			} else {
				CodeTypeReference arrayType = createType.ArrayElementType;
				while ( arrayType != null ) {
					createType = arrayType;
					arrayType = arrayType.ArrayElementType;
				}

				output.Write( '(' );

				CodeExpression size = expression.SizeExpression;
				if ( size != null )
					GenerateExpression( size );
				else
					output.Write( expression.Size );

				output.Write( ')' );

//				output.WriteLine ("<");
//				OutputType (createType);
//				output.WriteLine (">");
			}
			output.WriteLine ();
		}
		
		protected override void GenerateBaseReferenceExpression ( CodeBaseReferenceExpression expression)
		{
			Output.Write ("base");
		}
		
		protected override void GenerateCastExpression ( CodeCastExpression expression)
		{
			TextWriter output = Output;
			output.Write( "(" );
			GenerateExpression( expression.Expression );
			output.Write( " :> " );
			OutputType( expression.TargetType );
			output.Write( ")" );
		}


		protected override void GenerateCompileUnitStart ( CodeCompileUnit compileUnit)
		{
			GenerateComment( new CodeComment( "------------------------------------------------------------------------------" ) );
			GenerateComment( new CodeComment( " <autogenerated>" ) );
			GenerateComment( new CodeComment( "     This code was generated by a tool." ) );
			GenerateComment( new CodeComment( "     Runtime Version: " +  System.Environment.Version ) );
			GenerateComment( new CodeComment( "" ) );
			GenerateComment( new CodeComment( "     Changes to this file may cause incorrect behavior and will be lost if " ) );
			GenerateComment( new CodeComment( "     the code is regenerated." ) );
			GenerateComment( new CodeComment( " </autogenerated>" ) );
			GenerateComment( new CodeComment( "------------------------------------------------------------------------------" ) );
			Output.WriteLine();
		}

		protected override void GenerateDelegateCreateExpression (
			CodeDelegateCreateExpression expression)
		{
			TextWriter output = Output;

            /// we don't need to explicitly create delegate
            /// OutputType(expression.DelegateType);
            /// output.Write( '(' );

            CodeExpression targetObject = expression.TargetObject;
			if ( targetObject != null ) {
				GenerateExpression( targetObject );
				Output.Write( '.' );
			}
			output.Write( GetSafeName (expression.MethodName) );
//			output.Write( ')' );
		}

		protected override void GenerateFieldReferenceExpression (
			CodeFieldReferenceExpression expression)
		{
			CodeExpression targetObject = expression.TargetObject;
			if (targetObject != null) {
				GenerateExpression (targetObject);
				Output.Write ('.');
			}
			Output.Write (GetSafeName (expression.FieldName));
		}
		
		protected override void GenerateArgumentReferenceExpression (
			CodeArgumentReferenceExpression expression)
		{
			Output.Write (GetSafeName (expression.ParameterName));
		}

		protected override void GenerateVariableReferenceExpression (
			CodeVariableReferenceExpression expression)
		{
			Output.Write (GetSafeName (expression.VariableName));
		}
			
		protected override void GenerateIndexerExpression (
			CodeIndexerExpression expression)
		{
			TextWriter output = Output;

			GenerateExpression (expression.TargetObject);
			output.Write ( '[' );
			OutputExpressionList( expression.Indices );
			output.Write( ']' );
		}
		
		protected override void GenerateArrayIndexerExpression (
			CodeArrayIndexerExpression expression)
		{
			TextWriter output = Output;

			GenerateExpression (expression.TargetObject);
			output.Write ('[');
			OutputExpressionList (expression.Indices);
			output.Write (']');
		}
		
		protected override void GenerateSnippetExpression (
			CodeSnippetExpression expression)
		{
			Output.Write (expression.Value);
		}
		
		protected override void GenerateMethodInvokeExpression (
			CodeMethodInvokeExpression expression)
		{
			TextWriter output = Output;

			GenerateMethodReferenceExpression (expression.Method);

			output.Write ('(');
			OutputExpressionList (expression.Parameters);
			output.Write (')');
		}

		protected override void GenerateMethodReferenceExpression (
			CodeMethodReferenceExpression expression )
		{
			if (expression.TargetObject != null)
			{
				GenerateExpression (expression.TargetObject);
				Output.Write ('.');
			};
			Output.Write (GetSafeName (expression.MethodName));
		}

		protected override void GenerateEventReferenceExpression (
			CodeEventReferenceExpression expression )
		{
			GenerateExpression (expression.TargetObject);
			Output.Write ('.');
			Output.Write (GetSafeName (expression.EventName));
		}

		protected override void GenerateDelegateInvokeExpression (
			CodeDelegateInvokeExpression expression )
		{
			GenerateExpression (expression.TargetObject);
			Output.Write ('(');
			OutputExpressionList (expression.Parameters);
			Output.Write (')');
		}
		
		protected override void GenerateObjectCreateExpression (
			CodeObjectCreateExpression expression )
		{
			OutputType (expression.CreateType);
			Output.Write ('(');
			OutputExpressionList (expression.Parameters);
			Output.Write (')');
		}

		protected override void GeneratePropertyReferenceExpression (
			CodePropertyReferenceExpression expression )
		{
			CodeExpression targetObject = expression.TargetObject;
			if (targetObject != null) {
				GenerateExpression (targetObject);
				Output.Write ('.');
			}
			Output.Write (GetSafeName (expression.PropertyName));
		}

		protected override void GeneratePropertySetValueReferenceExpression (
			CodePropertySetValueReferenceExpression expression)
		{
			Output.Write ( "value" );
		}

		protected override void GenerateThisReferenceExpression (
			CodeThisReferenceExpression expression)
		{
			Output.Write ("this");
		}

		// FIXME: Is it allowed? It looks likely to be confused with
		// CodeMethodReturnStatement...
		protected override void GenerateExpressionStatement (
			CodeExpressionStatement statement)
		{
			GenerateExpression (statement.Expression);
            if (dont_write_semicolon)
				return;
			Output.WriteLine (';');
		}

		protected override void GenerateIterationStatement ( CodeIterationStatement statement)
		{
			TextWriter output = Output;

			output.Write( "for (" );
            dont_write_semicolon = true;
            GenerateStatement( statement.InitStatement );
			output.Write( "; " );
			GenerateExpression( statement.TestExpression );
			output.Write( "; " );
			GenerateStatement( statement.IncrementStatement );
			output.Write( ") " );
            dont_write_semicolon = false;
            output.WriteLine('{');
            ++Indent;
            GenerateStatements(statement.Statements);
            --Indent;
            output.WriteLine('}');
		}

		protected override void GenerateThrowExceptionStatement ( CodeThrowExceptionStatement statement)
		{
			Output.Write ("throw");
			if (statement.ToThrow != null) {
				Output.Write (' ');
				GenerateExpression (statement.ToThrow);
			}
            if (dont_write_semicolon)
				return;
			Output.WriteLine (";");
		}

		protected override void GenerateComment (CodeComment comment)
		{
			TextWriter output = Output;
			string [] lines = comment.Text.Split ('\n');
			bool first = true;
			foreach (string line in lines) {
				if ( comment.DocComment )
					output.Write ("///");
				else
					output.Write ("//");
				if (first) {
					output.Write (' ');
					first = false;
				}
				output.WriteLine (line);
    			}
		}

		// FIXME: How should I represent return statement?
		protected override void GenerateMethodReturnStatement ( 
			CodeMethodReturnStatement statement)
		{
			TextWriter output = Output;

			if (statement.Expression != null)
				GenerateExpression (statement.Expression);
            if (dont_write_semicolon)
				return;
			output.WriteLine (";");
		}

		protected override void GenerateConditionStatement (
			CodeConditionStatement statement)
		{
			TextWriter output = Output;

			CodeStatementCollection falses = statement.FalseStatements;

			if (falses.Count > 0)
				output.Write( "if (" );
			else
				output.Write( "when (" );

			GenerateExpression (statement.Condition);

			output.WriteLine( ") {" );
			++Indent;
			GenerateStatements (statement.TrueStatements);
			--Indent;

			if (falses.Count > 0) {
				output.Write ('}');
				if (Options.ElseOnClosing)
					output.Write(' ');
				else
					output.WriteLine ();
				output.WriteLine ("else {");
				++Indent;
				GenerateStatements (falses);
				--Indent;
			}
			output.WriteLine( '}' );
		}

		protected override void GenerateTryCatchFinallyStatement ( 
			CodeTryCatchFinallyStatement statement)
		{
			TextWriter output = Output;
			CodeGeneratorOptions options = Options;

			output.WriteLine ("try {");
			++Indent;
			GenerateStatements (statement.TryStatements);
			--Indent;
			output.Write ('}');

			if (statement.CatchClauses.Count > 0) {
				output.WriteLine ( " catch {" );
                ++Indent;
				foreach (CodeCatchClause clause in statement.CatchClauses) {
					output.Write ("| ");
					OutputTypeNamePair (clause.CatchExceptionType, GetSafeName (clause.LocalName));
					output.WriteLine (" =>");
					++Indent;
					GenerateStatements (clause.Statements);
					--Indent;
				}
                --Indent;
                output.Write("}");
            }

			CodeStatementCollection finallies = statement.FinallyStatements;
			if ( finallies.Count > 0 ) {
				if ( options.ElseOnClosing )
					output.Write( ' ' );
				else
					output.WriteLine();
				output.WriteLine( "finally {" );
				++Indent;
				GenerateStatements( finallies );
				--Indent;
				output.WriteLine( '}' );
			}

			output.WriteLine();
		}

		protected override void GenerateAssignStatement (
			CodeAssignStatement statement)
		{
			TextWriter output = Output;
			GenerateExpression (statement.Left);
			output.Write (" = ");
			GenerateExpression (statement.Right);
            if (dont_write_semicolon)
                return;
            output.WriteLine(';');
        }

		protected override void GenerateAttachEventStatement (
			CodeAttachEventStatement statement)
		{
			TextWriter output = Output;

			GenerateEventReferenceExpression (statement.Event);
			output.Write (" += ");
			GenerateExpression (statement.Listener);
            if (dont_write_semicolon)
                return;
            output.WriteLine (';');
		}

		protected override void GenerateRemoveEventStatement (
			CodeRemoveEventStatement statement)
		{
			TextWriter output = Output;
			GenerateEventReferenceExpression (statement.Event);
			Output.Write (" -= ");
			GenerateExpression (statement.Listener);
            if (dont_write_semicolon)
                return;
            output.WriteLine (';');
		}

		// FIXME: do something after it gets supported.
		protected override void GenerateGotoStatement (
			CodeGotoStatement statement)
		{
			throw new NotSupportedException ("Goto statement is not supported in Nemerle.");
		}
		
		protected override void GenerateLabeledStatement (
			CodeLabeledStatement statement)
		{
			throw new NotSupportedException ("Labeled statement is not supported in Nemerle.");
		}

		protected override void GenerateVariableDeclarationStatement ( CodeVariableDeclarationStatement statement)
		{
			TextWriter output = Output;

			output.Write ("mutable ");

			output.Write (GetSafeName (statement.Name));

			CodeExpression initExpression = statement.InitExpression;
            output.Write(" = ");
            if (initExpression != null) {
				GenerateExpression( initExpression );
                CodePrimitiveExpression x = initExpression as CodePrimitiveExpression;
                if (x != null && x.Value == null)
                {
                    Output.Write(" : ");
                    OutputType(statement.Type);
                }
            }
            else {
                /// FIXME: we should check if it is value type and emit null or () ctor
                if (statement.Type.ArrayElementType != null) {
                    output.Write(NullToken);
                    output.Write(" : ");
                    OutputType (statement.Type);
                }
                else {
                    output.Write (statement.Type.BaseType);
                    output.Write (" ()");
                }
            }
            if (dont_write_semicolon)
                return;
            output.WriteLine( ';' );
		}

		protected override void GenerateLinePragmaStart (CodeLinePragma linePragma)
		{
			Output.WriteLine ();
			Output.Write ("#line ");
			Output.Write (linePragma.LineNumber);
			Output.Write (" \"");
			Output.Write (linePragma.FileName);
			Output.Write ("\"");
			Output.WriteLine ();
		}

		protected override void GenerateLinePragmaEnd (CodeLinePragma linePragma)
		{
			Output.WriteLine ();
			Output.WriteLine ("#line default");
		}

		protected override void GenerateEvent (CodeMemberEvent eventRef,
			CodeTypeDeclaration declaration )
		{
            if (eventRef.CustomAttributes.Count > 0)
                OutputAttributeDeclarations(eventRef.CustomAttributes);

            OutputMemberAccessModifier (eventRef.Attributes);
			OutputMemberScopeModifier (eventRef.Attributes | MemberAttributes.Final); // Don't output "virtual"
			Output.Write ("event ");
			OutputTypeNamePair (eventRef.Type, GetSafeName (eventRef.Name));
			Output.WriteLine (';');
		}

		protected override void GenerateField (CodeMemberField field)
		{
			TextWriter output = Output;

            MemberAttributes attributes = field.Attributes;
            if (IsCurrentEnum) {
                output.Write("| ");
                Output.Write(field.Name);
            }
            else
            {
                if (field.CustomAttributes.Count > 0)
                    OutputAttributeDeclarations(field.CustomAttributes);

                OutputMemberAccessModifier(attributes);
                OutputFieldScopeModifier(attributes);
                OutputTypeNamePair(field.Type, GetSafeName(field.Name));
            }

            CodeExpression initExpression = field.InitExpression;
			if ( initExpression != null ) {
				output.Write ( " = " );
				GenerateExpression ( initExpression );
			}

            if (!IsCurrentEnum)
                output.WriteLine(';');
            else
                output.WriteLine("");
        }

        protected override void OutputFieldScopeModifier(MemberAttributes attributes)
        {
            if ((attributes & MemberAttributes.VTableMask) == MemberAttributes.New)
                Output.Write("new ");
            if ((attributes & MemberAttributes.Static) == MemberAttributes.Static ||
                (attributes & MemberAttributes.Const) == MemberAttributes.Const)
                Output.Write("static ");
            if ((attributes & MemberAttributes.Const) != MemberAttributes.Const)
                Output.Write("mutable ");
        }

        protected override void GenerateSnippetMember (
			CodeSnippetTypeMember member)
		{
			Output.Write (member.Text);
		}
		
		protected override void GenerateEntryPointMethod (
			CodeEntryPointMethod method,
			CodeTypeDeclaration declaration)
		{
			method.Name = "Main";
			GenerateMethod (method, declaration);
		}

		protected override void GenerateMethod (CodeMemberMethod method,
			CodeTypeDeclaration declaration)
		{
			TextWriter output = Output;

			if (method.CustomAttributes.Count > 0)
				OutputAttributeDeclarations (method.CustomAttributes);

			if (method.ReturnTypeCustomAttributes.Count > 0)
				OutputAttributeDeclarations (method.ReturnTypeCustomAttributes);

			MemberAttributes attributes = method.Attributes;

			if (method.PrivateImplementationType == null && !declaration.IsInterface)
				OutputMemberAccessModifier (attributes);

			if (!declaration.IsInterface)
				OutputMemberScopeModifier (attributes);

			output.Write (GetSafeName (method.Name));

			output.Write (' ');

			output.Write ('(');
			OutputParameters (method.Parameters);
			output.Write (')');

			output.Write (" : ");
			OutputType (method.ReturnType);

			if ( (attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract || declaration.IsInterface)
				output.WriteLine ( ';' );
			else {
                CodeTypeReference privateType =
                    method.PrivateImplementationType;
                if (privateType != null)
                {
                    output.Write(" implements ");
                    OutputType(privateType);
                    output.Write (".");
        			output.Write (GetSafeName (method.Name));
                }

                output.WriteLine ( " {" );
				++Indent;
				GenerateStatements (method.Statements);
				--Indent;
				output.WriteLine ( '}' );
			}
		}

		protected override void GenerateProperty (
			CodeMemberProperty property,
			CodeTypeDeclaration declaration)
		{
			TextWriter output = Output;

			if (property.CustomAttributes.Count > 0)
				OutputAttributeDeclarations( property.CustomAttributes );

			MemberAttributes attributes = property.Attributes;
			OutputMemberAccessModifier( attributes );
			OutputMemberScopeModifier( attributes );


			if (property.Name == "Item")
			{
				// indexer
                          output.Write (GetSafeName (property.Name));
                          output.Write (' ');
                          output.Write("[");
                          OutputParameters(property.Parameters);
                          output.Write("]");
                          output.Write (" : ");
                          OutputType (property.Type);                          
			}
			else
			{
         	     	   OutputTypeNamePair( property.Type, GetSafeName (property.Name));
			}
			output.WriteLine (" {");
			++Indent;

			if (declaration.IsInterface)
			{
				if (property.HasGet) output.WriteLine("get; ");
				if (property.HasSet) output.WriteLine("set; ");
			}
			else
			{
				if (property.HasGet)
				{
					output.WriteLine ("get {");
					++Indent;

					GenerateStatements (property.GetStatements);

					--Indent;
					output.WriteLine ("}");
				}

				if (property.HasSet)
				{
					output.WriteLine ("set {");
					++Indent;

					GenerateStatements (property.SetStatements);

					--Indent;
					output.WriteLine ("}");
				}
			}

			--Indent;
			output.WriteLine ("}");
		}

		protected override void GenerateConstructor( CodeConstructor constructor,
							     CodeTypeDeclaration declaration )
		{
            if (constructor.CustomAttributes.Count > 0)
                OutputAttributeDeclarations(constructor.CustomAttributes);

            OutputMemberAccessModifier (constructor.Attributes);
			Output.Write ("this (");
			OutputParameters (constructor.Parameters);
			Output.Write (") ");
			Output.WriteLine ("{");
			Indent++;
			if (constructor.ChainedConstructorArgs.Count > 0)
			{
				Output.Write("this (");
				bool first = true;
				foreach (CodeExpression ex in constructor.ChainedConstructorArgs)
				{
					if (!first)
						Output.Write(", ");
					first = false;
					GenerateExpression(ex);
				}
				
				Output.Write(");");
			};
 			if (constructor.BaseConstructorArgs.Count > 0)
			{
				Output.Write("base (");
				bool first = true;
				foreach (CodeExpression ex in constructor.BaseConstructorArgs)
				{
					if (!first)
						Output.Write(", ");
					first = false;
					GenerateExpression(ex);
				}
				
				Output.WriteLine (");");
			};
			GenerateStatements (constructor.Statements);
			Indent--;
			Output.WriteLine ('}');
		}
		
		protected override void GenerateTypeConstructor (
			CodeTypeConstructor constructor )
		{
			Output.WriteLine ("static this () {");
			Indent++;
			GenerateStatements (constructor.Statements);
			Indent--;
			Output.WriteLine ('}');
		}

		protected override void GenerateTypeStart (
			CodeTypeDeclaration declaration)
		{
			TextWriter output = Output;
			CodeTypeDelegate del = declaration as CodeTypeDelegate;

			if (declaration.CustomAttributes.Count > 0)
				OutputAttributeDeclarations ( declaration.CustomAttributes );

			TypeAttributes attributes = declaration.TypeAttributes;
			OutputTypeAttributes (attributes,
					      declaration.IsStruct,
					      declaration.IsEnum );

			output.Write (GetSafeName (declaration.Name));

			output.Write( ' ' );
			
			IEnumerator enumerator = declaration.BaseTypes.GetEnumerator();
			if ( enumerator.MoveNext() ) {
				CodeTypeReference type = (CodeTypeReference)enumerator.Current;
			
				output.Write( ": " );
				OutputType( type );
				
				while ( enumerator.MoveNext() ) {
					type = (CodeTypeReference)enumerator.Current;
				
					output.Write( ", " );
					OutputType( type );
				}

				output.Write( ' ' );
			}
			if (del != null)
				output.Write ( "(" );
			else
				output.WriteLine ( "{" );
			++Indent;
		}

		protected override void GenerateTypeEnd ( CodeTypeDeclaration declaration )
		{
			--Indent;
			if (declaration is CodeTypeDelegate) {
				Output.Write (") : ");
				CodeTypeReference type = ((CodeTypeDelegate )declaration).ReturnType;
				if (type != null)
					OutputType (type);
				else
					Output.Write ("void");
				Output.WriteLine (";");
			}
			else
				Output.WriteLine ("}");
		}

		protected override void GenerateNamespaceStart ( CodeNamespace ns )
		{
			TextWriter output = Output;
			
			string name = ns.Name;
			if ( name != null && name != "" ) {
				output.Write( "namespace " );
				output.Write( GetSafeName (name) );
				output.WriteLine( " {" );
				++Indent;
			}
		}

		protected override void GenerateNamespaceEnd ( CodeNamespace ns )
		{
			string name = ns.Name;
			if ( name != null && name != "" ) {
				--Indent;
				Output.WriteLine( "}" );
			}
		}

		protected override void GenerateNamespaceImport ( CodeNamespaceImport import )
		{
			TextWriter output = Output;

			output.Write( "using " );
			output.Write( GetSafeName (import.Namespace) );
			output.WriteLine( ';' );
		}

		protected override void GenerateAttributeDeclarationsStart ( CodeAttributeDeclarationCollection attributes )
		{
			Output.Write( '[' );
			CodeMemberMethod met = CurrentMember as CodeMemberMethod;
			if (met != null && met.ReturnTypeCustomAttributes == attributes)
				Output.Write ("return: ");

            IEnumerator enumerator = attributes.GetEnumerator();
            while (enumerator.MoveNext())
            {
                CodeAttributeDeclaration attribute = (CodeAttributeDeclaration)enumerator.Current;
                attribute.Name = attribute.Name.Replace('+', '.');
            }
        }
/*		
        protected override void GenerateAttributeDeclaration ( CodeAttributeDeclarationCollection attributes )
        {
            attribute.Name = attribute.Name.Replace ('+', '.'));
        }
*/
		protected override void GenerateAttributeDeclarationsEnd( CodeAttributeDeclarationCollection attributes )
		{
			Output.WriteLine( ']' );
		}

		protected override void OutputType (CodeTypeReference type)
		{
			Output.Write (GetTypeOutput(type));
		}

		protected override void OutputTypeNamePair (
			CodeTypeReference type, string name)
		{
			Output.Write (GetSafeName (name));
			Output.Write (" : ");
			Output.Write (GetTypeOutput (type));
		}

		protected override string QuoteSnippetString ( string value )
		{
			// FIXME: this is weird, but works.
			string output = value.Replace ("\\", "\\\\");
			output = output.Replace ("\"", "\\\"");
			output = output.Replace ("\t", "\\t");
			output = output.Replace ("\r", "\\r");
			output = output.Replace ("\n", "\\n");

			return "\"" + output + "\"";
		}

		private void GenerateDeclaration (CodeTypeReference type,
			string name, CodeExpression initExpression)
		{
			TextWriter output = Output;

			OutputTypeNamePair (type, GetSafeName (name));

            if (initExpression != null)
            {
                output.Write(" = ");
                GenerateExpression(initExpression);
            }

            output.WriteLine( ';' );
		}
		
		private void GenerateMemberReferenceExpression( CodeExpression targetObject, string memberName )
		{
			if (targetObject != null ) {
				GenerateExpression( targetObject );
				Output.Write( '.' );
			}
			Output.Write( GetSafeName (memberName) );
		}
			
		protected override void GenerateParameterDeclarationExpression (
			CodeParameterDeclarationExpression e)
		{
			if (e.CustomAttributes != null && e.CustomAttributes.Count > 0)
				OutputAttributeDeclarations (e.CustomAttributes);
			Output.Write (GetSafeName (e.Name));
			Output.Write (" : ");
            OutputDirection(e.Direction);
            OutputType (e.Type);
		}

		protected override void GenerateTypeOfExpression (
			CodeTypeOfExpression e)
		{
			Output.Write ("typeof(");
			OutputType (e.Type);
			Output.Write (")");
		}

        protected override void OutputOperator(CodeBinaryOperatorType op)
        {
            switch (op)
            {
                case CodeBinaryOperatorType.BitwiseAnd:
                    Output.Write(" %& ");
                    break;
                case CodeBinaryOperatorType.BitwiseOr:
                    Output.Write(" %| ");
                    break;
                default:
                    base.OutputOperator(op);
                    break;
            }
        }

        /* 
		 * ICodeGenerator
		 */

		protected override string CreateEscapedIdentifier (string value)
		{
			if (value == null)
				throw new NullReferenceException ("Argument identifier is null.");
			return GetSafeName (value);
		}

		protected override string CreateValidIdentifier (string value)
		{
			if (value == null)
				throw new NullReferenceException ();

			if (keywordsTable == null)
				FillKeywordTable ();

			if (keywordsTable.Contains (value) || typesTable.Contains (value))
				return "_" + value;
			else
				return value;
		}

		protected override string GetTypeOutput( CodeTypeReference type )
		{
			string output;
			CodeTypeReference arrayType;

			arrayType = type.ArrayElementType;
			if ( arrayType != null ) {
//				output = GetTypeOutput( arrayType );

				return "array <" + GetTypeOutput (arrayType) + ">";
			}
			else {
                switch (type.BaseType.ToLower(System.Globalization.CultureInfo.InvariantCulture))
                {
                    case "system.decimal":
					output = "decimal";
					break;
				case "system.double":
					output = "double";
					break;
				case "system.single":
					output = "float";
					break;
					
				case "system.byte":
					output = "byte";
					break;
				case "system.sbyte":
					output = "sbyte";
					break;
				case "system.int32":
					output = "int";
					break;
				case "system.uint32":
					output = "uint";
					break;
				case "system.int64":
					output = "long";
					break;
				case "system.uint64":
					output = "ulong";
					break;
				case "system.int16":
					output = "short";
					break;
				case "system.uint16":
					output = "ushort";
					break;

				case "system.boolean":
					output = "bool";
					break;
					
				case "system.char":
					output = "char";
					break;

				case "system.string":
					output = "string";
					break;
				case "system.object":
					output = "object";
					break;

				case "system.void":
					output = "void";
					break;

				default:
					output = GetSafeTypeName (type.BaseType);
					break;
				}
			}

			int rank = type.ArrayRank;
			if ( rank > 0 ) {
				output += "(";
				for ( --rank; rank > 0; --rank  )
					output += ",";
				output += ")";
			}

			return output;
		}

		protected override bool IsValidIdentifier ( string identifier )
		{
			if (keywordsTable == null)
				FillKeywordTable ();

			return !keywordsTable.Contains (identifier) && !typesTable.Contains (identifier);
		}

		protected override bool Supports( GeneratorSupport supports )
		{
            switch (supports)
            {
                case GeneratorSupport.Win32Resources:
                    return false;
                case GeneratorSupport.GotoStatements:
                    return false;
                default:
                    return true;
            }
        }

		string GetSafeName (string id)
		{
			if (keywordsTable == null) {
				FillKeywordTable ();
			}
			if (keywordsTable.Contains (id) || typesTable.Contains (id)) return "@" + id;
			else return id;
		}

		string GetSafeTypeName (string id)
		{
			if (keywordsTable == null) {
				FillKeywordTable ();
			}
			if (keywordsTable.Contains (id)) return "@" + id;
			else return id;
		}

		static void FillKeywordTable ()
		{
			keywordsTable = new Hashtable ();
				foreach (string keyword in keywords) keywordsTable.Add (keyword,keyword);
			typesTable = new Hashtable ();
				foreach (string type in types) typesTable.Add (type,type);
		}

		static Hashtable typesTable;
		static string[] types = new string[] {
			"object","bool","byte","float","uint","char","ulong","ushort",
			"decimal","int","sbyte","short","double","long","string","void"
		};

		static Hashtable keywordsTable;
		static string[] keywords = new string[] {
			"abstract", "and", "array", "as", "base", "catch", "class", "def", "delegate", "do", "else", "enum", "event", "extends", "extern", "false", "finally", "for", "foreach", "fun", "if", "implements", "in", "interface", "internal", "lock", "macro", "match", "module", "mutable", "namespace", "new", "null", "out", "override", "params", "private", "protected", "public", "ref", "sealed", "static", "struct", "syntax", "this", "throw", "true", "try", "type", "typeof", "unless", "using", "variant", "virtual", "void", "when", "where", "while", "assert", "abort", "ignore"
		};
	}
}
