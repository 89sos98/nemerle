using Nemerle.Collections;

module M {

  meth<'a> (v : int, x : 'a) : 'a {
    if (v < 0) x
    else {
      def (x, _) = meth (v - 1, (x, x));
      x
    }
  }


  variant T <'a>
  {
    | Empty
    | Node { f1 : 'a; f2 : T <T <'a>>; }
  }

  collect<'a> (x : T <'a>) : list <'a>
  {
    match (x) {
      | Empty => []
      | Node (e, es) =>
        e :: List.Concat (List.Map (collect, collect (es)))
    }
  }

  
  Main () : void {
    def double<'a> (f : 'a -> 'a, y : 'a) { f (f (y)) }
    and foo (v) { double (fun (x) { x + 1 }, v) }
    and goo (w) { double (fun (x) { x && x }, w) };
    assert (goo (true));
    assert (foo (3) == 5);

    def x12 = Node (1, Node (Node (2, Empty ()), Empty ()));
   
    match (collect (x12)) {
      | [1, 2] => printf ("OK\n")
      | _ => printf ("oops\n")
    };
  
    printf ("%d\n", meth (5, 1));
  }
}

/*
BEGIN-OUTPUT
OK
1
END-OUTPUT
*/
