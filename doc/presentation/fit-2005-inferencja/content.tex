\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\kw}[1]{{\textcolor{kwcolor}{\tt #1}}}
\newcommand{\ra}{\texttt{ -> }}

\definecolor{kwcolor}{rgb}{0.2,0.4,0.0}
\definecolor{lgray}{rgb}{0.8,0.8,0.8}

\title{Rekonstrukcja typów z odraczaniem}
\author{Micha{\l} Moskal}
\institute{Instytut Informatyki, Uniwersytet Wroc³awski}
\date{Forum Informatyki Teoretycznej, \\ Karpacz, 16 kwietnia 2005}



\begin{document}

\frame{
\frametitle{Przeci±¿anie jest dla miêczaków!}
\begin{itemize}
  \item<+->
mo¿emy przecie¿ kazaæ u¿ytkownikowi zamist dwa
razy {\tt SomeFun} napisaæ {\tt SomeFun\_Foo}
oraz {\tt SomeFun\_Bar}! 
\item<+-> przecie¿ w Eiffel.NET tak w³a¶nie jest, hmm...
\item<+->
{\tt Console.WriteLine\_System\_String\_System\_Object\_Sys\-tem\_Object("ala~ma~\{0\}~kotów~i~\{1\}~psów",~5,~7);}
\item<+-> ale to nie jedyny problem...
\end{itemize}
}


\frame{
\frametitle{Yyyyy, to mo¿e...}
\begin{itemize}
  \item<+-> zabroniæ metod o tej samej nazwie w wiêcej ni¿ jednej
        klasie?
  \item<+-> ale co z bibliotek±?
  \item<+-> poza tym chcieliby¶my {\tt args.Map (call\_some)} zamiast \\
          {\tt List.Map (args, call\_some)}
\end{itemize}
}



\frame{
\frametitle{Nienazwane typy?}
\begin{itemize}
  \item<+-> mo¿e przy wywo³aniu nadaæ {\tt x} typ wszystkie--klasy--z--metod±--{\tt SomeMethod}?
  \item<+-> ale pozostaje problem z przeci±¿aniem
  \item<+-> konwersje niejawne w ogóle nierabialne
\end{itemize}
}




\section{Rozwi±zanie!}

\frame{
\frametitle{Co masz zrobiæ dzi¶, zrób pojutrze!}
\begin{itemize}
  \item<+-> mo¿emy odroczyæ typowanie {\tt x} a¿ wiêcej siê o nim dowiemy
  \item<+-> podobnie mo¿emy zrobiæ z przeci±¿onymi wywo³aniami
  \item<+-> ale...
  \item<+-> je¶li to takie proste, to czemu nikt tego wcze¶niej nie robi³?
\end{itemize}
}


\frame{
\frametitle{Znowu k³opoty...}
\begin{itemize}
  \item<+-> wymagamy globalnego rozwi±zywania wiêzów na typach
  \begin{itemize}
  \item<+-> co jest ogólnie uznawane za nieefektywne
  \item<+-> ciê¿ko podaæ dobry komunikat b³êdu
  \item<+-> ciekawostka -- czy wiecie, ¿e ponad po³owa porz±dnego
            kompilatora zwi±zana jest ze zg³aszaniem b³êdów?
  \end{itemize}
  \item<+-> w trakcie typowania mamy niepe³n± informacjê
  \item<+-> algorytm typowania musi byæ odporny na braki informacji
            i zawsze zak³adaæ, ¿e mo¿e kiedy¶ bêdzie co¶ wiadomo
\end{itemize}
}


\section{Wiêzy na typach}

\frame{
\frametitle{Podtypowanie}
\begin{itemize}
  \item<+-> mamy dwie klasy A oraz B, gdzie A dziedziczy po B
  \item<+-> czyli dla ka¿dy obiekt klasy A jest równie¿ obiektem
        klasy B, ale nie koniecznie odwrotnie
  \item<+-> o typach A i B mo¿na my¶leæ jak o zbiorach warto¶ci (obiektów)
  \item<+-> wtedy ³atwo zauwa¿yæ, ¿e $B \subseteq A$
  \item<+-> w teorii typów piszemy, ¿e $B <: A$.
\end{itemize}
}

\frame{
\frametitle{Problem z polimorfizmem i podtypowaniem}
\begin{itemize}
  \item<+-> we¼my funkcjê {\tt Compare[$\alpha$] (x : $\alpha$, y : $\alpha$) : bool}
  \item<+-> oraz wywo³anie {\tt Compare (create\_A (), create\_B ())}
  \item<+-> je¶li podamy jawnie {\tt Compare[A] (create\_A (), create\_B ())}
    \begin{itemize}
      \item typ metody zmieni siê na {\tt Compare (x : A, y : A) : bool},
      \item pierwszy argument bêdzie pasowa³ od razu,
      \item a drugi po niejawnej konwersji w górê.
    \end{itemize}
\end{itemize}
}


\frame{
\frametitle{Jawne parametry typowe s± nie³adne}
\begin{itemize}
  \item<+-> nie chcemy podawaæ jawnie parametrów typowych
  \item<+-> dlatego w miejscu wywo³ania rozwi±zujemy uk³ad nierówno¶ci
            na typach: \\
	\[
	  \left\{ \begin{array}{l}A <: \alpha \\B <: \alpha\end{array} \right.
	\]
  \item<+-> którego najbardziej szczegó³owym rozwi±zaniem jest $\alpha = A$
\end{itemize}
}

\frame{
\frametitle{Lokalne i globalne wiêzy}
\begin{itemize}
  \item<+-> wiêzy na typach mo¿emy traktowaæ lokalnie lub globalnie
  \item<+-> mo¿emy je próbowaæ rozwi±zaæ od razu w miejscu wywo³ania funkcji,
            w razie problemów zg³aszaj±c b³±d (lokalnie)
  \item<+-> lub pozbieraæ z ca³ego programu (lub fragmentu, który akurat typujemy)
            i próbowaæ rozwi±zaæ na koniec (globalnie)
  \item<+-> globalne podej¶cie pozwala na zebranie wiêkszej ilo¶ci informacji,
            kompilator jest wiêc bardziej domy¶lny,
  \item<+-> tylko, je¶li co¶ siê nie uda, to sk±d wiedzieæ co to by³o?
\end{itemize}
}


\frame{
\frametitle{Wiêzy on--line}
\begin{itemize}
  \item<+-> my jednak zrobimy co¶ po¶redniego,
  \item<+-> próbujemy z ka¿dego dodanego wiêzu wyci±gn±æ maximum informacji
            od razu,
  \item<+-> zostawiaj±c jednak wszelkie niejasno¶ci na pó¼niej
\end{itemize}
}


\frame{
\frametitle{Graf zmiennych}
\begin{itemize}
  \item<+-> na zmienne wraz z ³±cz±cymi je relacjami podtypowania patrzymy jako na graf
  \item<+-> graf jest przechodnio--domkniêty (je¶li $\alpha <: \beta \;\wedge\;
    \beta<:\gamma$ to $\alpha <: \gamma$)
  \item<+-> ka¿dy wierzcho³ek ma górn± i doln± granicê, która nie jest zmienn±
  \item<+-> mo¿emy o te granice zapytaæ solver
\end{itemize}
}

\frame{
\frametitle{Graf zmiennych II}
\begin{itemize}
  \item<+-> cykle s± ³±czone -- graf jest DAGiem
  \item<+-> dla ka¿dego wierzcho³ka $\alpha$ \\
    $\alpha^{\uparrow} <: \alpha_{\downarrow}$
  \item<+-> oraz je¶li $\alpha <: \beta$ jest krawêdzi± to \\
    $\alpha^{\uparrow} <: \beta^{\uparrow} \;\wedge\;
    \alpha_{\downarrow} <: \beta_{\downarrow}$
  \item<+-> je¶li $\alpha^{\uparrow}$ oraz $\alpha_{\downarrow}$
      siê zejd± to unifikujemy
  \item<+-> je¶li dodajemy $\tau <: \alpha$ to robimy
     $\alpha^{\uparrow} := \alpha^{\uparrow} \cup \tau$
  \item<+-> je¶li dodajemy $\alpha <: \tau$ to robimy
     $\alpha_{\downarrow} := \alpha_{\downarrow} \cap \tau$
\end{itemize}
}

\frame{
\frametitle{Inne problemy}
\begin{itemize}
  \item<+-> stan solvera musi byæ mo¿liwy do zapamiêtania i odtworzenia
  \item<+-> kilka zmiennych typowych na bajt kodu ¼ród³owego -- solver musi
byæ efektywny
\end{itemize}
}


\section{To jest ju¿ koniec}
\frame{
\frametitle{Podsumowanie}
\begin{itemize}
  \item<+-> typowanie z globalnym rozwi±zywaniem wiêzów wcale nie musi byæ
            nieefektywne 
  \item<+-> nie musi te¿ dawaæ dziwnych komunikatów o b³êdach
  \item<+-> rekonstrukcja typów mo¿e dzia³aæ w niesprzyjaj±cych warunkach
\end{itemize}
}



\end{document}

% vim: language=polish
