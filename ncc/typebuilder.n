/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.IO;
using Nemerle.Utility;
using Nemerle.Collections;

using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** This pass operates on [TypeBuilder] objects created for
    each type declaration found in source files.  These objects are
    already created, but most fields are empty.  The main function of
    this pass is [TypeBuilder.run].  */

public class TypeBuilder : TypeInfo
{
  public enclosing_type : option [TypeBuilder];
  variant_option_parent : TypeBuilder;

  public mutable pt_tydecl : PT.TopDeclaration; 

  modifiers : Modifiers;

  mutable tydecl : TypeDeclaration;
  mutable t_extends : option [TType];
  mutable t_implements : list [TType];

  is_module : bool;
  is_struct : bool;
  is_enum : bool;
  is_interface : bool;
  is_protected : bool;
  is_public : bool;
  is_internal : bool;
  is_private : bool;

  mutable cannot_finalize : bool;
  name : string;
  public env : GlobalEnv;
  loc : Location;
  accessibility : Accessibility;
  private mutable m_has_been_used : bool;
  mutable is_value_type : bool;
  mutable contained_types : list [TypeBuilder];
  mutable variant_options : list [TypeBuilder];
  mutable typarms : list [Tyvar.T];
  public mutable tenv : Tyvar.TEnv;
  mutable additional_decls : list [PT.ClassMember];

  /// if it doesn't, we must add implicit empty constructor
  mutable instance_ctor_occured : bool;

  public mutable is_finalized : bool;

  // the list of additional method overrides, see check_method_implements
  // (listed as pairs of implementation method / interface method)
  private mutable m_additional_method_overrides : list [IMethod * IMethod];
  
  mutable subtypes : SystemMap [int, TypeInfo * list [TType]];
  mutable member_map : SystemMap [string, list [IMember]];
  mutable member_list : list [IMember];

  mutable type_builder : System.Reflection.Emit.TypeBuilder;

  mutable constant_object : option [IField];
  mutable has_fields : bool;
  mutable self_type : TType;
  
  /**
   * Marker for [TypeBuilder.Iter].
   */
  mutable phase : int;
  
  /**
   * Transitive closure of inherited types in this type and its nested types.
   *
   * Used by [TypeBuilder.Iter] function.
   */
  mutable iterate_first : list [TypeBuilder];

  static mutable infos : list [TypeBuilder];

  static mutable run_phase : int;

  
  /**
   * Return list of type parameters under which we subtype given type.
   *
   * [remarks]
   *   For example if [A ('a) :> B (int)], then ["A".SuperType ("B")]
   *   returns [[int]].
   *
   *   This information can be also fetched from [GetDirectSuperTypes()]
   *   method but this function is transitive.
   * </remarks>
   */
  public override SuperType (ti : TypeInfo) : option [list [TType]]
  {
    match (subtypes.Find (ti.GetId ())) {
      | Some ((_, x)) => Some (x)
      | None =>
        if (ti.FullName == "System.Object")
          Some ([])
        else if (ti.SameAs (this))
          match (GetMemType ()) {
            | TType.Class (_, parms) => Some (parms)
            | _ => assert (false)
          }
        else
          None ()
    }
  }

  /** Return qualified type name. */
  public override FullName : string
  {
    get { env.GetCurrentNamespace () + name }
  }

  public override IsDelegate : bool
  {
    get
    {
      match (t_extends) {
        | Some (TType.Class (tycon, [])) =>
          tycon.FullName == "System.MulticastDelegate"

        | _ =>
          false
      }
    }
  }

  public override IsValueType : bool
  {
    get { is_value_type }
  }

  public override GetModifiers () : Modifiers
  {
    modifiers
  }
  
  /** Return type we were defined in (null for toplevel types). */
  public override DeclaringType : TypeInfo {
    get {
      match (enclosing_type) {
        | Some (ti) => ti
        | None => null
      }
    }
  }

  /** Return name without any dots. */  
  public override Name : string {
    get { name }
  }

  public override MemberType : System.Reflection.MemberTypes {
    get { System.Reflection.MemberTypes.NestedType }
  }
  
  public override GetAccessibility () : Accessibility
  {
    accessibility
  }

  public override IsExternallyAccessible : bool
  {
    get
    {
      match (accessibility) {
        | Accessibility.Public
        | Accessibility.Protected
        | Accessibility.ProtectedOrInternal => true
        | _ => false
      }
    }
  }

  public override HasBeenUsed : bool
  {
    get { m_has_been_used }
    set {
      m_has_been_used = m_has_been_used || value;
      match (enclosing_type) {
        | Some (enclosing_type) =>
          enclosing_type.HasBeenUsed = value

        | _ =>
          ()
      }
    }
  }
    
  /**
   * Return list of types that we directly subtype.
   *
   * [remarks]
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   */
  public override GetDirectSuperTypes () : list [TType]
  {
    match (t_extends) {
      | Some (t) => t :: t_implements
      | None => t_implements
    }
  }

  public override GetConstantObject () : option [IField]
  {
    constant_object
  }

  /** Return type we extend if any. */
  public override SuperClass () : option [TypeInfo]
  {
    match (t_extends) {
      | Some (TType.Class (ti, _)) => Some (ti)
      | _ => None ()
    }
  }

  /**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * [remarks]
   *   Used mainly with [FreshSubst ()] or [MakeSubst ()].
   * </remarks>
   */
  public override GetMemType () : TType
  {
    when (self_type == null) {
      def make_tv (tv : Tyvar.T) : TType { TType.Variable (tv) };
      self_type = TType.Class (this, List.Map (typarms, make_tv));
    }

    self_type
  }

  /**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   */
  public override FreshSubst () : Subst
  {
    Tyvar.fresh_subst (this.typarms)
  }

  /**
   * Helper used also in ExternalNemerleType.
   */
  internal static ConstructSubst (tc : TypeInfo, typarms : list [Tyvar.T],
                                  args : list [TType]) : Subst
  {
    def loop (ini : Subst, parms : list [Tyvar.T], args : list [TType]) : Subst {
      match ((parms, args)) {
        | (p :: ps, a :: args) =>
          match (a) {
            | TType.Variable (p') =>
              if (p.id == p'.id) ini
              else loop (ini.Add (p.id, TvValue.Exactly (a)), ps, args)
            | _ => loop (ini.Add (p.id, TvValue.Exactly (a)), ps, args)
          }
        | ([], []) => ini
        | _ => Util.ice ()
      }
    };

    def len_tp = List.Length (typarms);
    def len_ac = List.Length (args);

    if (len_tp == len_ac) {
      def sub = loop (SystemMap (), typarms, args);

      def check_constraints (tv : Tyvar.T, t : TType) : void {
        foreach (c in Tyvar.constraints (tv)) 
        {
          unless (t >:> (c /- sub)) {
            Message.error ($ "typing constraint $(tv.name) :> $c is not "
                             "satisfied by $t :> $(c /- sub)");
            Message.error (tc.Location, "upon instantiation of " + tc.FullName)
          }
        };
      };
      List.Iter2 (typarms, args, check_constraints);

      sub
    } else {
      Message.error (sprintf ("type `%s' takes %d argument(s) while %d were supplied",
                              tc.FullName, len_tp, len_ac));
      SystemMap ()
    }
  }

  /**
   * Construct substitution resulting from applying this type constructor
   * to specified arguments.
   *
   * [remarks]
   *   For example assuming our type parameters are are ('a, 'b), then
   *   [MakeSubst ([t1, t2])] produces substitution { 'a := t1; 'b := t2 }.
   * </remarks>
   */
  public override MakeSubst (args : list [TType]) : Subst
  {
    ConstructSubst (this, typarms, args)
  }

  type Subinfo = SystemMap [int, TypeInfo * list [TType]];

  public override GetTypeInfoKind () : TypeInfoKind
  {
    TypeInfoKind.NemerleType (this)
  }

  public override GetTydecl () : TypeDeclaration
  {
    tydecl
  }

  public override Attributes : NemerleAttributes
  {
    get { modifiers.mods }
  }

  public override LookupMember (name : string) : list [IMember]
  {
    match (member_map.Find (name)) {
      | None =>
        match (tydecl) {
          | TypeDeclaration.Interface =>
            InternalType.Object_tc.LookupMember (name)
          | _ => []
        }
      | Some (mems) =>
        mems
    }
  }

  internal ReverseChildren () : void {
    contained_types = List.Rev (contained_types);
    variant_options = List.Rev (variant_options);
  }

  
  /**
   * Iterate over all types defined in source code.
   *
   * [remarks]
   *   Supertypes are always processed before subtypes otherwise
   *   source code order is retained.
   * </remarks>
   */
  public static Iter (f : TypeBuilder -> void) : void
  {
    def working_on = Util.next_id ();
    def done = Util.next_id ();

    def maybe_f (ti : TypeBuilder) {
      if (ti.phase == done) ()
      else if (ti.phase == working_on)
        Message.error(ti.loc, "type definition for `" + ti.FullName + "' is cyclic")
      else {
        ti.phase = working_on;
        Util.locate (ti.loc, {
          List.Iter (ti.iterate_first, maybe_f);
          f (ti)
        });
        ti.phase = done
      }
    }

    List.Iter (List.Rev (infos), maybe_f)
  }

  /**
   * Return substitution to apply to types of members of our supertype [ti]
   * to get types of members in [this].
   *
   * [remarks]
   *    For example consider:
   *    [[[
   *      class A ('a) { f : 'a; }
   *      class B : A (int) { }
   *    ]]]
   *    Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
   *    it can be applied to type of [A.f] which is ['a], to obtain type
   *    of [B.f] which is [int].
   * </remarks>
   */
  public override SubtypingSubst (tc : TypeInfo) : Subst
  {
    if (SameAs (tc))
      SystemMap () // current type, no substitution
    else
      tc.MakeSubst (Option.UnSome (SuperType (tc)));
  }

  /**
   * Iterate over top level types in source code order.
   */
  public static SourceTopIter (f : TypeBuilder -> void) : void
  {
    foreach (x : TypeBuilder in List.Rev (infos))
      when (x.enclosing_type matches None)
        Util.locate (x.loc, f (x))
  }

  /**
   * Iterate over top level types in inheritance order.
   */
  public static TopIter (f : TypeBuilder -> void) : void
  {
    def wrap (x : TypeBuilder) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    Iter (wrap);
  }

  public this (par : option [TypeBuilder], vop : option [TypeBuilder], 
               env : GlobalEnv, td : PT.TopDeclaration)
  {
    variant_options = [];
    contained_types = [];
    this.enclosing_type = par;
    m_additional_method_overrides = [];    
    match (par) {
      | Some (p) => p.contained_types = this :: p.contained_types;
      | _ => ()
    };
    this.pt_tydecl = td;
    this.env = env;
    this.name = td.name.GetName ().Id;
    this.loc = td.loc;
    modifiers = td.modifiers;
    instance_ctor_occured = td is PT.TopDeclaration.Alias;
        
    match (td) {
      | PT.TopDeclaration.VariantOption =>
        instance_ctor_occured = true;
        match (vop) {
          | Some (ti) =>
            ti.variant_options = this :: ti.variant_options;
            modifiers.mods |= NemerleAttributes.Sealed;
            modifiers.macro_attrs = (":type:postadd", <[ Record ]>) :: modifiers.macro_attrs;
            if (ti.is_public)
              modifiers.mods |= NemerleAttributes.Public
            else
              modifiers.mods |= NemerleAttributes.Internal

          | None => assert (false)
        }
      | PT.TopDeclaration.Enum =>
        is_enum = true;
        is_value_type = true
      | _ => ()
    };

    ++Passes.tyinfo_counter;

    infos = this :: infos;

    is_public = NemerleAttributes.Public %&& modifiers.mods;
    is_internal = NemerleAttributes.Internal %&& modifiers.mods;
    is_protected = NemerleAttributes.Protected %&& modifiers.mods;
    is_private = NemerleAttributes.Private %&& modifiers.mods;
    is_interface = (this.pt_tydecl is PT.TopDeclaration.Interface);
    is_module = NemerleAttributes.Module %&& modifiers.mods;
    is_struct = NemerleAttributes.Struct %&& modifiers.mods;
    instance_ctor_occured = is_struct || is_module || instance_ctor_occured 
      || is_interface || is_enum;
    
    unless (is_public || is_internal || is_protected || is_private) {
      match (enclosing_type) {
        | Some =>
          modifiers.mods |= NemerleAttributes.Private;
          is_private = true
        | None =>
          modifiers.mods |= NemerleAttributes.Internal;
          is_internal = true
      }
    };

    if (is_private)
      accessibility = Accessibility.Private
    else if (is_protected && is_internal)
      accessibility = Accessibility.ProtectedOrInternal
    else if (is_protected)
      accessibility = Accessibility.Protected
    else if (is_internal)
      accessibility = Accessibility.Internal
    else
      accessibility = Accessibility.Public;

    match (enclosing_type) {
      | Some (tc) =>
        accessibility = 
          Tyutil.AccessibilityIntersect (accessibility,
                                         tc.GetAccessibility ())
      | None => ()
    }

    match ((vop, pt_tydecl)) {
      | (Some (x), PT.TopDeclaration.VariantOption) =>
        variant_option_parent = x
      | (None, PT.TopDeclaration.VariantOption) => Util.ice ()
      | (Some, _) => Util.ice ()
      | (None, _) => ()
    };

    additional_decls = [];

    CheckTypeAttributes ();

    m_has_been_used = IsExternallyAccessible
  }

  public override CanAccess (source : TypeInfo) : bool
  {
    is_public || 
    (is_internal && 
      (match (source.GetTypeInfoKind ()) { 
        | TypeInfoKind.NemerleType => true 
        | _ => false 
      })) || 
    (is_protected &&
        (match (enclosing_type) {
          | Some (tc) => Option.IsSome (source.SuperType (tc))
          | None => false
        })) ||
    (match (enclosing_type) {
      | Some (declaring_type) =>
        def walk_declaring (tc : TypeInfo) {
          tc.SameAs (declaring_type) || 
            (tc.DeclaringType != null && walk_declaring (tc.DeclaringType))
        };
        walk_declaring (source)
      | None => false
    })
  }

  /**
   * Construct typing environments for each declaration.
   *
   * [remarks]
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   */
  make_tyenvs (tenv : Tyvar.TEnv) : void
  {
    assert (this.tenv == null);
    match (this.pt_tydecl) {
      | PT.TopDeclaration.Class { typarms = ps; } | PT.TopDeclaration.Alias { typarms = ps; }
      | PT.TopDeclaration.Interface { typarms = ps; } | PT.TopDeclaration.Variant { typarms = ps; } =>
        def (tenv, tyvars) = tenv.add_typarms (this.env, ps,
                                               this, check_parms = false);
        this.tenv = tenv;
        this.typarms = tyvars;
      | _ =>
        this.tenv = tenv;
        this.typarms = [];
    }

    match (pt_tydecl) {
      | PT.TopDeclaration.VariantOption (members) =>
        unless (Util.is_capitalized (pt_tydecl.name.GetName ().Id)) {
          Message.error (loc, "variant options names must start with capital letters")
        };
        assert (variant_option_parent.tenv != null);
        this.tenv = variant_option_parent.tenv;
        this.typarms = variant_option_parent.typarms;
        def make_public (d : PT.ClassMember) : void {
          d.modifiers.mods |= NemerleAttributes.Public
        };
        List.Iter (members, make_public)
      | PT.TopDeclaration.Variant =>
        modifiers.mods |= NemerleAttributes.Abstract
      | _ => ()
    };

    foreach (x : TypeBuilder in this.contained_types)
      Util.locate (x.loc, x.make_tyenvs (tenv));
  }


  /**
   * Bind type expressions occurring in type declarations. This
   * includes [extends] type, [implements] list, and aliased type
   * in case of type alias declaration.
   *
   * [remarks]
   *   Binding type expression refers to rewriting [Parsetree.Type]
   *   into [Typedtree.TType], which involves resolving names of type
   *   constructors (to [TypeBuilder] objects) and type variables (to [Tyvar.T]
   *   objects).
   *   
   *   This function depends on nested types being processed *before*
   *   parent type (so it should only operate on reversed infos list).
   * </remarks>
   */
  bind_types () : void
  {
    def bind (t : PT.PType) : TType {
      this.tenv.bind (this.env, this, t, check_parms = false)
    };
    def td = this.pt_tydecl;
    
    this.tydecl =
      match (td) {
        | PT.TopDeclaration.Class => TypeDeclaration.Class ()
        | PT.TopDeclaration.Alias (_, t) => TypeDeclaration.Alias (bind (t))
        | PT.TopDeclaration.Interface => TypeDeclaration.Interface ()
        | PT.TopDeclaration.Delegate => Util.ice ("delegates shouldn't survive to typing")
        | PT.TopDeclaration.Enum => TypeDeclaration.Enum ()
        | PT.TopDeclaration.Variant =>
          TypeDeclaration.Variant (List.Map (variant_options, fun (x : TypeBuilder) : TypeInfo { x }))
        | PT.TopDeclaration.VariantOption => TypeDeclaration.VariantOption ()
        
        | PT.TopDeclaration.Macro | PT.TopDeclaration.Namespace | PT.TopDeclaration.Using 
        | PT.TopDeclaration.UsingAlias | PT.TopDeclaration.Attribute  
          => Util.ice ("this top declaration shouldn't survive to typing")        
      };
      
    match (td) {
      | PT.TopDeclaration.VariantOption =>
        this.t_extends = Some (variant_option_parent.GetMemType ());
        this.t_implements = [];
      | PT.TopDeclaration.Class { t_extends = hd :: tl }
      | PT.TopDeclaration.Interface { t_extends = hd :: tl }
      | PT.TopDeclaration.Variant { t_extends = hd :: tl } 
      | PT.TopDeclaration.Enum { t_extends = hd :: tl } =>        
        def is_interface (tc : TypeInfo) {
          if (tc.GetTydecl () == null)
            match ((tc :> TypeBuilder).pt_tydecl) {
              | PT.TopDeclaration.Interface => true
              | _ => false
            }
          else
            match (tc.GetTydecl ()) {
              | TypeDeclaration.Interface => true
              | _ => false
            }
        };
        def hd' = bind (hd);
        match (hd') {
          | TType.Class (tc, _) when !is_interface (tc) =>
            this.t_extends = Some (hd'); 
            this.t_implements = List.Map (tl, bind);
          | _ =>
            this.t_implements = hd' :: List.Map (tl, bind);
            this.t_extends = None ()
        }
      | _ =>
        this.t_implements = [];
        this.t_extends = None ()
    };

    when (pt_tydecl is PT.TopDeclaration.Enum)  handle_underlying_enum_type ();
    
    // warn about nested value types 
    when (Option.IsSome (enclosing_type) && (is_struct || is_enum))
      Message.warning (loc, "nested value types fail to compile under .NET Framework v1.1");

    when (is_struct)
    {      
      // make sure no bogus attributes have been specified
      def access_mask = NemerleAttributes.AccessModifiers %| NemerleAttributes.Struct;
      when ((modifiers.mods %& ~access_mask) != NemerleAttributes.None)
        Message.error (loc, "structures are only allowed to have access specifiers as attributes");
        
      // mark the structure as sealed
      modifiers.mods = modifiers.mods %| NemerleAttributes.Sealed %| NemerleAttributes.Struct;
      is_value_type = true;
    }
    
    match (t_extends) {
      | None =>
        match (pt_tydecl) {
          | PT.TopDeclaration.Interface 
          | PT.TopDeclaration.Alias => ()
          | _ =>
            t_extends = Some (
              // make the structure inherit from System.ValueType                           
              if (is_struct)
                InternalType.ValueType;
              else 
                InternalType.Object
            )
        }
      | Some =>
        when (is_interface) {
          Message.error (loc, "interfaces are not allowed to inherit from other types");
          t_extends = None ();
        }
        when (is_struct) {
          Message.error (loc, "structures are not allowed to inherit from other types");
          t_extends = Some (InternalType.ValueType)
        }        
    }
       
    // construct this.iterate_first:
    def iterate_first = Hashtable ();

    foreach (TType.Class (tc, _) in GetDirectSuperTypes ()) {
      when (tc != null) {
        match (tc.GetTypeInfoKind ()) {
          | TypeInfoKind.NemerleType (ti) => iterate_first.Set (ti.GetId (), ti)
          | _ => ()
        }
      }
    }

    foreach (ti : TypeBuilder in this.contained_types)
    {
      def is_self (ti : TypeInfo) {
        if (ti == null) false
        else (ti : object) == (this : object) 
             || is_self (ti.DeclaringType)
      };
      assert (ti.iterate_first != null);
      // add not self
      foreach (ti : TypeBuilder in ti.iterate_first)
        when (! is_self (ti))
          iterate_first.Set (ti.GetId (), ti)
    };

    this.iterate_first = iterate_first.Fold ([], fun (_, ti, acc) { ti :: acc });
  }

  /**
   * Construct datastructures we use to check subtyping relations.
   *
   * [remarks]
   *   This probably the hardest part of processing type declarations.
   *
   *   Each type directly subtypes types it extends or implements.  This
   *   pass computes transitive closure of direct subtyping relation
   *   and stores it [TypeBuilder.subtypes] map.  .NET generics doesn't allow
   *   same type to be subtyped under different instantiations, so we
   *   use map from (id of) subtyped TypeBuilder object to actual parameters
   *   of subtyped type.
   * </remarks>
   */
  static determine_subtyping () : void
  {
    Iter (fun (ti : TypeBuilder) { 
            ti.construct_subtyping_map () 
          });
  }

  construct_subtyping_map () : void
  {
    def add_srs (t, s : Subinfo) {
      match (t) {
        | TType.Class (ti', args) => add_subtyping_of (s, ti', args)
        | _ =>
          Message.error (loc, "cannot implement nor extend non-class type");
          s
      }
    };
    subtypes = List.FoldLeft (GetDirectSuperTypes (), SystemMap (), add_srs)
  }

  add_subtyping_of (subinfo : Subinfo, tc : TypeInfo, args : list [TType]) : Subinfo
  {
    def add_sr (subinfo : Subinfo, subtyped : TypeInfo, args : list [TType]) {
      match (subinfo.Find (subtyped.GetId ())) {
        | Some ((_, args')) =>
          mutable problem = "";
          def check_eq (t1 : TType, t2 : TType) : bool {
            if (Tyutil.types_eq (t1, t2)) true
            else {
              problem = $ "types $t1 and $t2 are not compatible";
              false
            }
          };
          unless (List.ForAll2 (args, args', check_eq)) {
            Message.error ($ "type `$(subtyped)' is implemented by type "
                             "`$(FullName)' twice under different "
                             "instantiations");
            if (tc.SameAs (subtyped))
              Message.error ("second one directly")
            else
              Message.error ("second one through `" + tc.FullName + "'");
            Message.error (problem);
          };
          subinfo
        | None =>
          subinfo.Add (subtyped.GetId (), (subtyped, args))
      }
    };

    def sub = tc.MakeSubst (args);

    def add_srt (t, subinfo : Subinfo) {
      match (t) {
        | TType.Class (tc, args) =>
          add_sr (subinfo, tc, List.Map (args, fun (t) { t /- sub }))
        | _ => Util.ice ("extending non-class type")
      }
    };

    def subinfo = List.FoldLeft (tc.GetSuperTypes (), subinfo, add_srt);
    def subinfo = add_sr (subinfo, tc, args);
    subinfo
  }

  public override GetSuperTypes () : list [TType]
  {
    if (subtypes == null) []
    else
      subtypes.Fold (fun (_, x, acc) {
                        def (tc, args) = x;
                        TType.Class (tc, args) :: acc },
                     [])
  }

  begin_adding_members () : void
  {
    def get_members (t) {
      match (t) {
        | TType.Class (tc, _) => tc.GetMembers ()
        | _ => []
      }
    };
    def members = 
      match (GetTydecl ()) {
        | TypeDeclaration.Interface =>
          List.Concat (List.Map (GetDirectSuperTypes (), get_members))
        | _ =>
          match (t_extends) {
            | Some (t) => get_members (t)
            | None => []
          }
      };
      
    def inherit_it (mem : IMember) {
      def kind_is_ok =
        match (mem.GetKind ()) {
          | MemberKind.Method (mem) =>
            match (mem.GetFunKind ()) {
              | FunKind.Constructor
              | FunKind.StaticConstructor => false
              | _ => true
            }
           
          | MemberKind.Field =>
            has_fields = true;
            true
          
          | _ =>
            true
        }

      kind_is_ok && !(mem.Attributes %&& NemerleAttributes.Private)
    };

    def add (mem : IMember, map : SystemMap [string, list [IMember]]) {
      if (inherit_it (mem)) {
        def n = mem.Name;
        match (map.Find (n)) {
          | Some (l) => map.Replace (n, mem :: l)
          | None => map.Add (n, [mem])
        }
      } else
        map
    };

    member_map = List.FoldLeft (members, SystemMap (), add);
    member_list = []
  }

  internal static constrain_member (m : IMember, flags : BindingFlags) : bool
  {
    def is_public = m.Attributes %&& NemerleAttributes.Public;
    // if flag is Public then always return all public members
    flags == BindingFlags.Public && is_public ||
    // if flag is NonPublic then always return all nonpublic members
    flags == BindingFlags.NonPublic && !is_public ||
    // masks
    (!m.IsStatic || flags %&& BindingFlags.Static) &&
    (m.IsStatic || flags %&& BindingFlags.Instance) &&
    (!is_public || flags %&& BindingFlags.Public) &&
    (is_public || flags %&& BindingFlags.NonPublic)
  }

  /** Note that [bindingAttr] is used only to check the case for DeclaredOnly
      members, so you have to provide filter function to check other flags */
  private get_members (bindingAttr : BindingFlags, filter : IMember -> bool)
  : list [IMember]
  {
    def maybe_add (m : IMember, acc) {
      if (filter(m)) m :: acc else acc
    };
    def add_few (_, mems, acc) {
      List.FoldLeft (mems, acc, maybe_add)
    };
    if (bindingAttr %&& BindingFlags.DeclaredOnly)
      List.Filter (member_list, filter)
    else
      member_map.Fold (add_few, [])
  }
  
  /** Searches for the members defined for the current TypeInfo, using the specified
      binding constraints.
      [remarks]
        Members include properties, methods, fields, events, and so on.

        The following BindingFlags filter flags can be used to define which members to
        include in the search: 
        [ul]
          [li]
            You must specify either BindingFlags.Instance or BindingFlags.Static in order to
            get a return.
          </li>
          [li]
            Specify BindingFlags.Public to include public members in the search.
          </li>
          [li]
            Specify BindingFlags.NonPublic to include non-public members (that is, private
            and protected members) in the search.
          </li>
        </ul>

        The following BindingFlags modifier flags can be used to change how the search
        works: 

        BindingFlags.DeclaredOnly to search only the members declared on the TType,
        not members that were simply inherited.

        Calling this method with only the Public flag or only the NonPublic flag will
        return the specified members and does not require any other flags.

        See Nemerle.Compiler.BindingFlags for more information.
      </remarks>
   */
  public override GetMembers (bindingAttr : BindingFlags) : list [IMember]
  {
    get_members (bindingAttr, fun (m : IMember) {
      constrain_member (m, bindingAttr)
    })
  }
  
  public override GetMembers () : list [IMember]
  {
    get_members ((0 :> BindingFlags), fun (_) { true })
  }

  public override GetFields (bindingAttr : BindingFlags) : list [IField]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Field => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list [IField])
  }
    
  public GetFields () : list [IField]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MemberKind.Field => true | _ => false }
    });
    (mems :> list [IField])
  }


  /** Searches for the methods defined for the current TypeInfo, using the
      specified binding constraints.
  */
  public GetMethods (bindingAttr : BindingFlags) : list [IMethod]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Method (m) =>
          match (m.GetFunKind ()) {
            | FunKind.Constructor | FunKind.StaticConstructor => false
            | _ => constrain_member (m, bindingAttr)
          }
        | _ => false
      }
    });
    (mems :> list [IMethod])
  }

  public GetMethods () : list [IMethod]
  {
    GetMethods (BindingFlags.Static %| BindingFlags.Instance %|
                BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the constructors defined for the current TypeBuilder, using the
      specified BindingFlags.
  */
  public override GetConstructors (bindingAttr : BindingFlags) : list [IMethod]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Method (m) =>
          match (m.GetFunKind ()) {
            | FunKind.Constructor | FunKind.StaticConstructor =>
              constrain_member (m, bindingAttr)
            | _ => false
          }
        | _ => false
      }
    });
    (mems :> list [IMethod])
  }

  public GetConstructors () : list [IMethod]
  {
    GetConstructors (BindingFlags.Static %| BindingFlags.Instance %|
                     BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the types defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetNestedTypes (bindingAttr : BindingFlags) : list [TypeInfo]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Type (t) =>
          constrain_member (t, bindingAttr %| BindingFlags.Static %|
                            BindingFlags.Instance)
        | _ => false
      }
    });
    (mems :> list [TypeInfo])
  }

  public GetNestedTypes () : list [TypeInfo]
  {
    GetNestedTypes (BindingFlags.Static %| BindingFlags.Instance %|
                    BindingFlags.Public %| BindingFlags.NonPublic)
  }

  public GetProperties (bindingAttr : BindingFlags) : list [IProperty]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Property => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list [IProperty])
  }
    
  public GetProperties () : list [IProperty]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MemberKind.Property => true | _ => false }
    });
    (mems :> list [IProperty])
  }

  public GetEvents (bindingAttr : BindingFlags) : list [IEvent]
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MemberKind.Event => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list [IEvent])
  }
    
  public GetEvents () : list [IEvent]
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MemberKind.Event => true | _ => false }
    });
    (mems :> list [IEvent])
  }

  [Nemerle.Assertions.Ensures (value != null)]
  public BindType (t : PT.PType) : TType
  {
    BindType (tenv, t)
  }

  [Nemerle.Assertions.Ensures (value != null)]
  public BindType (other_tenv : Tyvar.TEnv, t : PT.PType) : TType
  {
    other_tenv.bind (env, this, t, check_parms = true)
  }

  public BindTyparms (tp : PT.Typarms) : Tyvar.TEnv * list [Tyvar.T]
  {
    BindTyparms (tenv, tp)
  }

  public BindTyparms (other_tenv : Tyvar.TEnv, tp : PT.Typarms)
  : Tyvar.TEnv * list [Tyvar.T]
  {
    other_tenv.add_typarms (env, tp, this, check_parms = true)
  }

  /** Check if types that are already bound are correctly applied. */
  check_bound_types () : void
  {
    def types =
      match (tydecl) {
        | TypeDeclaration.Alias (t) => t :: GetDirectSuperTypes ()
        | _ => GetDirectSuperTypes ()
      };
    def check_type (t) {
      match (t) {
        | TType.ByRef (t) => check_type (t)
        | TType.Out (t) => check_type (t)
        | TType.Array (t, _) => check_type (t)
        | TType.Function (ts, t) => check_type (ts); check_type (t)
        | TType.Void => ()
        | TType.Product (ts) => List.Iter (ts, check_type)
        | TType.Variable => ()
        | TType.Class (ti, args) =>
          List.Iter (args, check_type);
          ignore (ti.MakeSubst (args));
      }
    };
    def do_check_type (t)
    { 
      Tyutil.CheckAccessibility (this, accessibility, t);
      check_type (t);
    };
    List.Iter (types, do_check_type); // access check also here
    foreach (tv in typarms)
      foreach (t in Tyvar.constraints (tv))
        do_check_type (t);
  }

  internal describe_member (m : IMember) : string
  {
    if (m.GetKind () == null)
      m.GetType ().ToString ()
    else {
      def kind =
        match (m.GetKind ()) {
          | MemberKind.Field => "a field"
          | MemberKind.Method => "a method"
          | MemberKind.Property => "a property"
          | MemberKind.Type => "a type"
          | MemberKind.Event => "an event"
        };
      def full_name =
        if (m.DeclaringType == null)
          m.Name
        else
          m.DeclaringType.FullName + "." + m.Name;
      match (m.GetKind ()) {
        | MemberKind.Method (m) =>
          def parms = List.Map (m.GetHeader ().parms, 
                                fun (p : Fun_parm) { 
                                    p.name + " : " + p.ty.ToString () 
                                });
          def ret_ty = m.GetHeader ().ret_type.ToString ();
          kind + " " + full_name + "(" + NString.Concat (", ", parms) + ") : " + ret_ty
        | _ =>
          kind + " `" + full_name + "'"
      }
    }
  }

  public override Location : Location
  {
    get { loc }
  }

  public BindAndAddMember (class_member : PT.ClassMember) : void
  {
    try { 
      ignore (bind_and_add_member (class_member))
    } catch {
      | _ : Recovery => ()
    }
  }
  
  bind_and_add_member (class_member : PT.ClassMember) : IMember
  {
    Util.locate (class_member.loc, {
      when (is_module)
        class_member.modifiers.mods |= NemerleAttributes.Static;      
        
      when (is_interface) {
        when (class_member.modifiers.mods != NemerleAttributes.None)
          Message.error ("interface members are not allowed"
                         " to have any attributes specified");
        class_member.modifiers.mods = NemerleAttributes.Virtual %|
          NemerleAttributes.Abstract %| NemerleAttributes.Public;
      }
      
      match (class_member) {
        | PT.ClassMember.EnumOption
        | PT.ClassMember.TypeDeclaration => null
          
        | (PT.ClassMember.Field) as f =>
          def r = (NemerleField (this, f) : IMember);
          CheckFieldAttributes ((r :> NemerleField));
          AddMember (r);
          r
          
        | (PT.ClassMember.Function) as f =>          
          def r = NemerleMethod (this, f);
          CheckMethodAttributes (r);
          unless (instance_ctor_occured)
            when (r.GetFunKind () matches FunKind.Constructor) instance_ctor_occured = true;

          AddMember (r);
          r
          
        | (PT.ClassMember.Property) as p =>
          def r = NemerleProperty (this, p);
          when (r.IsIndexer && r.Name == "Item") {
            default_indexer = Some ("Item");
            modifiers.AddCustomAttribute (System.AttributeTargets.Class,
                                          <[ System.Reflection.DefaultMemberAttribute ("Item") ]>);
          }
          CheckPropertyAttributes (r);
          AddMember (r);
          r
          
        | (PT.ClassMember.Event) as e =>
          def r = NemerleEvent (this, e);
          CheckEventAttributes (r);
          AddMember (r);
          r
      }
    })
  }

  public AddMember (mem : IMember) : void
  {
    def replace_method (acc, meth : IMethod, mems) {
      match (mems) {
        | [] =>
          when (mem.Attributes %&& NemerleAttributes.Override)
            Message.error ("`override' specified on " + 
                           describe_member (mem) + 
                           ", but there is no method with this signature "
                           "in parent to override");
          mem :: acc
        | x :: xs =>
          match ((x : IMember).GetKind ()) {
            | MemberKind.Method (m) =>
              def sub = SubtypingSubst (m.DeclaringType);

              when (m.DeclaringType.SameAs (this))
                match ((m.GetMemType () /- sub, mem.GetMemType ())) {
                  | (TType.Function (t1, r1), TType.Function (t2, r2))
                    when Tyutil.types_eq (t1, t2) && ! Tyutil.types_eq (r1, r2) =>
                    Message.error (mem.Location, 
                                   "attemted return type overload on " +
                                   describe_member (mem) + " and " +
                                   describe_member (m))
                  | _ => ()
                };
                
              if (Tyutil.types_eq (m.GetMemType () /- sub, mem.GetMemType ())) {
                match (m.GetFunKind ()) {
                  | _ when m.DeclaringType.SameAs (this) =>
                    Message.error (mem.Location,
                                   "redefinition of " + describe_member (mem))

                  | FunKind.Constructor | FunKind.StaticConstructor => ()
                  | _ when mem.Attributes %&& NemerleAttributes.New => ()
                  | _ when mem.Attributes %&& NemerleAttributes.Override =>
                    if (x.Attributes %&& NemerleAttributes.Virtual)
                      if (x.Attributes %&& NemerleAttributes.Sealed)
                        Message.error ("`override' specified on " + 
                                       describe_member (mem) + 
                                       ", but " + 
                                       describe_member (x) + " is `sealed'")
                      else {}
                    else
                      Message.error ("`override' specified on " + 
                                     describe_member (mem) + 
                                     ", but there is no `virtual' modifier on " + 
                                     describe_member (x));
                    when ((x.Attributes %& NemerleAttributes.AccessModifiers) !=
                          (mem.Attributes %& NemerleAttributes.AccessModifiers))
                      Message.error ("attempt to change the access modifiers of " + 
                                     describe_member (mem) + " during override of " +
                                     describe_member (x));
                  | _ =>
                    Message.error (mem.Location, describe_member (mem) +
                                   " hides " + describe_member (x) +
                                   " but no `new' specified")
                };
                List.RevAppend (xs, mem :: acc)
              } else replace_method (x :: acc, meth, xs)
            | _ => Util.ice ("expecting method, got " + describe_member (x))
          }
      }
    };

    def new_mems =
      match (member_map.Find (mem.Name)) {
        | Some ([]) => Util.ice ()
        | Some ((x :: _) as old) =>
          if (x.DeclaringType.SameAs (this))
            match ((mem.GetKind (), x.GetKind ())) {
              | (MemberKind.Method (m), MemberKind.Method) =>
                replace_method ([], m, old)
              | (MemberKind.Property (p1), MemberKind.Property (p2)) when p1.IsIndexer && p2.IsIndexer =>
                // overloading is (hopefully) checked at the get/set method level
                mem :: old
              | _ =>
                Message.error (mem.Location, describe_member (mem) +
                               " redefined in `" + FullName + "'");
                Message.error (x.Location, "  first definition here as " +
                               describe_member (x));
                [mem]
            }
          else
            match ((mem.GetKind (), x.GetKind ())) {
              | (MemberKind.Method (m), MemberKind.Method) =>
                replace_method ([], m, old)
              | (MemberKind.Property (new_prop), MemberKind.Property) 
                  when new_prop.Attributes %&& NemerleAttributes.Override =>
                [mem]
              | _ when mem.Attributes %&& NemerleAttributes.New => [mem]
              | _ =>
                Message.error (mem.Location, describe_member (mem) +
                               " hides " + describe_member (x) +
                               " but no `new' specified");
                [mem]
            }

        | None =>
          when (mem.Attributes %&& NemerleAttributes.Override)
            Message.error ("`override' specified on " + 
                           describe_member (mem) + 
                           ", but there is no such member "
                           "in parent to override");
          [mem]
      };

    unless (has_fields) {
      has_fields = mem.GetKind () matches MemberKind.Field;
    };

    member_map = member_map.Replace (mem.Name, new_mems);
    member_list = mem :: member_list;
  }

  /** Return list of all members defined in this very type. */
  public GetDirectMembers () : list [IMember]
  {
    member_list
  }

  public GetTypeBuilder () : System.Reflection.Emit.TypeBuilder
  {
    assert (type_builder != null);
    type_builder
  }

  public GetVariantOptionParent () : TypeBuilder
  {
    assert (variant_option_parent != null);
    variant_option_parent
  }
  
  public GetVariantOptions () : list [TypeBuilder]
  {
    variant_options
  }

  mutable underlying_enum_type_iface : INumericType;
  mutable underlying_enum_type : TType;
  
  handle_underlying_enum_type () : void
  {
    match (t_extends) {
      | Some (t) =>
        underlying_enum_type = t;
      | None =>
        underlying_enum_type = InternalType.Int32;
    };
    
    t_extends = Some (InternalType.Enum);

    unless (t_implements matches [])
      Message.error ("enum cannot implement anything");

    def oops () {
      Message.error ($ "`$(underlying_enum_type)' is not valid underlying enum type");
    };

    
    match (Tyutil.top_expand (underlying_enum_type)) {
      | TType.Class (tc, []) =>
        match (NumericType.ByName (tc.FullName)) {
          | Some (t) when t.IsInteger =>
            underlying_enum_type_iface = t
          | _ => oops ()
        }
      | _ => oops ()
    }
  }


  /*
   * This methods calculates an enum's field values. We allow constants,
   * references to enum fields of this enum that already have been calculated,
   * arithmetic addition and basic bit-wise operations.
   */
  calculate_enum_value (expr : PT.PExpr, default_value : object,
                        resolved_values : Hashtable [string, object]) : object
  {
    def enum_type = underlying_enum_type_iface;

    def resolve_ref (_, is_post, e) {
      if (is_post) 
        match (e) {
          | <[ $(n : name) ]> when resolved_values.Contains (n.Id) =>
            def val = resolved_values [n.Id];
            match (NumericType.ByName (val.GetType ().FullName)) {
              | Some (nt) =>
                PT.PExpr.Literal (nt.ToLiteral (val))
              | _ =>
                Util.ice ("resolved_values holds nonnumeric type?")
            }

          | <[ $(n : name) ]> when ConstantFolder.is_known_operator (n.Id) => e
            
          | <[ $(n : name) ]> =>
            Message.fatal_error ($"references are allowed only to this enum's fields preceding "
                                 "this one in the source code, while `$(n.Id)' occured");
            null

          | _ => e    
        }
      else e
    }
    def no_refs = 
      Util.locate (expr.loc, {
        Macros.TraverseExpr (None (), expr, false, resolve_ref)
      });
    
    match (ConstantFolder.FoldConstants (env, no_refs)) {
      | PT.PExpr.Literal (lit) =>
        def have_good_literal_type =
          match (lit) {
            | Literal.Byte
            | Literal.SByte
            | Literal.Short
            | Literal.UShort
            | Literal.Int
            | Literal.UInt
            | Literal.Long
            | Literal.ULong =>
              true

            | _ =>
              false
          }

        if (have_good_literal_type)
        {            
          def val = enum_type.FromLiteral (lit);
        
          if (val == null)
          {
            Message.error ($ "underlying type of enum `$(FullName)' "
                           " is $(underlying_enum_type), so enum literal "
                           "need to have this type");
            default_value
          }
          else
            val
        }
        else
        {
          Message.error ("only 8, 16, 32 and 64-bit, signed and unsigned integer "
                         "types are allowed as enum values");
          default_value
        }
          
      | _ =>
        Message.error ("enum definition expression is too complex");
        Message.hint ("  enum definitions are allowed to be expressions taking constants,");
        Message.hint ("  references to this enum's fields preceding this field, checked ");
        Message.hint ("  operations +, <[, ]> and -, bit-wise operations %|, %&, %^ and negation");          
        default_value
    }
  }
  
  add_enum_members (decls : list [PT.ClassMember]) : void
  {
    def field_type = PT.PType.Typed (GetMemType ());
    def enum_type = underlying_enum_type_iface;
    def resolved_values = Hashtable (32);
    
    def add_field (ef : PT.ClassMember, default_value) {
      def current_value =
        match (ef) {
          | PT.ClassMember.EnumOption (Some (expr)) =>
            calculate_enum_value (expr, default_value, resolved_values)

          | PT.ClassMember.EnumOption (None) =>
            default_value
            
          | _ =>
            Util.ice ("add_enum_members")
        }
      
      ef.modifiers.mods |= NemerleAttributes.Public %| NemerleAttributes.Static;
      def field = PT.ClassMember.Field (ef.loc, ef.name, ef.modifiers, field_type);
      def field = bind_and_add_member (field);
      (field :> NemerleField).enum_value = current_value;
      resolved_values.Add (ef.name.GetFullId (), current_value);
      enum_type.Binary (false, "+", current_value, enum_type.One)
    };

    assert (underlying_enum_type != null);
    BindAndAddMember (<[ decl: public value__ : $(underlying_enum_type : typed); ]>);
    ignore (List.FoldLeft (decls, underlying_enum_type_iface.Zero, add_field));
  }
  

  /**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [TypeBuilder.contained_types]) and store
   * them in [TypeBuilder.member_map] and [TypeBuilder.member_list].
   *
   * [remarks]
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   */
  add_members () : void
  {
    begin_adding_members ();
    def decls =
      match (pt_tydecl) {
        | PT.TopDeclaration.Class { decls = ds }
        | PT.TopDeclaration.Interface { methods = ds }
        | PT.TopDeclaration.Variant { decls = ds }
        | PT.TopDeclaration.VariantOption (ds) => ds
        | PT.TopDeclaration.Enum { decls = ds } => add_enum_members (ds); []
        | _ => []
      };

    List.Iter (decls, BindAndAddMember);
    List.Iter (additional_decls, BindAndAddMember);

    contained_types = List.Rev (contained_types);
    List.Iter (contained_types, AddMember);
    
    member_list = List.Rev (member_list);

    /// define implicit instance constructor if none exists
    unless (instance_ctor_occured) {
      match (DefineAndReturn (<[ decl: public this () { } ]>)) {
        | Some (meth) => meth.SetInstanceUsed ();
        | _ => ()
      }
    }

    // we no longer need it, let GC kill it
    pt_tydecl = null;
    additional_decls = null;
  }

  add_constant_object_ctor () : void
  {
    match (member_map.Find (".ctor")) {
      | Some ([ctor]) =>
        def ctor = (ctor :> NemerleMethod);
        def field = PT.ClassMember.Field (loc = loc, 
                                name = PT.Splicable.Name (PT.Name ("_N_constant_object")), 
                                modifiers = Modifiers (NemerleAttributes.Public %|
                                                       NemerleAttributes.Static, []),
                                ty = PT.PType.Void ());
        def typed_field = NemerleField (this, (field :> PT.ClassMember.Field));
        typed_field.MarkWithSpecialName ();
        typed_field.ty = variant_option_parent.GetMemType ();
        ctor.modifiers.mods = NemerleAttributes.Private;
        AddMember (typed_field);
        
        constant_object = Some ((typed_field : IField));
        
        def ttf = typed_field.ty;
        
        // use typed trees here to avoid problems during actual typing
        def tbody = TExpr.Assign (loc, TType.Void (),
                              TExpr.StaticRef (loc, ttf, typed_field), 
                              TExpr.Call (loc, ttf,
                                      TExpr.StaticRef (loc, ctor.GetMemType (), ctor), []));
                                      
        def static_ctor = <[ decl: static this () { $(tbody : typed) } ]>;
        BindAndAddMember (static_ctor);

        // add the constant object generator function
        def generator_ret_type = PT.PType.Typed (typed_field.ty);
        
        def generator = DefineAndReturn (<[ decl:
          public static _N_constant_object_generator () : $(generator_ret_type)
          {
            _N_constant_object
          }
        ]>);

        assert (Option.IsSome (generator));
        Option.UnSome (generator).MarkWithSpecialName ()
        
      | _ => Util.ice (FullName)
    }
  }

  /**
   * Add special methods to variants and variant options. These methods
   * are used to accelerate matching over variants, allowing us to use
   * a single CExpr.Switch statement to identify a variant options instead of 
   * a series of CExpr.If/HasType instructions.
   *
   */
  private add_special_variant_methods () : void
  {
    match (tydecl) {
      | TypeDeclaration.Variant =>
        def gvc = <[ decl:
          public abstract _N_GetVariantCode () : int ;
        ]>;

        gvc.modifiers.mods = gvc.modifiers.mods %| NemerleAttributes.SpecialName;

        Define (gvc)

      | TypeDeclaration.VariantOption =>
        mutable my_index = 0;
                       
        ignore (List.Find (variant_option_parent.GetVariantOptions (), fun (x) {
          (x : object) == (this : object) || ({ ++my_index; false })
        }));

        def gvc = <[ decl:
          public override _N_GetVariantCode () : int {
            $(my_index : int)
          }
        ]>;
        
        gvc.modifiers.mods = gvc.modifiers.mods %| NemerleAttributes.SpecialName;
        
        Define (gvc)

      | _ =>
        ()
    }
  }

  /**
   * Add constant fields with single instance of parameter-less 
   * variant options.
   */
  private add_constant_variant_ctors () : void
  {
    constant_object = None ();

    match (tydecl) {
      | TypeDeclaration.VariantOption when !has_fields =>
        add_constant_object_ctor ()
      | _ =>
        ()
    }        
  }
  
  public static Init () : void
  {
    infos = [];
  }

  public ConstructTypeBuilder () : void
  {
    when (system_type == null) {
      type_builder = Passes.cgil.ConstructTypeBuilder (this);
      system_type = type_builder;
    }
  }

  
  /*
   * This method emits the warnings about unused global symbols.
   */
  private static check_for_unused_global_symbols (tb : TypeBuilder) : void
  {
    unless (tb.IsDelegate)
    {
      def is_variant = !(tb.variant_options matches []);
      def is_alias = tb.tydecl is TypeDeclaration.Alias;
      
      // first, check if this type has ever been referenced
      when (!(tb.HasBeenUsed || is_variant || is_alias))
        Message.warning (tb.loc, $ "`$(tb)' is not externally visible and has never been referenced");

      // then, proceed with the members of this type
      foreach (member : IMember in tb.member_list)
        when (!(member.HasBeenUsed || (member is TypeInfo) || (is_variant && member.Name == ".ctor")))
        {
          Message.warning (member.Location, tb.describe_member (member) +
                           " is not externally visible and has never been referenced")
        }
    }
  }

  
  public FinalizeType () : void
  {
    when (!cannot_finalize && type_builder != null) {
      define_additional_method_overrides ();

      system_type = type_builder.CreateType ();
      type_builder = null;
    }
  }

  internal GetTyparms () : list [Tyvar.T]
  {
    typarms
  }

  /** Return interfaces [this] needs to implement (that is it says it will
      implement them, but they are not implemented in base class). */
  public InterfacesToImplement () : list [TypeInfo] 
  {
    def base_class =
      match (SuperClass ()) {
        | Some (tc) => tc
        | None => InternalType.Object_tc
      };

    def collect (t, acc) {
      match (t) {
        | TType.Class (tc, _) =>
          match (tc.GetTydecl ()) {
            | TypeDeclaration.Interface =>
              match (base_class.SuperType (tc)) {
                | Some => acc
                | None => tc :: acc
              }
            | _ => acc
          }
        | _ => acc
      }
    };
    
    List.FoldLeft (GetSuperTypes (), [], collect);
  }

  check_ctor_constraints () : void
  {
    def check_ctors (ty : TypeInfo) {
      def check_ctor (member : IMember, acc) {
        match (member.GetKind ()) {
          | MemberKind.Method (meth) when meth.DeclaringType.SameAs (ty) =>
            match (meth.GetFunKind ()) {
              | FunKind.Constructor =>
                def is_default = List.IsEmpty (meth.GetHeader ().parms);
                match (acc) {
                  | (true, _) => (true, true)
                  | _ => (is_default, true)
                }
              | _ => acc
            }
          | _ => acc
        }
      };

      List.FoldLeft (ty.GetMembers (), (false, false), check_ctor)
    };

    match (t_extends) {
      | Some (TType.Class (par, _)) =>
        def (_, has_ctor) = check_ctors (this);
        def (par_has_default, par_has_ctor) = check_ctors (par);
        when (!has_ctor && !par_has_default && par_has_ctor)
          Message.error ("the type `" + FullName + 
                         "' has no constructors and the parent type `" + 
                         par.FullName + "' has no default constructor")
      | _ => ()
    }
  }


  /**
   * Checks for abstract method in non-abstract class errors.
   * Marks abstract declaration/implementation pairs as used.
   *
   * FIXME: we should store information about abstract overrides
   *        the same way we store information about interfaces,
   *        this way this code would be linear instead of n^2
   */
  check_abstract () : void
  {
    def override_methods = Hashtable (30);
    def type_members = GetMembers ();

    // first, check for the abstract method/non-abstract class errors
    foreach (m : IMember in type_members)
      match (m.GetKind ()) {
        | MemberKind.Method when m.Attributes %&& NemerleAttributes.Abstract =>
          unless (Attributes %&& NemerleAttributes.Abstract)
          {
            modifiers.mods |= NemerleAttributes.Abstract;
            Message.error (describe_member (m) + 
                           " is abstract, but the parent class `" + 
                           FullName + "' is not");
          }
            
        | _ => ()
      }

    // find all the `override' methods in this type
    foreach (m : IMember in type_members)
      match (m.GetKind ()) {
        | MemberKind.Method when m.Attributes %&& NemerleAttributes.Override =>
          def previous_methods =
            match (override_methods.Get (m.Name)) {
              | Some (methods) => methods
              | _ => []
            }
            
          override_methods.Set (m.Name, (m :> IMethod) :: previous_methods);
          m.HasBeenUsed = true
    
        | _ => ()
      }

    // then, mark abstract declaration/implementation pair as used
    def walk_hierarchy (tycon : TypeInfo)
    {
      // FIXME: this should be defined on Fun_header -- IsCompatible () (?)
      def fun_parms_agree (abstract_parms : list [Fun_parm], impl_parms : list [Fun_parm])
      {          
        | ([], []) => true
          
        | (abstract_parm :: rest_abstract_parms, impl_parm :: rest_impl_parms) =>
          abstract_parm.name == impl_parm.name &&
          Tyutil.types_eq (abstract_parm.ty, impl_parm.ty) &&
          fun_parms_agree (rest_abstract_parms, rest_impl_parms)
          
        | _ => false
      }
      
      override_methods.Iter (fun (name : string, meths : list [IMethod]) {
        foreach (meth : IMethod in meths) 
        {
          def meth_parms = meth.GetHeader ().parms;
        
          def possible_abstract_meths =
            List.Filter (tycon.LookupMember (name), fun (mem : IMember) {            
              mem.Attributes %&& NemerleAttributes.Abstract
            });

          foreach (abstract_meth : IMember in possible_abstract_meths) {
            def abstract_meth = abstract_meth :> IMethod;

            when (fun_parms_agree (abstract_meth.GetHeader ().parms, meth_parms)) {
              abstract_meth.HasBeenUsed = true;
              meth.HasBeenUsed = true
            }
          }
        }
      })
    }
    and recurse (supertypes : list [TType])
    {
      | TType.Class (tycon, _) :: rest =>
        walk_hierarchy (tycon);
        recurse (rest)

      | _ :: rest =>
        recurse (rest)
        
      | [] => ()
    }

    recurse (GetDirectSuperTypes ())
  }

  
  /**
   * Defines additional method overrides that have been gathered
   * in check_method_implements from this type's parent types.
   */
  private define_additional_method_overrides () : void
  {
    def define_override (meth : IMethod, iface_meth : IMethod)
    {
      type_builder.DefineMethodOverride (meth.GetMethodInfo (),
                                         iface_meth.GetMethodInfo ());
      meth.HasBeenUsed = true
    }
    
    List.Iter (m_additional_method_overrides, define_override)
  }


  /**
   * Resolves overrides for the required interface methods
   */
  check_method_implements () : void
  {
    check_abstract ();

    def collect (mem : IMember, acc) {
      match (mem.GetKind ()) {
        | MemberKind.Method (m) =>
          match (m.GetFunKind ()) {
            | FunKind.Method =>
              (m :> NemerleMethod) :: acc
            | _ => acc
          }
        | _ => acc
      }
    };
    def methods = List.FoldLeft (this.GetDirectMembers (), [], collect);
    
    // FIXME: in fact we should only mark some methods as implemented and scream
    // when signature match is ambigious
    def iface_methods = Hashtable (30);
  
    foreach (tc : TypeInfo in InterfacesToImplement ())
      foreach (m : IMember in tc.GetMembers (BindingFlags.DeclaredOnly %|
                                             BindingFlags.Public %|
                                             BindingFlags.Instance))
        match (m.GetKind ()) {
          | MemberKind.Method (m) =>
            match (iface_methods.Get (m.Name)) {
              | Some (lst) => iface_methods.Set (m.Name, m :: lst)
              | None => iface_methods.Add (m.Name, [m])
            };
          | _ => ()
        }

    def bind_explicit_implements (meth : NemerleMethod)
    {
      def bind_one (name : PT.Splicable)
      {
        def name = name.GetName ();
        def env = name.GetEnv (this.env);
        def (ns, member) = List.DivideLast (name.idl);
        def ty = env.GetType (ns, this);
        
        match (iface_methods.Get (member)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              iface_meth.DeclaringType.SameAs (ty) &&
                meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] =>
                Message.fatal_error ("interface `" + ty.FullName + 
                                     "' does not contain method named `" + member + 
                                     "' with proper signature")
              | [m] =>                
                iface_methods.Set (member, List.Filter (meths, fun (x) { ! is_correct (x) }));
                meth.HasBeenUsed = true;
                m
              | _ =>
                Message.fatal_error ("interface `" + ty.FullName + 
                                     "' contains more then one method named `" + member + 
                                     "' with proper signature")
            }
          | None =>
            Message.fatal_error ("no interface implemented by `" + this.FullName + 
                                 "' contains method named `" + member + 
                                 "' (looking for `" +
                                 Util.qid_of_list (name.idl) + "')")
        }
      };
      match (meth.GetFunKind ()) {
        | FunKind.Method (impl) =>
          def impl' =
            try { List.Map (impl, bind_one) }
            catch { _ : Recovery => [] };

          foreach (impl : IMember in impl')
            impl.HasBeenUsed = true;

          meth.fun_kind = FunKind.BoundMethod (impl')
        | _ => ()
      }
    };
    List.Iter (methods, bind_explicit_implements);
    
    def bind_implicit_implements (meth : NemerleMethod) {
      def lookup_iface_members () {
        match (iface_methods.Get (meth.Name)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              if (meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this))
                if (meth.Attributes %&& NemerleAttributes.Public &&
                    !(meth.Attributes %&& NemerleAttributes.Static))
                  true
                else {
                  Message.error (meth.Location, "method implementing interface"
                                 " member must be public and nonstatic");
                  false
                }
              else
                false                 
            };
            match (List.Filter (meths, is_correct)) {
              | [] => []
              | lst =>
                iface_methods.Set (meth.Name, 
                                   List.Filter (meths, fun (x) { ! is_correct (x) }));
                meth.HasBeenUsed = true;
                lst
            }
          | None => []
        }
      };
      match (meth.GetFunKind ()) {
        | FunKind.BoundMethod (impl) =>
          match (lookup_iface_members ()) {
            | [] => ()
            | impl' =>
              def new_impls = impl' + impl;

              foreach (impl : IMethod in new_impls)
                impl.HasBeenUsed = true;

              meth.fun_kind = FunKind.BoundMethod (new_impls);
              meth.modifiers.mods |= NemerleAttributes.Virtual;
          }
        | _ => ()
      }
    };
    List.Iter (methods, bind_implicit_implements);

    // create the additional overrides for unresolved interface methods
    mutable resolved_overrides = [];
    
    def create_additional_overrides (name : string, meths : list [IMethod])
    {
      def possible_impls = LookupMember (name);

      def check_possible_impl (member : IMember)
      {
        when (member is IMethod)
        {
          def meth = (member :> IMethod);

          def is_correct (iface_meth : IMethod)
          {
            (meth.Attributes %&& NemerleAttributes.Public) &&
            (meth.Attributes %&& NemerleAttributes.Virtual) &&
            (meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this))
          };

          def iface_meths = List.Filter (meths, is_correct);

          unless (iface_meths matches [])
          {
            resolved_overrides = List.Append (resolved_overrides, iface_meths);

            // create a wrapper in the current type
            def meth_header = meth.GetHeader ();
            def meth_name = Macros.UseSiteSymbol (meth_header.name);
            def meth_ret_type = meth_header.ret_type;
            
            def meth_parms =
              List.Map (meth_header.parms, fun (fp : Fun_parm) {
                <[ funparm: $(fp.name : usesite) : $(fp.ty : typed) ]>
              });

            def meth_call_parms = List.Map (meth_header.parms, fun (fp : Fun_parm) {
              <[ $(fp.name : usesite) ]>
            });

            def wrapper = DefineAndReturn (<[ decl:
              public override $(meth_name : name) (..$meth_parms) : $(meth_ret_type : typed)
              {
                base.$(meth_name : name) (..$meth_call_parms)
              }
            ]>);

            // unpack the new method definition
            assert (Option.IsSome (wrapper));
            def wrapper = Option.UnSome (wrapper);

            wrapper.MarkWithSpecialName ();
            
            assert ((wrapper is IMethod));
            def wrapper = (wrapper :> IMethod);
            
            // add the new overrides
            def new_overrides =
              List.Map (iface_meths, fun (iface_meth : IMethod) {
                iface_meth.HasBeenUsed = true;
                (wrapper, iface_meth)
              });
            
            m_additional_method_overrides =
              List.Append (new_overrides, m_additional_method_overrides);
          }
        }
      }

      unless (meths matches [])
        List.Iter (possible_impls, check_possible_impl)
    }

    iface_methods.Iter (create_additional_overrides);

    foreach (iface_meth : IMethod in resolved_overrides)
    {
      def iface_meths = iface_methods.Get (iface_meth.Name);

      when (Option.IsSome (iface_meths)) {
        iface_methods.Set (iface_meth.Name, 
                           List.Filter (Option.UnSome (iface_meths), 
                                        fun (x) { 
                                          (x : object) != (iface_meth : object)
                                        }))
      }
    };               
    
    // emit error messages for any unbound interface method
    def scream_about_unimplemented (_, meths : list [IMethod])
    {
      foreach (meth : IMethod in meths)
        Message.error ("unimplemented interface method `" + 
                       meth.DeclaringType.FullName + 
                       "." + meth.Name + "' with signature " +
                       Tyutil.fun_type (meth.GetHeader ()).ToString ())
    }
    
    iface_methods.Iter (scream_about_unimplemented)
  }


  process_macro_attributes (stage : int) : void
  {
    def process_attributes (self_parm, suff, mods : Modifiers, meth : IMethod) {
      mutable macro_attrs = mods.macro_attrs;
      // we have to do the assignment here, in case macro has added a new
      // custom attribute
      mods.custom_attrs =
        List.Filter (mods.custom_attrs, fun (expr) {
          match (MacroRegistry.lookup_macro (env, expr, suff)) {
            | None => true
            | Some =>
              macro_attrs = (suff, expr) :: macro_attrs;
              false
          }
        });
      foreach ((_, expr) in macro_attrs)
      {
        match (MacroRegistry.lookup_macro (env, expr, suff)) {
          | None => ()
          | Some ((name, imacro, exprs)) =>
            def meth_header =
              if (meth == null) null else meth.GetHeader ();
            def tenv = 
              if (meth_header == null) this.tenv else meth_header.tenv;
            def in_ctor =
              if (meth != null)
                match (meth.GetFunKind ()) {
                  | FunKind.Constructor => true 
                  | _ => false
                }
              else
                false;
            def ctx =
              TypingContext (in_ctor = in_ctor,
                             this_ptr_decl = None (),
                             env = this.env,
                             tenv = tenv,
                             current_fun = meth_header,
                             locals = null,
                             parent_type = this,
                             in_tail_position = false,
                             is_checked = true);
            TypingContext.PushNewColor (name.color, name.GetEnv (env));

            def parms = 
              List.Append (self_parm, imacro.CallTransform (exprs));
            def res = imacro.Run (ctx, parms);
            TypingContext.PopColor ();

            assert (res == null);
            ()
        }
      };
      mods.macro_attrs = macro_attrs;
    };

    def process_member (mem, stage_suff) {
      match (mem) {
        | PT.ClassMember.Field =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                                     ":field" + stage_suff, mem.modifiers, null)

        | (PT.ClassMember.Function) as f =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                              ":method" + stage_suff, mem.modifiers, null);

          foreach (p : PT.Fun_parm in f.header.parms)
            process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                 PT.SyntaxElement.ClassMember (mem),
                                 PT.SyntaxElement.Parameter (p)],
                                ":param" + stage_suff,  p.modifiers, null);

        | PT.ClassMember.EnumOption
        | PT.ClassMember.TypeDeclaration => ()

        | PT.ClassMember.Property =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                              ":property" + stage_suff, mem.modifiers, null)

        | PT.ClassMember.Event => 
          process_attributes ([PT.SyntaxElement.TypeBuilder (this), PT.SyntaxElement.ClassMember (mem)],
                              ":event" + stage_suff, mem.modifiers, null)
      }
    };

    def iter_decls (stage_suff) {
      def decls =
        match (pt_tydecl) {
          | PT.TopDeclaration.Class { decls = ds }
          | PT.TopDeclaration.Interface { methods = ds }
          | PT.TopDeclaration.Variant { decls = ds }
          | PT.TopDeclaration.VariantOption (ds) => ds
          | _ => []
        };      

      foreach (x in decls) process_member (x, stage_suff);
      foreach (x in additional_decls) process_member (x, stage_suff);
    };

    def process_typed_member (mem : IMember) {
      def mods () { (mem :> NemerleMember).modifiers };
      match (mem.GetKind ()) {
        | MemberKind.Field (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                PT.SyntaxElement.FieldBuilder ((f :> NemerleField))],
                                     ":field:postadd", mods (), null)
        | MemberKind.Method (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                PT.SyntaxElement.MethodBuilder ((f :> NemerleMethod))],
                               ":method:postadd", mods (), f);

          foreach (p : Fun_parm in f.GetHeader ().parms)
            process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                 PT.SyntaxElement.MethodBuilder ((f :> NemerleMethod)),
                                 PT.SyntaxElement.ParameterBuilder (p)],
                                 ":param:postadd", p.modifiers, f);
                              
        | MemberKind.Property (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                PT.SyntaxElement.PropertyBuilder ((f :> NemerleProperty))],
                               ":property:postadd", mods (), null)

        | MemberKind.Event (f) =>
          process_attributes ([PT.SyntaxElement.TypeBuilder (this),
                                PT.SyntaxElement.EventBuilder ((f :> NemerleEvent))],
                               ":event:postadd", mods (), null)

        | MemberKind.Type => ()
      }
    };

    match (stage) {
      | 1 =>
        process_attributes ([PT.SyntaxElement.TypeBuilder (this)], ":type:postscan", modifiers, null);
        iter_decls (":postscan");

      | 2 =>
        process_attributes ([PT.SyntaxElement.TypeBuilder (this)], ":type:preadd", modifiers, null);
        iter_decls (":preadd");
        
      | 3 =>
        process_attributes ([PT.SyntaxElement.TypeBuilder (this)], ":type:postadd", modifiers, null);
        List.Iter (GetDirectMembers (), process_typed_member);

      | _ => assert (false)
    }
  }

  
  /**
   * Main function of type declaration handling pass.
   *
   * [remarks]
   *   - constructing typing environments [TypeBuilder.make_tyenvs]
   *   - binding types [TypeBuilder.bind_types]
   *   - determining subtyping relations [TypeBuilder.determine_subtyping]
   *   - checking subtyping constraints on types that are already bound
   *     [TypeBuilder.check_bound_types]
   *   - adding members [TypeBuilder.add_members]
   *   - adding the variant/variant option special matching methods
   * </remarks>
   */
  public static Run () : void
  {
    foreach (x : TypeBuilder in List.Rev (infos))
      Util.locate (x.loc, x.process_macro_attributes (1));

    run_phase = 1;
    SourceTopIter (fun (x : TypeBuilder) { 
                      x.make_tyenvs (Tyvar.TEnv ()) 
                    });
    
    run_phase = 2;

    foreach (x : TypeBuilder in infos)
      Util.locate (x.loc, x.bind_types ());

    // add the _N_GetVariantCode methods to variants and variant options
    Iter (fun (x : TypeBuilder) { x.add_special_variant_methods () });
    
    run_phase = 3;
    determine_subtyping ();
    
    run_phase = 4;
    Iter (fun (x : TypeBuilder) { x.check_bound_types () });

    run_phase = 5;
    
    Iter (fun (x : TypeBuilder) { x.process_macro_attributes (2) });

    Iter (fun (x : TypeBuilder) { x.add_members () });

    Iter (fun (x : TypeBuilder) { x.process_macro_attributes (3) });

    // add constant object constructors for constant variant options
    Iter (fun (x : TypeBuilder) { x.add_constant_variant_ctors () });

    // propagate the SpecialName attribute if needed
    Iter (fun (x : TypeBuilder) { 
      when (x.modifiers.mods %&& NemerleAttributes.SpecialName)
        x.mark_members_with_special_name ()
    });
    
    def check_method_implements (ti : TypeBuilder) {
      match (ti.GetTydecl ()) {
        | TypeDeclaration.Interface => ()
        | _ => ti.check_method_implements ()
      }
    };

    Iter (check_method_implements);

    Iter (fun (x : TypeBuilder) { x.check_ctor_constraints () });
  }


  /**
   * This method iterates through all the known type builders,
   * looking for unused global symbols.
   */
  public static CheckForUnusedGlobalSymbols () : void
  {
    when (Flags.global_unused_symbols_warnings)
      Iter (check_for_unused_global_symbols)
  }

  
  internal FixupDefinedClass () : void
  {
    // finalization is blocked until call to Compile
    this.cannot_finalize = true;
    this.constant_object = None ();
    when (run_phase >= 1)
      match (enclosing_type) {
        | Some (ti) =>
          make_tyenvs (ti.tenv)
        | None =>
          make_tyenvs (Tyvar.TEnv ())
      };
    when (run_phase >= 2)
      Util.locate (loc, bind_types ());
    when (run_phase >= 3)
      construct_subtyping_map ();
    when (run_phase >= 4)
      check_bound_types ();
    when (run_phase >= 5)
      begin_adding_members ();
  }


  public AddImplementedInterface (t : PT.PType) : void
  {
    match (pt_tydecl) {
      | (PT.TopDeclaration.Class) as td => td.t_extends += [t]
      | (PT.TopDeclaration.Interface) as td => td.t_extends += [t]
      | (PT.TopDeclaration.Variant) as td => td.t_extends += [t]
      | _ => Message.error ("cannot add interface to this kind of type")
    }
  }
  
  public DefineNestedType (td : PT.ClassMember) : TypeBuilder
  {
    | PT.ClassMember.TypeDeclaration (td) =>
      def name = match (td.name.GetIdList ()) {
        | [x] => x;
        | x :: _ => Message.error ("cannot define nested type with a qualified name"); x
        | _ => assert (false, "Empty name")
      };
      def fullns = env.GetCurrentNamespaceND ().Path (Name).Path (name);
      def env = env.AddOpenNamespace (fullns, td.loc).EnterIntoNamespace ([Name]);
      def tyinfo = TypeBuilder (Some (this), None (), env.AddOpenNamespace (fullns, td.loc), td);
      GlobalEnv.AddType (fullns, tyinfo);
      tyinfo.FixupDefinedClass ();
      match (td) {
        | PT.TopDeclaration.Class { decls = ds } =>
          foreach (x : PT.ClassMember in ds) tyinfo.Define (x);
        | _ => ()
      };
      tyinfo
    | _ =>
      Message.error ("expected declaration of nested type");
      null
  }


  /**
   * Adds a definition and returns the new NemerleMember, if available
   */
  public DefineAndReturn (f : PT.ClassMember) : option [NemerleMember]
  {
    if (member_map == null) {
      additional_decls = f :: additional_decls;
      None ()
    }
    else {
      try {
        def mem = bind_and_add_member (f);
        Passes.cgil.MemberAdded (this, mem);
        Some (mem :> NemerleMember)
      } catch {
        | _ : Recovery => None ()
      }
    }
  }


  /**
   * Adds a definition to this type
   */
  public Define (f : PT.ClassMember) : void
  {
    ignore (DefineAndReturn (f))
  }


  /**
   * Builds this type
   */
  public Compile () : void
  { 
    cannot_finalize = false;
    when (type_builder != null) {
      this.FinalizeType ();
      Passes.MarkTypeBuilderCompiled ();
    }
  }


  public FindAttribute (looking_for : TypeInfo) : option [PT.PExpr]
  {
    mutable result = None ();
    
    // find our attribute
    foreach (expr in GetModifiers ().custom_attrs)
      match (AttributeCompiler.ResolveAttribute (this.env, expr)) {
        | Some ((t, _)) =>
          when (looking_for.SameAs (t))
            result = Some (expr)
            
        | _ => ()
      }

    result
  }


  public override HasAttribute (attribute : TypeInfo) : bool
  {
     Option.IsSome (FindAttribute (attribute))
  }
  
  /** Nemerle.Reflection  interfaces */


  /* ---------------------------------------------------------------------- */
  /* -- VALIDITY CHECKS --------------------------------------------------- */
  /* ---------------------------------------------------------------------- */

  /**
   * Performs access attributes related checks. Returns an optional
   * description of the problem.
   */
  internal static CheckAccessAttributes (attrs : NemerleAttributes) : option [string]
  {
    def access_attrs_count =
      (if (attrs %&& NemerleAttributes.Public)    1 else 0) +
      (if (attrs %&& NemerleAttributes.Internal)  1 else 0) +
      (if (attrs %&& NemerleAttributes.Protected) 1 else 0) +
      (if (attrs %&& NemerleAttributes.Private)   1 else 0);

    def is_protected_internal =
      attrs %&& NemerleAttributes.Internal &&
      attrs %&& NemerleAttributes.Protected &&
      access_attrs_count == 2;
       
    if (access_attrs_count <= 1 || is_protected_internal)
      None ()
    else
      Some ("inconsistent access attributes specified")
  }


  /**
   * Performs attributes checks for method definitions.
   */
  internal CheckMethodAttributes (meth : NemerleMethod) : void
  {
    def attributes = meth.Attributes;
    def loc = meth.Location;

    when (is_interface) {
      unless (meth.HasAbstractBody)
        Message.error (loc, "interface method cannot have body");
      match (meth.GetFunKind ()) {
        | FunKind.Method (_ :: _) =>
          Message.error (loc, "interface method cannot implement anything");
        | _ => ()
      }
    }
    
    // only allow static methods to be extern
    def meth_is_instance =
      !(attributes %&& NemerleAttributes.Static);
            
    when (meth_is_instance && meth.HasExternBody)
      Message.fatal_error (loc, "only static methods are allowed to be extern: " +
                           describe_member (meth));      

    // only allow abstract methods to have abstract bodies
    def meth_is_abstract =
      attributes %&& NemerleAttributes.Abstract;

    when (meth.HasAbstractBody && !meth_is_abstract)
      Message.fatal_error (loc, "missing body of a non-abstract method: " +
                     describe_member (meth));
                           
    // most of the checks are common with the properties and events:
    check_method_like_attributes ((meth :> IMember), "method", "methods")
  }


  /**
   * Performs attributes checks for properties definitions.
   */
  internal CheckPropertyAttributes (prop : NemerleProperty) : void
  {
    def attributes = prop.Attributes;
    def loc = prop.Location;

    // make sure no static indexers get defined
    def prop_is_static =
      attributes %&& NemerleAttributes.Static;
    
    when (prop_is_static && prop.IsIndexer)
      Message.fatal_error (loc, "indexer properties are not allowed to be static: " +
                           describe_member (prop));
    
    // most of the checks are common with the methods and events:
    check_method_like_attributes ((prop :> IMember), "property", "properties")
  }
  

  /**
   * Performs attributes checks for events definitions.
   */
  internal CheckEventAttributes (evt : NemerleEvent) : void
  {
    // most of the checks are common with the properties and methods:
    check_method_like_attributes ((evt :> IMember), "event", "events")
  }

  
  /**
   * Performs the attributes checks that are common to methods and properties
   */
  private check_method_like_attributes (mem : IMember, title : string,
                                        title_plural : string) : void
  {                                               
    def attributes = mem.Attributes;
    def loc = mem.Location;
    
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for " + title + ": " + describe_member (mem))
    }

    check_for_invalid_attr (NemerleAttributes.Mutable, "mutable");
    check_for_invalid_attr (NemerleAttributes.Module, "module");
    check_for_invalid_attr (NemerleAttributes.Struct, "struct");
    check_for_invalid_attr (NemerleAttributes.Macro, "macro");
    check_for_invalid_attr (NemerleAttributes.Volatile, "volatile");

    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for " + title + ": " + describe_member (mem))
      | _ => ()
    }
    
    // make sure 'virtual', 'new' and 'override' never appear at once 
    def mem_is_virtual =
      attributes %&& NemerleAttributes.Virtual;

    def mem_is_new =
      attributes %&& NemerleAttributes.New;

    def mem_is_override =
      attributes %&& NemerleAttributes.Override;

    when (mem_is_override && mem_is_new)
      Message.fatal_error (loc, "both `override' and `new' attributes specified for " +
                           title + ": " + describe_member (mem));

    // only allow 'override' methods/properties/events to be 'sealed'
    def mem_is_sealed =
      attributes %&& NemerleAttributes.Sealed;

    when (mem_is_sealed && !mem_is_override)
      Message.fatal_error (loc, "only `override' " + title + " are allowed to be `sealed': " +
                           describe_member (mem));
                           
    // do not allow new virtual methods/properties/events in sealed clases
    def type_is_sealed =
      this.modifiers.mods %&& NemerleAttributes.Sealed;

    when (type_is_sealed && mem_is_virtual && !mem_is_override && !IsDelegate)
      Message.fatal_error (loc, mem.Name +
                           " is a new virtual member in a sealed class " +
                           this.FullName);

    // do not allow private abstract methods
    def mem_is_private =
      attributes %&& NemerleAttributes.Private;

    def mem_is_abstract =
      attributes %&& NemerleAttributes.Abstract;
            
    when (mem_is_abstract && mem_is_private)
      Message.fatal_error (loc, "abstract " + title_plural + " are not allowed to be private: " +
                           describe_member (mem));      

    // do not allow private 'virtual' or 'override' methods/properties/events
    when (mem_is_virtual && mem_is_private)
      Message.fatal_error (loc, "virtual " + title_plural + " are not allowed to be private: " +
                           describe_member (mem));      
    
    when (mem_is_override && mem_is_private)
      Message.fatal_error (loc, "override " + title_plural + " are not allowed to be private: " +
                           describe_member (mem));      
                           
    // do not allow to mix abstract with the 'override' modifier
    when (mem_is_abstract && mem_is_override)
      Message.fatal_error (loc, "abstract " + title_plural + " are not allowed to have the " +
                           "'override' modifier: " + describe_member (mem));      

    // static methods/properties cannot be abstract, virtual or override
    def mem_is_static =
      attributes %&& NemerleAttributes.Static;
      
    when ((mem_is_abstract || mem_is_virtual || mem_is_override) && mem_is_static)
      Message.fatal_error (loc, "static " + title_plural + " are not allowed to be abstract, " +
                           "virtual or override: " + describe_member (mem));

    // do not allow protected and protected internal methods in structures
    when (this.is_struct && (attributes %&& NemerleAttributes.Protected))
    {
      def msg =
        if (attributes %&& NemerleAttributes.Internal)
          "protected internal"
        else
          "protected";
          
      Message.fatal_error (loc, title_plural + " defined in a struct are not allowed to be " +
                           msg + ": " + describe_member (mem))
    }
  }


  /**
   * Performs attributes checks for field definitions.
   */
  internal CheckFieldAttributes (fld : NemerleField) : void
  {
    def attributes = fld.Attributes;
    def loc = fld.Location;
    
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for field: " + describe_member (fld))                           
    }

    check_for_invalid_attr (NemerleAttributes.Abstract, "abstract");
    check_for_invalid_attr (NemerleAttributes.Virtual, "virtual");
    check_for_invalid_attr (NemerleAttributes.Sealed, "sealed");
    check_for_invalid_attr (NemerleAttributes.Override, "override");
    check_for_invalid_attr (NemerleAttributes.Module, "module");
    check_for_invalid_attr (NemerleAttributes.Struct, "struct");
    check_for_invalid_attr (NemerleAttributes.Macro, "macro");
    
    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for field: " + describe_member (fld))
      | _ => ()
    }

    // check for non-mutable / volatile consistency
    def is_mutable =
      attributes %&& NemerleAttributes.Mutable;

    def is_volatile =
      attributes %&& NemerleAttributes.Volatile;

    when (!is_mutable && is_volatile)
      Message.fatal_error (loc, "only mutable fields are allowed to be volatile: " +
                           describe_member (fld));

    // do not allow protected and protected internal methods in structures
    when (this.is_struct && (attributes %&& NemerleAttributes.Protected))
    {
      def msg =
        if (attributes %&& NemerleAttributes.Internal)
          "protected internal"
        else
          "protected";
          
      Message.fatal_error (loc, "fields defined in a struct are not allowed to be " +
                           msg + ": " + describe_member (fld))
    }
  }


  /**
   * Performs attributes checks for type definitions.
   */
  internal CheckTypeAttributes () : void
  {
    def title =
      if (this.is_interface) "interface" else (if (this.is_struct) "struct" else "type");
        
    def attributes = Attributes;
    
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {      
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for " + title + ": " + FullName)                           
    }
    
    check_for_invalid_attr (NemerleAttributes.Virtual, "virtual");
    check_for_invalid_attr (NemerleAttributes.Override, "override");
    check_for_invalid_attr (NemerleAttributes.Mutable, "mutable");
    check_for_invalid_attr (NemerleAttributes.Volatile, "volatile");
    check_for_invalid_attr (NemerleAttributes.Static, "static");

    // some extra checks for structs and interfaces
    when (this.is_interface || this.is_struct)
    {
      check_for_invalid_attr (NemerleAttributes.Abstract, "abstract");
      check_for_invalid_attr (NemerleAttributes.Sealed, "sealed");
      check_for_invalid_attr (NemerleAttributes.Module, "module");
      check_for_invalid_attr (NemerleAttributes.Macro, "macro")
    }
    
    // some extra checks for interfaces
    when (this.is_interface)
    {
      check_for_invalid_attr (NemerleAttributes.Struct, "struct")
    }
    
    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for type: " + FullName)
      | _ => ()
    }

    // different limitations apply to top-level and nested types
    def type_is_protected_internal =
      attributes %&& NemerleAttributes.Protected &&
      attributes %&& NemerleAttributes.Internal;
      
    def type_is_protected =
      !type_is_protected_internal && attributes %&& NemerleAttributes.Protected;
      
    def type_is_private =
      attributes %&& NemerleAttributes.Private;

    def type_is_top_level =
      !Option.IsSome (enclosing_type);

    // top-level classes can only be public or internal
    when (type_is_top_level && (type_is_protected_internal || type_is_protected || type_is_private))
      Message.fatal_error (loc, "top level " + title + "s are only allowed to be public or internal: " +
                           FullName);

    // top-level classes are not allowed to be `new'
    def type_is_new =
      attributes %&& NemerleAttributes.New;
      
    when (type_is_top_level && type_is_new)
      Message.fatal_error (loc, "only nested " + title +"s are allowed to `new': " + FullName);

    // types cannot be abstract and sealed at the same time
    def type_is_abstract =
      attributes %&& NemerleAttributes.Abstract;

    def type_is_sealed =
      attributes %&& NemerleAttributes.Sealed;

    when (type_is_abstract && type_is_sealed)
      Message.fatal_error (loc, title + "s are not allowed to be abstract and sealed at the same time: " +
                           FullName)
  }

  public DisableImplicitConstructor () : void
  {
    instance_ctor_occured = true;
  }
  
  /**
   * Marks this with the SpecialName attribute, the attribute will
   * be propagated to members and contained types at a later stage.
   */
  public MarkWithSpecialName () : void
  {
    modifiers.mods = modifiers.mods %| NemerleAttributes.SpecialName
  }

  
  /**
   * Propagates the SpecialName mark throughout the member hierarchy
   */
  private mark_members_with_special_name () : void
  {
    foreach (member : IMember in member_list)
      match (member) {
        | nm : NemerleMember =>  nm.MarkWithSpecialName ()
        | _ => ()
      }

    foreach (tb : TypeBuilder in contained_types)
      tb.MarkWithSpecialName ();
  }
}

} // ns
