
using Nemerle.Collections;
using System;

variant RedBlackTree
{
	| Red { left : RedBlackTree; value : int; right : RedBlackTree; }
	| Black { left : RedBlackTree; value : int; right : RedBlackTree; }
	| Leaf { value : int; }
}

variant SomeLargeVariant
{
  | SLV_Zero
  | SLV_One
  | SLV_Two { value : int; }
  | SLV_Three { value : int; }
  | SLV_Four { value : int; }
  | SLV_Five { value : int; }
  | SLV_Six { value : int; }
  | SLV_Seven { value : int; }
  | SLV_Eight { value : int; }
  | SLV_Nine { value : int; }
  | SLV_Ten { value : int; }
  | SLV_Eleven { value : int; }
}

public class MatchingOverCons
{
	static TestA (rbt : RedBlackTree) : void 
	{
		match (rbt) {
			| Red => Console.WriteLine ("Red")
			| Black => Console.WriteLine ("Black")
			| Leaf => Console.WriteLine ("Leaf")
		}
	}

	static TestB (rbt : RedBlackTree) : void 
	{
		match (rbt) {
			| Red (Leaf (i), _, _) => Console.WriteLine ("Red / Leaf: " + i.ToString ())
			| Black (Leaf, _, _) => Console.WriteLine ("Black / Leaf")
			| Black (Red, _, _) => Console.WriteLine ("Black / Red")
			| Black (Black, _, _) => Console.WriteLine ("Black / Black")
			| Leaf (i) => Console.WriteLine ("Leaf: " + i.ToString ())
      | _ => Console.WriteLine ("[FAILED]")
		}
	}
	
	static TestC (some_list : list <int>) : void
	{
	  def msg =
	    match (some_list) {
	      | [] => "empty list"
	      | [_] => "one element"
	      | [_, _] => "two elements"
	      | x => List.Length (x).ToString () + " elements"	  
  	  };
  	  
  	Console.WriteLine (msg)
	}

  static TestD (rbt : RedBlackTree) : void
  {
    def result =
      match (rbt) {
        | Leaf (7) => "7"
        | Leaf (i) => (-i).ToString ()
        | _ => "[FAILED]"
      };
      
    Console.WriteLine ("TestD: " + result)
  }

  public variant mylist <'a> 
  {
    | MyCons { hd : 'a; tl : mylist <'a>; }
    | MyNil {} 
  }
  
  public static MyNth<'a> (l : mylist <'a>, n : int) : 'a {
    match (l) {
      | MyCons (h, t) => if (n == 0) h else MyNth (t, n - 1)
      | MyNil => throw System.ArgumentOutOfRangeException ("List.Nth")
    }
  }

  static TestE (slv : SomeLargeVariant) : void
  {
    def result =
      match (slv) {
        | SLV_Three => "three"
        | _ => "something else"
      };
      
    Console.WriteLine ("TestE: " + result)
  }

  static TestF (slv : SomeLargeVariant) : void
  {
    def result =
      match (slv) {
        | SLV_Three => "three"
        | SLV_Four => "four"
        | _ => "something else"
      };
      
    Console.WriteLine ("TestF: " + result)
  }


  static TestG (slv : SomeLargeVariant) : void
  {
    def result =
      match (slv) {
        | SLV_Zero => "zero"
        | SLV_One => "one"
        | SLV_Three => "three"
        | _ => "something else"
      };
      
    Console.WriteLine ("TestG: " + result)
  }


	static Main () : void
	{
		TestA (Red (Leaf (0), 1, Leaf (2)));
		TestA (Black (Leaf (3), 4, Leaf (5)));
		TestA (Leaf (6));

		TestB (Red (Leaf (0), 1, Leaf (2)));
		TestB (Black (Leaf (0), 1, Leaf (2)));
		TestB (Black (Red (Leaf (3), 4, Leaf (5)), 6, Leaf (7)));
		TestB (Black (Black (Leaf (3), 4, Leaf (5)), 6, Leaf (7)));
		TestB (Leaf (8));
		
		TestC ([3, 4]);
		TestC ([1]);
		TestC ([]);
		TestC ([6, 7, 8, 9, 10]);

		TestD (Leaf (8));
		TestD (Leaf (7));
		TestD (Leaf (6));
		
		TestE (SLV_Three (10));
		TestE (SLV_Four (7));
		TestF (SLV_Three (10));
		TestF (SLV_Four (7));
		TestF (SLV_Five (13));
		TestG (SLV_Zero ());
		TestG (SLV_One ());
		TestG (SLV_Three (7));
		TestG (SLV_Five (13));
	}
}

/*
BEGIN-OUTPUT 
Red
Black
Leaf
Red / Leaf: 0
Black / Leaf
Black / Red
Black / Black
Leaf: 8
two elements
one element
empty list
5 elements
TestD: -8
TestD: 7
TestD: -6
TestE: three
TestE: something else
TestF: three
TestF: four
TestF: something else
TestG: zero
TestG: one
TestG: four
TestG: something else
END-OUTPUT
*/
