/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is the main compiler file. But all it does it running parser
 * (parser.n) and transferring control to Passes.run function (from
 * passes.n).
 *
 * Main file also catches some exceptions.
 */

using Nemerle.Collections;
using Nemerle.Utility;

namespace Nemerle.Compiler 
{
  module MainClass
  {
    public Main () : void
    {
      try
        do_main ()
      with {
        | e : System.IO.FileNotFoundException =>
          Message.error (e.Message)
        | e : Recovery =>
          bomb (e, "got Recovery exception")
        | e : Invalid_argument =>
          bomb (e, "got Invalid_argument (" + e.msg + ")")
        | e : Match_failure =>
          bomb (e, "got Match_failure exception")
        | e : ICE =>
          bomb (e, e.msg)
        | e : Assertion_failed =>
          bomb (e, "assertion failed " + e.msg)
        | e : System.Exception =>
          bomb (e, "got some unknown exception " + e.ToString ())
      };

      Message.maybe_bailout();
    }
    
    bomb (e : System.Exception, msg : string) : void
    {
      Message.maybe_bailout (true);
      print_string ("internal compiler error: " + msg + "\n" + e.StackTrace);
      System.Environment.Exit (2);
    }

    do_main () : void {
      mutable files <- [];
      mutable no_macros <- false;
      mutable no_stdlib <- false;

      def print_version () {
        System.Console.Error.Write ("Nemerle Compiler (ncc) version 0.0.1\n" +
                                    "(c) 2003, 2004 University of Wroclaw, All rights reserved.\n");
        System.Environment.Exit (0);
      };

      def opts = [
        Getopt.Flag      (name = "-xml", 
                          aliases = ["-x"], 
                          help = "Output XML representation of AST (for documentation)",
                          handler = fun () { Flags.just_dump_xml <- true; });
        Getopt.Flag      (name = "-target-exe", 
                          aliases = ["-texe"],
                          help = "Build an executable file",
                          handler = fun () { Flags.target_is_library <- false; });
        Getopt.Flag      (name = "-target-library", 
                          aliases = ["-tdll"], 
                          help = "Build a library",
                          handler = fun () { Flags.target_is_library <- true; });
        Getopt.String    (name = "-out",
                          aliases = [],
                          help = "Output file name",
                          handler = fun (s) { Flags.output_file_name <- s });
        Getopt.String    (name = "-reference",
                          aliases = ["-r"; "-ref"],
                          help = "Link specified assembly",
                          handler = fun (s) { Flags.referenced_libraries <- 
                                                        s :: Flags.referenced_libraries });
        Getopt.Flag      (name = "-no-stdmacros",
                          help = "Do not load standard macros",
                          handler = fun () { no_macros <- true });
        Getopt.Flag      (name = "-no-stdlib",
                          help = "Do not load Nemerle.dll",
                          handler = fun () { no_stdlib <- true });
        Getopt.Flag      (name = "-ignore-confusion",
                          help = "Output stack trace even when seen errors",
                          handler = fun () { Flags.ignore_confusion <- true });
        Getopt.Flag      (name = "-no-tail-call-opt",
                          help = "Disable tail call optmization",
                          handler = fun () { Flags.tail_call_opt <- false });
        Getopt.Flag      (name = "-no-self-tail-call-opt",
                          help = "Disable self tail call optmization",
                          handler = fun () { Flags.self_tail_call_opt <- false });
        Getopt.Flag      (name = "-general-tail-call-opt",
                          aliases = ["-Ot"],
                          help = "Enable general tail call optmization",
                          handler = fun () { Flags.general_tail_call_opt <- true });
        Getopt.Flag      (name = "-no-pedantic-lexer",
                          help = "Disable some pedantic checks for illegal characters in input stream",
                          handler = fun () { Flags.pedantic_lexer <- false });
        Getopt.Flag      (name = "-version",
                          aliases = ["-V"],
                          help = "Output version information and exit",
                          handler = print_version);
        Getopt.Flag      (name = "-no-progress-bar",
                          aliases = ["-q"],
                          help = "Disable progress bar",
                          handler = fun () { Flags.progress_bar <- false; });
        Getopt.NonOption (name = "",
                          help = "Specify file to compile",
                          handler = fun (s) { files <- s :: files });
      ];

      Getopt.Parse (opts);

      match (files) {
        | [] =>
          Getopt.Error ("need at least one file to compile\n" + Getopt.Usage (opts))
        | _ =>
          unless (no_macros)
            LibraryReferenceManager.LoadMacrosFrom ("stdmacros");

          unless (no_stdlib)
            LibraryReferenceManager.AddLibrary (LibraryReference ("Nemerle"));

          List.iter (fun (name) { LibraryReferenceManager.AddLibrary (LibraryReference (name)) },
                     List.rev (Flags.referenced_libraries)); 
                 
          def trees = List.map (fun (f) { Parser.parse (Lexer (f)) }, 
                                List.rev (files));

          Passes.run (trees)
      }
    }
  }
}
