/*
 * Copyright (c) 2004, 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Matching
 */
using Nemerle.Collections;

using Nemerle.Compiler.CompileTypedTree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.MatchingCompiler;

using System.Reflection;
using System.Reflection.Emit;

namespace Nemerle.Compiler 
{
  /**
   * A match effect
   */
  class MatchEffect
  {
    public this (index : int, effect : TExpr)
    {
      m_index = index;
      m_effect = effect;
    }
    
    [Nemerle.Assertions.Ensures (value >= 0)]
    public GetIndex () : int
    {
      m_index
    }
    
    public GetEffect () :TExpr
    {
      m_effect
    }

#if EXTRAMATCHINGDEBUG    
    public Dump () : void
    {
      Message.Debug ("MatchEffect::Dump: " + m_index.ToString ());
    }
#endif 
            
    private mutable m_index : int;
    private mutable m_effect :TExpr;
  }
  
  
  /**
   * Top-level pattern with a guard and effect index
   */
  class MatchClause
  {
    public this (pattern : Pattern, guard : TExpr, effect : int)
    {
      m_pattern = pattern;

      if (guard_is_always_true (guard))
        m_guard = None ()
      else
        m_guard = Some (guard);

      m_effect = effect;
    }
        
    public GetPattern () : Pattern
    {
      m_pattern
    }
    
    public GetEffect () : int
    {
      m_effect
    }      

    private guard_is_always_true (guard : TExpr) : bool
    {
      match (guard) {
        | TExpr.Literal (Literal.Bool (true)) => 
          true
          
        | _ =>
          false
      }
    }

    public Dump () : void
    {
      def dump_pattern (pattern : Pattern) 
      {      
        match (pattern) {
          | Pattern.Wildcard => 
            "Wildcard"

          | Pattern.As (as_pattern, decl) => 
            "As (" + dump_pattern (as_pattern) + ", '" + decl.Name + "')"

          | Pattern.Tuple (args) =>
            "Tuple {" + List.FoldLeft (
              args, "", 
              fun (tuple_pattern, desc : string) { 
                (if (desc.Length > 0) desc + ", " else "") + dump_pattern (tuple_pattern)
              }
            ) + "}"

          | Pattern.Record (args) =>
            "Record {" + List.FoldLeft (
              args, "", 
              fun (field_and_tuple_pattern, desc) {
                def (field, tuple_pattern) = field_and_tuple_pattern;
                                                
                (if (desc.Length > 0) desc + ", " else "") +
                 field.Name + ":" + dump_pattern (tuple_pattern)
              }
            ) + "}"

          | Pattern.Application (name, arg) =>
            "Application (" + name.FullName + ", " + dump_pattern (arg) + ")"

          | Pattern.Enum (fld, l) =>
            $ "Enum ($(fld.Name), $l)"
            
          | Pattern.Literal (l) =>
            $ "Literal ($l)"

          | Pattern.HasType (t) =>
            "HasType (" + t.FullName + ")"

          | Pattern.Error => "Error"
        }
      };
    
      Message.Debug ("MatchClause::Dump: " + dump_pattern (m_pattern))
    }


    /**
     * Builds a pattern-matcher expression
     */
    public BuildMatchExpr (ctx : CTX, 
                           vals : SystemMap [int, CG_val], 
                           val : CExpr) : CTX * SystemMap [int, CG_val] * CExpr 
    {
      m_vals = vals;
      m_ctx = ctx;
      
      def pattern_expr =
        Util.locate (m_pattern.Location, build_pattern_expr (val, m_pattern, true));

      def guarded_expr =
        if (Option.IsSome (m_guard))
          CExpr.If (SystemType.Boolean,
                 pattern_expr,
                 cg_expr (m_ctx, Option.UnSome (m_guard)),
                 CExpr.FalseLiteral)
        else
          pattern_expr;
        
      (m_ctx, m_vals, guarded_expr)
    }


    /**
     * Builds an expression that evaluates to true if the pattern is a value
     */
    private build_pattern_expr (val : CExpr, pattern : Pattern, is_top_level : bool) : CExpr
    {
      match (pattern) {
        | Pattern.Error => assert (false)

        | Pattern.Wildcard => 
          //FIXME: check for non-nullness of non-value types
          CExpr.TrueLiteral

        | Pattern.Literal (lit) =>
          MatchingCompiler.emit_compare_with (val, lit)
        
        | Pattern.HasType (ti) =>
          CExpr.HasType (val, ti.GetSystemType ())

        | Pattern.Application (cons_name, Pattern.Wildcard) =>
          assert (! (cons_name.GetTydecl () is TypeDeclaration.Alias));

          if (is_top_level)
            // no nullness check is required here -- it is guaranteed by the effects switch
            CExpr.TrueLiteral
          else {
            def tyname = cons_name.GetSystemType ();
            CExpr.HasType (val, tyname)
          }
          
        | Pattern.Application (cons_name, subpattern) =>
          assert (! (cons_name.GetTydecl () is TypeDeclaration.Alias));

          def tyname = cons_name.GetSystemType ();
          def cast_expr = CExpr.Cast (val, tyname, true);

          if (is_top_level) {
            // no nullness check is required here -- it is guaranteed by the effects switch
            build_pattern_expr (cast_expr, subpattern, false)
          }
          else {
            def has_type_expr = CExpr.HasType (val, tyname);
                    
            CExpr.If (SystemType.Boolean,          
                      has_type_expr,
                      build_pattern_expr (cast_expr, subpattern, false),
                      CExpr.FalseLiteral)
          }

        | Pattern.As (subpattern, decl) =>
          unless (decl.InClosure)
            match (m_vals.Find (decl.Id)) {
              | Some => ()
              | None =>
                def (new_ctx, v) = store_local (m_ctx, decl, CExpr.Nop ());
                m_ctx = new_ctx;
                m_vals = m_vals.Add (decl.Id, v);
            };
              
          def assign_expr = 
            CExpr.Assign (MatchingCompiler.local_ref (m_ctx, decl),
                          maybe_cast (m_ctx, decl.Type.Fix ().GetSystemType (), val));

          match (build_pattern_expr (val, subpattern, false)) {
            | (CExpr.If (c, e_then, e_else)) as e =>
              CExpr.If (e.ty, c, CExpr.Sequence ([assign_expr, e_then]), e_else)
            | expr =>
              CExpr.If (SystemType.Boolean, expr, 
                        CExpr.Sequence ([assign_expr, CExpr.TrueLiteral]), CExpr.FalseLiteral)
          }

        | Pattern.Tuple (args) =>
          def len = List.Length (args);

          def f (arg, acc)
          {
            def (pos, ex) = acc;
            def cond = 
              build_pattern_expr (
                CompileTypedMethod.tuple_ref (CExpr.Cast (val, CompileTypedMethod.tuple_type (len),
                                                          true), pos, len), 
                arg, 
                false
              );
                                  
            (pos - 1, CExpr.If (SystemType.Boolean, 
                                cond, ex, CExpr.FalseLiteral))
          };

          def ini = (len, CExpr.TrueLiteral);            
          def (_, ex) = List.FoldLeft (List.Rev (args), ini, f);
          ex
            
        | Pattern.Record (args) =>
          def val = CExpr.Cast (val, pattern.GetSystemType (), true);
            
          def f (np, ex) 
          {
            def (name, pat) = np;
            def cond = 
              build_pattern_expr (build_record_field_ref (val, name), pat, false);
              
            CExpr.If (SystemType.Boolean, cond, ex, CExpr.FalseLiteral)
          };
          
          List.FoldLeft (List.Rev (args), CExpr.TrueLiteral, f)

        | Pattern.Enum => assert (false)
      }
    }
    
    private mutable m_pattern : Pattern;
    private mutable m_guard : option [TExpr];
    private mutable m_effect : int;

    private mutable m_vals : SystemMap [int, CG_val];
    private mutable m_ctx : CTX;
  }



  /* -- MATCH COLLECTOR ---------------------------------------------------- */
  
  /**
   * Collects match effects and clauses
   */
  class MatchCollector
  {
    public this (matchType : System.Type, ctx : CTX, cases : list [Match_case])
    {
      m_ctx = ctx;
      m_vals = SystemMap ();
      m_matchType = matchType;
      
      collect_cases (cases, [], 0, [])
    }
  
    public GetClauses () : list [MatchClause]
    {
      m_clauses
    }

    public IsTopLevelMatchingOverCons () : bool
    {
      def walk_clauses (clauses : list [MatchClause]) 
      {
        | [] => false            
        | clause :: rest =>
          match (clause.GetPattern ()) {
            | Pattern.Application => true
            | _ => walk_clauses (rest)
          } 
      };
      
      walk_clauses (m_clauses)
    }
  
    public GetTopLevelConsName () : TypeInfo
    {
      assert (IsTopLevelMatchingOverCons ());

      def walk_clauses (clauses : list [MatchClause]) 
      {
        | [] => Util.ice ("MatchCollector::GetTopLevelConsName")
        | clause :: rest =>
          match (clause.GetPattern ()) {
            | Pattern.Application (name, _) => name
            | _ => walk_clauses (rest)
          } 
      };
      
      walk_clauses (m_clauses)
    }

    public BuildEffectsSwitch (ctx : CTX, matching_expr : CExpr) : CExpr
    {
      def walk_effects (effects : list [MatchEffect]) : list [int * CExpr]
      {
        | [] => []
        | effect :: rest =>
          def effect_expr = cg_expr (ctx, effect.GetEffect ());
          
          (effect.GetIndex (), effect_expr) :: walk_effects (rest)
      };

      def match_failure_expr =
        CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []));

      CExpr.Switch (
        m_matchType,
        matching_expr,
        Some (match_failure_expr),
        walk_effects (m_effects)
      )
    }


    private collect_cases (cases : list [Match_case], 
                           effects : list [MatchEffect], 
                           effects_counter : int,
                           clauses : list [MatchClause]) : void
    {
      match (cases) {
        | [] =>
          m_effects = List.Rev (effects);
          m_clauses = List.Rev (clauses)
          
        | case :: rest =>
          def walk_patterns (patterns : list [Pattern * TExpr], 
                             new_clauses : list [MatchClause]) {
            match (patterns) {
              | [] => new_clauses // they will be reversed when all cases are processed
              | (pattern, guard) :: rest =>
                def new_clause =
                  MatchClause (
                    pattern, 
                    guard, 
                    effects_counter
                  );
                          
                walk_patterns (rest, new_clause :: new_clauses) 
            }                             
          };
    
          def new_effect =
            MatchEffect (
              effects_counter, 
              case.body
            );
            
          def new_clauses = walk_patterns (case.patterns, []);
                  
          collect_cases (
            rest, 
            new_effect :: effects, 
            effects_counter + 1, 
            List.Append (new_clauses, clauses)
          )
      }
    }
  
    private mutable m_effects : list [MatchEffect];
    private mutable m_clauses : list [MatchClause];

    private mutable m_vals : SystemMap [int, CG_val];
    private mutable m_matchType : System.Type;
    private mutable m_ctx : CTX;
  }



  /* ----------------------------------------------------------------------- */
  /* -- MATCHING PROBLEM CATEGORIZATION ------------------------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Recognized matching problem categories
   */
  variant MatchProblemCategory {
    | Cons_list_like
    | Cons_tree_like
    | Cons_sparse
    | Cons_sparse_with_const
    | Cons_general
    | Other
  }


  /**
   * A set of heuristics used to categorize matching problems.
   */
  class MatchProblemCategorizer
  {
    public this (variant_options : list [TypeInfo], match_collector : MatchCollector)
    {
      m_variant_options = variant_options;
      m_match_collector = match_collector;
          
      categorize_match_problem ()
    }
    
    
    /**
     * Returns the category of the matching problem
     */
    public GetCategory () : MatchProblemCategory
    {
#if EXTRAMATCHINGDEBUG
      Message.Debug ("MatchProblemCategorizer::GetCategory: " + m_category.ToString ());
#endif

      m_category
    }
    
    
    /**
     * Returns the list of constant variants
     */
    public GetConstVariants () : list [TypeInfo * FieldInfo]
    {
      m_const_variants
    }


    /**
     * Returns the list of used const variants
     */
    public GetConstVariantsUsed () : list [TypeInfo * FieldInfo]
    {
      m_const_variants_used
    }


    /**
     * Returns the list of used non-const variants
     */
    public GetNonConstVariantsUsed () : list [TypeInfo]
    {
      m_non_const_variants_used    
    }
    
    
    /*
     * Calculates some statistics on the variant options. 
     * Collect the field infos of the const variants for later use.
     */
    private calculate_variant_statistics (variant_options : list [TypeInfo]) : void
    {
      match (variant_options) {
        | variant_option :: rest =>
          match (MatchingCompiler.get_constant_object (variant_option)) {
            | Some (const_variant_field_info) => 
              m_const_variant_names =
                m_const_variant_names.Add (variant_option.FullName, 0);

              m_const_variants =
                (variant_option, const_variant_field_info) :: m_const_variants;

              ++m_const_variants_count
              
            | _ => ()
          };

          m_variant_names =
            m_variant_names.Add (variant_option.FullName, 0);
          
          m_variants_lookup =
            m_variants_lookup.Add (variant_option.FullName, variant_option);
          
          calculate_variant_statistics (rest)
          
        | [] => ()
      }
    }


    /*
     * Calculates some statistics on clauses
     */    
    private calculate_clause_statistics (clauses : list [MatchClause]) : void
    {
      def increase_occurence_count (name : string)
      {
        def occurence_count =
          m_variant_names.Get (name);
    
        m_variant_names =
          m_variant_names.Replace (name, occurence_count + 1);
      
        ++m_cons_patterns_count;
      };

      def increase_const_occurence_count (name : string)
      {
        def occurence_count =
          m_const_variant_names.Get (name);
    
        m_const_variant_names =
          m_const_variant_names.Replace (name, occurence_count + 1);
      
        ++m_const_cons_patterns_count;
      };
      
      def classify_pattern (pattern : Pattern) : void
      {
        match (pattern) {
          | Pattern.As (subpattern, _) => 
            classify_pattern (subpattern)
            
          | Pattern.Application (name, _) =>
            def name = 
              name.FullName;
                    
            increase_occurence_count (name);
            
            when (m_const_variant_names.Member (name))
              increase_const_occurence_count (name);
            
          | _ => ()
        }
      };
      
      match (clauses) {
        | clause :: rest =>
          ++m_patterns_count;
          classify_pattern (clause.GetPattern ());
                  
          calculate_clause_statistics (rest)
          
        | [] => ()      
      }
    }


    /*
     * Calculates how many variants have actually been used in clauses
     */
    private count_unique_variants_in_clauses () : void
    {
      def variant_iterator (key : string, value : int) : void
      {
        when (value != 0) {
          def variant_option =
            m_variants_lookup.Get (key);

          ++m_unique_cons_patterns_count;
          
          match (m_const_variant_names.Find (key)) {
            | Some (value) when value != 0 =>                
              def const_variant_field_info =
                Option.UnSome (MatchingCompiler.get_constant_object (variant_option));
                
              m_const_variants_used =
                (variant_option, const_variant_field_info) :: m_const_variants_used;
            
              ++m_unique_const_cons_patterns_count
              
            | _ =>
              m_non_const_variants_used =
                variant_option :: m_non_const_variants_used
          }
        }
      };
      
      m_variant_names.Iter (variant_iterator)
    }


    /*
     * Applies some heuristics to categorize the matching problem
     */    
    private categorize_match_problem () : void
    {
      // step one: count the variants
      m_variants_count = List.Length (m_variant_options);
      
      calculate_variant_statistics (m_variant_options);

      // step two: count the patterns      
      calculate_clause_statistics (m_match_collector.GetClauses ());
      
      // step three: check which variants have actually been used
      count_unique_variants_in_clauses ();
      
      // step four: given above statistics, decide the category of the problem
      m_category =
        if (m_variants_count == 0 || m_cons_patterns_count == 0)
          MatchProblemCategory.Other ()
        else {
          if (m_variants_count <= 2 && m_const_variants_count >= 1)
            MatchProblemCategory.Cons_list_like ()
          else if (m_variants_count == 3 && m_const_variants_count >= 1)
            MatchProblemCategory.Cons_tree_like ()
          else if (m_unique_cons_patterns_count <= 3 && 
                   m_unique_const_cons_patterns_count >= 1)
            MatchProblemCategory.Cons_sparse_with_const ()
          else if (m_unique_cons_patterns_count <= 2)
            MatchProblemCategory.Cons_sparse ()
          else
            MatchProblemCategory.Cons_general ()
        }      
    }


    // input data        
    private mutable m_variant_options : list [TypeInfo];
    private mutable m_match_collector : MatchCollector;

    // pattern statistics
    private mutable m_patterns_count : int;
    private mutable m_cons_patterns_count : int;
    private mutable m_const_cons_patterns_count : int;
    
    // unique variants in patterns statistics
    private mutable m_unique_cons_patterns_count : int;
    private mutable m_unique_const_cons_patterns_count : int;
    
    // variants statistics
    private mutable m_variants_count : int;
    private mutable m_const_variants_count : int;

    // names of the variants and their usage counts
    private mutable m_variant_names : SystemMap [string, int] = SystemMap ();
    private mutable m_const_variant_names : SystemMap [string, int] = SystemMap ();
    
    // the list of constant variant options
    private mutable m_const_variants : list [TypeInfo * FieldInfo] = [];
    
    // variants lookup table
    private mutable m_variants_lookup : SystemMap [string, TypeInfo] = SystemMap ();

    // the lists of constant/non-constant variants that actually have been used
    private mutable m_non_const_variants_used : list [TypeInfo] = [];
    private mutable m_const_variants_used : list [TypeInfo * FieldInfo] = [];
    
    // the calculated category of the matching problem
    private mutable m_category : MatchProblemCategory;
  }
  

  
  /* ----------------------------------------------------------------------- */
  /* -- MATCHING OVER VARIANT CONSTRUCTORS CODE GENERATOR ------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Matching over variant constructors code generator
   */
  class MatchingOverVariantCons
  {
    public this (ctx : CTX, val : CExpr, match_collector : MatchCollector)
    {
      m_ctx = ctx;
      m_val = val;
      m_vals = SystemMap ();    
      m_match_collector = match_collector;
    
      def (variant_options, variant_code_method_info) =
        fetch_variant_options ();

      m_variant_options = variant_options;
  
      m_variant_code_call_expr =
        CExpr.Call (SystemType.Int32, 
                    CExpr.MethodRef (val, variant_code_method_info, false), 
                    []);

      m_match_categorizer =
        MatchProblemCategorizer (variant_options, match_collector);
        
      match (m_match_categorizer.GetCategory ()) {
        | MatchProblemCategory.Cons_list_like => 
          create_list_like_matcher ()

        | MatchProblemCategory.Cons_sparse_with_const
        | MatchProblemCategory.Cons_sparse =>
          create_sparse_matcher ()

        | _ => create_general_matcher ()
      }
    }


    /**
     * Returns the resulting matcher
     */
    public GetMatcher () : CExpr
    {
      m_matcher
    }


    /**
     * Returns the method info for the _N_GetVariantCode method defined in a given tycon
     */
    private get_variant_code_method (variant_tycon : TypeInfo) : System.Reflection.MethodInfo 
    {
      def members = variant_tycon.LookupMember ("_N_GetVariantCode");
      
      match (members) {
        | [variant_code_method] =>
          (variant_code_method :> IMethod).GetMethodInfo ()
        
        | _ =>
          Util.ice ("MatchingOverVariantCons::get_variant_code_method: expected "
                    "exactly one _N_GetVariantCode method")
      }      
    }


    /**
     * Returns the list of variants we're matching over at the top level
     * and the info on the _N_GetVariantCode method.
     */
    private fetch_variant_options () : list [TypeInfo] * MethodInfo
    {
      def name = 
        m_match_collector.GetTopLevelConsName ();
        
      def variant_tycon =
        match (name.GetDirectSuperTypes ()) {
          | [ty] => ty.tycon
          | _ => Util.ice ("MatchingOverVariantCons::fetch_variant_options: "
                           "got more than one directsupertypes")
        };

      def variant_options =
        match (variant_tycon.GetTydecl ()) {
          | TypeDeclaration.Variant (members) => members
          | _ => Util.ice ("wrong tydecl in variant")
        };              

      (variant_options, get_variant_code_method (variant_tycon))
    }


    /**
     * Returns a list of clauses that have to do with a variant option
     */
    private collect_variant_related_clauses (variant_option : TypeInfo) : list [MatchClause]
    {
      def variant_full_name = variant_option.FullName;
        
      def walk_clauses (clauses : list [MatchClause], 
                        acc : list [MatchClause]) : list [MatchClause]
      {
        match (clauses) {
          | [] => List.Rev (acc)
            
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | Pattern.As (Pattern.Application (name, _), _)
              | Pattern.Application (name, _) =>
                if (name.FullName == variant_full_name)
                  walk_clauses (rest, clause :: acc)
                else
                  walk_clauses (rest, acc);

              | Pattern.As (Pattern.Wildcard, _) | Pattern.Wildcard  =>
                walk_clauses (rest, clause :: acc)

              | Pattern.As (Pattern.HasType (ty), _) | Pattern.HasType (ty) =>
                if (ty.Equals (variant_option))
                  walk_clauses (rest, clause :: acc)
                else
                  walk_clauses (rest, acc);

              | Pattern.Literal (Literal.Null) =>
                Message.FatalError ("sorry, null patterns are not yet supported in mix with variant options");
                //walk_clauses (rest, clause :: acc)
                 
              | _ =>
                clause.Dump ();
                Util.ice ("MatchingOverVariantCons::collect_variant_related_clauses: "
                          "wrong pattern (see the dump above)")
            }
        }
      };
      
      walk_clauses (m_match_collector.GetClauses (), [])
    }


    /**
     * Returns a list of clauses that do not have anything in common with a variant option
     */
    private collect_variant_unrelated_clauses () : list [MatchClause]
    {
      def walk_clauses (clauses : list [MatchClause], acc)
      {
        match (clauses) {
          | [] => List.Rev (acc)
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | Pattern.As (Pattern.Application, _) | Pattern.Application =>
                walk_clauses (rest, acc);

              | Pattern.As (Pattern.Wildcard, _) | Pattern.Wildcard =>
                walk_clauses (rest, clause :: acc)

              | Pattern.As (Pattern.HasType, _) | Pattern.HasType =>
                walk_clauses (rest, clause :: acc);
                
              | _ =>
                clause.Dump ();
                Util.ice ("MatchingOverVariantCons::collect_variant_unrelated_clauses: "
                          "wrong pattern (see the dump above)")
            }
        }
      };
      walk_clauses (m_match_collector.GetClauses (), [])
    }


    /**
     * Performs the last step of matcher generation: wraps the matcher
     * expression with CExpr.Define bindings of Pattern.As-induced variables.
     */
    private finalize_matcher (matcher : CExpr) : void
    {
      def mklet (_ : int, val : CG_val, acc : CExpr) : CExpr
      { 
        CExpr.Define (val, acc) 
      };
      
      m_matcher = m_vals.Fold (matcher, mklet)
    }
    

    /**
     * Binds clauses, creating an expression that evaluates to
     * an integer denoting the effect of each of the clauses.
     * We can perform a CExpr.Switch over that later.
     */
    private bind_clauses_for_switch (clauses : list [MatchClause]) : CExpr
    {
      match (clauses) {          
        | clause :: rest =>
          def (new_ctx, new_vals, clause_expr) =
            clause.BuildMatchExpr (m_ctx, m_vals, m_val);
            
          m_ctx = new_ctx;
          m_vals = new_vals;
            
          CExpr.If (SystemType.Boolean,          
                 clause_expr,
                 CExpr.Literal (Literal.FromInt (clause.GetEffect ())),
                 bind_clauses_for_switch (rest))

        | [] => CExpr.Literal (Literal.Integer (1, true, InternalType.Int32))
      }          
    }

    
    /**
     * Creates a sparse matcher for top-level variants.
     */
    private create_sparse_matcher () : void
    {
      // collects and bind clauses, builds the corresponding CExpr.HasType expression
      def process_variant (some_variant : TypeInfo) : CExpr * CExpr
      {
        def some_clauses =
          collect_variant_related_clauses (some_variant);

        def some_clauses_effect_expr =
          bind_clauses_for_switch (some_clauses);

        assert (! (some_variant.GetTydecl () is TypeDeclaration.Alias));
        
        def some_has_type_expr =
          CExpr.HasType (m_val, some_variant.GetSystemType ());
          
        (some_has_type_expr, some_clauses_effect_expr)
      };

      // get the matchers for the variant unrelated clauses
      def unrelated_clauses = collect_variant_unrelated_clauses ();

      def unrelated_clauses_effect_expr =
        match (unrelated_clauses) {
          | [] => CExpr.Literal (Literal.Integer (1, true, InternalType.Int32))
          | _ => bind_clauses_for_switch (unrelated_clauses)
        };
            
      // get the matchers for the variant options used
      def fold_non_const_variants (some_variant : TypeInfo, matcher_expr_acc : CExpr) : CExpr
      {
        def (some_has_type_expr, some_clauses_effect_expr) =
          process_variant (some_variant);

        CExpr.If (
          SystemType.Int32, 
          some_has_type_expr,
          some_clauses_effect_expr,
          matcher_expr_acc
        )        
      };
      
      def non_const_matcher_expr =
        List.FoldLeft (
          m_match_categorizer.GetNonConstVariantsUsed (), 
          unrelated_clauses_effect_expr,
          fold_non_const_variants
        );

      // build the comparers for the const variants
      def fold_const_variants (const_cons : TypeInfo * FieldInfo, matcher_expr_acc : CExpr) : CExpr
      {
        def (some_variant, const_cons_field_info) = 
          const_cons;
        
        def (_, some_clauses_effect_expr) =
          process_variant (some_variant);

        def compare_to_const_expr =
          CExpr.Call (SystemType.Boolean, CExpr.Opcode ("==.ref"),
                  [m_val, CExpr.GlobalRef (const_cons_field_info)]);
            
        CExpr.If (SystemType.Int32,
               compare_to_const_expr,
               some_clauses_effect_expr,
               matcher_expr_acc);
      };

      def matcher_expr =
        List.FoldLeft (
          m_match_categorizer.GetConstVariantsUsed (),
          CExpr.Sequence ([CExpr.NotNull (m_val), non_const_matcher_expr]),
          fold_const_variants
        );

      // builds the effects switch and wrap the matcher with appropriate CExpr.Defines
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, matcher_expr);

      finalize_matcher (effects_switch)      
    }


    /**
     * Creates a matcher for top-level list-like variants
     *
     * NOTE: we could have two constant constructors here
     */
    private create_list_like_matcher () : void
    {
      // get the tycons for the variant options
      def (const_cons_tycon, const_cons_field_info) =
        match (m_match_categorizer.GetConstVariants ()) {
          | const_cons :: _ => const_cons
          | _ => Util.ice ("MatchingOverVariantCons::create_list_like_matcher: "
                           "expected at least one constant variant constructor")
        };

      def non_const_cons_tycon =
        match (m_variant_options) {
          | [left, right] => if (left.Equals (const_cons_tycon)) right else left
          | x :: _ => x
          | _ => Util.ice ("MatchingOverVariantCons::create_list_like_matcher: "
                           "expected some variant options")
        };

      // categorize the clauses, build the effects expressions
      def const_clauses =
        collect_variant_related_clauses (const_cons_tycon);

      def const_clauses_effect_expr =
        bind_clauses_for_switch (const_clauses);
        
      def non_const_clauses =
        collect_variant_related_clauses (non_const_cons_tycon);

      def non_const_clauses_effect_expr =
        bind_clauses_for_switch (non_const_clauses);

      // build the variant checking expression
      def compare_to_const_expr =
        CExpr.Call (SystemType.Boolean, CExpr.Opcode ("==.ref"),
                [m_val, CExpr.GlobalRef (const_cons_field_info)]);

      def non_const_check_expr =
        CExpr.Sequence ([CExpr.NotNull (m_val), non_const_clauses_effect_expr]);
            
      def const_check_expr =
        CExpr.If (SystemType.Int32,
               compare_to_const_expr,
               const_clauses_effect_expr,
               non_const_check_expr);

      // builds the effects switch and wrap the matcher with appropriate CExpr.Defines
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, const_check_expr);

      finalize_matcher (effects_switch)      
    }

    /**
     * Builds a general matcher over constructors on the top level
     */
    private create_general_matcher () : void
    {
      def walk_variant_options (index : int, variant_options : list [TypeInfo]) : list [int * CExpr]
      {
        match (variant_options) {
          | variant_option :: rest =>
#if EXTRAMATCHINGDEBUG
            Message.Debug (index.ToString () + ": " + variant_option.FullName);
#endif

            def patterns =
              collect_variant_related_clauses (variant_option);

            def effect_expr =
              bind_clauses_for_switch (patterns);
            
            (index, effect_expr) :: walk_variant_options (index + 1, rest)
            
          | [] => []
        }
      };

#if EXTRAMATCHINGDEBUG
      Message.Debug ("walking variant options of type " + variant_tyinfo.FullName);
#endif

      def cons_switch_cases =
        walk_variant_options (0, m_variant_options);
        
      def cons_switch =
        CExpr.Switch (
          SystemType.Int32,
          m_variant_code_call_expr,
          Some (CExpr.Literal (Literal.Integer (1, true, InternalType.Int32))),
          cons_switch_cases
        );
        
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, cons_switch);

      def guarded_effects_switch =
//        if (contains_nullcheck ()) effects_switch
//        else
          CExpr.Sequence ([CExpr.NotNull (m_val), effects_switch]);

      finalize_matcher (guarded_effects_switch)
    }  


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable m_ctx : CTX;
    private mutable m_val : CExpr;
    private mutable m_vals : SystemMap [int, CG_val];
    private mutable m_match_collector : MatchCollector;
    private mutable m_variant_options : list [TypeInfo];
    private mutable m_variant_code_call_expr : CExpr;
    private mutable m_match_categorizer : MatchProblemCategorizer;
    
    // the resulting matcher
    private mutable m_matcher : CExpr; 
  }




  /* ----------------------------------------------------------------------- */  
  /* --  OLD APPROACH ------------------------------------------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * The matching module
   */
  partial module MatchingCompiler 
  {
    // handle both IField and IProperty
    internal build_record_field_ref (val : CExpr, member : IMember) : CExpr
    {
      match (member) {
        | field is IField =>
          CExpr.FieldRef (val, field.GetFieldInfo ())
          
        | prop is IProperty =>
          CExpr.Call (CExpr.MethodRef (val, prop.GetGetter ().GetMethodInfo (), false), [])

        | _ => assert (false)
      }
    }

    
    /**
     * Emit comparison code with specific literal.
     */
    public emit_compare_with (compare_to : CExpr, literal : Literal) : CExpr
    {
      def method =
        match (literal) {
          | Literal.String => CExpr.GlobalRef (SystemType.String_opEquality)
          | Literal.Decimal => CExpr.GlobalRef (SystemType.Decimal_opEquality)
          | _ => CExpr.Opcode ("==") 
        };
      assert (literal != null);
      def (compare_to, lit) =
        if (compare_to.SystemType.IsValueType)
          (compare_to,
           CExpr.Cast (CExpr.Literal (literal), compare_to.SystemType, true))
        else 
          (CExpr.Cast (compare_to, literal.GetSystemType (), true),
           CExpr.Literal (literal));
      CExpr.Call (SystemType.Boolean, method, [compare_to, lit])
    }

    cg_pattern (ctx : CTX, val : CExpr, pats : list [Pattern * TExpr])
    : CExpr * bool * CTX * list [CG_val]
    {
      mutable vals = SystemMap ();
      mutable rctx = ctx;
      mutable always_matches = true;
      
      def cgpat (val : CExpr, pat : Pattern) : CExpr {
        match (pat) {
          | Pattern.Wildcard => CExpr.TrueLiteral
          
          | Pattern.As (subpat, d) =>
            if (d.InClosure) ()
            else
              match (vals.Find (d.Id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, CExpr.Nop ());
                  rctx = ctx;
                  vals = vals.Add (d.Id, v);
              };
            def ass = CExpr.Assign (local_ref (rctx, d),
                                    maybe_cast (ctx, d.Type.Fix ().GetSystemType (), val));
            match (subpat) {
              | Pattern.Application =>
                match (cgpat (val, subpat)) {
                  | (CExpr.If (c, e_then, e_else)) as e =>
                    CExpr.If (e.ty, c, CExpr.Sequence ([ass, e_then]), e_else)
                  | _ => Util.ice ()
                }

              | Pattern.HasType (ti) =>
                CExpr.If (SystemType.Boolean, 
                       CExpr.HasType (val, ti.GetSystemType ()),
                       CExpr.Sequence ([ass, CExpr.TrueLiteral]),
                       CExpr.FalseLiteral)

              | _ =>
                CExpr.Sequence ([ass, cgpat (val, subpat)])
            }
            
          | Pattern.Tuple (args) =>
            def len = List.Length (args);
            def f (arg, acc)
              {
                def (pos, ex) = acc;
                def cond = cgpat (CompileTypedMethod.tuple_ref (CExpr.Cast (val, CompileTypedMethod.tuple_type (len), true),
                                             pos, len), arg);
                (pos - 1, CExpr.If (SystemType.Boolean, cond, ex,
                                    CExpr.FalseLiteral))
              };
            def ini = (len, CExpr.TrueLiteral);
            def (_, ex) = List.FoldLeft (List.Rev (args), ini, f);
            ex

          | Pattern.Literal (lit) =>
            emit_compare_with (val, lit)
            
          | Pattern.Record (args) =>
            def val = CExpr.Cast (val, pat.GetSystemType (), true);
            def f (np, ex) {
              def (name, pat) = np;
              def cond = cgpat (build_record_field_ref (val, name), pat);
              CExpr.If (SystemType.Boolean, cond, ex, CExpr.FalseLiteral)
            };
            List.FoldLeft (List.Rev (args), CExpr.TrueLiteral, f)
          
          | Pattern.Application (n, a) =>
            assert (! (n.GetTydecl () is TypeDeclaration.Alias));

            always_matches = false;
            def tyname = n.GetSystemType ();
            def ex = CExpr.HasType (val, tyname);
            CExpr.If (SystemType.Boolean, ex, 
                      cgpat (CExpr.Cast (val, tyname, true), a), 
                      CExpr.FalseLiteral)

          | Pattern.HasType (ti) =>
            always_matches = false;
            CExpr.HasType (val, ti.GetSystemType ())

          | Pattern.Enum => assert (false)

          | Pattern.Error => assert (false)
        }
      };

      mutable global_always_matches = false;

      def loop (pats) {
        match (pats) {
          | (pat : Pattern, expr) :: rest =>
            always_matches = true;
            def cond = Util.locate (pat.Location, cgpat (val, pat));
            def cond =
              match (expr) {
                | TExpr.Literal (Literal.Bool (true)) => cond
                | _ =>
                  always_matches = false;
                  CExpr.If (SystemType.Boolean, cond, cg_expr (rctx, expr),
                            CExpr.FalseLiteral)
              };
            global_always_matches = global_always_matches || always_matches;
            CExpr.If (SystemType.Boolean, cond, CExpr.TrueLiteral, loop (rest))
            
          | [] => CExpr.FalseLiteral
        }
      };

      def r = loop (pats);
      def collect_vals (_ : int, v : CG_val, acc : list [CG_val]) : list [CG_val] { 
        v :: acc };
      (r, global_always_matches, rctx, vals.Fold ([], collect_vals))
    }

    
    /**
     * Matching over arbitrary types
     */    
    cg_match_general (t : System.Type, ctx : CTX, val : CExpr,
                      mcs : list [Match_case]) : CExpr 
    {
      match (mcs) {
        | [] =>
          CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []))

        | m :: ms =>
          // FIXME: do something with always_matches
          def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
          def then_part = cg_expr (ctx', m.body);
          def else_part = cg_match_general (t, ctx, val, ms);
          List.FoldLeft (vals, CExpr.If (t, cond, then_part, else_part), CExpr.Define)
      }
    }
    
    
    /**
     * Returns the constant object for a parameterless variant constructor
     */
    public get_constant_object (variant_tycon : TypeInfo) : option [FieldInfo]
    {
      def members = 
        variant_tycon.LookupMember ("_N_constant_object");
      
      match (members) {
        | [] => None ()
        
        | [constant_object_field] =>
          Some ((constant_object_field :> IField).GetFieldInfo ())

        | _ =>
          Util.ice ("get_constant_object: expected zero or exactly one _N_constant_object fields")
      }          
    }
           

    /**
     * Matching over arbitrary types
     */
    cg_match_over_any_type (t : System.Type, ctx : CTX, val : CExpr,
                            mcs : list [Match_case]) : CExpr 
    {
      def match_collector = MatchCollector (t, ctx, mcs);
        
      if (match_collector.IsTopLevelMatchingOverCons ()) {
        def matcher_generator =
          MatchingOverVariantCons (ctx, val, match_collector);
          
        matcher_generator.GetMatcher ()
      }
      else
        cg_match_general (t, ctx, val, mcs)        
    }


    /**
     * Matching over booleans.
     */
    cg_match_over_booleans (t : System.Type, ctx : CTX, val : CExpr,
                            mcs : list [Match_case]) : CExpr
    {
      mutable vals = SystemMap ();
      mutable rctx = ctx;

      mutable true_handled = false;
      mutable false_handled = false;
      mutable last_pattern_always_matches = false;

      def is_always_true (expr : TExpr) : bool {
        match (expr) {
          | TExpr.Literal (Literal.Bool (true)) => true
          | _ => false
        }    
      };

      def make_cond (patterns : list [Pattern * TExpr]) : CExpr {
        match (patterns) {        
          | (Pattern.Wildcard, when_expr) :: _ when is_always_true (when_expr) =>
            last_pattern_always_matches = true;          
            CExpr.TrueLiteral
        
          | (Pattern.Wildcard, when_expr) :: rest =>
            CExpr.If (SystemType.Boolean, cg_expr (rctx, when_expr),
                      CExpr.TrueLiteral, make_cond (rest))

          | (Pattern.Literal (Literal.Bool (literal)), when_expr) :: rest
            when is_always_true (when_expr)
            =>
            def literal_already_handled = if (literal) true_handled else false_handled;   
            when (literal_already_handled)
              Message.Warning ("unreachable pattern in matching");
            
            if (literal) true_handled = true else false_handled = true;
                      
            if (true_handled && false_handled) {
              last_pattern_always_matches = true;          
              CExpr.TrueLiteral
            }
            else {
              if (literal) 
                CExpr.If (SystemType.Boolean, val,
                          CExpr.TrueLiteral, make_cond (rest))
              else
                CExpr.If (SystemType.Boolean, val,
                          make_cond (rest), CExpr.TrueLiteral)
            }

          | (Pattern.Literal (Literal.Bool (literal)), when_expr) :: rest =>
            def literal_already_handled = if (literal) true_handled else false_handled;
            when (literal_already_handled)
              Message.Warning ("unreachable pattern in matching");

            def opposite_handled = if (literal) false_handled else true_handled;

            if (opposite_handled) {
              CExpr.If (SystemType.Boolean, cg_expr (rctx, when_expr),
                        CExpr.TrueLiteral, make_cond (rest))          
            }
            else {
              def not_handled = CExpr.If (SystemType.Boolean, cg_expr (rctx, when_expr), 
                                          CExpr.TrueLiteral, make_cond (rest));
              if (literal)
                CExpr.If (SystemType.Boolean, val, CExpr.TrueLiteral, not_handled)
              else                              
                CExpr.If (SystemType.Boolean, val, not_handled, CExpr.TrueLiteral)                 
            }

          | (Pattern.As (Pattern.Wildcard, decl), when_expr) :: _
            when is_always_true (when_expr) =>
            if (decl.InClosure) ()
            else
              match (vals.Find (decl.Id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, decl, CExpr.Nop ());
                  rctx = ctx;
                  vals = vals.Add (decl.Id, v);
              };
            last_pattern_always_matches = true;
            def assign_expr = 
              CExpr.Assign (local_ref (rctx, decl),
                            maybe_cast (rctx, decl.Type.Fix ().GetSystemType (), val));
            assign_expr

          | [] => CExpr.FalseLiteral

          | (Pattern.Tuple, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind Pattern.Tuple")
          | (Pattern.Record, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind Pattern.Record")
          | (Pattern.Application, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind Pattern.Application")

          | _ :: _ => 
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
        }      
      };

      def walk_match_cases (mcs : list [Match_case]) : CExpr {
        match (mcs) {
          | [] =>
            CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []))

          | mc :: rest =>
            def cond = make_cond (mc.patterns);
            def body = cg_expr (rctx, mc.body);
            
            def vals' = vals;
            vals = SystemMap ();
            
            def body =
              if (true_handled && false_handled || last_pattern_always_matches) {
                // should be handled already anyway, and here there is no way
                // to disable this warning (from @foreach)
                // unless (rest matches []) Message.Warning ("unreachable match cases");
                match (cond) {
                  | CExpr.Assign =>
                    CExpr.Sequence ([cond, body])
                  | _ => body
                }
              }
              else
                CExpr.If (body.SystemType, cond, body, walk_match_cases (rest));

            vals'.Fold (body, fun (_, val, acc) { CExpr.Define (val, acc) })
        }
      };

      // handle the special cases for the if/when/unless macros
      match (mcs) {
        | [then_case, else_case] =>
          match ((then_case.patterns, else_case.patterns)) {
            | ([(Pattern.Literal (Literal.Bool (literal)), then_case_when_expr)],
               [(Pattern.Wildcard, else_case_when_expr)]) 
              when is_always_true (then_case_when_expr) &&
                   is_always_true (else_case_when_expr) =>
              if (literal)
                CExpr.If (t, val, cg_expr (ctx, then_case.body),
                       cg_expr (ctx, else_case.body))
              else
                CExpr.If (t, val, cg_expr (ctx, else_case.body), 
                       cg_expr (ctx, then_case.body));
                                              
            | _ => walk_match_cases (mcs)
          }
        | _ => walk_match_cases (mcs)
      }
    }


    internal local_ref (ctx : CTX, decl : LocalValue) : CExpr
    {
      Util.cassert (decl.RefAs != null, $"for $decl");
      cg_expr (ctx, decl.RefAs)
    }


    /**
     * Matching
     */
    public Run (t : System.Type, ctx : CTX, val : CExpr,
                mcs : list [Match_case]) : CExpr
    {
      def valt = val.SystemType;
      // here we choose whether to use some optimized matching algorithm or
      // just most general one
      if (valt.Equals (SystemType.Boolean))
        cg_match_over_booleans (t, ctx, val, mcs)
      else
        cg_match_over_any_type (t, ctx, val, mcs)
    }
   
  } // end of the module

} // end of the namespace
