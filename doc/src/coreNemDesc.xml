<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<?xml version='1.0' encoding='UTF-8' ?>
<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Decription of core Nemerle language</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document describes, in informal way, with examples, the
        core Nemerle language. Audience is assumed to know some dialect of ML
        (SML, Caml or Haskell will do (no flame please, up to the level
        needed here Haskell is dialect of ML :-)). This has been written a few
	weeks ago and some constructs might not be up to date with the present
	core Nemerle compiler. We will try to correct any inconsistency as soon
	as possible.
      </p>
      <p>
	<meta>X</meta> is subtype of <meta>Y</meta> (<tt><meta>X</meta>
	&lt;: <meta>Y</meta></tt>) means that each value of type
	<meta>Y</meta> has also type <meta>X</meta>. In object oriented
	systems <meta>Y</meta> is base type of <meta>X</meta> (or
	<meta>X</meta> derives from <meta>Y</meta>) implies <meta>X</meta>
	is subtype of <meta>Y</meta>. Specifically it means that
	all functions operating on <meta>Y</meta> can also operate on
	<meta>X</meta>.
      </p>
    </body>
  </section>
  <section id="expr">
    <title>Expressions</title>
    <body>
      <p>
        Expressions are basic building blocks for Core-Nem language. 
        Refer to grammar for exact rules.
      </p>
      <ul>
        <li>
          Identifier is expression. It references value bound in
          <tt>let</tt> expression or global value. Global values that are
          not functions need to have unique names, for global functions
          overloading resolution is performed, for <tt>let</tt> bindings
          regular innermost-match rules apply.
        </li>
        <li>
          Method call. Example: <tt>x # mem (y)</tt>.
        </li>
        <li>
          Function call. <tt>f (x, y)</tt>
        </li>
        <li>
          Assignment to mutable value (global mutable value, or mutable
          type member). <tt>x &lt;- y</tt>
        </li>
        <li>
          Name binding. Name can be made mutable using <tt>ref</tt>.
<code>
(* Object construction for builtin type: *)
let one = 1 in
let two = 2 in
(* Binding value of function: *)
let x = f (one) in
(* Mutable value: *)
let ref y = f (two) in
(* Just control flow: *)
let _ = x &lt;- y in
...
</code>
        </li>
        <li>
          Name binding for functions. Several names can be bound at once,
          so they can be mutually recursive.
<code>
(* Yes, f and g loop forever :-) *)
let f (x : int, y : int) : int = g (x) 
and g (x : int) : int = f (x, x)
in ...
</code>
        </li>
        <li>
          <tt>tymatch</tt> expression for induction over type structure. We'll
          describe this concept later.
        </li>
        <li>
          Exception handling expressions: <tt>try ... with</tt> and <tt>raise</tt>.
        </li>
      </ul>
    </body>
  </section>
  <section id="ext_syn">
    <title>Extended syntax</title>
    <body>
      <p>
        In this section we define few very basic syntax extensions. All
        those syntax extensions are here just for bravity and can be
        thought of as macros.
      </p>
    </body>
    <subsection id="lambda-expr">
      <title>Lambda expressions</title>
      <body>
        <p>
          <tt>fun <meta>args</meta> -> <meta>expr</meta></tt> is translated to
          <tt>let tmp <meta>args</meta> = <meta>expr</meta> in tmp</tt>. 
        </p>
      </body>
    </subsection>
    <subsection id="if-expr">
      <title><tt>if</tt> expressions</title>
      <body>
<code>
  if <meta>expr</meta> then 
    <meta>expr1</meta> 
  else 
    <meta>expr2</meta>
</code>
        <p>
          is translated to:
        </p>
<code>
tymatch <meta>expr</meta> with [
  | System.Boolean.True  -> <meta>expr1</meta>
  | System.Boolean.False -> <meta>expr2</meta> 
]
</code>
      </body>
    </subsection>
  </section>
  <section id="type-decl">
    <title>Type declarations</title>
    <body>
      <p>
        It is possible to create three kinds of types in Core-Nem: interfaces,
        class types and struct types.
      </p>
      <p>
        All entities (nested types, values, members and methods) defined
        inside types (struct types, class types and interfaces) have
        names implicitly prefixed with name of type and a dot. For
        example:
      </p>
<code>
class Foo {
  value x : int = 3;
  value y : int = Foo.x;
}
</code>
      <p>
        defines values <tt>Foo.x</tt> and <tt>Foo.y</tt>. One needs this type
        prefix to refer to values, <b>even</b> defined inside the same type.
      </p>
    </body>
    <subsection id="ifaces">
      <title>Interfaces</title>
      <body>
        <p>
          Interface is specified by enumerating set of named methods
          along with their type. Interface does not contain members nor
          method implementation. It is not possible to create values of
          (exactly) interface type, however classes can <b>implement</b>
          interface and hence by subtypes of it. 
        </p>
        <p>
          Interface can subtype (implement) other interfaces. Classes
          that later implement that interface, shall also implement all
          interfaces it subtypes. Indirectly implemented interfaces need
          not but can be listed in <tt>implements</tt> clause in type
          definition, however all their methods shall be implemented.
        </p>
        <p>
          I.e. if interface <meta>X</meta> implements interface
          <meta>Y</meta>, and class <meta>Z</meta> implements
          <meta>X</meta>, then it can also list <meta>Y</meta>
          in its <tt>implements</tt> clause. In any case 
          <tt><meta>Z</meta> :> <meta>X</meta></tt> and 
          <tt><meta>Z</meta> :> <meta>Y</meta></tt>, and
          <meta>Z</meta> should have implementation for all methods
          from both <meta>X</meta> and <meta>Y</meta>.
        </p>
        <p>
          Methods are functions that take zero or more arguments, plus one
          additional object argument. This additional argument is hidden
          in type presented in interface.
        </p>
        <p>
          Example:
        </p>
<code>
interface I_Comparable_To ('a)
{
  compare_to (_ : 'a) : int;
}

interface I_Runnable ('a)
{
  run () : 'a;
}

interface I_Set ('a)
{
  add (elem : 'a) : void;
  mem (elem : 'a) : bool;
  ('b) fold (f : 'a * 'b -> 'b, init : 'b) : 'b;
}
</code>
      </body>
    </subsection>
    <subsection id="classes">
      <title>Classes</title>
      <body>
        <p>
          Classes can extend (and hence subtype) other classes. They can also
          implement (and hence subtype) interfaces.
        </p>
        <p>
          It looks like this:
        </p>
<code>
class Lazy ('a)
  implements
    I_Comparable_To(Lazy('a)),
    I_Runnable('a)
{
  (* There is no real-life reason it needs integer key, except
     that will put this stuff into tree. *)
  field key : int;
  field fnc : void -> 'a;

  method run () : 'a
    implements I_Runnable.run
  =
    (this # fnc) ();

  method compare_to (that : Lazy('a)) : int
    implements I_Comparable_To.compare_to
  =
    this # key - that # key;
}
</code>
        <p>
          Now we can create objects of type <tt>Lazy['a]</tt> and call
          its methods:
        </p>
<code>
let lazy_foo = Lazy (fnc = fun () : string => "foo",
                     key = 17) in
let lazy_bar = Lazy (37, fun () : string => "bar") in
(* Can use names from type... *)
let cmp_res = lazy_foo # compare_to (lazy_bar) in
(* ...or from interface. *)
let dummy1 = (lazy_bar :> I_Runnable(string))#run () in
...
</code>
        <p>
          Now we'll see how <tt>extends</tt> works:
        </p>
<code>

class Cached_Lazy ('a)
  extends Lazy ('a)
  (* this sucks. *)
  implements
    I_Comparable_To(Lazy('a)),
    I_Runnable('a)
{
  (* key and fnc fields are automagically copied. *)
  field ref cache : 'a;

  method run () : 'a implements I_Runnable.run =
    if this # cache == null then
      let v = this # fnc () in
      { this # cache &lt;- v; v }
    else
      this # cache;
}
</code>
      </body>
    </subsection>
    <subsection id="variants">
      <title>Variant types</title>
      <body>
        <p>
          Variant types are natural way of representing values that
          fall in one of few given categories. Variants can extend other
          types and implement interfaces. However it is not possible to
          extend variant type.
        </p>
<code>
(* BST *)
type Tree ['a]
  (* This is typing constraint, it means that 'a have to be
     subtype of I_Comparable_To['a] *)
  where 'a :> I_Comparable_To['a]
[
  | Node 
      { 
         value : 'a;
         left : Tree['a];
         right : Tree['a] 
      }
  | Tip {}
]
{
  value ['a] where 'a :> I_Comparable_To['a] 
    insert : Tree['a] * 'a -> Tree['a] = 
    fun (t : Tree['a], e : 'a) : Tree['a] ->
      match t with [
        | Node { value = ?n; 
                 left = ?l; 
                 right = ?r; 
               } ->
          if e # compare_to (n) &lt; 0 then
            Node { value = n; 
                   left = Tree.insert (l, e);
                   right = r;
                 }
          else
            Node { value = n; 
                   left = l;
                   right = Tree.insert (r, e);
                 }
        | Tip {} -> Node { value = e; 
                           left = Tip {}; 
                           right = Tip {};
                         }
      ];
      
  method find ... later ... ;
}
</code>
      </body>
    </subsection>
  </section>
  <section id="mutables">
    <title>Mutable values</title>
    <body>
      <p>
        Little intro:
      </p>
      <ul>
        <li>
          First assume all members of types, global and local values
          are pointers in C's sense. This includes integers and other basic
          types.
        </li>
        <li>
          <tt>ref</tt> in front of value means
          that the pointer can be changed.  For example: <tt>let ref x =
          3</tt> means to construct new integer object holding value 3
          and assign pointer to it to name <tt>x</tt>. Of course since
          integers are immutable there is no need for more then one
          object holding value 3, so in fact we can assign reference to
          some existing 3 to <tt>x</tt>.
        </li>
        <li>
          The simple semantics <tt>ref</tt> (,,can be changed'') is true
          for <tt>ref</tt> use in front of member, formal parameter and
          local or global value.
        </li>
        <li>
          In normal case of function invocation pointers representing values
          are passed by value (function gets own copy).
          However if <tt>ref</tt> is present in front of formal parameter,
          there is no copying -- changing the value in function changes
          it also outside.
        </li>
        <li>
          Of course we're not going to create zillions of integer objects :-)
          It is impossible for the programmer to distinguish
          between pointer to immutable object or this object stored inline.
          And integers, strings, floats and so on are all immutable objects,
          so they can be stored inline.
        </li>
      </ul>
      <p>
        And example:
      </p>
<code>
type Set['a]
  where 'a :> I_Comparable_To['a]
  implements 
    I_Set['a] 
{
  member ref root : Tree['a];
  method add (e : 'a) : void implements I_Set.add 
    = s ! root &lt;- Tree.insert (this ! root, e);
  method mem ... ;
  method fold ... ;
}
</code>
    </body>
  </section>
  <section id="exns">
    <title>Exception handling</title>
    <body>
      <p>
        Exceptions can be thrown using <tt>raise</tt> expression. Raise
        expects value of subtype of <tt>System.Exception</tt> class.
        Exceptions can be intercepted using <tt>try ... with</tt> 
        expression. 
      </p>
<code>
  (* This method from Tree: *)
  method find (e : 'a) =
      match this with [
        | Node { value = ?n; 
                 left = ?l; 
                 right = ?r; 
               } ->
          let cmp = e # I_Comparable_To.compare_to (n) in
          if cmp &lt; 0 then
            Tree.find (l, e)
          else
            if cmp > 0 then
              Tree.find (r, e)
            else
              n
        | Tip {} -> 
          raise (Nemerle.Not_Found {})
      ];

  (* And this is from Set *)
  method mem (e : 'a) : bool implements I_Set.mem =
      try 
        let dummy1 = s # Tree.find (e) in 
        true 
      with (dummy2) Nemerle.Not_Found {} -> false;
</code>
      <p>
        Well known Java construct:
      </p>
<code>
try
  <meta>expr1</meta>
finally
  <meta>expr2</meta>
</code>
      <p>
        can be translated to:
      </p>
<code>
let fin_block () : void = <meta>expr2</meta> in
let res =
  try
    <meta>expr1</meta>
  with (?exn) System.Exception {} ->
    let dummy1 = fin_block () in
    raise exn
in 
let dummy2 = fin_block () in
res
</code>
      <p>
        <tt>System.Exception {}</tt> will catch any subtype of
        <tt>System.Exception</tt> (read: any exception, that can be
        thrown).
      </p>
    </body>
  </section>
  <section id="overloading">
    <title>Symbol overloading</title>
    <body>
      <p>
        It is possible to have several functions or methods with the
        same name but different type signature. Version choosen is one
        that matches types of supplied arguments (which is always known)
        best. This best match is defined as follows:
      </p>
      <ul>
        <li>
          if there is symbol that matches type signature exactly --
          it is choosen
        </li>
        <li>
          otherwise subtyping is considered, treating any ambiguity as
          fatal error
        </li>
      </ul>
    </body>
  </section>
  <section id="rtti">
    <title>Runtime types</title>
    <body>
      <p>
        Up to here there was nothing special or new in this design. Just
        cut-down version of OCaml 3.05 (not to confuse with OCaml
        3.04). Now we'll be adding runtime types that will support ad-hoc
        polymorphism and few other things.
      </p>
      <p>
        The key thing to note is that all values carry exact runtime
        type information. This also includes parameterized types. This
        information can be therefore accessed from program. This is done
        using <tt>tymatch</tt> expression. 
      </p>
      <p>
        Conceptually <tt>tymatch</tt> takes identifier <meta>x</meta>
        and list of (type, expression) pairs. It then examines them in
        order, until it finds one such (<meta>t</meta>, <meta>e</meta>),
        that <meta>x</meta> has type <meta>t</meta>. Then <meta>e</meta>
        is returned as value.  If no match is found, exception is raised.
      </p>
      <p>
        At typechecker level <meta>x</meta> is assumed to have type
        <meta>t</meta> when typechecking <meta>e</meta> (for each
        (<meta>t</meta>, <meta>e</meta>) pair).
      </p>
      <p>
        However, since set of types <meta>x</meta> can have is sometimes
        infinite, we can also use type variables to match arbitrary types.
        Each new type variable introduced this way needs to be quantified
        in front of <tt>tymatch</tt> branch, for example:
      </p>
<code>
let ['a, 'b] f (x : 'a, y : 'b) : void =
  tymatch y with [
    | List['a] -> (* 'b :> List['a] *)
    | ['c] List['c] -> (* 'b :> List['c] for some 'c *)
    | ['c] 'c -> (* 'b is some other type *)
  ]
</code>
      <p>
        <tt>tymatch</tt> type variables can be constrained in <tt>where</tt>
        clause. Possible constraints are:
      </p>
      <ul>
        <li>
          Subtyping constraint, written:
<code>
<meta>'a</meta> :> <meta>type</meta>
</code>
        </li>
        <li>
          Type equivalence, written:
<code>
<meta>'a</meta> = <meta>type</meta>
</code>
        </li>
        <li>
          Constraint that is always true, but binds additional values
          so type can be runtime decomposed, written:
<code>
?<meta>con</meta> { ?<meta>mem</meta> } : <meta>'a</meta>
</code>
          <meta>con</meta>, in scope of expression after <tt>-></tt>,
          is bound to runtime representation of constructor.  We can
          fetch it's type, what it subtypes, names of members and so on
          from it. We can also compare two constructors for equality.
          <meta>mem</meta> is bound to list of actual member values, it has
          type <tt>list[System.Object]</tt>. Additional <tt>tymatch</tt>
          expressions may be used to see what's inside.
        </li>
      </ul>
      <p>
        For example we consider polymorphic equality predicate:
      </p>
<code>
type ['a, 'b] Tuple2
{
  member f1 : 'a;
  member f2 : 'b;
}

value ['a] equal : 'a * 'a -> bool =
  let ['b] list_equal (x : list['b], y : list['b]) : bool =
    match x with [
      | Cons {head = x; tail = xs; } ->
        match y with [
          | Cons {head = y; tail = ys; } ->
            if equal (x, y) then
              list_equal (xs, ys)
            else
              false
          | Nil {} -> false
        ]
      | Nil ->
        match y with [
          | Cons {} -> false
          | Nil {} -> true
        ]
    ]
  in
  fun (x : 'a, y : 'a) : bool ->
    tymatch T2 { f1 = x; f2 = y; } with [
    | Tuple2[System.Int32, System.Int32] -> 
      System.Int32.op_Equals(x, y)
    | Tuple2[System.Int16, System.Int16] -> 
      System.Int16.op_Equals(x, y)
    | ... write here N cases for standard types ...
    | ['b, 'c] Tuple2['b, 'c] where 
        ?con_x { ?mem_x } : 'b, 
        ?con_y { ?mem_y } : 'c ->
      if Nemerle.constructors_equal (con_x, con_y) then
        list_equal (mem_x, mem_y)
      else
        false;
</code>
    </body>
  </section>
  <section id="clstypes">
    <title>Basic CLS types</title>
    <body>
      <p>
        Several integer, floating point, boolean and string types are provided.
        Set of basic operations on these types is yet to be decided. It will
        include common arithmetic operators (as functions).
      </p>
      <ul>
        <li>
          Type <tt>System.Object</tt> that is implicit subtype of all
          types.
        </li>
        <li>
          Integer types: <tt>System.Int8</tt>, <tt>System.UInt8</tt>,
          <tt>System.Int16</tt>, <tt>System.UInt16</tt>,
          <tt>System.Int32</tt>, <tt>System.UInt32</tt>,
          <tt>System.Int64</tt>, <tt>System.UInt64</tt>.
        </li>
        <li>
          Character type: <tt>System.Char</tt>.
        </li>
        <li>
          Boolean type: <tt>System.Boolean</tt> defined as follows:
<code>
type System.Boolean [ 
  | System.Boolean.true 
  | System.Boolean.false 
]
</code>
        </li>
        <li>
          String type: <tt>System.String</tt>.
        </li>
        <li>
          Unit type: <tt>System.Void</tt>, defined as follows:
<code>
type System.Void [ 
  System.Void.void_value 
]
</code>
        </li>
        <li>
          Floating point types: <tt>System.Single</tt> and <tt>System.Double</tt>.
        </li>
        <li>
          Decimal arithmetic type: <tt>System.Decimal</tt>.
        </li>
        <li>
          Array type: <tt>System.Array['a]</tt> (we leave multidimensional arrays
          (as opposed to arrays of arrays) for now).
        </li>
        <li>
          Basic exception type: <tt>System.Exception</tt>. All values that are used
          in <tt>raise</tt> expression, need to be subtypes of 
          <tt>System.Exception</tt>.
        </li>
      </ul>
      <p>
        In most examples we will refer to <tt>System.Int32</tt> as <tt>int</tt>,
        and so on as listed below, for brevity.
      </p>
<code>
int = System.Int32
string = System.String
void = System.Void
() = System.Void.void_value
bool = System.Boolean 
true = System.Boolean.true
false = System.Boolean.false
</code>
    </body>
  </section>
</document>
