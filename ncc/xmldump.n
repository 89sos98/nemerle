(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module XmlDump {

  p (s : string) : void { print_endline (s) }
  
  xmlescape (s : string) : string {
    def buf = System.Text.StringBuilder();

    for (mutable i <- 0; i < s.Length; i <- i + 1)
      match (s[i]) {
        | '"' => ignore (buf.Append("&quot;"))
        | '<' => ignore (buf.Append("&lt;"))
        | '&' => ignore (buf.Append("&amp;"))
        | c => ignore (buf.Append(c))
      };
			
    buf.ToString();
  }

  attr (name : string, val : string) : string {
    " " + name + "=\"" + xmlescape (val) + "\" "
  }

  loc (l : Location) : string {
    attr ("file", l.file) +
    attr ("line", string_of_int (l.line))
  }

  dump_typarms (tp : Typarms) : void {
    def dump_tv (n : string) : void {
      def dump_constraint (c : Constraint) : void {
        if (c.tyvar == n) {
          p ("<constraint>");
          dump_ty (c.ty);
          p ("</constraint>");
        } else ()
      };
      p ("<tvar" + attr("name", n) + ">");
      List.iter (dump_constraint, tp.constraints);
      p ("</tvar>");
    };

    p ("<typarms>");
    List.iter (dump_tv, tp.tyvars);
    p ("</typarms>");
  }

  dump_ty (t : Type) : void {
    match (t) {
      | T_app (SS_string (n), a) =>
        p ("<tapp" + attr ("ref", n) + ">");
          List.iter (dump_ty, a);
        p ("</tapp>");
      | T_app (_, _) =>
        Util.ice ("Spliced string in xmldump")
      | T_prod (a) =>
        p ("<tprod>");
          List.iter (dump_ty, a);
        p ("</tprod>");
      | T_var (a) =>
        p ("<tvar" + attr ("name", a) + "/>");
      | T_fun (t1, t2) =>
        p ("<tfun>");
          p ("<from>");
            dump_ty (t1);
          p ("</from>");
          p ("<to>");
            dump_ty (t2);
          p ("</to>");
        p ("</tfun>");
      | T_void => p ("<tvoid/>");
      | T_ref (t) =>
        p ("<tref>");
          dump_ty (t);
        p ("</tref>");
      | T_out (t) =>
        p ("<tout>");
          dump_ty (t);
        p ("</tout>");
      | T_array (t) =>
        p ("<tarray");
          dump_ty (t);
        p ("</tarray>");
      | T_spliced | T_spliced_special =>
        p ("<tspliced>");
        p ("</tspliced>");
      | T_type_list =>
        p ("<ttypelist>");
        p ("</ttypelist>");
      | T_infer =>
        p ("<tinfer>");
        p ("</tinfer>");
    } 
  }
  
  dump_class_member (mem : Class_member) : void {
    match (mem) {
      | M_type (t) => dump_tydecl (t)
      | M_field (t, is_ref, kind) =>
        p ("<field " + attr ("name", mem.name) + loc (mem.loc) +
                       attr ("mutable", if (is_ref) "yes" else "no") +
                       attr ("extern-name", 
                         match (kind) {
                           | Val_normal => ""
                           | Val_extern (n) => n
                         }) + ">");
          dump_mods (mem.modifiers);
          p ("<type>");
            dump_ty (t);
          p ("</type>");
        p ("</field>");

      | M_property (t, get_methods, set_methods, is_static) =>
        p ("<property " + attr ("name", mem.name) + loc (mem.loc) +
                          attr ("is_readable", if (List.is_empty (get_methods)) "no" else "yes") +
                          attr ("is_writeable", if (List.is_empty (set_methods)) "no" else "yes") +
                          attr ("is_static", if (is_static) "yes" else "no") +
                          ">");
          dump_mods (mem.modifiers);
          p ("<type>");
          dump_ty (t);
          p ("</type>");

(** FIXME: dump all the get and set methods with their parameters here...

          if (List.length (indexer_parameters) > 0)
          {          
            def dump_parm (fp : Fun_parm) : void {
              p ("<parm" + attr ("name", fp.name) + ">");
                p ("<type>");
                  dump_ty (fp.ty);
                p ("</type>");
              p ("</parm>");
            };

            p ("<parms>");
              List.iter (dump_parm, indexer_parameters);
            p ("</parms>");
          }
          else ();
*)

        p ("</property>");
        
      | M_function (h, k, _) =>
        p ("<method " + attr ("name", mem.name) + loc (mem.loc) + ">");
          dump_mods_noend (mem.modifiers);
            match (k) {
              | FK_ctor => p ("<mod-ctor/>")
              | FK_static_ctor => p ("<mod-ctor/>")
              | _ => ()
            };
          p ("</modifiers>");
          
          dump_typarms (h.typarms);

          def dump_parm (fp : Fun_parm) : void {
            p ("<parm" + attr ("name", Macros.unsstring (fp.name)) + ">");
              p ("<type>");
                dump_ty (fp.ty);
              p ("</type>");
            p ("</parm>");
          };
          
          p ("<parms>");
            List.iter (dump_parm, h.parms);
          p ("</parms>");
          p ("<ret-type>");
            dump_ty (h.ret_type);
          p ("</ret-type>");
          
        p ("</method>");
    }
  }

  dump_mods_noend (mods : list (Modifier)) : void {
    def dump_mod (mod : Modifier) : void {
      def x =
        match (mod) {
          | Mod_public => "mod-public"
          | Mod_private => "mod-private"
          | Mod_new => "mod-new"
          | Mod_protected => "mod-protected"
          | Mod_internal => "mod-internal"
          | Mod_abstract => "mod-abstract"
          | Mod_virtual => "mod-virtual"
          | Mod_sealed => "mod-sealed"
          | Mod_static => "mod-static"
          | Mod_module => "mod-module"
          | Mod_struct => "mod-struct"
          | Mod_macro => "mod-macro"
          | Mod_attribute => "mod-macro"
        };
      p ("<" + x + "/>");
    };
    p ("<modifiers>");
    List.iter (dump_mod, mods);
  }

  dump_mods (mods : list (Modifier)) : void {
    dump_mods_noend (mods);
    p ("</modifiers>");
  }
  
  dump_tydecl (td : Type_decl) : void {
    def elt =
      match (td) {
        | TD_class => "class"
        | TD_alias => "alias"
        | TD_interface => "interface"
        | TD_variant => "variant"
        | TD_variant_option => "variant_option"
      };
    p ("<" + elt + 
           attr ("name", td.name) +
           loc (td.loc) +
       ">");
    dump_mods (td.modifiers);
    dump_typarms (td.typarms);
    match (td.t_extends) {
      | Some (t) => 
        p ("<extends>");
        dump_ty (t);
        p ("</extends>");
      | None => ()
    };
    match (td.t_implements) {
      | _ :: _ => 
        p ("<implements>");
        List.iter (dump_ty, td.t_implements);
        p ("</implements>");
      | [] => ()
    };
    
    def members (decls : list (Class_member)) : void {
      p ("<members>");
      List.iter (dump_class_member, decls);
      p ("</members>");
    };
    
    match (td) {
      | TD_class (d) => members (d)
      | TD_interface (d) => members (d)
      | TD_variant_option (d) => members (d)
      | TD_variant (d) =>
        p ("<members>");
        List.iter (dump_tydecl, d);
        p ("</members>");
      | TD_alias (t) =>
        p ("<aliased>");
        dump_ty (t);
        p ("</aliased>");
    };

    p ("</" + elt + ">");
  }

  public run () : void {
    def ti_run (ti : Tyinfo) : void { dump_tydecl (ti.pt_tydecl) };
    p ("<unit>");
    Tyinfo.SourceTopIter (ti_run);
    p ("</unit>");
  }
  
}
} // end ns
