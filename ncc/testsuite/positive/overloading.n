using Nemerle.IO;
class A {}
class B : A {}
class C : B { public this () {} }

class StaticOverride {
    static new ToString () : string {
        "bla"
    }

    public static Run () : void { 
        System.Console.WriteLine (StaticOverride.ToString ());
//        def x = StaticOverride ();
//        printf ("%s\n", x.ToString ());
    }
}

namespace CtorVsMethodOut {
  using System;

  enum AEnum { | a | b }

  public class T {
       private static Convert ( a : out AEnum) : void
        {
                a = AEnum.a;
                printf ("called Convert\n");
        }
        public static Run () : void
        {
                mutable a = ( 0 :> AEnum);
                Convert (out a);
        }
  }
}

namespace PolymorphicPlusFunctionals {
  using Nemerle.Collections;

  module M {
    f (x : int) : int { x }
    f (_x : string) : int { 1 }
    g['a] (l : list['a], f : 'a -> int) : void {
      Nemerle.IO.printf ("%s\n", List.Map (l, f).ToString ())
    }

    public Run () : void {
      def l = [1,2,3];
      g (l, f);
      def l = ["a","b","c"];
      g (l, f)
    }
  }
}

namespace AssignmentLValue {
  using System;

  class X {
      static mutable Int32 : Int32;

      public static Run () : void
      {
         Int32 = ( 0 : Int32);
      }
  }
}


public class Bug743
{
  public this (_ : string) { printf("743.string\n"); }
  public this (_ : object, _ = "a") { printf("743.object\n"); }
}

public class Bug743x
{
  public this (_ : string, _ = "a") { printf("743x.string\n"); }
  public this (_ : object) { printf("743x.object\n"); }
}

namespace Bug723 {
class X1
{
  public M() : void {}
}

class X2
{
  public X1 : X1 = X1();
  public K() : void
  {
    X1.M()
  }
}
}

module Bug770 {
    test(_ : object) : void { }
    test(_ : array[object]) : void { }
    foo() : void {
        def z(x,y){x+y}
        test(z(1,2));
    }
}


module M {
  foo (_ : array [string]) : void { }
  foo (_ : array [object]) : void { assert (false) }

  
  quxx (_ : A) : void { printf ("A\n"); }
  quxx[T] (_ : T) : void where T : A { printf ("poly\n"); }

  bar (s : string, i : int) : void {
    _ = s;
    _ = i;
  }
  
  bar (i : int, s : object) : void {
    _ = s;
    _ = i;
    assert (false);
  }
  
  f (_ : A, _ : B) : void {}
  f (_ : B, _ : B) : void { printf ("OK\n") }

  public Main () : void {
    f (C (), C ());
    StaticOverride.Run ();
    CtorVsMethodOut.T.Run ();
    PolymorphicPlusFunctionals.M.Run ();
    AssignmentLValue.X.Run ();

    bar (s = "foo", i = 42);
    bar (i = 42, s = "foo");
    foo (array ["foo"]);

    quxx (A ());
    // FIXME: poly should be chosen
    // quxx (B ()); 

    _ = Bug743("");
    _ = Bug743("", "");
    _ = Bug743x("");
    _ = Bug743x("", "");
  }

  public Main (_args : string) : void // W: has the wrong signature to be an entry point
  {  }
}

/*
BEGIN-OUTPUT
OK
bla
called Convert
[1, 2, 3]
[1, 1, 1]
A
743.string
743.object
743x.string
743x.string
END-OUTPUT
*/
