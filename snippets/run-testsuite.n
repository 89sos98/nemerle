(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *) 


(* Requires $nempath/lib/hashtable.n and $nempath/lib/list.n *)
open System;
open System.Diagnostics;
open System.ComponentModel;
open System.IO;
open System.Text.RegularExpressions;
open System.String;
open Nemerle.Collections;
open Nemerle.Collections.List;


class Tester{

	private _nem_runtime:string;
	private _csc_runtime:string;
	private _bo_regexp:Regex;		// E: unbound
	private _eo_regexp:Regex;
	private _err_regexp:Regex;
	private _warn_regexp:Regex;
	private _ok_regexp:Regex;
	private mutable _filename:string;
	private mutable _checked_msg:Hashtable(string,string);
	private mutable _warn_lines:Hashtable(string,Regex);
	private mutable _err_lines:Hashtable(string,Regex);
	private mutable _err_overall_count:int;
	private mutable _ok_lines:Hashtable(string,string);
	private mutable _is_reading_output:bool;
	private mutable _expected_output:list(string);
	private mutable _was_output:bool;


 public this(nem_comp:string,csc_comp:string)
	{

		this._nem_runtime<-nem_comp;
		this._csc_runtime<-csc_comp;
		this._bo_regexp<-Regex("^BEGIN-OUTPUT");	
		this._eo_regexp<-Regex("^END-OUTPUT");		
		this._err_regexp<-Regex("//\\s*E:\\s*(?<1>.*)$");
		this._err_overall_count<-0;
		this._warn_regexp<-Regex("//\\s*W:\\s*(?<1>.*)$");
		this._ok_regexp<-Regex("//\\s*OK\\s{0,1}.*$");
		this.Init("");
		
 }



 private Init(filename:string):void
	{
	this._checked_msg<-Hashtable();
	this._filename<-filename;
	this._warn_lines<-Hashtable();
	this._err_lines<-Hashtable();
	this._ok_lines<-Hashtable();
	this._is_reading_output<-false;
	this._expected_output<-Nil();
	this._was_output<-false;
	()
	}

 private CheckLine(str:string,line_index:int):void		
	{

		if (this._eo_regexp.IsMatch(str))
		   {
			this._is_reading_output<-false;
			()
		   }
		else
		if (this._is_reading_output)
			{
			 this._expected_output<-(str::(this._expected_output));
			}
		 else 
		 {
		def _err_match=this._err_regexp.Match(str);
		if (_err_match.Success)
		   {
			this._err_lines.Add(string_of_int(line_index),Regex((_err_match.Groups[1]).ToString()));
			()
		   }
		else
		 {
		def _warn_match=this._warn_regexp.Match(str);
		if (_warn_match.Success)
		   {
			this._warn_lines.Add(string_of_int(line_index),Regex(_warn_match.Groups[1].ToString()));
			()
		   }
		else
		if (this._bo_regexp.IsMatch(str))
		   {
			this._is_reading_output<-true;
			this._was_output<-true;
			()
		   } 
		else
		if (this._ok_regexp.IsMatch(str))
		   {
			this._ok_lines.Add(string_of_int(line_index),"");
			()
		   }
		else{
		  ()
		};
		};
		};
		()			
	}

 private GetLineAndMsgType(out_str:string):int*string
	{
	  def out_line_match=(Regex(""+this._filename+":(?<1>\\d*):\\d*:\\s+(?<2>.*)$")).Match(out_str);
	  if (out_line_match.Success){
	  def line_number=((out_line_match.Groups[1]).ToString());
	  def msg_type_str=((out_line_match.Groups[2]).ToString());
	  if (msg_type_str.IndexOf("error:")!=(-1))
		(0,line_number)
	   else
	   if (msg_type_str.IndexOf("warning:")!=(-1))
		(1,line_number)
	   else
	        (-1,line_number)
	  }
	   else
	{
	  (-1,"")
	}
	}

 private HandleMsg(out_str:string):bool
	{
	  match (this.GetLineAndMsgType(out_str)){
		| (0,line) => 	 match (this._err_lines.Get(line)){
				| Some (err) => if(err.Match(out_str).Success&&(!this._checked_msg.Contains(line)))
						 this._checked_msg.Add(line,"")
						else
						();
						true					
				| None => 
				 if ((this._err_lines.Count())==0){
					false
					}
				 else
				 {
				  match (this._ok_lines.Get(line)){
					| Some (_) => false
					| None => true
					}
				 }
				}
		| (1,line) =>  	 match (this._warn_lines.Get(line)){
				| Some (warn) => if (warn.Match(out_str).Success&&(!this._checked_msg.Contains(line)))
						  this._checked_msg.Add(line,"")
						else 
						 ();
						true
				| None => (this._warn_lines.Count()!=0)
				 }
		| _ => true
		}		 
	}

 private NemerleTest():bool
	{
	
	mutable nem_compile<-Process();
	nem_compile.StartInfo.FileName<-(this._nem_runtime);
	nem_compile.StartInfo.Arguments<-("../../lib/core.n ../../lib/aliases.n ../../lib/list.n "+this._filename);
	nem_compile.StartInfo.RedirectStandardOutput<-true;
	nem_compile.StartInfo.UseShellExecute<-false;
// TODO:Errors errors errors ;)
	try {
 		def _=nem_compile.Start();
	mutable nem_output<-nem_compile.StandardOutput.ReadLine();
	nem_compile.WaitForExit();
	mutable is_ok<-true;
	while(nem_output != null)
	{
	   if (this.HandleMsg(nem_output))
		()
		else {
		print_endline("Unexpected Nemerle compiler's message:\n"+nem_output);
		is_ok<-false
		};
	   nem_output<-nem_compile.StandardOutput.ReadLine()
	}; 

	def Check(line:string,msg:Regex):void
		{
		  match (this._checked_msg.Get(line)){
		  | Some (_) => ()
		  | None => print_endline("Expected error: "+msg.ToString()+" hasn't occured in line: "+line);
		 	 is_ok<-false
			}
		};
	this._err_lines.Iter(Check);
	def Check(line:string,msg:Regex):void
	 {
		  match (this._checked_msg.Get(line)){
		  | Some (_) => ()
		  | None => print_endline("Expected warning: "+msg.ToString()+" hasn't occured in line: "+line);
		 	 is_ok<-false
			}
	};
	this._warn_lines.Iter(Check);
	is_ok
	}
	with err:Win32Exception => {
		print_endline("Error occured while running Nemerle compiler");
		false
		}
    }

 private TestOutput():bool
	{
	try 
	{
	 mutable runtime<-Process();
	 runtime.StartInfo.FileName<-"./out.exe";
	 runtime.StartInfo.Arguments<-"";
	 runtime.StartInfo.RedirectStandardOutput<-true;
  	 runtime.StartInfo.UseShellExecute<-false;
	def _=runtime.Start();
	runtime.WaitForExit();
	def CheckOutput(in_list:list(string),output:string,is_ok:bool):bool
		{
		  match((in_list,output)){
		  | (Nil,null) => is_ok
		  | (Nil,_) => print_endline("Runtime output is longer than it should be");
				false
		  | (_,null) => print_endline("Unexpected end of runtime output");
				false
		  | (h::tl,str) => if (h.Equals(str))
					CheckOutput(tl,runtime.StandardOutput.ReadLine(),is_ok)
				   else
					{
					print_endline("Runtime output: \""+str+"\"\ndoes not match expected: \""+h+"\"");
					CheckOutput(tl,runtime.StandardOutput.ReadLine(),false) 
					}		
		   }
		};
	CheckOutput(this._expected_output,runtime.StandardOutput.ReadLine(),true)
	}
	with err:Win32Exception => {
		print_endline("Error occured while running the program");
		false
		}
	}

 public AttachFile(filename:string):void
	{
	  try {	
		if (File.Exists(filename))
		 {
		
		this.Init(filename);
		def reader=File.OpenText(filename);
		mutable temp_str<-reader.ReadLine();
		mutable index<-1;	
		while(temp_str != null)
		 {
		   this.CheckLine(temp_str,index);
		   index<-index+1;
		   temp_str<-reader.ReadLine()
		 };
		reader.Close();
		this._expected_output<-List.rev(this._expected_output);
		 ()
		}
		else
		 ()
	  } with err:Exception =>
		print_endline("Error occured while reading the file")
	}

 public Test():void 
	{
	print_endline("Testing..."+this._filename);
	try
	{
	if (this.NemerleTest()){
		print_endline("Nemerle compile test passed");
		if (this._err_lines.Count()==0)
		{
		def csc_compile=Process();
		csc_compile.StartInfo.FileName<-(this._csc_runtime);
		csc_compile.StartInfo.RedirectStandardOutput<-true;
		csc_compile.StartInfo.UseShellExecute<-false;
		if (this._was_output)
		csc_compile.StartInfo.Arguments<-("/out:out.exe /nowarn:162 /nowarn:649 /nowarn:219 out.cs")
		else
		csc_compile.StartInfo.Arguments<-("/out:"+this._filename.Substring(0,this._filename.Length-2)+".netmodule /target:module /nowarn:162 /nowarn:649 /nowarn:219 out.cs");
		def _=csc_compile.Start();
		def _=csc_compile.WaitForExit();
		if (csc_compile.ExitCode==0)
		 {
		   print_endline("C# compilation succeeded");
		   if (this._was_output)
			{
		    	if(this.TestOutput())
			  print_endline("Runtime test passed")
			else
			  print_endline("Runtime test failed")
			}
			else
			 ()
		}
		else
		   {
		   print_endline("C# compilation failed");
		   this._err_overall_count<-this._err_overall_count+1
		   }
		}
		 else
		()
	}
	else
	{
		print_endline("Nemerle compile test failed");
		this._err_overall_count<-this._err_overall_count+1
	};
	()
	}
	with err:Win32Exception => 
		print_endline("Error occured while running Nemerle compiler")
	}

 public GetReport():int
	{
	 if(this._err_overall_count==0){
	   print_endline("All tests passed");
	   0
	}
	 else{
	   print_endline(string_of_int(this._err_overall_count)+" of tests failed");
	   1
	}
	}

 public static Main (args : array(string)): int 
	{ 
		def length = (args:Array).Length;
	//FIXME: Change path :)
		mutable nem_comp <- "<path to nermerle compiler>";
		mutable csc_comp <- "<path to C# compiler>";
		
(*
	Tell me if it works on your machine ;)
		Process.Start("ls");
*)
		if (length>0)
		{
		  nem_comp<-args[0];
	 	  if (length>1)
		   {
		    csc_comp<-args[1];
		   }
		  else
		   ();
		}
		else 
		();
		def tester = Tester(nem_comp,csc_comp);
		def this_file= Regex("test.n$");
		def str = Directory.GetFiles(Directory.GetCurrentDirectory(),"*.n");
		mutable fcounter<- ((str:Array).Length-1);

		while(fcounter>=0)
		{
		  if (!this_file.IsMatch(str[fcounter]))
			{
// For Windows compatibility:
		  tester.AttachFile(str[fcounter].Replace("\\","/"));
		  tester.Test()
			}
		else
		  ();	
		  fcounter<-fcounter-1;
		};
		tester.GetReport()
	}

}
