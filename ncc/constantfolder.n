/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler 
{
  module ConstantFolder
  {
    is_known_operator (name : string) : bool
    {
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "%^"
      | "%|"
      | "%&"
      | "&&"
      | "||"
      | "!"
      | "~" => true
      | _ => false
    }

    is_flag_enum (t : System.Type) : bool
    {
      t.GetCustomAttributes (typeof (System.FlagsAttribute), false).Length > 0
    }

    underlaying_enum_type (t : System.Type) : System.Type
    {
      def res =
        NArray.Fold (t.GetFields (), null, fun (elt : System.Reflection.FieldInfo, acc) {
          if (!elt.IsStatic) {
            assert (acc == null);
            elt.FieldType
          } else
            acc
        });
      assert (res != null);
      res
    }

    enum_field_value (env : GlobalEnv, expr : Expr) : Expr
    {
      def split (l, acc) {
        match (l) {
          | [x] => (List.Rev (acc), x)
          | x :: xs => split (xs, x :: acc)
          | _ => Util.ice ("empty")
        }
      };
      
      match (Util.qidl_of_expr (expr)) {
        | Some ((id, name)) =>
          def val = 
            List.FoldLeft (name.GetEnv (env).ExpandName (id), None (),
              fun (fullname, acc) {
                def (front, last) = split (fullname, []);
                
                match (GlobalEnv.LookupExactType (front)) {
                  | Some (t) =>
                    def is_enum_field (m : IMember) {
                      m.IsStatic () && match (m.GetKind ()) {
                        | MK_field => true
                        | _ => false
                      }
                    };
                    def members = t.LookupMember (last);
                    match (List.Filter (members, is_enum_field)) {
                      | [] => acc
                      | [x] =>
                        match (acc) {
                          | Some (y) when (y : IMember).GetId () != x.GetId () =>
                            Message.error ("the field name `" +
                                           Util.qid_of_list (id) +
                                           "' is ambigious");
                            Some (x)
                          | _ => Some (x)
                        }
                      | _ =>
                        Message.error ("the field name `" +
                                       Util.qid_of_list (id) + 
                                       "' is ambigious in its own type");
                        acc
                    }
                  | None => acc
                }
              });
          match (val) {
            | Some (field) =>
              def field = (field :> IField);
              def enum_ty = field.DeclaringType.GetSystemType ();
              def under_ty = underlaying_enum_type (enum_ty);
              def obj = field.GetFieldInfo ().GetValue (null);
              def r (l) { E_literal (L_enum (l, enum_ty)) };
              if (under_ty.Equals (typeof (int)))
                r (L_int ((obj :> int)))
              else if (under_ty.Equals (typeof (long)))
                r (L_long ((obj :> long)))
              else
                expr
            | None => expr
          }
        | None => expr
      }
    }

    literal_of_expr (e : Expr) : option <Literal>
    {
       | E_literal (l) => Some (l)
       | E_typed_expr (Typedtree.E_literal (l)) => Some (l)
       | _ => None ()
    }
    
    fold_unary_operator (name : string, 
                         e1 : Expr, expr : Expr) : Expr
    {
      match (literal_of_expr (e1)) {
        | Some (L_enum (lit, enum_ty)) 
          when name == "~" && is_flag_enum (enum_ty) =>
          def t = Option.UnSome (NumericType.ByLiteral (lit));
          def res = t.Unary (name, t.FromLiteral (lit));
          assert (res != null);
          E_literal (L_enum (t.ToLiteral (res), enum_ty))

        | Some (lit) =>
          match (NumericType.ByLiteral (lit)) {
            | Some (t) =>
              def res = t.Unary (name, t.FromLiteral (lit));
              if (res == null)
                expr
              else
                E_literal (t.ToLiteral (res))
            | None => expr
          }
        | None => expr
      }
    }

    fold_binary_operator (name : string, e1 : Expr, e2 : Expr, 
                          expr : Expr) : Expr
    {
      match ((literal_of_expr (e1), literal_of_expr (e2))) {
        | (Some (l1), Some (l2)) =>
          def (l1, l2, enum_ty) =
            match ((l1, l2)) {
              | (L_enum (l1, t1), L_enum (l2, t2)) 
                when t1.Equals (t2) && is_flag_enum (t1) =>
                (l1, l2, Some (t1))
              | _ => (l1, l2, None ())
            };
          match ((NumericType.ByLiteral (l1), NumericType.ByLiteral (l2))) {
            | (Some (t1), Some (t2)) when t1 == t2 =>
              def res = t1.Binary (name, t1.FromLiteral (l1), 
                                   t1.FromLiteral (l2));
              def lit = t1.ToLiteral (res);
              if (res != null)
                match ((enum_ty, name)) {
                  | (None, _) => 
                    E_literal (lit)
                  | (Some (t), "%|")
                  | (Some (t), "%&")
                  | (Some (t), "%^") => 
                    E_literal (L_enum (lit, t))
                  | (Some, _) =>
                    // other operators not allowed on enums
                    expr
                }
              else
                expr
            | _ => expr
          }
        | _ => expr
      }
    }
    
    fold_constants (env : GlobalEnv, expr : Expr, recurse : bool) : Expr
    {
      match (expr) {
        | <[ $(name : dyn) ($e1, $e2) ]> when is_known_operator (name) =>
          if (recurse)
            fold_binary_operator (name, 
                                  fold_constants (env, e1, true), 
                                  fold_constants (env, e2, true), 
                                  expr)
          else
            fold_binary_operator (name, e1, e2, expr)

        | <[ $(name : dyn) ($e1) ]> when is_known_operator (name) =>
          if (recurse)
            fold_unary_operator (name, fold_constants (env, e1, true), expr)
          else
            fold_unary_operator (name, e1, expr)
  
        | <[ $_o . $_f ]>
        | <[ $(_ : name) ]> => 
          enum_field_value (env, expr)

        | _ => expr
      }
    }

    internal FoldConstants (env : GlobalEnv, expr : Expr) : Expr
    {
      fold_constants (env, expr, true)
    }
    
    internal FoldTopConstants (env : GlobalEnv, expr : Expr) : Expr
    {
      fold_constants (env, expr, false)
    }

  }
}
