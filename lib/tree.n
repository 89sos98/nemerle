(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Collections.New {

public interface IComparableTo ('a)
  {
    Compare (_ : 'a) : int;
  }

public interface IComparator ('a)
  {
    Compare (_ : 'a, _ : 'a) : int;
  }

public class BalanceViolation extends System.Exception
	{
		public this(){}
	}

public class NotFound extends System.Exception
	{
		public this(){}
	}

public module Tree {

  public variant Color 
	{ 
	|	Red
	|	Black
	}

  public variant Node ('a) where 'a :> IComparableTo ('a)
    {
      | Tr {
		key : 'a;
		color : Color;
		lchild : Node ('a);
		rchild : Node ('a); 
		}
      | Leaf
    }

   public 'a where 'a :> IComparableTo ('a) 
   Get (tree: Node('a), elem: 'a): option ('a)
	{
	  def _get(tree: Node('a), candidate : option ('a)):option ('a) 
		{	
			match (tree) {
			| (Tr) as tree => if (tree.key.Compare(elem)>0)
						_get(tree.lchild,candidate)
						else
						_get(tree.rchild,Some (tree.key))
			| Leaf => match (candidate){
					| Some (key) => if (elem.Compare(key)==0)
								candidate
							  else 
								None ()
					| None => None ()
					}
			}
		};
	  _get(tree,None ())
	}

   public 'a where 'a :> IComparableTo ('a)
   Insert(tree: Node('a),elem: 'a,replace: bool): Node('a)
	{
		def _insert(tree: Node('a)): Node('a)
		{
			match (tree){
			| (Tr (key,Red,ltree,rtree)) as node =>
				if (elem.Compare(key)>0)
					Tr(key,Red(),ltree,_insert(rtree))
				else if (elem.Compare(key)<0)
					Tr(key,Red(),_insert(ltree),rtree)
				else if (replace)
					Tr(key,Red(),ltree,rtree)
					else 
					node
			| (Tr (key,Black,ltree,rtree)) as node =>
				if (elem.Compare(key)>0)
					BalanceRight(key,ltree,_insert(rtree))
				else if (elem.Compare(key)<0)
					BalanceLeft(key,_insert(ltree),rtree)
				else if (replace)
					Tr(key,Red(),ltree,rtree)
					else 
					node
			| Leaf => 
				Tr (elem,Red(),Leaf(),Leaf())
							
			}
		};
	   match (_insert(tree)){
		| Tr (key,_,ltree,rtree) =>
			Tr (key,Black(),ltree,rtree)
		| Leaf => Leaf ()
		}
	}

   'a where 'a :> IComparableTo ('a)
   BalanceLeft (elem: 'a, lchild: Node('a),rchild: Node('a)):Node('a)
	{
// Well this isn't too readable but quite efficient ;)
		match((elem,lchild,rchild)){
		| (key,Tr(key1,Red,ltree1,rtree1),Tr(key2,Red,ltree2,rtree2)) =>
			Tr(key,Red(),Tr(key1,Black(),ltree1,rtree1),Tr(key2,Black(),ltree2,rtree2))
		| (key,Tr(key1,Red,Tr(key2,Red,ltree2,rtree2),rtree1),rtree) =>
			Tr(key1,Red(),Tr(key2,Black(),ltree2,rtree2),Tr(key,Black(),rtree1,rtree))
		| (key,Tr(key1,Red,ltree1,Tr(key2,Red,ltree2,rtree2)),rtree) =>
			Tr(key2,Red(),Tr(key1,Black(),ltree1,ltree2),Tr(key,Black(),rtree2,rtree))
		| (key,ltree,rtree) =>
			Tr(key,Black(),ltree,rtree)
		}	
	}

   'a where 'a :> IComparableTo ('a)
   BalanceRight (elem: 'a, lchild: Node('a),rchild: Node('a)):Node('a)
	{
// same here ;)
		match((elem,lchild,rchild)){
		| (key,Tr(key1,Red,ltree1,rtree1),Tr(key2,Red,ltree2,rtree2)) =>
			Tr(key,Red(),Tr(key1,Black(),ltree1,rtree1),Tr(key2,Black(),ltree2,rtree2))
		| (key,ltree,Tr(key1,Red,ltree1,Tr(key2,Red,ltree2,rtree2))) =>
			Tr(key1,Red(),Tr(key,Black(),ltree,ltree1),Tr(key2,Black(),ltree2,rtree2))
		| (key,ltree,Tr(key1,Red,Tr(key2,Red,ltree2,rtree2),rtree1)) =>
			Tr(key2,Red(),Tr(key,Black(),ltree,ltree2),Tr(key1,Black(),rtree2,rtree1))
		| (key,ltree,rtree) =>
			Tr(key,Black(),ltree,rtree)
		}	
	}

  'a where 'a :> IComparableTo ('a)
   Balance (elem: 'a, lchild: Node('a),rchild: Node('a)):Node('a)
	{
// same here ;)
		match((elem,lchild,rchild)){
		| (key,Tr(key1,Red,ltree1,rtree1),Tr(key2,Red,ltree2,rtree2)) =>
			Tr(key,Red(),Tr(key1,Black(),ltree1,rtree1),Tr(key2,Black(),ltree2,rtree2))
		| (key,ltree,Tr(key1,Red,ltree1,Tr(key2,Red,ltree2,rtree2))) =>
			Tr(key1,Red(),Tr(key,Black(),ltree,ltree1),Tr(key2,Black(),ltree2,rtree2))
		| (key,ltree,Tr(key1,Red,Tr(key2,Red,ltree2,rtree2),rtree1)) =>
			Tr(key2,Red(),Tr(key,Black(),ltree,ltree2),Tr(key1,Black(),rtree2,rtree1))
		| (key,Tr(key1,Red,Tr(key2,Red,ltree2,rtree2),rtree1),rtree) =>
			Tr(key1,Red(),Tr(key2,Black(),ltree2,rtree2),Tr(key,Black(),rtree1,rtree))
		| (key,Tr(key1,Red,ltree1,Tr(key2,Red,ltree2,rtree2)),rtree) =>
			Tr(key2,Red(),Tr(key1,Black(),ltree1,ltree2),Tr(key,Black(),rtree2,rtree))
		| (key,ltree,rtree) =>
			Tr(key,Black(),ltree,rtree)
		}	
	}				

   public 'a where 'a :> IComparableTo ('a)
   Delete(tree: Node('a),elem: 'a): Node('a)
	{
		def _delete(tree: Node('a)): Node('a)
			{
				match(tree){
				| Tr(key,_,ltree,rtree) =>
					if (elem.Compare(key)>0)
					  match (rtree) {
						| Tr(_,Black,_,_) => BalRight(key,ltree,_delete(rtree))
						| _ => Tr(key,Red(),ltree,_delete(rtree))
						}	
					else if (elem.Compare(key)<0)
					  match (ltree) {
						| Tr(_,Black,_,_) => BalLeft(key,_delete(ltree),rtree)
						| _ => Tr(key,Red(),_delete(ltree),rtree)
						}
					else 
						GetSubst(ltree,rtree)
				| Leaf => Leaf()
				}
			};
		match (_delete(tree)){
		| Tr(key,_,ltree,rtree) =>
			Tr(key,Black(),ltree,rtree)
		| Leaf => Leaf()
		}	
	}
	
	'a where 'a :> IComparableTo ('a)
   	BalRight (elem: 'a, lchild: Node('a),rchild: Node('a)):Node('a)
	{
		match ((elem,lchild,rchild)){
		| (key,ltree,Tr(key1,Red,ltree1,rtree1)) =>
			Tr(key,Red(),ltree,Tr(key1,Black(),ltree1,rtree1))
		| (key,Tr(key1,Black,ltree1,rtree1),rtree) =>
			Balance(key,Tr(key1,Red(),ltree1,rtree1),rtree)
		| (key,Tr(key1,Red,Tr(key3,Black,ltree3,rtree3),Tr(key2,Black,ltree2,rtree2)),rtree)=>
			Tr(key2,Red(),Balance(key1,Tr(key3,Red(),ltree3,rtree3),ltree2),Tr(key,Black(),rtree2,rtree))
		| _ => raise BalanceViolation()
		}
	}

	'a where 'a :> IComparableTo ('a)
   	BalLeft (elem: 'a, lchild: Node('a),rchild: Node('a)):Node('a)
	{
		match ((elem,lchild,rchild)){
		| (key,Tr(key1,Red,ltree1,rtree1),rtree) =>
			Tr(key,Red(),Tr(key1,Black(),ltree1,rtree1),rtree)
		| (key,ltree,Tr(key1,Black,ltree1,rtree1)) =>
			Balance(key,ltree,Tr(key1,Red(),ltree1,rtree1))
		| (key,ltree,Tr(key1,Red,Tr(key3,Black,ltree3,rtree3),Tr(key2,Black,ltree2,rtree2)))=>
			Tr(key3,Red(),Tr(key,Black(),ltree,ltree3),Balance(key1,rtree3,Tr(key2,Red(),ltree2,rtree2)))
		| _ => raise BalanceViolation()
		}
	}

	'a where 'a :> IComparableTo ('a)
   	GetSubst (lchild: Node('a),rchild: Node('a)):Node('a)
	{
		match ((lchild,rchild)){
		| (Leaf,tree) => tree
		| (tree,Leaf) => tree
		| (Tr(key,Red,ltree,rtree),Tr(key1,Red,ltree1,rtree1)) =>
			match (GetSubst(rtree,ltree1)){
			| Tr(key2,Red,ltree2,rtree2) =>
				Tr(key2,Red(),Tr(key,Red(),ltree,ltree2),Tr(key1,Red(),rtree2,rtree1))
			| tree => Tr(key,Red(),ltree,Tr(key1,Red(),tree,rtree1))
			}
		| (Tr(key,Black,ltree,rtree),Tr(key1,Black,ltree1,rtree1)) =>
			match (GetSubst(rtree,ltree1)){
			| Tr(key2,Red,ltree2,rtree2) =>
				Tr(key2,Red(),Tr(key,Black(),ltree,ltree2),Tr(key1,Black(),rtree2,rtree1))
			| tree => BalLeft(key,ltree,Tr(key1,Black(),tree,rtree1))
			}
		| (tree,Tr(key,Red,ltree,rtree)) =>
			Tr(key,Red(),GetSubst(tree,ltree),rtree)
		| (Tr(key,Red,ltree,rtree),tree) =>
			Tr(key,Red(),ltree,GetSubst(rtree,tree))
		}
	}

 	 public 'a, 'b where 'a :> IComparableTo ('a) 
  	  Fold (func : 'b * 'a -> 'b, ini : 'b,  tree : Node ('a)) : 'b {
  	  match (tree) {
  	    | Tr (key,_,ltree,rtree) =>
  	      Fold (func, func (Fold (func, ini, ltree), key), rtree)
  	    | Leaf => ini
 	   }
 	 } 
	
}	
	
   class MapNode ('a, 'b) implements IComparableTo (MapNode ('a, 'b))
 	 {
  	  public key : 'a;
 	  public val : 'b;
    	  public cmp : IComparator ('a);
    
    	  Compare (x : MapNode ('a, 'b)) : int implements IComparableTo.Compare
      		{ this.cmp.Compare (this.key, x.key) }

    	  public this (c : IComparator ('a), k : 'a, v : 'b) 
     		 { 
       		 this.cmp <- c;
      		 this.key <- k; 
        	 this.val <- v;
      		}

    	  public this (c : IComparator ('a), k : 'a) 
      		{
      		 this.cmp <- c;
       		 this.key <- k;
      		}
  	} 
    class IntComparator implements IComparator (int)
  	{
 	   Compare (x : int, y : int) : int implements IComparator.Compare
    		  { x - y }
    	    public this () {}
  	}

    class StringComparator implements IComparator (string)
 	 {
   	   Compare (x : string, y : string) : int implements IComparator.Compare
      		{ compare_strings (x, y) }
   	   public this () {}
  	 }
 
 public class Map ('a, 'b, 'c) where 'c :> IComparator ('a)
  	{
   	 root : Tree.Node (MapNode ('a, 'b));
    	 cmp : IComparator ('a);
    // TODO: Make it implement ICollection (problem with names and being functional or imperative - both mb)
   	 public this (c : IComparator ('a))
      		{
      		 this.root <- Tree.Leaf ();
       		 this.cmp <- c;
     		 }

    	this (c : IComparator ('a), r : Tree.Node (MapNode ('a, 'b))) 
      	{
       	 	this.cmp <- c;
        	this.root <- r;
      	}

	public IsEmpty () : bool
    	{
     	 match (root) {
     	   | Tree.Leaf => true
           | _ => false
      	 }
   	}
    

	public Insert (k : 'a, v : 'b) : Map ('a, 'b, 'c)
      	{ Map (this.cmp, Tree.Insert (this.root, MapNode (this.cmp, k, v), false)) }
      
    	public Replace (k : 'a, v : 'b) : Map ('a, 'b, 'c)
     	 { Map (this.cmp, Tree.Insert (this.root, MapNode (this.cmp, k, v), true)) }
      
    	public Find (k : 'a) : option ('b) {
      	 match (Tree.Get (this.root, MapNode (this.cmp, k))) {
         | (Some) as n => Some (n.val.val) 
         | None => None ()
      	 }
    	}

    	public Get(k : 'a) : 'b {
      	 match (Tree.Get (this.root, MapNode (this.cmp, k))) {
         | (Some) as n => n.val.val 
         | None => raise (NotFound ())
      	 }
    	}

	public Member(k : 'a) : bool {
      	 match (Tree.Get (this.root, MapNode (this.cmp, k))) {
         | Some => true 
         | None => raise (NotFound ())
      	 }
    	}
	
	public Delete (k: 'a,v: 'b): Map ('a,'b,'c){
		Map (this.cmp, Tree.Delete (this.root,MapNode(this.cmp,k,v)))
		}

    	public 'd Fold (func : 'd * 'a * 'b -> 'd, ini : 'd) : 'd
        {
         def wrap (ctx : 'd, n : MapNode ('a, 'b)) : 'd {
          func (ctx, n.key, n.val)
         };
         Tree.Fold (wrap, ini, this.root)
      	}
      
    	public 'd Iter (func : 'a * 'b -> void) : void
      	{
        	def wrap (ctx : int, n : MapNode ('a, 'b)) : int
         	 { 
       		     func (n.key, n.val); 
      		      ctx 
   	       	};
        	def _ = Tree.Fold (wrap, 0, this.root);
        	()
     	}

    	static public 'd IntMap () : IntMap ('d)
      	{ Map (IntComparator ()) }
    	static public 'd StringMap () : StringMap ('d)
      	{ Map (StringComparator ()) }
	}

	public type IntMap('a) = Map(int,'a,IntComparator);
	public type StringMap('a) = Map(string,'a,StringComparator);
 
}
