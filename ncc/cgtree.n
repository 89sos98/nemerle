/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Collections;

using System.Reflection;
using System.Reflection.Emit;

namespace Nemerle.Compiler {

public class CG_method
{
  public mutable name : string;
  public mutable parms : list (CG_val);
  public mutable ret_type : System.Type;
  public mutable body : CG_expr;
  public mutable implemented_methods : list (IMethod);
  public mutable modifiers : list (Modifier);

  public mutable lambda_ctor : ConstructorBuilder;
  public mutable lambda_type_builder : TypeBuilder;
  public mutable closure_type : System.Type;
  public mutable closure_pointers : Int_map (FieldInfo);

  public mutable method_builder : MethodBuilder;
  public mutable constructor_builder : ConstructorBuilder;

  public this () { }  
}
  
public class CG_expr_base
{
  /** this is a cache for the type of the expression */
  public mutable ty : System.Type;

  public mutable loc : Location;  
  public this () {}
  public this (ty : System.Type) { this.ty <- ty }
}

public class CG_val
{
  public mutable loc : Location;
  public mutable name : string;
  public mutable ty : System.Type;
  public mutable val : CG_expr;

  public mutable local_slot : option (System.Reflection.Emit.LocalBuilder);
  public mutable parm_index : option (int);

  public this (loc : Location, name : string, ty : System.Type, val : CG_expr) 
  { 
    this.loc <- loc;
    this.name <- name;
    this.ty <- ty;
    this.val <- val;
    this.local_slot <- None ();
    this.parm_index <- None ();
  }
}
  
public variant CG_expr extends CG_expr_base
{ 
  | CE_ref { decl : CG_val; }
  | CE_global_ref { decl : System.Reflection.MemberInfo; } // not ctor
  | CE_ctor_ref { ctor : System.Reflection.ConstructorInfo; }
  | CE_field_ref { obj : CG_expr; fld : System.Reflection.FieldInfo; }
  | CE_method_ref { obj : CG_expr; meth : System.Reflection.MethodInfo; }
  | CE_method_addr { meth : System.Reflection.MethodInfo; } // ldftn
  | CE_ignore { expr : CG_expr; } // pop
  | CE_opcode { name : string; } // like +, == etc
  | CE_call { func : CG_expr; parms : list (CG_expr); }
  | CE_tail_call { func : CG_expr; parms : list (CG_expr); }
  | CE_self_tail_call { parms : list (CG_expr); }
  | CE_assign { target : CG_expr; source : CG_expr; }
  | CE_let { name : CG_val; body : CG_expr; }
  | CE_has_type { expr : CG_expr; test_type : System.Type; }
  | CE_raise { exn : CG_expr; }
  | CE_if { cond : CG_expr; e_then : CG_expr; e_else : CG_expr; }
  | CE_try_with { body : CG_expr; exn : CG_val; handler : CG_expr; }
  | CE_try_finally { body : CG_expr; handler : CG_expr; }
  | CE_literal { val : Literal; }
  | CE_this
  | CE_cast { expr : CG_expr; target_type : System.Type; }
  | CE_sequence { body : list (CG_expr); }
  | CE_mkarray { element_type : System.Type; initializers : list (CG_expr); }
  | CE_array_indexer { obj : CG_expr; args : list (CG_expr); }
  | CE_typeof { target_type : System.Type; }

  | CE_skip // FIXME: what is this for?

  /** reference to a base class constructor */
  | CE_base_ctor_ref { base_ctor : System.Reflection.ConstructorInfo; }
   
  /** 
   * Creates a jump table. The 'indexing_expr' is evaluated to an integer 
   * in range [0 .. List.Length (branches) - 1], then the corresponding
   * branch (or the default expression) gets calculated.
   */
  | CE_switch { 
      indexing_expr : CG_expr; 
      default : option (CG_expr);
      cases : list (int * CG_expr); 
    }
   
  /** denotes an empty program */
  | CE_none
} 


} // end ns
