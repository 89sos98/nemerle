open Nemerle.Compiler;
open Nemerle.Collections;


namespace Nemerle.Compiler {

(*
pass 1:
  Walk through Top_decls, set env field for all global symbols, register
  all global symbols. Return list of Type_decls.
*)

class Scan_globals
  {
    fun run (decls : list (Top_decl)) : list (Type_decl) =
      letfun loop (state : Env * list (Type_decl), decl : Top_decl) : Env * list (Type_decl) =
        let (?env, ?acc) = state in
        match decl with [
          | TD_namespace (?n, ?d) =>
//            let _ = print_endline("ns: " + n) in
            let env' = env#copy() in {
              env'#current_namespace <- env#current_namespace + n + ".";
              let (_, ?acc) = List.fold_left (loop, (env', acc), d) in
              (env, acc)
            }
          | TD_open (?n) =>
            let env' = env#copy() in {
              env'#add_open(n);
              (env', acc)
            }
          | TD_namespace_alias (?s, ?l) =>
            let env' = env#copy() in {
              env'#add_namespace_alias(s, l);
              (env', acc)
            }
          | TD_type (?d) =>
            {
//        print_endline("d: " + d#name);
              d#env <- env;
              let mem = M_type(d) in {
                mem#name <- d#name;
                mem#loc <- d#loc;
                mem#modifiers <- d#modifiers;
                mem#env <- d#env;
                mem#id <- d#id;
                Env.add_global(env#current_namespace, mem);
              };
              (env, Cons(d, acc))
            }
        ]
      in 
      let (_, ?r) = List.fold_left (loop, (Env(), Nil()), decls) 
      in List.rev(r);
  }


(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

} // N.C
