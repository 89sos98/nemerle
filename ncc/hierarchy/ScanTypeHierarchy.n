/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

namespace Nemerle.Compiler
{
  public module ScanTypeHierarchy
  {
    /** Process toplevel type declaration.
    
        This function does the very first pass, after parsing.
        It creates [TypeBuilder] object for each type and registers it
        in namespace hierarchy.
        It also creates classes of delegates and macros.
     */
    public ProcessDeclaration (decl : TopDeclaration) : void
    {
      def handle_type (parent, vop, env, t)
      {
        match (t) {
          | TopDeclaration.Macro (header, synt, expr) =>
            Macros.GenerateMacroClass (env, parent, t.modifiers, header, synt, expr)

          | TopDeclaration.Delegate (header) =>
            Delegates.GenerateDelegateClass (env, parent, t.modifiers, header)

          | _ =>
            def ti = GlobalEnv.AddType (parent, vop, env.CurrentNamespace, t);
            assert (ti != null);
            def me = Some (ti);
            def env_in_type = env.EnterIntoNamespace ([t.ParsedName.Id]);

            match (t) {
              | TopDeclaration.VariantOption (ds)
              | TopDeclaration.Interface (methods = ds)
              | TopDeclaration.Class (decls = ds) =>
                foreach (ClassMember.TypeDeclaration (t) in ds)
                  handle_type (me, None (), env_in_type, t)

              | (TopDeclaration.Variant) as td_v =>
                def fixup_option (x) {
                  | ClassMember.EnumOption (None) =>
                    def d = TopDeclaration.VariantOption (loc = x.loc, 
                                                          name = x.name, 
                                                          modifiers = x.modifiers,
                                                          decls = []);
                    ClassMember.TypeDeclaration (x.loc, x.name, x.modifiers, d)
                  | _ => x
                }
                td_v.decls = List.Map (td_v.decls, fixup_option);

                foreach (x in td_v.decls) {
                  match (x) {
                    | ClassMember.TypeDeclaration (TopDeclaration.VariantOption as d) =>
                      handle_type (me, me, env_in_type, d)

                    | ClassMember.EnumOption =>
                      Message.error (t.Location, "variant options cannot have value, they are not enums")
                    | _ => ()
                  }
                }

              | TopDeclaration.Enum => ()
              | TopDeclaration.Alias => ()
              | TopDeclaration.Macro => assert (false)
              | TopDeclaration.Delegate => assert (false)
            };
            when (ti != null)
              ti.ReverseChildren ();
        }
      }
      handle_type (None (), None (), decl.ParsedName.context, decl); 
    }
  } // module ScanTypeHierarchy
} // N.C
