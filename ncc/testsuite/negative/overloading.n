using Nemerle.IO;

class A {}
class B : A {}
class C : B { public this () {} }
 
module M {
  f (_ : A, _ : B) : void {}
  f (_ : B, _ : A) : void { printf ("OK\n") }
  public Main () : void {
    f (C (), C ());     // E: typing fails on ambiguity between overloads
  }
}


using M1;
using M2;

interface I1 {}
interface I2 {}
interface I : I1, I2 {}

class MM {
  static f (_ : I1) : void {}
  static f (_ : I2) : void {}
  static m (a : I) : void { MM.f (a) }    // E: typing fails on ambiguity between overloads
}

class M1 {
  public static g (_ : I) : void {}
}

class M2 {
  public static g (_ : I) : void {}
}

class M3 {
  static h (a : I) : void { g(a) }    // E: typing fails on ambiguity between overloads
}


namespace ConstVariantAndType {
  using X;

  class TextView {
  }

  variant X
  {
    | TextView
  }

  module M {

   Main () : void
   {
     def x = TextView (); // E: typing fails on ambiguity between overloads
     ()
   }
  }
}


namespace NotExpectVoidInSequence {
namespace n1 {
        class Attribute {}
}

namespace n3 {
        using n1;
        using System;
        class A {
                 Attribute () : void {
                    ();
                }
                 X () : void
                {
                        Attribute (); // E: ambiguity
                    ();
                }
                static Main () :  void {
                         A ().X ();

                }
        }
}
}
