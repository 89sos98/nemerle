\documentclass[]{article}
\usepackage[latin2]{inputenc}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{hcolor}
\usepackage{color}
\usepackage[a4paper, top=2.5cm, left=2.5cm, right=2.5cm, bottom=3.5cm]{geometry}

\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\netf}[0]{{\tt .NET} framework}
\newcommand{\nem}[0]{Nemerle}
\newcommand{\cs}[0]{C\#}
\newcommand{\oo}[0]{object-oriented}
\newcommand{\kw}[1]{{\tt \bf #1}}

\DefineVerbatimEnvironment
  {Code}{Verbatim}
  {frame=lines,numbers=left,xleftmargin=15mm,%
   xrightmargin=10mm,framesep=2mm,framerule=1mm,%
   rulecolor=\color[rgb]{0.8,0.8,0.8}}

\begin{document}

\title{{\Huge \sc Nemerle} \\ 
  Introduction to a Functional \net\ Language \\
  {\large \tt http://nemerle.org/}}
\author{Micha³ Moskal, Pawe³ W. Olszta, Kamil Skalski \\
{\tt \{michal.moskal,pawel.olszta,kamil.skalski\}@nemerle.org} \\
{\small University of Wroc³aw}}
\date{\today}

\maketitle

\thispagestyle{empty}

\begin{abstract}
  \nem\ is a new functional language designed from the ground up for the \net.
  In this paper we have focused on features absent in traditional ML-like and \oo\ languages:
  variant inheritance, powerful assertions and code-generating macros. We also 
  gave some concern for the syntax and the ``spirit'' of \nem\ that makes it a good
  transition language for programmers with \cs\ background.
\end{abstract}

\pagestyle{fancy}
\lhead{Moskal, Olszta, Skalski -- \it Nemerle}
\rhead{\thepage}
\cfoot{}


\section{Motivation}

Our objective was to create a statically typed functional language with well 
founded \net~\cite{CLI}\ interoperability. The \net\ environment, especially 
since the introduction of generics~\cite{Generics}, provides an excellent 
platform for high-level language implementation which:

\begin{itemize}
  \item comes with a rich class library in the core system
  \item gives access to vast cache of additional third party libraries
  \item provides automatic garbage collection and security features
  \item handles native code generation and low-level optimizations (JIT)
  \item guarantees portability of executables
  \item allows integration with existing development tools
  \item etc. etc.
\end{itemize}

Of course, the framework is heavily \oo\ and primarily focused on traditional
\oo\ and imperative languages. Therefore ports of the existing functional 
languages to the \net\ did not fit in as well, as for example, \cs~\cite{CS}
does. Addressing this issue was the main idea behind the design of \nem.

In comparison to Haskell~\cite{Haskell} or SML~\cite{SML}, \nem\ is not a pure 
language in the functional sense, allowing the programmer to create completely 
\oo\ and imperative programs. This makes \nem\ a good transition language for 
people with C-like imperative and \oo\ languages background. They can take 
advantage of the language's imperative features until they gradually learn 
how to program in the functional fashion.

Easy access to imperative constructs is only one of the requirements needed 
in such a transition language. Probably the hardest thing about learning ML 
is understanding the compiler error messages about typing mismatches. This 
may seem odd at the first glance, but this is the reality -- type inference
is very nice when it works, but when it fails, you are stuck with error
messages hundred lines from place of the real error. 

We have decided to avoid language constructions that produce typing errors in ML, 
while generating syntax errors in other languages (for example function application 
being just $\epsilon$); requiring the typing to be explicit, at least for global 
functions -- implicit typing is not really possible to achieve when aiming for
a good support for methods overloading.

It seems easy to observe that it is the quality of the design of the \oo\ system 
to determine usability of a programming language. While the existing \oo\ extensions 
to functional languages are appealing because of their elegance, they do not fit 
the \netf\ at all. We have decided to make our \oo\ system simply mirror 
the \net\ design.


\section{Overview}

At the high level \nem\ can be characterized as a combination of \cs\
at the class level and a ML-like language at the expression level. 
However the syntax of the ML fragment is much less ambiguous and 
more C-like than Algol-like. The result is an expression-oriented 
language with a feeling of \cs.

Of course we also need variants\footnote{Called datatypes in SML,
and sometimes sum types in Caml.}, pattern matching and functional
values. These can be thought of as extensions to the base 
\cs-like language.

There are some other facts about \nem\ that are implied by the 
``not-so-ML-like \net\ language'' paradigm:

\begin{itemize}
  \item The language is statically typed, but dynamic cast are available
        and can be used when needed.
  \item The language combines functional, \oo, and imperative features.
  \item The object system is a one-to-one mapping of CLR's -- making it
        fairly easy to understand.
  \item The language fully interoperates with other \net\ languages -- it
        is both a CLS consumer and producer.
\end{itemize}

In the following sections we will show how the language looks like and
how is it different from ML and \cs. Reader is assumed to have some
basic knowledge about both ML and \cs.

It is important to mention that the language is still evolving and that
its design is quite flexible. Especially the assertions and macros are 
relatively new features. We are open to any suggestions.


\section{The language}

Top-level program structure reassembles \cs. There are namespaces,
then classes and finally methods. We also have modules (classes with all
members static and public) and variants. Let us look at the famous example:

\begin{Code}
  class Hello {
    public static Main () : void {
      System.Console.WriteLine ("Hello world, " +
                       "my name is not Jan B.!");
    }
  }
\end{Code}

The basic building block of a method is a sequence. A sequence groups local
definitions (specified with the \kw{def} keyword), expressions computed for
their side effects and the final expression returned as the value of entire
sequence\footnote{We put here value bindings and side-effect expressions
into one can. This is exactly how it works in imperative languages and 
(under the hood) in eager functional languages. It models real world
behavior better, and should be easier to understand.}.

\begin{Code}
public static factorial (x : int) : int {
  def loop (acc, x) {
    if (x <= 1)  acc
    else         loop (acc * x, x - 1)
  };
  loop (1, x)
}
\end{Code}

In this example the local function is implicitly typed -- its type is
inferred automatically by the compiler. Global functions are explicitly
typed by design of the language.


\subsection{Mutable values}

Mutable local values are defined using declarations like 
\kw{mutable}\ $x$\ {\tt <-}\ $expression${\tt ;}. The value $x$ can be 
later used as a value bound with \kw{def} without any explicit dereference 
operator\footnote{Like the {\tt !} operator in ML.}, but can be 
assigned using the assignment operator ({\tt <-}).

\begin{Code}
public static factorial (x : int) : int {
  mutable acc <- 1;
  mutable k <- n;
  while (k > 0) {
    acc <- acc * k;
    k <- k - 1;
  };
  acc
}
\end{Code}

The \kw{while} loop should be considered just different form of tail
recursion. It is in fact implemented as a macro which generates the
following code:

\begin{Code}
public static factorial (x : int) : int {
  mutable acc <- 1;
  mutable k <- n;
  def loop () {
    when (k > 0) {
      acc <- acc * k;
      k <- k - 1;
      loop ()
    }
  };
  loop ();
  acc
}
\end{Code}

Our optimizer is clever enough to recognize that it needs no new \verb,loop,
method here -- it will just insert the \verb,br, opcode at the il level.

The \kw{mutable} keyword can be also used as a modifier on fields. The contents
of such fields can be modified using the same assignment operator.


\subsection{Variants and pattern matching}

Variants are compiled to subclassing and should be thought of as subtypes.
For example:

\begin{Code}
variant BinaryTree <'a> {
  | Leaf { val : 'a; }
  | Node { left : BinaryTree <'a>; 
	   val : 'a; 
	   right : BinaryTree <'a>; }
} 
\end{Code}

Would be compiled to:

\begin{Code}
class BinaryTree<A> {}
class Node<A> : BinaryTree<A> { 
  BinaryTree<A> left; 
  A val; 
  BinaryTree<A> right; 
}
class Leaf<A> : BinaryTree<A> {}
\end{Code}

However in absence of of generics support in the current Framework release
type qualifiers are stored as attributes alongside the type declarations.

Of course we can use regular ML-like matching over variants:

\begin{Code}
count<'a> (t : BinaryTree <'a>) : int {
  match (t) {
    | Node (l, _, r) => count (l) + 1 + count (r)
    | Leaf => 1
  }
}
\end{Code}

The \verb|'a| after \verb|count| quantifies following occurrences of
\verb|'a|.

It is also possible to have deep patterns like \verb,Foo (Bar (Baz)),
to match constants and to match real tuples. We also support pattern 
guards -- that is condition checked after pattern has matched.


\subsection{Variant inheritance}

The subtyping model allows the variants to carry slightly more
information then their ML counterparts. In particular it is possible to
make the variant base class have some fields, methods or even derive
from some other class.  This way all variant options can have some
common part. Example (taken from \nem\ compiler, which is written in
\nem\ itself):

\begin{Code}
class Located {
  file : string;
  line : int;
}

variant Expr extends Located {
  | E_call { fn : Expr; parms : list <Expr>; }
  | E_ref { name : string; }
}

public static dump (e : Expr) : void {
  print ("// " + e.file + ": " + e.line.ToString ());
  match (e) {
    | E_ref (name) => print (name)
    | E_call (fn, parms) =>
      dump (fn);
      List.iter (dump, parms)
  }
}
\end{Code}


\subsection{Constrained parametric types}

Types can be parametrized over other types. Type arguments can be
constrained. This works the same way as generics do in IL. It is also 
possible to parametrize methods.

\begin{Code}
variant tree <'a> where 'a : IComparable <'a> {
  | Node { 
      left : tree <'a>; 
      data : 'a; 
      right : tree <'a>; 
    }
  | Tip
}
\end{Code}

This is the \nem\ way to do things that would have been done with
functors in ML-like languages. It is not strictly as powerful, but 
seems to be good enough in practice and it integrates well with 
the \netf.


\section{Assertions}

Currently we have C-like \kw{assert}\ implemented as a macro. We plan implement
have \kw{require}\ and \kw{ensure}\ to support design by contract, as well
as several special assertions for mutable value enforcing invariants.

\begin{itemize}
  \item mutable values \kw{guarded}\ with assertions -- update of this very 
        value triggers associated assertion
  \item \kw{guard} assertions that are checked after update of any value 
        directly referenced from the assertion body; checks are performed 
        until the end of the current block
\end{itemize}

It is possible to attach the \kw{guard}\ assertions to local values, instance
fields, and static fields (global values).

We sometimes want assertions like \verb,x + y == 5, to hold, with mutable
\verb,x, and \verb,y,. To allow update of \verb,x, immediately followed
by update of \verb,y, \kw{transaction} block is introduced. Assertions to
be triggered during the \kw{transaction} block are stacked, and executed
when control leaves it.

It is to be reconsidered when exactly we check assertions. Enforcing
check after each update can be hard in presence of parameters passed
by \kw{ref}.


\section{Macros}

Macros in \nem\ have much more to do with Meta Haskell~\cite{MetaHaskell}, 
CamlP4~\cite{CamlP4} or Scheme Lisp code-generating macros, than with macros 
in languages like C. Macros are essentially compiler plugins -- pieces 
of \nem\ code that take type or expression abstract syntax trees (AST) 
and return some other expressions or types (also as AST).

Macros are by definition Turing-complete\footnote{It is not by accident
like in some other languages.}. Macros can access external files,
can extract typing information from a running database and generally
do whatever you can imagine.

Macros are executed at the compilation time. The code they generate is later
statically type checked. Macros are thus safe. There is always risk that
macro will crash (or loop) during the compilation, but there is no way
to avoid that while retaining its expressiveness.

As said before macros are written in Nemerle itself. In principle it 
would be possible to use any other \net\ language, but \nem\ provides special
code quotation syntax to construct and walk its own AST. It provides clear
separation of meta-language from object language it is describing.

Macros can be also executed at the run time, taking advantage of dynamic
aspects of the \netf. This can be used for example to develop programming
language interpreters, or to specialize code for efficiency.

Our meta-system is closely interleaved with compilation process. 
It can perform guided by user partial typing of program's AST. Compiler's 
internal typing procedures are executed by macro's code in arbitrary order
and their result can be analyzed giving much more information about program.

\subsection{Usage}

Example uses of macros:

\begin{itemize}
  \item extending syntax of language
  \item embedding special purpose sublanguages in \nem:
  \begin{itemize}
    \item \verb,printf,\ and \verb,scanf,\ like functions
    \item binding optional and named groups in regular expression to local 
          variables
    \item \verb,$,-interpolation like in Bourne shell or Perl   %$
    \item binding results of SQL queries to local variables in type safe way
    \item special syntax for XPath or some other XML-matching constructions
  \end{itemize}

  \item generation of AST from external files
  \begin{itemize}
    \item Yacc and Burg-like tools
    \item generating types from XML schema or DTD
  \end{itemize}

  \item generation of external files based on AST
  \begin{itemize}
    \item pretty printing generated or original code
  \end{itemize}

  \item generation of AST based on other AST
  \begin{itemize}
    \item generating XML serialization methods
    \item specialization of code at the source language level
    \item support for Aspects-Oriented Programming by adding 
          cross-cutting ``concerns'' to program in algorithmic
          and arbitrarily flexible way   
  \end{itemize}
\end{itemize}

\subsection{Example: regular expression macro}

This macro matches given string against pattern in sequence
binding matched groups to variables. Not the use of \verb,printf,
macro in this example.

\begin{Code}
regexp match (s) {
  | "a*.+" => printf ("a\n");
  | @"(?<num : int>\d+)-\w+" => printf ("%d\n", num + 3);
  | "(?<name>(Ala|Kasia))? ma kota" =>
    match (name) {
      | None => printf ("noname?\n")
      | Some (n) => printf ("%s\n", n)
    }
  | _ => printf ("default\n");
}
\end{Code}

\subsection{Example: SQL queries macro}

This macro requires an SQL parser, and access to database we are working on,
so that the types of table columns and stored functions can be determined. 
It is needed to determine types of SQL expressions, which can be later used
to produce source language bindings for values returned by SQL queries.

\begin{Code}
  sql_loop (conn, "SELECT salary, LOWER (name) AS lname"
                  "  FROM employees"
                  "  WHERE salary > $(min_salary * 3)")
    sql_print ("$lname : $salary\n")
\end{Code}

And the result:

\begin{Code}
  def cmd = SqlCommand ("SELECT salary, LOWER (name)"
                        "  FROM employees"
                        "  WHERE salary > @parm1", conn);
  cmd.Parameters.Add ("@parm1", min_salary * 3);
  def r = cmd.ExecuteReader ();
  while (r.Read ()) {
    def salary = r.GetInt32 (0);
    def lname = r.GetString (1);
    printf ("%s: %d\n", lname, salary)
  }
\end{Code}


\subsection{Example: A sample macro implementation}

This is a sample implementation of a macro that adds \cs -like
\verb,foreach, loop to language (together with special syntax
for this construct). 
This code comes directly from the compiler implementation.

\begin{Code}
  macro @foreach (iter : funparm, collection, body) 
  syntax ("foreach", "(", iter, "in", collection, ")", body)
  {
    match (iter) {
      | <[ funparm: $(iname : var) : $ty ]> =>
        <[ def enumerator = $collection.GetEnumerator ();
           while (enumerator.NextMove ()) {
             mutable $(iname : var) <- (enumerator.Current :> $ty);
             $body;
           }
        ]>        
      | _ =>
        Message.fatal_error ("iterator in foreach must be identifier" + 
                             "with optional type")
    }
  }
\end{Code}

The code generated by the presented macro is constructed by 
the quotation construct in lines 6--13. Note that it creates code,
which uses another syntax-extending macro, the \verb,while, loop.

\section{Code generation}

The typed abstract syntax tree of expressions is converted into 
an intermediate functional description of a stack machine which
is later used to build the compiler output using the 
\verb,System.Reflection.Emit, API. 

Optimizations are performed on both the typed AST level as well as
on the intermediate representation level. For example tail calls
are marked as such during AST generation, while matching automata
generation is performed after intermediate code is generated.


\subsection{Tail call elimination}

We have implemented tail calls using the \verb,tail., prefix available in IL.
However it did not bring any improvements to the execution speed, it even slowed
things down by a factor of 15\%.

For tail calls to the current function, we have implemented simple
transformation to argument assignment and goto. It brought little speed improvement (over
version without tail calls), but reduced memory usage by about 20\% (compared to the same version). 
Later we have implemented real loops (that is we do not always generate new method for local
functions now), it made things faster by about 12\%.

\subsection{Matching optimizations}

We are working on good matching code generation using hashing function
and binary search automates. This is however in very early stage.


\section{Summary}

We have shown the key points of a new functional language for the \netf.
The language combines well-known concepts in a unique fashion. We believe 
that it could be used to teach the basics of functional programming and 
the \net. We also hope it can be used outside academia as a real life, 
industry language.

\newcommand{\bibent}[3]{\bibitem{#1} #2: {\it #3}.}
\newcommand{\bibweb}[2]{\bibitem{#1} {\tt #2}}

\begin{thebibliography}{9}
\bibent{Generics}{Andrew Kennedy, Don Syme}{Design and Implementation of Generics for 
the .NET Common Language Runtime}
\bibent{SML}{Robin Milner, Mads Tofte, Robert Harper}{The Definition of Standard ML}
\bibent{Haskell}{Simon Peyton Jones, John Hughes}{Report on the Programming Language Haskell 98}
\bibent{MetaHaskell}{Tim Sheard, Simon Peyton Jones}{Template metaprogramming for Haskell}
\bibent{CS}{International Organization for Standardization}{C\# Language Specification,
ISO/IEC 23270:2003}
\bibent{CLI}{International Organization for Standardization}{Common Language Infrastructure,
ISO/IEC 23271:2003}
\bibweb{CamlP4}{http://caml.inria.fr/camlp4/}
\end{thebibliography}

\end{document}
