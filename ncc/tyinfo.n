(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

class Tyinfo
  {
    variant Member
      {
        | Mem_methods { methods : list (M_function); }
        | Mem_field { fld : M_field; }
      }
      
    class Subtyping_relation
      {
        ti : Tyinfo;
        args : list (option (Type));
      }
    
    enclosing_type : option (Tyinfo);
    id : int;

    mutable pt_tydecl : PT.Type_decl;
    
    mutable tydecl : Type_decl;
    mutable t_extends : option (Type);
    mutable t_implements : list (Type);
    mutable is_module : bool;
    name : string;
    env : Env;
    loc : Location;
    modifiers : list (Modifier);
    mutable member_list : list (Class_member);
    mutable contained_types : list (Tyinfo);
    mutable typarms : list (Tyvar.T);
    mutable tenv : Tyvar.TEnv;
    
    mutable subtypes : Int_map (Subtyping_relation);
    mutable member_map : String_map (Member);
    mutable phase : int; // used by iter function
    // FIXME methods to implement
    
    static mutable infos : Int_map (Tyinfo);        // FIXME: this can be list
    static mutable can_check_constraints : bool;

    this (par : option (Tyinfo), env : Env, td : PT.Type_decl) 
      { 
        this.enclosing_type <- par;
        this.pt_tydecl <- td;
        this.env <- env;
        this.name <- td.name;
        this.modifiers <- td.modifiers;
        this.loc <- td.loc;
        
        this.subtypes <- Map.int_map ();
        this.member_map <- Map.string_map ();

        this.id <- Util.next_id ();

        if (infos == null) 
          infos <- Map.int_map () 
        else ();
        infos <- infos.add (this.id, this);
      }

    bind_tyvars (tenv : Tyvar.TEnv) : void 
      {
        if (this.tenv != null) Util.ice () else ();
        def (tenv, tyvars) = tenv.add_typarms (this.env, this.pt_tydecl.typarms);
        this.tenv <- tenv;
        this.typarms <- tyvars;
        
        def bind_child (x : Tyinfo) : void
          {
            Util.locate (x.loc, fun () : void { x.bind_tyvars (tenv) });
            match (x.pt_tydecl) {
              | PT.TD_variant_option => x.typarms <- tyvars
              | _ => ()
            }
          }
        List.iter (bind_child, this.contained_types);
      }

    
    bind_types () : void
      {
        def tenv = this.tenv;
        def bind (t : PT.Type) : Type { tenv.bind (this.env, t) }
        def td = this.pt_tydecl;
        this.tydecl <-
          match (td) {
            | PT.TD_class => TD_class ()
            | PT.TD_module => this.is_module <- true; TD_class ()
            | PT.TD_alias (t) => TD_alias (bind (t))
            | PT.TD_interface => TD_interface ()
            | PT.TD_external (n) => TD_external (n)
            | PT.TD_variant => TD_variant ()
            | PT.TD_variant_option => TD_variant_option ()
          };
        this.t_extends <- Option.map (bind, td.t_extends);
        this.t_implements <- List.map (bind, td.t_implements);
      }
    
    lookup_method (name : string) : list (M_function) {
      match (this.member_map.find(name)) {
        | Some (Mem_methods (x)) => x
        | _ => Nil()
      }
    }
      
    lookup_field (name : string) : option (M_field) {
      match (this.member_map.find(name)) {
        | Some (Mem_field (x)) => Some(x)
        | _ => None()
      }
    }

    how_subtypes (ti : Tyinfo) : option (list (option (Type))) {
      match (this.subtypes.find (ti.id)) {
        | Some (sr) => Some (sr.args)
        | None => None ()
      }
    }

    fullname () : string { this.env.current_namespace + this.name }

    basename () : string { this.name }
   
    enclosing_tyinfo () : Tyinfo {
      Util.unsome (this.enclosing_type)
    }
      
    direct_supertypes () : list (Type) {
      match (this.tydecl) {
        | TD_variant_option =>
          List.cons ((this.enclosing_tyinfo ()).generic_type ())
        | _ =>
          match (this.t_extends) {
            | Some (t) => Cons (t, this.t_implements)
            | None => this.t_implements
          }
      }
    }

    generic_type () : Type
      {
        def make_tv (tv : Tyvar.T) : Type { T_var (tv) }
        T_app (this, List.map (make_tv, this.typarms))
      }

    fresh_generic_type () : Type {
      this.generic_type () /- this.fresh_subst ()
    }

    fresh_subst () : Subst {
      Tyvar.fresh_subst (this.typarms)
    }

    make_subst (args : list (Type)) : Subst
      {
        def loop (ini : Subst, parms : list (Tyvar.T), args : list (Type)) : Subst {
          match ((parms, args)) {
            | (Cons (p, ps), Cons (a, args)) =>
              match (a) {
                | T_var (p') =>
                  if (p.id == p'.id) ini
                  else loop (ini.add (p.id, a), ps, args)
                | _ => loop (ini.add (p.id, a), ps, args)
              }
            | (Nil, Nil) => ini
            | _ => Util.ice ()
          }
        }
        loop (Map.int_map (), this.typarms, args)
      }
    
    // check if we can access D from THIS
    // FIXME
    can_access (d : Class_member) : bool { true }
    
    can_access_any (ds : list (Class_member)) : bool {
      List.exists (fun (d : Class_member) : bool { this.can_access (d) }, ds)
    }

    type Subinfo = Int_map (Subtyping_relation);

    // iterate over tyinfos, but supertypes are always processed before subtypes
    // otherwise source-code order is retained
    static iter (f : Tyinfo -> void) : void
      {
        def working_on = Util.next_id ();
        def done = Util.next_id ();
        def sub_do (t : Type) : void {
          match (t) {
            | T_app (ti, _) => maybe_f (ti)
            | _ => ()
          }
        }
        and maybe_f (ti : Tyinfo) : void {
          if (ti.phase == done) ()
          else if (ti.phase == working_on)
            Message.error(ti.loc, "type definition for `" + ti.fullname() + "' is cyclic")
          else {
            ti.phase <- working_on;
            Util.locate (ti.loc, fun () : void {
              List.iter (sub_do, ti.direct_supertypes ());
              f (ti)
            });
            ti.phase <- done
          }
        }
	if (infos == null) 
          ()
        else 
	  infos.iter(fun (_ : int, ti : Tyinfo) : void { maybe_f (ti) });
      }

    static add_subtyping_of (ti : Tyinfo, s : Subinfo, t : T_app) : Subinfo
      {
        def (sub, ti') = Tyutil.subst_of_app (t);
        def add_sr (s : Subinfo, sr : Subtyping_relation) : Subinfo {
          match (s.find (sr.ti.id)) {
            | Some (sr') =>
              mutable problem <- "";
              def opt_eq (a : option (Type), b : option (Type)) : bool {
                match ((a, b)) {
                  | (Some (t1), Some (t2)) =>
                    if (Tyutil.types_eq (t1, t2)) true
                    else {
                      problem <- "types " + t1.as_string() + " and " +
                                 t2.as_string() + " are not compatible";
                      false
                    }
                  | (None, None) => true
                  | _ => false
                }
              }
              if (List.forall2 (opt_eq, sr.args, sr'.args)) s
              else {
                Message.error ("type `" + sr.ti.fullname () + 
                               "' is implemented by type `" +
                               ti.fullname() +
                               "' twice under different instantiations");
                if (ti'.id == sr.ti.id)
                  Message.error ("second one directly")
                else
                  Message.error ("second one through `" + ti'.fullname() + "'");
                Message.error (problem);
                s
              }
            | None => 
              s.add (sr.ti.id, sr)
          }
        }
        def add_sr_from_parent (s : Subinfo, _ : int, 
                                sr : Subtyping_relation) : Subinfo
          {
            def apply_sub (t : option (Type)) : option (Type) {
              match (t) { 
                | Some (x) => Some (x /- sub) 
                | None => None ()
              }
            }
            def new_sr = Subtyping_relation (sr.ti, List.map (apply_sub, sr.args));
            add_sr (s, new_sr)
          }
          
        def s = ti'.subtypes.fold(add_sr_from_parent, s);
        def args = List.map (fun (x : Type) : option (Type) { Some (x) }, t.args);
        def new_sr = Subtyping_relation (ti', args);
        add_sr (s, new_sr)
      }
      
    static determine_subtyping () : void
      {
        def make_srs (ti : Tyinfo) : void
          {
            def add_srs (s : Subinfo, t : Type) : Subinfo {
              match (t) {
                | T_app t => add_subtyping_of (ti, s, t)
                | _ =>
                  Message.error("cannot implement nor extend non-class type");
                  s
              }
            }
            ti.subtypes <- List.fold_left (add_srs, Map.int_map (), ti.direct_supertypes ())
          }
        iter (make_srs)
      }

    subtyping_subst (ti : Tyinfo) : Subst {
      if (ti.id == this.id) 
        Map.int_map () // current type, no substitution
      else
        match (this.how_subtypes (ti)) {
          | None => Util.ice ()
          | Some (args) =>
            def f (t : option (Type)) : Type {
              match (t) {
                | Some (t) => t
                | None => Tyvar.free_variable ()
              }
            }
            ti.make_subst (List.map (f, args))
        }
      }
    
    // Return type of given member in this type (i.e. if type comes from
    // supertype, substitute it). Only works for methods and fields.
    member_type (m : Class_member) : Type
      {
        def t =
          match (m) {
            | M_field f => f.ty
            | M_function f => Tyutil.fun_type (f.header)
          };
        t /- this.subtyping_subst (m.tyinfo);
      }

    add_member (d : Class_member) : void
      {
        Env.add_global (this.fullname () + ".", d);
        d.tyinfo <- this;
        this.member_list <- Cons (d, this.member_list);
      }
      
    static make_member_list (this_ : Tyinfo) : void
      {
        def tenv = this_.tenv;
        can_check_constraints <- true;
        def types =
          match (this_.tydecl) {
            | TD_alias (t) => Cons (t, this_.direct_supertypes ())
            | _ => this_.direct_supertypes ()
          };
        def check_type (t : Type) : void {
          match (t) {
            | T_ref (t) => check_type (t)
            | T_out (t) => check_type (t)
            | T_fun (ts, t) => check_type (ts); check_type (t)
            | T_void => ()
            | T_prod (ts) => List.iter (check_type, ts)
            | T_var => ()
            | T_app (ti, args) => 
              Tyvar.check_constraints (ti, args)
          }
        }
        def check_constraints_in_tv (tv : Tyvar.T) : void {
          List.iter (check_type, Tyvar.constraints (tv))
        }
        List.iter (check_type, types);
        List.iter (check_constraints_in_tv, this_.typarms);
        
        def bind_member (d : PT.Class_member) : void {
          Util.locate (d.loc, fun () : void
            {
              mutable tenv <- tenv;
              def bind (t : PT.Type) : Type { tenv.bind (this_.env, t) }
              def mkparm (p : PT.Fun_parm) : Fun_parm {
                Fun_parm (loc = p.loc, name = p.name, ty = bind (p.ty), decl = null)
              }
              def is_static (m : Modifier) : bool { 
                match (m) { Mod_static => true | _ => false } 
              }
              def is_static = 
                if (this_.is_module) true
                else List.exists (is_static, d.modifiers);
              def id = Util.next_id ();
              def d' =
                match (d) {
                  | PT.M_type => None ()
                  | PT.M_field (t, r, k) =>
                    if (is_static)
                      Some (M_value (bind (t), r, k))
                    else {
                      match (k) {
                        | Val_normal => ()
                        | Val_extern => 
                          Message.error ("non-static fields cannot be extern")
                      };
                      Some (M_field (bind (t), r))
                    }
                  | PT.M_function (h, k, b) =>
                    def k =
                      if (is_static)
                        match (k) {
                          | FK_method (Nil) => FK_function ()
                          | FK_method => 
                            Message.error ("static function cannot implement anything");
                            FK_function ()
                          | FK_ctor => FK_static_ctor ()
                          | _ => Util.ice ()
                        }
                      else k;
                    def (tenv', typarms) = tenv.add_typarms (this_.env, h.typarms);
                    tenv <- tenv';
                    def h' = Fun_header (
                      ret_type = bind (h.ret_type),
                      typarms = typarms,
                      name = h.name,
                      parms = List.map (mkparm, h.parms),
                      id = id,
                      closure_vars = Nil (),
                      tenv = tenv',
                      loc = h.loc);
                    Some (M_function (header = h', kind = k, body = b))
                };
              match (d') {
                | Some (d') =>
                  d'.name <- d.name;
                  d'.loc <- d.loc;
                  d'.modifiers <- d.modifiers;
                  d'.id <- id;
                  this_.add_member (d');
                | None => ()
              }
            })
        }

        def decls = 
          match (this_.pt_tydecl) {
            | PT.TD_class (ds) => ds
            | PT.TD_module (ds) => ds
            | PT.TD_interface (ds) => ds
            | PT.TD_variant_option (ds) => 
              if (CSglue.is_capitalized (this_.name)) ()
              else Message.error (this_.loc, "variant options names must start with capital letters");
              ds
            | _ => Nil ()
          };
        
        this_.member_list <- Nil ();
        List.iter (bind_member, decls);
        
        this_.member_list <- List.rev (this_.member_list);
        this_.contained_types <- List.rev (this_.contained_types);

        // we no longer need it, let GC kill it
        this_.pt_tydecl <- null;
      }

    static make_member_map (ti : Tyinfo) : void
      {
        def parent_members =
          match (ti.t_extends) {
            | Some (T_app (ti, _)) => ti.member_map
            | None =>
              match (ti.tydecl) {
                | TD_variant_option =>
                  (ti.enclosing_tyinfo ()).member_map
                | _ => Map.string_map ()
              }
          };
        def can_access (m : M_function) : bool { ti.can_access (m) }
        def parent_members =
          {
            def filter_accessible (ms : String_map (Member), n : string, 
                                      m : Member) : String_map (Member) {
              match (m) {
                | Mem_field (f) =>
                  if (ti.can_access (f)) ms.add (n, m)
                  else ms
                | Mem_methods (meths) =>
                  match (List.filter (can_access, meths)) {
                    | Nil => ms
                    | meths => ms.add (n, Mem_methods (meths))
                  }
              }
            }
            parent_members.fold (filter_accessible, Map.string_map ()) 
          };
        def process_decl (mem : String_map (Member), d : Class_member) : String_map (Member) {
          Util.locate (d.loc, fun () : String_map (Member) {
            match (d) {
              | M_field f =>
                  match (parent_members.find (f.name)) {
                    | Some (Mem_field f') =>
                      if (Util.is_new (f)) ()
                      else Message.error ("field `" + f.name + 
                                          "' overrides field from parent, but no `new'")
                    | Some (Mem_methods ms) =>
                      Message.error ("name `" + f.name + 
                                     "' used to be method, it cannot be field now")
                    | None => ()
                  };
                  mem.add (f.name, Mem_field (f))
              | M_function f =>
                def fun_ty = Tyutil.fun_type (f.header);
                def put_f_in (meths : list (M_function)) : String_map (Member)
                  {
                    mutable replaced <- false;
                    def replace (acc : list (M_function), old : M_function) : list (M_function) {
                      if (Tyutil.types_eq (ti.member_type (old), fun_ty)) {
                        replaced <- true;
                        Cons (f, acc)
                      } else
                        Cons (old, acc)
                    }
                    def meths = List.fold_left (replace, Nil (), meths);
                    def meths = 
                      if (replaced) meths
                      else Cons (f, meths);
                     mem.replace (f.name, Mem_methods (meths))
                  }
                  
                def store_f () : String_map (Member) {
                  match (mem.find (f.name)) {
                    | Some (Mem_field) =>
                      {
                        Message.error ("name `" + f.name + 
                                       "' used to be field, it cannot be method now");
                        mem.add (f.name, Mem_methods (List.cons (f)))
                      }
                    | Some (Mem_methods (meths)) => put_f_in (meths)
                    | None => mem.add (f.name, Mem_methods (List.cons (f)))
                  }
                }

                match (f) {
                  | {kind = FK_method (impl)} => store_f ()
                  | {kind = FK_ctor} => store_f ()
                  // FIXME we don't really want it. We should hide interface members
                  // in classes but not in interfaces
                  | {kind = FK_iface_method} => store_f ()
                  | _ => mem
                }
              | _ => mem
            }})
          }
        ti.member_map <- List.fold_left (process_decl, parent_members, ti.member_list);
      }

    static add_implicit_ctor (ti : Tyinfo) : void {
      match (ti.tydecl) {
        | TD_class cl =>
          def is_field (m : Class_member) : bool {
            match (m) { M_field => true | _ => false }
          }
          if (List.forall (is_field, ti.member_list))
            match (ti.direct_supertypes ()) {
              | Nil =>
                ti.add_member (Extensions.implicit_ctor (ti))
              | _ => ()
            }
          else ()

        | TD_variant_option =>
          ti.add_member (Extensions.implicit_ctor (ti))

        | _ => ()
      }
    }
      
    static top_iter (f : Tyinfo -> void) : void
      {
	def phase = Util.next_id ();
        
        def wrap (_ : int, x : Tyinfo) : void {
          if (x.phase == phase) ()
          else {
            x.phase <- phase;
            match (x.enclosing_type) {
              | Some => ()
              | None => Util.locate (x.loc, fun () : void { f (x) })
            };
          }
        }
	if (infos == null)
          ()
        else
	  infos.iter (wrap)
      }

    static run () : void 
      {
        if (infos == null) 
          ()
        else {
	  top_iter (fun (x : Tyinfo) : void { x.bind_tyvars (Tyvar.TEnv ()) });

          def bind_types (_ : int, x : Tyinfo) : void {
            Util.locate (x.loc, fun () : void { x.bind_types () })
          }
          infos.iter (bind_types);

          // FIXME: this is a bootstrapping solution
          ExternalDeclarationsRegistry.add_mscorelib_decls(); 
        
          determine_subtyping ();
          iter (make_member_list);
          iter (add_implicit_ctor);
          iter (make_member_map);
        }
      }
  }

} // ns
