#
# Copyright (c) 2003 The University of Wroclaw.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#    3. The name of the University may not be used to endorse or promote
#       products derived from this software without specific prior
#       written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
# NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

program:
	{ top_decl }

top_decl:
	"open" qid ";"
	"namespace" ID "=" qid ";"
	"namespace" qid "{" { top_decl } "}"
	type_decl

type_header:
	ID [ typarms ] [ extends ] [ implements ]
	
typarms:
	"(" TYVAR { "," TYVAR } ")" [ where_constraints ]
		Types can be parametrized by type variables. Type variables can be constrained 
		to be subtypes of given type. One type variable can be constrained more then 
		once (that's why type variables are not constrained in "()" but in separate 
		"where" clause), it has to satisfy each constraint.

where_constraints:
	"where" TYVAR ":>" ty { "," TYVAR ":>" ty }
	
ftyparms:
	TYVAR { "," TYVAR } [ where_constraints ]
	
extends:
	"extends" ty
		Types can extend other types. Extending implies subtyping. "extends" clause
		makes all fields of extended type be fields of derived type.
		
implements:
	"implements" ty { "," ty }
		Types can implement interfaces. Defined type is subtype of each interface
		it implements. It is not possible to implement the same interface more then
		once with different actual parameters (i.e. it's illegal to say:
		"implements X('a), X('b)").

type_decl:
	attrs "type" type_header "=" type_declarator ";"
		An alias for existing type or external type import.
	attrs "interface" type_header "{" { interface_member } "}"
	attrs "class" type_header class_body
	attrs "struct" type_header class_body
	attrs "module" type_header class_body
	attrs "variant" type_header "=" "[" { "|" variant_option } "]"
	
type_declarator:
	ty
	"extern" STRING_LITERAL
        
id_or_dummy:
	ID
	"_"

qid:
	ID { "." ID }

interface_member:
	[ "new" ] fun_def_head ";"
        
variant_option
	ID [ "{" { field_def } "}" ]
	
attrs:
	{ attr }

attr:
	"new"
	"public"
	"protected"
	"internal"
	"private"
	"abstract"
	"sealed"

field_def:
	attrs [ "ref" ] ID ":" ty ";"
	
type_member:
	attrs [ "static" ] [ "ref" ] ID ":" ty [ "=" "extern" STRING_LITERAL ] ";"
	attrs [ "static" ] fun_def
	type_decl
	
fun_def_head:
	[ ftyparms ] ID "(" fun_parms ")" ":" ty [ "implements" qid { "," qid } ]
	[ ftyparms ] "this" "(" fun_parms ")"

fun_body:
	"=" expr ";"
	"=" "extern" STRING_LITERAL ";"
	sequence

fun_def:
	fun_def_head fun_body
	
fun_def_term:
	fun_def_head "=" fun_body ";"
	fun_def_head "=" sequence

ref_or_out:
	"ref"
	"out"
        
fun_parm:
	id_or_dummy ":" ty

fun_parms:
	[ fun_parms { "," fun_parm } ]

prim_ty:
	qid
		Reference named type. It is an error to reference type with formal arguments
		without actual arguments.
	qid "(" ty { "," ty } ")"
		Reference named type with specified type arguments. There ought to be exactly
		the same number of actual and formal parameters.
	TYVAR
	"(" ty ")"
		Grouping.
	"void"
	"ref" prim_ty
	"out" prim_ty

ty:
	prim_ty { "*" prim_ty }
		Tuple type.
	prim_ty { "->" prim_ty }
		Type of functions.

prim_expr:
	qid
		Value reference.
	"this"
		Refernce parent type instance in method.
	"(" expr ")"
		Allow grouping.
	"null"
	"(" ")"
	STRING_LITERAL
	NUMBER_LITERAL
	"(" expr ":>" ty ")"
		Type cast.
	"(" expr ":" ty ")"
		Type enforcement.
	prim_expr "." ID
		Member reference.
	"(" expr {+ "," expr }+ ")"
		Tuple constructor.

sequence:
	"{" [ expr { ";" expr } [ ";" ] ] "}"

expr:
	prim_expr
	prim_expr "(" [ parameter { "," parameter } ] ")"
		Function call.
	prim_expr "<-" expr
		Assignment to mutable value (global mutable value, mutable
		type member, or array member).
	"def" id_or_dummy "=" expr
	"def" tuple_pattern "=" expr
	"def" local_fun_def { "and" local_fun_def }
	"mutable" ID "<-" expr
	"if" expr "then" expr "else" expr
	"match" expr "with" "[" [ "|" ] match_case { "|" match_case } "]"
	"raise" expr
		Raise exception.
	"try" expr "with" ID ":" ty "=>" expr
		Try compute first expression. If specified exception is raised -- catch it.
		Exception value is then bound to specified ID.
	"try" expr "finally" expr
	expr OPERATOR expr
	OPERATOR expr
	sequence
	[ ftyparms ] "fun" "(" fun_parms ")" local_fun_body

local_fun_body:
	"=" expr
	"=>" expr
	sequence

local_fun_def:
	fun_def_head local_fun_body
	
parameter:
	[ "ref" ] expr
	[ "ref" ] ID "=" expr

pattern:
	qid [ pattern ]
	"_"
	"{" ID "=" pattern { ";" ID "=" pattern } [ ";" ] "}"
	tuple_pattern
	"(" pattern ")"

tuple_pattern:
	"(" pattern {+ "," pattern }+ ")"

match_case:
	pattern "=>" expr { ";" expr } [ ";" ]
	
# vim: ai ft=conf ts=4
