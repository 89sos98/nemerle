/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
public module Tyexpr {
  type CTX = TypingContext;

  variant Call_result
  {
    | CR_error { msg : string; }
    | CR_ok { call : Expr; sub : Subst; }
  }

  class Typing_error extends System.Exception
  {
    public msg : string;
    public this (s : string) { this.msg <- s; }
  }

  public FoldConstants (expr : Expr) : Expr
  {
    | E_call (E_opcode (mem),
              [{expr = E_literal (L_int (x1))}; 
               {expr = E_literal (L_int (x2))}]) =>
      match (mem) {
        | "int32.+" => E_literal (L_int (x1 + x2))
        | "int32.-" => E_literal (L_int (x1 - x2))
        | "int32./" => E_literal (L_int (x1 / x2))
        | "int32.%" => E_literal (L_int (x1 % x2))
        | "int32.*" => E_literal (L_int (x1 * x2))
        | _ => expr
      }

    | E_call (E_opcode (mem),
                     [{expr = E_literal (L_int (x))}]) =>
      match (mem) {
        | "int32.+" => E_literal (L_int (x))
        | "int32.-" => E_literal (L_int (-x))
        | _ => expr
      }
    | _ => expr
  }

  public type_of (expr : Expr) : Type
  {
    if (expr.expr_ty == null) Util.ice ()
    else expr.expr_ty;
  }

  fixup (expr : Expr, loc : Location, t : Type) : Expr
  {
    expr.loc <- loc;
    expr.expr_ty <- t;
    expr
  }

  fixup (expr : Expr, t : Type) : Expr
  {
    expr.loc <- Location_stack.top ();
    expr.expr_ty <- t;
    expr
  }

  public expect_type (name : string, expr : Expr, t : Type) : void
  {
    if (type_of (expr) >> t) ()
    else
      Message.error (expr.loc, name + " was expected to have type " +
                               t.as_string () + " while it has " +
                               (type_of (expr)).as_string ())
  }

  // given an expression return list of symbols it can expand to
  make_value_reference (ctx : CTX, expr : PT.Expr, fallback : bool) : list (Expr)
  {
    def check_eref (expr) {
      match (expr) {
        | PT.E_ref (n) => Some (n)
        | PT.E_member (e1, PT.SS_string (x)) =>
          match (check_eref (e1)) {
            | Some (y) => Some (y + "." + x)
            | None => None ()
          }
        | _ => None ()
      }
    };

    def lookup_type (expr) {
      match (check_eref (expr)) {
        | Some (r) =>
          match (ctx.env.LookupType (r)) {
            | (Some) as r => r
            | None => None ()
          }
        | _ => None ()
      }
    };

    def unalias (ti : Tycon) {
      match (ti.GetTydecl ()) {
        | TD_alias (T_app (ti, _)) => unalias (ti)
        | _ => ti
      }
    };

    def lookup_ctors (ti : Tycon) {
      def ti = unalias (ti);
      def is_ctor (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_ctor when m.CanAccess (ctx.parent_type) => true
              | _ => false
            }
          | _ => false
        }
      };
      match (List.Filter (is_ctor, ti.LookupMember (".ctor", LF_all ()))) {
        | [] =>
          Message.fatal_error ("type `" + ti.GetFullName () + "' has no accessible constructors")
        | decls => decls
      }
    };

    def convert_symbols (acc, syms) {
      def handle_type (t : Tycon) {
        def mkctor (m : IMember) {
          def ty =
            match (m.GetMemType ()) {
              | T_fun (arg, T_void) =>
                def ret_t =
                  match (t.GetTydecl ()) {
                    | TD_variant_option =>
                      def t' = Option.unsome (t.SuperClass ());
                      t'.GetMemType () /- t.SubtypingSubst (t')
                    | _ =>
                      t.GetMemType ()
                  };
                def ret = T_fun (arg, ret_t) /- t.FreshSubst ();
                //Message.debug ("arg " + arg.as_string () +  " ret " + ret.as_string ());
                ret
                
              | t => Util.ice ("fscked ctor type " + t.as_string ())
            };
          E_static_ref (loc = expr.loc, ty = ty, mem = m)
        };
        List.Map (mkctor, lookup_ctors (t))
      };
      
      def last_chance () {
        match ((acc, syms)) {
         | ([], [_]) => true
         | _ => false
        }
      };
        
      def can_access () {
        match (syms) {
          | Sym_type_member (x) :: _
            when x.CanAccess (ctx.parent_type) => true
          | Sym_type (t) :: _
            when t.CanAccess (ctx.parent_type) => true
          | _ => false
        }
      };

      match (syms) {
        | [] => acc
        | Sym_type_member (x) :: xs when x.IsStatic () =>
          if (can_access ()) {
              def acc =
                match (x.GetKind ()) {
                  | MK_type (t) => List.RevAppend (handle_type (t), acc)
                  | MK_method (m) =>
                      def name = m.GetExternName ();
                      if (name == null || name.StartsWith ("%op"))
                        E_static_ref (loc = expr.loc, ty = m.GetFreshType (), mem = x) :: acc
                      else {
                        def split_at_dots (str : string) {
                          def idx = str.LastIndexOf ('.');
                          if (idx == -1) PT.E_ref (str)
                          else PT.E_member (split_at_dots (str.Substring (0, idx)),
                                            PT.SS_string (str.Substring (idx + 1)))
                        };
                        def exprs = make_value_reference (ctx, split_at_dots (name), fallback = false);
                        def valid (expr) {
                          match (expr) {
                            | E_static_ref (mem) =>
                              Tyutil.types_eq (mem.GetMemType (), m.GetMemType ())
                            | _ => false
                          }
                        };
                        match (List.Filter (valid, exprs)) {
                          | [x] => x :: acc
                          | [] =>
                            Message.fatal_error ("unbound extern symbol `" + name + "'")
                          | _ =>
                            Message.fatal_error ("wrong extern symbol `" + name + "'")
                        }
                      }
                  | MK_property (x) =>
                    E_static_property_ref (loc = expr.loc, ty = x.GetMemType (), prop = x) :: acc
                  | MK_field =>
                    E_static_ref (loc = expr.loc, ty = x.GetMemType (), mem = x) :: acc
                };
              convert_symbols (acc, xs)
          } else {
            when (last_chance ())
              Message.error ("cannot access `" + x.GetDeclaringTycon ().GetFullName () + 
                             "." + x.GetName () + "'");
            convert_symbols (acc, xs)
          }
        | Sym_type_member :: xs =>
          convert_symbols (acc, xs)
        | Sym_type (t) :: xs when can_access () => 
          convert_symbols (List.RevAppend (handle_type (t), acc), xs)
        | Sym_type (t) :: xs => 
          when (last_chance ())
            Message.error ("cannot access type `" + t.GetFullName () + "'");
          convert_symbols (acc, xs)
      }
    };

    def error_when_empty (lst, msg) {
      match (lst) {
        | [] => Message.fatal_error (msg)
        | _ => lst
      }
    };

    Util.locate (expr.loc, fun () {
      match (expr) {
        | PT.E_ref (n) =>
          match (ctx.locals.find (n)) {
            | Some (d) =>
              ignore (ctx.Closurise (d));
              d.ever_used <- true;
              def ty =
                match (d.kind) {
                  | D_local_fun (h, _) =>
                    Tyvar.global_expand (d.ty) /- Tyvar.fresh_subst (h.typarms)
                  | _ => d.ty
                };
              [E_local_ref (loc = expr.loc, ty = ty, decl = d)]
            | None =>
              def from_this =
                match (ctx.this_ptr_decl) {
                  | Some ({ty = T_app (ti, _)}) =>
                    match (ti.LookupMember (n, LF_instance ())) {
                      | [] => []
                      | _ => lookup_member (ctx, expr.loc, ty_expr (ctx, PT.E_this ()), n, 
                                            error_when_not_found = false)
                    }
                  | _ => []
                };
              def res = convert_symbols (from_this, ctx.env.LookupSymbol (n));
              error_when_empty (res, "unbound symbol `" + n + "'")
          }

        | PT.E_member (e1, PT.SS_string (x)) =>
          match (lookup_type (e1)) {
            | Some (t) =>
              def err = "unbound member `" + x + "' in type `" + t.GetFullName () + "'";
              def t = unalias (t);
              match (t.LookupMember (x, LF_static ())) {
                | [] =>
                  match (lookup_type (expr)) {
                    | Some (t) =>
                      convert_symbols ([], [Sym_type (t)])
                    | None =>
                      Message.fatal_error (err)
                  }
                | lst =>
                  def lst' = List.Map (fun (x) { Sym_type_member (x) }, lst);
                  error_when_empty (convert_symbols ([], lst'), err)
              }
            | None =>
              match (lookup_type (expr)) {
                | Some (t) =>
                  convert_symbols ([], [Sym_type (t)])
                | None =>
                  lookup_member (ctx, expr.loc, ty_expr (ctx, e1), x)
              }
          };

        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_base =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = T_app (ti, _)}); in_ctor = true} =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  // FIXME: check access
                  def mkbase (m : IMember) {
                    E_base (loc = expr.loc,
                            ty = m.GetMemType () /- ti.SubtypingSubst (baseti),
                            base_ctor = (m :> IMethod))
                  };
                  List.Map (mkbase, lookup_ctors (baseti))

                | None =>
                  Message.fatal_error ("class " + ti.GetFullName () + " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base' used outside constructor")
          }

        | _ when fallback => [ty_expr (ctx, expr)]
        | _ => Util.ice ("evil value passed to make_value_reference")
      }
    })
  }

  // given list of formal parms names and actual parms names,
  // reorder actuals to match formals
  reorder_named_parms (names : list (string), parms : list (Parm)) : list (Parm)
  {
    def is_named (p : Parm) : bool { p.name != "" };
    mutable seen_kw <- false;

    def loop (acc : list (Parm), names : list (string),
              parms : list (Parm)) : list (Parm) {
      match ((parms, names)) {
        | (p :: ps, n :: ns) =>
          if (p.name == "")
            if (seen_kw)
              raise Typing_error ("unnamed parameters after named")
            else
              loop (p :: acc, ns, ps)
          else {
            seen_kw <- true;
            def lookup (parms : list (Parm)) : Parm * list (Parm) {
              match (parms) {
                | p :: ps =>
                  if (p.name == n)
                    (p, ps)
                  else {
                    def (r, ps) = lookup (ps);
                    (r, p :: ps)
                  }
                | [] =>
                  raise Typing_error ("keyword parameter `" + n + "' not found")
              }
            };
            def (p, ps) = lookup (parms);
            loop (p :: acc, ns, ps)
          }
        | ([], []) => List.Rev (acc)
        | _ => Util.ice ()
      }
    };
    if (List.Exists (is_named, parms))
      match (names) {
        | [] =>
          raise Typing_error ("named parameters given but formals' names cannot be inferred")
        | _ =>
          loop ([], names, parms)
      }
    else
      parms
  }

  // check if FN can be called with PARMS
  check_call_to (parms : list (Parm), fn : Expr) : Call_result
  {
    def check_arg (ctx : int * Subst, parm : Parm, ty : Type) : int * Subst {
      def (arg_no, sub) = ctx;
      match (Tyutil.unify (sub, type_of (parm.expr), ty, true)) {
        | Some (u) =>
          (arg_no + 1, u)
        | None =>
          raise Typing_error ("in arg #" + string_of_int (arg_no) + " needed " +
                              (ty /- sub).as_string () + " got " +
                              (type_of (parm.expr) /- sub).as_string ())
      }
    };

    def formal_names = {
      def from_header (h : Fun_header) : list (string) {
        List.Map (fun (p : Fun_parm) : string { p.name }, h.parms)
      };
      match (fn) {
        | E_local_ref ({kind = D_local_fun (h, _)}) =>
          from_header (h)
        | E_static_ref (m) =>
          match (m.GetKind ()) {
            | MK_method (m) => from_header (m.GetHeader ())
            | _ => []
          }
        | E_method_ref (_, m) =>
          from_header (m.GetHeader ())
        | _ => []
      }
    };

    match (Tyutil.top_expand (type_of (fn))) {
      | T_fun (from, ret) =>
        def args = Tyutil.fun_args (from);
        def wrong_args_cnt () {
          raise Typing_error ("needed " + string_of_int (List.Length (args)) +
                              " parameters, got " +
                              string_of_int (List.Length (parms)))
        };
        try {
          def args =
            match ((parms, args)) {
              | ([parm], _ :: _ :: _) =>
                match (Tyutil.top_expand (type_of (parm.expr))) {
                  | T_prod (types) when List.Length (types) == List.Length (args) =>
                    [T_prod (args)]
                  | _ => wrong_args_cnt ()
                }
              | _ when List.Length (args) != List.Length (parms) => wrong_args_cnt ()
              | _ => args
            };
          def parms = reorder_named_parms (formal_names, parms);
          def (_, sub) =
            List.FoldLeft2 (check_arg, (1, Map.int_map ()), parms, args);
          CR_ok (E_call (fn.loc, ret /- sub, fn, parms), sub)
        } with { x : Typing_error => CR_error (x.msg) }
      | _ =>
        CR_error ("called value has non-functional type " +
                  (type_of (fn)).as_string ())
    }
  }

  resolve_overloaded_call (fncs : list (Expr), parms : list (Parm)) : Expr
  {
    match (fncs) { [] => Util.ice ("empty fncs") | _ => () };
    def check_one (ctx, fn) {
      def (errs, rets) = ctx;
      match (check_call_to (parms, fn)) {
        | CR_ok (ex, sub) => (errs, (ex, sub) :: rets)
        | CR_error (e) => ((e, fn) :: errs, rets)
      }
    };

    match (List.FoldLeft (check_one, ([], []), fncs)) {
      // special case (simple)
      | (_, [(x, sub)]) =>
        Tyvar.global_store (sub);
        x
      | ([(err, fn)], []) =>
        Message.error (err + " calling " + describe_expression (fn)); 
        raise Recovery ()
      | (p, []) =>
        Message.error ("typing error in call:");
        def print_err (err, fn) {
          Message.error ("  " + err + " calling " + describe_expression (fn)) 
        };
        List.Iter (print_err, p);
        raise Recovery ()
      // in general we look for set of maximal argument types
      | (_, l) =>
        def get_type (ex : Expr, s : Subst) : Type * (Expr * Subst) {
          match (ex) {
            | E_call (fn, _) =>
              match (Tyutil.top_expand (type_of (fn))) {
                | T_fun (t1, _) => (t1, (ex, s))
                | _ => Util.ice ()
              }
            | _ => Util.ice ()
          }
        };

        match (Tyutil.maximal_types (List.Map (get_type, l))) {
          | [(_, (x, sub))] =>
            Tyvar.global_store (sub);
            x
          | l =>
            def print_err (_ : Type, x : Expr * Subst) : void {
              match (x) {
                /*
                | (E_call (E_ref (d), _), _) =>
                  // FIXME: we could do better
                  Message.error (d.loc, "    functional value of type " + d.ty.as_string ())
                */
                | (E_call (ex, _), _) =>
                  Message.error ("    functional value of type " + (type_of (ex)).as_string ())
                | _ => Util.ice ("non-call")
              }
            };
            Message.error ("overloading resolution ambiguity between:");
            List.Iter (print_err, l);
            raise Recovery ()
        }
    }
  }

  public lookup_member (ctx : CTX, loc : Location, o : Expr, mem : string) : list (Expr)
  {
    lookup_member (ctx, loc, o, mem, true);
  }

  // lookup member MEM in type_of (O)
  // return list of how we can call it
  public lookup_member (ctx : CTX, loc : Location, o : Expr, mem : string, 
                        error_when_not_found : bool) : list (Expr)
  {
    mutable problem <- "???";
    def visited = Hashtable (10);

    def collect_from (acc, t) {
      match (Tyutil.top_expand (t)) {
        | T_app (ti, args) =>
          if (visited.Contains (ti.GetId ())) acc
          else {
            visited.Add (ti.GetId (), null);

            def subst = ti.MakeSubst (args);
            def can_access (acc, mem : IMember) {
              if (!mem.IsStatic () && mem.CanAccess (ctx.parent_type))
                mem.GetKind () :: acc
              else
                acc
            };
            def members = ti.LookupMember (mem, LF_all ());
            def accessible_members = List.FoldLeft (can_access, [], members);
            def mems =
              match (accessible_members) {
                | [MK_field (f)] =>
                  [E_field_ref (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [] =>
                  def how =
                    match (members) {
                      | [] => "unbound"
                      | _ => "inaccessible"
                    };
                  problem <- how + " member `" + mem + "' in type `" +
                             ti.GetFullName () + "'";
                  []
                  
                | lst =>
                  mutable was_prop <- false;
                  mutable was_meth <- false;
                  def make (m) {
                    match (m) {
                      | MK_property (p) when !was_meth =>
                        was_prop <- true;
                        E_property_ref (loc, Tyutil.TypeOfMemberIn (p, ti) /- subst, o, p)
                      | MK_method (m) when !was_prop =>
                        was_meth <- true;
                        E_method_ref (loc, Tyutil.TypeOfMethodIn (m, ti) /- subst, o, m)
                      | _ =>
                        Message.fatal_error ("ambiguous member name `" + mem +
                                             "' in type `" + ti.GetFullName () + "'")
                    }
                  };
                  List.Map (make, lst)
               };
            List.Append (mems, acc)
          }

        | T_var (tv) =>
          if (visited.Contains (tv.id)) acc
          else {
            visited.Add (tv.id, null);
            match (List.FoldLeft (collect_from, acc, Tyvar.constraints (tv))) {
              | [] =>
                problem <- "no constrain of " + t.as_string () +
                           " provides member `" + mem + "'";
                []
              | acc => acc
            }
          }

        | T_ref (t) =>
          collect_from (acc, t) // FIXME: this is a quick hack for Kamil

        | T_array =>
          collect_from (acc, Tyutil.make_tapp ("System.Array"))

        | _ =>
          problem <- "type `" + t.as_string () + "' was expected to be class";
          acc
      }
    };

    match (collect_from ([], type_of (o))) {
      | [] when error_when_not_found => Message.fatal_error (problem)
      | x => x
    }
  }

  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.E_match) : Expr * Type
  {
    def matched_value = ty_expr (ctx, mtch.expr);

    def do_case (acc : option (Type) * list (Match_case),
                 c : PT.Match_case) : option (Type) * list (Match_case) {
      def (pat, ctx') = Typattern.ty_patterns (ctx, type_of (matched_value), c.patterns);
      def body = ty_expr (ctx', c.body);
      match (acc) {
        | (Some (t), l) =>
          match (Tyutil.unify_branches (t, type_of (body))) {
            | Some (t') => (Some (t'), Match_case (pat, body) :: l)
            | None =>
              expect_type ("match case body", body, t);
              Util.ice () // not reached
          }
        | (None, l) =>
          (Some (type_of (body)), Match_case (pat, body) :: l)
      }
    };

    match (List.FoldLeft (do_case, (None (), []), mtch.cases)) {
      | (Some (t), mcs') =>
        def mcs = List.Rev (mcs');
        Typattern.check_matching (mcs);
        (E_match (matched_value, mcs), t)
      | (None, _) =>
        Message.fatal_error ("cannot have empty match construct");
    }
  }

  ty_letfun (ctx : CTX, fs : list (PT.Function_decl)) : list (Function_decl) * CTX
  {
    def make_fun (d : PT.Function_decl) {
      def pars = {
        def h = ctx.current_fun;
        if (h.decl == null) [h]
        else
          match (h.decl.kind) {
            | D_local_fun (_, pars) => h :: pars
            | _ => Util.ice ()
          }
      };

      def h = d.header;
      def hname = Macros.unsstring (h.name);
      def (tenv, typarms) = ctx.tenv.add_typarms (ctx.env, h.typarms);
      def mkparm (p : PT.Fun_parm) : Fun_parm {
        Fun_parm (loc = p.loc, name = Macros.unsstring (p.name), 
                  ty = tenv.bind (ctx.env, p.ty), decl = null)
      };
      def h' = Fun_header (
         ret_type = tenv.bind (ctx.env, h.ret_type),
         typarms = typarms,
         name = hname,
         parms = List.Map (mkparm, h.parms),
         id = Util.next_id (),
         closure_vars = [],
         all_locals = [],
         tenv = tenv,
         loc = h.loc,
         decl = null,
         cg_method = null);

      def lv = LocalValue (hname, D_local_fun (h', pars), 
                           Tyutil.fun_type (h'), ctx.current_fun);
      h'.decl <- lv;
      h'
    };

    def headers = List.Map (make_fun, fs);
    def localvals = List.Map (fun (h : Fun_header) { h.decl }, headers);
    def ctx = ctx.WithLocals (localvals);
    def do_fun (d : PT.Function_decl, h : Fun_header) : Function_decl {
      Function_decl (h.decl, ty_function (ctx, h, d.body))
    };
    (List.Map2 (do_fun, fs, headers), ctx)
  }

  ty_sequence (ctx : CTX, l : list (PT.Expr)) : Expr
  {
    def go () : Expr {
      match (l) {
        | [x] => ty_expr (ctx, x)

        | PT.E_letfun (fs) :: xs =>
          def (fs', ctx') = ty_letfun (ctx, fs);
          def body = ty_sequence (ctx', xs);
          fixup (E_letfun (fs', body), type_of (body))

        | (PT.E_let) as x :: xs =>
          def val = ty_expr (ctx, x.val);
          def name = match (x.name) {
            | PT.SS_string (n) => n
            | _ =>
              Message.fatal_error ("$ operator used outside quotation <[ ... ]> context")
          };
          def decl = LocalValue (name, D_local_value(), type_of (val), ctx.current_fun);
          decl.is_ref <- x.is_ref;
          def body = ty_sequence (ctx.WithLocal (decl), xs);
          fixup (E_let (decl, val, body), type_of (body))

        | PT.E_letpat (p, v) :: xs =>
          def body = PT.E_sequence (xs);
          def mtch = PT.E_match (v, [PT.Match_case ([(p, None ())], body)]);
          body.loc <- (List.Head (xs)).loc;
          mtch.loc <- p.loc;
          ty_expr (ctx, mtch)

        | x :: xs =>
          def ex = ty_expr (ctx, x);
          def t = type_of (ex);
          if (t >> T_void ()) {
            def tl = ty_sequence (ctx, xs);
            fixup (E_sequence (ex, tl), type_of (tl))
          } else {
            Message.warning ("ignored computed value of type " + t.as_string ());
            Message.hint_once ("use ignore (...); to avoid the warning");

            def tmp = Util.tmpname ("ign");
            def decl = LocalValue (tmp, D_local_value (), type_of (ex), ctx.current_fun);
            def body = ty_sequence (ctx.WithLocal (decl), xs);
            fixup (E_let (decl, ex, body), type_of (body))
          }
        | [] => Util.ice ("empty sequence")
      }
    };

    Util.locate ((List.Head (l)).loc, go)
  }

  public ty_literal (_ : CTX, l : Literal) : Type
  {
    match (l) {
      | L_void => T_void ()
      | L_null =>
        match (Tyvar.free_variable ()) {
          | (T_var (tv)) as r => tv.is_from_null <- true; r
          | _ => Util.ice ()
        }
      | L_int => Tyutil.make_tapp ("System.Int32")
      | L_char => Tyutil.make_tapp ("System.Char")
      | L_string => Tyutil.make_tapp ("System.String")
      | L_float => Tyutil.make_tapp ("System.Single")
      | L_bool => Tyutil.make_tapp ("System.Boolean")
    }
  }

  describe_expression (expr : Expr) : string
  {
    match (expr) {
      | E_local_ref (d) =>
        "a reference to local symbol `" + d.name + "'"
      | E_static_ref (m) =>
        def tyname =
          if (m.GetDeclaringTycon () == null)
            ""
          else
            m.GetDeclaringTycon ().GetFullName () + ".";
        "a reference to global symbol `" + tyname + m.GetName () + "'"
      | E_field_ref (_, f) =>
        "a reference to field `" + f.GetName () + "'"
      | E_static_property_ref (p)
      | E_property_ref (_, p) =>
        "a reference to property `" + p.GetName () + "'"
      | E_method_ref (_, m) =>
        "a reference to method `" + m.GetName () + "'"
      | E_call (f, _) =>
        "a function call to " + describe_expression (f)
      | E_assign => "an assignment"
      | E_let => "an value binding"
      | E_letfun => "an function binding"
      | E_match => "an `match' expression"
      | E_raise => "a raise expression"
      | E_try_with => "a try...with expression"
      | E_try_finally => "a try...finally expression"
      | E_literal => "a literal value"
      | E_this => "a this pointer reference"
      | E_base => "a base class reference"
      | E_type_conversion => "a type conversion (:>)"
      | E_type_enforcement => "a type enforcement (:)"
      | E_sequence => "a sequence"
      | E_tuple => "a tuple constructor"
      | E_mkarray => "a array constructor"
      | E_array_indexer => "an array indexer reference"
      | E_typeof => "an typeof expression"
      | E_opcode => "an operator reference"
    }
  }

  make_first_class (ctx : CTX, expr : Expr) : Expr
  {
    match (expr) {
      | E_method_ref (obj_ref, mem) =>
        match (Tyutil.top_expand (type_of (expr))) {
          | T_fun (from, _) =>
            def mkparm (acc, _) {
               def t = Util.tmpname ("parm");
               def (fps, ps) = acc;
               (PT.Fun_parm (expr.loc, PT.SS_string (t), PT.T_infer (), 
                             PT.FP_normal ()) :: fps, PT.Parm (PT.E_ref (expr.loc, t)) :: ps)
            };
            def (fps, ps) = List.FoldLeft (mkparm, ([], []), Tyutil.fun_args (from));
            def ptr_name = Util.tmpname ("ptr");
            def header = PT.Fun_header (expr.loc, PT.SS_string (Util.tmpname ("ml")), 
                                        PT.T_infer (), fps);
            def body = PT.E_call (PT.E_member (PT.E_ref (ptr_name), 
                                  PT.SS_string (mem.GetName ())), ps);
            //def body = <[ $(ptr_name : var) . $mem_name (.. $ps) ]>;
            def lambda = PT.E_lambda (expr.loc, PT.Function_decl (header, body));
            ty_expr (ctx, PT.E_sequence ([
                PT.E_let (false, PT.SS_string (ptr_name), PT.E_typed_expr (obj_ref));
                lambda
                ]))
            //ty_expr (ctx, <[ { def $ptr_name = $(PT.E_typed_expr (tye));
            //              $lambda } ]>)
          | _ => Util.ice ()
        }
      | _ => expr
    }
  }

  public ty_expr (ctx : CTX, expr : PT.Expr) : Expr
  {
    def expr = ty_expr_with_no_properties_conversion (ctx, expr);
    def make_getter (obj, prop : IProperty, args) {
      def meth = prop.GetGetter ();
      E_call (expr.loc, expr.expr_ty, 
              E_method_ref (expr.loc, meth.GetMemType (), obj, meth),
              args)
    };
    def make_static_getter (prop : IProperty, args) {
      def meth = prop.GetGetter ();
      E_call (expr.loc, expr.expr_ty, 
              E_static_ref (expr.loc, meth.GetMemType (), meth),
              args)
    };
    match (expr) {
      | E_property_ref (obj, prop) => make_getter (obj, prop, [])
      | E_call (E_property_ref (obj, prop), args) => make_getter (obj, prop, args)
      | E_static_property_ref (prop) => make_static_getter (prop, [])
      | E_call (E_static_property_ref (prop), args) => make_static_getter (prop, args)
      | expr => expr
    }
  }

  convert_setter_property (_ctx : CTX, expr : Expr, val : Expr) : Expr * Type
  {
    def make_setter (obj, prop : IProperty, args) {
        def meth = prop.GetSetter ();
        E_call (expr.loc, T_void (), 
                E_method_ref (expr.loc, meth.GetMemType (), obj, meth),
                List.Append (args, [Parm (false, val, "")]))
    };
      
    def make_static_setter (prop : IProperty, args) {
        def meth = prop.GetSetter ();
        E_call (expr.loc, T_void (), 
                E_static_ref (expr.loc, meth.GetMemType (), meth),
                List.Append (args, [Parm (false, val, "")]))
    };
      
    def res =
      match (expr) {
        | E_property_ref (obj, prop) => make_setter (obj, prop, [])
        | E_call (E_property_ref (obj, prop), args) => make_setter (obj, prop, args)
        | E_static_property_ref (prop) => make_static_setter (prop, [])
        | E_call (E_static_property_ref (prop), args) => make_static_setter (prop, args)
        | expr => E_assign (expr.loc, T_void (), expr, val)
      };

    (res, T_void ())
  }
  
  ty_expr_with_no_properties_conversion (ctx : CTX, expr : PT.Expr) : Expr
  {
    def do_typing () : Expr * Type {
      def restart (e : PT.Expr) : Expr * Type {
        def ex = ty_expr (ctx, e);
        (ex, type_of (ex))
      };
      def bind_ty (t : PT.Type) : Type {
        ctx.tenv.bind (ctx.env, t)
      };

      def expr = MacroRegistry.expand_macro (ctx, expr);

      match (expr) {
        // this doesn't make much sense I hope
        | PT.E_let => Message.fatal_error ("let binding not followed by any expression")
        | PT.E_letpat => Message.fatal_error ("letpat binding not followed by any expression")
        | PT.E_letfun => Message.fatal_error ("letfun binding not followed by any expression")

        | PT.E_lambda (d) =>
          def newname = Util.tmpname ("l");
          d.header.name <- PT.SS_string (newname);
          def rf = PT.E_ref (newname);
          def lf = PT.E_letfun ([d]);
          def sq = PT.E_sequence ([lf; rf]);
          rf.loc <- expr.loc;
          lf.loc <- expr.loc;
          sq.loc <- expr.loc;
          restart (sq)

        | PT.E_mkarray (lst) =>
          def (typed_initializers, array_type) =
          match (lst) {
            | [] => (E_mkarray ([]), T_array (Tyvar.free_variable ()))
            | head :: _ =>
              def typed_head = ty_expr (ctx, head);
              def array_type = type_of (typed_head);
              def type_array_initializers (initializers) {
                match (initializers) {
                  | [] => []
                  | initializer :: rest =>
                    def typed_initializer = ty_expr (ctx, initializer);
                    expect_type ("array initializer", typed_initializer, array_type);
                    typed_initializer :: type_array_initializers (rest)
                }
              };
              (E_mkarray (type_array_initializers (lst)), T_array (array_type))
          };
          typed_initializers.expr_ty <- array_type;
          typed_initializers.loc <- expr.loc;
          def fresh_name = Util.tmpname ("array_initializer");
          def decl = LocalValue (fresh_name, D_local_value (), array_type, ctx.current_fun);
          decl.is_ref <- false;
          def array_as_let = E_let (decl, typed_initializers, E_local_ref (decl));
          array_as_let.loc <- expr.loc;
          (array_as_let, array_type)

        | PT.E_empty_array (sizes) =>
          match (sizes) {
            | [size] =>
              def fv = Tyvar.free_variable ();
              def type_of_expr = E_typeof (expr.loc, Tyutil.make_tapp ("System.Type"), fv);
              def call_expr = <[ System.Array.CreateInstance ($(type_of_expr : typed), $size) ]>;
              def ex = ty_expr (ctx, call_expr);
              def ex_ty = T_array (fv);
              (E_type_conversion (ex, ex_ty), ex_ty)
            | _ => Message.fatal_error ("multi-dimensional arrays not supported yet")
          }

        // FIXME: allow for multi-dimensional indexers
        | PT.E_indexer (obj, args) =>
          def typed_obj = ty_expr (ctx, obj);
          def typed_args = List.Map (fun (x) { ty_expr (ctx, x) }, args);

          match (typed_obj.expr_ty) {
            | T_array (indexer_over_type) =>
              /* indexers over arrays */
              def typed_index =
              match (typed_args) {
                | [index] => index
                | [] => Message.fatal_error ("empty indexer applied to indexer type")
                // FIXME: allow for multi-dimensional indexers
                | _ => Message.fatal_error ("multi-dimensional indexers not supported yet")
              };
              expect_type ("indexer type", typed_index, Tyutil.make_tapp ("System.Int32"));
              (E_array_indexer (indexer_over_type, typed_obj, [typed_index]), indexer_over_type)

            | _ =>
              /* indexers over the Item or Chars property */
              def check_for_indexer_property (prop_name : string) : option (Expr * Type) {
                match (lookup_member (ctx, expr.loc, typed_obj, prop_name, error_when_not_found = false)) {
                  | (E_property_ref :: _) as lst =>
                    def args' = List.Map (fun (x) { Parm (false, x, "") }, typed_args);
                    def ex = resolve_overloaded_call (lst, args');
                    Some ((ex, type_of (ex)))
                  | _ => None ()
                }
              };

              match (check_for_indexer_property ("Chars")) {
                | Some (e) => e
                | None =>
                  match (check_for_indexer_property ("Item")) {
                    | Some (e) => e
                    | None =>
                      Message.fatal_error ("indexer applied to non-indexer type " +
                                           "(Chars or Item property required)")
                  }
              }
          }

        | (PT.E_try_with) as x =>
          def b = ty_expr (ctx, x.body);
          def exn = match (x.exn) {
            | PT.SS_string (e) => e
            | _ =>
            Message.fatal_error ("$ operator used outside quotation <[ ... ]> context")
          };
          def decl = LocalValue (exn, D_exn (), bind_ty (x.exn_ty), ctx.current_fun);
          def h = ty_expr (ctx.WithLocal (decl), x.handler);
          match (Tyutil.unify_branches (type_of (h), type_of (b))) {
            | Some (t) =>
              (E_try_with (b, decl, h), t)
            | None =>
              Message.fatal_error (h.loc, "try...with body has type " +
                                          (type_of (b)).as_string () +
                                          " while the handler has type " +
                                          (type_of (h)).as_string ())
          }

        | PT.E_try_finally (e1, e2) =>
          def e1 = ty_expr (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("try...finally handler", e2, T_void ());
          (E_try_finally (e1, e2), type_of (e1))

        | PT.E_typeof (t) =>
          (E_typeof (bind_ty (t)), Tyutil.make_tapp ("System.Type"))

        | PT.E_type_conversion (e, t) =>
          // FIXME shall we check sth here ?
          def t = bind_ty (t);
          (E_type_conversion (ty_expr (ctx, e), t), t)

        | PT.E_type_enforcement (e, t) =>
          def ex = ty_expr (ctx, e);
          def t = bind_ty (t);
          expect_type ("type-enforced expression", ex, t);
          (E_type_enforcement (ex, t), t)

        | PT.E_ref (n) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              (x, type_of (x))

            | l =>
              Message.error ("name `" + n + "' is ambiguous:");
              def print (ex) { Message.error ("  " + describe_expression (ex)) };
              List.Iter (print, l);
              raise Recovery ()
          }

        | PT.E_member (_, PT.SS_string (mem_name)) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              (x, type_of (x))

            | l =>
              Message.error ("reference to member `" + mem_name + "' is ambiguous:");
              def print (ex) { Message.error ("  " + describe_expression (ex)) };
              List.Iter (print, l);
              raise Recovery ()
          }

        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_call (fnc, parms) =>
          def fp (p : PT.Parm) {
            def ex = ty_expr (ctx, p.expr);
            Parm (p.is_ref, ex, Macros.unsstring (p.name))
          };
          def parms = List.Map (fp, parms);
          def fncs = make_value_reference (ctx, fnc, fallback = true);
          def ex = resolve_overloaded_call (fncs, parms);
//          def foldedex = FoldConstants (ex);
//          (foldedex, type_of (ex))
          (ex, type_of (ex))

        | PT.E_assign (e1, e2) =>
          def e1 = ty_expr_with_no_properties_conversion (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("assigned value", e2, type_of (e1));
          def is_lval =
            match (e1) {
              | E_local_ref (d) => d.is_ref
              | E_static_ref (m) =>
                match (m.GetKind ()) {
                  | MK_field (f) =>
                    f.IsMutable () || (ctx.current_fun.name == ".cctor" && 
                                       f.GetDeclaringTycon ().SameAs (ctx.parent_type))
                  | MK_property (p) => p.IsMutable ()
                  | _ => false
                }
              | E_field_ref (E_this, _) when ctx.in_ctor => true
              | E_field_ref (_, mem) => mem.IsMutable ()
              | E_property_ref (_, p) => p.IsMutable ()
              | E_call (E_property_ref (_, p), _) => p.IsMutable ()
              | E_array_indexer => true
              | _ => false
            };
          unless (is_lval)
            Message.error ("assignment to read-only location");
            
          convert_setter_property (ctx, e1, e2)

        | PT.E_raise (e) =>
          def ex = ty_expr (ctx, e);
          def exn_ty = Tyutil.make_tapp ("System.Exception");
          expect_type ("raised value", ex, exn_ty);
          (E_raise (ex), Tyvar.free_variable ())

        | PT.E_literal (l) =>
          (E_literal (l), ty_literal (ctx, l))

        | PT.E_this =>
          match (ctx.this_ptr_decl) {
              | Some (d) =>
              def e =
                if (ctx.Closurise (d)) E_local_ref (d)
                else E_this ();
              (e, d.ty)
            | None =>
              Message.error ("`this' used outside method");
              (E_literal (L_null ()), Tyvar.free_variable ())
          }

        | PT.E_sequence ([]) =>
          (E_literal (L_void ()), T_void ())

        | PT.E_sequence (l) =>
          def ex = ty_sequence (ctx, l);
          (ex, type_of (ex))

        | PT.E_tuple (l) =>
          def self (e : PT.Expr) : Expr { ty_expr (ctx, e) };
          def parms = List.Map (self, l);
          (E_tuple (parms), T_prod (List.Map (type_of, parms)))

        | (PT.E_match) as m => ty_match (ctx, m)

        | PT.E_typed_expr (tytree) => (tytree, type_of (tytree))

        | PT.E_quoted (parse_element) =>
          def lifted =
            match (parse_element) {
              | PT.SyntaxExpr (e) => 
                Macros.quoted_expr (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxType (e) => 
                Macros.quoted_type (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxPattern (e) => 
                Macros.quoted_pattern (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxParm (e) => 
                Macros.quoted_param (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxCase (e) => 
                Macros.quoted_case (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxCaseGuard (a, b) => 
                Macros.quoted_case_guard (ctx, Macros.QuotationContext (), (a, b))
              | PT.SyntaxFunDecl (e) => 
                Macros.quoted_fundecl (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxFunParm (e) => 
                Macros.quoted_fparam (ctx, Macros.QuotationContext (), e)
            };
          def b = ty_expr (ctx, lifted);
          (b, type_of (b))

        | PT.E_base =>
          Message.fatal_error ("`base' can be only used to call base class constructor")

        | PT.E_spliced | PT.E_spliced_patt | PT.E_spliced_special =>
          Message.fatal_error ("$ macro keyword used in regular expression")

        | PT.E_expr_list =>
          Util.ice ("List of expression parameters out of any construct")

        | PT.E_macrocall  =>
          Util.ice ("Macrocalls should have been expanded already")
      }
    };

    def (ret, expr_ty) =
      try
        Util.locate (expr.loc, do_typing)
      with { _ : Recovery =>
        (E_literal (L_null ()), Tyvar.free_variable ()) };
    fixup (ret, expr.loc, expr_ty)
  }

  check_unused_values (ctx : CTX) : void
  {
    def warned = Hashtable (50);
    
    def check_value (v : LocalValue) {
      when (!v.ever_used && v.name[0] != '_' && !warned.Contains (v.id)) {
        Message.warning (v.loc, v.kind_as_string () + " `" + v.name + 
                         "' was never used");
        Message.hint_once (v.loc, "replace name with `_' or prefix it like `_foo' to avoid the warning");
        warned.Set (v.id, null)
      }
    };
    
    List.Iter (check_value, List.Rev (ctx.current_fun.all_locals));
    ctx.current_fun.all_locals <- null; // GC it
  }

  ty_function (ctx : CTX, h : Fun_header, b : Fun_body) : Fun_body
  {
    def ctx = ctx.WithCurrentFunction (h);
    
    def make_parm_decl (p : Fun_parm) {
      Util.locate (p.loc, fun () {
                            def d = LocalValue (p.name, D_fun_parm (), p.ty, h);
                            p.decl <- d;
                            d
                         })
    };

    def ctx = ctx.WithLocals (List.Map (make_parm_decl, h.parms));

    match (b) {
      | FB_parsed_expr (e) =>
        def ctx = ctx.WithTEnv (h.tenv);
        def e' = ty_expr (ctx, e);
        if (type_of (e') >> h.ret_type) ()
        else
          Message.error (e.loc, "function return type was declared to be " +
                                h.ret_type.as_string() + " while it is " +
                                (type_of (e')).as_string ());
        check_unused_values (ctx);
        FB_typed_expr (e')
      | FB_typed_expr => Util.ice ()
      | FB_compiled_expr => Util.ice ()
      | FB_extern => b
      | FB_abstract => b
    }
  }

  ty_function (ctx : CTX, h : Fun_header, b : PT.Expr) : Expr
  {
    match (ty_function (ctx, h, FB_parsed_expr (b))) {
      | FB_typed_expr (e) => e
      | _ => Util.ice ()
    }
  }

  /**
   * Walk through method body typing it.
   *
   * <remarks>
   *   Typing generally involves rewriting from [Parsetree] to [Typedtree]
   *   namespace. Also entry point for expression is changed from
   *   [FB_parsed_expr] to [FB_typed_expr].
   *
   *   During typing we do few things:
   *
   *   <list>
   *     - Infer types and check if they are correct. Store information
   *       about types in resulting [Typedtree.Expr] objects.
   *     - Define (generate [LocalValue] objects) and later resolve local values.
   *     - Rewrite few redundant source language constructs into
   *       unambiguous equivalents from [Typedtree].
   *     - Bind type expressions occurring in source code.
   *     - Mark which values should go into closures.
   *   </list>
   *
   *   This is however all done in parallel to improve efficiency.
   *
   *   Documentation FIXME: overloading resolution, CTX type, more
   *   about closures, binding method implement list.
   * </remarks>
   */
  public TypeMethod (m : NemerleMethod) : void
  {
    def ti = (m.GetDeclaringTycon () :> Tyinfo);

    def (in_ctor, is_method) =
      match (m.GetFunKind ()) {
        | FK_ctor => (true, true)
        | FK_method | FK_bound_method => (false, true)
        | _ => (false, false)
      };

    // Message.debug ("type " + m.GetName () + if (is_method) " method" else "");

    def ctx = TypingContext 
                  (in_ctor = in_ctor,
                   this_ptr_decl =
                     if (is_method)
                       Some (LocalValue ("_N_this", D_closurised_this_ptr (),
                                   ti.GetMemType (), m.GetHeader ()))
                     else None (),
                   env = ti.env,
                   tenv = m.GetHeader ().tenv,
                   current_fun = m.GetHeader (),
                   locals = Map.string_map (),
                   parent_type = ti);

    try
      m.fun_body <- ty_function (ctx, m.GetHeader (), m.fun_body)
    with { _ : Recovery => () }
  }
}

} // end ns
