/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.CompileTypedMethod;

using System.Reflection;

namespace Nemerle.Compiler {

module CompileTypedTree
{
  get_apply_method (parm_cnt : int) : IMethod
  {
    InternalType.GetFunctionType (parm_cnt).ApplyMethod
  }

  internal make_ref_type (t : System.Type) : System.Type
  {
#if _NET_2_0
    t.MakeByRefType ()
#else  
    def ty = t.Module.GetType (t.FullName + "&");
    assert (ty != null);
    ty
#endif
  }
  
  internal class CTX
  {
    public mutable current_fun : Fun_header;
    public mutable current_fun_or_loop : Fun_header;
    public mutable current_closure : option [CG_val];
    public mutable closure_fields : SystemMap [int, FieldInfo];
    public mutable closure_ptrs : SystemMap [int, FieldInfo];
    public mutable locals : SystemMap [int, CG_val];
    public mutable current_type : TypeBuilder;
    public mutable current_loop : option [CExpr.Loop];

    /** Copy constructor */
    public this (copied : CTX) {
      current_fun = copied.current_fun;
      current_closure = copied.current_closure;
      closure_fields = copied.closure_fields;
      closure_ptrs = copied.closure_ptrs;
      locals = copied.locals;
      current_type = copied.current_type;
      current_loop = copied.current_loop;
      current_fun_or_loop = copied.current_fun_or_loop
    }

    /** Empty context */
    public this (ti : TypeBuilder) {
      current_closure = None ();
      closure_fields = SystemMap ();
      closure_ptrs = SystemMap ();
      locals = SystemMap ();
      current_type = ti;
      current_loop = None ();
    }
  }

  store_in_closure (ctx : CTX, d : LocalValue, val : CExpr) : CExpr
  {
    match (ctx.current_closure) {
      | Some (clo) =>
        def rf = CExpr.FieldRef (CExpr.Ref (clo), ctx.closure_fields.Get (d.id));
        CExpr.Assign (rf, val)
      | None =>
        Message.warning ("no local closure for " + d.name);
        Util.ice ()
    }
  }

  internal store_local (ctx : CTX, d : LocalValue, val : CExpr) : CTX * CG_val
  {
    def var_ty = d.ty.GetSystemType ();
    def val =
      match (val) {
        | CExpr.Nop => val
        | _ when val.SystemType.IsValueType && !var_ty.IsValueType => 
          CExpr.Cast (val, var_ty, true)
        | _ => val
      };
    if (d.in_closure) {
      def assign = store_in_closure (ctx, d, val);
      def cgv = CG_val (loc = d.loc, 
                        name = "dummy",
                        ty = SystemType.Void, 
                        val = assign);
      (CTX (ctx), cgv)
    } 
    else {
      def cgv = CG_val (loc = d.loc, 
                        name = d.name, 
                        ty = var_ty,
                        val = val);
      def ctx' = CTX (ctx);
      ctx'.locals = ctx.locals.Add (d.id, cgv);
      (ctx', cgv)
    }
  }

  internal closure_ref (ctx : CTX, fn : Fun_header) : CExpr
  {
    if (ctx.current_fun.id == fn.id)
      CExpr.Ref (Option.UnSome (ctx.current_closure))
    else
      CExpr.FieldRef (CExpr.This (), ctx.closure_ptrs.Get (fn.id))
  }

  internal box_value (body : CExpr) : CExpr 
  {
    if (body.SystemType.IsValueType || SystemType.Void.Equals (body.SystemType))
      CExpr.Cast (body, SystemType.Object, true)
    else
      body
  }

  internal unbox_value (body : CExpr, ty : System.Type) : CExpr 
  {
    if (SystemType.Void.Equals (ty))
      CExpr.Ignore (body)
    else
      CExpr.Cast (body, ty, true)
  }

  internal set_parm_info (fp : Fun_parm, v : CG_val) : CG_val
  {
    def kind =
      match (fp.ty) {
        | TType.ByRef => ParmKind.Ref
        | TType.Out => ParmKind.Out
        | _ => ParmKind.Normal
      };
    v.parm_info = CG_parm_info (parm_kind = kind, 
                                modifiers = fp.modifiers);
    v
  }

  internal set_parm_info (ty : TType, v : CG_val) : CG_val
  {
    def kind =
      match (ty) {
        | TType.ByRef => ParmKind.Ref
        | TType.Out => ParmKind.Out
        | _ => ParmKind.Normal
      };
    v.parm_info = CG_parm_info (parm_kind = kind, modifiers = Modifiers.Empty);
    v
  }

  global_ref (ctx : CTX, m : IMember) : CExpr {
    match (m.GetKind ()) {
      | MemberKind.Type 
      | MemberKind.Event => assert (false)

      | MemberKind.Field (f) =>
        if (f.IsLiteral) {
          match (ConstantFolder.FieldValueAsLiteral (f)) {
            | Some (lit) =>
              // this is kinda last resort, we should have converted it during
              // constant folding, but if we have missed it, do it here, as cgil
              // will fail to generate proper code for this.
              //Message.debug ("converting literal field `" + f.Name + "' to literal");
              CExpr.Literal (lit)
            | None =>
              if (f.IsVolatile)
                CExpr.VolatileGlobalRef (f.GetFieldInfo ())
              else
                CExpr.GlobalRef (f.GetFieldInfo ())
          }
        } else
          if (f.IsVolatile)
            CExpr.VolatileGlobalRef (f.GetFieldInfo ())
          else
            CExpr.GlobalRef (f.GetFieldInfo ())

      | MemberKind.Property (f) =>
        CExpr.GlobalRef (f.GetPropertyInfo ())
        
      | MemberKind.Method (f) =>
        CExpr.Call (CExpr.ConstructorRef (CompileTypedMethod.get_lambda_proxy (ctx, f)), [])
    }
  }

  internal local_ref (ctx : CTX, d : LocalValue, store : bool) : CExpr
  {
    if (d.in_closure) {
      if (!store && ctx.current_fun.decl == null && (d.kind is LocalValueKind.ClosurisedThis))
          CExpr.This ()
      else {
        def defined_in = d.parent_fun;
        CExpr.FieldRef (closure_ref (ctx, defined_in), 
                        ctx.closure_fields.Get (d.id))
      }
    }
    else if (ctx.locals.Member (d.id)) {
      match (d.kind) {
        | LocalValueKind.Parameter (kind) 
          when kind == ParmKind.Out || kind == ParmKind.Ref =>
          def ty = make_ref_type (d.ty.GetSystemType ());
          CExpr.Indirect (CExpr.Ref (ty, ctx.locals.Get (d.id)))
          
        | _ =>
          CExpr.Ref (ctx.locals.Get (d.id))
      }
    } else {
      match (d.kind) {
        | LocalValueKind.ClosurisedThis => CExpr.This ()
        | _ =>
          Message.debug ("undef " + d.name + " = " + d.id.ToString () + " " + d.kind.ToString ());
          Util.ice ("ref to undef val " + d.name)
      }
    }
  }

  internal maybe_cast (_ctx : CTX, needed_type : System.Type, ex : CExpr) : CExpr
  {
    assert (needed_type != null);
    def current_type = ex.SystemType;
    assert (current_type != null);
    if (needed_type.Equals (SystemType.Void))
      if (current_type.Equals (SystemType.Void))
        ex
      else
        CExpr.Ignore (ex)
    else {
/*    
// bug in MS.NET makes it return false for IField[] and IField[]         
      when (needed_type.Equals (current_type) !=
            (needed_type.FullName == current_type.FullName))
        Message.debug (ex.loc, needed_type.Assembly.ToString () + " " + needed_type.ToString () + " " + 
                               current_type.Assembly.ToString () + " " + current_type.ToString ());
*/                               
      if (needed_type.FullName == current_type.FullName ||    
          (needed_type.IsAssignableFrom (current_type) && !current_type.IsValueType))
        ex
      else 
        CExpr.Cast (ex, needed_type, true)
    }
  }

  /**
   * Properly format list of expression before being passed in a function
   * call -- box value types, and add needed downcasts.
   */
  casted_exprs (ctx : CTX, formals : list [CG_val], parms : list [CExpr]) : list [CExpr]
  {
    //Message.debug ("formals : " + formals.ToString () + " params : " + parms.ToString ());
    def parms = CompileTypedMethod.adjust_tupled_parms (ctx, List.Length (formals), parms);
    List.Map2 (formals, parms, 
      fun (v : CG_val, e) { 
        maybe_cast (ctx, v.ty, e) 
      })
  }

  casted_parms (ctx : CTX, formals : list [Fun_parm], parms : list [Parm]) : list [CExpr]
  {
    def parms = List.Map (parms, fun (p : Parm) { cg_expr (ctx, p.expr) });
    def parms = adjust_tupled_parms (ctx, List.Length (formals), parms);
    List.Map2 (formals, parms, 
      fun (v : Fun_parm, e) { 
        maybe_cast (ctx, v.ty.GetSystemType (), e) 
      })
  }

  emit_loop (ctx : CTX, h : Fun_header, parms : list [Parm]) : CExpr
  {
    def ctx' = CTX (ctx);
    def parms = casted_parms (ctx, h.parms, parms);
    def parm_vals = List.Map2 (h.parms, parms, fun (fp : Fun_parm, ap) {
      def val = CG_val (loc = fp.decl.loc, 
                        name = fp.name,
                        ty = fp.ty.GetSystemType (),
                        val = ap);
      ignore (set_parm_info (fp, val));
      ctx'.locals = ctx'.locals.Add (fp.decl.id, val);
      val
    });
    ctx'.current_fun_or_loop = h;
    def loop = (CExpr.Loop (null, None ()) :> CExpr.Loop);
    ctx'.current_loop = Some (loop);
    loop.body = cg_expr (ctx', h.body);
    h.body = null;
    List.FoldLeft (List.Rev (parm_vals), (loop : CExpr), 
                   fun (v, expr) { CExpr.Define (v, expr) })
  }

  with_cached (expr : CExpr, f : CExpr -> CExpr) : CExpr
  {
    match (expr) {
      | CExpr.Ref
      | CExpr.GlobalRef
      | CExpr.VolatileGlobalRef
      | CExpr.ConstructorRef
      | CExpr.MethodAddress
      | CExpr.Opcode
      | CExpr.Literal
      | CExpr.This
      | CExpr.TypeOf 
      | CExpr.Indirect (CExpr.Ref) => f (expr)

      | _ =>
        def v = CG_val (loc = Location_stack.top (),
                        name = Util.tmpname ("cached"),
                        ty = expr.SystemType,
                        val = expr);
        CExpr.Define (v, f (CExpr.Ref (v)))
    }
  }

  cg_call (ctx : CTX, is_tail : bool, ret_type : TType, 
           f : TExpr, ps : list [Parm]) : CExpr
  {
    def compile_parm (p : Parm) {
      def ex = cg_expr (ctx, p.expr);
      if (p.kind == ParmKind.Out || p.kind == ParmKind.Ref)
        CExpr.Address (ex)
      else
        ex
    };

    def emit_call (cgm : CG_method, callable) {
      def parms = List.Map (ps, compile_parm);
      def callable =
        match (callable) {
          | CExpr.MethodRef (e, meth, notvirt) when e.SystemType.IsValueType && 
                                         !meth.DeclaringType.IsValueType =>
            CExpr.MethodRef (CExpr.Cast (e, meth.DeclaringType, true), meth, notvirt)
          | x => x
        };
      if (cgm == null) {
        def t = ret_type.GetSystemType ();
        if (is_tail)
          CExpr.TailCall (t, callable, parms)
        else
          CExpr.Call (t, callable, parms)
      } else {
        //Message.debug ("real casted params for " + cgm.name);
        def generate_call (parms) {
          if (is_tail)
            CExpr.TailCall (callable, casted_exprs (ctx, cgm.parms, parms))
          else
            CExpr.Call (callable, casted_exprs (ctx, cgm.parms, parms))
        };
        
        def call =
          match ((parms, cgm.parms)) {
            | ([parm], _ :: _ :: _) =>
              // need to cache it, so casted_parms can untuple it
              with_cached (parm, fun (parm) { generate_call ([parm]) })
            | _ =>
              generate_call (parms)
          };
        maybe_cast (ctx, ret_type.GetSystemType (), call)
      }
    };
    def plain_call () {
      def len = List.Length (ps);
      def imeth = get_apply_method (len);
      emit_call (CompileTypedMethod.GetCgMethod (imeth), 
                 CExpr.MethodRef (cg_expr (ctx, f), 
                 imeth.GetMethodInfo (), false))
    };
    
    match (f) {
      | TExpr.StaticRef (m) =>
        match (m.GetKind ()) {
          | MemberKind.Method (m) =>
            match (m.GetFunKind ()) {
              | _ when Option.IsSome (m.GetExternName ()) =>
                def opname = Option.UnSome (m.GetExternName ());
                assert (opname.StartsWith ("%op"));
                emit_call (null, CExpr.Opcode (opname.Substring (3)))
              | FunKind.Constructor =>
                if (m.DeclaringType.IsDelegate)
                  Util.locate (f.loc, CompileTypedMethod.emit_delegate_ctor (ctx, m, ps))
                else {
#if _GENERICS
                  def retty = ret_type.GetSystemType ();
                  Message.debug (retty.ToString ());
                  def cons = if (retty.HasGenericArguments) {
                    Message.debug (retty.ToString ());
                    def pars = array (ps.Length);
                    mutable i = 0;
                    foreach (p in ps) {
                      pars [i] = cg_expr (ctx, p.expr).SystemType;
                      ++i
                    } 
                    def c = retty.GetConstructor (pars);
                    Message.debug (c.ToString ());
                    c
                  }
                  else
                    m.GetConstructorInfo ();
                  emit_call (CompileTypedMethod.GetCgMethod (m), CExpr.ConstructorRef (cons))
#else                  
                  emit_call (CompileTypedMethod.GetCgMethod (m), CExpr.ConstructorRef (m.GetConstructorInfo ()))
#endif                  
                }
                  
              | _ =>
                emit_call (GetCgMethod (m), CExpr.GlobalRef (m.GetMethodInfo ()))
            }
          | _ => plain_call ()
        }
      | TExpr.OpCode (name) =>
        emit_call (null, CExpr.Opcode (name))
      
      // check for this invisibly coerced to other type -- encoding for base
      // and force nonvirt then
      | TExpr.MethodRef ((TExpr.LocalRef { 
                         decl = { kind = LocalValueKind.ClosurisedThis; 
                                  ty = TType.Class (ti, _) };
                         ty = TType.Class (ti', _) }) as o, m, false) 
                    when ! ti.Equals (ti') =>
        emit_call (GetCgMethod (m), CExpr.MethodRef (cg_expr (ctx, o), m.GetMethodInfo (), true))
        
      | TExpr.MethodRef (o, m, notvirt) =>   
        emit_call (GetCgMethod (m), CExpr.MethodRef (cg_expr (ctx, o), m.GetMethodInfo (), notvirt))
      | TExpr.Base (m) =>
        emit_call (GetCgMethod (m), CExpr.BaseCtorRef (m.GetConstructorInfo ()))
      | TExpr.LocalRef (d) =>
        match (d.kind) {
          | LocalValueKind.Function (({usage = FunctionUsage.UsedJustOnce}) as h, _) =>
            emit_loop (ctx, h, ps)
          | LocalValueKind.Function (h, _) when h.id == ctx.current_fun.id =>
            assert (h.cg_method.method_builder != null);
            emit_call (get_cg_method (h),
                       CExpr.MethodRef (CExpr.This (), h.cg_method.method_builder, false))
          | _ => plain_call ()
        }
      | _ => plain_call ()
    }
  }

  raw_cg_expr (ctx : CTX, inex : TExpr) : CExpr
  {
    //Message.debug ("emit");
    def self (e : TExpr) : CExpr { cg_expr (ctx, e) };
    match (inex) {
      | TExpr.LocalRef (d) => 
        local_ref (ctx, d, false)

      | TExpr.StaticRef (d) => 
        global_ref (ctx, d)

      | TExpr.FieldMember (o, f) =>
        def field_ref =
          if (f.IsVolatile)
            CExpr.VolatileFieldRef (self (o), f.GetFieldInfo ())
          else
            CExpr.FieldRef (self (o), f.GetFieldInfo ());
            
        maybe_cast (ctx, inex.ty.GetSystemType (), field_ref)

      | TExpr.ImplicitValueTypeCtor (t) =>
        CExpr.InitValueType (t.GetSystemType ())

      | TExpr.MethodRef => Util.ice ("MethodRef")
      | TExpr.PropertyMember => Util.ice ("PropertyMember " + PrettyPrint.SprintTyExpr (None (), inex))
      | TExpr.StaticPropertyRef => Util.ice ("StaticPropertyRef")
      | TExpr.ConstantObjectRef (mem) =>
        Message.warning ("using a constant object reference directly");
        Message.warning ("  you probably have meant to write `" +
                         mem.DeclaringType.FullName + " ()'");
        def mems =
          mem.DeclaringType.LookupMember ("_N_constant_object_generator");
        match (mems) {
          | [mem] => global_ref (ctx, mem)
          | _ =>
            Message.error ("  no constant object generator method found");
            CExpr.Nop ()
        }
      
      | TExpr.TypeOf (t) => CExpr.TypeOf (t.GetSystemType ())

      | TExpr.SelfTailCall (parms) =>
        def fn = ctx.current_fun_or_loop;
        match (fn.usage) {
          | FunctionUsage.UsedJustOnce =>
            def parms = casted_parms (ctx, fn.parms, parms);
            def assigns = 
              List.Map2 (parms, fn.parms, fun (expr, fp : Fun_parm) {
                (ctx.locals.Get (fp.decl.id), expr)
              });
            CExpr.Sequence ([CExpr.MultipleAssign (assigns), 
                          CExpr.ContinueLoop (Option.UnSome (ctx.current_loop))])
          | _ =>
            def parms = List.Map (parms, fun (p : Parm) { self (p.expr) });
            // Message.debug ("self casted params for " + fn.cg_method.name);
            def parms = casted_exprs (ctx, fn.cg_method.parms, parms);
            def t = inex.ty.GetSystemType ();
            CExpr.SelfTailCall (t, parms)
        }

      | TExpr.Call (f, ps) =>
        cg_call (ctx, false, inex.ty, f, ps)
       
      | TExpr.TailCall (f, ps) =>
        cg_call (ctx, true, inex.ty, f, ps)

      | TExpr.Assign (e1, e2) =>
        def e1 = self (e1);
        def e2 = self (e2);
        def e2 =
          if (e2.SystemType.IsValueType && !e1.SystemType.IsValueType)
            CExpr.Cast (e2, e1.SystemType, true)
          else
            e2;
        CExpr.Assign (e1, e2)
        
      | TExpr.Array (initializers, dimensions) =>
        def element_type =
          match (inex.ty) {
            | TType.Array (t, _) => t.GetSystemType ()
            | _ => assert (false)
          };
        def elt_is_value = element_type.IsValueType;
        def make_initializer (e) {
          def e = self (e);
          if (!elt_is_value && e.SystemType.IsValueType)
            CExpr.Cast (e, element_type, true)
          else
            e
        };
        CExpr.Array (ty = inex.ty.GetSystemType (), 
                    element_type = element_type, 
                    initializers = List.Map (initializers, make_initializer),
                    dimensions = List.Map (dimensions, fun (x) { self (x) }))

      | TExpr.ArrayIndexer (ty, obj, args) =>
        match (Tyutil.top_expand (obj.ty)) {
          | TType.Array => CExpr.ArrayAccess (ty.GetSystemType (), self (obj), List.Map (args, self))
          | _ => Util.ice ("ArrayIndexer")
        }

      | TExpr.DefValIn (d, v, b) =>
        if (d.ever_used) {
          def (ctx', cgv) = store_local (ctx, d, self (v));
          CExpr.Define (cgv, cg_expr (ctx', b))
        }
        else
          CExpr.Sequence ([CExpr.Ignore (self (v)), cg_expr (ctx, b)])

      | TExpr.DefFunctionsIn (fs, body) =>
        mutable vals = [];
        def store (f : Function_decl, ctx : CTX) : CTX {
          def fh = f.header.decl.GetFunctionHeader ();
          match (fh.usage) {
            | FunctionUsage.UsedJustOnce =>
              ctx
            | _ =>
              def ct = make_lambda_ctor_call (ctx, fh);
              def (ctx, val) = store_local (ctx, f.header.decl, ct);
              vals = val :: vals;
              ctx
          }
        };
        def emit (f : Function_decl) {
          def fh = f.header.decl.GetFunctionHeader ();
          match (fh.usage) {
            | FunctionUsage.UsedJustOnce => 
              // used later in emit_loop
              fh.body = f.body
            | _ => emit_lambda_code (ctx, fh, f.body)
          }
        };
        def mklet (val, acc) { CExpr.Define (val, acc) };

        def ctx = List.FoldLeft (fs, ctx, store);
        List.Iter (fs, emit);
        List.FoldLeft (vals, cg_expr (ctx, body), mklet)

      | TExpr.Match (e, mcs) =>
        with_cached (cg_expr (ctx, e), 
          fun (e) { 
            MatchingCompiler.Run (inex.ty.GetSystemType (), ctx, e, mcs)
          });

      | TExpr.Throw (e) => CExpr.Throw (cg_expr (ctx, e))

      | TExpr.TryWith (body, exn, handler) =>
        def body = cg_expr (ctx, body);
        // FIXME: this is broken for exn values to go into closure
        def (ctx', v) = store_local (ctx, exn, CExpr.Nop ());
        def handler = cg_expr (ctx', handler);
        CExpr.TryWith (inex.ty.GetSystemType (), body, v, handler);

      | TExpr.TryFinally (e1, e2) =>
        CExpr.TryFinally (cg_expr (ctx, e1), cg_expr (ctx, e2))

      | TExpr.Literal (l) => CExpr.Literal (l)

      | TExpr.This => CExpr.This ()

      | TExpr.TypeConversion (e, t, is_checked) => 
        CExpr.Cast (cg_expr (ctx, e), t.GetSystemType (), is_checked)

      | TExpr.TypeEnforcement (e, t) =>
        def e' = cg_expr (ctx, e);
        def t' = t.GetSystemType ();
        if (e'.SystemType.IsValueType != t'.IsValueType)
          CExpr.Cast (e', t', true)
        else
          e'

      | TExpr.Sequence (e1, e2) =>
        CExpr.Sequence ([cg_expr (ctx, e1), cg_expr (ctx, e2)])

      | TExpr.Tuple (l) =>
        tuple_ctor (List.Map (l, fun (e) { box_value (self (e)) }))

      | TExpr.Base => Util.ice ("stray base")
      | TExpr.OpCode => Util.ice ("stray opcode")
    }
  }

  /** 
   * Flatten given [Typedtree.TExpr] object into [CExpr].
   *
   * <remarks>
   *   As a side-effect few classes for closures and local functions
   *   can be generated and stored in current type builder.
   * </remarks>
   */
  internal cg_expr (ctx : CTX, ex : TExpr) : CExpr
  {
    Util.locate (ex.loc, raw_cg_expr (ctx, ex))
  }
} // end module
} // end ns
