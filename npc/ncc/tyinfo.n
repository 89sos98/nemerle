open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;

namespace Nemerle.Compiler {

(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

class Tyinfo
  {
    variant Member =
      [
        | Mem_methods { methods : list (M_function); }
        | Mem_field { fld : M_field; }
      ]
      
    record Subtyping_relation
      {
        td : Type_decl;
        args : list (option (Type));
      }
    
    field enclosing_type : option (Type_decl);
    field tydecl : Type_decl;
    field ref subtypes : Int_map (Subtyping_relation);
    field ref members : String_map (Member);
    field ref phase : int; // used by iter function
    // FIXME methods to implement
    
    method this (par : option (Type_decl), td : Type_decl) 
      { 
        this#enclosing_type <- par;
        this#tydecl <- td;
        this#subtypes <- Map.int_map ();
        this#members <- Map.string_map ();
      }

    method lookup_method (name : string) : list (M_function) =
      match this#members#find(name) with [
        | Some (Mem_methods (?x)) => x
        | _ => Nil()
      ];
      
    method lookup_field (name : string) : option (M_field) =
      match this#members#find(name) with [
        | Some (Mem_field (?x)) => Some(x)
        | _ => None()
      ];

    method how_subtypes (td : Type_decl) : option (list (option (Type))) =
      match this#subtypes#find(td#id) with [
        | Some (?sr) => Some(sr#args)
        | None => None()
      ];

    method fullname () : string = 
      let td = this#tydecl in td#env#current_namespace + td#name;
    
    method direct_supertypes () : list (Type) =
      let td = this#tydecl in
      match td#t_extends with [
        | Some (?t) => Cons (t, td#t_implements)
        | None => td#t_implements
      ];

    fun td_name (td : Type_decl) : string = (lookup(td#id))#fullname();

    value ref infos : Int_map(Tyinfo);
    
    fun lookup (id : int) : Tyinfo =
      match infos#find(id) with [
        | Some (?ti) => ti
        | None => Util.ice()
      ];

    fun lookup (td : Type_decl) : Tyinfo = lookup(td#id);
    
    fun make (decls : list (Type_decl)) : void =
      letfun tydecl_f (par : option (Type_decl), d : Type_decl) : option (Type_decl) = {
        infos <- infos#add(d#id, Tyinfo(par, d));
        Some (d)
      } and decl_f (_ : option (Type_decl), _ : Class_member) : void = () 
      in {
        infos <- Map.int_map();
        Treeutil.decl_walk(tydecl_f, decl_f, None(), decls);
      };

    type Subinfo = Int_map (Subtyping_relation);

    // iterate over tyinfos, but supertypes are always processed before subtypes
    // otherwise source-code order is retained
    fun iter (f : Tyinfo -> void) : void =
      let working_on = Util.next_id () in
      let done = Util.next_id () in
      letfun sub_do (t : Type) : void =
        match t with [
          | T_app ?td => maybe_f (lookup (td#ref_to))
          | _ => ()
        ]
      and maybe_f (ti : Tyinfo) : void =
        if ti#phase == done then ()
        else if ti#phase == working_on then {
          Message.error(ti#tydecl#loc, "type definition for `" + ti#fullname() + "' is cyclic")
        } else {
          ti#phase <- working_on;
          Util.locate (ti#tydecl#loc, fun () : void => {
            List.iter (sub_do, ti#direct_supertypes ());
            f (ti)
          });
          ti#phase <- done
        }
      in infos#iter(fun (_ : int, ti : Tyinfo) : void => maybe_f (ti));
      
    fun determine_subtyping () : void = 
      letfun add_subtyping_of (ti : Tyinfo, s : Subinfo, t : T_app) : Subinfo =
        let (?sub, ?ti') = Tyutil.subst_of_app (t) in
        letfun add_sr (s : Subinfo, sr : Subtyping_relation) : Subinfo =
          match s#find (sr#td#id) with [
            | Some (?sr') =>
              let ref problem = "" in
              letfun opt_eq (a : option (Type), b : option (Type)) : bool =
                match (a, b) with [
                  | (Some (?t1), Some (?t2)) =>
                    if Tyutil.types_eq (t1, t2) then true
                    else {
                      problem <- "types " + t1#as_string() + " and " +
                                 t2#as_string() + " are not compatible";
                      false
                    }
                  | (None, None) => true
                  | _ => false
                ]
              in
              if List.forall2 (opt_eq, sr#args, sr'#args) then s
              else {
                Message.error ("type `" + td_name(sr#td) + 
                               "' is implemented by type `" +
                               ti#fullname() +
                               "' twice under different instantiations");
                if ti'#tydecl#id == sr#td#id then
                  Message.error ("second one directly")
                else
                  Message.error ("second one through `" + ti'#fullname() + "'");
                Message.error (problem);
                s
              }
            | None => 
              s#add (sr#td#id, sr)
          ]
        in
        letfun add_sr_from_parent (s : Subinfo, _ : int, 
                                   sr : Subtyping_relation) : Subinfo =
          letfun apply_sub (t : option (Type)) : option (Type) =
            match t with [ 
              | Some (?x) => Some (x /- sub) 
              | None => None ()
            ]
          in
          let new_sr = Subtyping_relation (sr#td, List.map (apply_sub, sr#args)) in
          add_sr (s, new_sr)
        in {
          let s = ti'#subtypes#fold(add_sr_from_parent, s) in
          let new_sr = 
            Subtyping_relation (ti'#tydecl, 
                                List.map (fun (x : Type) : option (Type) => Some (x), t#args))
          in add_sr (s, new_sr)
        }

      and make_srs (ti : Tyinfo) : void =
        letfun add_srs (s : Subinfo, t : Type) : Subinfo =
          match t with [
            | T_app ?t => add_subtyping_of (ti, s, t)
            | _ =>
              {
                Message.error("cannot implement nor extend non-class type");
                s
              }
          ]
        in ti#subtypes <- List.fold_left (add_srs, Map.int_map (), ti#direct_supertypes ())
      in iter (make_srs);

    fun run (decls : list (Type_decl)) : void {
      make(decls);
      determine_subtyping();
    }
  }

} // ns
