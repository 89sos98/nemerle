/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler.Parsetree;

using TT = Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler 
{
  public module ConstantFolder
  {
    internal is_known_operator (name : string) : bool
    {
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "%^"
      | "%|"
      | "&"
      | "^"
      | "|"
      | "%&"
      | "&&"
      | "||"
      | "!"
      | ">>"
      | "<<"
      | "~" => true
      | _ => false
    }

    emit_flag_warning (t : TypeInfo) : void
    {
      when ((t.GetTydecl () matches TT.TypeDeclaration.Enum) && 
            ! t.HasAttribute (InternalType.FlagsAttribute_tc) &&
            Options.EnumFlagsWarnings)
        Message.warning ($ "using bitwise operator on enum type `$(t)' "
                           "that has [Flags] attribute");
    }

    [Nemerle.Assertions.Ensures (value != null)]
    underlying_enum_type (t : TypeInfo) : TypeInfo
    {
      def flds = t.GetFields (BindingFlags.Public %|
                              BindingFlags.NonPublic %|
                              BindingFlags.Instance);
      List.FoldLeft (flds, null, fun (elt : IField, acc) {
        assert (acc == null);
        match (elt.GetMemType ()) {
          | TT.TType.Class (tc, []) => tc
          | _ => assert (false)
        }
      });
    }

    internal FieldValueAsLiteral (field : IField) : option [Literal]
    {
      def decl_type = field.DeclaringType;
      decl_type.HasBeenUsed = true;
      def (enum_ty, field_type) =
        match (decl_type.GetTydecl ()) {
          | TT.TypeDeclaration.Enum =>
            (Some (decl_type), underlying_enum_type (decl_type))
            
          | _ => 
            match (field.GetMemType ()) {
              | TT.TType.Class (tc, []) => (None (), tc)
              | _ => assert (false) // shouldn't be literal
            }
        };
      match (NumericType.ByName (field_type.FullName)) {
        | Some (num_ty) =>
          def lit = num_ty.ToLiteral (field.GetValue ());
          field.HasBeenUsed = true;
          match (enum_ty) {
            | Some (tc) => Some (Literal.Enum (lit, tc))
            | None => Some (lit)
          }
        | None =>
          // ice?
          Message.warning ("literal field of unknown type `" + 
                           field_type.FullName + "'");
          None ()
      }
    }

    literal_field_value (env : GlobalEnv, expr : PExpr) : PExpr
    {
      match (Util.qidl_of_expr (expr)) {
        | Some ((id, name)) =>
          match (name.GetEnv (env).LookupSymbol (id, null)) {
            | [Symbol.TypeMember (m)] =>
              match (m.GetKind ()) {
                | MemberKind.Field (fld) when fld.IsLiteral =>
                  match (FieldValueAsLiteral (fld)) {
                    | Some (lit) => PExpr.Literal (expr.loc, lit)
                    | None => expr
                  }
                | _ => expr
              }
            | [] => 
              expr
            | _ => 
            expr
          }
        | None => expr
      }
    }

    literal_of_expr (e : PExpr) : option [Literal]
    {
       | PExpr.Literal (l) => Some (l)
       | PExpr.Typed (TT.TExpr.Literal (l)) => Some (l)
       | _ => None ()
    }
    
    fold_unary_operator (is_checked : bool, name : string, 
                         e1 : PExpr, expr : PExpr) : PExpr
    {
      match (literal_of_expr (e1)) {
        | Some (Literal.Enum (lit, enum_ty)) when name == "~" =>
          emit_flag_warning (enum_ty);
          def t = Option.UnSome (NumericType.ByLiteral (lit));
          def res = t.Unary (is_checked, name, t.FromLiteral (lit));
          assert (res != null);
          PExpr.Literal (expr.loc, Literal.Enum (t.ToLiteral (res), enum_ty))

        | Some (lit) =>
          match (NumericType.ByLiteral (lit)) {
            | Some (t) =>
              def res = t.Unary (is_checked, name, t.FromLiteral (lit));
              if (res == null)
                expr
              else
                PExpr.Literal (expr.loc, t.ToLiteral (res))
            | None => expr
          }
        | None => expr
      }
    }

    fold_binary_operator (is_checked : bool, name : string, e1 : PExpr, e2 : PExpr, 
                          expr : PExpr) : PExpr
    {
      match ((literal_of_expr (e1), literal_of_expr (e2))) {
        | (Some (l1), Some (l2)) =>
          def (l1, l2, enum_ty) =
            match ((l1, l2)) {
              | (Literal.Enum (l1, t1), Literal.Enum (l2, t2)) 
                when t1.Equals (t2) =>
                (l1, l2, Some (t1))
              | _ => (l1, l2, None ())
            };
          match ((NumericType.ByLiteral (l1), NumericType.ByLiteral (l2))) {
            | (Some (t1), Some (t2)) when (t1 : object) == (t2 : object) =>
              def res = t1.Binary (is_checked, name, t1.FromLiteral (l1), 
                                   t1.FromLiteral (l2));
              def lit = t1.ToLiteral (res);
              if (res != null)
                match ((enum_ty, name)) {
                  | (None, _) => 
                    PExpr.Literal (expr.loc, lit)
                  | (Some (t), "|")
                  | (Some (t), "&")
                  | (Some (t), "^")
                  | (Some (t), "%|")
                  | (Some (t), "%&")
                  | (Some (t), "%^") =>
                    emit_flag_warning (t);
                    PExpr.Literal (expr.loc, Literal.Enum (lit, t))
                  | (Some, _) =>
                    // other operators not allowed on enums
                    expr
                }
              else
                expr
            | _ => expr
          }
        | _ => expr
      }
    }
    
    fold_constants (is_checked : bool, env : GlobalEnv, expr : PExpr, recurse : bool) : PExpr
    {
      try {
        match (expr) {
          | <[ $(name : dyn) ($e1, $e2) ]> when is_known_operator (name) =>
            if (recurse)
              fold_binary_operator (is_checked,
                                    name, 
                                    fold_constants (is_checked, env, e1, true), 
                                    fold_constants (is_checked, env, e2, true), 
                                    expr)
            else
              fold_binary_operator (is_checked, name, e1, e2, expr)

          | <[ $(name : dyn) ($e1) ]> when is_known_operator (name) =>
            if (recurse)
              fold_unary_operator (is_checked, name, fold_constants (is_checked, env, e1, true), expr)
            else
              fold_unary_operator (is_checked, name, e1, expr)

          | <[ $_o . $_f ]>
          | <[ $(_ : name) ]> => 
            literal_field_value (env, expr)

          | _ => expr
        }
      }
      catch {
        | _ : System.OverflowException => // FIXME: use guards in catching
          if (is_checked) {
            Message.error ("The operation overflows at compile-time during"
                           " constants folding in checked mode");
            expr
          }
          else
            Util.ice ("overflow exception")
      }
    }

    public FoldConstants (env : GlobalEnv, expr : PExpr) : PExpr
    {
      fold_constants (false, env, expr, true)
    }
    
    internal FoldTopConstants (is_checked : bool, env : GlobalEnv, expr : PExpr) : PExpr
    {
      fold_constants (is_checked, env, expr, false)
    }
  }
}
