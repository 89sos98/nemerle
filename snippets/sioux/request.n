/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ 

namespace Sioux
{
  using Nemerle.Collections;
  using Nemerle.Xml;

  using System.Net.Sockets;
  

  /**
   * Description of an HTTP request
   */
  public variant RequestInfo
  {
    | StaticGet { url : string; }
    | DynamicGet { url : string; get_params : list <string * string>; }
    | Post { url : string; post_data : string; }
    | Invalid    
  }
  
  
  /**
   * Request parser
   */
  public class Request
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */
    
    /**
     * Parses the request data.
     */
    internal this (stream : NetworkStream)
    {
      request_stream <- stream;
      logger <- Httpd.GetLogger ();
      
      parse_request_data ()
    }
    
    
    /* -- PUBLIC METHODS --------------------------------------------------- */
    
    /**
     * Returns the request info associated with this instance
     */
    public GetRequestInfo () : RequestInfo
    {
      request_info
    }


    /**
     * Returns a list of headers. The ordering is the same
     * as sent by the client.
     */
    public GetHeaders () : list <string * string>
    {
      headers
    }
    
    
    
    /* -- INTERNAL METHODS ------------------------------------------------- */
    
    /**
     * Reads a line from the stream
     */     
    internal ReadLine () : string
    {
      def sb = System.Text.StringBuilder ();
      
      def loop () {
        def ich = request_stream.ReadByte ();
        def ch = (ich :> char);
        if (ich == -1 || ch == '\n') ()
        else if (ch == '\r') loop ()
        else {
          ignore (sb.Append (ch));
          loop ()
        }
      };
      
      loop ();
      sb.ToString ()
    }
    
    
    
    
    /* -- PRIVATE METHODS -------------------------------------------------- */

    /**
     * Splits a string given a separator character. Checks if the split was
     * unique -- or, if the separator occured exactly once in the original 
     * string.
     */
    private split_unique_at (separator : char, str : string) 
                                                   : string * string * bool
    {
      def pos = str.IndexOf (separator);
      
      def (l, r) =
        if (pos != -1)
          (str.Substring (0, pos), str.Substring (pos + 1))
        else
          (str, "");
          
      def validity =
        l.IndexOf (separator) == -1 && r.IndexOf (separator) == -1;
        
      (l, r, validity)
    }
    
    
    /**
     * A helper function ignoring the validity result from
     * the split_unique_at function.
     */
    private split_at (separator : char, str : string) : string * string
    {
      def (l, r, _) = split_unique_at (separator, str);
      
      (l, r)
    }


    /**
     * Parses a string of form: 
     *
     * url?param_1=val_1&param_2=val_2&...&param_k=val_k
     *
     * Checks the validity of such a request.
     */
    private parse_get_params (orig_url : string) : string * list <string * string> * bool
    {
      def (url, get_params, split_was_unique) = split_unique_at ('?', orig_url);
      def invalid = (orig_url, [], false);
            
      if (url.Length > 0 && split_was_unique) {
        // check the case for no GET parameters
        if (get_params.Length == 0) {
          (url, [], true) 
        }
        else {        
          def delimiter = array ['&'];
          def split = get_params.Split (delimiter);
          
          // check for the url?param special case
          if (split.Length == 1) {
            def (param, value, split_was_unique) = 
              split_unique_at ('=', split [0]);

            if (split_was_unique)
              (url, [(param, value)], true)
            else
              invalid
          }
          else {
            mutable params_are_valid <- true;
            mutable result <- [];
            mutable index <- 0;
            
            while (index < split.Length) {          
              def (param, value, split_was_unique) = 
                split_unique_at ('=', split [index]);
              
              unless (split_was_unique && param.Length > 0 && value.Length > 0)
                params_are_valid <- false;

              result <- (param, value) :: result;          
              index <- index + 1
            };
            
            if (params_are_valid)
              (url, List.Rev (result), true)
            else
              invalid
          }        
        }
      }
      else
        invalid
    }


    /**
     * Retrieves the post data
     *
     * FIXME: what about file uploads?
     */
    private parse_post_data () : string
    {

/*
    set_post_vars () : void
    {
      def sb = System.Text.StringBuilder ();
      def loop () {
        if (post_length == 0) ()
        else {
          post_length <- post_length - 1;
          def ch = SockStream.ReadByte ();
          if (ch == -1) ()
          else {
            ignore (sb.Append ((ch :> char)));
            loop ()
          }
        }
      };
      loop ();
      parse_into (PostVars, sb.ToString ())
    }

*/

      "NOT YET IMPLEMENTED"
    }


    /**
     * Parses request data
     */ 
    private parse_request_data () : void
    {
      def request_data = ReadLine ();
      
      def delimiter = array [' '];
      def split = request_data.Split (delimiter);

      request_info <- Invalid ();
      content_length <- None ();

      read_headers ();

      if (split.Length >= 2)
      {
        def request_type = (split [0]).ToUpper ();
        def request_url = split [1];
        
        def (request_url, request_params, request_params_validity) =
          parse_get_params (request_url);
        
        match (request_type) {
          | "GET" =>            
            if (split.Length > 3)
              logger.Log ("more than three tokens in a GET request")
            else if (!request_params_validity)
              logger.Log ("invalid GET parameters")
            else {
              if (request_url == "/")
                request_info <- DynamicGet ("index.xml", request_params)                
              else if (request_url.EndsWith (".xml"))
                request_info <- DynamicGet (request_url, request_params)
              else {
                if (List.Length (request_params) > 0)
                  logger.Log ("static GET request had GET parameters")
                else
                  request_info <- StaticGet (request_url)
              }
            }

          | "POST" =>
            if (List.Length (request_params) > 0)
              logger.Log ("POST request had GET parameters")
            else if (!request_url.EndsWith (".xml"))
              logger.Log ("POST request to an invalid URL")
            else {
              def post_data = parse_post_data ();
              request_info <- Post (request_url, post_data)
            }

          | _ =>
            logger.Log ("unknown request type")
        }
      }
      else
        logger.Log ("request contains less than two words")
    }


    /**
     * Reads the HTTP headers
     */
    private read_headers () : void
    {
      mutable result <- [];
      
      def loop () {
        match (ReadLine ()) {
          | "" => ()
          | line =>
            def (name, val) = split_at (':', line);
            def (name, val) = (name.ToLower ().Trim (), val.Trim ()); 

            when (name == "content-length")            
              content_length <- Some (System.Int32.Parse (val));
 
            loop ();
        }
      };

      loop ();
      
      headers <- List.Rev (result)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable request_stream : NetworkStream;
    private mutable request_info : RequestInfo;
    private mutable headers : list <string * string>;
    private mutable content_length : option <int>;
    private mutable logger : Logger;
  }
}
