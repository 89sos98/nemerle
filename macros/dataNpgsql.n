/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Data;
using System.Text.RegularExpressions;
using Nemerle.Collections;
using Npgsql;

using Nemerle.Compiler;

namespace Nemerle.Data {
module Npgsql {
  private connections : Hashtable <string, NpgsqlConnection>;
  
  public this () { connections <- Hashtable () }

  get_connection (name : string) : NpgsqlConnection
  {
    match (connections.Get (name)) {
      | Some (c) => c
      | None =>
        Message.fatal_error ("connection `" + name + "' was not found")
    }
  }
  
  type_representant (t : Typedtree.Type) : DbType * object
  {
    match (t) {
      | Typedtree.T_app (tc, []) =>
        match (tc.GetFullName ()) {
          | "System.String" | "Nemerle.Core.string" =>
            (DbType.String, ("string parameter" : object))
          | "System.Int32" | "Nemerle.Core.int" =>
            (DbType.Int32, 234)
          | "System.Bool" | "Nemerle.Core.bool" =>
            (DbType.Boolean, true)
          | "System.UInt32" | "Nemerle.Core.uint" =>
            (DbType.UInt32, 234u)
          | "System.Byte" | "Nemerle.Core.byte" =>
            (DbType.Byte, 34ub)
          | "System.DataTime" =>
            (DbType.DateTime, System.DateTime.Now)
          | "System.Decimal" | "Nemerle.Core.decimal" =>
            (DbType.Decimal, System.Convert.ToDecimal (45.3))
          | "System.Double" | "Nemerle.Core.double" =>
            (DbType.Double, 34.4)
          | "System.Guid" =>
            (DbType.Guid, System.Guid.NewGuid ())
          | "System.Int16" | "Nemerle.Core.short" =>
            (DbType.Int16, 34s)
          | "System.UInt16" | "Nemerle.Core.ushort" =>
            (DbType.UInt16, 34us)
          | "System.Int64" | "Nemerle.Core.long" =>
            (DbType.Int64, 34l)
          | "System.UInt64" | "Nemerle.Core.ulong" =>
            (DbType.UInt64, 34ul)
          | "System.Object" | "Nemerle.Core.object" =>
            (DbType.Object, null)
          | "System.SByte" | "Nemerle.Core.sbyte" =>
            (DbType.SByte, 34b)
          | "System.Single" | "Nemerle.Core.float" =>
            (DbType.Single, 34.4f)
          | x =>
            Message.fatal_error (x + " type not supported")
        }
      | _ =>
        Message.fatal_error ("only basic types supported in sql query")
    }
  }

  /** Extracts parameters after $, perform typing of expressions containing
      variables with names of those parameters.

      Returns:
       - final SQL provider secific query
       - collection of name and typed expression containing variable with this
         name
       - list of expressions initializing [querycmd.Parameters] to value of
         above variables
   */
  extract_parameters (ctx : Tyexpr.CTX, query : string)
  : string * Hashtable <string, Typedtree.Expr> * list <Parsetree.Expr>
  {
    // take names after $
    def namesreg = Regex (@"(([^\$]*)\$(\w+))|(.+)", RegexOptions.Singleline);
    mutable m <- namesreg.Match (query);
    def fquery = System.Text.StringBuilder (query);
    def pars = Hashtable ();

    // extract names and prefix them with Npgsql parameter delimiter `:'
    while (m.Success) {
      when (m.Groups[1].Success) {
        pars.Set (m.Groups[3].ToString (), null);
        fquery[m.Groups[3].Index - 1] <- ':';
      };
      m <- m.NextMatch ();
    };

    /// initializers of sql command parameters
    def tpars = Hashtable ();
    /// expressions initializing [querycmd.Parameters] with their values    
    mutable pars_init <- [];
    // itreate through parameters to type them and create initializers
    pars.Iter (fun (x, _) {
      def varname = Macros.UseSiteSymbol (x);
      def tvar = Tyexpr.ty_expr (ctx, <[ $(varname : var) ]>);
      tpars.Set (x, tvar);

      /// add parameter initializer
      pars_init <- <[
        ignore (querycmd.Parameters.Add ($(x : string), $(tvar : typed)))
      ]> :: pars_init;
    });
    (fquery.ToString (), tpars, pars_init)
  }

  
  macro CreateCompileTimeConnection (con_str : string, name : string = "")
  {
    if (connections.Contains (name))
      Message.fatal_error ("Connection with name `" + name + "' is already defined")
    else {
      def connection = NpgsqlConnection (con_str);
      connection.Open ();
      connections.Add (name, connection)
    };
    <[ () ]>
  }

  macro ExecuteNonQuery (query : string, conn, con_name : string = "")
  {
    def (query, tpars, pars_init) =
      extract_parameters (Nemerle.Macros.ImplicitCTX (), query);

    // create compile-time query to check syntax and types in query
    def mytran = get_connection (con_name).BeginTransaction ();    
    def mycmd = NpgsqlCommand (query, get_connection (con_name), mytran);
    try 
      try {
        tpars.Iter (fun (name, tvar : Typedtree.Expr) {
          def (dbtype, dbvalue) = type_representant (tvar.expr_ty);
          mycmd.Parameters.Add (name, dbtype).Value <- dbvalue;
        });
        // try to execute query chcecking its syntax and typecorrectness

        ignore (mycmd.ExecuteNonQuery ())
      }
      catch {
        | e : NpgsqlException =>
          Message.fatal_error ("sql query error: " + e.Message)
      }
    finally {
      mytran.Rollback ();
      mycmd.Dispose ();
    };
    
    <[
      def querycmd = NpgsqlCommand ($(query : string), $conn);
      { .. $pars_init };
      def result = querycmd.ExecuteNonQuery ();
      querycmd.Dispose ();
      result
    ]>
  }

  macro ExecuteScalar (query : string, conn, con_name : string = "")
  {
    def (query, tpars, pars_init) =
      extract_parameters (Nemerle.Macros.ImplicitCTX (), query);

    mutable col_type <- null;

    // create compile-time query to check syntax and types in query
    def mytran = get_connection (con_name).BeginTransaction ();          
    def mycmd = NpgsqlCommand (query, get_connection (con_name), mytran);
    try
      try {
        tpars.Iter (fun (name, tvar : Typedtree.Expr) {
          def (dbtype, dbvalue) = type_representant (tvar.expr_ty);
          mycmd.Parameters.Add (name, dbtype).Value <- dbvalue;
        });

        // try to execute query chcecking its syntax and aquiring names of columns
        def myreader = mycmd.ExecuteReader(CommandBehavior.SchemaOnly);
        def table = myreader.GetSchemaTable ();
        if (table.Rows.Count < 1)
          Message.fatal_error ("this query doesn't return any value")
        else 
          col_type <- Macros.UseSiteSymbol (table.Rows[0]["DataType"].ToString ());
        myreader.Close ();
        mytran.Rollback ();      
        mycmd.Dispose ();
      }
      catch {
        | e : NpgsqlException =>
          Message.fatal_error ("sql query error: " + e.Message)
      }
    finally {
      mytran.Rollback ();
      mycmd.Dispose ();
    };
      
    /// final code for entire sql loop
    <[
      def querycmd = NpgsqlCommand ($(query : string), $conn);
      { .. $pars_init };
      def result = (querycmd.ExecuteScalar () :> $(col_type : var));
      querycmd.Dispose ();
      result
    ]>
  }

  macro ExecuteReader (query : string, conn, con_name : string = "")
  {
    def (query, tpars, pars_init) =
      extract_parameters (Nemerle.Macros.ImplicitCTX (), query);

    // create compile-time query to check syntax and types in query
    def mytran = get_connection (con_name).BeginTransaction ();                
    def mycmd = NpgsqlCommand (query, get_connection (con_name));
    try
      try {
        tpars.Iter (fun (name, tvar : Typedtree.Expr) {
          def (dbtype, dbvalue) = type_representant (tvar.expr_ty);
          mycmd.Parameters.Add (name, dbtype).Value <- dbvalue;
        });
        // try to execute query chcecking its syntax
        ignore (mycmd.ExecuteNonQuery ());
        mytran.Rollback ();
        mycmd.Dispose ();
      }
      catch {
        | e : NpgsqlException =>
          Message.fatal_error ("sql query error: " + e.Message)
      }
    finally {
      mytran.Rollback ();
      mycmd.Dispose ();
    };

    /// final code for entire sql loop
    <[
      def querycmd = NpgsqlCommand ($(query : string), $conn);
      { .. $pars_init };
      def result = querycmd.ExecuteReader ();
      querycmd.Dispose ();
      result
    ]>
  }
  
  macro ExecuteReaderLoop (query : string, conn, body)
  {
    def (query, tpars, pars_init) =
      extract_parameters (Nemerle.Macros.ImplicitCTX (), query);

    // list of definitions of query results inside loop body
    mutable bodyseq <- [body];

    // create compile-time query to check syntax and types in query
    def mytran = get_connection ("").BeginTransaction ();
    def mycmd = NpgsqlCommand (query, get_connection (""), mytran);
    try
      try {
        tpars.Iter (fun (name, tvar : Typedtree.Expr) {
          def (dbtype, dbvalue) = type_representant (tvar.expr_ty);
          mycmd.Parameters.Add (name, dbtype).Value <- dbvalue;
        });

        // try to execute query chcecking its syntax and aquiring names of columns
        def myreader = mycmd.ExecuteReader(CommandBehavior.SchemaOnly %|
                                           CommandBehavior.SingleRow);
        def table = myreader.GetSchemaTable ();
        mutable col_num <- 0;
        foreach(myRow : DataRow in table.Rows){
          def col_type = Macros.UseSiteSymbol (myRow["DataType"].ToString ());
          def col_name = Macros.UseSiteSymbol (myRow["ColumnName"].ToString ());
          def type_suff = col_type.id.Substring (col_type.id.LastIndexOf ('.') + 1);

          // create runtime variables definition according to extracted types
          bodyseq <- <[ def $(col_name : var) =
                          reader.$("Get" + type_suff : dyn) ($(col_num : int)) ]>
                      :: bodyseq;
          ++col_num;
        };
        myreader.Close ();
      }
      catch {
        | e : NpgsqlException =>
          Message.fatal_error ("sql query error: " + e.Message)
      }
    finally {
      mytran.Rollback ();
      mycmd.Dispose ();
    };

    /// final code for entire sql loop
    <[
      def querycmd = NpgsqlCommand ($(query : string), $conn);
      { .. $pars_init };
      def reader = querycmd.ExecuteReader ();
      while (reader.Read ()) { ..$bodyseq };
      reader.Close ();
      querycmd.Dispose ();
    ]>
  }

}
}
