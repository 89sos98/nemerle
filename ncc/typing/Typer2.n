/*
 * Copyright (c) 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  [ManagerAccess]
  internal class Typer2
  {
    top_level_fun : MethodBuilder;
    mutable this_ptr_decl : LocalValue;
    mutable current_fun : Fun_header;
    top_fun : Fun_header;
    current_type : TypeBuilder;
    messenger : Messenger;
    inside_yielding_function : bool;

    [System.Flags]
    enum Context {
      | Clean              = 0x0000
      | IsTail             = 0x0001
      | NeedLValue         = 0x0002
      | IsCalledValue      = 0x0004
      | IsIndexerRef       = 0x0008
      | IsDelegeteCtorParm = 0x0010
      | AllowGoto          = 0x0020
      | AllowTry           = 0x0040
      | AllowTryAtFuncLev  = 0x0080
      
      | AllowGotoAndSuch   = AllowGoto %| AllowTry

      | TopLevel           = IsTail %| AllowGoto %| AllowTry
    }
    
    public this (ty : TypeBuilder, fn : MethodBuilder)
    {
      Manager = ty.Manager;
      current_fun = fn.GetHeader ();
      top_fun = current_fun;
      current_fun.usage = FunctionUsage.Used;
      top_level_fun = fn;
      current_type = ty;

      messenger = Manager.Solver.CurrentMessenger;

      inside_yielding_function =  current_fun.yield_type != null;
    }
    

    public Run () : void
    {
      foreach (parm in current_fun.parms)
        parm.decl.Register ();

      match (current_fun.body) {
        | FunBody.Typed (expr) =>
          current_fun.body = FunBody.Typed (Walk (Context.TopLevel, expr));
          FixupCurrentFunction ();
        | _ => {}
      }
    }


    Walk (expr : TExpr) : TExpr
    {
      Walk (Context.Clean, expr)
    }


    Walks (exprs : list [TExpr]) : list [TExpr]
    {
      List.Map (exprs, Walk)
    }

    
    Walk (ctx : Context, expr : TExpr) : TExpr
    {
      assert (expr != null);
      Util.locate (expr.loc, {
        messenger.CleanLocalError ();
        def expr = PushConversionDown (expr);
        def res = DoWalk (ctx, expr);
        def res =
          if (res == null)
            expr
          else {
            match (res) {
              | _ when res.ty != null =>
                // Message.Debug ($ "type for $res ($(res.GetType())) already set to $(res.ty), "
                //                 "would set to $(expr.ty)");
                {}

              | Sequence (_, e)
              | DefValIn (_, _, e) =>
                res.ty = e.Type;
              | _ =>
                res.ty = expr.ty;
            }
            res
          }
        when (ctx %&& Context.IsTail)
          match (res) {
            | TExpr.Call as call =>
              call.is_tail = true;
            | _ => ()
          }
        res
      })
    }


    static AreSelfMethodTyParms (meth : IMethod, typarms : list [TyVar]) : bool
    {
      if (typarms.IsEmpty) true
      else {
        def Manager = typarms.Head.Manager;
        def is_ok =
          try {
            Manager.Solver.PushState ();
            List.ForAll2 (meth.GetHeader ().typarms, typarms, fun (st, tv) {
              tv.Unify (MType.TyVarRef (st))
            })
          } finally {
            Manager.Solver.PopState ();
          }
        if (is_ok) {
          List.Iter2 (meth.GetHeader ().typarms, typarms, fun (st, tv) {
            tv.ForceUnify (MType.TyVarRef (st))
          });
          true
        } else false
      }
    }
    

    IsSelfCall (func : TExpr) : bool
    {
      match (Unfold (func)) {
        | TExpr.LocalFunRef (decl, _) =>
          match (decl.ValKind) {
            | LocalValue.Kind.Function (hd, _) =>
              hd.id == current_fun.id
            | _ => false
          }
        | TExpr.StaticRef (Class (tc, _) as from, meth is IMethod, typarms) =>
          meth.GetHeader ().id == current_fun.id &&
          tc.GetMemType ().Equals (from) &&
          AreSelfMethodTyParms (meth, typarms)
          
        | TExpr.MethodRef (th, meth : IMethod, typarms, _) =>
          meth.GetHeader ().id == current_fun.id &&
          Unfold (th) is TExpr.This &&
          AreSelfMethodTyParms (meth, typarms)

        | _ => false
      }
    }


    Unfold (expr : TExpr) : TExpr
    {
      match (expr) {
        | TExpr.Delayed (dt) =>
          match (dt.DtKind) {
            | Typer.DelayedTyping.Kind.Resolved (expr) =>
              Unfold (expr)
            | _ => Util.ice ($ "unresolved expression: $dt");
          }
        | TExpr.TypeConversion =>
          PushConversionDown (expr)
        | _ => expr
      }
    }


    IsOperator (expr : TExpr) : bool
    {
      match (Unfold (expr)) {
        | TExpr.StaticRef (_, meth is IMethod, _) =>
          ! (meth.BuiltinKind is BuiltinMethodKind.NotBuiltin)
        | _ => false
      }
    }

    OperatorKind (expr : TExpr) : BuiltinMethodKind
    {
      match (Unfold (expr)) {
        | TExpr.StaticRef (_, meth is IMethod, _) =>
          meth.BuiltinKind
        | _ => assert (false)
      }
    }


    IsCurrentType (tv : TyVar) : bool
    {
      match (tv.Fix ()) {
        | MType.Class (ti, _) =>
          ti.Equals (current_type)
        | _ => false
      }
    }


    GetEventObj (expr : TExpr) : option [IEvent * TExpr * MType.Class]
    {
      match (Unfold (expr)) {
        | TExpr.StaticEventRef (ty, ev) => Some ((ev, null, ty))
        | TExpr.EventMember (obj, ev) => Some ((ev, obj, null))
        | _ => None ()
      }
    }



    TheSame (e1 : TExpr, e2 : TExpr) : bool
    {
      e1 : object == e2 : object ||
      match ((Unfold (e1), Unfold (e2))) {
        | (TExpr.LocalRef (d1), TExpr.LocalRef (d2)) =>
          d1.Equals (d2)
        | (TExpr.StaticRef (t1, m1, l1), TExpr.StaticRef (t2, m2, l2)) =>
          t1.Equals (t2) &&
          m1.Equals (m2) &&
          l1.Equals (l2)
        | (TExpr.This, TExpr.This) => true
        | _ => false
      }
    }

    PushConversionDown (expr : TExpr) : TExpr
    {
      match (expr) {
        | TExpr.Delayed =>
          PushConversionDown (Unfold (expr))
        | TExpr.TypeConversion (e, t, k) as conv =>
          if (k is ConversionKind.Implicit && 
              t.TryUnify (e.Type)) {
            _ = t.Unify (e.Type);
            e
          } else {
            def e = Unfold (e);
            match (e) {
              | TExpr.DefValIn as d =>
                conv.expr = VoidIfNull (d.body);
                d.body = PushConversionDown (conv);
                e

              | TExpr.DefFunctionsIn as d =>
                conv.expr = VoidIfNull (d.body);
                d.body = PushConversionDown (conv);
                e

              | TExpr.Sequence as d =>
                conv.expr = VoidIfNull (d.e2);
                d.e2 = PushConversionDown (conv);
                e

              | _ => expr
            }
          }
        | _ => expr
      }
    }


    ConvertEventExpr (target : TExpr, source : TExpr) : TExpr
    {
      match (GetEventObj (target)) {
        | Some ((ev1, obj1, ty1)) =>
          match (Unfold (source)) {
            | TExpr.Call (meth, [p1, p2], _) 
              when IsOperator (meth) =>
              match (OperatorKind (meth)) {
                | BuiltinMethodKind.CallWithCast (meth)
                  when meth.Equals (InternalType.Delegate_Combine) ||
                       meth.Equals (InternalType.Delegate_Remove) =>
                  match (GetEventObj (p1.expr)) {
                    | Some ((ev2, obj2, _ty2))
                      when ev1.Equals (ev2) && TheSame (obj1, obj2) =>
                      def ev_meth =
                        if (meth.Equals (InternalType.Delegate_Combine))
                          ev1.GetAdder ()
                        else
                          ev2.GetRemover ();
                      assert (ev_meth != null);
                      ManagerClass.Instance.MarkAsUsed (ev_meth, source.Location);
                      def ev_meth_ref =
                        if (obj1 == null) {
                          def (ty, vars) = ty1.Fix ().TypeOfMethodWithTyparms (ev_meth);
                          TExpr.StaticRef (ty, ty1, ev_meth, vars)
                        } else {
                          def obj1 = Walk (obj1); 
                          def (ty, vars) = obj1.Type.Fix ().TypeOfMethodWithTyparms (ev_meth);
                          TExpr.MethodRef (ty, obj1, ev_meth, 
                                           vars, IsBaseRef (obj1));
                        }
                      p2.expr = Walk (p2.expr);
                      TExpr.Call (ev_meth_ref, [p2], false)
                    | _ => null
                  }
                | _ => null
              }
            | _ => null
          }
        | _ => null
      }
    }


    WalkPattern (pat : Pattern) : Pattern
    {
      pat.Walk (fun (_) {
        | Pattern.HasType (tc) =>
          when (pat.ty.TryRequire (tc) && messenger.NeedMessage)
            Message.Warning (pat.loc, "using the ``is'' pattern here is redundant, "
                                      "please use ``:''");
          null
        
        | Pattern.As (_, decl) =>
          unless (decl.IsRegistered)
            decl.Register ();
          null

        | _ => null
      })
    }


    FixupCurrentFunction () : void
    {
      foreach (parm in current_fun.parms)
        when (parm.ty.Fix () is MType.Void)
          Message.Error ($ "method `$(current_fun.name)' has void argument");

      def warned = Hashtable (50);
      
      def locals = List.Rev (current_fun.all_locals);
      current_fun.all_locals = null; // GC it

      unless (current_type.IsDelegate) {
        foreach (v in locals)
          when (!v.EverUsed && v.Name[0] != '_' && !warned.Contains (v)) {
            Message.Warning (168, v.loc, $ "$(v) was never used");
            Message.HintOnce (168, v.loc, "replace name with `_' or prefix it like"
                               " `_bar' to avoid the warning");
            warned.Set (v, null)
          }
        when (this_ptr_decl == null && current_fun : object == top_level_fun.GetHeader ())
          unless (top_level_fun.Attributes %&& (NemerleAttributes.Static |
                                                NemerleAttributes.Virtual | 
                                                NemerleAttributes.Override |
                                                NemerleAttributes.SpecialName ) ||
                  top_level_fun.MemberType == System.Reflection.MemberTypes.Constructor)
            Message.Warning (10006, $"`this' was never used, consider making `$top_level_fun' static");
      }

      // check for duplicate parameter names
      def loop (_ : list[Fun_parm]) {
        | x :: xs =>
          foreach (y in xs) 
            when (y.Name == x.Name) 
              Message.Error (y.Location, "duplicate parameter name: " + y.Name);
          loop (xs)

        | _ => () 
      }
      loop (current_fun.parms);

      // move closure vars of loops to their parent function
      foreach (v in locals)
        match (v.ValKind) {
          | LocalValue.Kind.Function (h, _) =>
            when (h.usage == FunctionUsage.UsedJustOnce ||
                  (inside_yielding_function && top_fun.id == current_fun.id))
              if (h.typarms is []) {
                current_fun.closure_vars += h.closure_vars;
                h.closure_vars = [];
              } else
                // we cannot yet deal with expanding these to loops
                h.usage = FunctionUsage.Used
          | _ => ()
        }

      foreach (v in locals) {
        // FIXME: this is wrong (performance problems) if we're inside
        // some real local function in yielding function
        mutable in_clo =
          inside_yielding_function && !v.NeverClosurise;

        v.UsedIn.Iter (fun (h : Fun_header) {
          unless (in_clo) {
            // check if all functions from h to current_fun are used_just_once
            def find_defining (header : Fun_header) {
              match (header.usage) {
                | _ when header.id == current_fun.id => {}
                | FunctionUsage.UsedJustOnce =>
                  find_defining (header.decl.DefinedIn)
                | _ =>
                  in_clo = true;
              }
            }
            find_defining (h)
          }
        });

        when (in_clo) {
          // check if we are not closuring some invalid things
          match (v.ValKind) {
            | LocalValue.Kind.FunParm (k) when k != ParmKind.Normal =>
              Message.Error (v.loc, $ "cannot store ref/out parameters in"
                                      " closures ($v)");
            | _ => ()
          }
          v.InClosure = true;
          v.DefinedIn.closure_vars ::= v;
        }
      }

      // Message.Debug ($ "$(current_fun.name): $(current_fun.usage) $(current_fun.has_1st_class_child) $(current_fun.closure_vars)");

      when (current_fun.has_1st_class_child && ! (current_fun.closure_vars is []))
        current_fun.cannot_inline = true;
    }


    PolyLocalToLambdaTransform (expr : TExpr.LocalFunRef) : TExpr
    {
      def (ret_type, parms_types) =
        match (expr.Type.Fix ()) {
          | MType.Fun (from, to) =>
            (to, from.Fix ().GetFunctionArguments ())
          | _ => assert (false)
        }
      def parms = 
        List.Map (parms_types, fun (ty) {
          Fun_parm (Util.tmpname ("fp"), 0, ty, Modifiers.Empty, ParmKind.Normal)
        });
      def lambda_header = 
        Fun_header (expr.loc, "_N_poly_local_lambda", ret_type, parms,
                    [], current_fun.tenv);
      def parms_refs =
        List.Map (parms, fun (fp : Fun_parm) {
          fp.decl =
            LocalValue (lambda_header, fp.name, fp.ty,
                        LocalValue.Kind.FunParm (ParmKind.Normal), 
                        is_mutable = false);
          def p = Parm (TExpr.LocalRef (fp.ty, fp.decl));
          p.required_type = fp.ty;
          p
        });
      def lambda_body =
        TExpr.Call (ret_type, expr, parms_refs, false);
      def parents = current_fun :: current_fun.GetParents ();
      def lambda_value =
        LocalValue (current_fun, lambda_header.name, expr.Type,
                    LocalValue.Kind.Function (lambda_header, parents),
                    is_mutable = false);
      lambda_header.body = FunBody.Typed (lambda_body);
      lambda_header.decl = lambda_value;

      def res =
        TExpr.DefFunctionsIn (expr.Type, [lambda_header], 
                              TExpr.LocalFunRef (expr.Type, lambda_value, []));

      Walk (res)
    }


    MethodToLambdaTransform (expr : TExpr, obj : TExpr, meth : IMethod, 
                             type_parms : list [TyVar], notvirt : bool) : TExpr
    {
      def obj_cache = 
        LocalValue (current_fun, "_N_obj_cache", obj.Type,
                    LocalValue.Kind.Plain (), is_mutable = false);
      def (ret_type, parms_types) =
        match (expr.Type.Fix ()) {
          | MType.Fun (from, to) =>
            (to, from.Fix ().GetFunctionArguments ())
          | _ => assert (false)
        }
      def parms = 
        List.Map (parms_types, fun (ty) {
          Fun_parm (Util.tmpname ("fp"), 0, ty, Modifiers.Empty, ParmKind.Normal)
        });
      def lambda_header = 
        Fun_header (obj.loc, "_N_method_lambda", ret_type, parms,
                    [], current_fun.tenv);
      def parms_refs =
        List.Map (parms, fun (fp : Fun_parm) {
          fp.decl =
            LocalValue (lambda_header, fp.name, fp.ty,
                        LocalValue.Kind.FunParm (ParmKind.Normal), 
                        is_mutable = false);
          Parm (TExpr.LocalRef (fp.ty, fp.decl))
        });
      def lambda_body =
        TExpr.Call (ret_type, 
           TExpr.MethodRef (expr.Type,
              TExpr.LocalRef (obj_cache.Type, obj_cache),
              meth, type_parms,
              notvirt), parms_refs, false);
      def parents = current_fun :: current_fun.GetParents ();
      def lambda_value =
        LocalValue (current_fun, lambda_header.name, expr.Type,
                    LocalValue.Kind.Function (lambda_header, parents),
                    is_mutable = false);
      lambda_header.body = FunBody.Typed (lambda_body);
      lambda_header.decl = lambda_value;

      def res =
        TExpr.DefFunctionsIn (expr.Type, [lambda_header], 
                              TExpr.LocalFunRef (expr.Type, lambda_value, []));
      def res = TExpr.DefValIn (expr.Type, obj_cache, obj, res);

      Walk (res)
    }


    VoidIfNull (expr : TExpr) : TExpr
    {
      if (expr == null)
        TExpr.Literal (InternalType.Void, Literal.Void ())
      else
        expr
    }


    IsBaseRef (expr : TExpr) : bool
    {
      match (Unfold (expr)) {
        | TExpr.This as ex => ! IsCurrentType (ex.Type)
          
        | TExpr.LocalRef (decl) as ex =>
          // assert (decl.ValKind != null);
          ! IsCurrentType (ex.Type) &&
          decl.ValKind is LocalValue.Kind.ClosurisedThisPointer
          
        | _ => false
      }
    }


    IgnoreExpr (expr : TExpr) : TExpr
    {
      def solver = Manager.Solver;
      solver.PushState ();
      def ok = expr.Type.Unify (InternalType.Void);
      solver.PopState ();
      if (ok) {
        def res = expr.Type.Unify (InternalType.Void);
        assert (res);
        expr
      } else {
        Message.Warning (10005, expr.Location, 
                         $ "ignored computed value of type $(expr.Type)");
        Message.HintOnce (10005, expr.Location, 
                          "use `_ = ...'; or -nowarn:10005 to avoid the warning");
        
        BuildEnforcement (expr, InternalType.Void);
      }
    }


    BuildEnforcement (expr : TExpr, target : MType) : TExpr
    {
      BuildConversion (expr, target, ConversionKind.UpCast ())
    }
    
    
    BuildConversion (expr : TExpr, target : TyVar, kind : ConversionKind) : TExpr
    {
      // Message.Debug ($ "bc: $expr -> $target ($kind)");

      assert (expr != null);

      def target = target.Fix ();
      def is_ignore = kind is ConversionKind.IgnoreValue;
      
      def kind =
        match (target) {
          | MType.Void when ! is_ignore => ConversionKind.IL (true)
          | _ => kind
        }

      if (kind is ConversionKind.Implicit && 
          target.TryUnify (expr.Type)) {
        _ = target.Unify (expr.Type);
        expr
      } else if (is_ignore) {
        IgnoreExpr (expr)
      } else
        match (kind) {
          | ConversionKind.MethodCall (sr) =>
            ManagerClass.Instance.MarkAsUsed (sr.mem, expr.Location);
            TExpr.Call (target, sr, [Parm (expr)], false)
          | ConversionKind.DownCast =>
            if (expr.Type.TryRequire (target)) {
              expr.Type.ForceRequire (target);
              Message.Warning (10001, $"there is no check needed to cast $(expr.Type) to $target");
              Message.HintOnce (10001, "consider using : instead of :>");
              BuildEnforcement (expr, target)
            } else
              TExpr.TypeConversion (target, expr, target, kind)
          | ConversionKind.Unspecified =>
            if (expr.Type.TryRequire (target)) {
              expr.Type.ForceRequire (target);
              BuildEnforcement (expr, target)
            } else
              TExpr.TypeConversion (target, expr, target, ConversionKind.DownCast ())
          | _ =>
            TExpr.TypeConversion (target, expr, target, kind)
        }
    }


    BuildBlockReturn (ctx : Context,
                      ty : TyVar, 
                      decl : LocalValue, 
                      parms : list [Parm]) : TExpr
    {
      def (result_decl, label) =
        match (decl.ValKind) {
          | LocalValue.Kind.BlockReturn (res, lab) => (res, lab)
          | _ => Util.ice ()
        }

      match (parms) {
        | [] =>
          result_decl.Type.ForceUnify (InternalType.Void);
          TExpr.Goto (ty, label, 1)
        | [parm] =>
          parm.expr.Type.ForceRequire (result_decl.Type);
          TExpr.Sequence (ty, 
                          TExpr.Assign (InternalType.Void,
                                        TExpr.LocalRef (result_decl),
                                        parm.expr),
                          Walk (ctx, TExpr.Goto (ty, label, 1)))
        | _ => Util.ice ()
      }
    }


    /* block (foo) {
         ...
         when (...) foo (33);
         ...
         77
       }

       is translated to:
       
       mutable result;
       result =
         {
           ...
           when (...) { result = 33; goto end; }
           ...
           77
         };
       end: result

       However the second part -- foo (33) --> result = 33; goto end; --
       is done in BuildBlockReturn, not here.
    */
    ExpandBlock (expr : TExpr.Block) : TExpr
    {
      if (! expr.jump_out.EverUsed)
        expr.body
      else {
        def expected = expr.Type;
        def result =
          LocalValue (current_fun, expr.jump_out.Name, 
                      expected, LocalValue.Kind.Plain (), 
                      is_mutable = true);
        result.NeverClosurise = true;
        def label_id = Util.next_id ();

        def ret =
          expr.jump_out.ValKind :> LocalValue.Kind.BlockReturn;
        ret.result_val = result;
        ret.block_label = label_id;
        
        def label = 
          TExpr.Label (expected, label_id, TExpr.LocalRef (expected, result));
        def assign = 
          TExpr.Assign (InternalType.Void, 
                        TExpr.LocalRef (result.Type, result),
                        expr.body);
        def seq = TExpr.Sequence (label.Type, assign, label);
        def deflt = TExpr.DefaultValue (result.Type);
        TExpr.DefValIn (expected, result, deflt, seq)
      }
    }

    
    
    static StripImplicitConversion (expr : TExpr) : TExpr
    {
      match (expr) {
        | TExpr.TypeConversion (e, _, ConversionKind.Implicit) => e
        | e => e
      }
    }


    DoWalk (ctx : Context, expr : TExpr) : TExpr
    {
      //Message.Debug ($ "dowalk: $expr $(ctx %&& Context.AllowGoto)");
      match (expr) {
        | TExpr.LocalFunRef (decl, _)
        | TExpr.LocalRef (decl) =>
          when (decl.ValKind is LocalValue.Kind.BlockReturn) {
            ReportError (messenger, 
                         $ "$decl was used as a first class value, "
                           "this is not supported");
            decl.Register ();
          }
          
          unless (decl.IsRegistered) {
            Message.Warning ($ "unregistered local $decl, $(decl.GetHashCode ())");
            assert (false);
          }
          decl.UseFrom (current_fun);

          match (decl.ValKind) {
            | LocalValue.Kind.Function (hd, _) =>
              if (ctx %&& Context.IsCalledValue) {
                match (hd.usage) {
                  | FunctionUsage.NotUsed =>
                    // we may set just-once flag only if referencing
                    // from the outer function
                    if (decl.DefinedIn.id == current_fun.id &&
                        (! hd.uses_try_block || ctx %&& Context.AllowTryAtFuncLev) &&
                        !hd.cannot_inline) {
                      //Message.Debug ($ "mark $(hd.name) just once");
                      hd.usage = FunctionUsage.UsedJustOnce
                    }
                    else {
                      //Message.Debug ($ "mark $(hd.name) used");
                      hd.usage = FunctionUsage.Used;
                    }
                  | FunctionUsage.UsedJustOnce =>
                    hd.usage = FunctionUsage.Used
                  | FunctionUsage.Used | FunctionUsage.UsedAsFirstClass => ()
                }
                null
              } else
                match (expr) {
                  | TExpr.LocalFunRef (_, []) =>
                    hd.usage = FunctionUsage.UsedAsFirstClass;
                    def mark (fn) {
                      fn.has_1st_class_child = true;
                      unless (fn.decl == null)
                        mark (fn.decl.DefinedIn)
                    }
                    mark (hd.decl.DefinedIn);
                    null
                  | TExpr.LocalFunRef as e =>
                    hd.usage = FunctionUsage.Used;
                    PolyLocalToLambdaTransform (e)
                  | _ => Util.ice ()
                }
            | _ => null
          }
          
          
        | TExpr.StaticRef (_, mem, _) =>
          match (mem) {
            | f is IField when ctx & Context.NeedLValue != 0 =>
              ManagerClass.Instance.MarkAsAssigned (f, expr.Location);

            | _ => ManagerClass.Instance.MarkAsUsed (mem, expr.Location);
          }
          null
          
          
        | TExpr.DefFunctionsIn (funs, body) =>
          foreach (fn in funs)
            fn.decl.Register ();
          foreach (fn in funs) {
            def last_fun = current_fun;
            current_fun = fn;
            foreach (parm in fn.parms)
              parm.decl.Register ();
            match (fn.body) {
              | FunBody.Typed (expr) =>
                fn.body = FunBody.Typed (Walk (Context.TopLevel, expr))
              | _ => assert (false)
            }
            FixupCurrentFunction ();
            current_fun = last_fun;
          }
          def body = Walk (ctx & ~Context.IsCalledValue, VoidIfNull (body));
          TExpr.DefFunctionsIn (body.Type, funs, body)

          
        | TExpr.ImplicitValueTypeCtor =>
          ManagerClass.Instance.MarkAsUsed ((expr.MType :> MType.Class).tycon, expr.Location);
          null
          

        | TExpr.FieldMember (obj, fld) =>
          if (ctx %&& Context.NeedLValue)
            ManagerClass.Instance.MarkAsAssigned (fld, expr.Location);
          else
            ManagerClass.Instance.MarkAsUsed (fld, expr.Location);
          TExpr.FieldMember (Walk (obj), fld)
          
          
        | TExpr.ConstantObjectRef (_, mem) =>
          ManagerClass.Instance.MarkAsUsed (mem, expr.Location);
          null
          
          
        | TExpr.PropertyMember (obj, prop) =>
          ManagerClass.Instance.MarkAsUsed (prop, expr.Location);
          def obj = Walk (obj);
          def meth =
            if (ctx %&& Context.NeedLValue) prop.GetSetter ()
            else prop.GetGetter ();
          when (meth == null) {
            assert (!(ctx %&& Context.NeedLValue), "should be rejected by Typer");
            ReportError (messenger, $ "the get accessor is unavailable for $prop");
          }

          unless (meth.CanAccess (current_type))
            Message.Error ($"property accessor $meth is inaccessible");
              
          // for setters the argument list is fixed later
          def ty = obj.Type.Fix ().TypeOfMember (meth);
          // Message.Debug ($ "prop $meth ty=$ty $obj $(IsBaseRef (obj))");
          def the_ref = TExpr.MethodRef (ty, obj, meth, [], IsBaseRef (obj));
          if (ctx %&& Context.IsIndexerRef)
            the_ref
          else if (prop.IsIndexer) {
            ReportError (messenger, $ "$prop was used as a first class value");
            the_ref
          } else
            TExpr.Call (the_ref, [], false)

        
        | TExpr.StaticPropertyRef (from, prop) =>
          ManagerClass.Instance.MarkAsUsed (prop, expr.Location);
          def meth =
            if (ctx %&& Context.NeedLValue) prop.GetSetter ()
            else prop.GetGetter ();
          assert (meth != null);
          def the_ref = TExpr.StaticRef (from.TypeOfMember (meth), from, meth, []); 
          if (ctx %&& Context.IsIndexerRef)
            the_ref
          else if (prop.IsIndexer) {
            ReportError (messenger, $ "$prop was used as a first class value");
            the_ref
          } else
            TExpr.Call (the_ref, [], false)
          
        
        | TExpr.EventMember (obj, ev) =>
          ManagerClass.Instance.MarkAsUsed (ev, expr.Location);
          def obj = Walk (obj);
          
          mutable field = null;
          when (ev.DeclaringType.Equals (current_type)) {
            field = (ev :> EventBuilder).storage_field;
          }
          if (field != null)
            TExpr.FieldMember (obj, field);
          else {
            ReportError (messenger, $ "$(ev) can only appear on the left-side of a += or -=");
            TExpr.Error ()
          }
          
        | TExpr.StaticEventRef (from, ev) =>
          ManagerClass.Instance.MarkAsUsed (ev, expr.Location);

          mutable field = null;
          when (ev.DeclaringType.Equals (current_type)) {
            field = (ev :> EventBuilder).storage_field;
          }
          if (field != null)
            TExpr.StaticRef (from, field, [])
          else {
            ReportError (messenger, $ "$(ev) can only appear on the left-side of a += or -=");
            TExpr.Error ()
          }

        | TExpr.MethodRef (obj, meth, type_parms, notvirt) =>
          ManagerClass.Instance.MarkAsUsed (meth, expr.Location);
          def notvirt = notvirt || IsBaseRef (obj);

          if (ctx %&& (Context.IsCalledValue | Context.IsDelegeteCtorParm))
            TExpr.MethodRef (Walk (obj), meth, type_parms, notvirt)
          else
            MethodToLambdaTransform (expr, obj, meth, type_parms, notvirt)
          

        | TExpr.Call (func, parms, false) =>
          match (Unfold (func)) {
            | TExpr.StaticRef (_, meth is IMethod, _) 
              when meth.DeclaringType.IsDelegate &&
                   meth.GetFunKind () is FunKind.Constructor =>
              match (parms) {
                | [parm] =>
                  parm.expr = Walk (Context.IsDelegeteCtorParm, parm.expr)
                | _ => Util.ice ()
              }

            | TExpr.MethodRef (_, IMethod where (BuiltinKind = ExtensionMethod), _, _) =>
              {}
              
            | unfold =>
              match (parms) {
                | p :: ps =>
                  mutable check_ps = parms;
                  when (unfold is TExpr.StaticRef) {
                    p.expr = Walk (ctx & Context.AllowTry, p.expr);
                    check_ps = ps;
                  }
                  foreach (p in check_ps)
                    p.expr = Walk (p.expr);

                | [] => ()
              }
          }

          if (IsOperator (func))
            match (OperatorKind (func)) {
              | BuiltinMethodKind.CallWithCast (meth') =>
                assert (meth' != null);
                // XXX possibly wrong type
                def (ty, vars) = meth'.GetFreshType ();
                BuildConversion (
                  TExpr.Call (meth'.ReturnType, 
                              TExpr.StaticRef (ty, 
                                               meth'.DeclaringType.GetMemType (), 
                                               meth', vars), parms, false),
                  expr.Type.Fix (), ConversionKind.Unspecified ())
              
              | _ => assert (false)
            }
          else
            match (Unfold (func)) {
              | TExpr.PropertyMember (_, prop) when prop.IsIndexer
              | TExpr.StaticPropertyRef (_, prop) when prop.IsIndexer => 
                def ctx =
                  Context.IsCalledValue %| 
                  Context.IsIndexerRef  %|
                  (ctx & Context.NeedLValue);
                TExpr.Call (Walk (ctx, func), parms, false)
              | TExpr.ConstantObjectRef (from, mem) =>
                TExpr.StaticRef (from, mem, []) // skip the call
              | TExpr.ImplicitValueTypeCtor as ivtc =>
                ivtc.ty = expr.ty;
                ivtc

              | TExpr.MethodRef (obj, IMethod where (BuiltinKind = ExtensionMethod (impl)) as im, type_parms, _) as func =>
                //Message.Debug ($"expand to $impl");
                def from = impl.DeclaringType.GetMemType ();
                def fnt = {
                  def (parms, ret) = func.MType.FunReturnTypeAndParms ().Value;
                  MType.ConstructFunctionType (obj.Type :: parms, ret)
                }
                def type_parms =
                  (match (obj.Type.Fix ().GetInstantiatedSuperType (im.DeclaringType)) {
                    | MType.Class (_, parms) => parms
                    | _ => Util.ice ()
                  }) + type_parms;
                def fn = TExpr.StaticRef (fnt, from, impl, type_parms);
                Walk (Context.IsCalledValue,
                      TExpr.Call (expr.Type, fn, Parm (obj) :: parms, false))

              | TExpr.LocalRef (LocalValue where (
                  ValKind = LocalValue.Kind.BlockReturn) as decl) =>
                BuildBlockReturn (ctx, expr.Type, decl, parms)

              | TExpr.OpCode ("==.ref") with eq = true
              | TExpr.OpCode ("!=.ref") with eq = false =>
                match (parms) {
                  | [p1, p2] =>
                    def e1 = StripImplicitConversion (p1.expr);
                    def e2 = StripImplicitConversion (p2.expr);

                    def t1 = e1.Type.Fix ();
                    def t2 = e2.Type.Fix ();
                    
                    //Message.Debug ($"$t1 $t2 with $eq");
                    
                    match ((t1, t2)) {
                      // nullable types need special handling in comparisons
                      | (MType.Class (tc, _), _) when tc.Equals (InternalType.Generic_Nullable_tc) 
                      | (_, MType.Class (tc, _)) when tc.Equals (InternalType.Generic_Nullable_tc) => 
                        match ((e1, e2)) {
                          | (TExpr.Literal (Literal.Null), e) 
                          | (e, TExpr.Literal (Literal.Null)) =>
                            def hasval = TExpr.Call (expr.Type, TExpr.MethodRef (e, 
                              InternalType.Generic_Nullable_tc.LookupMember ("get_HasValue").Head :> IMethod, [], false), [], false);
                            if (eq)
                              TExpr.Call (expr.Type, TExpr.OpCode ("bool.!"), [Parm (hasval)], false)
                            else
                              hasval
                          
                          | _ => 
                            ReportError (messenger, 
                                         $ "Comparison of two nullable instances is not yet supported.");
                            Message.HintOnce ("You can compare only with null or use Equals method.");
                            TExpr.Call (Unfold (func), parms, false)
                        }
                      
                      | _ =>
                        def prob =
                          if (t1.IsSystemObject && !t2.CanBeNull) t2
                          else if (t2.IsSystemObject && !t1.CanBeNull) t1
                          else null;
    
                        if (prob != null)
                          ReportError (messenger, 
                                       $ "comparing a value type $prob to "
                                         "System.Object (a `null' literal?) "
                                         "with reference equality");
                        else if (!t1.IsSystemObject && !t2.IsSystemObject) {
                          ReportError (messenger, 
                                       $ "comparing values of types $t1 and $t2 "
                                         "with reference equality");
                          Message.HintOnce ("upcast one of the values to object if "
                                            "this is desired");
                        } else {}
    
                        TExpr.Call (Unfold (func), parms, false)
                    }
                    
                  | _ => assert (false)
                }

              | _ =>
                if ((ctx %&& Context.IsTail) && IsSelfCall (func))
                  TExpr.SelfTailCall (parms)
                else {
                  def ctx =
                    if (ctx %&& Context.AllowTry)
                      Context.AllowTryAtFuncLev | Context.IsCalledValue
                    else Context.IsCalledValue;
                  TExpr.Call (Walk (ctx, func), parms, false)
                }
            }
              
        
        | TExpr.Call
        | TExpr.SelfTailCall => assert (false)
        

        | TExpr.Assign (target, source) =>
          def event_expr = ConvertEventExpr (target, source);
          if (event_expr != null)
            event_expr
          else {
            def transform_call =
              match (Unfold (target)) {
                | TExpr.PropertyMember
                | TExpr.StaticPropertyRef
                | TExpr.Call => true
                | _ => false
              }

            def target = Walk (Context.NeedLValue, target);
            def src_ctx =
              if (target is TExpr.LocalRef) ctx & Context.AllowGotoAndSuch
              else Context.Clean;
            def source = Walk (src_ctx, source);

            match (target) {
              | TExpr.Call as t when transform_call =>
                t.parms += [Parm (source)];
                t.ty = InternalType.Void;
                t
                
              | _ when transform_call => assert (false)
              | _ =>
                TExpr.Assign (target, source)
            }
          }
          
   
        | TExpr.DefValIn (name, val, body) =>
          name.Register ();
          // goto is allowed inside value definition, because
          // we do the store at the end anyway
          def val = Walk (ctx & Context.AllowGotoAndSuch, val);
          def body = Walk (ctx, VoidIfNull (body));
          TExpr.DefValIn (name, val, body)
          
          
        | TExpr.Match (matched_value, cases) =>
          def cast_to = expr.Type.Fix ();
          foreach (case in cases) {
            mutable pats = [];
            foreach ((pat, expr, assigns) in case.patterns) {
              def pat = WalkPattern (pat);
              def assigns = assigns.Map (fun (decl, val) {
                unless (decl.IsRegistered)
                  decl.Register ();
                (decl, Walk (val))
              });
              pats = (pat, Walk (expr), assigns) :: pats;
            }
            case.patterns = List.Rev (pats);
            case.body = 
              BuildEnforcement (Walk (ctx, VoidIfNull (case.body)), cast_to);
          }
          // We allow try here because matched value is pushed on the 
          // stack first so it is clean (if it was).
          def matched = Walk (ctx & Context.AllowTry, matched_value);
          TExpr.Match (matched, cases)
          

        | TExpr.Throw (exn) =>
          // exception can be null for `throw;' rethrow expression
          if (exn != null)
            TExpr.Throw (Walk (exn))
          else
            expr

        | TExpr.TryFinally (body, handler) =>
          unless (ctx %&& Context.AllowTry)
            ReportError (messenger, 
                         "try block is not allowed inside expressions");
          
          current_fun.uses_try_block = true;
          
          TExpr.TryFinally (Walk (Context.AllowGotoAndSuch, body), 
                            IgnoreExpr (Walk (Context.AllowTry, handler)))

        | TExpr.Try (body, cases) =>
          unless (ctx %&& Context.AllowTry)
            ReportError (messenger, 
                         "try block is not allowed inside expressions");
          def register_case(case) {
            | Try_case.Catch (exn, _)
            | Try_case.Filter (exn, _, _) =>
              exn.Register ();
            | Try_case.Fault => ()
          }
          foreach (case in cases)
            register_case (case);
          current_fun.uses_try_block = true;

          def walk_case(case) {
            | Try_case.Catch (exn, handler) =>
              Try_case.Catch (exn, Walk (Context.AllowGotoAndSuch, handler))
            | Try_case.Filter (exn, filter, handler) =>
              Try_case.Filter (exn, Walk (Context.AllowGotoAndSuch, filter),
                               Walk (Context.AllowGotoAndSuch, handler))
            | Try_case.Fault (handler) =>
              Try_case.Fault (Walk (Context.AllowGotoAndSuch, handler))
          }
          TExpr.Try (Walk (Context.AllowGotoAndSuch, body), cases.Map (walk_case))

        | TExpr.Literal (Literal.Integer as i) =>
          def t = expr.Type.Fix ();
          unless (i.treat_as.Equals (t)) {
            if (Typer.LiteralConversionPossible (i, t))
              i.treat_as = t :> MType.Class;
            else {
              Message.Warning ($ "literal type $(i.treat_as), "
                          "expression type $t, literal is $i");
              assert (false);
            }
          }
          null


        | TExpr.Literal => null
   
        
        | TExpr.This =>
          when (this_ptr_decl == null) {
            this_ptr_decl = 
              LocalValue (
                top_level_fun.GetHeader (), 
                "_N_closurised_this_ptr",
                // cannot use expr.Type, because this can be base
                current_type.GetMemType (), 
                LocalValue.Kind.ClosurisedThisPointer (),
                is_mutable = false);
            this_ptr_decl.Register ();
          }
          this_ptr_decl.UseFrom (current_fun);
          TExpr.LocalRef (this_ptr_decl);
          
          
        | TExpr.Base (meth) =>
          ManagerClass.Instance.MarkAsUsed (meth, expr.Location);
          null
          

        | TExpr.TypeConversion (expr, t, ConversionKind.UpCast)
          when t.Equals (InternalType.Void) && expr.Type.TryUnify (InternalType.Void)
        | TExpr.TypeConversion (expr, _, ConversionKind.IgnoreValue)
          when expr.Type.TryUnify (InternalType.Void) =>
          _ = expr.Type.Unify (InternalType.Void);
          Walk (ctx, expr)
        
        | TExpr.TypeConversion (expr, t, kind) =>
          BuildConversion (Walk (expr), t, kind)
          
          
        | TExpr.Sequence (e1, e2) =>
          def e1 = IgnoreExpr (Walk (ctx & Context.AllowGotoAndSuch, e1));
          TExpr.Sequence (e1, Walk (ctx & ~Context.IsCalledValue, e2))

          
        | TExpr.Tuple (args) =>
          TExpr.Tuple (Walks (args))


        | TExpr.TupleIndexer (obj, k, n) =>
          TExpr.TupleIndexer (Walk (obj), k, n)
          
          
        | TExpr.Array (args, dimensions) =>
          TExpr.Array (Walks (args), Walks (dimensions))
          
          
        | TExpr.TypeOf => null
          
          
        | TExpr.ArrayIndexer (obj, args) =>
          TExpr.ArrayIndexer (Walk (obj), Walks (args))
          
        
        | TExpr.OpCode => null
        
        | TExpr.Delayed => Walk (ctx, Unfold (expr))

        | TExpr.Error => null
          

        | TExpr.Goto =>
          unless (ctx %&& Context.AllowGoto)
            ReportError (messenger, "goto (block return?) is not allowed "
                                    "inside expressions");
          null
          
          
        | TExpr.Label (lab, body) =>
          TExpr.Label (lab, Walk (ctx, body))


        | TExpr.Block as b =>
          Walk (ctx, ExpandBlock (b))


        | TExpr.If (cond, e1, e2) =>
          TExpr.If (Walk (cond), Walk (ctx, e1), Walk (ctx, e2))


        | TExpr.HasType (e, t) =>
          TExpr.HasType (Walk (e), t)
          
        
        | TExpr.DefaultValue => null

        | TExpr.Switch
        | TExpr.MultipleAssign
        | TExpr.MethodAddress => assert (false)
      }
    }
  }
}
