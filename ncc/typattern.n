(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Typattern {
  
  variant Range {
    | R_omega        // _, x, everything
    | R_none         // nothing
    | R_any_except { lits : list (Literal); }
    | R_literal { l : Literal; }
    | R_variant_option { ti : Tyinfo; range : Range; }
    | R_tuple { ranges : list (Range); }
    | R_record { ranges : list (M_field * Range); }
    
    | R_or { ranges : list (Range); }
  }

  range_of_pattern (p : Pattern) : Range {
    match (p) {
      | P_underscore => R_omega ()
      | P_as (p, _) => range_of_pattern (p)
      | P_tuple (args) => R_tuple (List.map (range_of_pattern, args))
      | P_record (args) =>
        def f (n : Named_pattern) : M_field * Range {
          (n.name, range_of_pattern (n.pat))
        };
        R_record (List.map (f, args))
      | P_cons (ti, pat) =>
        R_variant_option (ti, range_of_pattern (pat))
      | P_literal (l) => R_literal (l)
    }
  }

  // debug routine
  string_of_range (r : Range) : string {
    match (r) {
      | R_omega => "_"
      | R_any_except ([L_bool (true)]) => "false"
      | R_any_except ([L_bool (false)]) => "true"
      | R_any_except (_) => "X" // FIXME
      | R_variant_option (ti, r) =>
        ti.fullname () + " (" + string_of_range (r) + ")"
      | R_tuple (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") string_of_range (r)
          else
            acc + ", " + string_of_range (r)
        };
        "(" + List.fold_left (concat, "", ranges) + ")"
        
      | R_record (ranges) =>
        def concat (acc : string, x : M_field * Range) : string {
          def (f, r) = x;
          def r' = f.name + " = " + string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.fold_left (concat, "", ranges) + " }"
        
      | R_none => "[[None]]"
      | R_literal => "[[Literal]]"
      
      | R_or (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") string_of_range (r)
          else
            acc + " | " + string_of_range (r)
        };
        "[ " + List.fold_left (concat, "", ranges) + " ]"
    }
  }

  // for user error messages, we just present first branch of R_or
  user_string_of_range (r : Range) : string {
    match (r) {
      | R_omega => "_"
      | R_any_except ([L_bool (true)]) => "false"
      | R_any_except ([L_bool (false)]) => "true"
      | R_any_except (_) => "X" // FIXME
      | R_variant_option (ti, r) =>
        ti.fullname () + " (" + user_string_of_range (r) + ")"
      | R_tuple (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") user_string_of_range (r)
          else
            acc + ", " + user_string_of_range (r)
        };
        "(" + List.fold_left (concat, "", ranges) + ")"
        
      | R_record (ranges) =>
        def concat (acc : string, x : M_field * Range) : string {
          def (f, r) = x;
          def r' = f.name + " = " + user_string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.fold_left (concat, "", ranges) + " }"
        
      | R_none => Util.ice ()
      | R_literal => Util.ice ()
      | R_or ([]) => Util.ice ()
      
      | R_or (x :: _) => user_string_of_range (x)
    }
  }

  simplify_range (r : Range) : Range {
  //  Message.debug ("simpl: " + string_of_range (r) );
    def aint_none (r : Range) : bool {
      match (r) {
        | R_none => false
        | _ => true
      }
    };
    match (r) {
      | R_or ([]) => R_none ()
      | R_or (lst) =>
        match (List.filter (aint_none, lst)) {
          | [] => R_none ()
          | [x] => x
          | l => R_or (l)
        }
      | R_any_except ([L_bool (true); L_bool (false)]) => R_none ()
      | R_any_except ([L_bool (false); L_bool (true)]) => R_none ()
      | R_variant_option (_, R_none) => R_none ()
      | R_tuple (ranges) =>
        if (List.forall (aint_none, ranges)) 
          r
        else
          R_none ()
      | R_record (ranges) =>
        def is_named_none (x : M_field * Range) : bool {
          match (x) {
            | (_, R_none) => true
            | _ => false
          }
        };
        if (List.exists (is_named_none, ranges))
          R_none ()
        else
          r
      | x => x 
    }
  }
    
  subtract (r1 : Range, r2 : Range) : bool * Range {
    mutable did_something <- false;

    // subtract new_r from cur_r
    def do_sub (cur_r : Range, new_r : Range) : Range {
//    Message.debug ("subx: " + string_of_range (cur_r) + "     " + string_of_range (new_r) );
      match ((cur_r, new_r)) {
        | (R_none, _) => R_none ()
        
        | (_, R_omega) => 
          did_something <- true; 
          R_none ()
          
        | (R_omega, R_literal (l)) =>
          did_something <- true;
          R_any_except ([l])

        | (R_or (ranges), _) =>
          R_or (List.map (fun (r : Range) : Range { sub (r, new_r) }, ranges))

        | (R_any_except (lits), R_literal (l)) =>
          // FIXME: check if l is in lits
          did_something <- true;
          R_any_except (l :: lits)

        | (R_any_except, _) => Util.ice ()

        | (R_variant_option (ti1, r1), R_variant_option (ti2, r2)) =>
          if (ti1.id == ti2.id)
            R_variant_option (ti1, sub (r1, r2))
          else
            cur_r
          
        | (cur, R_variant_option (ti, r)) =>
          def is_variant_option (ti : Tyinfo) : bool {
            match (ti.tydecl) {
              | TD_variant_option => true
              | _ => false
            }
          };
          def make_range (ti : Tyinfo) : Range {
            R_variant_option (ti, cur)
          };
          def types_in_parent = (ti.enclosing_tyinfo ()).contained_types;
          def variants = List.filter (is_variant_option, types_in_parent);
          sub (R_or (List.map (make_range, variants)), new_r)

        | (R_variant_option, R_record) => Util.ice ("FIXME")
       
        | (R_omega, R_tuple (ranges)) =>
          def args = List.map (fun (_ : Range) : Range { R_omega () }, ranges);
          sub (R_tuple (args), new_r)
          
        | (R_tuple (r1), R_tuple (r2)) =>
          mutable did <- true;
          def make_sub (r1 : Range, r2 : Range) : Range {
            def (d, r) = subtract (r1, r2);
            if (d) () else did <- false;
            r
          };
          def results = List.map2 (make_sub, r1, r2);
          if (did) {
            did_something <- true;

            mutable output <- [];
            // r1 - r2 = r3
            def dosub (pref : list (Range), 
                       cur : list (Range), 
                       after_sub : list (Range)) : void {
              match ((cur, after_sub)) {
                | (x :: xs, y :: ys) => 
                  def args = List.rev_append (pref, (y :: xs));
                  output <- simplify_range (R_tuple (args)) :: output;
                  dosub (x :: pref, xs, ys)
                | ([], []) => ()
                | _ => Util.ice ()
              }
            };
            dosub ([], r1, results);
            R_or (output)
          } else cur_r
        
        | (R_omega, R_record) =>
          sub (R_record ([]), new_r)

        | (R_record (r1), R_record (r2)) =>
//          Message.debug ("ransub: " + string_of_range (cur_r) + "   " + string_of_range (new_r));
          mutable all_did <- true;

          def loop (acc : list (Range), r2 : M_field * Range) : list (Range) {
            def (name, range) = r2;
            
            def loop2 (acc : list (M_field * Range), l : list (M_field * Range)) : list (M_field * Range) {
              match (l) {
                | (f, r) :: xs =>
                  if (name.id == f.id) {
                    def (did, res) = subtract (r, range);
                    if (did) () else all_did <- false;
                    List.rev_append (xs, (f, res) :: acc)
                  } else
                    loop2 ((f, r) :: acc, xs)
                | [] =>
                  (name, sub (R_omega (), range)) :: acc
              }
            };

            simplify_range (R_record (loop2 ([], r1))) :: acc
          };

          def r = R_or (List.fold_left (loop, [], r2));

          if (all_did) {
            did_something <- true;
            r
          } else cur_r

        | (R_variant_option, R_tuple) => Util.ice ()
        | (R_variant_option, R_literal) => Util.ice ()
        | (R_tuple, R_literal) => Util.ice ()
        | (R_record, R_literal) => Util.ice ()
        | (R_record, R_tuple) => Util.ice ()
        | (R_tuple, R_record) => Util.ice ()
        | (R_literal, _) => Util.ice ()
        | (_, R_any_except) => Util.ice ()
        | (_, R_or) => Util.ice ()
        | (_, R_none) => Util.ice ()
      }
    }

    and sub (r1 : Range, r2 : Range) : Range {
      simplify_range (do_sub (r1, r2))
    };

    def ret = sub (r1, r2);
//    Message.debug ("sub: " + string_of_range (r1) + " - " + string_of_range (r2) + " = " + string_of_range (ret));

    (did_something, ret)
  }

  (** Give warnings about ``pattern matching not exhaustive'' and 
      ``unused match clause''. *)
  public check_matching (cases : list (Match_case)) : void {
    def loop (acc : Range, m : Match_case) : Range {
      def loop2 (acc : Range, patex : Pattern * Expr) : Range {
        def (pat, ex) = patex;
        def (did_something, ret) = subtract (acc, range_of_pattern (pat));
        if (did_something)
          ()
        else
          Message.warning (pat.loc, "this match clause is unused");
        match (ex) {
          | E_literal (L_bool (true)) => ret
          | _ => acc
        }
      };
      List.fold_left (loop2, acc, m.patterns)
    };
    def remaining = List.fold_left (loop, R_omega (), cases);
    match (remaining) {
      | R_none => ()
      | r =>
        Message.warning ("this matching is not exhaustive, example unmatched value:");
        Message.warning (user_string_of_range (r))
    }
  }

  public ty_patterns (ctx : Tyexpr.CTX, 
                      matched_value_type : Type, 
                      patterns : list (PT.Pattern * option (PT.Expr))) 
                    : list (Pattern * Expr) * Env {
                    
    def mkcons (p1 : PT.Pattern, p2 : PT.Pattern) : PT.Pattern {
      def tup = PT.P_tuple ([p1; p2]);
      def ret = PT.P_cons (PT.SS_string ("Cons"), tup);
      tup.loc <- p1.loc;
      ret.loc <- p1.loc;
      ret
    };

    def mknil (loc : Location) : PT.Pattern {
      def tup = PT.P_underscore ();
      def ret = PT.P_cons (PT.SS_string ("Nil"), tup);
      tup.loc <- loc;
      ret.loc <- loc;
      ret
    };

    mutable pat_env <- ctx.env;
    mutable vars <- Map.string_map ();
    mutable common_vars <- None ();
    
    def do_walk (t : Type, p : PT.Pattern) : Pattern {
      match (p) {
        | PT.P_variable (n) =>
          if (n == "true")
            walk (t, PT.P_literal (L_bool (true)))
          else if (n == "false")
            walk (t, PT.P_literal (L_bool (false)))
          else 
            walk (t, PT.P_as (PT.P_underscore (), PT.SS_string (n)))

        | PT.P_as (pat, PT.SS_string (n)) =>
          def pat' = walk (t, pat);
          def t' =
            match (pat') {
              | P_cons (ti, _) =>
                def t' = ti.fresh_generic_type ();
                if (t' >> t) t'
                else Util.ice ()
              | _ => t
            };
          if (vars.mem (n))
            Message.error ("pattern variable `" + n + "' already seen in this pattern")
          else ();
          def (env', decl) =
            match (common_vars) {
              | None =>
                pat_env.add_local (n, D_pattern_variable (), t');
              | Some (cv) =>
                match ((cv : String_map (Decl)).find (n)) {
                  | Some (d) => 
                    if (t' >> d.ty) ()
                    else {
                      Message.error ("pattern variable `" + d.name + "' used to have type " +
                                     d.ty.as_string () + " but now it has type " + t'.as_string ());
                      Message.hint ("rename variable if they have no connection")
                    };
                    (pat_env.add_local (d), d)
                  | None => pat_env.add_local (n, D_pattern_variable (), t');
                }
            };
          vars <- vars.add (n, decl);
          pat_env <- env';
          P_as (pat', decl)
          
        | PT.P_as (_, _) =>
          Message.fatal_error ("$ operator used outside of quotation <[ ... ]> context")

        | PT.P_underscore => P_underscore ()

        | PT.P_list (lst) =>
          def mklst (lst : list (PT.Pattern)) : PT.Pattern {
            match (lst) {
              | x :: xs => mkcons (x, mklst (xs))
              | [] => mknil (p.loc)
            }
          };
          walk (t, mklst (lst))
          
        | PT.P_list_cons (p1, p2) =>
          walk (t, mkcons (p1, p2))
          
        | PT.P_literal (lit) =>
          def t' = Tyexpr.ty_literal (ctx, lit);
          match (Tyutil.unify (t, t', false)) {
            | Some (s) => 
              Tyvar.global_store (s);
              P_literal (lit)
            | None =>
              Message.fatal_error ("literal has type " + t'.as_string () + 
                                   " while matched value has type " + t.as_string ())
          }

        | PT.P_tuple (pats) =>
          match (Tyutil.top_expand (t)) {
            | T_app (ti, args) =>
              def collect_fields (acc : list (string), m : Class_member) : list (string) {
                match (m) {
                  | M_field => m.name :: acc
                  | _ => acc
                }
              };
              def names = List.rev (List.fold_left (collect_fields, [], ti.member_list));
              match (names) {
                | _ :: _ =>
                  if (List.length (names) == List.length (pats)) {
                    def mk (n : string, p : PT.Pattern) : string * PT.Pattern {
                      (n, p)
                    };
                    walk (t, PT.P_record (List.map2 (mk, names, pats)))
                  } else
                    Message.fatal_error ("pattern matches " + 
                                         string_of_int (List.length (pats)) + 
                                         " values, while type " + 
                                         ti.fullname () + " has " +
                                         string_of_int (List.length (names)) + 
                                         " fields")
                | [] =>
                    Message.fatal_error ("pattern matches " + string_of_int (List.length (pats)) + 
                                         " values, while type " + ti.fullname () + " has no fields")
              }
              
            | T_prod (ts) =>
              if (List.length (ts) == List.length (pats))
                P_tuple (List.map2 (walk, ts, pats))
              else
                Message.fatal_error ("pattern matches " + 
                                     string_of_int (List.length (pats)) + 
                                     "-tuples, while " + 
                                     string_of_int (List.length (ts)) + 
                                     "-tuple is required")
            | vart =>
              def free_vars (acc, n) {
                if (n <= 0) acc
                else free_vars (Tyvar.free_variable () :: acc, n - 1)
              };
              def ts = free_vars ([], List.length (pats));
              if (vart >> T_prod (ts))
                P_tuple (List.map2 (walk, ts, pats))
              else
                Message.fatal_error ("pattern matches " + string_of_int (List.length (pats)) + 
                                     "-tuples, not values of type " + t.as_string ())
          }
          
        | PT.P_record (l) =>
          def fn (np : string * PT.Pattern) : Named_pattern {
            // just a placeholder with correct type
            def bogus_expr = E_type_enforcement (null, t);
            def loc = Location_stack.top ();
            bogus_expr.loc <- loc;
            bogus_expr.expr_ty <- t;
            def (name, pat) = np;
            def fr = Tyexpr.lookup_field (loc, bogus_expr, name);
            Named_pattern (fr.fld, walk (Tyexpr.type_of (fr), pat))
          };
          P_record (List.map (fn, l))
          
        | PT.P_cons (PT.SS_string (n), p) =>
          if (Util.is_capitalized (n)) {
            def ti = pat_env.lookup_type (n);
            match (ti.tydecl) {
              | TD_variant_option =>
                def parent_type = (ti.enclosing_tyinfo ()).fresh_generic_type ();
                def option_type = ti.fresh_generic_type ();
                if (option_type >> parent_type) () else Util.ice ();
                // we use parent_type for subtyping in case matched value
                // has yet undefined type
                if (parent_type >> t)
                  // but option_type inside subpattern
                  P_cons (ti, walk (option_type, p))
                else
                  Message.fatal_error ("variant option " + option_type.as_string () + 
                                       " doesn't subtype " + t.as_string ())
              | _ =>
                Message.error ("`" + n + "' isn't variant case");
                P_underscore ()
            }
          } else
            match (p) {
              | PT.P_underscore => walk (t, PT.P_variable (n))
              | _ =>
                Message.fatal_error ("`" + n + "' cannot be variant option, " +
                                     "since it starts with lowercase letter")
            }

        | PT.P_cons (_, _) =>
          Message.fatal_error ("$ operator may appear only within <[ ... ]> quotation")

        | PT.P_quoted (parse_element) =>
          // we use Macros functions to translate quoted element
          def lifted = 
            match (parse_element) {
              | PT.ParseExpr (e) => Macros.quoted_expr (e)
              | PT.ParseType (e) => Macros.quoted_type (e)
              | PT.ParsePattern (e) => Macros.quoted_pattern (e)
              | PT.ParseParam (e) => Macros.quoted_param (e)
              | PT.ParseCase (e) => Macros.quoted_case (e)
            };
          walk (t, Macros.expr_to_pattern (lifted))

	| PT.P_spliced =>
          Message.fatal_error ("$ operator may appear only within <[ ... ]> quotation")

	| PT.P_spliced_literal  =>
          Message.fatal_error ("$ operator may appear only within <[ ... ]> quotation")

	| PT.P_patt_list =>
          Message.fatal_error (".. arguments list may appear only within <[ ... ]> quotation")
      }
    }
    and walk (t : Type, p : PT.Pattern) : Pattern {
      def r = Util.locate (p.loc, fun () : Pattern { do_walk (t, p) });
      r.loc <- p.loc;
      r.ty <- t; 
      r
    };


    def ty_pats (acc : list (Pattern * Expr),
                 patterns : list (PT.Pattern * option (PT.Expr))) 
               : list (Pattern * Expr) * Env {
      match (patterns) {
        | (pat, expr) :: rest =>
          pat_env <- ctx.env;
          vars <- Map.string_map ();
          def typed_pattern = walk (matched_value_type, pat);
          
          def filter (m : String_map (Decl), n : string, d : Decl) : String_map (Decl) {
            if (vars.mem (n))
              m.add (n, d)
            else
              m
          };
          
          common_vars <-
            match (common_vars) {
              | None => Some (vars)
              | Some (x) => Some (x.fold (filter, Map.string_map ()))
            };

          def expr =
            match (expr) {
              | None => 
                def ex = E_literal (L_bool (true));
                ex.loc <- Location_stack.top ();
                ex
              | Some (x) => 
                def ex = Tyexpr.ty_expr (ctx.with_env (pat_env), x);
                def bool_ty = Tyutil.make_tapp ("Nemerle.Core.Aliases.bool");
                Tyexpr.expect_type ("when guard", ex, bool_ty);
                ex
            };

          ty_pats ((typed_pattern, expr) :: acc, rest)
          
        | [] =>
          def addvar (env : Env, _ : string, d : Decl) : Env { 
            d.is_pattern_outcome <- true; 
            env.add_local (d)
          };
          (List.rev (acc), (Option.unsome (common_vars)).fold (addvar, ctx.env))
      }
      
    };

    ty_pats ([], patterns)
  }
  

}
}
