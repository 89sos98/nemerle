using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace LRPEGCC
{
  partial internal class RuleCompiler
  {
    _typer    : Typer;
    _isDebug  : bool;
    
    public this(typer : Typer)
    {
      _typer    = typer;
      _isDebug  = _typer.Manager.Options.IsConstantDefined("DEBUG");
    }
    
    public CompileRule(ruleToCompile : Rule) : PExpr
    {
      mutable recursionLevel = 0;
      def tokenVars : SCG.List[PExpr] = SCG.List();
      mutable subruleNestingLevel = -1;
      mutable nestingLevel = -1;
      def makeVarRef(rule : Rule) : PExpr.Ref
      {
        def varName = $"token_L$(subruleNestingLevel)_$(rule.Index)";
        def varRef = <[ $(varName : dyn) ]>;
        varRef
      }
      def prepandExprs(exprs : list[PExpr], mainExpr : PExpr.Sequence) : PExpr
      {
        match (mainExpr)
        {
          | <[ { ..$nestedExprs } ]> => <[ { ..$(exprs + nestedExprs) } ]>
        }
      }
      def compile(currentRule : Rule, isTrminalCapture : bool) : PExpr
      {
        recursionLevel++;
        when (recursionLevel > 500)
          assert(false, "Stack overflow");
        nestingLevel++;
        def prevSubruleNestingLevel = subruleNestingLevel;
        def debugString = if (_isDebug) $"$(currentRule.GetType().Name)[$(currentRule.Index)] (sl:$subruleNestingLevel): $currentRule" else "";
        def debugExpr   = if (_isDebug) <[ _ = $(debugString : string); ]> else <[ () ]>;
        def makeVariableNames(subrule : Rule) : list[string]
        {
          def isNotPredicate(rule : Rule) : bool
          {
            | Rule.And | Rule.Not => false
            | _ => true
          }
          def varCount   =  {
            def countVars(_) {
              | Rule.Sequence(rules) => rules.Count(isNotPredicate)
              | Rule.Choice(r :: _) => countVars(r)
              | _ => 1
            }
            countVars(subrule)
          }
          def upperBound = varCount - 1;
          def varNames   = $[$"token_L$(subruleNestingLevel)_$i" | i in [0 .. upperBound]]; // Generate variables
          varNames
        }
        def makeSubruleCode(rule : Rule, subrule : Rule, isTrminalCapture : bool, 
                            makeInitExpr    : PExpr               -> PExpr, 
                            makeSetExpr     : PExpr * list[PExpr] -> PExpr,
                            makeSetNoneExpr : PExpr               -> PExpr) 
          : list[PExpr] * PExpr * PExpr * PExpr
        {
          def varRef          = makeVarRef(rule); // this line must precede to subruleNestingLevel++
          subruleNestingLevel++; // it will be automatically restored after return from compile().
          def varNames        = makeVariableNames(subrule);
          // Add variables (by one for each subrule)
          def variables       = if (isTrminalCapture) []
                                else $[<[ mutable $(name : dyn); ]> | name in varNames];
          def variableRefs    = $[<[ $(name : dyn) ]> | name in varNames];
            
          def initList        = if (isTrminalCapture) <[ () ]> else makeInitExpr(varRef);
          def setExpr         = if (isTrminalCapture) <[ () ]> else makeSetExpr(varRef, variableRefs);
          def setNoneExpr     = if (isTrminalCapture) <[ () ]> else makeSetNoneExpr(varRef);
          def initialising    = debugExpr :: initList :: variables;
          def ruleCode        = compile(subrule, isTrminalCapture);
          (initialising, setExpr, setNoneExpr, ruleCode)
        }
        def makeListCode(rule : Rule, subrule : Rule, isTrminalCapture : bool) : list[PExpr] * PExpr * PExpr
        {
          def (initialising, setExpr, _setNoneExpr, rule) = 
            makeSubruleCode(rule, subrule, isTrminalCapture, 
                          varRef                 => <[ $varRef = SCG.List(); ]>, 
                          (varRef, variableRefs) => <[ $varRef.Add(..$variableRefs); ]>,
                          _                      => <[ () ]>);
          (initialising, setExpr, rule)
        }
        
        def result = match (currentRule)
        {
          | And(rule)              =>
            def rule = compile(rule, true);
            <[
              {
                $debugExpr;
                
                def newPos = $rule;
                
                if (newPos >= 0) pos else -1;
              }
            ]>

          | Not(Chars([RangeSet where (Ranges = [RangeSet.Range.Plain(char.MinValue, char.MaxValue)])])) // !any
                                   => 
            <[
              {
                $debugExpr;
                
                if (pos >= text.Length) pos else -1;
              }
            ]>

          | Not(rule)              =>
            //assert2(false);
            def rule = compile(rule, true);
            <[
              {
                $debugExpr;
                
                def newPos = $rule;
                
                if (newPos < 0) pos else -1;
              }
            ]>

          | Call(name) as rule     => 
            //assert2(name != "attr");
            if (isTrminalCapture)
              <[  { 
                    $debugExpr;
                    mutable ignoreResult;
                    
                    $(DecorateRuleName(name.Id) : dyn)(pos, ref ignoreResult, text);
                  } ]>
            else
              <[  {
                    $debugExpr;
                    $(DecorateRuleName(name.Id) : dyn)(pos, ref $(makeVarRef(rule)), text);
                  } ]>
          | Chars(chars)           =>
            def testChar(rset)
            {
              def nset = RangeSet().AddRange(char.MinValue, char.MaxValue).Sub(rset);

              def makeCond(rset)
              {
                def cmp(_ : RangeSet.Range)
                {
                  | RangeSet.Range.Plain as range =>
                    if (range.from == range.to)
                      (1, [<[ c == $(range.from : char) ]>])
                    else if (range.from == char.MinValue)
                      (1, [<[ c <= $(range.to : char) ]>])
                    else if (range.to == char.MaxValue)
                      (1, [<[ $(range.from : char) <= c ]>])
                    else if (range.from + 1 == range.to)
                      (2, [<[ c == $(range.from : char) ]>, <[ c == $(range.to : char) ]>])
                    else
                      (2, [<[ ($(range.from : char) <= c && c <= $(range.to : char)) ]>])
                  | RangeSet.Range.UnicodeClass as range =>
                    def cat = <[ System.Globalization.UnicodeCategory.$(range.category.ToString() : usesite) ]>;
                    if(range.inverted)
                      (2, [<[ char.GetUnicodeCategory(c) != $cat ]>])
                    else
                      (2, [<[ char.GetUnicodeCategory(c) == $cat ]>])
                }
                def rset = rset.Ranges.Map(cmp);

                def (rsetSize, rset) = rset.Fold((0, []), ((sz, r), (rsetSize, rset)) => (rsetSize + sz, r :: rset));

                def gen(ranges)
                {
                  | [range]         => range;
                  | range :: ranges => <[ $range || $(gen(ranges))]>
                  | []              => throw ArgumentException();
                }
                (rsetSize, gen(rset.Reverse().Flatten()))
              }
              def (rsetSize, rset) = makeCond(rset);
              def (nsetSize, nset) = makeCond(nset);
              if (rsetSize <= nsetSize)
                rset;
              else
                <[! $nset]>;
            }
            def generate(_)
            {
              | [ch] =>
                match (ch.Ranges)
                {
                  | [RangeSet.Range.Plain(char.MinValue, char.MaxValue)] =>
                    <[ pos + 1 ]>
                  | _ =>
                    <[
                      c = text[pos];
                      if ($(testChar(ch))) pos + 1 else -1;
                    ]>
                }
              | ch :: chars =>
                match (ch.Ranges)
                {
                  | [RangeSet.Range.Plain(char.MinValue, char.MaxValue)] =>
                    <[
                      def pos = pos + 1;
                      $(generate(chars));
                    ]>
                  | _ =>
                    <[
                      c = text[pos];
                      
                      if ($(testChar(ch)))
                      {
                        def pos = pos + 1;
                        $(generate(chars));
                      }
                      else
                        -1;
                    ]>
                }

              | [] => throw ArgumentException();
            }
            def len = chars.Length;
            def check = if (len > 1) <[pos + $((len - 1) : int)]> else <[pos]>;

            <[
              $debugExpr;

              if ($check < text.Length) $(generate(chars)) else -1
            ]>

          | Choice(rules)          =>
            def generate(_)
            {
              | [rule]        => rule;
              | rule :: rules =>
                <[
                  {
                    def newPos = $rule;
                    
                    if (newPos < 0) $(generate(rules)) else newPos;
                  }
                ]>
                
              | []            => throw ArgumentException();
            }
            
            def result = generate(rules.Map(compile(_, isTrminalCapture)));
            def exprs = [<[ $debugExpr; ]>, result];
            <[ { ..$exprs } ]>

          | RepeatMinMax(0, 1, subrule)    =>
            def (initialising, setExpr, setNoneExpr, ruleCode) = 
              makeSubruleCode(currentRule, subrule, isTrminalCapture, 
                              _                      => <[ () ]>, 
                              (varRef, variableRefs) => <[ $varRef = Some(..$variableRefs); ]>,
                              varRef                 => <[ $varRef = None(); ]>);
            prepandExprs(initialising, <[
              {
                def newPos = $ruleCode;
                
                if (newPos >= 0)
                {
                  $setExpr;
                  newPos
                }
                else
                {
                  $setNoneExpr;
                  pos
                }
              }
            ]>)

          | RepeatMinMax(minCount, maxCount, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(currentRule, subrule, isTrminalCapture);
            prepandExprs(initialising, <[
              {
                def rep(count, pos)
                {
                  if (count == $(maxCount : int))
                    pos
                  else
                  {
                    def newPos = $ruleCode;
                    
                    if (newPos >= 0)
                    {
                      $addTokensToList;
                      rep(count + 1, newPos)
                    }
                    else if (count >= $(minCount : int))
                      pos
                    else
                      -1
                   }
                }
                
                rep(0, pos);
              }
            ]>);

          | RepeatMin(0, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(currentRule, subrule, isTrminalCapture);
            
            prepandExprs(initialising, <[
              {
                def rep(pos : int)
                {
                  def newPos = $ruleCode;
                  
                  if (newPos >= 0)
                  {
                    $addTokensToList;
                    rep(newPos)
                  }
                  else
                    pos
                }
                
                rep(pos)
              }
            ]>)

          | RepeatMin(minCount, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(currentRule, subrule, isTrminalCapture);
            
            prepandExprs(initialising, <[
              {
                def rep(count, pos)
                {
                  def newPos = $ruleCode;
                  
                  if (newPos >= 0)
                  {
                    $addTokensToList;
                    
                    rep(count + 1, newPos)
                  }
                  else if (count >= $(minCount : int))
                    pos
                  else
                    -1
                }
                
                rep(0, pos)
              }
            ]>)

          | Sequence(subrules)        =>
            def generate(_rules : list[PExpr]) : PExpr
            {
              | [ruleCode]        => ruleCode
              | ruleCode :: rules =>
                <[
                  {
                    def pos = $ruleCode;
                    
                    if (pos >= 0) $(generate(rules)) else -1
                  }
                ]>
                
              | []                =>  <[ pos ]>;
            }
            
            def code   = generate(subrules.Map(compile(_, isTrminalCapture)));
            def result = [<[ $debugExpr; ]>, code];
            <[ { ..$result } ]>

          | Capture(name, _, _, subrule)              with isTrminalCapture = false =>
            //assert2(name != "inputError");
            def varRef       =  if (nestingLevel > 0) makeVarRef(currentRule);
                                else                  <[ $("result" : dyn) ]>;
            subruleNestingLevel++; // it will be automatically restored after return from compile().
            def varNames     = makeVariableNames(subrule);
            // Add variables (by one for each subrule)
            def variables    = $[<[ mutable $(name : dyn); ]> | name in varNames];
            def variableRefs = $[<[ $(name : dyn) ]> | name in varNames];
            def initialising = debugExpr :: variables;
            def subRuesCode  = compile(subrule, isTrminalCapture);
            // TODO: Надо сделат так, чтобы переменные генерируемые в Sequence не попадали в блок
            prepandExprs(initialising, <[
              {
                def newPos = $subRuesCode;
              
                if (newPos >= 0)
                  $varRef = Nemerle.Peg.VToken(pos, newPos, text, $(name.Id : string), $(name.Id : dyn)(..$variableRefs));
                else
                  SetMaxRollbackPos(pos);
                
                newPos
              }
            ]>)
          
          | CaptureNamedTerminalSymbol(name, subrule) =>
            //assert2(name.Id != "singleQuoteLiteral");
            def varRef     =  if (nestingLevel > 0) makeVarRef(currentRule);
                              else                  <[ $("result" : dyn) ]>;
            def subRuesCode = compile(subrule, isTrminalCapture = true);
            def setToken = 
              if (isTrminalCapture) <[ (); ]>;
              else <[
                if (newPos >= 0)
                  $varRef = Nemerle.Peg.NToken(pos, newPos, text, $(name.Id : string));
                else
                  SetMaxRollbackPos(pos);
                   ]>;

            <[
              {
                $debugExpr;
                def newPos = $subRuesCode;

                $setToken;
                
                newPos
              }
            ]>
            
          | ExtensionPoint         => throw NotImplementedException();
        }
        
        recursionLevel--;
        subruleNestingLevel = prevSubruleNestingLevel;
        nestingLevel--;
        result
      } // end of compile()
      
      def code = compile(ruleToCompile, false);
      tokenVars.Add(code);
      <[ { ..$(tokenVars.NToList()) } ]>
    }
  }
}
