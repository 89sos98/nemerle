using System;
using System.Console;
using System.Text;
using Nemerle.Text;
using Evaluator;

module zad4 
{
 Main (): void
 {
  def readinput (refr: list [string], ns: list [string], code: string, 
                 prompt: string): void {
   Write (prompt);
   def line = ReadLine ();
   match (line) {
    | null => ()
    | _ => 
     regexp match (line) {
      | @"^\s*$" => readinput (refr, ns, code, prompt)
      | @"^\s*help\s*(\(\))*[;\s]*;;\s*$" => 
       WriteLine ("Available built-in commands:\n"); 
       WriteLine ("help\t-\tprint this help");
       WriteLine ("ref\t-\tlink specified assembly");
       WriteLine ("using\t-\tuse specified namespace\n");
       WriteLine ("Built-in commands must be entered on a separate line.");
       readinput (refr, ns, code, "- ")
      | @"^\s*using\s+""(?<n>[\w\.]+)""[;\s]*;;\s*$" => 
       WriteLine ("Now using the " + n + " namespace.");
       readinput (refr, n :: ns, code, "- ")
      | @"^\s*ref\s+""(?<r>[\w\.]+)""[;\s]*;;\s*$" =>
       WriteLine ("Added " + r + " for linking.");
       readinput (r :: refr, ns, code, "- ")
      | _ =>  { 
       def l = line.TrimEnd ();
       if (l.EndsWith (";;")) {
        try { 
         def res = Eval (typeof (object), refr, ns,
                         code + l.TrimEnd ("; \t".ToCharArray ()));
         WriteLine (res.ToString ()); 
        } 
        catch { | e : Exception => WriteLine (e.Message); } 
        finally { readinput (refr, ns, "", "- "); }
       }
       else {
        readinput (refr, ns, code+line, "= ");
       }
      }
     }
   }
  }
  readinput ([], ["System"], "", "- ");
 }
}

