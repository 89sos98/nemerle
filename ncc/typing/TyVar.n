/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;
using Nemerle.Collections;

namespace Nemerle.Compiler 
{
  /** Represents a node in constraint graph. Used during type
      inference. */
  public class TyVar
  {
    // PUBLIC interface

    /** Require [this] to be at least [t].
    
        To be called when we require some lower constraint on type
        variable. */
    public Require (t : TyVar) : void
    {
      AddRelation (t, this)
    }


    /** Require [this] to be at least [t].
    
        To be called when we require some lower constraint on type
        variable. */
    public Require (t : MType) : void
    {
      AddRelation (t, this, rev = false)
    }

    
    /** Provide type [t] as the maximal type for [this].
        
        To be called when value of type [t] is assigned to cell of type
        [this]. Dual to [Require]. */
    public Provide (t : TyVar) : void
    {
      AddRelation (this, t)
    }

    
    /** Provide type [t] as the maximal type for [this].
        
        To be called when value of type [t] is assigned to cell of type
        [this]. Dual to [Require]. */
    public Provide (t : MType) : void
    {
      AddRelation (t, this, rev = true)
    }


    /** Make sure [t] and [this] will from now on always represent the 
        same type. */
    public Unify (t : TyVar) : void
    {
      match (t.Self.state) {
        | State.Free =>
          Require (t);
          Provide (t);
        | State.MonoType (t) =>
          Unify (t)
        | State.Alias => assert (false)
      }
    }


    /** Make sure [t] and [this] will from now on always represent the 
        same type. */
    [ForwardThis (Self)]
    public Unify (t : MType) : void
    {
      match (state) {
        | State.MonoType (t') =>
          t'.Unify (solver, t)

        | State.Free =>
          def self = solver.Copy (this);
          def f = Free (self);
          SetLowerBound (f, t);
          SetUpperBound (f, t);
          def lower = f.lower_tyvars;
          def upper = f.upper_tyvars;
          self.state = State.MonoType (t);
          lower.Iter (fun (tv) {
            def f = Free (solver.Copy (tv));
            assert (f.upper_tyvars [self]);
            f.upper_tyvars = f.upper_tyvars.Remove (self);
          })
          upper.Iter (fun (tv) {
            def f = Free (solver.Copy (tv));
            assert (f.lower_tyvars [self]);
            f.lower_tyvars = f.lower_tyvars.Remove (self);
          })

        | State.Alias => assert (false)
      }
    }


    public LowerBound : option [MType]
    {
      get {
        match (Self.state) {
          | State.MonoType (t) => Some (t)
          | (State.Free) as f =>
            if (f.lower_bound == null) None ()
            else Some (f.lower_bound)
          | State.Alias => assert (false)
        }
      }
    }


    public UpperBound : option [MType]
    {
      get {
        match (Self.state) {
          | State.MonoType (t) => Some (t)
          | (State.Free) as f =>
            if (f.upper_bound == null) None ()
            else Some (f.upper_bound)
          | State.Alias => assert (false)
        }
      }
    }
    

    public IsFixed : bool
    {
      get {
        Self.state matches State.MonoType
      }
    }


    public IsFree : bool
    {
      get {
        Self.state matches State.Free
      }
    }


    /** Fix the type to be [LowerBound], so it won't change anymore.
    
        Don't use this function unless absolutely necessary. */
    public Fixate () : void
    {
      match (Self.state) {
        | State.MonoType => ()
        | (State.Free) as f =>
          if (f.lower_bound == null)
            Provide (InternalType.Object)
          else
            Provide (f.lower_bound)
        | State.Alias => assert (false)
      }
    }
    
    
    public override ToString () : string
    {
      match (Self.state) {
        | (State.Free) as f =>
          $ "[$(f.lower_bound) TILL $(f.upper_bound)]"
          
        | State.MonoType (t) =>
          t.ToString ()

        | State.Alias => assert (false)
      }
    }


    // PRIVATE helper functions

    static AddRelation (low : TyVar, high : TyVar) : void
    {
      def low = low.Self;
      def high = high.Self;
      match ((low.state, high.state)) {
        | (State.MonoType (low), State.MonoType (high)) =>
          high.Require (solver, low)
        | (State.MonoType (low), State.Free) =>
          AddRelation (low, high, rev = false)
        | (State.Free, State.MonoType (high)) =>
          AddRelation (high, low, rev = true)
        | _ =>
          AddTyVarRelation (low, high)
      }
    }


    static AddRelation (low : MType, high : TyVar, rev : bool) : void
    {
      if (low.IsSeparated)
        high.Unify (solver, low)
      else {
        // TODO don't call it if not needed
        if (rev)
          SetUpperBound (Free (solver.Copy (high)), low)
        else
          SetLowerBound (Free (solver.Copy (high)), low);
        def f = Free (this);
        when (f.upper_bound.TryUnify (f.lower_bound))
          Unify (solver, f.lower_bound)
      }
    }
    
      
    static Free (v : TyVar) : State.Free
    {
      v.Self.state :> State.Free
    }

    
    static MergeCycle (low : State.Free, high : State.Free) : void
    {
      def upper = low.upper_tyvars.Sum (high.upper_tyvars);
      def lower = low.lower_tyvars.Sum (high.lower_tyvars);
      def cycle = upper.Intersect (lower).ToList ();
      def cycle = List.Map (solver.Copy, cycle);
      def upper = Set.Sum (List.Map (cycle, fun (x) { Free (x).upper_tyvars }));
      def lower = Set.Sum (List.Map (cycle, fun (x) { Free (x).lower_tyvars }));
      match (cycle) {
        | x :: xs =>
          mutable lb = Free (x).lower_bound;
          mutable ub = Free (x).upper_bound;
          x.lower_tyvars = lower;
          x.upper_tyvars = upper;
          foreach (y in xs) {
            lb = solver.Intersect (lb, Free (y).lower_bound);
            ub = solver.Sum (ub, Free (y).upper_bound);
            solver.AddLink (x, y);
          }
          foreach (y in cycle) {
            def f = free (y);
            f.lower_bound = lb;
            f.upper_bound = ub;
            f.lower_tyvars = lower;
            f.upper_tyvars = upper;
          }
        | [] => assert (false)
      }
    }
    
    
    static AddTyVarRelation (low_tv : TyVar, high_tv : TyVar) : void
    {
      if (Free (low_tv).upper_tyvars.Contains (high_tv)) {
        assert (Free (high_tv).lower_tyvars.Contains (low_tv));
        ()
      } else {
        def low = Free (solver.Copy (low_tv));
        def high = Free (solver.Copy (low_tv));
        def upper = low.upper_tyvars.Sum (high.upper_tyvars).Replace (high);
        def lower = high.lower_tyvars.Sum (low.lower_tyvars).Replace (low);
        def have_cycle = upper [low];
        assert (have_cycle == lower [high]);
        if (have_cycle) {
          high.lower_tyvars = lower;
          low.upper_tyvars = upper;
          MergeCycle (low, high)
        } else {
          SetLowerBound (high, low.lower_bound);
          SetUpperBound (low, high.upper_bound);
          high.lower_tyvars = lower;
          low.upper_tyvars = upper;
        }
      }
    }


    static SetLowerBound (f : State.Free, t : MType) : void
    {
      f.lower_bound = solver.Intersect (f.lower_bound, t);
      f.upper_bound.Require (solver, f.lower_bound);
      f.upper_tyvars.Iter (fun (tv : TyVar) { tv.Require (lb) })
    }
    
    
    static SetUpperBound (f : State.Free, t : MType, rec : bool) : void
    {
      f.upper_bound = solver.Sum (f.upper_bound, t);
      f.upper_bound.Require (solver, f.lower_bound);
      f.lower_tyvars.Iter (fun (tv : TyVar) { tv.Provide (ub) })
    }


    internal variant State {
      | MonoType { ty : MType; }
      | Free {
          mutable lower_tyvars : Set [TyVar];
          mutable upper_tyvars : Set [TyVar];
          mutable lower_bound : MType;
          mutable upper_bound : MType;
        }
      | Alias { tv : TyVar; }
    }

    internal mutable state : State;
    internal id : int;
    solver : Solver;

    static mutable current_id : int;

    Self : TyVar
    {
      get { solver.Find (this) }
    }

    internal this (s : Solver)
    {
      solver = s;
      state = State.Free (Set (), Set (), null, null);
      id = current_id;
      ++current_id;
    }

    internal this (s : Solver, m : MType)
    {
      solver = s;
      state = State.MonoType (m);
      id = current_id;
      ++current_id;
    }

    internal this (other : TyVar)
    {
      id = other.id;
      solver = other.solver;
      match (other.Self.state) {
        | State.Free (a, b, c, d) =>
          state = State.Free (a, b, c, d);
        | State.MonoType
        | State.Alias => assert (false)
      }
    }
  }
}
