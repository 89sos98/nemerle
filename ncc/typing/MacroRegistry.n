/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;
using Nemerle.Compiler.Tyexpr;

using Nemerle.Text;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 */
public interface IMacro
{
  GetName () : string;
  GetNamespace () : string;  
  Run (ctx : TypingContext, args : list [PT.SyntaxElement]) : PT.PExpr;
  CallTransform (_ : list [PT.PExpr]) : list [PT.SyntaxElement];
  SyntaxExtension () : string * list [Parser.GrammarElement] * list [int];
  IsTailRecursionTransparent : bool { get; }
} 

public module MacroRegistry
{
#if NEWPARSER
  extensions : Hashtable [list [string], list [SyntaxDefinition]];
#else  
  extensions : Hashtable [string, list [string * list[string] * (void -> PT.PExpr)]];
#endif  

  mutable loaded : list[string];

  this () {
    extensions = Hashtable (50);
    loaded = [];
  }

#if NEWPARSER
  internal GetSyntaxExtensions (name_space : list [string]) : list [SyntaxDefinition]
  {
    match (extensions [name_space]) {
      | null => []
      | definition => definition
    }
  }

  public LoadSyntaxExtensions (_from_namespace : string) : void { }
  internal RemoveSyntaxExtensions () : void { }
#else
  public LoadSyntaxExtensions (from_namespace : string) : void
  {
    match (extensions.Get (from_namespace)) {
      | Some (l) =>
        foreach ((key, keywords, callback) in l) {
          Parser.AddParsingFunction (key, callback);
          foreach (x in keywords) LexerBase.AddKeyword (x);
        }
        loaded = from_namespace :: loaded;
      | _ => ()
    }
  }

  internal RemoveSyntaxExtensions () : void
  {
    loaded = List.Filter (loaded, fun (ns) {
      if (ns != "Nemerle.Core")
        match (extensions.Get (ns)) {
          | Some (val) =>
            foreach ((key, keywords, _) in val) {
              foreach (x in keywords) LexerBase.RemoveKeyword (x);
              Parser.ctx.keywords.Remove (key)
            };
            false
            
          | None => Util.ice ("cannot find loaded namespace in extensions")
        }
      else
        true
    })
  }
#endif
  
  public register_macro (m : IMacro) : void {
    def ns = m.GetNamespace ();
#if !NEWPARSER
 def ns =
     if (ns == "")
       "Nemerle.Core"
     else
       ns.Substring (0, ns.Length - 1);
#endif
    def nslist = NString.Split (ns, array ['.']);

    // full qualified name of macro call    
    def full_list = nslist + [m.GetName ()];

    match (GlobalEnv.LookupExactMacro (full_list)) {
      | Some =>
        Message.error ("macro `" + ns + m.GetName () + "' already defined")
      | None =>
        // store syntax extension in MacroRegistry
        match (m.SyntaxExtension ()) {
          | ("", [], []) => ()
          | (key, rules, positions) =>
            mutable keywords = [key];
            foreach (Parser.GrammarElement.GE_keyword (k) in rules) 
              keywords = k :: keywords;

            def permute = Macros.CreatePermutingFunction (List.Rev (positions));
            def macro_ns = GlobalEnv.ExactPath (full_list);
            
#if NEWPARSER
            def syntax_def =
              SyntaxDefinition (key, keywords, macro_ns, rules, permute);

            // store extensions for this namespace
            match (extensions.Get (nslist)) {
              | Some (l) => extensions.Set (nslist, syntax_def :: l)
              | None => extensions.Set (nslist, [syntax_def])
            }
#else

            def callback = Parser.make_parsing_function (macro_ns, rules, permute);
              
            // store extensions for this namespace
            match (extensions.Get (ns)) {
              | Some (l) =>
                extensions.Set (ns, (key, keywords, callback) :: l)
              | None =>
                extensions.Set (ns, [(key, keywords, callback)])
            }
#endif            
        };
        GlobalEnv.AddMacro (full_list, m);
    }
  }

  internal expand_macro (orig_ctx : TypingContext, ctx : TypingContext, expr : PT.PExpr) : PT.PExpr {
    match (expr) {
      | PT.PExpr.Call (name, args) =>
        match (Util.qidl_of_expr (name)) {
          | Some ((namepath, name)) =>
            match (name.GetEnv (ctx.env).LookupMacro (namepath)) {
              | Some (x) =>
                def used_ctx = if (x.IsTailRecursionTransparent) orig_ctx else ctx;
                TypingContext.PushNewColor (name.color, name.GetEnv (ctx.env));
                def expanded = Util.locate (expr.loc, x.Run (used_ctx, x.CallTransform (args)));
                TypingContext.PopColor ();
                expand_macro (orig_ctx, ctx, expanded);
              | None => expr
            }
          | None => expr
        }
        
      | PT.PExpr.MacroCall (name, namespc, parms) =>
        match (namespc.Value) {
          | GlobalEnv.TypeInfoCache.MacroCall (m) =>
            def used_ctx = if (m.IsTailRecursionTransparent) orig_ctx else ctx;            
            TypingContext.PushNewColor (name.color, name.GetEnv (ctx.env));
            def expanded = Util.locate (expr.loc, m.Run (used_ctx, parms));
            TypingContext.PopColor ();        
            expand_macro (orig_ctx, ctx, expanded)
          | _ =>
            Util.ice ("failed to resolve macro name `" +
                      NString.Concat (".", namespc.Name) + "'")
        }

      | _ => expr
    }
  }

  internal lookup_macro (env : GlobalEnv, expr : PT.PExpr, suff : string)
  : option [PT.Name * IMacro * list [PT.PExpr]]
  {
    match (expr) {
      | <[ $(_ : name) ]>
      | <[ $_ . $_ ]> =>
        lookup_macro (env, <[ $expr () ]>, suff)
      | <[ $name ( .. $parms ) ]> =>
          match (Util.qidl_of_expr (name)) {
            | Some ((id, name)) =>
              def ctx = name.GetEnv (env);
              def id =
                match (List.Rev (id)) {
                  | x :: xs => List.Rev (x + suff :: xs)
                  | [] => assert (false)
                };
              match (ctx.LookupMacro (id)) {
                | Some (m) => Some ((name, m, parms))
                | None => None ()
              };
            | None => None ()
          }
      | _ => None ()
    }
  }
  
}
} // end ns
