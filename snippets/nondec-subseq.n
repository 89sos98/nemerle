public class NondecreasingSubsequence 
{
  class node {
    public mutable best : int;
    public mutable bestid : int;
  }

  static find_longest (seq : array (int)) : int * list (int)
    {
      def close2pow (n : int, pow : int) : int
        {
          if (n == 0) pow
	  else
	    close2pow (n / 2, pow * 2)
        }

      def n = (seq : System.Array).Length;
      def pow = close2pow (n, 1);
      def tab = mkarray [node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1); 
                         node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1);
                         node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1);
                         node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1);
			 node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1);
			 node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1);
			 node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1);
			 node(0,-1); node(0,-1); node(0,-1); node(0,-1); node(0,-1)];

      def insert (dest : int, ex : int, pos : int, bestl : int, bestlid : int) : void
        {
	  if (pos >= pow)
	    {
	      tab[pos] .best <- bestl + 1;
	      tab[pos] .bestid <- bestlid;
	    }
	  else
	    {
	      def dir = if (dest >= (pos * 2 + 1) * ex / 2) 1 else 0;
	      def child = pos * 2 + dir;

	      def (nb, nbid) = 
	        if (bestl < tab[pos * 2] .best && dir == 1) 
		  (tab[pos * 2] .best, tab[pos * 2] .bestid)
  		else 
		  (bestl, bestlid);

	      insert (dest, ex / 2, child, nb, nbid);
 
	      if (tab[pos] .best < tab[child] .best) {
		tab[pos] .best <- tab[child] .best;
		if (child >= pow)
                  tab[pos] .bestid <- child - pow
		else
		  tab[pos] .bestid <- tab[child] .bestid;
	      }
	      else
	        ();
	    }
	}

      def loop (i : int) : void
        {
	  if ( i < n )
	    {
	      insert (seq[i] + pow, pow, 1, 0, -1);
	      loop (i + 1);
	    }
	  else
	    ()
	}

      def reconstruct (i : int, next : int, acc : list (int)) : list (int)
 	{
	  if ( i >= pow )
  	    if ( i - pow == next )
	      reconstruct (i - 1, tab[i] .bestid, next :: acc)
	    else
	      reconstruct (i - 1, next, acc)
          else
	    acc
	}    

      loop (0);
      (tab[1] .best, reconstruct (n + pow - 1, tab[1] .bestid, []))
    }

  public static Main () : void
    {
      def sequence = mkarray [4; 2; 6; 1; 3; 0; 5];

      def (len, subs) = find_longest (sequence);
      
      def print_list (l : list (int)) : void
        {
	  match (l) {
            | [] => print_endline ("")
            | x::xs => print_string (string_of_int (x) + " "); print_list (xs)
          }
        }

      print_endline (string_of_int (len));
      print_list (subs);
    }
}
(*
BEGIN-OUTPUT
3
1 3 5 
END-OUTPUT
*)
