/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using System.Globalization;

namespace Nemerle.Compiler {

  [Record]
  public class Location 
  {
    public file : string;
    public line : int;
    public column : int;
    public mutable comment : string;
  }
  
  public class Located
  {
    internal static default_loc : Location;

    static this () { default_loc = Location ("", 0, 0, null) }

    public mutable loc : Location;
    public this () { loc = Location_stack.top (); }
    public this (loc : Location) { this.loc = loc }
  }

  [System.FlagsAttribute ()]
  public enum NemerleAttributes
  {
    | None      = 0x0000
    | Public    = 0x0001
    | Private   = 0x0002
    | New       = 0x0004 
    | Protected = 0x0008
    | Abstract  = 0x0010
    | Virtual   = 0x0020
    | Sealed    = 0x0040
    | Static    = 0x0080
    | Mutable   = 0x0100      
    | Internal  = 0x0200
    | Override  = 0x0400
    | Module    = 0x0800
    | Struct    = 0x1000
    | Macro     = 0x2000
    | Volatile  = 0x4000

    | AccessModifiers = 0x020b
  }                 

  
  public class Modifiers 
  {
    public mutable mods : NemerleAttributes;
    public mutable custom_attrs : list <Parsetree.Expr>;
    public mutable macro_attrs : list <string * Parsetree.Expr>;

    public static Empty : Modifiers;

    public this (mods : NemerleAttributes, attrs : list <Parsetree.Expr>)
    {
      this.mods = mods;
      this.custom_attrs = attrs;
      this.macro_attrs = [];
    }

    public static this () {
      Empty = Modifiers (NemerleAttributes.None, []);
    }
  }

  public variant Literal
  {
    | L_void
    | L_null
    | L_string { val : string; }
    | L_float { val : float; }
    | L_double { val : double; }
    | L_decimal { val : decimal; }
    | L_char { val : char; }
    | L_bool { val : bool; }
    | L_sbyte { val : sbyte; }
    | L_byte { val : byte; }
    | L_short { val : short; }
    | L_ushort { val : ushort; }
    | L_int { val : int; }
    | L_uint { val : uint; }
    | L_long { val : long; }
    | L_ulong { val : ulong; }

    | L_enum { val : Literal; ty : Tycon; }


    /**
     * Converts 'this' literal to an equivalent (lexable) string
     */
    public override ToString () : string
    {
      match (this) {
        | L_void           => "()"
        | L_null           => "null"

        | L_string   (val) => "\"" + val + "\""
        | L_float    (val) => val.ToString (NumberFormatInfo.InvariantInfo) + "f"
        | L_double   (val) => val.ToString (NumberFormatInfo.InvariantInfo) + "d"
        | L_decimal  (val) => val.ToString (NumberFormatInfo.InvariantInfo) + "m"
        | L_char     (val) => "'" + val.ToString () + "'"
        | L_bool     (val) => if (val) "true" else "false"
        | L_sbyte    (val) => val.ToString () + "sb"
        | L_byte     (val) => val.ToString () + "b"
        | L_short    (val) => val.ToString () + "s"
        | L_ushort   (val) => val.ToString () + "us"
        | L_int      (val) => val.ToString ()
        | L_uint     (val) => val.ToString () + "u"
        | L_long     (val) => val.ToString () + "l"
        | L_ulong    (val) => val.ToString () + "ul"
          
        | L_enum (val, ty) => "(" + val.ToString () + " :> " + ty.GetFullName () + ")"
      }
    }
  }

  public variant Fun_body
  {
    | FB_parsed_expr { expr : Parsetree.Expr; }
    | FB_typed_expr { expr : Typedtree.Expr; }
    | FB_compiled_expr
    | FB_extern { name : string; }
    | FB_abstract  // for interface method
  }

  public variant Fun_kind
  {
    | FK_method { f_implements : list <Parsetree.Splicable_string>; }
    | FK_bound_method { f_implements : list <IMethod>; }
    | FK_ctor
    | FK_static_ctor
    | FK_function
    | FK_iface_method
  }


} // Nemerle.Compiler
