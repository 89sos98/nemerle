<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Quick summary of differences between Nemerle and C#</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document lists basic differences between Nemerle and C#
        in a terse form. If you know Java or C++ you also should be able
        to use it.
      </p>
    </body>
  </section>


  <section id="expr-changes">
    <title>Changes in expressions</title>
    <body>
      <comparison>
        <entry>
          <csharp>
            int x = 3;<br/>
            string y = "foo";<br/>
            FooBarQux fbq = make_fbq ();
          </csharp>
          <nemerle>
            def x = 3;<br/>
            def y = "foo";<br/>
            def fbq = make_fbq ();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> cannot be changed.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
              int x = 3;<br/>
              string y = "foo";<br/>
              FooBarQux fbq = make_fbq();
          </csharp>
          <nemerle>
              mutable x &lt;- 3;<br/>
              mutable y &lt;- "foo";<br/>
              mutable fbq &lt;- make_fbq();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> can be changed.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta>;
          </csharp>
          <nemerle>
            <meta>expr_1</meta> &lt;- <meta>expr_2</meta>;
          </nemerle>
          <remarks>
            The assignment operator.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta> = <meta>expr_3</meta>;
          </csharp>
          <nemerle>
            def tmp = <meta>expr_3</meta>;<br/>
            <meta>expr_1</meta> &lt;- tmp;<br/>
            <meta>expr_2</meta> &lt;- tmp;
          </nemerle>
          <remarks>
            The type of assignment operator is <tt>void</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> (<meta>parms</meta>)
          </csharp>
          <nemerle>
            <meta>Class</meta> (<meta>parms</meta>)
          </nemerle>
          <remarks> 
            The <tt>new</tt> keyword is dropped.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            array (<meta>size</meta>)
          </nemerle>
          <remarks>
            If the type can be inferred (most of the time).
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            (array (<meta>size</meta>) : array (<meta>Class</meta>))
          </nemerle>
          <remarks>
            If the type cannot be inferred.
          </remarks>
        </entry>

        <entry>
          <csharp>
            { <meta>expr_1</meta>, <meta>expr_1</meta>, ..., 
              <meta>expr_n</meta> }
          </csharp>
          <nemerle>
            array [<meta>expr_1</meta>, 
                   <meta>expr_1</meta>, ..., 
                   <meta>expr_n</meta>]
          </nemerle>
          <remarks>
            The array constructor.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) return <meta>foo</meta>;<br/>
            <meta>do_something ()</meta>;<br/>
            return <meta>bar</meta>;
          </csharp>
          <nemerle>
            if (<meta>cond</meta>) <meta>foo</meta><br/>
            else {<br/>
            <meta>do_something ()</meta>;<br/>
            <meta>bar</meta><br/>
            }
          </nemerle>
          <remarks>
            There is no <tt>return</tt> statement that cuts control flow in Nemerle.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            when (<meta>cond</meta>) answer &lt;- 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without <tt>else</tt> is called <tt>when</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (!<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            unless (<meta>cond</meta>) answer &lt;- 42;<br/>
            // or: when (!<meta>cond</meta>) answer &lt;- 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without "then" is called
            <tt>unless</tt>. However nobody is forced to use it.
          </remarks>
        </entry>

        <entry>
          <csharp>
            try ... <br/>
            catch (FooException e) { ... }<br/>
            catch (BarException e) { ... }
          </csharp>
          <nemerle>
            try ... <br/>
            catch {<br/>
              | e : FooException => ...<br/>
              | e : BarException => ...<br/>
            }
          </nemerle>
          <remarks>
            Somewhat different syntax, consistent with <tt>match</tt> though.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> :> <meta>type</meta>)
          </nemerle>
          <remarks>
            Runtime type cast, allows for downcasts and upcasts.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> : <meta>type</meta>)
          </nemerle>
          <remarks>
            Static cast, allow only upcast.
          </remarks>
        </entry>

        <entry>
          <csharp>
            using System;<br/>
            ...<br/>
            Console.WriteLine ("foo");
          </csharp>
          <nemerle>
            using System.Console;<br/>
            ...<br/>
            WriteLine ("foo");
          </nemerle>
          <remarks>
            In Nemerle you can also apply <tt>using</tt> directive
            to classes.
          </remarks>
        </entry>

      </comparison>
      <!-- TODO: while, for -->
      
    </body>
  </section>
  

  <section id="class-changes">
    <title>Changes in type definitions</title>
    <body>
      <comparison>

        <entry>
          <csharp>
            class Foo : Bar, IComparable, IEnumerable { ... }
          </csharp>
          <nemerle>
            class Foo extends Bar implements IComparable, IEnumerable { ... }
          </nemerle>
          <remarks>
            This seems more readable.
          </remarks>
        </entry>

        <entry>
          <csharp>
              static int foo (int x, string y) { ... }
          </csharp>
          <nemerle>
              static foo (x : int, y : string) : int { ... }
          </nemerle>
          <remarks>
            Type are written after variables.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              public Foo (int x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              public this (x : int) { ... }<br/>
            }
          </nemerle>
          <remarks>
            Constructor name is always <tt>this</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo : Bar {<br/>
              public Foo (int x) : base (x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo extends Bar {<br/>
              public this (x : int) { base (x); ... }<br/>
            }
          </nemerle>
          <remarks>
            Base constructor is called in function body.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              mutable x : int;<br/>
            }
          </nemerle>
          <remarks>
            Fields to be changed outside constructor need to be marked <tt>mutable</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              readonly int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              x : int;<br/>
            }
          </nemerle>
          <remarks>
            <tt>readonly</tt> is the default.
          </remarks>
        </entry>

        <entry>
          <csharp>
            interface I { void m(); }<br/>
            class C : I {<br/>
              public void m () { ... }<br/>
            }
          </csharp>
          <nemerle>
            interface I { m () : void; }<br/>
            class C implements I {<br/>
              public m () : void { ... }<br/>
            }
          </nemerle>
          <remarks>
            Implementing methods from interfaces.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class C : I1, I2 {<br/>
              void I1.m () { ... }<br/>
              void I2.m () { ... }<br/>
            }
          </csharp>
          <nemerle>
            class C implements I1, I2 {<br/>
              meth1 () : void implements I1.m { ... }<br/>
              meth2 () : void implements I2.m { ... }<br/>
            }
          </nemerle>
          <remarks>
            When two interfaces have the method with the same name.
          </remarks>
        </entry>

      </comparison>
    </body>
  </section>
 

  <section id="generics">
    <title>As in Generic C#...</title>
    <body>
      <p>
        This section describes stuff that is similar to what is called
        generics in C# 2.0.
      </p>
      
      <comparison>
      
        <entry>
          <csharp>
            class A &lt;T> { readonly T x; }
          </csharp>
          <nemerle>
            class A ('t) { x : 't; }
          </nemerle>
          <remarks>
            Type parameters (or type variables) have special syntax even at
            the lexical level.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class A &lt;T> where T : IComparable &lt;T> { ... }
          </csharp>
          <nemerle>
            class A ('t) where 't :> IComparable ('t) { ... }
          </nemerle>
          <remarks>
            Type parameters are written in parens <tt>()</tt>.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class A &lt;T> where T : IFoo, IBar { ... }
          </csharp>
          <nemerle>
            class A ('t) where 't :> IFoo, 't :> IBar { ... }
          </nemerle>
          <remarks>
            Multiple constraints.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class A &lt;X,Y> where X : IFoo, IBar where Y : IBaz { ... }
          </csharp>
          <nemerle>
            class A ('x, 'y) where 'x :> IFoo, 'x :> IBar, 'y :> IBaz { ... }
          </nemerle>
          <remarks>
            Multiple type variables.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            int meth&lt;A> (A x) { ... }
          </csharp>
          <nemerle>
            'a meth (x : 'a) : int { ... }
          </nemerle>
          <remarks>
            Polymorphic method.
          </remarks>
        </entry>
        
      </comparison>
      
    </body>
  </section>

  
  <section id="new-stuff">
    <title>New stuff</title>
    <body>
      <p>
        This section talks about stuff more or less absent in C#.
      </p>
      
      <comparison>
        <entry>
          <csharp>
            void m(int _unused1, string _unused2) { ... }
          </csharp>
          <nemerle>
            m (_ : int, _ : string) : void { ... }
          </nemerle>
          <remarks>
            Upon each use the <tt>_</tt> keyword generates new name.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class Foo { static readonly int x; static int m () { ... } }
          </csharp>
          <nemerle>
            module Foo { x : int; m () : int { ... } }
          </nemerle>
          <remarks>
            <tt>module</tt> is a class, that have all members <tt>static</tt>.
          </remarks>
        </entry>
      </comparison>
    </body>
    

    <subsection id="ns-alias">
      <title>Namespace aliases</title>
      <body>
        <p>
          Example:
        </p>
<code>
namespace SR = System.Reflection;
namespace SC = System.Console;
...
def name = SR.AssemblyName ();
SC.WriteLine (name.CodeBase);
</code>
        <p>
          This example probably wouldn't convince anybody this feature
          is needed :) However it comes in handy when one have two very
          similar namespaces (for two SQL providers) and want to use
          both without writing veeeery long names each time.
        </p>
      </body>
    </subsection>
    
    
    <subsection id="tuple">
      <title>Tuples</title>
      <body>
        <p>
          Tuples are form of nameless data structures. They are usable
          when you need to return two or three values from function.
        </p>
<code>
/** Parses time in HH:MM format. */
parse_time (time : string) : int * int
{
  def arr = time.Split (array [':']);
  (System.Int32.Parse (arr[0]), System.Int32.Parse (arr[1]))
}

seconds_since_midnight (time : string) : int
{
  def (hours, minutes) = parse_time (time);
  (hours * 60 + minutes) * 60
}

foo () : void
{
  def secs = seconds_since_midnight ("17:42");
  ...
}
</code>
        <p>
          Another example could be:
        </p>
<code>
// split (3.7) => (3, 0.7)
split (x : double) : int * double
{
  def floor = System.Math.Floor (x);
  (System.Convert.ToInt32 (floor), x - floor)
}
</code>
      </body>
    </subsection>
    
        
    <subsection id="local-functions">
      <title>Local functions</title>
      <body>
        <p>
          Local functions are functions defined within other functions.
          For this reason they are also called <b>nested functions</b>.
        </p>
        <p>
          There are three reasons to defined local functions. First one
          is not to pollute class namespace. We have the <tt>private</tt>
          keyword for that, so this doesn't seem any good reason.
        </p>
        <p>
          The second one is that local functions can access variables
          defined in outer function. This allows for somewhat different
          (better?) code structuring then in C#. You can have several
          variables and local functions using them defined in a function.
        </p>
        <p>
          The most important reason for local function is however the
          fact that you can pass them to other functions so they can
          be run from there implementing for example iterators for
          data structures. This is explained in more detail
          <a ref="functional-values">later</a>.
        </p>
        <p>
          Local functions are defined just like other values with
          the <tt>def</tt> keyword.
        </p>
<code>
sum_cubes (v1 : int, v2 : int, v2 : int) : int
{
  def cube (x : int) : int {
    x * x * x
  };
  cube (v1) + cube (v2) + cube (v3)
}
</code>
        <p>
          In almost all cases you can omit return type specification for
          local functions.  In most cases you can also omit parameter
          specifications (however not in the example above).
        </p>
        <p>
          Using local functions is one of way of implementing loops in
          Nemerle.
        </p>
<code>
<![CDATA[class Sum {
  public Main () : void
  {
    def sum (x) {
      if (x <= 0) 
        0
      else
        x + sum (x - 1)
    };
    System.Console.WriteLine ("Sum of numbers from 20 to 0 is: {0}", 
                              sum (20));
  }
}]]>
</code>
      </body>
    </subsection>

    
    <subsection id="functional-values">
      <title>Functional values</title>
      <body>
        <p>
          In Nemerle one can pass functions as arguments of other
          functions, as well as return them as results. This way functions
          are not worse then any other data types (think about Equal
          Rights for Functions movement :-)
        </p>
        <p>
          In C# one have delegates. This concept is quite similar to
          functional values.  However functional values are far more
          efficient and their types need not be declared before use.
        </p>
        <p>
          As a first example consider:
        </p>
<code>
// C#
delegate int IntFun (int);

class M {
  static int f(int x)
  {
    return x * 2;
  }

  static int run_delegate_twice(IntFun f, int v)
  {
    return f(f(v));
  }
  
  static void Main ()
  {
    System.Console.WriteLine("{0}", 
                   run_delegate_twice(new IntFun (f), 3));
  }
}
</code>
<code>
// Nemerle
class M {
  static f (x : int) : int
  {
    x * 2
  }

  static run_delegate_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }
  
  static void Main ()
  {
    System.Console.WriteLine ("{0}", run_delegate_twice (f, 3))
  }
}
</code>
        <p>
          In this example delegates seem just like function pointers
          in C.  Functional values don't present any better, except
          maybe shorter syntax.  However real power of delegates comes
          from the fact that one can use methods as delegates (thus
          effectively embedding the <tt>this</tt> pointer in delegate).
          This is much like "functional objects" design pattern in C++.
          We won't show it here, please refer to C# manual for details.
        </p>
        <p>
          Still using methods as delegates doesn't show their full power.
          The funny part begins when we use nested functions as functional
          values.
        </p>
<code>
class M {
  static run_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }

  static run_adder (x : int) : void
  {
    def f (y : int) : int { x + y };
    System.Console.WriteLine ("{0}", run_twice (f, 1))
  }

  static Main () : void
  {
    run_adder (1);
    run_adder (2);
  }
}
</code>
        <p>
          This example prints 3 and 5. Note how <tt>x</tt> is captured in local
          function <tt>f</tt>.
        </p>
        <p>
          This feature is similar to anonymous delegates in C# 2.0.
        </p>
        <!-- TODO: describe multi argument function types -->
        <!-- TODO: mention iterators -->
      </body>
    </subsection>
    
      
    <subsection id="named-parms">
      <title>Named parameters</title>
      <body>
        <p>
          This feature (in this form) comes from <a
          ref="http://www.python.org/">python</a>.  When you call a
          function you can name some of its parameters (which allows
          putting them in different order then in definition).
        </p>
<code>
<![CDATA[frobnicate (foo : int, do_qux : bool, 
                                do_baz : bool, 
                                do_bar : bool)
{
  // The method body doesn't mean anything ;-)
  if (do_qux && !do_baz) foo * 2
  else if (do_bar) foo * 7
  else if (do_baz) foo * 13
  else 42
}

Main () : void {
  // Parameters' names can be omitted.
  def res1 = frobnicate (7, true, false, true);
  
  // This is the indented usage -- the first 
  // (main) parameter comes without a name
  // and the following flags with names
  def res2 = frobnicate (7, do_qux = true,
                            do_baz = false, 
                            do_bar = true);
                            
  // You can however name every parameter:
  def res3 = frobnicate (foo = 7, do_qux = true, 
                         do_baz = false, do_bar = true);
                         
  // And permute them:
  def res3 = frobnicate (do_qux = true, do_bar = true, 
                         do_baz = false, foo = 7);
                         
  // You can also omit names for any number of leading 
  // parameters and permute the trailing ones.
  def res2 = frobnicate (7, true,
                            do_bar = true,
                            do_baz = false);
  ()
}]]>
</code>
        <p>
          The rules behind named parameters are simple:
        </p>
        <ul>
          <li>
            named parameters must come after all unnamed (positional)
            parameters
          </li>
          <li>
            positional parameters are assigned first
          </li>
          <li>
            the remaining parameters are assigned based on their names
          </li>
        </ul>
        <p>
          Named parameters can be used only when names of parameters are
          known (which basically mean they do not work in conjunction
          with functional values).
        </p>
      </body>
    </subsection>
      <!-- TODO:
        void literal
        lambda
        [],::
       -->
  </section>
  

  <section id="variants-and-matching">
    <title>Variants and matching</title>
    <body>
      <!-- TODO -->
    </body>
  </section>

  
  <section id="same">
    <title>The same</title>
    <body>
      <p>
        This section lists things that are written (mostly) the same way as
        they do in C#. It only includes cases when it could be doubtful.
      </p>
      <!-- 
        @"foo"
        /* */
        //
        using (+ opening classes)
        throw
        try..finally
        opertors?
      -->
    </body>
  </section>

  
    <!-- 
      <comparison>
        <entry>
          <csharp>
          </csharp>
          <nemerle>
          </nemerle>
          <remarks>
          </remarks>
        </entry>
      </comparison>

    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
