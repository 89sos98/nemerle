/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;
using Nemerle.Collections;

namespace Nemerle.Compiler 
{
  // to be moved somewhere else
  public enum DiagnosticKind
  {
    | Debug
    | Hint
    | Warning
    | Error
  }


  /** Represent a compiler diagnostic message. */
  public class Diagnostic
  {
    public Message : string
    {
      get {
      }
    }
    

    public Location : Location
    {
      get {
      }
    }


    public Kind : DiagnosticKind
    {
      get {
      }
    }
  }
  
  
  /** A constraint solver. */
  public class Solver
  {
    /** Store current constraint state.
        
        Called before some speculative type checking fragment, like
        overload resolution. */
    public PushState () : void
    {
    }


    /** Go one constraint state back.
        
        This function rollbacks all constraints made in current state,
        and also clear the error state if it was in */
    public PopState () : void
    {
    }


    /** Check if the solver has encountered an error in the current of
        parent state. */
    public InErrorState : bool
    {
      get {
      }
    }
    

    /** The first error encountered in the current (or parent) state, or 
        [null] if not [InErrorState]. */
    public ErrorMessage : Diagnostic
    {
      get {
      }
    }
    

    /** Make sure all TyVars created so far won't go anywhere.
        
        Called when the type checking process for a method is finished (or
        for a class, if we decide to go with inferred private types). */
    public FixateAll () : void
    {
    }


    /** Generate a new type variable. */
    public FreshTyVar () : TyVar
    {
    }


    /** Increment current type variable rank.

        Called before typing of a local function. */
    public PushRank () : void
    {
    }

    
    /** Restore previous type variable rank.

        Called after typing of a local function. */
    public PopRank () : void
    {
    }


    public Intersect (t1 : MType, t2 : MType) : MType
    {
    }
    

    public Sum (t1 : MType, t2 : MType) : MType
    {
    }
    

    public AddLink (t1 : TyVar, t2 : TyVar) : void
    {
    }
    

    public Find (id : int) : TyVar
    {
    }
  }



  /** Represent top-level type constructor for a given type. */
  public variant MType
  {
    | Class {
        tycon : TypeInfo;
        args : list <TyVar>;
      }
    | TyVar {
        tyvar : StaticTyVar;
      }
    | Fun {
        from : TyVar;
        to : TyVar;
      }
    | Tuple {
        args : list <TyVar>;
      }
    | Array {
        t : TyVar;
        rank : int;
      }
    | Void

      /* Used when given value is required to have all the listed types.
         Invariant: the types listed cannot be in the subtyping relation
         pairwise.  This type is not expressible in the .NET type system
         directly, it can be however expressed with type variable bounds
         in some cases. */
    | Intersection {
        types : list <MType>;
      }


    /** Check for type equality, taking intersection types
        into account. */
    [Nemerle.OverrideObjectEquals]
    public Equals (t : MType) : bool
    {
    }


    /** Enforce [this] to be subtype of [t]. */
    public Require (t : MType) : void
    {
    }
  }



  /** Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types. */
  public class StaticTyVar
  {
  }


  
  /** Represents a node in constraint graph. Used during type
      inference. */
  public class TyVar
  {
    /** Require [this] to be at least [t].
    
        To be called when we require some lower constraint on type
        variable. */
    [ForwardThis (Self)]
    public Require (t : TyVar) : void
    {
      match (t.Self.state) {
        | State.Fixed (t) =>
          // delegate to specialized method
          Require (t)
        | (State.Free) as low =>
          match (state) {
            | State.Fixed (high) =>
              // we prefer working on the Free side
              t.Provide (high)
            | (State.Free) as high =>
              AddTyvarLink (low, high)
          }
      }
    }


    MergeCycle (low : State.Free, high : State.Free) : void
    {
      def free (v : TyVar) { v.Self.state :> State.Free }
      def upper = low.upper_tyvars.Sum (high.upper_tyvars);
      def lower = low.lower_tyvars.Sum (high.lower_tyvars);
      def cycle = upper.Intersect (lower).ToList ();
      def upper = Set.Sum (List.Map (cycle, fun (x) { free (x).upper_tyvars }));
      def lower = Set.Sum (List.Map (cycle, fun (x) { free (x).lower_tyvars }));
      match (cycle) {
        | x :: xs =>
          mutable lb = free (x).lower_bound;
          mutable ub = free (x).upper_bound;
          x.lower_tyvars = lower;
          x.upper_tyvars = upper;
          foreach (y in xs) {
            lb = solver.Intersect (lb, free (y).lower_bound);
            ub = solver.Sum (ub, free (y).upper_bound);
            solver.AddLink (x, y);
          }
          foreach (y in cycle) {
            def f = free (y);
            f.lower_bound = lb;
            f.upper_bound = ub;
            f.lower_tyvars = lower;
            f.upper_tyvars = upper;
          }
        | [] => assert (false)
      }
    }
    
    
    AddTyvarLink (low : State.Free, high : State.Free) : void
    {
      def upper = low.upper_tyvars.Sum (high.upper_tyvars).Replace (high);
      def lower = high.lower_tyvars.Sum (low.lower_tyvars).Replace (low);
      def have_cycle = upper [low];
      assert (have_cycle == lower [high]);
      if (have_cycle) {
        high.lower_tyvars = lower;
        low.upper_tyvars = upper;
        MergeCycle (low, high)
      } else {
        SetLowerBound (high, low.lower_bound, true);
        SetUpperBound (low, high.upper_bound, true);
        high.lower_tyvars = lower;
        low.upper_tyvars = upper;
      }
    }


    SetLowerBound (f : State.Free, t : MType, rec : bool) : void
    {
      def lb = solver.Intersect (f.lower_bound, t);
      def need_propagate = (lb : object) != f.lower_bound;
      f.lower_bound = lb;
      when (rec && need_propagate)
        f.upper_tyvars.Iter (fun (tv : TyVar) { tv.Require (lb) })
    }
    
    
    SetUpperBound (f : State.Free, t : MType, rec : bool) : void
    {
      def ub = solver.Sum (f.upper_bound, t);
      def need_propagate = (ub : object) != f.upper_bound;
      f.upper_bound = ub;
      when (rec && need_propagate)
        f.lower_tyvars.Iter (fun (tv : TyVar) { tv.Provide (ub) })
    }
    

    [ForwardThis (Self)]
    public Require (t : MType, rec : bool) : void
    {
      match (state) {
        | State.Fixed (this_mt) =>
          this_mt.Require (t)
        | (State.Free) as f =>
          // TODO check if t is a tuple, fun, void etc
          SetLowerBound (f, t, rec)
      }
    }
    
    public Require (t : MType) : void
    {
      Require (t, true)
    }
    

    /** Provide type [t] as the maximal type for [this].
        
        To be called when value of type [t] is assigned to cell of type
        [this]. Dual to [Require]. */
    [ForwardThis (Self)]
    public Provide (t : TyVar) : void
    {
      match (t.Self.state) {
        | State.Fixed (t) =>
          // delegate to specialized method
          Provide (t)
        | (State.Free) as high =>
          match (state) {
            | State.Fixed (low) =>
              // we prefer working on the Free side
              t.Require (low)
            | (State.Free) as low =>
              AddTyvarLink (low, high)
          }
      }
    }

    [ForwardThis (Self)]
    public Provide (t : MType, rec : bool) : void
    {
      match (state) {
        | State.Fixed (this_mt) =>
          t.Require (this_mt)
        | (State.Free) as f =>
          // TODO check if t is a tuple, fun, void etc
          SetUpperBound (f, t, rec)
      }
    }
    
    public Provide (t : MType) : void
    {
      Provide (t, true)
    }

    /** Make sure [t] and [this] will from now on always represent the 
        same type. */
    [ForwardThis (Self)]
    public Unify (t : TyVar) : void
    {
      Require (t);
      Provide (t);
    }


    /** Return type associated with [this] in current solution.
    
        Warning: this type may change later! */
    public CurrentValue : TyVar
    {
      get {
      }
    }


    public LowerBound : option <MType>
    {
      get {
      }
    }


    public UpperBound : option <MType>
    {
      get {
      }
    }
    

    /** Make sure [CurrentValue] won't change anymore. Return [CurrentValue].
    
        Don't use this function unless absolutely necessary. */
    public Fixate () : TyVar
    {
    }

    variant State {
      | MonoType { ty : MType; }
      | Free {
          mutable lower_tyvars : Set <TyVar>;
          mutable upper_tyvars : Set <TyVar>;
          mutable lower_bound : MType;
          mutable upper_bound : MType;
        }
    }

    mutable state : State;
    id : int;
    solver : Solver;

    static current_id : int;

    Self : TyVar
    {
      get { solver.Find (id) }
    }

    internal this (s : Solver)
    {
      solver = s;
      state = State.Free (Set (), Set (), null, null);
      id = current_id;
      ++current_id;
    }

    internal this (other : TyVar)
    {
      id = other.id;
      solver = other.solver;
      match (other.Self.state) {
        | State.Free (a, b, c, d) =>
          state = State.Free (a, b, c, d);
        | State.MonoType =>
          assert (false)
      }
    }
  }

}
