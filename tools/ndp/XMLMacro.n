namespace NemerleDoc
{

    using System.Xml;
    using System;
    using Nemerle.Collections;
    
    class SaxDefaultHandler
    {
      mutable protected cursor : XmlTextReader;
      
      /// <param name="field">Name of a field</param>
      /// <returns>Returns the value of an attribute</returns>
      internal attribute (field : string) : string { cursor[field] }
      
      private iterate () : void
      {
          do
          {
              match (cursor.NodeType) {
              
                | Element => Element(cursor.Name)
                | EndElement => EndElement(cursor.Name)
                | Text => Text(cursor.Value)
                | Document => Document()
                | EntityReference => EntityReference(cursor.Name)
                | XmlDeclaration => XmlDeclaration()
                | None => ()
                | _ => Console.WriteLine("Unsupported element {0}", cursor.NodeType)
              
              } // match
          } while (cursor.Read()) // 
      
      } // iterate
      
      // -------- public interface -------------
      
      virtual public Element(_ : string) : void {}
      virtual public EndElement(_ : string) : void {};
      virtual public Text(_ : string) : void { };
      virtual public Document () : void {}
      virtual public EntityReference (_ : string) : void { }
      virtual public XmlDeclaration () : void { }
    
      public this (filename : string)
      {
          cursor = XmlTextReader(filename);
          cursor.WhitespaceHandling = WhitespaceHandling.None;
          iterate();
      }

    } // SaxDefaultHanler
    
    variant TagName
    {
      | Summary
      | Remarks
      | Returns
      | Param
      | Example
      | Exception
      | Permission
      | Other
    }
    
    [Record]
    sealed class Handler
    {
      internal begin : void -> void;
      internal end   : void -> void    
    }
    
    /// <summary>
    /// Processes xml file
    /// </summary>
    class MyXmlHandler : SaxDefaultHandler
    {
    
      mutable buffer : string = "";
      
      tree : DataTree ;
      mutable state : TagName = TagName.Other();
      
      mutable static handlers : Hashtable [ string, Handler] ;
      
      /// <summary>
      /// Summary <see cref="anything" />
      /// </summary>
      make_handler () : void {
        handlers = Hashtable();
        
        handlers["member"] = Handler(fun () : void {tree.AddItem(this.attribute("name"))}, fun () {} );
        
        handlers["summary"] = Handler( fun () { state = TagName.Summary() },
                                       fun () {
                                             when (buffer.Length > 0) this.tree.AddComment(buffer);
                                             buffer = "";
                                             state = TagName.Other()

                                       });
                                       
        handlers["remarks"] = Handler( fun () { state = TagName.Remarks() },
                                        fun () {
                                              when (buffer.Length > 0) this.tree.AddRemark(buffer);
                                              buffer = "";
                                              state = TagName.Other()
                                        });
        
        handlers["returns"] = Handler( fun () { state = TagName.Returns() },
                                        fun () {
                                              when (buffer.Length > 0) this.tree.AddReturn(buffer);
                                              buffer = "";
                                              state = TagName.Other()
                                        });
                                        
        handlers["example"] = Handler( fun () { state = TagName.Example() },
                                        fun () {
                                              when (buffer.Length > 0) this.tree.AddExample(buffer);
                                              buffer = "";
                                              state = TagName.Other()
                                        });
                                        
        handlers["param"] = Handler(fun () {state = TagName.Param(); buffer = this.attribute("name") + ": ";},
                                fun () {
                                      when (buffer.Length > 0) this.tree.AddParam(buffer);
                                      buffer = "";
                                      state = TagName.Other()
                                });
                                
        handlers["exception"] = Handler(fun () { state = TagName.Exception(); buffer = this.attribute("cref") + ": ";},
                                fun () {
                                      when (buffer.Length > 0) this.tree.AddException(buffer);
                                      buffer = "";
                                      state = TagName.Other()
                                });
                                
        handlers["permission"] = Handler(fun () { state = TagName.Permission(); buffer = this.attribute("cref") + ": ";},
                                fun () {
                                       when (buffer.Length > 0) this.tree.AddPermission(buffer);
                                       buffer = "";
                                       state = TagName.Other()
                                });
                                
        // formatting tags                                
        handlers["code"] = Handler(fun () { buffer += "<pre>" }, fun () { buffer += "</pre>"   });
                                
        handlers["c"] = Handler(fun () { buffer += "<tt>"  }, fun () { buffer += "</tt>" });
                                 
        handlers["para"] = Handler( fun () { buffer += "<p>" }, fun () { buffer = "</p>" } );
        
        handlers["paramref"] = Handler( fun () { buffer += "<span class=\"paramref\">" }, fun () { buffer = "</span>" } );
        
        handlers["see"] = Handler( fun () {
                                      buffer += "<span class=\"see\">" + this.attribute("cref");
                                      when (this.cursor.IsEmptyElement) buffer += "</span>";
                                      }, 
                                   fun () { buffer = "</span>" } );
        
        handlers["value"] = Handler( fun () { buffer += "<div class=\"value\">" }, fun () { buffer += "</div>" });
        
        // list and list family tags
        handlers["list"] = Handler( fun () { buffer += "<ul>" }, fun () { buffer += "</ul>" });
        
        handlers["listheader"] = Handler( fun () { buffer += "<li>" }, fun () { buffer += "</li>" });
        
        handlers["item"] = Handler( fun () { buffer += "<li>" }, fun () { buffer += "</li>" });
        
        handlers["term"] = Handler( fun () { buffer += "<span class=\"term\">" }, fun () { buffer += "</span> " });
        
        handlers["description"] = Handler( fun () { buffer += "<span class=\"description\">" }, fun () { buffer += "</span>" });
        
        
        
        // not processed tags 
        handlers["doc"] = Handler(fun () {}, fun () { });
        handlers["assembly"] = Handler(fun () {}, fun () { });
        handlers["name"] = Handler(fun () {}, fun () { });
        handlers["members"] = Handler(fun () {}, fun () { });
      }
      
      public override Element ( tagName : string ) : void
      {
          if (handlers.Contains(tagName)) handlers[tagName].begin();
          else
            Console.WriteLine("*** Warning: tag '{0}' is not supported", tagName);
      }
      
            
      public override Text (text : string) : void
      {
        match (state) {
        
          | Summary
          | Remarks
          | Returns
          | Example
          | Exception
          | Permission
          | Param   => buffer += text
          | Other => ()
        }
      }
      
      public override EntityReference (text : string) : void
      {
          Console.WriteLine("Entity");
          Console.WriteLine(text);
          buffer += text;
      }
      
      public override EndElement (tagName : string ) : void 
      {
          when (handlers.Contains(tagName))
              handlers[tagName].end()
      }
      
            
      // public this(f : string) { base(f) }
      public this(tree : DataTree, file : string)
      {
        this.tree = tree;
        make_handler();
        base(file)
      }      
      
    } // MyHandler

} // namespace NemerleDoc
