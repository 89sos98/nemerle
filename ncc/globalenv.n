/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler;
using Nemerle.Utility;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

  public variant Symbol
  {
    | Sym_type { tycon : Tycon; }
    | Sym_type_member { member : IMember; }
  }

 
  public class GlobalEnv 
  {
    public variant TyconCache {
      | No
      | Cached { tycon : Tycon; }
      | NotLoaded { e : LibraryReferenceManager.ExternalType; }
      | MacroCall { m : IMacro; }
    }
    
    public class NamespaceND {
      public Name : list <string>;
      public mutable Value : TyconCache;
      mutable children : Hashtable <string, NamespaceND>;
      
      public this (n : list <string>, v : TyconCache) {
        Name <- n;
        Value <- v;
      }

      /// Walks down the tree begining at current node, spliting given
      /// name to `.' separated parts. The path is created if at some
      /// point it doesn't exist in tree.
      public Path (n : string) : NamespaceND {
        mutable cur_node <- this;
        mutable last <- 0;
        for (mutable i <- 0; i < n.Length; ++i) {
          when (n[i] == '.') {
            cur_node <- cur_node.Child (n.Substring (last, i - last));
            last <- i + 1;
          }
        };
        when (n.Length > 0 && !n.EndsWith ("."))
          cur_node <- cur_node.Child (n.Substring (last, n.Length - last));
        cur_node
      }

      public Path (n : list <string>) : NamespaceND {
        mutable cur_node <- this;
        def loop (l) {
          | x :: xs =>
            cur_node <- cur_node.Child (x);
            loop (xs)
          | _ => cur_node
        };
        loop (n)
      }
      
      public TryPath (n : list <string>) : TyconCache {
        def loop (l, cur_node : NamespaceND) {
          match (l) {
            | [x] =>
              when (cur_node.children == null)
                cur_node.children <- Hashtable (10, 1.0f);
                
              match (cur_node.children.Get (x)) {
                | Some (nd) => nd.Value
                | _ =>
                  match (x [x.Length - 1]) {
                    | '*' | '&' =>
                      def bare_name = x.TrimEnd (array ['*', '&']);
                      def (st, lib) =
                        match (cur_node.children.Get (bare_name)) {
                          | Some (nd) =>
                            match (nd.Value) {
                              | Cached (tc) =>
                                (tc.GetSystemType (), tc.GetLibraryReference ())
                              | NotLoaded (e) =>
                                (e.system_type, e.library)
                              | _ =>
                                (null, null)
                            }
                          | _ => (null, null)
                        };
                      if (st != null) {
                        def correct_name = st.FullName + x.Substring (bare_name.Length);
                        def nst = st.Assembly.GetType (correct_name);
                        def correct_name = correct_name.Replace ('+', '.');
                        assert (nst != null);

                        def res = Cached (lib.ConstructTycon (nst));
                        namespace_tree.Path (correct_name).Value <- res;
                        namespace_tree.Child (nst.Assembly.CodeBase).
                          Path (correct_name).Value <- res;
                        res
                      }
                      else
                        No ()

                    | _ =>
                      No ()
                  }
                }

            | x :: xs =>
              when (cur_node.children == null)
                cur_node.children <- Hashtable (10, 1.0f);
                
              match (cur_node.children.Get (x)) {
                | Some (nd) => loop (xs, nd)
                | _ => No ()
              }
            // we are at good namespace, so return our own Value
            | _ => Value
          }
        };
        loop (n, this)
      }

      public LookupType (split : list <string>) : option <Tycon>
      {
        match (TryPath (split)) {
          | Cached (tc) => Some (tc)
          | NotLoaded (e) =>
            def nd = Path (split);
            when (e.tycon == null) {
              when (e.message != null) {
                Message.warning ("using type `" + e.system_type.FullName + 
                                 "' that was defined in more then one assembly: " +
                                 e.message + " (the first version was used)")
              };
              e.tycon <- e.library.ConstructTycon (e.system_type);
            };
            nd.Value <- Cached (e.tycon);
            Some (e.tycon)

          | MacroCall | No => None ()
        }
      }

      public LookupValue () : option <Tycon>
      {
        LookupType ([])
      }


      public LookupMacro (split : list <string>) : option <IMacro>
      {
        match (TryPath (split)) {
          | MacroCall (m) => Some (m)
          | _ => None ()
        }
      }
      
      /// Performs one step down the tree through given edge (name).
      /// String in this edge isn't splited to `.' separated parts.
      /// In case there is no such child in current node, it is created.
      Child (name : string) : NamespaceND {
        when (children == null) children <- Hashtable (10, 1.0f);
        match (children.Get (name)) {
          | None =>
            def result = NamespaceND (List.Append (Name, [name]), No ());
            children.Add (name, result);
            result

          | Some (r) => r
        }
      }

      public override ToString () : string {
        def s = System.Text.StringBuilder ("( ");
        children.Iter (fun (x, y : NamespaceND) {
          ignore (s.Append (x + "-" + y.ToString () + ", "))
        });
        ignore (s.Append (")\n"));
        s.ToString ();
      }
    }
    
    static mutable macro_context : int;
    static macro_contexts : Hashtable <string, int>;
    static imported_contexts : array <GlobalEnv>;
    static mutable macro_context_class : ITypeModifier;
    static namespace_tree : NamespaceND;

    static this () {
      macro_context <- 0;
      macro_contexts <- Hashtable (100);
      imported_contexts <- null;
      namespace_tree <- NamespaceND ([], No ());

      Empty <- GlobalEnv ();
      Core <- Empty.AddOpenNamespace (["Nemerle", "Core"])
                   .AddOpenNamespace (["Nemerle", "Core", "Aliases"]);
    }

    open_namespaces : list <NamespaceND>;
    current_namespace : NamespaceND;
    namespace_aliases : SystemMap <string, NamespaceND>;
    mutable macro_ctx_cache : int;

    internal static AddType (ns : NamespaceND, t : Tycon) : void {
      match (ns.Value) {
        | Cached (t') when t'.SameAs (t) => ()
        | Cached (t') =>
          Message.error (t.GetLocation (), "redefinition of type `" +
                         Util.qid_of_list (ns.Name) + "'");
          Message.error (t'.GetLocation (), "first defined here")
        | _ =>
          ns.Value <- Cached (t);
      }
    }

    public static AddMacro (split : list<string>, m : IMacro) : void {
      def ns = namespace_tree.Path (split);
      match (ns.Value) {
        | No =>
          ns.Value <- MacroCall (m)

        | _ =>
          Message.error ("redefinition of `" +
                         Util.qid_of_list (split) + "'");
      }
    }
    
    expandl_namespace_aliases (sym : list <string>) : list <string> {
      | x :: (_ :: _) as rest =>
        match (namespace_aliases.Find (x)) {
          | Some (r) =>
            List.Append (r.Name, rest)
          | None => sym
        }
      | _ => sym
    }
    
    public static DefineExact (td : PT.Class_member) : ITypeModifier
    {
      Core.Define (td)
    }
    
    public Define (td : PT.Class_member) : ITypeModifier
    {
      | PT.M_type (td) =>
        def nm = Macros.NameOfSString (td.name);
        def (namesp, name) = List.DivideLast (nm.idl);
        def env = 
          match (namesp) {
            | [] => this
            | _ =>
              // store only last part as valid name
              td.name <- PT.SS_string (PT.Name ([name], nm.color, nm.context));
              // FIXME: check if user doesn't do anything nasty
              EnterIntoNamespace (current_namespace.Path (namesp))
          };
        def fullns = env.current_namespace.Path ([name]);
        def tyinfo = TypeBuilder (None (), None (), env.AddOpenNamespace (fullns), td);
        AddType (fullns, tyinfo);
        tyinfo.FixupDefinedClass ();
        match (td) {
          | PT.TD_class (decls) =>
            List.Iter (decls, fun (x : PT.Class_member) { tyinfo.Define (x) });
          | _ => ()
        };
        tyinfo
      | _ =>
        Message.error ("only types can be defined in global namespaces");
        null
    }
    
    public static LookupInternalType (name : list<string>) : Tycon {
      match (LookupExactType (name)) {
        | Some (t) => t
        | None => Util.ice ("unbound internal type " + Util.qid_of_list (name))
      }
    }

    public static LookupExactType (name : string) : option <Tycon> {
      namespace_tree.LookupType (NString.Split (name, array ['.']))
    }

    public static LookupExactType (name : list <string>) : option <Tycon> {
      namespace_tree.LookupType (name)
    }
  
    public GetType (name : list <string>, from : Tycon) : Tycon
    {
      match (LookupType (name, from)) {
        | Some (r) => r
        | None =>
          Message.fatal_error ("unbound type name `" + Util.qid_of_list (name) + "'")
      }
    }

    public static ExactPath (path : list <string>) : NamespaceND
    {
      namespace_tree.Path (path)
    }
    
    public LookupType (name : list <string>) : option <Tycon> 
    {
      LookupType (name, null)
    }
    
    public static LookupExactMacro (name : list <string>) : option <IMacro>
    {
      Empty.LookupMacro (name)
    }
    
    public LookupMacro (name : list <string>) : option <IMacro>
    {
      def name = expandl_namespace_aliases (name);
      def collect (pref : NamespaceND, res) {
        match ((res, pref.LookupMacro (name))) {  
          | (x, None) | (None, x) => x
          | (Some (x), Some (y)) when x == y => res
          | (Some (x), Some (y)) =>
            Message.error ("name `" + NString.Concat (".", name)
                           + "' is ambiguous, it could be:");
            Message.error (x.GetNamespace () + x.GetName () + " this macro");
            Message.error (y.GetNamespace () + y.GetName () + " or this macro");
            res
          }
        };
      List.FoldLeft (namespace_tree :: open_namespaces, None (), collect)
    }
    
    public LookupType (name : list <string>, from : Tycon) : option <Tycon>
    {
      def name = expandl_namespace_aliases (name);
      match (LookupExactType (name)) {
        | (Some (t)) as r when from == null || t.CanAccess (from) => r
        | _ =>
          def non_public_external (t : Tycon) {
            match (t.GetTyconKind ()) {
              | TK_NemerleType => false
              | TK_ExternalNemerleType
              | TK_ExternalNetType =>
                t.GetSystemType ().IsNotPublic
            }
          };
          def check_access (x) {
            | Some (t) when non_public_external (t) => None ()
            | Some (t) when from == null || (t : Tycon).CanAccess (from) => x
            | _ => None ()
          };
          
          def collect (pref : NamespaceND, res) {
            match ((res, check_access (pref.LookupType (name)))) {  
              | (x, None) | (None, x) => x
              | (Some (x), Some (y)) when x.SameAs (y) => res
              | (Some (x), Some (y)) =>
                Message.error ("type name `" + NString.Concat (".", name)
                               + "' is ambiguous, it could be:");
                Message.error (x.GetLocation (), "   this declaration");
                Message.error (y.GetLocation (), "   or this declaration");
                res
            }
          };
          List.FoldLeft (open_namespaces, None (), collect)
      }
    }
    
    public LookupSymbol (name : list <string>) : list <Symbol>
    {
      def name = expandl_namespace_aliases (name);
      def visited = Hashtable (10);
      def added_types = Hashtable (10);
      mutable the_name <- null;
      def split (_) {
        | [x] => the_name <- x; []
        | x :: xs => x :: split (xs)
        | [] => assert (false)
      };
      def type_part = split (name);
      // now we have type_part . the_name
      
      def lookup_members (pref : NamespaceND, acc) {
        def acc =
          match (pref.LookupType (type_part)) {
            | Some (t) when ! visited.Contains (t.GetId ()) => 
              def encapsulate (m : IMember, acc) {
                match (m.GetKind ()) {
                  | MK_type => acc // nested types already added
                  | _ => Sym_type_member (m) :: acc
                }
              };
              def members = t.LookupMember (the_name);
              visited.Add (t.GetId (), null);
              List.FoldLeft (members, acc, encapsulate)
            | _ => acc
          };
        match (pref.LookupType (name)) {
          | Some (t) when ! added_types.Contains (t.GetId ()) =>
            added_types.Add (t.GetId (), null);
            Sym_type (t) :: acc
          | _ => acc
        }
      };
      
      List.FoldLeft (namespace_tree :: open_namespaces, 
                     [], lookup_members);
    }

    /** Return what given name can be in current environment. */    
    public ExpandName (name : list<string>) : list <list <string>>
    {
      def res = 
        match (name) {
          | x :: (_ :: _) as rest =>
            match (namespace_aliases.Find (x)) {
              | Some (r) =>
                [List.Append (r.Name, rest)]
              | None =>
                []
            }
          | _ =>
            []
        };
      match (res) {
        | [] =>
          name :: List.Map (open_namespaces, fun (ns : NamespaceND) {
            List.Append (ns.Name, name)
          }) 
        | _ => res
      }
    }
      
    public AddOpenNamespace (ns : list <string>) : GlobalEnv
    {
      AddOpenNamespace (namespace_tree.Path (ns))
    }

    internal AddOpenNamespace (ns : NamespaceND) : GlobalEnv
    {
      GlobalEnv (List.Append (open_namespaces, [ns]),
                 current_namespace, namespace_aliases)
    }
    
    internal AddNamespaceAlias (short_name : string, long_name : list <string>) : GlobalEnv
    {
      AddNamespaceAlias (short_name, namespace_tree.Path (long_name))
    }

    internal AddNamespaceAlias (short_name : string, ns : NamespaceND) : GlobalEnv
    {
      GlobalEnv (open_namespaces, current_namespace,
                 namespace_aliases.Add (short_name, ns))
    }

    internal EnterIntoNamespace (pref : list <string>) : GlobalEnv
    {
      def ns = current_namespace.Path (pref);
      GlobalEnv (List.Append (open_namespaces, [ns]), ns, namespace_aliases)
    }

    internal EnterIntoNamespace (full : NamespaceND) : GlobalEnv
    {
      GlobalEnv (List.Append (open_namespaces, [full]), full, namespace_aliases)
    }
    
    this () 
    {
      current_namespace <- namespace_tree;
      open_namespaces <- [];
      namespace_aliases <- SystemMap ();
      macro_ctx_cache <- -1;
    }

    this (o : list <NamespaceND>, c : NamespaceND, n : SystemMap <string, NamespaceND>)
    {
      current_namespace <- c;
      open_namespaces <- o;
      namespace_aliases <- n;
      macro_ctx_cache <- -1;
    }

    /** Creates environment described by given string encoded for purpose
        of storing macro contexts */
    public this (coded : string)
    {
      mutable state <- 0;
      mutable last <- 0;
      mutable short <- "";
      
      current_namespace <- namespace_tree;
      open_namespaces <- [];
      namespace_aliases <- SystemMap ();
      macro_ctx_cache <- -1;
      
      for (mutable i <- 0; i < coded.Length; ++i) {
        match ((state, coded[i])) {
          | (0, '&') =>
            current_namespace <- namespace_tree.Path (coded.Substring (0, i));
            state <- 1;
            last <- i + 1;
           
          | (1, '#') =>
            open_namespaces <- namespace_tree.Path (coded.Substring (last, i - last))
                               :: open_namespaces;
            last <- i + 1;
            
          | (1, '&') =>
            open_namespaces <- namespace_tree.Path (coded.Substring (last, i - last))
                               :: open_namespaces;
            state <- 2;
            last <- i + 1;

          | (2, '#') | (2, '&') =>
            namespace_aliases <- namespace_aliases.
              Add (short, namespace_tree.Path (coded.Substring (last, i - last)));
            last <- i + 1;

          | (2, '=') =>
            short <- coded.Substring (last, i - last);
            last <- i + 1;

          | _ => ()
        }
      }
    }

    internal GetCurrentNamespaceND () : NamespaceND {
      current_namespace
    }
    
    public GetCurrentNamespace () : string
    {
      match (current_namespace.Name) {
        | [] => ""
        | _ =>
          Util.qid_of_list (current_namespace.Name) + "."
      }
    }

    // the format is Current.Namespace.&open.ns1#open.ns2&al1=alias.one#al2=alias.two&
    public GetMacroContext () : int
    {
      when (macro_ctx_cache == -1) {
        when (macro_context_class == null)
          prepare_macro_context_class ();
        
        def cmp (x, y) { System.String.CompareOrdinal (x, y) };
        def collect (k, v : NamespaceND, acc) {
          k + "=" + Util.qid_of_list (v.Name) :: acc };
        def extract (x : NamespaceND) { Util.qid_of_list (x.Name) };

        def aliases = List.Sort (namespace_aliases.Fold (collect, []), cmp);
        def spaces = List.Sort (List.Map (open_namespaces, extract), cmp);
        def coded_al = NString.Concat ("#", aliases);
        def coded_ns = NString.Concat ("#", spaces);
        def coded = System.Text.StringBuilder (Util.qid_of_list
                                               (current_namespace.Name) + "&");
        ignore (coded.Append (coded_ns + "&"));
        ignore (coded.Append (coded_al + "&"));
        match (macro_contexts.Get (coded.ToString ())) {
          | None =>
            ++macro_context;
            macro_contexts.Add (coded.ToString (), macro_context);
            macro_ctx_cache <- macro_context  
          | Some (ctx) =>
            macro_ctx_cache <- ctx
        }
      };
      macro_ctx_cache
    }

    private static LiftMacroContexts () : Parsetree.Expr
    {
      def ar = array (macro_context);
      macro_contexts.Iter (fun (k, v) {ar[v - 1] <- k});
      def make_expr (s) {
        assert (s != null); 
        <[ $(s : string) ]>
      };
      <[ array [.. $(List.Map (List.FromArray (ar), make_expr))] ]>
    }

    private static prepare_macro_context_class () : void
    {
      def ty = DefineExact (<[ decl:
        internal class _N_MacroContexts {
          private static serialized : array <string>;
          private static contexts : array <GlobalEnv>;

          static internal Get (no : int) : GlobalEnv
          {
            when (_N_MacroContexts.contexts[no - 1] == null)
              _N_MacroContexts.contexts[no - 1] <-
                Nemerle.Compiler.GlobalEnv (_N_MacroContexts.serialized[no - 1]);
            _N_MacroContexts.contexts[no - 1]
          }
          
          private this () { }
        }
      ]>);

      macro_context_class <- ty;
    }

    internal static FinishMacroContextClass () : void
    {
      def ty = macro_context_class;
      when (ty != null) {
        ty.Define (<[ decl:
          static this ()
          {
            _N_MacroContexts.serialized <- $(LiftMacroContexts ());
            _N_MacroContexts.contexts <- array ($(macro_context : int));
          } 
        ]>);
        ty.Compile ();
      }
    }

    public override ToString () : string
    {
      def aliases = namespace_aliases.Fold (fun (k, v : NamespaceND, a) {
        k + "=" + Util.qid_of_list (v.Name) :: a
      }, []);
      def openns = List.Map (open_namespaces, fun (x : NamespaceND) {
        Util.qid_of_list (x.Name) });
      "GlobalEnv(" + Util.qid_of_list (current_namespace.Name) + ": " +
                     NString.Concat (", ", List.Append (openns, aliases)) + ")"
    }

    public static Empty : GlobalEnv;
    public static Core : GlobalEnv;
  }
} // ns
