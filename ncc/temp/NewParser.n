/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#if NEWPARSER
 
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public enum TokenSeparator {
    | None 
    | Comma
    | Semicolon
/*
    public override ToString () : string {
      match (this) {
        | None => " "
        | Comma => ", "
        | Semicolon => "; "
      }
    }
*/    
  }

  class PreParserException : System.Exception { }

  /** Transforms stream of tokens from given LexerBase to token tree
      with matched brackets.
   */
  public class PreParser
  {
    lexer : LexerBase;
    mutable last_token : Token = null;

    mutable finished : bool = false;
    
    /** Parent stream is the stack of processed token nodes,
        which are already assigned to be in currently build sequence.
        For example:
          a; b; c (); d e _we_are_here_
        'a, b, c()', are alredy known to be in parent sequence,
        while 'd e' are in current temporary sequence, which might
        get added to parent_stream if separator (e.g. ';') occurs
     */
    mutable parent_stream : array [Token] = array (4000);
    mutable parent_pos : int;

    /** Currently builded stream of token nodes is an array of
        loose tokens, which have occured after last separator.
        It will probably form LooseGroup as an element of parent
        sequence or all elements will constitue parent
     */
    mutable current_stream : array [Token] = array (2000);
    mutable current_pos : int;

    public this (lex : LexerBase) {
      register_syntax_keywords (MacroRegistry.GetSyntaxExtensions (["Nemerle", "Core"]));
      lexer = lex;
    }

    /** Fetch next token (from one token buffer or lexer if it's empty */
    get_token () : Token {
      if (last_token != null) {
        def result = last_token;
        last_token = null;
        result;
      }
      else
        lexer.GetToken ()
    }

    /** Store token in our mini one token buffer */
    push_back (tok : Token) : void {
      assert (last_token == null);
      last_token = tok;
    }

    static store (tokens : ref array [Token], idx : ref int, tok : Token) : void
    {
      tokens [idx] = tok;
      ++idx;
    }

    /** links Tokens from specified subarray to form a list and return its head */
    static make_list (tokens : array [Token], start : int, end : int) : Token
    {
      for (mutable i = end - 2; i >= start; --i) 
        tokens [i].Next = tokens [i + 1];
      tokens [start]
    }

    
    public static Dump (tok : Token, ident : string) : string {
      def (open, close, sepstr, elements) =
        match (tok) {
          | Token.RoundGroup (separator, _) => ("(", ")", separator.ToString (), tok)
          | Token.BracesGroup => ("{\n" + ident, "}", ";\n" + ident, tok)
          | Token.SquareGroup => ("[", "]", ", ", tok)
          | Token.QuoteGroup  => ("<[\n", "]>", "; ", tok)
          | Token.LooseGroup  => ("", "", " ", tok)

          | _ => ("", tok.ToString (false), "", null)
        }
      def builder = System.Text.StringBuilder (open);
      when (elements != null)
        foreach (e : Token in elements) 
          _ = builder.Append (Dump (e, ident + "  ")).Append (sepstr);
      builder.Append (close).ToString ()
    }

    /** Closes both currently created LooseGroup and parent group.
        Returns list of tokens composing parent group */
    finish_parent (parent_begin : int, current_begin : int) : Token {
      finish_current (current_begin);
      def parent_group = 
        if (parent_begin == parent_pos)
          null // case of `(` `)`
        else
          make_list (parent_stream, parent_begin, parent_pos);
      parent_pos = parent_begin;
      parent_group
    }

    /** Closes currently created LooseGroup and adds it at the end of the
        parent group. After that we are ready to make another LooseGroup.

        It is called mainly when separator token occurs.
     */   
    finish_current (current_begin : int) : void {
      unless (current_begin == current_pos) {
        def loose_group = make_list (current_stream, current_begin, current_pos);
        def loose = Token.LooseGroup (current_stream [current_begin].Location, loose_group);
        store (ref parent_stream, ref parent_pos, loose);
        current_pos = current_begin;
      }
    }

    /** Handle standard situations when new bracket group is beginning
        or there is erronous situation. Any non bracket token is
        appended to current LooseGroup.

        Throws PreParserException when there is unmatched end bracket.
     */
    handle_default_token (current_begin : int, tok : Token) : void {
      match (tok) {
        | Token.BeginBrace =>
          def brace_group = parse_brace_group (tok.Location, parent_pos, current_pos);
          store (ref current_stream, ref current_pos, brace_group);
          finish_current (current_begin);

        | Token.BeginRound =>
          def round_group = parse_round_group (tok.Location, parent_pos, current_pos);
          store (ref current_stream, ref current_pos, round_group);

        | Token.BeginSquare =>
          def square_group = parse_square_group (tok.Location, parent_pos, current_pos);
          store (ref current_stream, ref current_pos, square_group);

        | Token.BeginQuote =>
          def quote_group = parse_quote_group (tok.Location, parent_pos, current_pos);
          store (ref current_stream, ref current_pos, quote_group);

        | Token.EndRound | Token.EndSquare | Token.EndQuote | Token.EndBrace =>
          push_back (tok);
          Message.error (tok.Location, "unexpected closing bracket: " + tok.ToString ());
          throw PreParserException ();

        | Token.EndOfFile =>
          Message.error (tok.Location, "unexpected end of file");
          throw PreParserException ();

        | _ => store (ref current_stream, ref current_pos, tok);
      }
    }
    
    parse_brace_group (loc : Location, parent_begin : int, current_begin : int) : Token.BracesGroup
    {
      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire brace group
          | Token.EndBrace =>
            def brace_group = finish_parent (parent_begin, current_begin);
            Token.BracesGroup (loc + tok.Location, brace_group);

          // finish current loose group
          | Token.Semicolon => finish_current (current_begin); loop ()

          | Token.EndOfFile when parent_begin == 0 =>
            def brace_group = finish_parent (parent_begin, current_begin);
            finished = true;
            Token.BracesGroup (loc + tok.Location, brace_group);
            
          | _ => handle_default_token (current_begin, tok); loop ()
        }
      }
      try { loop () :> Token.BracesGroup }
      catch { _ : PreParserException =>
        def group = finish_parent (parent_begin, current_begin);
        Token.BracesGroup (loc, group) :> Token.BracesGroup;
      }
    }

    parse_round_group (loc : Location, parent_begin : int, current_begin : int) : Token.RoundGroup
    {
      mutable separator = TokenSeparator.None;
      
      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire round group
          | Token.EndRound =>
            def round_group = finish_parent (parent_begin, current_begin);
            Token.RoundGroup (loc + tok.Location, separator, round_group);

          // finish current loose group
          | Token.Comma =>
            match (separator) {
              | TokenSeparator.None => separator = TokenSeparator.Comma;
              | TokenSeparator.Comma => ()
              | TokenSeparator.Semicolon =>
                Message.error (tok.Location, "inconsistent `,' separator (expected `;')");
            }
            finish_current (current_begin);
            loop ()

          | Token.Semicolon =>
            match (separator) {
              | TokenSeparator.None => separator = TokenSeparator.Semicolon;
              | TokenSeparator.Semicolon => ()
              | TokenSeparator.Comma =>
                Message.error (tok.Location, "inconsistent `;' separator (expected `,')");
            }
            finish_current (current_begin); 
            loop ()

          | _ => handle_default_token (current_begin, tok); loop ()
        }
      }
      try { loop () :> Token.RoundGroup }
      catch { _ : PreParserException =>
        def group = finish_parent (parent_begin, current_begin);
        Token.RoundGroup (loc, separator, group) :> Token.RoundGroup;
      }
    }

    parse_square_group (loc : Location, parent_begin : int, current_begin : int) : Token.SquareGroup
    {
      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire brace group
          | Token.EndSquare =>
            def group = finish_parent (parent_begin, current_begin);
            Token.SquareGroup (loc + tok.Location, group);

          // finish current loose group
          | Token.Comma => finish_current (current_begin); loop ()

          | _ => handle_default_token (current_begin, tok); loop ()
        }
      }
      try { loop () :> Token.SquareGroup }
      catch { _ : PreParserException =>
        def group = finish_parent (parent_begin, current_begin);
        Token.SquareGroup (loc, group) :> Token.SquareGroup;
      }
    }

    parse_quote_group (loc : Location, parent_begin : int, current_begin : int) : Token.QuoteGroup
    {
      def loop () {
        def tok = get_token ();
        match (tok) {
          // finish entire brace group
          | Token.EndQuote =>
            def group = finish_parent (parent_begin, current_begin);
            Token.QuoteGroup (loc + tok.Location, group) :> Token.QuoteGroup;

          // finish current loose group
          | Token.Semicolon => finish_current (current_begin); loop ()

          | _ => handle_default_token (current_begin, tok); loop ()
        }
      }
      try { loop () :> Token.QuoteGroup }
      catch { _ : PreParserException =>
        def group = finish_parent (parent_begin, current_begin);
        Token.QuoteGroup (loc, group) :> Token.QuoteGroup;
      }
    }


    register_syntax_keywords (extensions : list [SyntaxDefinition]) : void {
      foreach (x in extensions)
        foreach (key in x.Keywords) LexerBase.AddKeyword (key);
    }

    remove_syntax_keywords (extensions : list [SyntaxDefinition]) : void {
      foreach (x in extensions)
        foreach (key in x.Keywords) LexerBase.RemoveKeyword (key);
    }
    
    ParseTopLevel (parent_begin : int, current_begin : int) : Token
    {
      def get_qid () {
        match (get_token ()) {
          | Token.Identifier (x) =>
            match (get_token ()) {
              | Token.Operator (".", _) => x :: get_qid ()
              | t => push_back (t); [x]
            }
          | t => Message.error (t.Location, "expected qualified identifier"); []
        }
      }
      
      mutable open_usings = [];
      
      def loop () {
        def tok = get_token ();
        match (tok) {
          | Token.Keyword ("using") =>
            finish_current (current_begin);
            
            def id = get_qid ();
            match (get_token ()) {
              | Token.Semicolon as st =>
                def extensions = MacroRegistry.GetSyntaxExtensions (id);
                register_syntax_keywords (extensions);
                open_usings = extensions + open_usings;

                def using_tok = Token.Using (tok.Location + st.Location, id, extensions);
                store (ref current_stream, ref current_pos, using_tok);
                
              | Token.Operator ("=", _) =>
                def id' = get_qid ();

                def st = get_token ();
                match (st) {
                  | Token.Semicolon => ()
                  | _ => Message.error (st.Location, "expecting `;' after using alias")
                }
                
                def using_tok = Token.UsingAlias (tok.Location + st.Location, id, id');
                store (ref current_stream, ref current_pos, using_tok);
                
              | x => Message.error (x.Location, "expecting `;' or `='")
            }
            finish_current (current_begin);
            loop ()

          | Token.Keyword ("namespace") =>
            finish_current (current_begin);
            
            def id = get_qid ();
            match (get_token ()) {
              | Token.BeginBrace as br =>
                def extensions = MacroRegistry.GetSyntaxExtensions (id);
                register_syntax_keywords (extensions);

                def decls = ParseTopLevel (parent_pos, current_pos);

                remove_syntax_keywords (extensions);

                def namespace_tok = Token.Namespace (tok.Location + br.Location, id, extensions, decls);
                store (ref current_stream, ref current_pos, namespace_tok);                  

              | x => Message.error (x.Location, "expecting `{' opening namespace scope")
            }
            finish_current (current_begin);            
            loop ()
          
          // finish entire brace group
          | Token.EndBrace =>
            remove_syntax_keywords (open_usings);
            finish_parent (parent_begin, current_begin);

          // finish current loose group
          | Token.Semicolon => finish_current (current_begin); loop ()

          | Token.EndOfFile when parent_begin == 0 =>
            def brace_group = finish_parent (parent_begin, current_begin);
            finished = true;
            brace_group;
            
          | _ => handle_default_token (current_begin, tok); loop ()
        }
      }
      try { loop () }
      catch { _ : PreParserException =>
        finish_parent (parent_begin, current_begin);
      }
    }

    public ParseTopLevel () : Token {
      Token.BracesGroup (ParseTopLevel (0, 0))
    }
    
    public PreParse () : Token {
      def top = parse_brace_group (Location.Default, 0, 0);
      unless (finished) Message.error (lexer.Location, "expected end of file, encountered finishing token");
      top
    }
  }


  enum OpContext {
    | Prefix
    | Postfix
  }

  [System.Flags]
  enum TokenStoppers {
    | None   = 0x0000
    | Pipe   = 0x0001 // |
    | Equal = 0x0002 // =
    | Braces = 0x0004 // {}
    | Arrow = 0x0008 // =>
    | Colon = 0x0010 // :
    | All = Pipe %| Equal %| Braces
  }

  [Record]
  public class SyntaxDefinition {
    public Start : string;
    public Keywords : list [string];
    public MacroNamespace : GlobalEnv.NamespaceND;
    public Rules : list [Parser.GrammarElement];
    public Permute : list [SyntaxElement] -> list [SyntaxElement];
  }
  
  
  /// Reverse Polish Notation token. It is used on the stack created during translation
  /// of infix operator expression into RPN on the way to create appropriate PExpr.
  [Record]
  class OperatorInfo {
    public Name : string;
    public LeftPriority : int;
    public RightPriority : int;

    public static RoundInfo : OperatorInfo = OperatorInfo ("(", 285,286);
    public static SquareInfo : OperatorInfo = OperatorInfo ("[", 285, 286);
    public static CommaInfo : OperatorInfo = OperatorInfo (",", 300, 301);
    public static ProductInfo : OperatorInfo = OperatorInfo ("*", 260, 261);    

    public static PrefixInfos : Hashtable [string, OperatorInfo];    
    public static Infos : Hashtable [string, OperatorInfo];

    static this () {
      PrefixInfos = Hashtable ();
      PrefixInfos.Add ("-", UnaryOperatorInfo ("-", 281, 280));
      PrefixInfos.Add ("+", UnaryOperatorInfo ("+", 281, 280));      
      PrefixInfos.Add ("++", UnaryOperatorInfo ("++", 281, 280));
      PrefixInfos.Add ("--", UnaryOperatorInfo ("--", 281, 280));
      PrefixInfos.Add ("!", UnaryOperatorInfo ("!", 281, 280));
      PrefixInfos.Add ("~", UnaryOperatorInfo ("~", 281, 280));      

      Infos = Hashtable ();
      Infos.Add ("++", UnaryOperatorInfo ("++", 300, 301));
      Infos.Add ("--", UnaryOperatorInfo ("--", 300, 301));            
      Infos.Add (".", BinaryOperatorInfo (".", 290, 291));
      Infos.Add (":", BinaryOperatorInfo (":", 270, 271));
      Infos.Add (":>", BinaryOperatorInfo (":>", 270, 271));
      Infos.Add ("/", BinaryOperatorInfo ("/", 260, 261));
      Infos.Add ("%", BinaryOperatorInfo ("%", 260, 261));
      Infos.Add ("->", BinaryOperatorInfo ("->", 250, 251));      
      Infos.Add ("+", BinaryOperatorInfo ("+", 240, 241));
      Infos.Add ("-", BinaryOperatorInfo ("-", 240, 241));
      Infos.Add ("<<", BinaryOperatorInfo ("<<", 230, 231));
      Infos.Add (">>", BinaryOperatorInfo (">>", 230, 231));
      Infos.Add ("::", BinaryOperatorInfo ("::", 221, 220));      
      Infos.Add ("<", BinaryOperatorInfo ("<", 210, 211));
      Infos.Add (">", BinaryOperatorInfo (">", 210, 211));
      Infos.Add ("<=", BinaryOperatorInfo ("<=", 210, 211));
      Infos.Add (">=", BinaryOperatorInfo (">=", 210, 211));
      Infos.Add ("as", BinaryOperatorInfo ("as", 215, 301));      
      Infos.Add ("is", BinaryOperatorInfo ("is", 210, 211));
      Infos.Add ("matches", BinaryOperatorInfo ("matches", 210, 211));
      Infos.Add ("==", BinaryOperatorInfo ("==", 200, 201));
      Infos.Add ("!=", BinaryOperatorInfo ("!=", 200, 201));
      Infos.Add ("^", BinaryOperatorInfo ("^", 190, 191));
      Infos.Add ("%^", BinaryOperatorInfo ("%^", 190, 191));
      Infos.Add ("&", BinaryOperatorInfo ("&", 180, 181));
      Infos.Add ("%&", BinaryOperatorInfo ("%&", 180, 181));
      Infos.Add ("|", BinaryOperatorInfo ("|", 170, 171));
      Infos.Add ("%|", BinaryOperatorInfo ("%|", 170, 171));
      Infos.Add ("&&", BinaryOperatorInfo ("&&", 160, 161));
      Infos.Add ("%&&", BinaryOperatorInfo ("%&&", 160, 161));
      Infos.Add ("||", BinaryOperatorInfo ("||", 150, 151));
      Infos.Add ("=", BinaryOperatorInfo ("=", 141, 140));
      Infos.Add ("*=", BinaryOperatorInfo ("*=", 141, 140));
      Infos.Add ("/=", BinaryOperatorInfo ("/=", 141, 140));
      Infos.Add ("%=", BinaryOperatorInfo ("%=", 141, 140));
      Infos.Add ("+=", BinaryOperatorInfo ("+=", 141, 140));      
      Infos.Add ("-=", BinaryOperatorInfo ("-=", 141, 140));
      Infos.Add ("<<=", BinaryOperatorInfo ("<<=", 141, 140));
      Infos.Add (">>=", BinaryOperatorInfo (">>=", 141, 140));
      Infos.Add ("&=", BinaryOperatorInfo ("&=", 141, 140));
      Infos.Add ("^=", BinaryOperatorInfo ("^=", 141, 140));
      Infos.Add ("|=", BinaryOperatorInfo ("|=", 141, 140));      
      Infos.Add ("when", BinaryOperatorInfo ("when", 130, 131));
    }

    public static GetOrCreate (op : string) : OperatorInfo {
      match (Infos.Get (op)) {
        | Some (x) => x
        | None =>
          def newinfo = BinaryOperatorInfo (op, 200, 201);
          Infos.Add (op, newinfo);
          newinfo
      }
    }
  }

  class UnaryOperatorInfo : OperatorInfo {
    public this (name : string, left : int, right : int) {
      base (name, left, right);
    }
  }

  class BinaryOperatorInfo : OperatorInfo {
    public this (name : string, left : int, right : int) {
      base (name, left, right);
    }
  }
  
  class NaryOperatorInfo : OperatorInfo {
    public this (copy : OperatorInfo) {
      base (copy.Name, copy.LeftPriority, copy.RightPriority);
    }
    
    public mutable ExprsBegin : list [PExpr];
  }
    
 
  public class MainParser
  {
    mutable env : GlobalEnv;
    mutable stream : Token;
    mutable last_tok : Token;
    mutable syntax_keywords : SystemMap [string, SyntaxDefinition];

    mutable streams_stack : array [Token] = array (200);
    mutable stack_pos : int = 0;

    public this (env : GlobalEnv) {
      this.env = env;
      syntax_keywords = SystemMap ();
      def core_extensions = MacroRegistry.GetSyntaxExtensions (["Nemerle", "Core"]);
      syntax_keywords = load_syntax (core_extensions);
    }

    public ParseExpr (expr : string) : PExpr
    {
      def lexer = LexerString (expr, Location_stack.top ());
      MacroRegistry.RemoveSyntaxExtensions ();
      def preparser = PreParser (lexer);
      def _tokens = preparser.PreParse ();
      null
    }

    public static Parse (lex : LexerBase) : list [TopDeclaration]
    {
      def preparser = PreParser (lex);
      def parser = MainParser (GlobalEnv.Core);
      
      mutable result = [];
      foreach (tok : Token in preparser.ParseTopLevel ()) 
        result = parser.ParseTopLevel (tok, result);
        
      List.Rev (result);
    }
    
    #region Utility functions operating on current token stream
    push_stream (newstream : Token) : void {
      streams_stack [stack_pos] = stream;
      ++stack_pos;
      stream = newstream;
    }

    pop_stream () : void {
      --stack_pos;
      if (stack_pos > 0)
        // previous stack was stored before incrementing pointer
        stream = streams_stack [stack_pos];
      else
        stream = null;
    }

    pop_stream (finish_entity : string) : void {
      expect_empty (finish_entity);
      pop_stream ();
    }

    get_token () : Token {
      if (stream != null) {
        last_tok = stream;
        stream = stream.Next;
        last_tok
      }
      else {
        Error (last_tok, "unexpected end of token sequence");
        Token.EndOfFile (last_tok.Location)
      }
    } 

    peek_token () : Token {
      if (stream != null) stream
      else Token.EndOfFile (last_tok.Location)
    }

    peek_second_token () : Token {
      if (stream != null)
        if (stream.Next != null) stream.Next
        else Token.EndOfFile (stream.Location)
      else Token.EndOfFile (last_tok.Location)
    }

    peek_sibling_token () : Token {
      if (stream != null) stream
      else {
        def next_group = streams_stack [stack_pos - 1].Next;
        if (next_group != null)
          (next_group :> Token.LooseGroup).Child
        else
          Token.EndOfFile (last_tok.Location)
      }
    }

    jump_to_sibling () : void {
      if (stream == null) {
        streams_stack [stack_pos - 1] = streams_stack [stack_pos - 1].Next;
        stream = (streams_stack [stack_pos - 1] :> Token.LooseGroup).Child;
      }
      else
        Util.ice ("cannot jump to sibling, some tokens are still here")
    }
    
    shift_sibling () : void {
      if (stream == null) {
        jump_to_sibling ();
        shift ()
      }
      else
        shift ();
    }
    
    push_back () : void {
      stream = last_tok;
      last_tok = null;
    }
    
    shift () : void {
      if (stream != null) {
        last_tok = stream;
        stream = stream.Next;
      }
      else Error (last_tok, "unexpected end of token sequence");
    }
    
    expect_empty (msg : string) : void {
      expect_empty (stream, msg);
    }

    expect_empty (tok : Token, msg : string) : void {
      when (tok != null)
        Error (tok, "unexpected tokens after " + msg)
    }

    expect_operator (op : string) : void {
      match (get_token ()) {
        | Token.Operator (o, _) when op == o => ()
        | Token.Operator (o, _) =>
          match (peek_token ()) {
            | Token.Operator (o', _) when op == o + o' => shift (); ()
            | x => Error (x, "expecting operator `" + op + "'");
          }
        | x => Error (x, "expecting operator `" + op + "'");
      }
    }

    expect_keyword (op : string) : void {
      match (get_token ()) {
        | Token.Keyword (o) when op == o => ()
        | x =>
          Error (x, "expecting keyword `" + op + "'");
      }
    }
    
    flag_keyword (kw : string) : bool {
      match (peek_token ()) {
        | Token.Keyword (n) when n == kw => shift (); true
        | _ => false
      }
    }

    flag_sibling_keyword (kw : string) : bool {
      match (peek_sibling_token ()) {
        | Token.Keyword (k) when kw == k => shift_sibling (); true
        | _ => false
      }
    }
    
    comma_separated_list ['a] (f : void -> 'a) : list ['a] {
      def loop (acc) {
        match (peek_token ()) {
          | Token.Comma => shift (); loop (f () :: acc)
          | _ => List.Rev (acc)
        }
      };
      loop ([f ()])
    }

    should_stop (stop : TokenStoppers) : bool {
      if (stream == null) true
      else {
        match (stream) {
          | Token.LooseGroup (Token.Operator (str, _))
          | Token.Operator (str, _) =>
            match (str) {
              | "|" when stop %&& TokenStoppers.Pipe 
              | "=" when stop %&& TokenStoppers.Equal 
              | "=>" when stop %&& TokenStoppers.Arrow 
              | ":" when stop %&& TokenStoppers.Colon => true
              | _ => false
            }
          | _ => false
        }
      }
    }
    
    #endregion Utility functions operating on current token stream

    Error (tok : Token, msg : string) : void {
      Message.error (tok.Location, "parse error near " + tok.ToString (true) + ": " + msg)
    }
    
    TokenMap ['a] (tokens : Token, f : void -> 'a) : list ['a] {
      mutable result = [];
      foreach (tok : Token.LooseGroup in tokens) {
        push_stream (tok.Child);
        result = f () :: result;
        pop_stream ("group of tokens");
      }
      List.Rev (result);
    }
    
    get_splicable_id () : Splicable {
      def tok = get_token ();
      def loc = tok.Location;
      match (tok) {
        | Token.Identifier (n) => Splicable.Name (loc, Name.NameInCurrentColor (n, env))
          
        | Token.Operator ("$", _) =>
          def second = get_token ();
          match (second) {
            | Token.Identifier (id)  =>
              Splicable.Expression (loc + second.Location,
                                    PExpr.Ref (second.Location, Name.NameInCurrentColor (id, env)))

            | Token.RoundGroup (_, expr) =>
              def loc = loc + second.Location;
              def expr = parse_expr (expr);
              match (expr) {
                | PExpr.TypeEnforcement =>
                  Splicable.Expression (loc, PExpr.Spliced (second.Location, expr))

                | x => Splicable.Expression (loc, x); 
              }

            | Token.Keyword ("_") =>
              Splicable.Expression (loc + second.Location, PExpr.Wildcard (second.Location))

            | _ =>
              Error (second, "expecting expression after `$' operator");
              Splicable.Name (Name (["error"]))
          }
              
        | Token.Keyword ("_") =>
          Splicable.Name (loc, Name.NameInCurrentColor (Util.tmpname ("u"), env))
          
        | _ =>
          Error (tok, "expecting identifier");
          Splicable.Name (Name (["error"]))
      }
    }


    load_syntax (extensions : list [SyntaxDefinition]) : SystemMap [string, SyntaxDefinition]
    {
      mutable keywords = syntax_keywords;
      foreach (definition in extensions)
        keywords = keywords.Replace (definition.Start, definition);
      keywords
    }
    
   
    /** This function parses top level group updating global environment
        when entering into new namespace, using directive, class, etc.
     */
    ParseTopLevel (tok : Token, mutable acc : list [TopDeclaration]) : list [TopDeclaration]
    {
      match (tok) {
        | Token.LooseGroup (tokens) =>
          match (tokens) {
            | Token.Namespace (name, extensions, _) =>
              def begin_syntax = syntax_keywords;
              def begin_env = env;

              // update current environment
              env = env.EnterIntoNamespace (name);
              syntax_keywords = load_syntax (extensions);

              // parse elements of namespace with new environment enabled
              foreach (child : Token in tokens)
                acc = ParseTopLevel (child, acc);

              // bring env from outside of namespace
              env = begin_env;
              syntax_keywords = begin_syntax;
              acc

            | Token.Using (name, extensions) =>
              syntax_keywords = load_syntax (extensions);          
              env = env.AddOpenNamespace (name, tok.Location);
              acc

            | Token.UsingAlias (name, fullname) =>
              match (name) {
                | [name] => env = env.AddNamespaceAlias (name, fullname, tok.Location);
                | _ => Error (tok, "using alias must be simple name without dots")
              }
              acc

            | Token.SquareGroup (null) => Error (tok, "empty custom attribute"); acc

            // assembly attribute
            | Token.SquareGroup (inner) as square =>
              match (inner) {
                | Token.LooseGroup (Token.Identifier ("assembly")) =>
                  mutable assembly_custom = [square];
                  def customs = take_attributes_out (ref assembly_custom,
                                                     System.AttributeTargets.Assembly, true);

                  foreach (cust in customs)
                    AttributeCompiler.AddAssemblyAttribute (env, cust);

                  // executed only in case of [assembly: .. ] [ .. ]
                  if (square.Next != null)
                    ParseTopLevel (Token.LooseGroup (square.Next.Location, square.Next), acc)
                  else
                    acc

                | _ => ParseTypeDeclaration (tokens) :: acc
              }
            | _ => ParseTypeDeclaration (tokens) :: acc
          }

        | x => Error (x, "expecting group of tokens"); acc
      }
    }

    /** Parses toplevel type (like class, interface, etc.).
        Expects [toks] to be first token in type declaration.
     */
    ParseTypeDeclaration (toks : Token) : TopDeclaration
    {
      push_stream (toks);
      mutable customs_token = get_customs ();
      def customs = take_attributes_out (ref customs_token, System.AttributeTargets.Class, true);      
      def mods = Modifiers (get_modifiers (), customs);
      def result = ParseTypeDeclaration (mods);
      pop_stream ("type declaration");

      result;
    }

    /** Parses toplevel type (like class, interface, etc.).
        We are inside stream with modifiers and custom attributes already read.
     */
    ParseTypeDeclaration (mods : Modifiers) : TopDeclaration
    {
      def tok = get_token ();
      def res =
        match (tok) {
          | Token.Keyword (key) =>
            match (key) {
              | "type" | "class" | "struct" | "module" | "interface" | "enum"
              | "variant" =>
                /// first get name of this declartion
                def name = get_splicable_id ();
                // now generic type parameters
                def tyvars = parse_tyvars ();                  
                def t_extends =
                  match (peek_token ()) {
                    | Token.Operator (":", _) =>
                      shift ();
                      match (maybe_parse_ellipsis ()) {
                        | Some (e) => [PExpr.Ellipsis (e)]
                        | _ =>
                          // parse , separated sequence as one expression
                          comma_separated_list (fun () { parse_expr (TokenStoppers.All) });
                      }
                    | _ => []
                  };
                // where constraints for specified generic type parameters
                def typarms = parse_where_constraints (tyvars);

                mutable members = [];
                unless (key == "type")
                  match (get_token ()) {
                    | Token.BracesGroup (children) =>
                      push_stream (children);
                      
                      while (stream != null) {
                        def child = ParseClassMember ();
                        when (child != null) members = child :: members;
                      }
                      pop_stream ("type body");
                        
                    | x => Error (x, "expecting type body");
                  }

                def td =
                  match (key) {
                    | "class" => TopDeclaration.Class (typarms, t_extends, members)
                    | "struct" =>
                      mods.mods |= NemerleAttributes.Struct;
                      TopDeclaration.Class (typarms, t_extends, members)

                    | "module" =>
                      mods.mods |= NemerleAttributes.Static;
                      TopDeclaration.Class (typarms, t_extends, members)

                    | "type" =>
                      expect_operator ("=");
                      def t = parse_expr ();
                      expect_empty ("type alias declaration");
                      TopDeclaration.Alias (typarms, t)

                    | "interface" => TopDeclaration.Interface (typarms, t_extends, members)
                    | "variant" => TopDeclaration.Variant (typarms, t_extends, members)
                    | "enum" => TopDeclaration.Enum (t_extends, members)

                    | _ => Util.ice ()
                  };
                td.name = name;
                td.loc = tok.Location + name.Location;                
                td

              | "delegate" =>
                def h = parse_fun_header (null);
                def td = TopDeclaration.Delegate (h);
                expect_empty ("delegate declaraion");
                td.loc = tok.Location + h.Location;
                td

              | "macro" => 
                def header = parse_fun_header (null);
                def synt = 
                  match (peek_token ()) {
                    | Token.Keyword ("syntax") =>
                      shift ();
                      match (get_token ()) {
                        | Token.RoundGroup (TokenSeparator.Comma, _) as group =>
                          // FIXME: use parse_expr directly
                          TokenMap (group, fun () { parse_expr () });

                        | t => Error (t, "expecting comma sperated list of syntax specifiers in `()'"); []
                      }
                    | _ => []
                  }
                def expr = parse_block ([]);
                def res = TopDeclaration.Macro (header, synt, expr);
                res.loc = tok.Location + header.Location;
                res

              | _ => Error (tok, "expecting type declaration"); TopDeclaration.Delegate (null);
            }
          | x => Error (x, "expecting type declaration"); TopDeclaration.Delegate (null);
        };
      res.modifiers = mods;
      res
    }

    
    ParseClassMember () : ClassMember
    {
      match (get_token ()) {
        | Token.LooseGroup (toks) =>
          push_stream (toks);
          mutable customs = get_customs ();
          def mods = get_modifiers ();

          def tok = peek_token ();
          def result = 
            match (tok) {
              | Token.Operator ("$", _) | Token.Identifier =>
                def id = get_splicable_id ();
                mutable is_property = false;
                def (tyvars, parms) =
                  match ((peek_token (), peek_second_token ())) {
                    | (Token.SquareGroup, Token.SquareGroup) =>
                      is_property = true;
                      (parse_tyvars (), parse_parameters ());

                    | (Token.SquareGroup, Token.RoundGroup) =>
                      (parse_tyvars (), parse_parameters ());            

                    | (Token.SquareGroup, _) =>
                      is_property = true;                      
                      ((null, null), parse_parameters ());                        

                    | (Token.RoundGroup, _) =>
                      ((null, null), parse_parameters ());

                    | _ =>
                      is_property = true; // most probably it is a field or property
                      ((null, null), [])
                  }

                def ret_type = parse_return_type (false);
                def typarms = parse_where_constraints (tyvars);

                if (is_property)
                  parse_property (mods, customs, id, ret_type, parms, typarms)
                else {
                  def header = Fun_header (tok.Location + ret_type.Location,
                                           name = id,
                                           ret_type = ret_type, 
                                           parms = parms, 
                                           typarms = typarms);
                  def mcustoms = take_attributes_out (ref customs, System.AttributeTargets.Method, true);
                  parse_method (header, Modifiers (mods, mcustoms));
                }


              | Token.Keyword ("this") =>
                shift ();
                def parms = parse_parameters ();                
                def header = Fun_header (tok.Location,
                                         name = Splicable.Name (Name (["ctor."])),
                                         ret_type = PExpr.Void (),
                                         parms = parms,
                                         typarms = Typarms.Empty);
                def mcustoms = take_attributes_out (ref customs, System.AttributeTargets.Method, true);
                parse_method (header, Modifiers (mods, mcustoms));

              | Token.Keyword ("event") =>
                shift ();
                parse_event (tok.Location, mods, customs)

              | Token.Operator ("|", _) =>
                shift ();
                unless (customs matches []) Error (tok, "custom attributes not allowed on options");
                unless (mods == NemerleAttributes.None) Error (tok, "modifiers not allowed on options");              
                parse_option ()

              | _ =>
                def tcustoms = take_attributes_out (ref customs, System.AttributeTargets.Class, true);                
                def td = ParseTypeDeclaration (Modifiers (mods, tcustoms));
                ClassMember.TypeDeclaration (loc = td.loc, 
                                             name = td.name, 
                                             modifiers = td.modifiers, 
                                             td = td)
            }
          pop_stream ("class member");
          result
            
        | _ => null
      }
    }

    parse_property (mods : NemerleAttributes, mutable customs : list [Token.SquareGroup],
                    id : Splicable, ret_type : PExpr, parms : list [Fun_parm],
                    typarms : Typarms) : ClassMember
    {
     // FIXME:       | Token.Keyword ("implements") => null      
      match (peek_token ()) {
        | Token.BracesGroup as group =>
          shift ();
          mutable pcustoms = take_attributes_out (ref customs, System.AttributeTargets.Property, true);
          mutable setter = None ();
          mutable getter = None ();

          def plain_name = match (id) { | Splicable.Name (n) => n.Id | _ => "" };

          def prop_ty =
            match (parms) {
              | [parm] => PExpr.Call (PExpr.Ref (Name (["->"])), [parm.ty, ret_type])
              | [] => ret_type
              | (x :: xs) as parms =>
                def parms_prod_type =
                  List.FoldLeft (xs, x.ty, fun (fp : Fun_parm, acc) { 
                    PExpr.Call (PExpr.Ref (Name (["*"])), [acc, fp.ty])
                  });
                PExpr.Call (PExpr.Ref (Name (["->"])), [parms_prod_type, ret_type])
            }
          
          def parse_bd (p) {
            match (peek_token ()) {
              | Token.EndOfFile => (FunKind.Method ([]), FunBody.Abstract ())
              | _ =>
                def bl = parse_block (p);
                (FunKind.Method ([]), FunBody.Parsed (bl))
            };
          };

          foreach (Token.LooseGroup (toks) in group) {
            push_stream (toks);
            mutable mycustoms = get_customs ();
            def mymods = get_modifiers ();

            match (get_token ()) {
              | Token.Identifier (i) as nametok =>
                def loc = nametok.Location;
                match (i) {
                  | "get" =>
                    unless (getter matches None)
                      Message.error (loc, "property cannot have multiple getters");

                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, true);
                    def method_atts = Modifiers (mymods, method_atts);

                    def (kind, bd) = parse_bd ([]);
                    def name = Splicable.Name (loc, Name ("get_" + plain_name));
                    def fh = Fun_header (loc, name, ret_type, []);
                    getter = Some (ClassMember.Function (loc, fh.name, method_atts, fh, kind, bd));

                  | "set" =>
                    unless (setter matches None)
                      Message.error (loc, "property cannot have multiple setters");
                    
                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, false);
                    def method_atts = Modifiers (mymods, method_atts);                    

                    def par_atts = Modifiers (NemerleAttributes.None,
                      take_attributes_out (ref mycustoms, System.AttributeTargets.Parameter, true));
                    def val_n = Splicable.Name (loc, Name.NameInCurrentColor ("value", env));
                    def setter_parms = parms + [Fun_parm (val_n, ret_type, par_atts)];
                    
                    def (kind, bd) = parse_bd (setter_parms);
                    def name = Splicable.Name (loc, Name ("set_" + plain_name));
                    def fh = Fun_header (loc, typarms, name, PExpr.Void (), setter_parms);
                    setter = Some (ClassMember.Function (loc, fh.name, method_atts, fh, kind, bd));

                  | _ =>
                    def nm = Splicable.Name (loc, Name.NameInCurrentColor (i, env));
                    def t = parse_return_type (false);
                    def attrs = Modifiers (mymods, take_attributes_out
                                  (ref mycustoms, System.AttributeTargets.Field, true));
                    def embed = PExpr.Quoted (SyntaxElement.ClassMember (
                                  ClassMember.Field (loc + t.Location, nm, attrs, t)));
                    pcustoms = <[ $(Name ("PropertyEmbeddedField") : name) ($embed) ]> :: pcustoms;
                }

              | x => Error (x, "expecting property accessor"); 
            }
            pop_stream ("property member");
          }
          // FIXME: create prop type
          ClassMember.Property (id.Location + ret_type.Location, id,
                                Modifiers (mods, pcustoms), ret_type, prop_ty, parms, getter, setter)
          
          
        | Token.EndOfFile =>
          def fcustoms = take_attributes_out (ref customs, System.AttributeTargets.Field, true);
          ClassMember.Field (id.Location + ret_type.Location, id,
                             Modifiers (mods, fcustoms), ret_type)
          
        | t => Error (t, "expecting `;' or `{ }' in field / property declaration"); null
      }
    }

    parse_method (h : Fun_header, modifiers : Modifiers) : ClassMember
    {
      def parse_extern () {
        expect_keyword ("extern");
        match (get_token ()) {
          | Token.StringLiteral (s) => 
            expect_empty ("extern function name");
            s
          | x => Error (x, "expecting string after `extern'"); ""
        }
      };
      def impl =
        match (peek_token ()) {
          | Token.Keyword ("implements") =>
            shift ();
            match (maybe_parse_ellipsis ()) {
              | Some (e) => [Splicable.Expression (PExpr.Ellipsis (e))]
              | _        => comma_separated_list (fun () {
                // FIXME
                  def expr = parse_expr (TokenStoppers.All);
                  match (Util.qidl_of_expr (expr)) {
                    | Some ((qid, _)) => Splicable.Name (Name.NameInCurrentColor (qid, env))
                    | None =>
                      Message.error (expr.Location, "expected name of implemented interface method");
                      Splicable.Name (Name ([]))
                  }
                });
            }
          | _ => []
        };
      def body =
        match (peek_token ()) {
          | Token.Operator ("=", _) =>
            shift (); FunBody.Extern (parse_extern ())
            
          | Token.BracesGroup       => FunBody.Parsed (parse_block (h.parms))
          | Token.EndOfFile         => FunBody.Abstract ()
          | Token.Operator ("$", _) => FunBody.Parsed (parse_spliced_expr ())

          | x => Error (x, "expecting method body"); FunBody.Abstract ();
        };

      ClassMember.Function (header = h, name = h.name, modifiers = modifiers, 
                            loc = h.loc, body = body, kind = FunKind.Method (impl))
    }

    parse_option () : ClassMember
    {
      def new_group_beginning () {
        when (stream != null) {
          def newgroup = Token.LooseGroup (stream);
          newgroup.Next = streams_stack [stack_pos - 1];
          streams_stack [stack_pos - 1] = newgroup;
          stream = null;
        }
      }
      
      def id = get_splicable_id ();
      match (peek_token ()) {
        | Token.BracesGroup (children) =>
          shift ();
          push_stream (children);
          mutable members = [];
          while (stream != null) {
            def child = ParseClassMember ();
            when (child != null) members = child :: members;
          }
          pop_stream ();          
          def td = TopDeclaration.VariantOption (name = id, loc = id.loc,
                                                 modifiers = Modifiers.Empty,
                                                 decls = members);

          ClassMember.TypeDeclaration (loc = id.loc, name = id, 
                                       modifiers = Modifiers.Empty, td = td)

        | Token.EndOfFile =>
          ClassMember.EnumOption (id.Location, id, Modifiers.Empty, None ());
                                       
        | Token.Operator ("=", _) =>
          shift ();
          def val = Some (parse_expr (TokenStoppers.Pipe));
          new_group_beginning ();
          ClassMember.EnumOption (id.Location, id, Modifiers.Empty, val);

        | _ =>
          new_group_beginning ();
          ClassMember.EnumOption (id.Location, id, Modifiers.Empty, None ());
      }
    }

    parse_event (loc : Location, mods : NemerleAttributes,
                 mutable customs : list [Token.SquareGroup]) : ClassMember
    {
      def id = get_splicable_id ();
      def ret_type = parse_return_type (false);
      match (get_token ()) {
        | Token.BracesGroup as group =>
          mutable ecustoms = take_attributes_out (ref customs, System.AttributeTargets.Event, true);
          mutable remove = None ();
          mutable add = None ();

          def plain_name = match (id) { | Splicable.Name (n) => n.Id | _ => "" };

          def parse_bd (p) {
            match (peek_token ()) {
              | Token.EndOfFile => (FunKind.Method ([]), FunBody.Abstract ())
              | _ =>
                def bl = parse_block (p);
                (FunKind.Method ([]), FunBody.Parsed (bl))
            };
          };

          foreach (Token.LooseGroup (toks) in group) {
            push_stream (toks);
            mutable mycustoms = get_customs ();
            def mymods = get_modifiers ();

            match (get_token ()) {
              | Token.Identifier (i) as nametok =>
                def loc = nametok.Location;
                def val_n = Splicable.Name (loc, Name.NameInCurrentColor ("value", env));                
                match (i) {
                  | "remove" =>
                    unless (remove matches None)
                      Message.error (loc, "event cannot have multiple remove methods");

                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, false);
                    def method_atts = Modifiers (mymods, method_atts);                    

                    def par_atts = Modifiers (NemerleAttributes.None,
                      take_attributes_out (ref mycustoms, System.AttributeTargets.Parameter, true));

                    def method_parms = [Fun_parm (val_n, ret_type, par_atts)];
                    
                    def (kind, bd) = parse_bd (method_parms);
                    def name = Splicable.Name (loc, Name ("remove_" + plain_name));
                    def fh = Fun_header (loc, name, PExpr.Void (), method_parms);
                    remove = Some (ClassMember.Function (loc, fh.name, method_atts, fh, kind, bd) :>
                                   ClassMember.Function);

                  | "add" =>
                    unless (add matches None)
                      Message.error (loc, "event cannot have multiple add methods");
                    
                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, false);
                    def method_atts = Modifiers (mymods, method_atts);                    

                    def par_atts = Modifiers (NemerleAttributes.None,
                      take_attributes_out (ref mycustoms, System.AttributeTargets.Parameter, true));
                      
                    def method_parms = [Fun_parm (val_n, ret_type, par_atts)];
                    
                    def (kind, bd) = parse_bd (method_parms);
                    def name = Splicable.Name (loc, Name ("add_" + plain_name));
                    def fh = Fun_header (loc, name, PExpr.Void (), method_parms);
                    add = Some (ClassMember.Function (loc, fh.name, method_atts, fh, kind, bd) :>
                                ClassMember.Function);

                  | _ =>
                    def nm = Splicable.Name (loc, Name.NameInCurrentColor (i, env));
                    def t = parse_return_type (false);
                    def attrs = Modifiers (mymods, take_attributes_out
                                  (ref mycustoms, System.AttributeTargets.Field, true));
                    def embed = PExpr.Quoted (SyntaxElement.ClassMember (
                                  ClassMember.Field (loc + t.Location, nm, attrs, t)));
                    ecustoms = <[ $(Name ("EventEmbeddedField") : name) ($embed) ]> :: ecustoms;
                }

              | x => Error (x, "expecting event accessor"); 
            }
            pop_stream ("property member");
          }
          ClassMember.Event (loc + ret_type.Location, id, Modifiers (mods, ecustoms),
                             ret_type, add, remove)
          
        | Token.EndOfFile =>
          // FIXME: take out also attributes for auto methods and field
          def ecustoms = take_attributes_out (ref customs, System.AttributeTargets.Event, true);
          /// FIXME: always provide add and remove                    
          ClassMember.Event (loc + ret_type.Location, id, Modifiers (mods, ecustoms),
                             ret_type, null, null)
          
        | t => Error (t, "expecting `;' or `{ }' in event declaration"); null
      }
    }
    
    maybe_parse_ellipsis () : option [PExpr]
    {
      match (peek_token ()) {
        | Token.Operator (".", _) =>
          expect_operator ("..");
          Some (parse_spliced_expr ())
        | _ => None ()
      }
    } 
    
    get_customs () : list [Token.SquareGroup] {
      def loop (acc) {
        match (peek_token ()) {
          | Token.SquareGroup as gr =>
            shift ();
            loop (gr :: acc)

          | _ => List.Rev (acc)
        }
      }
      loop ([])
    }

    get_modifiers () : NemerleAttributes
    {
      def loop (acc) {
        def tok = peek_token ();
        match (tok) {
          | Token.Keyword (key) =>
            def add_and_loop (attr : NemerleAttributes) {
              shift ();              
              when (attr %&& acc)
                Message.error (tok.Location, "attribute '" + key + "' specified more than once");
              loop (attr %| acc)
            }
            match (key) {
              | "mutable" => add_and_loop (NemerleAttributes.Mutable)
              | "public" => add_and_loop (NemerleAttributes.Public)
              | "private" => add_and_loop (NemerleAttributes.Private)
              | "static" => add_and_loop (NemerleAttributes.Static)
              | "new" => add_and_loop (NemerleAttributes.New)
              | "protected" => add_and_loop (NemerleAttributes.Protected)
              | "internal" => add_and_loop (NemerleAttributes.Internal)
              | "abstract" => add_and_loop (NemerleAttributes.Abstract)
              | "sealed" => add_and_loop (NemerleAttributes.Sealed)
              | "override" => add_and_loop (NemerleAttributes.Override)
              | "virtual" => add_and_loop (NemerleAttributes.Virtual)
              | "volatile" => add_and_loop (NemerleAttributes.Volatile)
              | "partial" => add_and_loop (NemerleAttributes.Partial)
              | _ => acc
            }
          | _ =>
            // perform some sanity checks on the declared attributes
            when (acc %&& NemerleAttributes.Virtual &&
                  acc %&& NemerleAttributes.Override)
              Message.warning ("the `virtual' attribute is redundant, `override' implies `virtual'");
            acc
        }
      }
      loop (NemerleAttributes.None)
    }


    get_tyvar () : string * int {
      match (peek_token ()) {
        | Token.Identifier (tv) =>
          shift ();
          (tv, TypingContext.MacroColor)
        | t => Error (t, "expecting type variable"); ("error", 0)
      }
    }
    
    /** `splicing_type' is for noting, that there are spliced tyvars
     * if yes, it's PType.Spliced with expression describing their list
     * else it's PType.Void ()
     */
    parse_tyvars () : list [string * int] * PExpr
    {
      match (peek_token ()) {
        | Token.SquareGroup (null) as t =>
          shift ();
          Error (t, "expecting type variables"); (null, null)
          
        | Token.SquareGroup (children) as group =>
          push_stream ((children :> Token.LooseGroup).Child);          
          match (maybe_parse_ellipsis ()) {
            | Some (e) =>
              pop_stream ("type variables");
              shift ();              
              ([], e)

            | _ =>
              pop_stream ();
              shift (); // now we are after whole '[..]' group
              (TokenMap (group, get_tyvar), PExpr.Void ())
          }
        | _ => (null, null)
      };
    }

    parse_where_constraints (tyvars : list [string * int], splicing_type : PExpr) 
    : Typarms 
    {
      def loop (acc) {
        if (flag_keyword ("where"))
          match (maybe_parse_ellipsis ()) {
            | Some (e) => (List.Rev (acc), e)
            | _ =>
              def tv = get_tyvar ();
              expect_operator (":");
              def types = comma_separated_list (fun () { parse_expr (TokenStoppers.Braces) });
              def acc = List.FoldLeft (types, acc, fun (t, acc) { 
                Constraint (tv, t) :: acc 
              });
              loop (acc)
          }
        else (List.Rev (acc), PExpr.Void ())
      };
      if (tyvars != null) {
        def (where_cts, where_spl_t) = loop ([]);
        match ((splicing_type, where_spl_t)) {
          | (PExpr.Void, PExpr.Void) => Typarms (tyvars, where_cts)
          | _ =>
            // we have spliced type variables
            Typarms (tyvars, Constraint (("", 0), <[ $splicing_type * $where_spl_t ]>) 
                     :: where_cts)
        }
      }
      else Typarms.Empty
    }

    /**
     *  Parse plain functional header (with optional '[..]' generic parameters
     *                                 and '(..)' fun parameters)
     */
    parse_fun_header (mutable name : Splicable) : Fun_header
    {
      when (name == null) name = get_splicable_id ();
      def tyvars = parse_tyvars ();      
      def parms = parse_parameters ();
      def ret_type = parse_return_type (true);
      def typarms = parse_where_constraints (tyvars);

      Fun_header (name.Location + ret_type.Location,
                  name = name,
                  ret_type = ret_type, 
                  parms = parms, 
                  typarms = typarms)
    }
   

    /** Parse function parameter definition from given LooseGroup */
    parse_parameter () : Fun_parm {
      mutable customs_token = get_customs ();
      def customs = take_attributes_out (ref customs_token, System.AttributeTargets.Parameter, true);      
      def mods = Modifiers (get_modifiers (), customs);

      match (peek_token ()) {
        | Token.Keyword ("params") =>
          shift ();
          mods.custom_attrs = <[ System.ParamArrayAttribute ]> :: mods.custom_attrs;
        | _ => ()
      };
      def id = get_splicable_id ();
      def t =
        match (peek_token ()) {
          | Token.Operator (":", _) => shift (); parse_expr (TokenStoppers.Equal)
          | _ => PExpr.Wildcard (id.Location)
        };
      match (peek_token ()) {
        | Token.Operator ("=", _) => 
          shift ();
          def e = parse_expr ();
          mods.custom_attrs = <[ System.ComponentModel.DefaultValueAttribute ($e)
                              ]> :: mods.custom_attrs;
        | _ => ()
      };
      Fun_parm (loc = id.loc, name = id, ty = t, modifiers = mods)
    }

    parse_parameters () : list [Fun_parm] {
      def group = get_token ();
      match (group) {
        | Token.RoundGroup (_, null)
        | Token.SquareGroup (null) => []
        
        | Token.RoundGroup (TokenSeparator.Comma, child)
        | Token.RoundGroup (TokenSeparator.None, child)          
        | Token.SquareGroup (child) =>
          match (child) {
            | Token.LooseGroup (Token.Operator (".", _) as dot) =>
              push_stream (dot);
              match (maybe_parse_ellipsis ()) {
                | Some (e) =>
                  pop_stream ("ellipsis spliced expression");
                  [Fun_parm (e.loc, Splicable.Name (Name ([])), PExpr.Void (), 
                             Modifiers (NemerleAttributes.None, [e]))]
                | _ => pop_stream (); []
              }
            | _ => TokenMap (group, parse_parameter);
          }
        | _ => Error (group, "expecting function parameters"); []
      }
    }

    parse_return_type (allow_inference : bool) : PExpr {
      match (peek_token ()) {
        | Token.Operator (":", _) => shift (); parse_expr (TokenStoppers.Braces)
        | _ when allow_inference => PExpr.Wildcard (last_tok.Location)
        | t => Error (t, "expecting `:' and type specifier for class member");
          PExpr.Wildcard (last_tok.Location)
      };
    }
       
                   
    take_attributes_out (from : ref list [Token.SquareGroup], 
                         what : System.AttributeTargets,
                         comply_on_other : bool) : list [PExpr]
    {
      mutable result = [];      
      from = List.Filter (from, fun (x : Token.SquareGroup) {
        mutable removed = false;
        match (x.Child) {
          | Token.LooseGroup (first) =>
            push_stream (first);
            def target = 
              match (first) {
                | Token.Identifier ("assembly") => System.AttributeTargets.Assembly
                | Token.Identifier ("field") => System.AttributeTargets.Field
                | Token.Keyword ("event") => System.AttributeTargets.Event
                | Token.Identifier ("method") => System.AttributeTargets.Method
                | Token.Keyword ("module") => System.AttributeTargets.Module
                | Token.Identifier ("param") => System.AttributeTargets.Parameter
                | Token.Identifier ("property") => System.AttributeTargets.Property
                | Token.Identifier ("return") => System.AttributeTargets.ReturnValue
                | Token.Keyword ("type") => System.AttributeTargets.Class
                | _ => System.AttributeTargets.All
              }
            when (target != System.AttributeTargets.All) {
              shift (); // ignore target token
              expect_operator (":");
            }
            if (target %&& what || target == System.AttributeTargets.All) {
              removed = true;
              // parse body of first element in this [ , , ]
              result = parse_expr () :: result;

              // parse all remaining in current bracket group [ , , , ]
              when (x.Child.Next != null) {
                x.Child = x.Child.Next;
                foreach (group : Token in x)
                  result = parse_expr (group) :: result;
              }
            }
            else  
              when (comply_on_other)
                Error (first, $"unexpected attribute target `$(first)'");
            pop_stream ("custom attribute body");
              
          | _ => Util.ice ("broken brackets in attribute")
        }
        removed;
      });
      List.Rev (result);
    }

    parse_block (parms : list [Fun_parm]) : PExpr
    {
      def tok = get_token ();
      def loc = tok.Location;
      match (tok) {
        // entire function body may be spliced
        | Token.Operator ("$", _) =>
          push_back (); parse_spliced_expr ()

        // empty { }
        | Token.BracesGroup (x) when x == null => PExpr.Sequence (loc, [])

        // function body with embedded matching { | pat => bd | ... }
        | Token.BracesGroup (Token.LooseGroup (Token.Operator ("|", _)) as group) =>
          // convert function's parameters to tuple to be matched
          def parms_to_tupl (prs : list [Fun_parm], acc) {
            match (prs) {
              | [] => PExpr.Tuple (List.Rev (acc))
              | ({name = Splicable.Name (x); loc = l}) :: xs => 
                parms_to_tupl (xs, PExpr.Ref (l, x) :: acc)
              | x :: _  => Message.error (x.Location, "illegal spliced parameter?"); <[ () ]>
            }
          };
          push_stream (group);          
          def cases = parse_match_group ();
          pop_stream ("function body");
          match (parms) {
            | [{name = Splicable.Name (x)}] => PExpr.Match (loc, PExpr.Ref (loc, x), cases)
            | _::_::_ => 
              def tup = parms_to_tupl (parms, []);
              tup.loc = loc;
              PExpr.Match (loc, tup, cases)
              
            | [] =>             
              Message.error (loc, "functions with direct matching must have parameters"); <[ () ]>
              
            | x :: _ => Message.error (x.Location, "illegal spliced parameter?"); <[ () ]>
          }
          
        // standard body enclosed by { ... }
        | Token.BracesGroup (group) =>
          push_stream (group);
          def seq = parse_expr_sequence (TokenStoppers.None);
          pop_stream ("function body");
          PExpr.Sequence (loc, seq);

        | x =>
          Error (x, "expected `{' at the beginning of function body"); <[ () ]>
      }
    }

    make_operator_call (name : string, e1 : PExpr, e2 : PExpr) : PExpr
    {
      def loc = e1.Location + e2.Location;
      match (name) {
        | "." =>
          match (e2) {
            | PExpr.Ref (n) => PExpr.Member (loc, e1, Splicable.Name (n));
            | PExpr.Spliced (s) => PExpr.Member (loc, e1, Splicable.Expression (s));
            | _ =>
              Message.error (e2.Location, "expecting member name after `.'");
              e1
          }
        
        | "=" => PExpr.Assign (loc, e1, e2)
        | ":" => PExpr.TypeEnforcement (loc, e1, e2)
        | ":>" => PExpr.TypeConversion (loc, e1, e2)
        | "::" => PExpr.Call (loc, PExpr.Ref (loc, Name.NameInCurrentColor ("Cons", env)), [e1, e2])
        | _ => PExpr.Call (loc, PExpr.Ref (loc, Name.NameInCurrentColor (name, env)), [e1, e2])
      }
    }

    make_operator_call (name : string, e : PExpr) : PExpr
    {
      PExpr.Call (e.Location, PExpr.Ref (e.Location, Name.NameInCurrentColor (name, env)), [e])
    }
    
    make_operator_call (name : string, parms : list [PExpr]) : PExpr
    {
      match (name) {
        | "(" => PExpr.Call (List.Head (parms), List.Tail (parms))
        | "[" => PExpr.Indexer (List.Head (parms), List.Tail (parms))
        | _ => PExpr.Call (PExpr.Ref (Name (name)), parms)
      }
    }
    
    roll_exprs (exprs : ref list [PExpr], begin : list [PExpr]) : list [PExpr]
    {
      mutable result = [];
      while ((exprs : object) != begin) {
        match (exprs) {
          | x :: xs =>
            result = x :: result;
            exprs = xs;
          | _ => Util.ice ("invalidated expressions stack")
        }
      }
      result
    } 
    
    roll_operators (exprs : ref list [PExpr], ops : ref list [OperatorInfo], priority : int) : void
    {
      def loop () {
        match (ops) {
          | [] => ()
          | x :: xs =>
            // a * b + c --- *'s right is higher, than +'s left, so a*b rolls
            // when + occurs
            when (x.RightPriority >= priority) {
              // we take all expressions, which appeared after this operator
              // appeared on stack (and sometimes the one from top at that time)
              def expr = 
                match (x) {
                  | nary : NaryOperatorInfo =>
                    def parms = roll_exprs (ref exprs, nary.ExprsBegin);
                    make_operator_call (x.Name, parms)
                    
                  | _ : BinaryOperatorInfo =>
                    match (exprs) {
                      | e1 :: e2 :: rest =>
                        exprs = rest;
                        make_operator_call (x.Name, e2, e1)
                      | _ => Util.ice ("not enough parms for binary")
                    }
                  | _ =>
                    def e = List.Head (exprs);
                    exprs = List.Tail (exprs);
                    make_operator_call (x.Name, e);
                }
              
              // put new expression on the stack
              exprs = expr :: exprs;
              ops = xs;
              loop ();
            }
        }
      }
      loop ();
    }

    parse_expr () : PExpr {
      parse_expr (TokenStoppers.None);
    }
    
    /** Parse expression from current stream of tokens.
        Reading is terminated before every token from [stop]. */
    parse_expr (stop : TokenStoppers) : PExpr
    {
      mutable _expr_stack = [];
      mutable rpn_op_stack = [];
      mutable _op_context = OpContext.Prefix;

      def loop () {
        if (_op_context == OpContext.Prefix)
          match (peek_token ()) {
            | Token.Operator (".", _) =>
              expect_operator ("..");
              match (peek_token ()) {
                | Token.Operator ("$", _) =>
                  def expr = parse_spliced_expr ();
                  _expr_stack = PExpr.Ellipsis (expr.Location, expr) :: _expr_stack;
                  expect_empty ("ellipsis expression");
                  _op_context = OpContext.Postfix;
                  loop ()

                | x => Error (x, "expecting `$' after `..'"); loop ()
              }
            
            | Token.Operator (str, _) when str != "$" =>
              def info = OperatorInfo.PrefixInfos [str];
              if (info == null) {
                Error (stream, "invalid operator in prefix position");
                <[ () ]>
              }
              else {
                shift ();
                rpn_op_stack = info :: rpn_op_stack;
                // we leave prefix context here (for things like `!!expr'
                loop ();
              }

            | _ =>
              def expr = parse_embedded_expr (stop);
              _expr_stack = expr :: _expr_stack;
              // after raw expression we are in postfix context
              _op_context = OpContext.Postfix;
              loop ()
          }
        else {
          mutable group = null : Token;
          def info = 
            match (peek_token ()) {
              | Token.Operator ("*", _) =>
                NaryOperatorInfo (OperatorInfo.ProductInfo);

              | Token.Operator (str, _) =>
                match (str) {
                  | "|" when stop %&& TokenStoppers.Pipe 
                  | "=" when stop %&& TokenStoppers.Equal 
                  | "=>" when stop %&& TokenStoppers.Arrow 
                  | ":" when stop %&& TokenStoppers.Colon => null
                  | _ => OperatorInfo.GetOrCreate (str)
                }
                  
              | Token.Keyword (k) => OperatorInfo.Infos [k]
              | Token.SquareGroup as g  =>
                group = g;                
                NaryOperatorInfo (OperatorInfo.SquareInfo);

              | Token.RoundGroup as g =>
                group = g;
                NaryOperatorInfo (OperatorInfo.RoundInfo);

              | _ => null
            }
          if (info == null) {
            // this is the end of parsing, roll all operators
            roll_operators (ref _expr_stack, ref rpn_op_stack, 0);
            // there should be only one expr on the stack, return it
            match (_expr_stack) {
              | [x] => x
              | _ => Util.ice ("something different than one expression after rolling")
            }
          }
          else {
            shift ();
            roll_operators (ref _expr_stack, ref rpn_op_stack, info.LeftPriority);

            match (info) {
              | x : NaryOperatorInfo => x.ExprsBegin = List.Tail (_expr_stack);
              | _ => ()
            }
            
            // special case for x * y * z
            if (info.Name == "*") {
              _op_context = OpContext.Prefix;
              match (rpn_op_stack) {
                | x :: _ when x.Name == "*" => ()
                | _ => rpn_op_stack = info :: rpn_op_stack;
              }
            }
            else
              rpn_op_stack = info :: rpn_op_stack;

            when (group != null)
              foreach (el : Token in group)
                _expr_stack = parse_expr (el) :: _expr_stack;

            when (info is BinaryOperatorInfo)
              _op_context = OpContext.Prefix;
            
            loop ();
          }
        }
      }
      loop ();
    }
    
    /** Parse expression beginning in given LooseGroup */    
    parse_expr (group_token : Token) : PExpr
    {
      def group_token = group_token :> Token.LooseGroup;
      push_stream (group_token.Child);
      def expr = parse_expr (TokenStoppers.None);
      pop_stream ("expression in sequence");
      expr
    }

    parse_literal () : PExpr
    {
      def tok = peek_token ();
      def lit = 
        match (tok) {
          | Token.Keyword ("null") => Literal.Null ()
          | Token.Keyword ("true") => Literal.Bool (true)
          | Token.Keyword ("false") => Literal.Bool (false)
          | Token.RoundGroup (_, null) => Literal.Void ()
          | Token.StringLiteral (s) => Literal.String (s)
          | Token.ByteLiteral (n) => Literal.Byte (n)
          | Token.SByteLiteral (n) => Literal.SByte (n)
          | Token.ShortLiteral (n) => Literal.Short (n)
          | Token.UShortLiteral (n) => Literal.UShort (n)
          | Token.IntLiteral (n) => Literal.Int (n)
          | Token.UIntLiteral (n) => Literal.UInt (n)
          | Token.LongLiteral (n) => Literal.Long (n)
          | Token.ULongLiteral (n) => Literal.ULong (n)
          | Token.FloatLiteral (n) => Literal.Float (n)
          | Token.DoubleLiteral (n) => Literal.Double (n)
          | Token.DecimalLiteral (n) => Literal.Decimal (n)
          | Token.CharLiteral (c) => Literal.Char (c)
          | _ => null
        }
      if (lit != null) {
        shift ();
        PExpr.Literal (tok.Location, lit)
      }
      else null
    }

    parse_spliced_expr () : PExpr {
      def id = get_splicable_id ();
      match (id) {
        | Splicable.Expression (e) =>
          match (e) {
            | PExpr.Spliced (PExpr.TypeEnforcement) => e
            | _ => PExpr.Spliced (id.Location, e)
          }
        | Splicable.Name | Splicable.Int =>
          Message.error (id.Location, "expected spliced expression"); <[ () ]>
      }
    }

    parse_case_guard () : PExpr * option [PExpr] {
      match (parse_expr (TokenStoppers.Pipe %| TokenStoppers.Arrow)) {
        | <[ @when ($pat, $guard) ]> => (pat, Some (guard))
        | pat                        => (pat, None ())
      }
    }
   
    parse_match_case () : MatchCase {
      def loop2 (acc) {
        def res = parse_case_guard ();
        match (get_token ()) {
          | Token.Operator ("=>", _) => List.Rev (res :: acc)
          | Token.Operator ("|", _) => loop2 (res :: acc)
          | x => Error (x, "found junk after pattern"); List.Rev (res :: acc)
        }
      };

      def case_group = (stream :> Token.LooseGroup);
      push_stream (case_group.Child);
      
      // eat pattern part and '=>'
      def pats = 
        match (peek_token ()) {
          | Token.Operator ("|", _) =>
            shift ();
            match (maybe_parse_ellipsis ()) {
              | Some (e) =>
                expect_operator ("=>");
                [(PExpr.Ellipsis (e.loc, e), None ())]                  
                
              | None => loop2 ([])
            }
          | _ => loop2 ([])
        };
      // modify beginning of current group to point at match case body  
      case_group.Child = stream; 
      pop_stream ();

      def expr =
        match (parse_expr_sequence (TokenStoppers.Pipe)) {
          | [x] => x
          | l => PExpr.Sequence (case_group.Child.Location, l)
        };

      MatchCase (pats, expr)
    }
    
    parse_match_group () : list [MatchCase]
    {
      mutable result = [];
      while (stream != null) {
        result = parse_match_case () :: result
      }
      List.Rev (result)
    }
    
    parse_embedded_expr (stop : TokenStoppers) : PExpr
    {
      def lit = parse_literal ();
      if (lit != null) lit
      else {
        def tok = get_token ();
        def loc = tok.Location;

        match (tok) {
          | Token.Keyword ("void") => PExpr.Void (loc)
          | Token.Keyword ("this") => PExpr.This (loc)
          | Token.Keyword ("base") => PExpr.Base (loc)
          | Token.Keyword ("_") => PExpr.Wildcard (loc)
          | Token.Keyword ("typeof") =>
            match (get_token ()) {
              | Token.RoundGroup (TokenSeparator.None, child) when child != null =>
                PExpr.Typeof (loc, parse_expr (child))
              | x => Error (x, "expecting `(..)' with single type after `typeof'"); <[ () ]>
            }

          | Token.Keyword ("array") =>
            def rank =
              match (peek_token ()) {            
                | Token.Operator (".", _) =>
                  shift ();
                  match (get_token ()) {
                    | Token.SquareGroup (child) when child != null && child.Next == null =>
                      parse_expr (child);
                      
                    | x => Error (x, "expecting `[rank]' after `array.'"); <[ 1 ]>
                  }
                | _ => <[ 1 ]>
              }

            def body = peek_token ();              
            match (body) {
              | Token.SquareGroup | Token.Operator ("$", _) =>
                PExpr.Array (loc, rank, parse_embedded_expr (TokenStoppers.All))

              | Token.RoundGroup =>
                shift ();
                // FIXME: use parse_expr directly
                def exprs = TokenMap (body, fun () { parse_expr () });
                PExpr.EmptyArray (loc + body.Location, exprs)

              | x =>
                Error (x, "expected [ ..elements of array.. ], ( .."
                       "sizes of empty array.. )  or `array .[rank] [..]' in array creation");
                <[ () ]>
            }
            
          // tuples
          | Token.RoundGroup =>
            def exprs = TokenMap (tok, fun () { parse_expr () });
            match (exprs) {
              | [PExpr.Ellipsis] => PExpr.Tuple (loc, exprs)
              | [e] => e
              | _ => PExpr.Tuple (loc, exprs)
            }

          | Token.SquareGroup =>
            def exprs = TokenMap (tok, fun () { parse_expr () });
            def nil = PExpr.Call (loc, PExpr.Ref (loc, Name.NameInCurrentColor ("Nil", env)), []);
            List.FoldRight (exprs, nil, fun (x : PExpr, acc) {
              PExpr.Call (x.Location, PExpr.Ref (x.Location, Name.NameInCurrentColor ("Cons", env)), [x, acc])
            });

          | Token.BracesGroup (group) when !(stop %&& TokenStoppers.Braces) =>
            push_stream (group);
            def seq = parse_expr_sequence (TokenStoppers.None);
            pop_stream ("sequence of expressions");
            PExpr.Sequence (loc, seq);

          | Token.QuoteGroup (group) =>
            push_stream (group);
            def expr = parse_quotation ();
            pop_stream ("code quotation");
            expr
            
          | Token.Keyword ("ref") =>
            def refexpr = parse_expr (TokenStoppers.All);
            PExpr.ParmByRef (loc + refexpr.loc, refexpr)

          | Token.Keyword ("out") =>
            def outexpr = parse_expr (TokenStoppers.All);
            PExpr.ParmOut (loc + outexpr.loc, outexpr)

          | Token.Keyword ("throw") =>
            def exn = parse_expr (stop);
            PExpr.Throw (loc + exn.loc, exn)
            
          | Token.Keyword ("mutable") =>
            def id = get_splicable_id ();
            match (get_token ()) {
              | Token.Operator ("=", _) =>
                def val = parse_expr (stop);
                PExpr.Define (loc + val.loc, true, id, val)
              | x =>
                Error (x, "expected assignment operator ="); <[ () ]>
            };

          | Token.Keyword ("fun") =>
            def tyvars = parse_tyvars ();      
            def parms = parse_parameters ();
            def ret_type = parse_return_type (true);
            def typarms = parse_where_constraints (tyvars);

            def h = Fun_header (loc + ret_type.Location,
                                name = Splicable.Name (Name ([])),
                                ret_type = ret_type, 
                                parms = parms, 
                                typarms = typarms);
            
            def expr = parse_block (parms);
            PExpr.Lambda (h.loc, Function_decl (h, expr))

          | Token.Operator ("$", _) =>
            match (peek_token ()) {
              | Token.StringLiteral (str) =>
                shift ();
                <[ Nemerle.IO.sprint ($(str : string)) ]>
              | _ =>
                push_back ();
                parse_spliced_expr ();
            }
            
          | Token.Keyword ("match") =>
            def expr = 
              match (get_token ()) {
                | Token.RoundGroup (TokenSeparator.None, group) when group != null =>
                  parse_expr (group);
                | x => Error (x, "expecting `(expr)' after `match'"); <[ () ]>
              }
            match (get_token ()) {
              | Token.BracesGroup (group) =>
                push_stream (group);
                def result = 
                  match (maybe_parse_ellipsis ()) {
                    | Some (e) =>
                      PExpr.Match (loc, expr, [MatchCase ([], PExpr.Ellipsis (e.loc, e))]);
                                   
                    | _ => PExpr.Match (loc, expr, parse_match_group ())
                  }
                pop_stream ("match body");
                result
                
              | x => Error (x, "expecting '{' after 'match (e)'"); <[ () ]>
            }

          | Token.Keyword ("try") =>
            def try_body = parse_block ([]);
            mutable body = null; // resulting expression

            // exception handlers
            when (flag_sibling_keyword ("catch")) {
              def mktry (h : MatchCase, body) {
                match (h.patterns) {
                  | [(PExpr.TypeEnforcement (PExpr.Wildcard, t), _)] =>
                    PExpr.TryWith (loc, body, Splicable.Name (Name ([Util.tmpname ("u")])), t, h.body)
                  
                  | [(PExpr.TypeEnforcement (PExpr.Ref (id), t), _)] =>
                    PExpr.TryWith (loc, body, Splicable.Name (id), t, h.body)

                  | [(PExpr.TypeEnforcement (PExpr.Spliced (id), t), _)] =>
                    PExpr.TryWith (loc, body, Splicable.Expression (id), t, h.body)

                  | _ =>
                    Message.error (h.body.Location, "exception catch pattern must"
                                   " be in form of `| e : ExceptionType => handler'"); body
                }
              };
              match (get_token ()) {
                | Token.BracesGroup (group) =>
                  push_stream (group);
                  body = List.FoldLeft (parse_match_group (), try_body, mktry);
                  pop_stream ("exception handlers");

                | x => Error (x, "expecting handlers of exceptions")
              }
            }
            
            if (flag_sibling_keyword ("finally")) {
              def handler = parse_block ([]);
              PExpr.TryFinally (loc, body, handler)
            }
            else {
              if (body == null) {
                Message.error (loc, "expecting `catch' or `finally'");
                try_body
              }
              else body
            }

          | Token.Keyword ("def") =>
            def parse_val (id) {
              expect_operator ("=");
              def val = parse_expr (stop);
              PExpr.Define (loc + val.loc, false, id, val)
            };
            def parse_pat () {
              def pat = parse_expr (stop %| TokenStoppers.Equal);
              expect_operator ("=");
              def expr = parse_expr (stop);
              PExpr.DefPattern (loc + expr.loc, pat, expr)
            };
            def parse_funs (acc, idopt) {
              def h = parse_fun_header (idopt);
              def fd = Function_decl (h, parse_block (h.parms));
              if (flag_sibling_keyword ("and")) {
                def id = get_splicable_id ();
                parse_funs (fd :: acc, id)
              }
              else    
                PExpr.DefFunctions (loc + h.loc, List.Rev (fd :: acc))
            };

            match (maybe_parse_ellipsis ()) {
              | Some (e) =>
                PExpr.DefFunctions (loc, [Function_decl (null, PExpr.Ellipsis (e))])

              | _ =>
                match (peek_token ()) {
                  | Token.Keyword ("_")
                  | Token.Operator ("$", _) 
                  | Token.Identifier =>
                    def id = get_splicable_id ();
                    match (peek_token ()) {
                      | Token.SquareGroup 
                      | Token.RoundGroup => parse_funs ([], id)
                      | Token.Operator ("=", _) => parse_val (id)
                      | x => Error (x, "expecting `def x = expr' or `def f () { .. }'"); <[ () ]>
                    }
                  | _ => parse_pat ()                    
                }
            }

          | Token.Identifier (i) => PExpr.Ref (loc, Name.NameInCurrentColor (i, env))
            
          | Token.Keyword (k) =>
            match (syntax_keywords.Find (k)) {
              | None => Error (tok, "unexpected keyword in expression context"); <[ () ]>
              | Some (syntax_definition) =>
                parse_syntax_definition (syntax_definition, stop)                
            }

          | _ => Error (tok, "expecting expression"); <[ () ]>
        }
      }
    }

    parse_quotation () : PExpr {
      def first = get_token ();
      def loc = first.Location;

      PExpr.Quoted (loc,
        match (peek_token ()) {
          | Token.Operator (":", _) =>
            shift ();
            match (first) {
              | Token.Identifier ("ttype") =>
                SyntaxElement.TType (parse_expr ())

              | Token.Identifier ("case") =>
                SyntaxElement.MatchCase (parse_match_case ())

              | Token.Identifier ("caseguard") =>
                SyntaxElement.MatchCaseGuard (parse_case_guard ())

              | Token.Identifier ("fundecl") =>
                def h = parse_fun_header (null);
                SyntaxElement.Function (Function_decl (h, parse_block (h.parms)))

              | Token.Identifier ("parameter")
              | Token.Identifier ("funparm") =>
                SyntaxElement.Parameter (parse_parameter ())

              | Token.Identifier ("decl") =>
                SyntaxElement.ClassMember (ParseClassMember ())

              | _ => Error (first, "bad quotation type"); SyntaxElement.Expression (<[ () ]>)
            }
          | _ =>
            push_back ();
            def expr =
              match (parse_expr_sequence (TokenStoppers.None)) {
                | [x] => x
                | l => PExpr.Sequence (loc, l)
              };
            SyntaxElement.Expression (expr)
        }
      )
    }

    
 
    /** special function to parse sequence in a way allowing other functions
        switching to sibling LooseGroup of tokens. Like:
          LooseGroup (..a b c..); LooseGroup (d..)
     */
    parse_expr_sequence (stop : TokenStoppers) : list [PExpr]
    {
      mutable result = [];
      def loop () {
        unless (should_stop (stop)) {
          def group_token = stream :> Token.LooseGroup;
          push_stream (group_token.Child);
          result = parse_expr (stop) :: result;
          
          if (stop == TokenStoppers.None || stream == null) {
            pop_stream ("expression in sequence");
            shift (); // shift group in which we reached the end
            loop ();
          }
          else {
            def next = stream;
            pop_stream ();
            (stream :> Token.LooseGroup).Child = next;
          }
        }
      }
      loop ();
      List.Rev (result)
    }

    //------------- PARSING OF MACRO SYNTAX EXTENSIONS ---------------------

    parse_syntax_definition (definition : SyntaxDefinition, stop : TokenStoppers) : PExpr
    {
      def loc = last_tok.Location;
      def parms = parse_wrt_rule (definition.Rules, stop);
      PExpr.MacroCall (loc, Name ([]), definition.MacroNamespace, definition.Permute (parms))
    }
    
    parse_wrt_rule (rule : list [Parser.GrammarElement], stop : TokenStoppers) : list [SyntaxElement] {
      def find_closing (li) {
        def loop (ac, l) {
          match (l) {
            | [] => Message.fatal_error ("syntax definition do not have `)' after '(");
            | Parser.GrammarElement.GE_operator (")") :: xs =>
              (List.Rev (ac), xs)
            | x :: xs => loop (x :: ac, xs)
          }
        }
        loop ([], li)
      }

      def expect_semicolon () {
        if (stream == null)
          jump_to_sibling ();
        else
          Error (stream, "expected `;'");
      }
      
      def loop (acc, lst) {
        match (lst) {
          | Parser.GrammarElement.GE_operator ("(") :: xs =>
            def (g_elements, rest) = find_closing (xs);
            match (get_token ()) {
              | Token.RoundGroup (_, Token.LooseGroup (first) as loose) =>
                push_stream (loose);
                push_stream (first);
                def res = parse_wrt_rule (g_elements, TokenStoppers.None);
                pop_stream ("inside `()'");
                shift (); // shift the loose group, which just ended
                pop_stream ("end of `()'");
                loop (List.Rev (res) + acc, rest)

              | Token.RoundGroup as x => Error (x, "it cannot be empty"); loop (acc, rest)
              | x => Error (x, "expecting `(..)'"); loop (acc, rest);
            }

          | Parser.GrammarElement.GE_operator (";") :: xs =>
            expect_semicolon ();
            loop (acc, xs)
            
          | Parser.GrammarElement.GE_operator (n) :: xs =>
            expect_operator (n);
            loop (acc, xs)

          | Parser.GrammarElement.GE_keyword (n) :: xs =>
            unless (flag_sibling_keyword (n)) 
              Error (peek_token (), $"expected `$(n)' keyword");
            loop (acc, xs)

          | Parser.GrammarElement.GE_expression :: xs =>
            def expr = parse_expr (stop);
            loop (SyntaxElement.Expression (expr) :: acc, xs)

          | Parser.GrammarElement.GE_expression_list (_) :: _ =>
            Util.ice ("expr list?")

          | Parser.GrammarElement.GE_funparm :: xs =>
            def p = parse_parameter ();
            loop (SyntaxElement.Parameter (p) :: acc, xs)

          | Parser.GrammarElement.GE_optional (Parser.GrammarElement.GE_operator (n)) :: xs =>
            match (peek_token ()) {
              | Token.Operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
                expect_operator (n)
              | _ => ()
            };
            loop (acc, xs)

          | Parser.GrammarElement.GE_optional (Parser.GrammarElement.GE_keyword (n)) :: xs =>
            match (peek_token ()) {
              | Token.Keyword (o) when o == n => shift ();
              | _ => ()
            };
            loop (acc, xs)

          | Parser.GrammarElement.GE_optional (Parser.GrammarElement.GE_expression)
            :: Parser.GrammarElement.GE_keyword (n) :: xs =>
            match (peek_token ()) {
              | Token.Keyword (o) when o == n =>
                shift ();
                loop (SyntaxElement.Expression (null) :: acc, xs)
              | _ =>
                def expr = parse_expr (stop);
                expect_keyword (n);
                loop (SyntaxElement.Expression (expr) :: acc, xs)
            };

          | Parser.GrammarElement.GE_optional (Parser.GrammarElement.GE_expression)
            :: Parser.GrammarElement.GE_operator (";") :: xs =>
            if (stream == null) {
              shift_sibling ();
              loop (SyntaxElement.Expression (null) :: acc, xs)
            }
            else {
              def expr = parse_expr (stop);
              expect_semicolon ();
              loop (SyntaxElement.Expression (expr) :: acc, xs)
            }

          | [Parser.GrammarElement.GE_optional (Parser.GrammarElement.GE_expression)] =>
            if (stream == null)
              List.Rev (acc)
            else
              List.Rev (SyntaxElement.Expression (parse_expr ()) :: acc)
            
          | Parser.GrammarElement.GE_optional (Parser.GrammarElement.GE_expression)
            :: Parser.GrammarElement.GE_operator (n) :: xs =>
            match (peek_token ()) {
              | Token.Operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
                shift ();
                loop (SyntaxElement.Expression (null) :: acc, xs)
              | _ =>
                def expr = parse_expr (stop);
                expect_operator (n);
                loop (SyntaxElement.Expression (expr) :: acc, xs)
            };

          | x :: _ =>
            Message.fatal_error (last_tok.Location, "syntax definition of macro is ambiguous: " + x.ToString ())

          | [] => List.Rev (acc)
        }
      };

      loop ([], rule)
    }
  } // end MainParser
} // end namespace


#endif NEWPARSER
