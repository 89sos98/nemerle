/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public module Parser {
  [Record]
  public class ParenCallback {
    public opening_paren : string;
    public closing_paren : string;
    public parsing_function : void -> Expr;
  }

  [Record]
  public class KeywordCallback {
    public name : string;
    public parsing_function : void -> Expr;
  }

  [Record]
  public class CTX {
    public mutable lexer : LexerBase;
    public mutable last_token1 : Token; // most recent token
    public mutable last_token2 : Token; // one token before
    public mutable last_token3 : Token; // two tokens before
    public mutable push_back : int; // position in last_token{1,2} or 0
    public mutable in_pattern : bool;
    public parens : Hashtable <string, ParenCallback>;
    public closing_parens : Hashtable <string, int>;
    public keywords : Hashtable <string, KeywordCallback>;
  }

  public mutable ctx : CTX;
  private mutable pending_comment : string;
  private tok_semicolon : Token;

  this () 
  {
    ctx = CTX (lexer = null,
                last_token1 = null, 
                last_token2 = null, 
                last_token3 = null,
                push_back = 0,
                in_pattern = false,
                keywords = Hashtable (),
                parens = Hashtable (),
                closing_parens = Hashtable ());
    init_parens ();
    tok_semicolon = Tok_operator (";", 0);
  }

  opt_locate<'a> (f : void -> option <'a>) : option <'a> where 'a : Located 
  {
    def loc = location_here ();
    def ret = Util.locate (loc, f ());
    match (ret) {
      | Some (x) => x.loc = loc
      | None => ()
    };
    ret
  }

  /** executes given function and returns its result enriched
      by location at the beginning of parsing */
  locate<'a> (f : void -> 'a) : 'a where 'a : Located 
  {
    def loc = location_here ();
    def ret = Util.locate (loc, f ());
    when (ret != null)
      ret.loc = loc;
    ret
  }

  last_token () : Token
  {
    match (ctx.push_back) {
      | 0 => ctx.last_token1
      | 1 => ctx.last_token2
      | 2 => ctx.last_token3
      | _ => assert (false)
    }
  }

  get_token () : Token
  {
    match (ctx.push_back) {
      | 1 =>
        ctx.push_back = 0;
        ctx.last_token1
      | 2 =>
        ctx.push_back = 1;
        ctx.last_token2
      | _ =>
        def get_token () {
          def tok = 
            try
              ctx.lexer.get_token ()
            catch { e : LexerBase.Error =>
              Message.error (ctx.lexer.get_location (), "lexing problem: " + e.name);
              get_token ()
            };
          match (tok) {
            | Tok_comment (c) => pending_comment = c; get_token ()
            | t => t
          }
        };
        ctx.last_token3 = ctx.last_token2;
        ctx.last_token2 = ctx.last_token1;
        ctx.last_token1 = get_token ();
        ctx.last_token1
    }
  }

  peek_token () : Token {
    def tok = get_token ();
    push_back ();
    tok
  }
  
  push_back () : void {
    match (ctx.push_back) {
      | 1 => ctx.push_back = 2
      | 2 => Util.ice ()
      | _ => ctx.push_back = 1
    }
  }

  push_back (tok : Token) : void {
    match (ctx.push_back) {
      | 1 => ctx.push_back = 2; ctx.last_token2 = tok
      | 2 => Util.ice ()
      | _ => ctx.push_back = 1; ctx.last_token1 = tok
    }
  }
  
  shift () : void {
    ignore (get_token ()) 
  }

  location_here () : Location {
    ignore (peek_token ());
    def loc = location ();
    loc.comment = pending_comment;
    pending_comment = null;
    loc
  }

  location () : Location {
    ctx.lexer.get_location ()
  }

  public token_name (t : Token) : string {
    match (t) {
      | Tok_keyword (x) => "keyword `" + x + "'"
      | Tok_identifier (x) => "identifier `" + x + "'"
      | Tok_operator (x, _) => "operator `" + x + "'"
      | Tok_string_literal => "string literal"
      | Tok_byte_literal => "byte literal"
      | Tok_sbyte_literal => "signed byte literal"        
      | Tok_short_literal => "short literal"
      | Tok_ushort_literal => "unsigned short literal"        
      | Tok_integer_literal => "integer literal"
      | Tok_uinteger_literal => "unsigned integer literal"        
      | Tok_long_literal => "long literal"
      | Tok_ulong_literal => "unsigned long literal"        
      | Tok_float_literal => "float literal"
      | Tok_double_literal => "double literal"
      | Tok_decimal_literal => "decimal literal"        
      | Tok_char_literal => "character literal"
      | Tok_EOF => "end of file"
      | Tok_comment => "documentation comment"
    }
  }

  describe () : string {
    when (ctx.push_back != 2) {
      push_back ()
    };
    def name = token_name (peek_token ());
    "parse error near " + name + ": "
  }

  fatal_error<'a> (msg : string) : 'a {
    Message.fatal_error (location (), describe () + msg)
  }

  error (msg : string) : void {
    Message.error (location (), describe () + msg)
  }

  get_qid (first : list <string>) : list <string> {
    def loop (acc) {
      match (get_token ()) {
        | Tok_operator (".", _) =>
          match (get_token ()) {
            | Tok_identifier (x) => loop (x :: acc)
            | _ => fatal_error ("expecting identifier after dot in qualified ID")
          }
        | _ =>
          push_back ();
          List.Rev (acc)
      }
    };

    match (get_token ()) {
      | Tok_identifier (x) =>
        // reversed accumulator
        loop (x :: first)
      | _ => fatal_error ("expecting qualified identifier")
    }
  }

  get_splicable_qid () : Splicable_string {
    match (peek_token ()) {
      | Tok_identifier => SS_string (Name (get_qid ([])))
        
      | Tok_operator ("$", _) => get_splicable_id ()
        
      | _ => fatal_error ("expecting qualified identifier")
    }
  }
  
  get_id () : string {
    match (get_token ()) {
      | Tok_identifier (x) => x
        
      | _ => fatal_error ("expecting identifier")
    }
  }
  
  get_id_or_dummy () : string {
    match (get_token ()) {
      | Tok_identifier (x) => x
        
      | Tok_keyword ("_") => Util.tmpname ("u")
        
      | _ => fatal_error ("expecting identifier")
    }
  }
  
  get_splicable_id () : Splicable_string {
    def loc = location_here ();
    match (get_token ()) {
      | Tok_identifier (n) => SS_string (loc, Name ([n]))
      | Tok_operator ("$", _) =>
        match (get_token ()) {
          | Tok_identifier (id) =>
            if (ctx.in_pattern)
              SS_spliced_expr (loc, E_spliced_patt (P_variable (location (),
                                                                Name ([id]))))
            else
              SS_spliced_expr (loc, E_ref (location (), Name ([id])))
          | Tok_operator ("(", _) =>
            def expr =
              if (ctx.in_pattern)
                E_spliced_patt (parse_pattern ())
              else
                parse_expr ();
            match (peek_token ()) {
              | Tok_operator (":", _) =>
                shift();
                match (get_token ()) {
                  | Tok_identifier (ty) =>
                    match (ty) {
                      | "int" | "string" | "bool" | "float" | "double"
                      | "uint" | "byte" | "sbyte" | "short" | "ushort" | "long"
                      | "char"  | "decimal" | "ulong"
                      | "dyn" | "name" | "typed" =>
                        expect_operator (")");
                        SS_spliced_expr (loc, E_spliced_special (ty, expr))
                      | _ =>
                        fatal_error ("wrong splicing type after ':'")
                    }
                  | _ =>
                    fatal_error ("expecting splicing type after ':'")
                }
              | _ =>
                expect_operator (")");
                SS_spliced_expr (loc, expr);
            }
          | Tok_keyword ("_") =>
            SS_spliced_expr (loc, E_spliced_patt (P_underscore (location ())))
          | _ =>
            fatal_error ("expecting identifier or '(' after '$'")
        }
      | Tok_keyword ("_") => 
        SS_string (loc, Name ([Util.tmpname ("u")]))
      | _ => fatal_error ("expecting identifier")
    }
  }

  get_tyvar () : string {
    match (get_token ()) {
      | Tok_identifier (tv) => tv
      | _ => fatal_error ("expecting type variable")
    }
  }

  expect_operator (op : string) : void {
    match (get_token ()) {
      | Tok_operator (o, _) when op == o => ()
      | Tok_operator (o, _) when o.StartsWith (op) =>
        push_back (Tok_operator (o.Substring (op.Length), 0))
      | Tok_operator (o, _) =>
        match (peek_token ()) {
          | Tok_operator (o', _) when op == o + o' => shift (); ()
          | _ => fatal_error ("expecting operator `" + op + "'");
        }
      | _ =>
        fatal_error ("expecting operator `" + op + "'");
    }
  }

  expect_keyword (op : string) : void {
    match (get_token ()) {
      | Tok_keyword (o) when op == o => ()
      | _ =>
        fatal_error ("expecting keyword `" + op + "'");
    }
  }

  flag_keyword (kw : string) : bool {
    match (get_token ()) {
      | Tok_keyword (n) when n == kw => true
      | _ => push_back (); false
    }
  }

  parse_funparm (allow_inference : bool) : Fun_parm {
    def atts = get_attrs ();
    match (peek_token ()) {
      | Tok_keyword ("params") =>
        shift ();
        atts.attrs = <[ System.ParamArrayAttribute ]> :: atts.attrs;
      | _ => ()
    };
    def id = get_splicable_id ();
    def loc = location ();
    def t =
      match (get_token ()) {
        | Tok_operator (":", _) => parse_type ()
        | _ when allow_inference => push_back (); T_infer ()
        | _ => fatal_error ("expecting typing constraint after parameter name")
      };
    match (peek_token ()) {
      | Tok_operator ("=", _) => 
        shift ();
        def e = parse_expr ();
        atts.attrs = <[ System.ComponentModel.DefaultValueAttribute ($e) ]> :: atts.attrs;
      | _ => ()
    };
    Fun_parm (loc = loc, name = id, ty = t, modifiers = atts)
  }

  // `splicing_type' is for noting, that there are spliced tyvars
  // if yes, it's T_spliced with expression describing their list
  // else it's T_void ()
  parse_tyvars () : list <string> * Type
  {
    match (get_token ()) {
      | Tok_operator ("<", _) =>
        match (peek_token ()) {
          | Tok_operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | SS_string =>
                fatal_error ("expected spliced expression")
              | SS_spliced_expr (e) =>
                expect_operator (">");                    
                ([], T_spliced (e))
            }
          | _ =>
            def tyvars = operator_separated_list (",", get_tyvar);
            expect_operator (">");
            (tyvars, T_void ())
        }
      | _ => push_back (); ([], T_void ())
    };
  }
  
  /** eats exactly header with [name], [(parameters)] and inferencable [: type] */
  parse_fun_header (allow_inference : bool, 
                    allow_ctor : bool,
                    is_lambda : bool, 
                    knownname : option <Splicable_string>) : Fun_header
  {
    locate (fun () {
      mutable is_ctor = false;
      
      def name = 
        match (knownname) {
          | None =>
            match (peek_token ()) {
              | Tok_keyword ("this") when allow_ctor => 
                shift ();
                is_ctor = true; SS_string (Name ([".ctor"]))
              | Tok_keyword ("fun") when is_lambda =>
                shift (); SS_string (Name ([]))
              | _ when is_lambda => fatal_error ("expecting `fun'")
              | Tok_identifier  
              | Tok_operator ("$", _) => get_splicable_id ()
              | _ => fatal_error ("expecting function name")
            }
          | Some (n) => n
        };
      def (tyvars, splicing_type) = parse_tyvars ();
      expect_operator ("(");
      def parse_parm () { parse_funparm (allow_inference) };
      def parms =
        match (peek_token ()) {
          | Tok_operator (")", _) => []
          | Tok_operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                  [Fun_parm (e.loc, SS_string (Name ([])), <[ type: void ]>, 
                             Modifiers (NemerleAttributes.None, [E_spliced (e)]))]
              | SS_string =>
                fatal_error ("expected spliced expression")
              }
          | _ => operator_separated_list (",", parse_parm)
        };
      expect_operator (")");
      
      def ret_type =
        match (get_token ()) {
          | _ when is_ctor => push_back (); T_void ()
          | Tok_operator (":", _) => parse_type ()
          | _ when allow_inference => push_back (); T_infer ()
          | _ => fatal_error ("expecting typing constraint on function return value")
        };

      def typarms = parse_where_constraints (tyvars, splicing_type);

      Fun_header (name = name,
                  ret_type = ret_type, 
                  parms = parms, 
                  typarms = typarms)
    })
  }

  parse_literal () : option <Literal> {
    match (get_token ()) {
      | Tok_keyword ("null") => Some (L_null ())
      | Tok_keyword ("true") => Some (L_bool (true))        
      | Tok_keyword ("false") => Some (L_bool (false))
      | Tok_operator ("(", _) =>
        match (get_token ()) {
          | Tok_operator (")", _) => Some (L_void ())
          | _ => push_back (); push_back (); None ()
        }
      | Tok_string_literal (s) => Some (L_string (s))
      | Tok_byte_literal (n) => Some (L_byte (n))
      | Tok_sbyte_literal (n) => Some (L_sbyte (n))
      | Tok_short_literal (n) => Some (L_short (n))
      | Tok_ushort_literal (n) => Some (L_ushort (n))
      | Tok_integer_literal (n) => Some (L_int (n))
      | Tok_uinteger_literal (n) => Some (L_uint (n))
      | Tok_long_literal (n) => Some (L_long (n))
      | Tok_ulong_literal (n) => Some (L_ulong (n))
      | Tok_float_literal (n) => Some (L_float (n))
      | Tok_double_literal (n) => Some (L_double (n))
      | Tok_decimal_literal (n) => Some (L_decimal (n))                
      | Tok_char_literal (c) => Some (L_char (c))
      | _ => push_back (); None ()
    }
  }

  parse_closed_prim_expr () : Expr {
    def loc = location_here ();
    match (parse_literal ()) {
      | Some (l) => E_literal (loc, l)
      | None =>
        def problem () {
          Message.fatal_error (loc, describe () + "expecting primary expression")
        };
        
        match (get_token ()) {
          | Tok_keyword ("this") => E_this (loc)
          | Tok_keyword ("base") => E_base (loc)
          | Tok_keyword ("typeof") => 
            expect_operator ("(");
            def type_expr = parse_type ();
            expect_operator (")");
            E_typeof (loc, type_expr)
            
          | Tok_identifier (n) => E_ref (loc, Name ([n]))
          | Tok_operator ("(", _) =>
            def expr = parse_expr ();
            match (get_token ()) {
              | Tok_operator (":>", _) =>
                def t = parse_type ();
                expect_operator (")");
                E_type_conversion (loc, expr, t)

              | Tok_operator (":", _) =>
                def t = parse_type ();
                expect_operator (")");
                E_type_enforcement (loc, expr, t)

              | Tok_operator (",", _) =>
                def exprs = expr :: operator_separated_list (",", parse_expr);
                expect_operator (")");
                E_tuple (loc, exprs)
                
              | Tok_operator (")", _) => 
                match (expr) {
                  | E_expr_list => E_tuple (loc, [expr])
                  | _ => expr
                }

              | _ => Message.fatal_error (loc, "unbalanced `('")
            }

          | Tok_operator ("$", _) =>
            push_back ();
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                match (e) {
                  | E_spliced_special => e
                  | _ =>
                    if (ctx.in_pattern)
                      e
                    else
                      E_spliced (e)
                }
              | SS_string =>
                Util.ice ("expected spliced expression")
            }

          | Tok_operator (o, _) =>
            def parse_paren (p : ParenCallback) {
              def expr = p.parsing_function ();
              expect_operator (p.closing_paren);
              expr
            };

            def loop (i, o : string) {
              if (i > 0)
                match (ctx.parens.Get (o.Substring (0, i))) {
                  | Some (x)  => (i, Some (x))
                  | _ => loop (i - 1, o)
                }
              else
                (0, None ())
            };
            
            match (ctx.parens.Get (o)) {
              | Some (p) => parse_paren (p)
              | None =>
                match (loop (o.Length - 1, o)) {
                  | (i, Some (p)) =>
                    push_back (Tok_operator (o.Substring (i), 0));
                    parse_paren (p)
                  | (_, None) =>
                    match (get_token ()) {
                      | Tok_operator (o', _) =>
                        match (ctx.parens.Get (o + o')) {
                          | Some (p) => parse_paren (p)
                          | None => push_back (); problem ()
                        }
                      | _ => push_back (); problem ()
                    }
                }
            }
            
          | _ => problem ()
        }
    }
  }

  parse_prim_expr () : Expr {
    def loop (expr : Expr) {
      match (get_token ()) {
        | Tok_operator ("[", _) =>
          def exprs = operator_separated_list (",", parse_expr);
          expect_operator ("]");
          loop (E_indexer (expr.loc, expr, exprs))
          
        | Tok_operator (".", _) => 
          def id = get_splicable_id ();
          loop (E_member (expr.loc, expr, id))
          
        | Tok_operator ("(", _) =>
          def parms =
            match (peek_token ()) {
              | Tok_operator (")", _) => shift (); []
              | _ => 
                def parms = operator_separated_list (",", parse_expr);
                expect_operator (")");
                parms
            };
          loop (E_call (expr.loc, expr, parms))

        | _ => push_back (); expr
      }
    };

    loop (parse_closed_prim_expr ())
  }

  parse_unary_expr () : Expr {
    match (peek_token ()) {
      | Tok_operator ("(", _)
      | Tok_operator ("$", _) => parse_prim_expr ()

      | Tok_operator (".", _) =>
        expect_operator ("..");
        match (get_splicable_id ()) {
          | SS_spliced_expr (e) =>
            E_expr_list (e.loc, E_spliced (e))                
          | SS_string =>
            fatal_error ("expected spliced expression")
        }

      | Tok_operator (o, pri) =>
        def loc = location ();
        def unary () {
          when (pri == 0) {
            fatal_error ("operator `" + o + "' cannot be used in unary context")
          };
          shift ();
          E_call (loc, E_ref (loc, Name ([o])), [parse_unary_expr ()])
        };
        
        if (ctx.parens.Contains (o))
          parse_prim_expr ()
        else {
          shift ();
          def tok = peek_token ();
          push_back ();
          match (tok) {
            | Tok_operator (o', _) =>
              if (ctx.parens.Contains (o + o'))
                parse_prim_expr ()
              else unary ()
            | _ => unary ()
          }
        }
      | _ => parse_prim_expr ()
    }
  }

  parse_pattern () : Pattern {
    def loop () {
      def loc = location_here ();
      def pat = parse_closed_pattern ();
      match (peek_token ()) {
        | Tok_operator ("::", _) => 
          shift (); 
          P_cons (loc, SS_string (Name (["Cons"])), P_tuple (loc, [pat, loop ()]))
        | _ => pat
      }
    };

    loop ()
  }

  parse_pattern_after_id (id : Splicable_string) : Pattern {
    def id = 
      match (peek_token ()) {
        | Tok_operator (".", _) =>
          shift ();
          match (id) {
            | SS_string ({ idl = n }) => SS_string (Name (get_qid (n)))
            | _ =>
              fatal_error ("mixing spliced names with regular ids isn't allowed")
          }
        | _ => id;
      };
    def loc = location ();
    match (peek_token ()) {
      | Tok_operator ("{", _)
      | Tok_operator ("(", _) => 
        P_cons (loc, id, tuple_or_record ()) 
      | Tok_keyword ("_") => 
        shift ();
        P_cons (loc, id, P_underscore (loc))
      | _ =>
        match (id) {
          | SS_string => P_cons (loc, id, P_underscore (loc))
          | SS_spliced_expr (E_spliced_special (ty, expr)) =>
            P_spliced_special (loc, ty, expr)
          | SS_spliced_expr (expr) =>
            P_spliced (loc, expr)
        }
    }
  }

  /** this function expects first '{' to be already shifted, starting
      its scanning routine from inside of record;
      but it shifts the ending '}'
   */
  parse_record () : Pattern {
    def loop (acc) {
      match (get_token ()) {
        | Tok_operator ("}", _) => List.Rev (acc)
        | Tok_identifier (n) =>
          expect_operator ("=");
          def pat = parse_pattern ();
          def res = (n, pat);
          match (get_token ()) {
            | Tok_operator (";", _) => ()
            | Tok_operator ("}", _) => push_back ()
            | _ => fatal_error ("found junk after pattern in record")
          };
          loop (res :: acc)
        | _ => fatal_error ("expecting named pattern")
      }
    };
    def loc = location ();
    match (peek_token ()) {
      | Tok_operator (".", _) =>
        expect_operator ("..");
        match (get_splicable_id ()) {
          | SS_spliced_expr (e) =>
            expect_operator ("}");
            P_record ([("", P_patt_list (loc, P_spliced (e)))]);
          | SS_string =>
            fatal_error ("expected spliced expression")
        }
      | _ =>
        P_record (loc, loop ([]))
    }
  }

  tuple_or_record () : Pattern {
    match (get_token ()) {
      | Tok_operator ("(", _) =>
        def pats = operator_separated_list (",", parse_pattern);
        expect_operator (")");
        P_tuple (location_here (), pats)
      | Tok_operator ("{", _) => parse_record ()
      | _ => fatal_error ("expecting tuple or record pattern")
    }
  }
    
  parse_closed_pattern () : Pattern {
    def loc = location_here ();
  
    match (parse_literal ()) {
      | Some (l) => P_literal (loc, l)
      | None =>
        match (get_token ()) {
          | Tok_operator ("-", _) =>
            match (parse_literal ()) {
              | Some (L_int (v)) => P_literal (loc, L_int (-v))
              | _ => 
                fatal_error ("expecting integer literal")
            }          
         
          | Tok_operator ("+", _) =>
            match (parse_literal ()) {
              | Some (L_int (v)) => P_literal (loc, L_int (v))
              | _ => 
                fatal_error ("expecting integer literal")
            }
            
          | Tok_operator ("$", _) 
          | Tok_identifier =>
            push_back ();
            def id = get_splicable_id ();
            parse_pattern_after_id (id)
            
          | Tok_operator ("{", _) =>
            parse_record ()

          | Tok_operator (".", _) =>
            expect_operator (".");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                P_patt_list (e.loc, P_spliced (e))
              | SS_string =>
                fatal_error ("expected spliced expression")
            }
            
          | Tok_operator ("(", _) =>
            def pat = parse_pattern ();
            match (get_token ()) {
              | Tok_operator (",", _) =>
                def pats = pat :: operator_separated_list (",", parse_pattern);
                expect_operator (")");
                P_tuple (loc, pats)
              | Tok_operator (")", _) =>
                match (peek_token ()) {
                  | Tok_keyword ("as") =>
                    shift ();
                    def id = get_splicable_id ();
                    P_as (loc, pat, id)
                    
                  | _ =>
                    P_tuple (loc, [pat])
                }
              | Tok_operator (":", _) =>
                def ty = parse_type ();
                expect_operator (")");
                def name =
                  match (pat) {
                    | P_underscore => None ()
                    | P_cons (n, P_underscore) => Some (n)
                    | _ =>
                      fatal_error ("the `(x : type)' pattern expects `x' to be"
                                   " a variable or a `_'")
                  };
                P_has_type (loc, name, ty)
                
              | _ =>
                fatal_error ("expecting `,' or ')' in tuple pattern")
            }

          | Tok_keyword ("_") =>
            P_underscore (loc)

          | Tok_operator ("[", _) =>
            def loop () {
              match (get_token ()) {
                | Tok_operator (",", _) =>
                  match (peek_token ()) {
                    | Tok_operator ("]", _) => 
                      P_cons (SS_string (Name (["Nil"])), P_underscore ())
                    | _ => 
                      def p = parse_pattern ();
                      P_cons (p.loc, SS_string (Name (["Cons"])),
                              P_tuple (p.loc, [p, loop ()]))
                  }
                | Tok_operator ("]", _) =>
                  P_cons (SS_string (Name (["Nil"])), P_underscore ())
                | _ => fatal_error ("expecting pattern in list")
              }
            };

            match (peek_token ()) {
              | Tok_operator ("]", _) => shift (); 
                P_cons (SS_string (Name (["Nil"])), P_underscore ())
              | _ =>
                def p = parse_pattern ();
                P_cons (p.loc, SS_string (Name (["Cons"])), P_tuple (p.loc, [p, loop ()]))
            }
            
          | Tok_operator ("<", _) =>
            match (get_token ()) {
              | Tok_operator ("[", _) => ()
              | _ => fatal_error ("expecting '[' after '<' in pattern");
            };
            def back = ctx.in_pattern;
            ctx.in_pattern = true;
            def expr = parse_quotation ();
            expect_operator ("]>");
            ctx.in_pattern = back;
            match (expr) {
              | E_quoted (el) => P_quoted (loc, el)
              | _ => Util.ice ("parse_quoted returned sth strange")
            }
            
          | _ => fatal_error ("expecting pattern")
        }
    }
  }

  parse_case_guard () : Pattern * option <Expr> {
    def pat = parse_pattern ();
    if (flag_keyword ("when"))
      (pat, Some (parse_expr ()))
    else (pat, None ());
  }

  parse_match_case () : Match_case {
    def loop2 (acc) {
      def res = parse_case_guard ();
      match (get_token ()) {
        | Tok_operator ("=>", _) => List.Rev (res :: acc)
        | Tok_operator ("|", _) => loop2 (res :: acc)
        | _ => fatal_error ("found junk after pattern")
      }
    };
    
    // eat pattern part and '=>'
    def pats = 
      match (peek_token ()) {
        | Tok_operator ("|", _) => 
          shift ();
          match (peek_token ()) {
            | Tok_operator (".", _) =>
              expect_operator ("..");
              match (get_splicable_id ()) {
                | SS_spliced_expr (e) =>
                  expect_operator ("=>");
                  [(P_patt_list (e.loc, P_spliced (e)), None ())]                  
                | SS_string =>
                  fatal_error ("expected spliced expression")
              }
            | _ => loop2 ([])
          }
        | _ => loop2 ([])
      };

    def loc' = location_here ();
    def expr =
      match (parse_expr_sequence ()) {
        | [x] => x
        | l => E_sequence (loc', l)
      };

    Match_case (pats, expr)
  }

  parse_toplevel_expr () : Expr
  {
    def loc = location_here ();
    def tok = get_token ();
    //Message.debug ("pse " + token_name (tok));
    match (tok) {
      | Tok_operator ("{", _) =>
        def loc = location ();
        def res = E_sequence (loc, parse_maybe_null_expr_sequence ());
        expect_operator ("}");
        res

      | Tok_keyword (k) when ctx.keywords.Contains (k) =>
        def k = Option.UnSome (ctx.keywords.Get (k));
        k.parsing_function ()

      | Tok_keyword ("ref") =>
        E_parm_by_ref (loc, parse_expr ())
        
      | Tok_keyword ("out") =>
        E_parm_out (loc, parse_expr ())
        
      | Tok_keyword ("match") =>
        expect_operator ("(");
        def expr = parse_expr ();
        expect_operator (")");
        match (get_token ()) {
          | Tok_operator ("{", _) =>
            match (peek_token ()) {
              | Tok_operator (".", _) =>
                expect_operator ("..");
                match (get_splicable_id ()) {
                  | SS_spliced_expr (e) =>
                    expect_operator ("}");                  
                    E_match (loc, expr, 
                             [Match_case ([], E_expr_list (e.loc, E_spliced (e)))]);
                  | SS_string =>
                    fatal_error ("expected spliced expression")
                }
              | _ =>
                push_back ();
                def cases = collect_braced_list (parse_match_case);
                E_match (loc, expr, cases)
            }
          | _ =>
            fatal_error ("expecting '{' after 'match (e)'")
        }
      | Tok_keyword ("throw") =>
        E_raise (loc, parse_expr ())

      | Tok_keyword ("try") =>
        def body = parse_expr ();
        match (get_token ()) {
          | Tok_keyword ("catch") =>
            def parse_with () {
              match (peek_token ()) {
                | Tok_operator ("|", _) => shift ()
                | _ => ()
              };
              def id = get_splicable_id ();
              expect_operator (":");
              def t = parse_type ();
              expect_operator ("=>");
              match (parse_expr_sequence ()) {
                | [x] => (id, t, x)
                | l => (id, t, E_sequence (loc, l))
              }
            };

            def mktry (h, body) {
              def (id, t, handler) = h;
              E_try_with (loc, body, id, t, handler)
            };
            
            List.FoldLeft (collect_braced_list (parse_with), body, mktry)
            
          | Tok_keyword ("finally") =>
            def handler = parse_expr ();
            E_try_finally (loc, body, handler)

          | _ => fatal_error ("expecting `catch' or `finally'")
        }

      | Tok_keyword ("array") =>
        match (get_token ()) {
          | Tok_operator ("[", _) =>
            def exprs = parse_list ();
            expect_operator ("]");
            E_mkarray (loc, exprs)

          | Tok_operator ("(", _) =>
            def exprs = operator_separated_list (",", parse_expr);
            expect_operator (")");
            E_empty_array (loc, exprs)

          | _ => fatal_error ("expected [ ... ] after `array'")
        }

      | Tok_keyword ("fun") =>
        push_back ();
        def h = parse_fun_header (allow_ctor = false,
                                  allow_inference = true, 
                                  is_lambda = true, 
                                  knownname = None ());
        def expr = parse_block (h.parms);
        E_lambda (loc, Function_decl (h, expr))

      | Tok_keyword ("mutable") =>
        def id = get_splicable_id ();
        match (get_token ()) {
          | Tok_operator ("<-", _) =>
//            Message.warning ("<- assignment operator is obsolate");
            E_let (loc, true, id, parse_expr ())
          | Tok_operator ("=", _) =>
            E_let (loc, true, id, parse_expr ())
          | _ =>
            fatal_error ("expected assignment operator =")
        };

      | Tok_keyword ("def") =>
        def parse_val (id) {
          expect_operator ("=");
          E_let (loc, false, id, parse_expr ())
        };
        def parse_pat (idopt) {
          def pat =
            match (idopt) {
              | None => parse_pattern ()
              | Some (id) =>
                parse_pattern_after_id (id);
            };
          expect_operator ("=");
          def expr = parse_expr ();
          E_letpat (loc, pat, expr)
        };
        def parse_funs (acc, idopt) {
          def h = parse_fun_header (allow_ctor = false, 
                                    allow_inference = true, 
                                    is_lambda = false, knownname = idopt);
          def fd = Function_decl (h, parse_block (h.parms));
          match (peek_token ()) {
            | Tok_keyword ("and") =>
              shift ();
              parse_funs (fd :: acc, None ())
            | _ => E_letfun (loc, List.Rev (fd :: acc))
          }
        };
        
        match (peek_token ()) {
          | Tok_keyword ("_")
          | Tok_operator ("$", _) 
          | Tok_identifier =>
            def id = get_splicable_id ();
            match (peek_token ()) {
              | Tok_operator ("(", _) 
              | Tok_operator ("<", _) => 
                parse_funs ([], Some (id))
                
              | Tok_operator ("=", _) =>
                parse_val (id)
              
              | _ => parse_pat (Some (id))
            }

          | Tok_operator (".", _) =>
            shift ();
            expect_operator (".");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                E_letfun (loc, [Function_decl (Fun_header (), 
                                               E_expr_list (E_spliced (e)))])
              | SS_string =>
                fatal_error ("expected spliced expression")
            }
          | _ => parse_pat (None ())
        }
      
      | _ => push_back (); parse_operator_expr ()
    }
  }

  parse_operator_expr () : Expr
  {
    def is_paren (s) {
      ctx.parens.Contains (s) || ctx.closing_parens.Contains (s)
    };

    def make_bin (loc, op, e1, e2) {
      match (op) {
        | "=" =>
          E_assign (loc, e1, e2)
        | "<-" =>
//       Message.warning ("<- assignment operator is obsolate");
          E_assign (loc, e1, e2)
        | "::" =>
          E_call (loc, E_ref (loc, Name (["Cons"])), [e1, e2])
        | _ =>
          E_call (loc, E_ref (loc, Name ([op])), [e1, e2])
      }
    };
    
    def parse_pri (pri) : Expr {
      def loop_left (expr) {
        def loc = location_here ();
        match (get_token ()) {
          | Tok_operator (s, p) when p == pri && !is_paren (s) =>
            def expr' = parse_pri (pri - 1);
            loop_left (make_bin (loc, s, expr, expr'))
          | _ => 
            push_back (); 
            expr
        }
      };

      def loop_right () {
        def loc = location_here ();
        def expr = parse_pri (pri - 1);
        match (get_token ()) {
          | Tok_operator (s, p) when p == pri && !is_paren (s) =>
            make_bin (loc, s, expr, loop_right ())
          | _ => push_back (); expr
        }
      };
     
      match (pri) {
        | 0 => parse_unary_expr ()
        | 1 | 8 => loop_right ()
        | _ => loop_left (parse_pri (pri - 1))
      }
    };

    parse_pri (8)
  }

  parse_expr () : Expr
  {
    def expr = parse_toplevel_expr ();
    match (get_token ()) {
      | Tok_operator ("<-", _)
      | Tok_operator ("=", _) =>
        def expr' = parse_toplevel_expr ();
        E_assign (expr.loc, expr, expr')
      | _ => push_back (); expr
    }
  }

  parse_expr_sequence () : list <Expr> {
    def loop (acc) {
      def last = last_token ();
      match (get_token ()) {
        | Tok_operator (";", _) =>
          match (peek_token ()) {
            | Tok_operator ("}", _) 
            | Tok_operator ("|", _) 
            | Tok_operator ("]", _) 
              => List.Rev (acc)
            | _ => loop (parse_expr () :: acc)
          }
        | Tok_operator ("}", _) 
        | Tok_operator ("|", _) 
        | Tok_operator ("]", _) 
          => push_back (); List.Rev (acc)
        | _ =>
          match (last) {
            | Tok_operator ("}", _) =>
              push_back ();
              loop (parse_expr () :: acc)
            | _ =>
              fatal_error ("expecting the `;' separator after an expression in a sequence")
          }
      }
    };

    loop ([parse_expr ()])
  }

  parse_maybe_null_expr_sequence () : list <Expr> {
    match (peek_token ()) {
      | Tok_operator ("}", _) 
      | Tok_operator ("]", _) => []
      | _ => parse_expr_sequence ()
    }
  }

  parse_block (parms : list <Fun_parm>) : Expr 
  {
    def loc = location ();
    match (peek_token ()) {
      // entire function body may be spliced
      | Tok_operator ("$", _) =>
        parse_expr ()

      // standard body enclosed by { ... }
      | Tok_operator ("{", _) =>
        shift ();
        match (peek_token ()) {
          | Tok_operator ("}", _) => 
            shift (); E_sequence (location (), [])
          | Tok_operator ("|", _) =>
            // convert function's parameters to tuple to be matched
            def parms_to_tupl (prs : list <Fun_parm>, acc) {
              match (prs) {
                | [] => E_tuple (List.Rev (acc))
                | {name = SS_string (x)} :: xs => 
                  parms_to_tupl (xs, E_ref (x) :: acc)
                | _ => fatal_error ("illegal spliced parameter?")
              }
            };
            push_back ();
            def cases = collect_braced_list (parse_match_case);
            match (parms) {
              | [{name = SS_string (x)}] => 
                E_match (loc, E_ref (x), cases)
              | _::_::_ => 
                E_match (loc, parms_to_tupl (parms, []), cases)
              | [] =>             
                fatal_error ("functions with direct matching must have parameters")
              | _ => fatal_error ("illegal spliced parameter?")
            }
          | _ => 
            def r = E_sequence (loc, parse_expr_sequence ());
            expect_operator ("}");
            r
        }
      | _ =>
        fatal_error ("expected `{' at the beginning of function body")
    }
  }
  
  parse_type () : Type {
    def prim_type () {
      def get_args () {
        match (get_token ()) {
          | Tok_operator ("<", _) =>
            def args = operator_separated_list (",", parse_type);
            expect_operator (">");
            args
          | _ =>
            push_back ();
            []
        }
      };
      match (get_token ()) {
        | Tok_identifier
        | Tok_operator ("$", _) =>
          push_back ();
          def id = get_splicable_id ();
          def id = 
            match (peek_token ()) {
              | Tok_operator (".", _) =>
                shift ();
                match (id) {
                  | SS_string ({ idl = n }) => SS_string (Name (get_qid (n)))
                  | _ =>
                    fatal_error ("mixing spliced names with regular ids isn't allowed")
                }
              | _ => id;
            };
          match (peek_token ()) {
            | Tok_operator ("<", _) => 
              T_app (id, get_args ())
            | _ =>
              match (id) {
                | SS_string => T_app (id, [])
                | SS_spliced_expr (E_spliced_special (ty, expr)) =>
                  match (ty) {
                    | "name" | "typed" =>
                      T_spliced_special (ty, expr)
                    | _ =>
                      fatal_error ("wrong splicing type after ':'")
                  }
                | SS_spliced_expr (expr) =>
                  T_spliced (expr)
              }
          }

        | Tok_operator (".", _) =>
          expect_operator (".");
          match (get_splicable_id ()) {
            | SS_spliced_expr (e) =>
              T_type_list (T_spliced (e))
            | SS_string =>
              fatal_error ("expected spliced expression")
          }
          
        | Tok_keyword ("array") => 
          match (get_token ()) {
            | Tok_operator ("<", _) =>
              def t = T_array (prim_type ());
              expect_operator (">");
              t
            | _ =>
              fatal_error ("expecting < after array")
          }
        
        | Tok_keyword ("ref") => T_ref (prim_type ())
        
        | Tok_keyword ("out") => T_out (prim_type ())

        | Tok_keyword ("void") => T_void ()

        | Tok_operator ("(", _) =>
          def t = parse_type ();
          expect_operator (")");
          t

        | _ =>
          fatal_error ("expecting type expression")
      }
    }

    and prod_type () {
      def loop (acc) {
        match (get_token ()) {
          | Tok_operator ("*", _) =>
            loop (prim_type () :: acc)
          | _ => 
            push_back ();
            match (acc) {
              | [x] => x
              | acc => T_prod (List.Rev (acc))
            }
        }
      };

      loop ([prim_type ()])
    };

    def fun_type () {
      def t = prod_type ();
      match (get_token ()) {
        | Tok_operator ("->", _) =>
          T_fun (t, fun_type ())
        | _ => 
          push_back ();
          t
      }
    };

    fun_type ()
  }

  get_attrs () : Modifiers {
    def loop (acc, attrs) {
      match (get_token ()) {
        | Tok_keyword ("mutable") => loop (NemerleAttributes.Mutable %| acc, attrs)
        | Tok_keyword ("public") => loop (NemerleAttributes.Public %| acc, attrs)
        | Tok_keyword ("private") => loop (NemerleAttributes.Private %| acc, attrs)
        | Tok_keyword ("static") => loop (NemerleAttributes.Static %| acc, attrs)
        | Tok_keyword ("new") => loop (NemerleAttributes.New %| acc, attrs)
        | Tok_keyword ("private") => loop (NemerleAttributes.Private %| acc, attrs)
        | Tok_keyword ("static") => loop (NemerleAttributes.Static %| acc, attrs)
        | Tok_keyword ("new") => loop (NemerleAttributes.New %| acc, attrs)
        | Tok_keyword ("protected") => loop (NemerleAttributes.Protected %| acc, attrs)
        | Tok_keyword ("internal") => loop (NemerleAttributes.Internal %| acc, attrs)
        | Tok_keyword ("abstract") => loop (NemerleAttributes.Abstract %| acc, attrs)
        | Tok_keyword ("sealed") => loop (NemerleAttributes.Sealed %| acc, attrs)
        | Tok_keyword ("override") => loop (NemerleAttributes.Override %| acc, attrs)
        | Tok_keyword ("virtual") => loop (NemerleAttributes.Virtual %| acc, attrs)
        | Tok_operator ("[", _) => 
          def exps = operator_separated_list (",", parse_expr);
          expect_operator ("]");
          loop (acc, attrs + exps)
        | _ =>
          push_back ();
          Modifiers (acc, attrs)
      }
    };
    match (peek_token ()) {
      | Tok_operator (".", _) =>
        expect_operator ("..");
        match (get_splicable_id ()) {
          | SS_spliced_expr (e) =>
            Modifiers (NemerleAttributes.None, [E_expr_list (E_spliced (e))])
          | SS_string =>
            fatal_error ("expected spliced expression")
        }
      | _ =>
        loop (NemerleAttributes.None, [])
    }
  }
  
  operator_separated_list<'a> (op : string, f : void -> 'a) : list <'a> {
    def loop (acc) {
      match (get_token ()) {
        | Tok_operator (o, _) when o == op => loop (f () :: acc)
        | _ => push_back (); List.Rev (acc)
      }
    };

    loop ([f ()])
  }

  parse_where_constraints (tyvars : list <string>, splicing_type : Type) 
  : Typarms 
  {
    def loop (acc) {
      if (flag_keyword ("where")) {
        match (peek_token ()) {
          | Tok_operator (".", _) =>
            shift ();
            expect_operator (".");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                (List.Rev (acc), T_spliced (e))
              | _ =>
                fatal_error ("expected spliced expression")
            }
          | _ =>
            def tv = get_tyvar ();
            expect_operator (":");
            def types = operator_separated_list (",", parse_type);
            def acc = List.FoldLeft (types, acc, fun (t, acc) { 
              Constraint (tv, t) :: acc 
            });
            loop (acc)
        }
      } else (List.Rev (acc), T_void ())
    };
    def (where_cts, where_spl_t) = loop ([]);
    match ((splicing_type, where_spl_t)) {
      | (T_void, T_void) =>
        Typarms (tyvars, where_cts)
      | _ =>
        Typarms (tyvars, Constraint ("", T_prod ([splicing_type, where_spl_t])) 
                 :: where_cts)
    }
  }

  parse_property (name : Splicable_string, t : Type,
                  attrs : Modifiers, dims : list<Fun_parm>) : Class_member
  {
    def parse_bd (p) {
      match (peek_token ()) {
        | Tok_operator (";", _) =>
          shift ();
          Some (FB_abstract ())
        | _ =>
          def bl = parse_block (p);
          Some (FB_parsed_expr (bl))
      };
    };
    
    mutable set = None (); mutable get = None ();
    def loc = location_here ();
    
    match (get_token ()) {
      | Tok_identifier ("get") =>
        get = parse_bd ([]);

        match (get_token ()) {
          | Tok_identifier ("set") =>
            set = parse_bd (List.Append (dims,
                                          [Fun_parm (SS_string (Name (["value"])),
                                                     null, null)]));
            expect_operator ("}");

          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `set' section of property or `}'")
        }

      | Tok_identifier ("set") =>
        set = parse_bd (List.Append (dims,
                                      [Fun_parm (SS_string (Name (["value"])),
                                                 null, null)]));
        match (get_token ()) {
          | Tok_identifier ("get") =>
            get = parse_bd ([]);
            expect_operator ("}");

          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `get' section of property or `}'")
        }
      | _ => fatal_error ("expecting `set' of `get' section of property")
    };

    M_property (loc = loc, name = name, modifiers = attrs, ty = t,
             set = set, get = get, dims = dims)
  }

  parse_event (name : Splicable_string, t : Type,
               attrs : Modifiers) : Class_member
  {
    def parse_bd (p) {
      match (peek_token ()) {
        | Tok_operator (";", _) =>
          shift ();
          Some (FB_abstract ())
        | _ =>
          def bl = parse_block (p);
          Some (FB_parsed_expr (bl))
      };
    };
    
    mutable add = None (); mutable remove = None ();
    def loc = location_here ();

    def value_parm = Fun_parm (SS_string (Name (["value"])), null, null);
    
    match (get_token ()) {
      | Tok_identifier ("remove") =>
        remove = parse_bd ([value_parm]);

        match (get_token ()) {
          | Tok_identifier ("add") =>
            add = parse_bd ([value_parm]);
            expect_operator ("}");
                                                
          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `add' section of event or `}'")
        }

      | Tok_identifier ("add") =>
        add = parse_bd ([value_parm]);
        match (get_token ()) {
          | Tok_identifier ("remove") =>
            remove = parse_bd ([value_parm]);
            expect_operator ("}");

          | Tok_operator ("}", _) => ()
          | _ => fatal_error ("expecting `remove' section of event or `}'")
        }
      | _ => fatal_error ("expecting `add' or `remove' section of event")
    };
    M_event (loc = loc, name = name, modifiers = attrs, ty = t,
             add = add, remove = remove)
  }
  
  parse_field (loc : Location, name : Splicable_string, attrs : Modifiers,
               is_event : bool) : Class_member
  {
    expect_operator (":");
    def t = parse_type ();

    match (get_token ()) {
      | Tok_operator (";", _) =>
        if (is_event)
          M_event (loc = loc, name = name, modifiers = attrs, ty = t,
                   add = None (), remove = None ())
        else
          M_field (loc = loc, name = name, modifiers = attrs, ty = t)

      | Tok_operator ("{", _) =>
        if (is_event)
          parse_event (name, t, attrs)
        else
          parse_property (name, t, attrs, [])

      | Tok_operator ("[", _) =>
        when (is_event) fatal_error ("expecting body of event");
        def parse_parm () { parse_funparm (false) };
        def parms =
        match (peek_token ()) {
          | Tok_operator ("]", _) => fatal_error ("indexer without indices")
          | Tok_operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | SS_spliced_expr (e) =>
                [Fun_parm (e.loc, SS_string (Name ([])), <[ type: void ]>, 
                           Modifiers (NemerleAttributes.None, [E_spliced (e)]))]
              | SS_string =>
                fatal_error ("expected spliced expression")
            }
          | _ => operator_separated_list (",", parse_parm)
        };
        expect_operator ("]");
        expect_operator ("{");
        parse_property (name, t, attrs, parms)

      | Tok_operator ("=", _) =>
        def init = parse_expr ();
        expect_operator (";");
        attrs.attrs = <[ StaticInitializer ($init) ]> :: attrs.attrs;
        if (is_event)
          M_event (loc = loc, name = name, modifiers = attrs, ty = t,
                   add = None (), remove = None ())
        else
          M_field (loc = loc, name = name, modifiers = attrs, ty = t)

      | _ =>
        if (is_event)
          fatal_error ("expecting `;' finishing event declaration or `{'"
                       " for its body")
        else
          fatal_error ("expecting `;' finishing field declaration or `{'"
                       " for property declaration")
    }
  }

  parse_method (loc : Location, id : option <Splicable_string>,
                attrs : Modifiers) : Class_member
  {
    def parse_extern () {
      expect_keyword ("extern");
      match (get_token ()) {
        | Tok_string_literal (s) => 
          expect_operator (";");
          s
        | _ => fatal_error ("found some junk after extern (expecting string)")
      }
    };
    
    def ctr = 
      match (peek_token ()) {
        | Tok_keyword ("this") => true
        | _ => false
      };
    def h = parse_fun_header (allow_ctor = ctr, 
                              allow_inference = false,
                              is_lambda = false,
                              knownname = id);
    def impl =
      match (get_token ()) {
        | Tok_keyword ("implements") =>
          match (peek_token ()) {
            | Tok_operator (".", _) =>
              expect_operator ("..");
              match (get_splicable_id ()) {
                | SS_spliced_expr (e) =>
                  [SS_spliced_expr (E_expr_list (E_spliced (e)))]
                | _ =>
                  fatal_error ("expected spliced expression after `..'")
              }
            | _ =>
              operator_separated_list (",", get_splicable_qid)
          }
        | _ => push_back (); []
      };
    mutable is_abstract = false;
    def body =
      match (peek_token ()) {
        | Tok_operator ("=", _) =>
          shift ();
          FB_extern (parse_extern ())
        | Tok_operator ("{", _) =>
          FB_parsed_expr (parse_block (h.parms))
        | Tok_operator (";", _) =>
          shift ();
          is_abstract = true;
          FB_abstract ()
        | Tok_operator ("$", _) =>
          match (get_splicable_id ()) {
            | SS_spliced_expr (e) =>
              FB_parsed_expr (E_spliced (e))
            | _ => Util.ice ("get_splicable_id returned impossible value")
          }
        | _ => fatal_error ("expecting method body")
      };
    def kind =
      if (is_abstract)
        FK_iface_method (attrs.mods %&& NemerleAttributes.New)
      else FK_method (impl);
      
    M_function (header = h, 
                name = h.name, 
                modifiers = attrs, 
                loc = loc, 
                body = body, 
                kind = kind)
  }

  parse_option (loc : Location, attrs : Modifiers) : Class_member {
    def id = get_splicable_id ();
    match (peek_token ()) {
      | Tok_operator ("{", _) =>
        def parse_field () {
          ignore (peek_token ());
          locate (fun () {
            def attrs = get_attrs ();
            def id = get_splicable_id ();
            expect_operator (":");
            def ty = parse_type ();
            expect_operator (";");
            M_field (name = id,
                     modifiers = attrs,
                     ty = ty)
          })
        };
        def members = collect_braced_list (parse_field);
        def td =
          TD_variant_option (name = id, 
                             modifiers = attrs, 
                             t_extends = [],
                             typarms = Typarms ([], []),
                             decls = members);
        td.loc = loc;
        M_type (loc = loc,
                name = td.name, 
                modifiers = td.modifiers, 
                td = td)

      | Tok_operator ("=", _) =>
        shift ();
        def val = 
          match (get_token ()) {
            | Tok_byte_literal (n) => Some (L_byte (n))
            | Tok_sbyte_literal (n) => Some (L_sbyte (n))
            | Tok_short_literal (n) => Some (L_short (n))
            | Tok_ushort_literal (n) => Some (L_ushort (n))
            | Tok_integer_literal (n) => Some (L_int (n))
            | Tok_uinteger_literal (n) => Some (L_uint (n))
            | Tok_long_literal (n) => Some (L_long (n))
            | Tok_ulong_literal (n) => Some (L_ulong (n))
            | _ =>
              fatal_error ("elements can be initialized only by integer values")
          };
        M_enum (loc = loc, name = id, modifiers = attrs, value = val)

      | _ =>
        M_enum (loc = loc, name = id, modifiers = attrs, value = None ())
    };
  }
  
  parse_type_member () : Class_member {
    def loc = location_here ();
    def attrs = get_attrs ();
    
    match (peek_token ()) {
      | Tok_operator ("$", _) | Tok_identifier =>
        def id = get_splicable_id ();
        match (peek_token ()) {
          | Tok_operator ("(", _)
          | Tok_operator ("<", _) => 
            parse_method (loc, Some (id), attrs)
          | _ =>
            parse_field (loc, id, attrs, false)
        }
        
      | Tok_keyword ("this") =>
        parse_method (loc, None (), attrs)

      | Tok_keyword ("event") =>
        shift ();
        def id = get_splicable_id ();
        parse_field (loc, id, attrs, true)

      | Tok_operator ("|", _) =>
        shift ();
        parse_option (loc, attrs)
        
      | _ =>
        def td = parse_type_decl ();
        td.modifiers.mods |= attrs.mods;
        td.modifiers.attrs += attrs.attrs;
        M_type (loc = loc, 
                name = td.name, 
                modifiers = td.modifiers, 
                td = td)
    }
  }

/*
  PUT IT SOMEWHERE!
        when (attrs.mods %&& NemerleAttributes.Public)
          Message.warning ("interface members are public by default");
        when (attrs.mods %& NemerleAttributes.New != attrs.mods)
          Message.error ("only `new' modifier is available in interface members");
        attrs.mods |= NemerleAttributes.Public;
*/
  
  parse_type_decl () : Type_decl {
    def parse_header () {
      match (peek_token ()) {
        | Tok_identifier
        | Tok_operator ("$", _) =>
          def name = get_splicable_id ();
          def (tyvars, splicing_type) = parse_tyvars ();
            
          def t_extends =
            match (get_token ()) {
              | Tok_operator (":", _) =>
                match (peek_token ()) {
                  | Tok_operator (".", _) =>
                    expect_operator ("..");
                    match (get_splicable_id ()) {
                      | SS_spliced_expr (e) =>
                        [T_type_list (T_spliced (e))]
                      | SS_string =>
                        fatal_error ("expected spliced expression")
                    };
                  | _ =>
                    operator_separated_list (",", parse_type)
                }
              | _ => 
                push_back ();
                []
            };

          def typarms = parse_where_constraints (tyvars, splicing_type);
            
          (name, typarms, t_extends)
          
        | _ => fatal_error ("expecting type name")
      }
    };
    
    def parse_members () {
      collect_braced_list (parse_type_member)
    };
    
    def attrs = get_attrs ();

    def expect_macro () {
      shift ();
      match (peek_token ()) {
        | Tok_keyword ("macro") => ()
        | _ => fatal_error ("expecting macro after macro phase declaration")
      }
    };
    def _macro_phase = match (peek_token ()) {
      | Tok_keyword ("postscan") => expect_macro (); 1
      | Tok_keyword ("preadd") => expect_macro (); 2
      | Tok_keyword ("postadd") => expect_macro (); 3
      | _ => -1
    };
    
    def tok = get_token ();
    
    locate (fun () {
      match (tok) {
        | Tok_keyword ("type")
        | Tok_keyword ("class")
        | Tok_keyword ("struct")
        | Tok_keyword ("module")
        | Tok_keyword ("interface")
        | Tok_keyword ("enum")
        | Tok_keyword ("variant") =>
          def (name, typarms, t_extends) = parse_header ();
          def td =
            match (tok) {
              | Tok_keyword ("class") =>
                TD_class (parse_members ())
                
              | Tok_keyword ("struct") =>
                attrs.mods |= NemerleAttributes.Struct;
                TD_class (parse_members ())
                
              | Tok_keyword ("module") =>
                attrs.mods |= NemerleAttributes.Module;
                TD_class (parse_members ())
                
              | Tok_keyword ("type") =>
                expect_operator ("=");
                def t = parse_type ();
                expect_operator (";");
                TD_alias (t)
                
              | Tok_keyword ("interface") =>
                def mems = parse_members ();
                List.Iter (mems, fun (x : Class_member) {
                  x.modifiers.mods |= NemerleAttributes.Public;
                });
                TD_interface (mems)
                
              | Tok_keyword ("variant") =>
                TD_variant (parse_members ())

              | Tok_keyword ("enum") =>
                TD_enum (parse_members ())
                
              | _ => Util.ice ()
            };
            
          td.modifiers = attrs;
          
          td.name = name;
          td.typarms = typarms;
          td.t_extends = t_extends;
          
          td

        | Tok_keyword ("delegate") =>
          def r = TD_delegate (parse_fun_header (false, false, false, None ()));
          expect_operator (";");
          r

        | Tok_keyword ("macro") => 
          def header = parse_fun_header (true, false, false, None ());
          def synt = 
            match (peek_token ()) {
              | Tok_keyword ("syntax") =>
                shift ();
                expect_operator ("(");
                def parse_elems (acc) {
                  match (peek_token ()) {
                    | Tok_operator (")", _) =>
                      shift ();
                      List.Rev (acc)
                    | Tok_operator (",", _) =>
                      shift ();
                      parse_elems (parse_prim_expr () :: acc)
                    | _ =>
                      fatal_error ("expected comma separated expressions in "
                                   + "syntax description")
                  }
                };
                parse_elems ([parse_closed_prim_expr ()])
              | _ => []
            };
          def expr = parse_block ([]);
          def res = TD_macro (header, synt, expr);
          res.modifiers = attrs;
          res
       
        | _ => fatal_error ("expecting type declaration")
      }
    })
  }
  
  parse_topdecl () : Top_decl {
    def tok = get_token ();
    locate (fun () {
      match (tok) {
        | Tok_keyword ("using") =>
          def id = get_qid ([]);
          expect_operator (";");
          /// FIXME: pass list
          MacroRegistry.LoadSyntaxExtensions (Nemerle.Utility.NString.Concat (".", id));
          TD_open (id)
          
        | Tok_keyword ("namespace") =>
          def id = get_qid ([]);
          match (get_token ()) {
            | Tok_operator ("=", _) =>
              def id = 
                match (id) {
                  | [x] => x
                  | x :: _ =>
                    Message.error ("namespace alias cannot contain dots");
                    x
                  | [] => Util.ice ("empty list")
                };
              def id' = get_qid ([]);
              expect_operator (";");
              TD_namespace_alias (id, id')
              
            | Tok_operator ("{", _) =>
              // FIXME: pass list
              MacroRegistry.LoadSyntaxExtensions (Nemerle.Utility.NString.Concat (".", id));
              push_back ();
              def decls = collect_braced_list (parse_topdecl);
              TD_namespace (id, decls)

            | _ =>
              fatal_error ("expecting '}' or '='")
          }

        | _ =>
          push_back ();
          TD_type (parse_type_decl ())
      }
    })
  }

  parse_quotation () : Expr {
    def tok = get_token ();
    def loc = location ();
    
    E_quoted (loc,
      match (get_token ()) {
        | Tok_operator (":", _) =>
          match (tok) {
            | Tok_keyword ("type") =>
              SyntaxType (parse_type ())

            | Tok_identifier ("ttype") =>
              SyntaxTType (parse_type ())
            
            | Tok_identifier ("pattern") =>
              SyntaxPattern (parse_pattern ())

            | Tok_identifier ("case") =>
              SyntaxCase (parse_match_case ())

            | Tok_identifier ("caseguard") =>
              SyntaxCaseGuard (parse_case_guard ())

            | Tok_identifier ("fundecl") =>
              def h = parse_fun_header (allow_ctor = false, 
                                        allow_inference = true, 
                                        is_lambda = false, knownname = None ());
              SyntaxFunDecl (Function_decl (h, parse_block (h.parms)))

            | Tok_identifier ("funparm") =>
              SyntaxFunParm (parse_funparm (allow_inference = true))

            | Tok_identifier ("decl") =>
              SyntaxDeclaration (parse_type_member ())
              
            | _ =>
              fatal_error ("bad quotation type")
          }
        | _ =>
          push_back (); 
          push_back ();
          def expr =
            match (parse_expr_sequence ()) {
              | [x] => x
              | l => E_sequence (loc, l)
            };
          SyntaxExpr (expr)
      }
    )
  }
  
  collect_braced_list<'a> (f : void -> 'a) : list <'a> {
    expect_operator ("{");
    def r = collect_list (f);
    expect_operator ("}");
    r
  }
  
  collect_list<'a> (f : void -> 'a) : list <'a> {
    def loop (acc) {
      match (peek_token ()) {
        | Tok_operator ("}", _) | Tok_EOF => List.Rev (acc)
        | _ =>
          loop (f () :: acc)
      }
    };
    loop ([])
  }

  public variant GrammarElement {
    | GE_operator { name : string; }
    | GE_keyword { name : string; }
    | GE_expression
    | GE_block
    | GE_expression_list { sep : string; }
    | GE_funparm
    | GE_optional { body : GrammarElement; }
  }

  parse_wrt_rule (rule : list <GrammarElement>) : list <SyntaxElement> {
    def loop (acc, lst) {
      match (lst) {
        | GE_operator (n) :: xs =>
          expect_operator (n);
          loop (acc, xs)

        | GE_keyword (n) :: xs =>
          expect_keyword (n);
          loop (acc, xs)

        | GE_expression :: xs =>
          def expr = parse_expr ();
          loop (SyntaxExpr (expr) :: acc, xs)

        | GE_block :: xs =>
          def expr = parse_block ([]);
          loop (SyntaxExpr (expr) :: acc, xs)

        | GE_expression_list (sep) :: xs =>
          def exprs = operator_separated_list (sep, parse_expr);
          loop (List.RevAppend (List.Map (exprs, fun (e) { SyntaxExpr (e) }), 
                                 acc), xs)

        | GE_funparm :: xs =>
          def p = parse_funparm (allow_inference = true);
          loop (SyntaxFunParm (p) :: acc, xs)

        | GE_optional (GE_operator (n)) :: xs =>
          match (peek_token ()) {
            | Tok_operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
              expect_operator (n)
            | _ => ()
          };
          loop (acc, xs)

        | GE_optional (GE_keyword (n)) :: xs =>
          match (peek_token ()) {
            | Tok_keyword (o) when o == n => shift ();
            | _ => ()
          };
          loop (acc, xs)

        | GE_optional (GE_expression) :: GE_keyword (n) :: xs =>
          match (peek_token ()) {
            | Tok_keyword (o) when o == n =>
              shift ();
              loop (SyntaxExpr (null) :: acc, xs)
            | _ =>
              def expr = parse_expr ();
              expect_keyword (n);
              loop (SyntaxExpr (expr) :: acc, xs)
          };
          
        | GE_optional (GE_expression) :: GE_operator (n) :: xs =>
          match (peek_token ()) {
            | Tok_operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
              shift ();
              loop (SyntaxExpr (null) :: acc, xs)
            | _ =>
              def expr = parse_expr ();
              expect_operator (n);
              loop (SyntaxExpr (expr) :: acc, xs)
          };

        | _ :: _ => Message.fatal_error ("syntax definition of macro is ambiguous")
          
        | [] => List.Rev (acc)
      }
    };

    loop ([], rule)
  }

  internal make_parsing_function (macro_ns : GlobalEnv.NamespaceND,
                                rule : list <GrammarElement>, 
                                perm : list <SyntaxElement> -> list <SyntaxElement>) 
                                : void -> Expr 
  {
    fun () {
      def loc = location ();
      def parms = parse_wrt_rule (rule);
      E_macrocall (loc, Name ([]), macro_ns, perm (parms))
    }
  }

  parse_list () : list <Expr>
  {
    def parse_list () {
      match (peek_token ()) {
        | Tok_operator ("]", _) => []
        | Tok_operator (",", _) =>
          shift ();
          parse_expr () :: parse_list ()
        | _ =>
          fatal_error ("expecting expression in list literal")
      }
    };
    match (peek_token ()) {
      | Tok_operator ("]", _) => []
      | _ =>
        def expr = parse_expr ();
        expr :: parse_list ()
    }
  }

  init_parens () : void {
    def add (o, c, f) {
      ctx.parens.Add (o, ParenCallback (o, c, f));
      ctx.closing_parens.Add (c, 0);
    };
    add ("<[", "]>", parse_quotation);
    
    add ("[", "]", fun () {
      def loc = location ();
      def make_list (exps : list <Expr>) {
        match (exps) {
          | [] => E_call (loc, E_ref (loc, Name (["Nil"])), [])
          | x :: xs => E_call (x.loc, E_ref (x.loc, Name (["Cons"])), 
                               [x, make_list (xs)])
        }
      };
      make_list (parse_list ())
    });
  }

  public parse (lexer : LexerBase) : list <Top_decl>
  {
    ctx.lexer = lexer;
    ctx.last_token1 = null;
    ctx.last_token2 = null;
    ctx.push_back = 0;
    ctx.in_pattern = false;
    MacroRegistry.RemoveSyntaxExtensions ();
    def r = collect_list (parse_topdecl);
    match (peek_token ()) {
      | Tok_EOF => r
      | _ => fatal_error ("expecting EOF")
    }
  }

  public ParseExpr (expr : string) : Expr
  {
    ctx.lexer = LexerString (expr);
    ctx.last_token1 = null;
    ctx.last_token2 = null;
    ctx.push_back = 0;
    ctx.in_pattern = false;
    MacroRegistry.RemoveSyntaxExtensions ();
    def r = parse_expr ();
    match (peek_token ()) {
      | Tok_EOF => r
      | _ => fatal_error ("expecting EOF")
    }
  }
  
} // end module
} // end namespace
