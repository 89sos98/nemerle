/*
 * Copyright (c) 2004 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler
{
  using Nemerle.Compiler;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Collections;
  using Nemerle.Utility;

  /**
   * Executed between cgexpr and cgil
   */
  public class CGpost
  {
    public Run (expr : CG_expr) : bool
    {
      walk (expr, CgExprFlags.None)
    }
    
    walk (expr : CG_expr, flags : CgExprFlags) : bool
    {
      def simple_walk (e) {
        walk (e, CgExprFlags.None)
      }

      def skip (expr : CG_expr) {
        expr.flags |= CgExprFlags.SkipEmission;
        Message.error (expr.loc, "this expression has been skipped in code "
                                 "emission, due to `throw' usage")
      }
      
      def simple_walks (es : list <CG_expr>) {
        mutable skip_flag = false;
        
        foreach (e in es) {
          if (skip_flag)
            ignore (skip (e))
          else
            when (walk (e, CgExprFlags.None))
              skip_flag = true
        }

        skip_flag
      }

      def cannot_addr () {
        when (flags %&& CgExprFlags.NeedAddress &&
              CGexpr.type_of (expr).IsValueType)
          Message.error (expr.loc, "cannot load value type address for this expression")
      }
      
      expr.flags = flags;

      match (expr) {
        | CE_this
        | CE_ref
        | CE_global_ref
        | CE_volatile_global_ref =>
          false

        | CE_loop (e, _)
        | CE_cast (e, _, _)
        | CE_has_type (e, _) 
        | CE_not_null (e)
        | CE_method_ref (e, _, _)
        | CE_ignore (e)
        | CE_volatile_field_ref (e, _) =>
          cannot_addr ();
          simple_walk (e)

        // ??
        | CE_init_obj 
        | CE_literal =>
          cannot_addr ();
          false

        | CE_none
        | CE_base_ctor_ref
        | CE_typeof
        | CE_ctor_ref
        | CE_method_addr
        | CE_opcode =>
          cannot_addr ();
          false
        
        | CE_call (x, xs)
        | CE_tail_call (x, xs) =>
          cannot_addr ();
          simple_walks (x :: xs)

        | CE_field_ref (e, _) =>
          // can take address
          simple_walk (e)

        | CE_array_indexer (x, xs) =>
          // can take address
          simple_walks (x :: xs)
        
        | CE_mkarray (_, xs, _)
        | CE_self_tail_call (xs) =>
          cannot_addr ();
          simple_walks (xs)
        
        | CE_assign (target, source) =>
          cannot_addr ();
          if (walk (target, flags %| CgExprFlags.NeedAddress)) {
            skip (source);
            true
          } else
            simple_walk (source)
          
        | CE_let (name, body) =>
          if (simple_walk (name.val)) {
            skip (body);
            true
          } else
            walk (body, flags)
          
        | CE_raise (e) =>
          // we can take address of throw... 
          ignore (simple_walk (e));
          true
          
        | CE_if (e, e1, e2) =>
          if (simple_walk (e)) {
            skip (e1);
            skip (e2);
            true
          } else
            walk (e1, flags) && walk (e2, flags)
          
        | CE_try_with (body, _, handler) =>
          cannot_addr ();
          ignore (simple_walk (body));
          ignore (simple_walk (handler));
          false
          
        | CE_try_finally (body, handler) =>
          cannot_addr ();
          ignore (simple_walk (body));
          simple_walk (handler)
          
        | CE_sequence (lst) =>
          def loop (do_skip, lst) {
            match (lst) {
              | [] => do_skip
              | x :: xs when do_skip =>
                skip (x);
                loop (true, xs)
              | [x] => walk (x, flags)
              | x :: xs =>
                if (simple_walk (x))
                  loop (true, xs)
                else
                  loop (false, xs)
            }
          }

          loop (false, lst)
        
        | CE_addr (e) =>
          cannot_addr ();
          walk (e, flags %| CgExprFlags.NeedAddress)
          
        | CE_indirect (e) =>
          // can take address
          simple_walk (e)
          
        | CE_continue_loop =>
          true

        | CE_multiple_assign (lst) =>
          cannot_addr ();
          simple_walks (List.Map (lst, Pair.Second))
          
        | CE_switch (idx, default, cases) =>
          // optimize switch here?
          if (simple_walk (idx)) {
            Option.Iter (default, skip);
            List.Iter (cases, fun (_, e) { skip (e) });
            true
          } else {
            def exprs = List.Map (cases, Pair.Second);
            def exprs =
              match (default) {
                | Some (e) => e :: exprs
                | None => exprs
              };
            if (List.ForAll (exprs, fun (e) { walk (e, flags) }))
              true
            else
              false
          }
      }
    }
  } /* end of the class */

} /* end of the namespace */
