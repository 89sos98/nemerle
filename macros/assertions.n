/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Collections;
 
namespace Nemerle.Assertions {
  
  /// Example: foo ([NotNull] o : object) : void { ... }
  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Parameter,
                       Inherited = true, AllowMultiple = false)]
  macro NotNull (_ : TypeBuilder, m : ParsedMethod, p : ParsedParameter)
  {
    def assertion = <[ $(Macros.NameOfSString (p.name) : name) != null ]>;
    
    m.Body = <[
      assert ($assertion, "The ``NotNull'' contract of parameter `" +
              $(Macros.NameOfSString (p.name).GetId () : string) + "' has been violated.");
      $(m.Body)
    ]>
  }

  /// Example: foo ([Requires (value != 4)] i : int) : void { ... }
  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Parameter,
                       Inherited = true, AllowMultiple = true)]
  macro Requires (_ : TypeBuilder, m : ParsedMethod, p : ParsedParameter, assertion)
  {
    def v = Macros.UseSiteSymbol ("value");
    m.Body = <[
      def $(v : name) = $(Macros.NameOfSString (p.name) : name);    
      assert ($assertion, "The ``NotNull'' contract of parameter `" +
              $(Macros.NameOfSString (p.name).GetId () : string) + "' has been violated.");
      $(m.Body)
    ]>
  }

  /// Example: [Requires (i != 4 && boo ())] foo (i : int) : void { ... }
  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method,
                       Inherited = true, AllowMultiple = true)]
  macro Requires (_ : TypeBuilder, m : ParsedMethod, assertion)
  {
    m.Body = <[
      assert ($assertion, "The ``Requires'' contract has been violated.");
      $(m.Body)
    ]>
  }
  
  /// Example: [Ensures (foo () != 4)] foo (i : int) : int { ... }
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Method,
                       Inherited = true, AllowMultiple = true)]
  macro Ensures (_ : TypeBuilder, m : MethodBuilder, assertion)
  {
    if (Tyutil.types_eq (m.ReturnType, <[ ttype: void]>))
      m.Body = <[
        $(m.Body);
        assert ($assertion, "The ``Ensures'' contract has been violated.");
      ]>
    else {
      def result = Macros.UseSiteSymbol ("value");
      m.Body = <[
        def $(result : name) = $(m.Body);
        assert ($assertion, "The ``Ensures'' contract has been violated.");
        $(result : name);
      ]>
    }
  }

  /**
      TODO for invariant:
      - add syntax extensions for invariants
      - invariants are inherited from super class - all derived classes have
        implicit call to own / overriden _N_invariant in public methods
      - addition of expose to method can be disabled with attribute
      - add expose (o upto T), which fires invariants for o in its superclasses
      - only constants, fields, arrays, state independent and confined (depending
        on owned mutable fields) methods can mentioned in invariants
      - add class invariants (for static fields)
      - add support for checked exceptions and rethrowing them (in case of invariant
        violation, they are rewhrown as inner exceptions)

     Example: [Invariant (i > 0)] class A { mutable i : int; ... }
  */
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = true, AllowMultiple = true)]
  macro Invariant (ty : TypeBuilder, body)
  {
    def existing =
      List.Find (ty.LookupMember ("_N_invariant"), fun (x : IMember) {
        x.DeclaringType == (ty : Tycon) &&
        (match (x.GetKind ()) {
          | MK_method => true
          | _ => false
         })
      });

    match (existing) {
      | None =>
        def methods = ty.GetMethods (BindingFlags.Public %|
                                     BindingFlags.Instance %|
                                     BindingFlags.DeclaredOnly);
        List.Iter (methods, fun (m : IMethod) {
          def m = (m :> NemerleMethod);
          m.Body = <[
            InvariantExpose (this, $(m.Body))    
          ]>
        });
        ty.Define ( <[ decl:
          public mutable _N_invariant_lock : bool;
        ]> );
        ty.Define ( <[ decl:
          public virtual _N_invariant () : void
          {
            assert ($body, "The class invariant has been violated.")
          }
        ]> );
      | Some (m) =>
        def m = (m :> NemerleMethod);
        m.Body = <[
          $(m.Body);
          assert ($body, "The class invariant has been violated.");
        ]>
    }
  }

  macro InvariantExpose (exposed, body) 
  syntax ("expose", "(", exposed, ")", body) {
    <[ 
      def e = $exposed;
      lock (e) {
        when (e._N_invariant_lock)
          throw System.Exception ();
          
          e._N_invariant_lock <- true
      };
      mutable need_to_check <- false;
            
      try {
        try {
          $body;
          need_to_check <- true
        }
        catch {
        /* FIXME: we need type matching
          | e : IChecked => need_to_check <- true; rethrow
         */ 
         | _e : System.Exception => ()
        }
      }
      finally {
        lock (e) {
          e._N_invariant_lock <- false;
          when (need_to_check)
            e._N_invariant ()        
        };
      }
    ]>     
  }

  /// Attribute macros TODO:  
  
  /// Adds code coverage noting functions to bodies of all methods inside class
  /// Example: [CheckCodeCoverage ("coverage.txt") class A { foo () : void { .. } ... }
  ///  macro CheckCodeCoverage (t : TypeBuilder, output_file : string = "")

  /// Verify - tries to check other attributes at compile time
  /// CheckUselessAssignments - looks for code like i = i
}
