(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler;

namespace Nemerle.Compiler {

variant Decl_kind
  {
    | D_local_fun {
        header : Fun_header; 
        uses_closure_of : list (Decl); 
      }
    | D_fun_parm
    | D_local_value
    | D_exn
    | D_pattern_variable
    | D_class_member { mem : Class_member; }
    | D_type { mem : Tyinfo; }
    | D_closurised_this_ptr
  }
  
class Decl 
  {
    loc : Location;
    name : string;
    mutable is_ref : bool;
    mutable ty : Type;
    id : int;
    kind : Decl_kind;
    
    mutable parent_fun : option (Decl);
    mutable in_closure : bool;
    
    this (n : string, k : Decl_kind, ty : Type, par : Decl)
      {
        this.loc <- Location_stack.top();
        this.name <- n;
        this.ty <- ty;
        this.kind <- k;
        this.is_ref <- false;
        this.parent_fun <- Some (par);
        this.id <- Util.next_id();
      }

    this (pref : string, mem : Class_member)
      {
        this.loc <- mem.loc;
        this.name <- pref + mem.name;
        this.id <- mem.id;
        this.kind <- D_class_member (mem);
        this.parent_fun <- None ();
        this.ty <-
          match (mem) {
            | M_value (t, rf, _) => this.is_ref <- rf; t
            | M_field (t, rf) => this.is_ref <- rf; t
            | M_function (h, _, _) => Tyutil.fun_type (h)
          }
      }
      
    this (t : Tyinfo)
      {
        this.loc <- t.loc;
        this.name <- t.env.current_namespace + t.name;
        this.id <- t.id;
        this.kind <- D_type (t);
        this.ty <- null;
      }
      
    fun_header () : Fun_header {
      match (this.kind) {
        | D_local_fun x => x.header
        | D_class_member (M_function x) => x.header
        | _ => Util.ice ()
      }
    }
  }

class Env 
  {
    static mutable globals : String_map (list (Decl));
    static mutable globals_by_id : Int_map (Decl);

    static init () : void {
      if (globals == null) {
        globals <- Map.string_map ();
        globals_by_id <- Map.int_map ();
      } else ()
    }

    mutable open_namespaces : list (string);
    mutable current_namespace : string;
    mutable namespace_aliases : String_map (string);
    mutable locals : String_map (Decl);
    mutable parent_fun : option (Decl);
    
    static add_global_symbol (name : string, decl : Decl) : void {
      match (globals.find (name)) {
        | Some (Cons (decl', _)) =>
          Message.error (decl.loc, "redefinition of `" + name + "'");
          Message.error (decl'.loc, "first defined here")
        | _ =>
          globals_by_id <- globals_by_id.replace (decl.id, decl);
          globals <- globals.add (name, List.cons (decl))
      }
    }

    static add_type (ti : Tyinfo) : Decl 
      {
        def d = Decl (ti);
        add_global_symbol (ti.env.current_namespace + ti.name, d);
        d
      }
    
    static add_global (pref : string, m : Class_member) : void
      {
        def allow_overload (d : Decl) : bool {
          match ((d.kind, m)) {
            | (D_class_member (M_function {kind = k1}), M_function {kind = k2}) =>
              // FIXME: is this needed at all?
              match ((k1, k2)) {
                | (FK_method, FK_method) => true
                | (FK_function, FK_function) => true
                | (FK_iface_method, FK_iface_method) => true
                | (FK_ctor, FK_ctor) => true
                | (FK_ctor, FK_static_ctor) => true
                | (FK_static_ctor, FK_ctor) => true
                | (FK_static_ctor, FK_static_ctor) => true
                | _ => false
              }
            | _ => false
          }
        }

        def fullname = pref + m.name;
        def decl = Decl (pref, m);
        match (globals.find (fullname)) {
          | Some (Cons (x, xs)) =>
            if (allow_overload (x)) {
              globals <- globals.replace (fullname, Cons (decl, Cons (x, xs)));
              globals_by_id <- globals_by_id.add (decl.id, decl)
            } else {
              Message.error (m.loc, "redefinition of `" + m.name + "'");
              Message.error (x.loc, "first defined here")
            }
          | Some (Nil) =>
            raise ICE("empty list in env")
          | None =>
            add_global_symbol (fullname, decl)
        }
      }

    static global_by_id (id : int) : Decl {
      match (globals_by_id.find (id)) {
        | Some (r) => r
        | None => Util.ice ()
      }
    }

    expand_namespace_aliases (sym : string) : string
      {
        def ns = CSglue.get_ns (sym);
        if (ns == "") sym
        else
          match (this.namespace_aliases.find (ns)) {
            | Some (r) => r + "." + CSglue.strip_ns (sym)
            | None => sym
          }
      }

    static lookup_global (name : string) : Decl {
      match (globals.find (name)) {
        | Some (Cons (x, Nil)) => x
        | Some (Cons) => Util.ice ("multibound internal symbol " + name)
        | None => Util.ice ("unbound internal symbol " + name)
      }
    }

    bare_lookup(name : string) : list (Decl)
      {
        def append_not_in (acc : list (Decl), d : Decl) : list(Decl) {
          if (List.exists(fun (x : Decl) : bool {x.id == d.id}, acc))
            acc
          else
            Cons(d, acc)
        }
        def name' = this.expand_namespace_aliases (name);
        def lookup_in (acc : list (Decl), pref : string) : list (Decl) {
          match (globals.find(pref + name')) {
            | Some (lst) => 
              List.fold_left(append_not_in, acc, lst)
            | None => acc
          }
        }
        if (name == name')
          match (this.locals.find(name)) {
            | Some (d) => 
              List.cons(d) // locals shadow globals
            | None =>
              def path = Cons("", Cons(this.current_namespace, 
                                       this.open_namespaces));
              List.fold_left(lookup_in, Nil(), path)
          }
        else
          lookup_in (Nil (), "")
      }
          
    lookup_type (name : string) : Tyinfo {
      match (this.bare_lookup(name)) {
        | Cons({kind = D_type (t)}, Nil) => t
        | Cons({kind = D_type}, _) =>
          Message.error("type name `" + name + "' is ambiguous:");
          def print_one(d : Decl) : void 
             { Message.error(d.loc, "  - this") }
          List.iter(print_one, this.bare_lookup(name));
          raise Recovery();
        | Nil =>
          Message.fatal_error("name `" + name + "' is unbound")
        | _ =>
          Message.fatal_error("name `" + name + "' was expected to be type")
      }
    }

    add_open (ns : string) : void
      {
        def ns =
          if (ns == "") ns
          else ns + ".";
        this.open_namespaces <- List.append (this.open_namespaces, List.cons (ns));
      }

    add_namespace_alias (short_name : string, long_name : string) : void {
      this.namespace_aliases <- this.namespace_aliases.add(short_name, long_name)
    }
    
    add_local (name : string, kind : Decl_kind, ty : Type) : (Env * Decl)
      {
        def c = this.copy();
        def d = Decl(name, kind, ty, Util.unsome (this.parent_fun));
        c.locals <- c.locals.replace(name, d);
        (c, d)
      }
      
    in_prefix (pref : string) : Env
      {
        def env' = this.copy ();
        env'.current_namespace <- this.current_namespace + pref + ".";
        env'
      }

    copy () : Env
      {
        def c = Env ();
        c.open_namespaces <- this.open_namespaces;
        c.current_namespace <- this.current_namespace;
        c.namespace_aliases <- this.namespace_aliases;
        c.parent_fun <- this.parent_fun;
        c.locals <- this.locals;
        c
      }

    this () 
      {
        this.current_namespace <- "";
        this.open_namespaces <- Nil();
        this.locals <- Map.string_map();
        this.namespace_aliases <- Map.string_map();
      }
  }


} // ns
