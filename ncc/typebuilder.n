/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.IO;
using Nemerle.Utility;
using Nemerle.Collections;

using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** This pass operates on [TypeBuilder] objects created for
    each type declaration found in source files.  These objects are
    already created, but most fields are empty.  The main function of
    this pass is [TypeBuilder.run].  */

public class TypeBuilder : Tycon, ITypeModifier {

  enclosing_type : option <TypeBuilder>;
  variant_option_parent : TypeBuilder;
  id : int;

  public mutable pt_tydecl : PT.Type_decl; // xmldump

  modifiers : Modifiers;

  mutable tydecl : Type_decl;
  mutable t_extends : option <Type>;
  mutable t_implements : list <Type>;
  mutable is_module : bool;
  mutable is_struct : bool;
  mutable is_enum : bool;
  mutable is_interface : bool;
  mutable cannot_finalize : bool;
  name : string;
  public env : GlobalEnv;
  loc : Location;
  accessibility : Accessibility;
  mutable is_value_type : bool;
  mutable contained_types : list <TypeBuilder>;
  mutable variant_options : list <TypeBuilder>;
  mutable typarms : list <Tyvar.T>;
  public mutable tenv : Tyvar.TEnv;
  mutable additional_decls : list <PT.Class_member>;
  mutable default_indexer : string;

  // the list of additional method overrides, see check_method_implements
  // (listed as pairs of implementation method / interface method)
  private mutable m_additional_method_overrides : list <IMethod * IMethod>;
  
  mutable subtypes : SystemMap <int, Tycon * list <Type>>;
  mutable member_map : SystemMap <string, list <IMember>>;
  mutable member_list : list <IMember>;

  mutable type_builder : System.Reflection.Emit.TypeBuilder;
  mutable system_type : System.Type;

  mutable constant_object : option <IField>;
  mutable has_fields : bool;
  
  /**
   * Marker for [TypeBuilder.Iter].
   */
  mutable phase : int;
  
  /**
   * Transitive closure of inherited types in this type and its nested types.
   *
   * Used by [TypeBuilder.Iter] function.
   */
  mutable iterate_first : list <TypeBuilder>;

  mutable is_protected : bool;
  mutable is_public : bool;
  mutable is_internal : bool;
  mutable is_private : bool;

  static mutable infos : list <TypeBuilder>;

  static mutable run_phase : int;

  
  /**
   * Return list of type parameters under which we subtype given type.
   *
   * <remarks>
   *   For example if [A ('a) :> B (int)], then ["A".SuperType ("B")]
   *   returns [[int]].
   *
   *   This information can be also fetched from [GetDirectSuperTypes()]
   *   method but this function is transitive.
   * </remarks>
   */
  public SuperType (ti : Tycon) : option <list <Type>>
  {
    match (subtypes.Find (ti.GetId ())) {
      | Some ((_, x)) => Some (x)
      | None =>
        if (ti.FullName == "System.Object")
          Some ([])
        else
          None ()
    }
  }

  /** Return qualified type name. */
  public FullName : string
  {
    get { env.GetCurrentNamespace () + name }
  }

  public GetId () : int
  {
    id
  }

  public IsDelegate : bool
  {
    get
    {
      match (t_extends) {
        | Some (T_app (tycon, [])) =>
          tycon.FullName == "System.MulticastDelegate"

        | _ =>
          false
      }
    }
  }

  public IsValueType : bool
  {
    get { is_value_type }
  }

  public GetHandle () : System.Reflection.MemberInfo
  {
    system_type
  }

  public GetModifiers () : Modifiers
  {
    modifiers
  }
  
  /** Return type we were defined in (null for toplevel types). */
  public DeclaringType : Tycon {
    get {
      match (enclosing_type) {
        | Some (ti) => ti
        | None => null
      }
    }
  }

  /** Return name without any dots. */  
  public Name : string {
    get { name }
  }

  public MemberType : System.Reflection.MemberTypes {
    get { System.Reflection.MemberTypes.NestedType }
  }
  
  public GetKind () : MemberKind
  {
    MK_type (this)
  }

  public GetAccessibility () : Accessibility
  {
    accessibility
  }

  public GetLibraryReference () : LibraryReference { null }
  
  /**
   * Return list of types that we directly subtype.
   *
   * <remarks>
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   */
  public GetDirectSuperTypes () : list <Type>
  {
    match (t_extends) {
      | Some (t) => t :: t_implements
      | None => t_implements
    }
  }

  public GetConstantObject () : option <IField>
  {
    constant_object
  }

  /** Return type we extend if any. */
  public SuperClass () : option <Tycon>
  {
    match (t_extends) {
      | Some (T_app (ti, _)) => Some (ti)
      | _ => None ()
    }
  }

  /**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * <remarks>
   *   Used mainly with [FreshSubst ()] or [MakeSubst ()].
   * </remarks>
   */
  public GetMemType () : Type
  {
    def make_tv (tv : Tyvar.T) : Type { T_var (tv) };
    T_app (this, List.Map (typarms, make_tv))
  }


  /**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   */
  public FreshSubst () : Subst
  {
    Tyvar.fresh_subst (this.typarms)
  }

  /**
   * Helper used also in ExternalNemerleType.
   */
  internal static ConstructSubst (tc : Tycon, typarms : list <Tyvar.T>,
                                  args : list <Type>) : Subst
  {
    def loop (ini : Subst, parms : list <Tyvar.T>, args : list <Type>) : Subst {
      match ((parms, args)) {
        | (p :: ps, a :: args) =>
          match (a) {
            | T_var (p') =>
              if (p.id == p'.id) ini
              else loop (ini.Add (p.id, TV_exactly (a)), ps, args)
            | _ => loop (ini.Add (p.id, TV_exactly (a)), ps, args)
          }
        | ([], []) => ini
        | _ => Util.ice ()
      }
    };

    def len_tp = List.Length (typarms);
    def len_ac = List.Length (args);

    if (len_tp == len_ac) {
      def sub = loop (SystemMap (), typarms, args);

      def check_constraints (tv : Tyvar.T, t : Type) : void {
        def check_constraint (c : Type) : void {
          unless (t >:> (c /- sub)) {
              Message.error ("typing constraint '" + tv.name +
                             " :> " + c.as_string () + " is not satisfied");
              Message.error ("by " + t.as_string () + " :> " + (c /- sub).as_string ());
              Message.error (tc.GetLocation (), "upon instantiation of " + tc.FullName)
          }
        };
        List.Iter (Tyvar.constraints (tv), check_constraint)
      };
      List.Iter2 (typarms, args, check_constraints);

      sub
    } else {
      Message.error (sprintf ("type `%s' takes %d argument(s) while %d were supplied",
                              tc.FullName, len_tp, len_ac));
      SystemMap ()
    }
  }

  /**
   * Construct substitution resulting from applying this type constructor
   * to specified arguments.
   *
   * <remarks>
   *   For example assuming our type parameters are are ('a, 'b), then
   *   [MakeSubst ([t1, t2])] produces substitution { 'a := t1; 'b := t2 }.
   * </remarks>
   */
  public MakeSubst (args : list <Type>) : Subst
  {
    ConstructSubst (this, typarms, args)
  }

  type Subinfo = SystemMap <int, Tycon * list <Type>>;

  public GetTyconKind () : TyconKind
  {
    TK_NemerleType (this)
  }

  public GetTydecl () : Type_decl
  {
    tydecl
  }

  public SameAs (tc : Tycon) : bool
  {
    tc.GetId () == GetId ()
  }

  public Attributes : NemerleAttributes
  {
    get { modifiers.mods }
  }

  public IsStatic : bool
  {
    get { true }
  }

  public LookupMember (name : string) : list <IMember>
  {
    match (member_map.Find (name)) {
      | None =>
        match (tydecl) {
          | TD_interface =>
            InternalType.Object_tc.LookupMember (name)
          | _ => []
        }
      | Some (mems) => mems
    }
  }

  internal ReverseChildren () : void {
    contained_types = List.Rev (contained_types);
    variant_options = List.Rev (variant_options);
  }

  
  /**
   * Iterate over all types defined in source code.
   *
   * <remarks>
   *   Supertypes are always processed before subtypes otherwise
   *   source code order is retained.
   * </remarks>
   */
  public static Iter (f : TypeBuilder -> void) : void
  {
    def working_on = Util.next_id ();
    def done = Util.next_id ();
    def maybe_f (ti : TypeBuilder) : void {
      if (ti.phase == done) ()
      else if (ti.phase == working_on)
        Message.error(ti.loc, "type definition for `" + ti.FullName + "' is cyclic")
      else {
        ti.phase = working_on;
        Util.locate (ti.loc, {
          List.Iter (ti.iterate_first, maybe_f);
          f (ti)
        });
        ti.phase = done
      }
    };

    List.Iter (infos, maybe_f);
  }

  /**
   * Return substitution to apply to types of members of our supertype [ti]
   * to get types of members in [this].
   *
   * <remarks>
   *    For example consider:
   *    [[[
   *      class A ('a) { f : 'a; }
   *      class B : A (int) { }
   *    ]]]
   *    Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
   *    it can be applied to type of [A.f] which is ['a], to obtain type
   *    of [B.f] which is [int].
   * </remarks>
   */
  public SubtypingSubst (tc : Tycon) : Subst
  {
    if (tc.GetId () == GetId ())
      SystemMap () // current type, no substitution
    else
      tc.MakeSubst (Option.UnSome (SuperType (tc)));
  }

  /**
   * Iterate over top level types in source code order.
   */
  public static SourceTopIter (f : TypeBuilder -> void) : void
  {
    def wrap (x : TypeBuilder) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    List.Iter (infos, wrap);
  }

  /**
   * Iterate over top level types in inheritance order.
   */
  public static TopIter (f : TypeBuilder -> void) : void
  {
    def wrap (x : TypeBuilder) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    Iter (wrap);
  }

  public this (par : option <TypeBuilder>, vop : option <TypeBuilder>, 
               env : GlobalEnv, td : PT.Type_decl)
  {
    variant_options = [];
    contained_types = [];
    this.enclosing_type = par;
    m_additional_method_overrides = [];    
    match (par) {
      | Some (p) => p.contained_types = this :: p.contained_types;
      | _ => ()
    };
    this.pt_tydecl = td;
    this.env = env;
    this.name = List.Head (Macros.UnSString (td.name));
    this.loc = td.loc;
    modifiers = td.modifiers;
        
    match (td) {
      | PT.TD_variant_option =>
        match (vop) {
          | Some (ti) =>
            ti.variant_options = this :: ti.variant_options;
            modifiers.mods |= NemerleAttributes.Sealed;
            modifiers.macro_attrs = (":type:postadd", <[ Record ]>) :: modifiers.macro_attrs;
            if (ti.is_public)
              modifiers.mods |= NemerleAttributes.Public
            else if (ti.is_internal)
              modifiers.mods |= NemerleAttributes.Internal
            else if (ti.is_protected)
              modifiers.mods |= NemerleAttributes.Protected
            else if (ti.is_private)
              modifiers.mods |= NemerleAttributes.Private
            else ()
          | None => assert (false)
        }
      | PT.TD_variant =>
        modifiers.macro_attrs = (":type:postadd", <[ Record ]>) :: modifiers.macro_attrs;
      | PT.TD_enum =>
        is_enum = true;
        is_value_type = true
      | _ => ()
    };

    Passes.tyinfo_counter = Passes.tyinfo_counter + 1;

    this.id = Util.next_id ();

    infos = this :: infos;

    is_public = NemerleAttributes.Public %&& modifiers.mods;
    is_internal = NemerleAttributes.Internal %&& modifiers.mods;
    is_protected = NemerleAttributes.Protected %&& modifiers.mods;
    is_private = NemerleAttributes.Private %&& modifiers.mods;
    is_interface = (this.pt_tydecl is PT.TD_interface);
    is_module = NemerleAttributes.Module %&& modifiers.mods;
    is_struct = NemerleAttributes.Struct %&& modifiers.mods;
    
    unless (is_public || is_internal || is_protected || is_private) {
      match (enclosing_type) {
        | Some =>
          modifiers.mods |= NemerleAttributes.Private;
          is_private = true
        | None =>
          modifiers.mods |= NemerleAttributes.Internal;
          is_internal = true
      }
    };

    if (is_private)
      accessibility = A_private ()
    else if (is_protected && is_internal)
      accessibility = A_protected_or_internal ()
    else if (is_protected)
      accessibility = A_protected ()
    else if (is_internal)
      accessibility = A_internal ()
    else
      accessibility = A_public ();

    match ((vop, pt_tydecl)) {
      | (Some (x), PT.TD_variant_option) =>
        variant_option_parent = x
      | (None, PT.TD_variant_option) => Util.ice ()
      | (Some, _) => Util.ice ()
      | (None, _) => ()
    };

    additional_decls = [];

    CheckTypeAttributes ()
  }

  public CanAccess (source : Tycon) : bool
  {
    is_public || 
    (is_internal && 
      (match (source.GetTyconKind ()) { 
        | TK_NemerleType => true 
        | _ => false 
      })) || 
    (is_protected &&
        (match (enclosing_type) {
          | Some (tc) => Option.IsSome (source.SuperType (tc))
          | None => false
        })) ||
    (match (enclosing_type) {
      | Some (declaring_type) =>
        def walk_declaring (tc : Tycon) {
          tc.SameAs (declaring_type) || 
            (tc.DeclaringType != null && walk_declaring (tc.DeclaringType))
        };
        walk_declaring (source)
      | None => false
    })
  }

  /**
   * Construct typing environments for each declaration.
   *
   * <remarks>
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   */
  make_tyenvs (tenv : Tyvar.TEnv) : void
  {
    assert (this.tenv == null);
    def (tenv, tyvars) = tenv.add_typarms (this.env, this.pt_tydecl.typarms,
                                           this, check_parms = false);
    this.tenv = tenv;
    this.typarms = tyvars;

    match (pt_tydecl) {
      | PT.TD_variant_option (members) =>
        unless (Util.is_capitalized (List.Head (Macros.UnSString (pt_tydecl.name)))) {
          Message.error (loc, "variant options names must start with capital letters")
        };
        assert (variant_option_parent.tenv != null);
        this.tenv = variant_option_parent.tenv;
        this.typarms = variant_option_parent.typarms;
        def make_public (d : PT.Class_member) : void {
          d.modifiers.mods |= NemerleAttributes.Public
        };
        List.Iter (members, make_public)
      | PT.TD_variant =>
        modifiers.mods |= NemerleAttributes.Abstract
      | _ => ()
    };

    def bind_child (x : TypeBuilder) {
      Util.locate (x.loc, x.make_tyenvs (tenv));
    };
    List.Iter (this.contained_types, bind_child);
  }


  /**
   * Bind type expressions occurring in type declarations. This
   * includes [extends] type, [implements] list, and aliased type
   * in case of type alias declaration.
   *
   * <remarks>
   *   Binding type expression refers to rewriting [Parsetree.Type]
   *   into [Typedtree.Type], which involves resolving names of type
   *   constructors (to [TypeBuilder] objects) and type variables (to [Tyvar.T]
   *   objects).
   *   
   *   This function depends on nested types being processed *before*
   *   parent type (so it should only operate on reversed infos list).
   * </remarks>
   */
  bind_types () : void
  {
    def bind (t : PT.Type) : Type {
      this.tenv.bind (this.env, this, t, check_parms = false)
    };
    def td = this.pt_tydecl;
    
    this.tydecl =
      match (td) {
        | PT.TD_class => TD_class ()
        | PT.TD_alias (t) => TD_alias (bind (t))
        | PT.TD_interface => TD_interface ()
        | PT.TD_delegate => Util.ice ("delegates shouldn't survive to typing")
        | PT.TD_enum => TD_enum ()
        | PT.TD_variant =>
          TD_variant (List.Map (variant_options, fun (x : TypeBuilder) : Tycon { x }))
        | PT.TD_variant_option => TD_variant_option ()
        | PT.TD_macro => Util.ice ("macro shouldn't survive to typing")
      };
      
    match (td) {
      | PT.TD_variant_option =>
        this.t_extends = Some (variant_option_parent.GetMemType ());
        this.t_implements = [];
      | _ =>
        match (td.t_extends) {
          | hd :: tl =>
            def is_interface (tc : Tycon) {
              if (tc.GetTydecl () == null)
                match ((tc :> TypeBuilder).pt_tydecl) {
                  | PT.TD_interface => true
                  | _ => false
                }
              else
                match (tc.GetTydecl ()) {
                  | TD_interface => true
                  | _ => false
                }
            };
            def hd' = bind (hd);
            match (hd') {
              | T_app (tc, _) when !is_interface (tc) =>
                this.t_extends = Some (hd'); 
                this.t_implements = List.Map (tl, bind);
              | _ =>
                this.t_implements = hd' :: List.Map (tl, bind);
                this.t_extends = None ()
            }
          | [] =>
            this.t_implements = [];
            this.t_extends = None ()
        }
    };

    when (pt_tydecl is PT.TD_enum)
        handle_underlying_enum_type ();
    
    // warn about nested value types 
    when (Option.IsSome (enclosing_type) && (is_struct || is_enum))
      Message.warning (loc, "nested value types fail to compile under .NET Framework v1.1");

    // perform additional checks for structures
    when (is_struct)
    {      
      // make the structure inherit from System.ValueType
      when (Option.IsSome (t_extends))        
        Message.error (loc, "structures are not allowed to inherit from other types");

      when (List.Length (t_implements) > 0)
        Message.error (loc, "structures are not allowed to implement interfaces");
        
      t_extends = Some (bind (<[ type : System.ValueType ]>));

      // make sure no bogus attributes have been specified
      def access_mask =            
        NemerleAttributes.Public %| NemerleAttributes.Internal %|
        NemerleAttributes.Protected %| NemerleAttributes.Private %|
        NemerleAttributes.Struct;

      def negated_access_mask =
        ((~ (access_mask :> int)) :> NemerleAttributes);
        
      when ((modifiers.mods %& negated_access_mask) != NemerleAttributes.None)
        Message.error (loc, "structures are only allowed to have access specifiers as attributes");
        
      // mark the structure as sealed
      modifiers.mods = modifiers.mods %| NemerleAttributes.Sealed %| NemerleAttributes.Struct;

      is_value_type = true;
    }

    match (t_extends) {
      | None =>
        match (pt_tydecl) {
          | PT.TD_interface 
          | PT.TD_alias => ()
          | _ =>
            t_extends = Some (bind (<[ type: System.Object ]>))
        }
      | Some => ()
    };
    
    // construct this.iterate_first:
    def iterate_first = Hashtable ();
    def add_tycon (tc : Tycon) {
      when (tc != null) {
        match (tc.GetTyconKind ()) {
          | TK_NemerleType (ti) => iterate_first.Set (ti.GetId (), ti)
          | _ => ()
        }
      }
    };
    def add_type (t : Type) {
      match (t) {
        | T_app (tc, _) => add_tycon (tc)
        | _ => ()
      }
    };
    def add_from (ti : TypeBuilder) {
      def is_self (ti : Tycon) {
        if (ti == null) false
        else ti == (this : Tycon) || is_self (ti.DeclaringType)
      };
      def add_not_self (ti : TypeBuilder) {
        when (! is_self (ti)) {
          iterate_first.Set (ti.GetId (), ti)
        }
      };
      assert (ti.iterate_first != null);
      List.Iter (ti.iterate_first, add_not_self)
    };
    List.Iter (GetDirectSuperTypes (), add_type);
    List.Iter (this.contained_types, add_from);
    this.iterate_first = iterate_first.Fold ([], fun (_, ti, acc) { ti :: acc });
  }

  /**
   * Construct datastructures we use to check subtyping relations.
   *
   * <remarks>
   *   This probably the hardest part of processing type declarations.
   *
   *   Each type directly subtypes types it extends or implements.  This
   *   pass computes transitive closure of direct subtyping relation
   *   and stores it [TypeBuilder.subtypes] map.  .NET generics doesn't allow
   *   same type to be subtyped under different instantiations, so we
   *   use map from (id of) subtyped TypeBuilder object to actual parameters
   *   of subtyped type.
   * </remarks>
   */
  static determine_subtyping () : void
  {
    Iter (fun (ti : TypeBuilder) { 
            ti.construct_subtyping_map () 
          });
  }

  construct_subtyping_map () : void
  {
    def add_srs (t, s : Subinfo) {
      match (t) {
        | T_app (ti', args) => add_subtyping_of (s, ti', args)
        | _ =>
          Message.error (loc, "cannot implement nor extend non-class type");
          s
      }
    };
    subtypes = List.FoldLeft (GetDirectSuperTypes (), SystemMap (), add_srs)
  }

  add_subtyping_of (subinfo : Subinfo, tc : Tycon, args : list <Type>) : Subinfo
  {
    def add_sr (subinfo : Subinfo, subtyped : Tycon, args : list <Type>) {
      match (subinfo.Find (subtyped.GetId ())) {
        | Some ((_, args')) =>
          mutable problem = "";
          def check_eq (t1 : Type, t2 : Type) : bool {
            if (Tyutil.types_eq (t1, t2)) true
            else {
              problem = "types " + t1.as_string() + " and " +
                         t2.as_string() + " are not compatible";
              false
            }
          };
          unless (List.ForAll2 (args, args', check_eq)) {
            Message.error ("type `" + subtyped.FullName +
                           "' is implemented by type `" +
                           FullName + "' twice under different instantiations");
            if (tc.GetId () == subtyped.GetId ())
              Message.error ("second one directly")
            else
              Message.error ("second one through `" + tc.FullName + "'");
            Message.error (problem);
          };
          subinfo
        | None =>
          subinfo.Add (subtyped.GetId (), (subtyped, args))
      }
    };

    def sub = tc.MakeSubst (args);

    def add_srt (t, subinfo : Subinfo) {
      match (t) {
        | T_app (tc, args) =>
          add_sr (subinfo, tc, List.Map (args, fun (t) { t /- sub }))
        | _ => Util.ice ("extending non-class type")
      }
    };

    def subinfo = List.FoldLeft (tc.GetSuperTypes (), subinfo, add_srt);
    def subinfo = add_sr (subinfo, tc, args);
    subinfo
  }

  public GetSuperTypes () : list <Type>
  {
    if (subtypes == null) []
    else
      subtypes.Fold (fun (_, x, acc) {
                        def (tc, args) = x;
                        T_app (tc, args) :: acc },
                     [])
  }

  begin_adding_members () : void
  {
    def get_members (t) {
      match (t) {
        | T_app (tc, _) => tc.GetMembers ()
        | _ => []
      }
    };
    def members = 
      match (GetTydecl ()) {
        | TD_interface =>
          List.Concat (List.Map (GetDirectSuperTypes (), get_members))
        | _ =>
          match (t_extends) {
            | Some (t) => get_members (t)
            | None => []
          }
      };
      
    def inherit_it (mem : IMember) {
      if (mem.IsStatic)
        false
      else
        match (mem.GetKind ()) {
          | MK_method (mem) =>
            match (mem.GetFunKind ()) {
              | FK_ctor => false
              | _ => true
            }
          | MK_field =>
            has_fields = true;
            true
          | _ => true
        }
    };

    def add (mem : IMember, map : SystemMap <string, list <IMember>>) {
      if (inherit_it (mem)) {
        def n = mem.Name;
        match (map.Find (n)) {
          | Some (l) => map.Replace (n, mem :: l)
          | None => map.Add (n, [mem])
        }
      } else
        map
    };

    member_map = List.FoldLeft (members, SystemMap (), add);
    member_list = []
  }

  internal static constrain_member (m : IMember, flags : BindingFlags) : bool
  {
    def is_public = m.Attributes %&& NemerleAttributes.Public;
    // if flag is Public then always return all public members
    flags == BindingFlags.Public && is_public ||
    // if flag is NonPublic then always return all nonpublic members
    flags == BindingFlags.NonPublic && !is_public ||
    // masks
    (!m.IsStatic || flags %&& BindingFlags.Static) &&
    (m.IsStatic || flags %&& BindingFlags.Instance) &&
    (!is_public || flags %&& BindingFlags.Public) &&
    (is_public || flags %&& BindingFlags.NonPublic)
  }

  /** Note that [bindingAttr] is used only to check the case for DeclaredOnly
      members, so you have to provide filter function to check other flags */
  private get_members (bindingAttr : BindingFlags, filter : IMember -> bool)
  : list <IMember>
  {
    def maybe_add (m : IMember, acc) {
      if (filter(m)) m :: acc else acc
    };
    def add_few (_, mems, acc) {
      List.FoldLeft (mems, acc, maybe_add)
    };
    if (bindingAttr %&& BindingFlags.DeclaredOnly)
      List.Filter (member_list, filter)
    else
      member_map.Fold (add_few, [])
  }
  
  /** Searches for the members defined for the current TypeInfo, using the specified
      binding constraints.
      <remarks>
        Members include properties, methods, fields, events, and so on.

        The following BindingFlags filter flags can be used to define which members to
        include in the search: 
        <ul>
          <li>
            You must specify either BindingFlags.Instance or BindingFlags.Static in order to
            get a return.
          </li>
          <li>
            Specify BindingFlags.Public to include public members in the search.
          </li>
          <li>
            Specify BindingFlags.NonPublic to include non-public members (that is, private
            and protected members) in the search.
          </li>
        </ul>

        The following BindingFlags modifier flags can be used to change how the search
        works: 

        BindingFlags.DeclaredOnly to search only the members declared on the Type,
        not members that were simply inherited.

        Calling this method with only the Public flag or only the NonPublic flag will
        return the specified members and does not require any other flags.

        See Nemerle.Compiler.BindingFlags for more information.
      </remarks>
   */
  public GetMembers (bindingAttr : BindingFlags) : list <IMember>
  {
    get_members (bindingAttr, fun (m : IMember) {
      constrain_member (m, bindingAttr)
    })
  }
  
  public GetMembers () : list <IMember>
  {
    get_members ((0 :> BindingFlags), fun (_) { true })
  }

  public GetFields (bindingAttr : BindingFlags) : list <IField>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_field => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list <IField>)
  }
    
  public GetFields () : list <IField>
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MK_field => true | _ => false }
    });
    (mems :> list <IField>)
  }


  /** Searches for the methods defined for the current TypeInfo, using the
      specified binding constraints.
  */
  public GetMethods (bindingAttr : BindingFlags) : list <IMethod>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_ctor | FK_static_ctor => false
            | _ => constrain_member (m, bindingAttr)
          }
        | _ => false
      }
    });
    (mems :> list <IMethod>)
  }

  public GetMethods () : list <IMethod>
  {
    GetMethods (BindingFlags.Static %| BindingFlags.Instance %|
                BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the constructors defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetConstructors (bindingAttr : BindingFlags) : list <IMethod>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_ctor | FK_static_ctor =>
              constrain_member (m, bindingAttr)
            | _ => false
          }
        | _ => false
      }
    });
    (mems :> list <IMethod>)
  }

  public GetConstructors () : list <IMethod>
  {
    GetConstructors (BindingFlags.Static %| BindingFlags.Instance %|
                     BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the types defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetNestedTypes (bindingAttr : BindingFlags) : list <Tycon>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_type (t) =>
          constrain_member (t, bindingAttr %| BindingFlags.Static %|
                            BindingFlags.Instance)
        | _ => false
      }
    });
    (mems :> list <Tycon>)
  }

  public GetNestedTypes () : list <Tycon>
  {
    GetNestedTypes (BindingFlags.Static %| BindingFlags.Instance %|
                    BindingFlags.Public %| BindingFlags.NonPublic)
  }

  public GetProperties (bindingAttr : BindingFlags) : list <IProperty>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_property => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list <IProperty>)
  }
    
  public GetProperties () : list <IProperty>
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MK_property => true | _ => false }
    });
    (mems :> list <IProperty>)
  }

  public GetEvents (bindingAttr : BindingFlags) : list <IEvent>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_event => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list <IEvent>)
  }
    
  public GetEvents () : list <IEvent>
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MK_event => true | _ => false }
    });
    (mems :> list <IEvent>)
  }

  public BindType (t : PT.Type) : Type
  {
    BindType (tenv, t)
  }

  public BindType (other_tenv : Tyvar.TEnv, t : PT.Type) : Type
  {
    other_tenv.bind (env, this, t, check_parms = true)
  }

  public BindTyparms (tp : PT.Typarms) : Tyvar.TEnv * list <Tyvar.T>
  {
    BindTyparms (tenv, tp)
  }

  public BindTyparms (other_tenv : Tyvar.TEnv, tp : PT.Typarms)
  : Tyvar.TEnv * list <Tyvar.T>
  {
    other_tenv.add_typarms (env, tp, this, check_parms = true)
  }

  /** Check if types that are already bound are correctly applied. */
  check_bound_types () : void
  {
    def types =
      match (tydecl) {
        | TD_alias (t) => t :: GetDirectSuperTypes ()
        | _ => GetDirectSuperTypes ()
      };
    def check_type (t) {
      match (t) {
        | T_ref (t) => check_type (t)
        | T_out (t) => check_type (t)
        | T_array (t, _) => check_type (t)
        | T_fun (ts, t) => check_type (ts); check_type (t)
        | T_void => ()
        | T_prod (ts) => List.Iter (ts, check_type)
        | T_var => ()
        | T_app (ti, args) =>
          List.Iter (args, check_type);
          ignore (ti.MakeSubst (args));
      }
    };
    def do_check_type (t) { 
      Tyutil.CheckAccessibility (accessibility, t);
      check_type (t);
    };
    def check_constraints_in_tv (tv) {
      List.Iter (Tyvar.constraints (tv), do_check_type)
    };
    List.Iter (types, do_check_type); // access check also here
    List.Iter (typarms, check_constraints_in_tv);
  }

  describe_member (m : IMember) : string
  {
    def kind =
      match (m.GetKind ()) {
        | MK_field => "a field"
        | MK_method => "a method"
        | MK_property => "a property"
        | MK_type => "a type"
        | MK_event => "an event"
      };
    def full_name =
      if (m.DeclaringType == null)
        m.Name
      else
        m.DeclaringType.FullName + "." + m.Name;
    match (m.GetKind ()) {
      | MK_method (m) =>
        def parms = List.Map (m.GetHeader ().parms, 
                              fun (p : Fun_parm) { 
                                  p.name + " : " + p.ty.as_string () 
                              });
        def ret_ty = m.GetHeader ().ret_type.as_string ();
        kind + " " + full_name + "(" + NString.Concat (", ", parms) + ") : " + ret_ty
      | _ =>
        kind + " `" + full_name + "'"
    }
        
  }

  public GetLocation () : Location
  {
    loc
  }

  public BindAndAddMember (class_member : PT.Class_member) : void
  {
    try { 
      ignore (bind_and_add_member (class_member))
    } catch {
      | _ : Recovery => ()
    }
  }
  
  bind_and_add_member (class_member : PT.Class_member) : IMember
  {
    Util.locate (class_member.loc, {
      when (is_module)
        class_member.modifiers.mods |= NemerleAttributes.Static;      
        
      match (tydecl) {
        | TD_interface =>
          class_member.modifiers.mods |= NemerleAttributes.Virtual;
          class_member.modifiers.mods |= NemerleAttributes.Abstract;
        | _ => ()
      };
      
      match (class_member) {
        | PT.M_enum
        | PT.M_type => null
          
        | (PT.M_field) as f =>
          def r = (NemerleField (this, f) : IMember);
          CheckFieldAttributes ((r :> NemerleField));
          AddMember (r);
          r
          
        | (PT.M_function) as f =>          
          def r = NemerleMethod (this, f);
          CheckMethodAttributes (r);
          AddMember (r);
          r
          
        | (PT.M_property) as p =>
          def r = NemerleProperty (this, p);
          when (r.IsIndexer && r.Name == "Item") {
            default_indexer = "Item";
            modifiers.AddCustomAttribute (System.AttributeTargets.Class,
                                          <[ System.Reflection.DefaultMemberAttribute ("Item") ]>);
          }
          CheckPropertyAttributes (r);
          AddMember (r);
          r
          
        | (PT.M_event) as e =>
          def r = NemerleEvent (this, e);
          CheckEventAttributes (r);
          AddMember (r);
          r
      }
    })
  }

  public DefaultIndexerName : option <string>
  {
    get {
      if (default_indexer == null)
        match (SuperClass ()) {
          | Some (tc) => tc.DefaultIndexerName
          | None => None ()
        }
      else
        Some (default_indexer)
    }
  }
      
  public AddMember (mem : IMember) : void
  {
    def replace_method (acc, meth : IMethod, mems) {
      match (mems) {
        | [] =>
          when (mem.Attributes %&& (NemerleAttributes.New 
                                    %| NemerleAttributes.Override))
            Message.error ("`override' and/or `new' specified on " + 
                           describe_member (mem) + 
                           ", but there is no method with this signature "
                           "in parent to override");
          mem :: acc
        | x :: xs =>
          match ((x : IMember).GetKind ()) {
            | MK_method (m) =>
              def sub = SubtypingSubst (m.DeclaringType);

              when (m.DeclaringType.SameAs (this))
                match ((m.GetMemType () /- sub, mem.GetMemType ())) {
                  | (T_fun (t1, r1), T_fun (t2, r2))
                    when Tyutil.types_eq (t1, t2) && ! Tyutil.types_eq (r1, r2) =>
                    Message.error (mem.GetLocation (), 
                                   "attemted return type overload on " +
                                   describe_member (mem) + " and " +
                                   describe_member (m))
                  | _ => ()
                };
                
              if (Tyutil.types_eq (m.GetMemType () /- sub, mem.GetMemType ())) {
                match (m.GetFunKind ()) {
                  | _ when m.DeclaringType.SameAs (this) =>
                    Message.error (mem.GetLocation (),
                                   "redefinition of " + describe_member (mem))
                  | FK_ctor | FK_static_ctor => ()
                  | _ when mem.Attributes %&& NemerleAttributes.New => ()
                  | _ when mem.Attributes %&& NemerleAttributes.Override =>
                    if (x.Attributes %&& NemerleAttributes.Virtual)
                      if (x.Attributes %&& NemerleAttributes.Sealed)
                        Message.error ("`override' specified on " + 
                                       describe_member (mem) + 
                                       ", but " + 
                                       describe_member (x) + " is `sealed'")
                      else {}
                    else
                      Message.error ("`override' specified on " + 
                                     describe_member (mem) + 
                                     ", but there is no `virtual' modifier on " + 
                                     describe_member (x));
                    when ((x.Attributes %& NemerleAttributes.AccessModifiers) !=
                          (mem.Attributes %& NemerleAttributes.AccessModifiers))
                      Message.error ("attempt to change the access modifiers of " + 
                                     describe_member (mem) + " during override of " +
                                     describe_member (x));
                  | _ =>
                    Message.error (mem.GetLocation (), describe_member (mem) +
                                   " hides " + describe_member (x) +
                                   " but no `new' specified")
                };
                List.RevAppend (xs, mem :: acc)
              } else replace_method (x :: acc, meth, xs)
            | _ => Util.ice ("expecting method, got " + describe_member (x))
          }
      }
    };

    def new_mems =
      match (member_map.Find (mem.Name)) {
        | Some ([]) => Util.ice ()
        | Some ((x :: _) as old) =>
          if (x.DeclaringType.SameAs (this))
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | (MK_property (p1), MK_property (p2)) when p1.IsIndexer && p2.IsIndexer =>
                // overloading is (hopefully) checked at the get/set method level
                mem :: old
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " redefined in `" + FullName + "'");
                Message.error (x.GetLocation (), "  first definition here as " +
                               describe_member (x));
                [mem]
            }
          else
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | (MK_property (new_prop), MK_property) 
                  when new_prop.Attributes %&& NemerleAttributes.Override =>
                [mem]
              | _ when mem.Attributes %&& NemerleAttributes.New => [mem]
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " hides " + describe_member (x) +
                               " but no `new' specified");
                [mem]
            }

        | None =>
          when (mem.Attributes %&& (NemerleAttributes.New 
                                    %| NemerleAttributes.Override))
            Message.error ("`override' and/or `new' specified on " + 
                           describe_member (mem) + 
                           ", but there is no such member "
                           "in parent to override");
          [mem]
      };

    unless (has_fields) {
      match (mem.GetKind ()) {
        | MK_field => has_fields = true
        | _ => ()
      }
    };

    member_map = member_map.Replace (mem.Name, new_mems);
    member_list = mem :: member_list;
  }

  /** Return list of all members defined in this very type. */
  public GetDirectMembers () : list <IMember>
  {
    member_list
  }

  public GetTypeBuilder () : System.Reflection.Emit.TypeBuilder
  {
    assert (type_builder != null);
    type_builder
  }

  public GetSystemType () : System.Type
  {
    assert (system_type != null);
    system_type
  }
  
  
  public GetVariantOptionParent () : TypeBuilder
  {
    assert (variant_option_parent != null);
    variant_option_parent
  }
  
  
  public GetVariantOptions () : list <TypeBuilder>
  {
    variant_options
  }

  mutable underlying_enum_type_iface : INumericType;
  mutable underlying_enum_type : Type;
  
  handle_underlying_enum_type () : void
  {
    match (t_extends) {
      | Some (t) =>
        underlying_enum_type = t;
      | None =>
        underlying_enum_type = InternalType.Int32;
    };
    
    t_extends = Some (InternalType.Enum);

    match (t_implements) {
      | [] => ()
      | _ => Message.error ("enum cannot implement anything")
    };

    def oops () {
      Message.error ("`" + underlying_enum_type.as_string () + "' is not valid underlying enum type");
    };

    
    match (Tyutil.top_expand (underlying_enum_type)) {
      | T_app (tc, []) =>
        match (NumericType.ByName (tc.FullName)) {
          | Some (t) when t.IsInteger =>
            underlying_enum_type_iface = t
          | _ => oops ()
        }
      | _ => oops ()
    }
  }


  /*
   * This methods calculates an enum's field values. We allow constants,
   * references to enum fields of this enum that already have been calculated,
   * arithmetic addition and basic bit-wise operations.
   */
  calculate_enum_value (expr : PT.Expr, default_value : object,
                        resolved_values : Hashtable <string, object>) : object
  {
    def enum_type = underlying_enum_type_iface;

    def eval (expr) : object
    {
      match (expr) {
        | PT.E_literal (lit) =>
          def have_good_literal_type =
            match (lit) {
              | L_byte
              | L_sbyte
              | L_short
              | L_ushort
              | L_int
              | L_uint
              | L_long
              | L_ulong =>
                true

              | _ =>
                false
            }

          if (have_good_literal_type)
          {            
            def val = enum_type.FromLiteral (lit);
        
            if (val == null)
            {
              Message.error ("underlying type of enum `" + FullName + 
                             "' is `" + underlying_enum_type.as_string () + 
                             "', so enum literal need to have this type");
              default_value
            }
            else
              val
          }
          else
          {
            Message.error ("only 8, 16, 32 and 64-bit, signed and unsigned integer " +
                           "types are allowed as enum values");
            default_value
          }
          
        | PT.E_ref (name) =>
          match (resolved_values.Get (name.GetHead ())) {
            | Some (value) => value
            | _ =>
              Message.error ("references are allowed only to this enum's fields preceding " +
                             "this one in the source code");
              default_value
          }
            
        | <[ ~ $p ]> =>
          enum_type.Unary ("~", eval (p))
          
        | <[ $p + $q ]> =>
          enum_type.Binary ("+", eval (p), eval (q))

        | <[ $p - $q ]> =>
          enum_type.Binary ("-", eval (p), eval (q))
          
        | <[ $p %| $q ]> =>
          enum_type.Binary ("%|", eval (p), eval (q))

        | <[ $p %& $q ]> =>
          enum_type.Binary ("%&", eval (p), eval (q))

        | <[ $p %^ $q ]> =>
          enum_type.Binary ("%^", eval (p), eval (q))
          
        | _ =>
          Message.error ("enum definition expression is too complex");
          Message.hint ("  enum definitions are allowed to be expressions taking constants,");
          Message.hint ("  references to this enum's fields preceding this field, checked ");
          Message.hint ("  operations + and -, bit-wise operations %|, %&, %^ and negation");          
          default_value
      }
    }

    eval (expr)
  }
  
  add_enum_members (decls : list <PT.Class_member>) : void
  {
    def field_type = PT.T_typed (GetMemType ());
    def enum_type = underlying_enum_type_iface;
    def resolved_values = Hashtable (32);
    
    def add_field (ef : PT.Class_member, default_value) {
      def current_value =
        match (ef) {
          | PT.M_enum (Some (expr)) =>
            calculate_enum_value (expr, default_value, resolved_values)

          | PT.M_enum (None) =>
            default_value
            
          | _ =>
            Util.ice ("add_enum_members")
        }
      
      ef.modifiers.mods |= NemerleAttributes.Public %| NemerleAttributes.Static;
      def field = PT.M_field (ef.loc, ef.name, ef.modifiers, field_type);
      def field = bind_and_add_member (field);
      (field :> NemerleField).enum_value = current_value;
      resolved_values.Add (Macros.StringOfSString (ef.name), current_value);
      enum_type.Binary ("+", current_value, enum_type.One)
    };

    BindAndAddMember (<[ decl: public value__ : $(PT.T_typed (underlying_enum_type)); ]>);
    ignore (List.FoldLeft (decls, underlying_enum_type_iface.Zero, add_field));
  }
  

  /**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [TypeBuilder.contained_types]) and store
   * them in [TypeBuilder.member_map] and [TypeBuilder.member_list].
   *
   * <remarks>
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   */
  add_members () : void
  {
    begin_adding_members ();
    def decls =
      match (pt_tydecl) {
        | PT.TD_class (ds)
        | PT.TD_interface (ds)
        | PT.TD_variant (ds)
        | PT.TD_variant_option (ds) => ds
        | PT.TD_enum (ds) =>
          add_enum_members (ds); []
        | _ => []
      };
    List.Iter (decls, BindAndAddMember);
    List.Iter (additional_decls, BindAndAddMember);

    contained_types = List.Rev (contained_types);
    List.Iter (contained_types, AddMember);
    
    member_list = List.Rev (member_list);

    // we no longer need it, let GC kill it
    pt_tydecl = null;
    additional_decls = null;
  }

  add_constant_object_ctor () : void
  {
    match (member_map.Find (".ctor")) {
      | Some ([ctor]) =>
        def ctor = (ctor :> NemerleMethod);
        def field = PT.M_field (loc = loc, 
                                name = PT.SS_string (PT.Name ("_N_constant_object")), 
                                modifiers = Modifiers (NemerleAttributes.Public %|
                                                       NemerleAttributes.Static, []),
                                ty = PT.T_void ());
        def typed_field = NemerleField (this, (field :> PT.M_field));
        typed_field.MarkWithSpecialName ();
        typed_field.ty = variant_option_parent.GetMemType ();
        ctor.modifiers.mods = NemerleAttributes.Private;
        AddMember (typed_field);
        
        constant_object = Some ((typed_field : IField));
        
        def fh = PT.Fun_header (loc = loc, 
                                name = PT.SS_string (PT.Name ("this")),
                                ret_type = <[ type: void ]>,
                                parms = []);
        def ttf = typed_field.ty;
        
        // use typed trees here to avoid problems during actual typing
        def tbody = E_assign (loc, T_void (),
                              E_static_ref (loc, ttf, typed_field), 
                              E_call (loc, ttf,
                                      E_static_ref (loc, ctor.GetMemType (), ctor), []));
                                      
        def body = <[ { $(tbody : typed) } ]>;
        def static_ctor =
          PT.M_function (loc = loc, 
                         name = PT.SS_string (PT.Name ("this")),
                         modifiers = Modifiers (NemerleAttributes.Static, []),
                         header = fh,
                         kind = FK_ctor (),
                         body = FB_parsed_expr (body));
        BindAndAddMember (static_ctor);

        // add the constant object generator function
        def generator_ret_type = PT.T_typed (typed_field.ty);
        
        def generator = DefineAndReturn (<[ decl:
          public static _N_constant_object_generator () : $(generator_ret_type)
          {
            _N_constant_object
          }
        ]>);

        assert (Option.IsSome (generator));
        Option.UnSome (generator).MarkWithSpecialName ()
        
      | _ => Util.ice ()
    }

  }

  /**
   * Add special methods to variants and variant options. These methods
   * are used to accelerate matching over variants, allowing us to use
   * a single CE_switch statement to identify a variant options instead of 
   * a series of CE_if/CE_has_type instructions.
   *
   */
  private add_special_variant_methods () : void
  {
    match (tydecl) {
      | TD_variant =>
        def gvc = <[ decl:
          public abstract _N_GetVariantCode () : int ;
        ]>;

        gvc.modifiers.mods = gvc.modifiers.mods %| NemerleAttributes.SpecialName;

        Define (gvc)

      | TD_variant_option =>
        mutable my_index = 0;
                       
        ignore (List.Find (variant_option_parent.GetVariantOptions (), fun (x) {
          if (x == this) true else { ++my_index; false }
        }));

        def gvc = <[ decl:
          public override _N_GetVariantCode () : int {
            $(my_index : int)
          }
        ]>;
        
        gvc.modifiers.mods = gvc.modifiers.mods %| NemerleAttributes.SpecialName;
        
        Define (gvc)

      | _ =>
        ()
    }
  }

  /**
   * Add constant fields with single instance of parameter-less 
   * variant options.
   */
  private add_constant_variant_ctors () : void
  {
    constant_object = None ();

    match (tydecl) {
      | TD_variant_option when !has_fields =>
        add_constant_object_ctor ()
      | _ =>
        ()
    }        
  }
  

  static this ()
  {
    infos = [];
  }

  public ConstructTypeBuilder () : void
  {
    when (system_type == null) {
      type_builder = Passes.cgil.ConstructTypeBuilder (this);
      system_type = type_builder;
    }
  }
  
  public FinalizeType () : void
  {
    when (!cannot_finalize && type_builder != null) {
      define_additional_method_overrides ();
      
      system_type = type_builder.CreateType ();
      type_builder = null;
    }
  }

  internal GetTyparms () : list <Tyvar.T>
  {
    typarms
  }

  /** Return interfaces [this] needs to implement (that is it says it will
      implement them, but they are not implemented in base class). */
  public InterfacesToImplement () : list <Tycon> 
  {
    def base_class =
      match (SuperClass ()) {
        | Some (tc) => tc
        | None => InternalType.Object_tc
      };

    def collect (t, acc) {
      match (t) {
        | T_app (tc, _) =>
          match (tc.GetTydecl ()) {
            | TD_interface =>
              match (base_class.SuperType (tc)) {
                | Some => acc
                | None => tc :: acc
              }
            | _ => acc
          }
        | _ => acc
      }
    };
    
    List.FoldLeft (GetSuperTypes (), [], collect);
  }

  check_ctor_constraints () : void
  {
    def check_ctors (ty : Tycon) {
      def check_ctor (member : IMember, acc) {
        match (member.GetKind ()) {
          | MK_method (meth) when meth.DeclaringType.SameAs (ty) =>
            match (meth.GetFunKind ()) {
              | FK_ctor =>
                def is_default = List.IsEmpty (meth.GetHeader ().parms);
                match (acc) {
                  | (true, _) => (true, true)
                  | _ => (is_default, true)
                }
              | _ => acc
            }
          | _ => acc
        }
      };

      List.FoldLeft (ty.GetMembers (), (false, false), check_ctor)
    };

    match (t_extends) {
      | Some (T_app (par, _)) =>
        def (_, has_ctor) = check_ctors (this);
        def (par_has_default, par_has_ctor) = check_ctors (par);
        when (!has_ctor && !par_has_default && par_has_ctor)
          Message.error ("the type `" + FullName + 
                         "' has no constructors and the parent type `" + 
                         par.FullName + "' has no default constructor")
      | _ => ()
    }
  }

  check_abstract () : void
  {
    unless (Attributes %&& NemerleAttributes.Abstract) {
      List.Iter (GetMembers (), fun (m : IMember) {
        match (m.GetKind ()) {
          | MK_method when (m.Attributes %&& NemerleAttributes.Abstract) =>
            modifiers.mods |= NemerleAttributes.Abstract;
            Message.error (describe_member (m) + 
                           " is abstract, but the parent class `" + 
                           FullName + "' is not");
          | _ => ()
        }
      })
    }
  }

  
  /**
   * Defines additional method overrides that have been gathered
   * in check_method_implements from this type's parent types.
   */
  private define_additional_method_overrides () : void
  {
    def define_override (meth : IMethod, iface_meth : IMethod)
    {
      type_builder.DefineMethodOverride (meth.GetMethodInfo (),
                                         iface_meth.GetMethodInfo ())      
    }
    
    List.Iter (m_additional_method_overrides, define_override)
  }


  /**
   * Resolves overrides for the required interface methods
   */
  check_method_implements () : void
  {
    check_abstract ();

    def collect (mem : IMember, acc) {
      match (mem.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_method =>
              (m :> NemerleMethod) :: acc
            | _ => acc
          }
        | _ => acc
      }
    };
    def methods = List.FoldLeft (this.GetDirectMembers (), [], collect);
    
    // FIXME: in fact we should only mark some methods as implemented and scream
    // when signature match is ambigious
    def iface_methods = Hashtable (30);
    
    def add_iface_methods (tc : Tycon) {
      def add_method (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_iface_method when m.DeclaringType.SameAs (tc) =>
                match (iface_methods.Get (m.Name)) {
                  | Some (lst) => iface_methods.Set (m.Name, m :: lst)
                  | None => iface_methods.Add (m.Name, [m])
                }
              | _ => ()
            }
          | _ => ()
        }
      };
      List.Iter (tc.GetMembers (), add_method)
    };
    List.Iter (InterfacesToImplement (), add_iface_methods);

    def bind_explicit_implements (meth : NemerleMethod) {
      def bind_one (name : PT.Splicable_string) {
        def name = Macros.NameOfSString (name);
        def env = name.GetEnv (this.env);
        def (ns, member) = List.DivideLast (name.idl);
        def ty = env.GetType (ns, this);
        match (iface_methods.Get (member)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              iface_meth.DeclaringType.SameAs (ty) &&
                meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] =>
                Message.fatal_error ("interface `" + ty.FullName + 
                                     "' does not contain method named `" + member + 
                                     "' with proper signature")
              | [m] =>
                iface_methods.Set (member, List.Filter (meths, fun (x) { ! is_correct (x) }));
                m
              | _ =>
                Message.fatal_error ("interface `" + ty.FullName + 
                                     "' contains more then one method named `" + member + 
                                     "' with proper signature")
            }
          | None =>
            Message.fatal_error ("no interface implemented by `" + this.FullName + 
                                 "' contains method named `" + member + 
                                 "' (looking for `" +
                                 Util.qid_of_list (name.idl) + "')")
        }
      };
      match (meth.GetFunKind ()) {
        | FK_method (impl) =>
          def impl' =
            try { List.Map (impl, bind_one) }
            catch { _ : Recovery => [] };
          meth.fun_kind = FK_bound_method (impl')
        | _ => ()
      }
    };
    List.Iter (methods, bind_explicit_implements);
    
    def bind_implicit_implements (meth : NemerleMethod) {
      def lookup_iface_members () {
        match (iface_methods.Get (meth.Name)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              (meth.Attributes %&& NemerleAttributes.Public) &&
              (meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this))
            };
            match (List.Filter (meths, is_correct)) {
              | [] => []
              | lst =>
                iface_methods.Set (meth.Name, 
                                   List.Filter (meths, fun (x) { ! is_correct (x) }));
                lst
            }
          | None => []
        }
      };
      match (meth.GetFunKind ()) {
        | FK_bound_method (impl) =>
          match (lookup_iface_members ()) {
            | [] => ()
            | impl' => 
              meth.fun_kind = FK_bound_method (List.Append (impl', impl));
              meth.modifiers.mods |= NemerleAttributes.Virtual;
          }
        | _ => ()
      }
    };
    List.Iter (methods, bind_implicit_implements);

    // create the additional overrides for unresolved interface methods
    mutable resolved_overrides = [];
    
    def create_additional_overrides (name : string, meths : list <IMethod>)
    {
      def possible_impls = LookupMember (name);

      def check_possible_impl (member : IMember)
      {
        when ((member is IMethod)) {
          def meth = (member :> IMethod);
        
          def is_correct (iface_meth : IMethod) {
            (meth.Attributes %&& NemerleAttributes.Public) &&
            (meth.Attributes %&& NemerleAttributes.Virtual) &&
            (meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this))
          };

          def iface_meths = List.Filter (meths, is_correct);

          when (List.Length (iface_meths) > 0)
          {
            resolved_overrides = List.Append (resolved_overrides, iface_meths);

            // create a wrapper in the current type
            def meth_header = meth.GetHeader ();
            def meth_name = Macros.UseSiteSymbol (meth_header.name);
            def meth_ret_type = meth_header.ret_type;
            
            def meth_parms =
              List.Map (meth_header.parms, fun (fp : Fun_parm) {
                def parm_name = Macros.UseSiteSymbol (fp.name);
                <[ funparm: $(parm_name : name) : $(fp.ty : typed) ]>
              });

            def meth_call_parms = List.Map (meth_header.parms, fun (fp : Fun_parm) {
              <[ $(Macros.UseSiteSymbol (fp.name) : name) ]>
            });
              
            def wrapper = DefineAndReturn (<[ decl:
              public override $(meth_name : name) (..$meth_parms) : $(meth_ret_type : typed)
              {
                base.$(meth_name : name) (..$meth_call_parms)
              }
            ]>);

            // unpack the new method definition
            assert (Option.IsSome (wrapper));
            def wrapper = Option.UnSome (wrapper);

            wrapper.MarkWithSpecialName ();
            
            assert ((wrapper is IMethod));
            def wrapper = (wrapper :> IMethod);
            
            // add the new overrides
            def new_overrides =
              List.Map (iface_meths, fun (iface_meth : IMethod) {                
                (wrapper, iface_meth)
              });
            
            m_additional_method_overrides =
              List.Append (new_overrides, m_additional_method_overrides);
          }
        }
      }

      when (List.Length (meths) > 0)
        List.Iter (possible_impls, check_possible_impl)
    }

    iface_methods.Iter (create_additional_overrides);

    List.Iter (resolved_overrides, fun (iface_meth : IMethod) {
      def iface_meths = iface_methods.Get (iface_meth.Name);

      when (Option.IsSome (iface_meths)) {
        iface_methods.Set (iface_meth.Name, 
                           List.Filter (Option.UnSome (iface_meths), fun (x) { x != iface_meth }))
      }
    });               
    
    // emit error messages for any unbound interface method
    def scream_about_unimplemented (_, meths)
    {
      def scream_about (meth : IMethod) {
        Message.error ("unimplemented interface method `" + 
                       meth.DeclaringType.FullName + 
                       "." + meth.Name + "' with signature " +
                       Tyutil.fun_type (meth.GetHeader ()).as_string ())
      };
      List.Iter (meths, scream_about)
    }
    
    iface_methods.Iter (scream_about_unimplemented)
  }


  process_macro_attributes (stage : int) : void
  {
    def process_attributes (self_parm, suff, mods : Modifiers, meth : IMethod) {
      mutable macro_attrs = mods.macro_attrs;
      def new_custom =
        List.Filter (mods.custom_attrs, fun (expr) {
          match (MacroRegistry.lookup_macro (env, expr, suff)) {
            | None => true
            | Some =>
              macro_attrs = (suff, expr) :: macro_attrs;
              false
          }
        });
      List.Iter (macro_attrs, fun (mattribute) {
        def (_, expr) = mattribute;
        match (MacroRegistry.lookup_macro (env, expr, suff)) {
          | None => ()
          | Some ((name, imacro, exprs)) =>
            def meth_header =
              if (meth == null) null else meth.GetHeader ();
            def tenv = 
              if (meth_header == null) this.tenv else meth_header.tenv;
            def in_ctor =
              if (meth != null)
                match (meth.GetFunKind ()) {
                  | FK_ctor => true 
                  | _ => false
                }
              else
                false;
            def ctx =
              TypingContext (in_ctor = in_ctor,
                             this_ptr_decl = None (),
                             env = this.env,
                             tenv = tenv,
                             current_fun = meth_header,
                             locals = null,
                             parent_type = this,
                             in_tail_position = false,
                             is_checked = true);
//  FIXME: THIS IS CORRECT!
//            TypingContext.PushNewColor (name.color, name.GetEnv (env));

/// FIXME: THIS IS BAD, BUT ONLY THIS BOOTSTRAP
            TypingContext.PushNewColor (name.color, name.GetEnv (null));
            def parms = 
              List.Append (self_parm, imacro.CallTransform (exprs));
            def res = imacro.Run (ctx, parms);
            TypingContext.PopColor ();

            assert (res == null);
            ()
        }
      });
      mods.custom_attrs = new_custom;
      mods.macro_attrs = macro_attrs;
    };

    def process_member (mem, stage_suff) {
      match (mem) {
        | PT.M_field =>
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxDeclaration (mem)],
                                     ":field" + stage_suff, mem.modifiers, null)

        | (PT.M_function) as f =>
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxDeclaration (mem)],
                              ":method" + stage_suff, mem.modifiers, null);

          def iter_parm (p : PT.Fun_parm) {
            process_attributes ([PT.SyntaxTTycon (this),
                                 PT.SyntaxDeclaration (mem),
                                 PT.SyntaxFunParm (p)],
                                ":param" + stage_suff,  p.modifiers, null);
          };
          List.Iter (f.header.parms, iter_parm);
                                    

        | PT.M_enum
        | PT.M_type => ()

        | PT.M_property =>
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxDeclaration (mem)],
                              ":property" + stage_suff, mem.modifiers, null)

        | PT.M_event => 
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxDeclaration (mem)],
                              ":event" + stage_suff, mem.modifiers, null)
      }
    };

    def iter_decls (stage_suff) {
      def decls =
        match (pt_tydecl) {
          | PT.TD_class (ds)
          | PT.TD_interface (ds)
          | PT.TD_variant (ds)
          | PT.TD_variant_option (ds) => ds
          | _ => []
        };
      def f (x) { process_member (x, stage_suff) };
      List.Iter (decls, f);
      List.Iter (additional_decls, f);
    };

    def process_typed_member (mem : IMember) {
      def mods () { (mem :> NemerleMember).modifiers };
      match (mem.GetKind ()) {
        | MK_field (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                                PT.SyntaxTField ((f :> NemerleField))],
                                     ":field:postadd", mods (), null)
        | MK_method (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                                PT.SyntaxTMethod ((f :> NemerleMethod))],
                               ":method:postadd", mods (), f);
          def iter_parm (p : Fun_parm) {
            process_attributes ([PT.SyntaxTTycon (this),
                                 PT.SyntaxTMethod ((f :> NemerleMethod)),
                                 PT.SyntaxTFunParm (p)],
                                 ":param:postadd", p.modifiers, f);
          };
          List.Iter (f.GetHeader ().parms, iter_parm);
                              
        | MK_property (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                                PT.SyntaxTProperty ((f :> NemerleProperty))],
                               ":property:postadd", mods (), null)

        | MK_event (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                                PT.SyntaxTEvent ((f :> NemerleEvent))],
                               ":event:postadd", mods (), null)

        | MK_type => ()
      }
    };

    match (stage) {
      | 1 =>
        process_attributes ([PT.SyntaxTTycon (this)], ":type:postscan", modifiers, null);
        iter_decls (":postscan");

      | 2 =>
        process_attributes ([PT.SyntaxTTycon (this)], ":type:preadd", modifiers, null);
        iter_decls (":preadd");
        
      | 3 =>
        process_attributes ([PT.SyntaxTTycon (this)], ":type:postadd", modifiers, null);
        List.Iter (GetDirectMembers (), process_typed_member);

      | _ => assert (false)
    }
  }


  /**
   * Main function of type declaration handling pass.
   *
   * <remarks>
   *   - constructing typing environments [TypeBuilder.make_tyenvs]
   *   - binding types [TypeBuilder.bind_types]
   *   - determining subtyping relations [TypeBuilder.determine_subtyping]
   *   - checking subtyping constraints on types that are already bound
   *     [TypeBuilder.check_bound_types]
   *   - adding members [TypeBuilder.add_members]
   *   - adding the variant/variant option special matching methods
   * </remarks>
   */
  public static Run () : void
  {
    infos = List.Rev (infos);
    run_phase = 1;

    List.Iter (infos, fun (x : TypeBuilder) {
      Util.locate (x.loc, x.process_macro_attributes (1))
    });

    SourceTopIter (fun (x : TypeBuilder) { 
                      x.make_tyenvs (Tyvar.TEnv ()) 
                    });
    def bind_types (x : TypeBuilder) {
      Util.locate (x.loc, x.bind_types ())
    };
    
    run_phase = 2;
    List.Iter (List.Rev (infos), bind_types);

    // add the _N_GetVariantCode methods to variants and variant options
    Iter (fun (x : TypeBuilder) { x.add_special_variant_methods () });
    
    run_phase = 3;
    determine_subtyping ();
    
    run_phase = 4;
    Iter (fun (x : TypeBuilder) { x.check_bound_types () });

    run_phase = 5;
    
    Iter (fun (x : TypeBuilder) { x.process_macro_attributes (2) });

    Iter (fun (x : TypeBuilder) { x.add_members () });

    Iter (fun (x : TypeBuilder) { x.process_macro_attributes (3) });

    // add constant object constructors for constant variant options
    Iter (fun (x : TypeBuilder) { x.add_constant_variant_ctors () });

    // propagate the SpecialName attribute if needed
    Iter (fun (x : TypeBuilder) { 
      when (x.modifiers.mods %&& NemerleAttributes.SpecialName)
        x.mark_members_with_special_name ()
    });
    
    def check_method_implements (ti : TypeBuilder) {
      match (ti.GetTydecl ()) {
        | TD_interface => ()
        | _ => ti.check_method_implements ()
      }
    };

    Iter (check_method_implements);

    Iter (fun (x : TypeBuilder) { x.check_ctor_constraints () });
  }

  internal FixupDefinedClass () : void
  {
    // finalization is blocked until call to Compile
    this.cannot_finalize = true;
    this.constant_object = None ();
    when (run_phase >= 1)
      match (enclosing_type) {
        | Some (ti) =>
          make_tyenvs (ti.tenv)
        | None =>
          make_tyenvs (Tyvar.TEnv ())
      };
    when (run_phase >= 2)
      Util.locate (loc, bind_types ());
    when (run_phase >= 3)
      construct_subtyping_map ();
    when (run_phase >= 4)
      check_bound_types ();
    when (run_phase >= 5)
      begin_adding_members ();
  }


  public AddImplementedInterface (t : PT.Type) : void
  {
    pt_tydecl.t_extends = List.Append (pt_tydecl.t_extends, [t])
  }
  
  public DefineNestedType (td : PT.Class_member) : ITypeModifier
  {
    | PT.M_type (td) =>
      def name = match (Macros.NameOfSString (td.name).idl) {
        | [x] => x;
        | x :: _ => Message.error ("cannot define nested type with long name"); x
        | _ => assert (false, "Empty name")
      };
      def fullns = env.GetCurrentNamespaceND ().Path (name);
      def tyinfo = TypeBuilder (Some (this), None (), env.AddOpenNamespace (fullns), td);
      GlobalEnv.AddType (fullns, tyinfo);
      tyinfo.FixupDefinedClass ();
      match (td) {
        | PT.TD_class (decls) =>
          List.Iter (decls, fun (x : PT.Class_member) { tyinfo.Define (x) });
        | _ => ()
      };
      tyinfo
    | _ =>
      Message.error ("expected declaration of nested type");
      null
  }


  /**
   * Adds a definition and returns the new NemerleMember, if available
   */
  public DefineAndReturn (f : PT.Class_member) : option <NemerleMember>
  {
    if (member_map == null) {
      additional_decls = f :: additional_decls;
      None ()
    }
    else {
      try {
        def mem = bind_and_add_member (f);
        Passes.cgil.MemberAdded (this, mem);
        Some (mem :> NemerleMember)
      } catch {
        | _ : Recovery => None ()
      }
    }
  }


  /**
   * Adds a definition to this type
   */
  public Define (f : PT.Class_member) : void
  {
    ignore (DefineAndReturn (f))
  }


  /**
   * Builds this type
   */
  public Compile () : void
  { 
    cannot_finalize = false;
    when (type_builder != null) {
      this.FinalizeType ();
      Passes.MarkTypeBuilderCompiled ();
    }
  }


  public FindAttribute (looking_for : Tycon) : option <PT.Expr>
  {
    mutable result = None ();
    
    def find_our_attribute (expr) {
      match (AttributeCompiler.ResolveAttribute (this.env, expr)) {
        | Some ((t, _)) =>
          when (looking_for.SameAs (t))
            result = Some (expr)
            
        | _ => ()
      }
    }
    
    List.Iter (GetModifiers ().custom_attrs, find_our_attribute);

    result
  }


  public HasAttribute (attribute : Tycon) : bool
  {
     Option.IsSome (FindAttribute (attribute))
  }
  
  /** Nemerle.Reflection  interfaces */


  /* ---------------------------------------------------------------------- */
  /* -- VALIDITY CHECKS --------------------------------------------------- */
  /* ---------------------------------------------------------------------- */

  /**
   * Performs access attributes related checks. Returns an optional
   * description of the problem.
   */
  internal static CheckAccessAttributes (attrs : NemerleAttributes) : option <string>
  {
    def access_attrs_count =
      (if (attrs %&& NemerleAttributes.Public)    1 else 0) +
      (if (attrs %&& NemerleAttributes.Internal)  1 else 0) +
      (if (attrs %&& NemerleAttributes.Protected) 1 else 0) +
      (if (attrs %&& NemerleAttributes.Private)   1 else 0);

    def is_protected_internal =
      attrs %&& NemerleAttributes.Internal &&
      attrs %&& NemerleAttributes.Protected &&
      access_attrs_count == 2;
       
    if (access_attrs_count <= 1 || is_protected_internal)
      None ()
    else
      Some ("inconsistent access attributes specified")
  }


  /**
   * Performs attributes checks for method definitions.
   */
  internal CheckMethodAttributes (meth : NemerleMethod) : void
  {
    def attributes = meth.Attributes;
    def loc = meth.GetLocation ();
    
    // only allow static methods to be extern
    def meth_is_instance =
      !(attributes %&& NemerleAttributes.Static);
            
    when (meth_is_instance && meth.HasExternBody)
      Message.fatal_error (loc, "only static methods are allowed to be extern: " +
                           describe_member (meth));      

    // only allow abstract methods to have abstract bodies
    def meth_is_abstract =
      attributes %&& NemerleAttributes.Abstract;
    
    when (meth.HasAbstractBody && !meth_is_abstract)
      Message.fatal_error (loc, "missing body of a non-abstract method: " +
                           describe_member (meth));
                           
    // most of the checks are common with the properties and events:
    check_method_like_attributes ((meth :> IMember), "method", "methods")
  }


  /**
   * Performs attributes checks for properties definitions.
   */
  internal CheckPropertyAttributes (prop : NemerleProperty) : void
  {
    def attributes = prop.Attributes;
    def loc = prop.GetLocation ();

    // make sure no static indexers get defined
    def prop_is_static =
      attributes %&& NemerleAttributes.Static;
    
    when (prop_is_static && prop.IsIndexer)
      Message.fatal_error (loc, "indexer properties are not allowed to be static: " +
                           describe_member (prop));
    
    // most of the checks are common with the methods and events:
    check_method_like_attributes ((prop :> IMember), "property", "properties")
  }
  

  /**
   * Performs attributes checks for events definitions.
   */
  internal CheckEventAttributes (evt : NemerleEvent) : void
  {
    // most of the checks are common with the properties and methods:
    check_method_like_attributes ((evt :> IMember), "event", "events")
  }

  
  /**
   * Performs the attributes checks that are common to methods and properties
   */
  private check_method_like_attributes (mem : IMember, title : string,
                                        title_plural : string) : void
  {                                               
    def attributes = mem.Attributes;
    def loc = mem.GetLocation ();
    
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for " + title + ": " + describe_member (mem))
    }

    check_for_invalid_attr (NemerleAttributes.Mutable, "mutable");
    check_for_invalid_attr (NemerleAttributes.Module, "module");
    check_for_invalid_attr (NemerleAttributes.Struct, "struct");
    check_for_invalid_attr (NemerleAttributes.Macro, "macro");
    check_for_invalid_attr (NemerleAttributes.Volatile, "volatile");

    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for " + title + ": " + describe_member (mem))
      | _ => ()
    }
    
    // make sure 'virtual', 'new' and 'override' never appear at once 
    def mem_is_virtual =
      attributes %&& NemerleAttributes.Virtual;

    def mem_is_new =
      attributes %&& NemerleAttributes.New;

    def mem_is_override =
      attributes %&& NemerleAttributes.Override;

    when (mem_is_override && mem_is_new)
      Message.fatal_error (loc, "both `override' and `new' attributes specified for " +
                           title + ": " + describe_member (mem));

    // only allow 'override' methods/properties/events to be 'sealed'
    def mem_is_sealed =
      attributes %&& NemerleAttributes.Sealed;

    when (mem_is_sealed && !mem_is_override)
      Message.fatal_error (loc, "only `override' " + title + " are allowed to be `sealed': " +
                           describe_member (mem));
                           
    // do not allow new virtual methods/properties/events in sealed clases
    def type_is_sealed =
      this.modifiers.mods %&& NemerleAttributes.Sealed;

    when (type_is_sealed && mem_is_virtual && !mem_is_override && !IsDelegate)
      Message.fatal_error (loc, mem.Name +
                           " is a new virtual member in a sealed class " +
                           this.FullName);

    // do not allow private abstract methods
    def mem_is_private =
      attributes %&& NemerleAttributes.Private;

    def mem_is_abstract =
      attributes %&& NemerleAttributes.Abstract;
            
    when (mem_is_abstract && mem_is_private)
      Message.fatal_error (loc, "abstract " + title_plural + " are not allowed to be private: " +
                           describe_member (mem));      

    // do not allow private 'virtual' or 'override' methods/properties/events
    when (mem_is_virtual && mem_is_private)
      Message.fatal_error (loc, "virtual " + title_plural + " are not allowed to be private: " +
                           describe_member (mem));      
    
    when (mem_is_override && mem_is_private)
      Message.fatal_error (loc, "override " + title_plural + " are not allowed to be private: " +
                           describe_member (mem));      
                           
    // do not allow to mix abstract with the 'override' modifier
    when (mem_is_abstract && mem_is_override)
      Message.fatal_error (loc, "abstract " + title_plural + " are not allowed to have the " +
                           "'override' modifier: " + describe_member (mem));      

    // static methods/properties cannot be abstract, virtual or override
    def mem_is_static =
      attributes %&& NemerleAttributes.Static;
      
    when ((mem_is_abstract || mem_is_virtual || mem_is_override) && mem_is_static)
      Message.fatal_error (loc, "static " + title_plural + " are not allowed to be abstract, " +
                           "virtual or override: " + describe_member (mem));

    // do not allow protected and protected internal methods in structures
    when (this.is_struct && (attributes %&& NemerleAttributes.Protected))
    {
      def msg =
        if (attributes %&& NemerleAttributes.Internal)
          "protected internal"
        else
          "protected";
          
      Message.fatal_error (loc, title_plural + " defined in a struct are not allowed to be " +
                           msg + ": " + describe_member (mem))
    }
  }


  /**
   * Performs attributes checks for field definitions.
   */
  internal CheckFieldAttributes (fld : NemerleField) : void
  {
    def attributes = fld.Attributes;
    def loc = fld.GetLocation ();
    
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for field: " + describe_member (fld))                           
    }

    check_for_invalid_attr (NemerleAttributes.Abstract, "abstract");
    check_for_invalid_attr (NemerleAttributes.Virtual, "virtual");
    check_for_invalid_attr (NemerleAttributes.Sealed, "sealed");
    check_for_invalid_attr (NemerleAttributes.Override, "override");
    check_for_invalid_attr (NemerleAttributes.Module, "module");
    check_for_invalid_attr (NemerleAttributes.Struct, "struct");
    check_for_invalid_attr (NemerleAttributes.Macro, "macro");
    
    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for field: " + describe_member (fld))
      | _ => ()
    }

    // check for non-mutable / volatile consistency
    def is_mutable =
      attributes %&& NemerleAttributes.Mutable;

    def is_volatile =
      attributes %&& NemerleAttributes.Volatile;

    when (!is_mutable && is_volatile)
      Message.fatal_error (loc, "only mutable fields are allowed to be volatile: " +
                           describe_member (fld));

    // do not allow protected and protected internal methods in structures
    when (this.is_struct && (attributes %&& NemerleAttributes.Protected))
    {
      def msg =
        if (attributes %&& NemerleAttributes.Internal)
          "protected internal"
        else
          "protected";
          
      Message.fatal_error (loc, "fields defined in a struct are not allowed to be " +
                           msg + ": " + describe_member (fld))
    }
  }


  /**
   * Performs attributes checks for type definitions.
   */
  internal CheckTypeAttributes () : void
  {
    def title =
      if (this.is_interface) "interface" else (if (this.is_struct) "struct" else "type");
        
    def attributes = Attributes;
    
    // make sure only a valid subset of NemerleAttributes has been used
    def check_for_invalid_attr (attr : NemerleAttributes, attr_name : string)
    {      
      when (attributes %&& attr)
        Message.fatal_error (loc, "invalid attribute `" + attr_name +
                             "' specified for " + title + ": " + FullName)                           
    }
    
    check_for_invalid_attr (NemerleAttributes.Virtual, "virtual");
    check_for_invalid_attr (NemerleAttributes.Override, "override");
    check_for_invalid_attr (NemerleAttributes.Mutable, "mutable");
    check_for_invalid_attr (NemerleAttributes.Volatile, "volatile");
    check_for_invalid_attr (NemerleAttributes.Static, "static");

    // some extra checks for structs and interfaces
    when (this.is_interface || this.is_struct)
    {
      check_for_invalid_attr (NemerleAttributes.Abstract, "abstract");
      check_for_invalid_attr (NemerleAttributes.Sealed, "sealed");
      check_for_invalid_attr (NemerleAttributes.Module, "module");
      check_for_invalid_attr (NemerleAttributes.Macro, "macro")
    }
    
    // some extra checks for interfaces
    when (this.is_interface)
    {
      check_for_invalid_attr (NemerleAttributes.Struct, "struct")
    }
    
    // check the access attributes for consistency
    match (CheckAccessAttributes (attributes)) {
      | Some (msg) =>
        Message.fatal_error (loc, msg + " for type: " + FullName)
      | _ => ()
    }

    // different limitations apply to top-level and nested types
    def type_is_protected_internal =
      attributes %&& NemerleAttributes.Protected &&
      attributes %&& NemerleAttributes.Internal;
      
    def type_is_protected =
      !type_is_protected_internal && attributes %&& NemerleAttributes.Protected;
      
    def type_is_private =
      attributes %&& NemerleAttributes.Private;

    def type_is_top_level =
      !Option.IsSome (enclosing_type);

    // top-level classes can only be public or internal
    when (type_is_top_level && (type_is_protected_internal || type_is_protected || type_is_private))
      Message.fatal_error (loc, "top level " + title + "s are only allowed to be public or internal: " +
                           FullName);

    // top-level classes are not allowed to be `new'
    def type_is_new =
      attributes %&& NemerleAttributes.New;
      
    when (type_is_top_level && type_is_new)
      Message.fatal_error (loc, "only nested " + title +"s are allowed to `new': " + FullName);

    // types cannot be abstract and sealed at the same time
    def type_is_abstract =
      attributes %&& NemerleAttributes.Abstract;

    def type_is_sealed =
      attributes %&& NemerleAttributes.Sealed;

    when (type_is_abstract && type_is_sealed)
      Message.fatal_error (loc, title + "s are not allowed to be abstract and sealed at the same time: " +
                           FullName)
  }

  
  /**
   * Marks this with the SpecialName attribute, the attribute will
   * be propagated to members and contained types at a later stage.
   */
  public MarkWithSpecialName () : void
  {
    modifiers.mods = modifiers.mods %| NemerleAttributes.SpecialName
  }

  
  /**
   * Propagates the SpecialName mark throughout the member hierarchy
   */
  private mark_members_with_special_name () : void
  {
    List.Iter (member_list, fun (member : IMember) {
      match (member) {
        | nm : NemerleMember =>
          nm.MarkWithSpecialName ()
        | _ =>
          ()
      }
    });

    List.Iter (contained_types, fun (tb : TypeBuilder) {
      tb.MarkWithSpecialName ()
    })
  }
}

} // ns
