/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

open Nemerle;

namespace Nemerle.Collections {
  public class EmptyHeap extends System.Exception
  {
    public msg : string;
    public this (msg : string) { this.msg <- msg; }
  }

  /**
   * General usage heap, can be used as priority queue.
   */
  public class Heap('a) where 'a :> System.IComparable {

    private mutable heap  : System.Array;
    private mutable size  : int;
    private mutable count : int;

    private this() 
    {
    }

    public this(size : int) {
      def realSize = if ( size >= 10 ) 
        size
      else
        10;
      heap <- System.Array.CreateInstance(typeof(System.Object),realSize+1);
      this.size <- realSize;
      count <- 0;
    }

    private grow_up() : void {
      def newSize = 2 * size;
      def newHeap = System.Array.CreateInstance(typeof(System.Object),newSize+1);

      this.heap.CopyTo(newHeap,0);

      this.heap <- newHeap;
      this.size <- newSize;
    }

    private is_greater(k : int, l : int) : bool {
      def kVal = (this.heap.GetValue(k) :> System.IComparable);
      def lVal = (this.heap.GetValue(l) :> ('a));
      def r = kVal.CompareTo(lVal) > 0;
      r
    }

    private swap(k : int, l : int) : void {
      def kVal = this.heap.GetValue(k);
      this.heap.SetValue(this.heap.GetValue(l),k);
      this.heap.SetValue(kVal,l)
    }

    private parent(i : int) : int {
      i / 2
    }

    private left(i : int) : int {
      2 * i
    }

    private right(i : int) : int {
      2 * i + 1
    }

    private heapify(i : int) : void {
      def l = left(i);
      def r = right(i);
      mutable largest <- 0;
      if ( l <= this.count && is_greater(l,i) ) 
        largest <- l
      else
        largest <- i;
      if ( r <= this.count && is_greater(r,largest) )
        largest <- r
      else
        ();
      if ( largest != i ) {
        swap(i,largest);
        heapify(largest)
      } else 
        ();
    }

    private build_heap() : void {
      for ( mutable i <- this.count / 2; i >= 1; i <- i + 1 )
        heapify(i);
    }

    public Insert(x : 'a) : void {
      if ( this.count >= this.size )
        grow_up ()
      else 
        ();
      this.count <- this.count + 1;
      mutable i <- this.count;
      while ( i > 1 && x.CompareTo(this.heap.GetValue(parent(i))) > 0 ) {
        this.heap.SetValue(this.heap.GetValue(parent(i)),i);
        i <- parent(i)
      };
      this.heap.SetValue(x,i)
    }

    public Top() : ('a) {
      if ( this.count == 0 )
        raise EmptyHeap("Empty heap exception")
      else 
        (this.heap.GetValue(1) :> ('a))
    }
    
    public ExtractFirst() : ('a) {
      if ( this.count < 1 )
        raise EmptyHeap("Empty heap exception")
      else {
        def result = (this.heap.GetValue(1) :> ('a));
        this.heap.SetValue(this.heap.GetValue(this.count),1);
        this.count <- this.count - 1;
        heapify(1);
        result
      } 
    }

    public IsEmpty () : bool {
      if ( count == 0 )
        true
      else
        false
    }

    public Count () : int {
      count
    }

    public Size () : int {
      size
    }

    public 'b where 'b :> System.Object 
    Map(f : 'a -> 'b) : Heap('a) 
    {
      def newHeapArray = System.Array.CreateInstance(typeof(System.Object),this.size);
      for ( mutable i <- 1; i <= this.count; i <- i + 1 ) {
        newHeapArray.SetValue( f ( (this.heap.GetValue(i) :> 'a) ) , i );
      };
      def newHeap = Heap ();
      newHeap.heap  <- newHeapArray;
      newHeap.count <- this.count;
      newHeap.size  <- this.size;
      newHeap.build_heap ();
      newHeap
    }

    public Iter(f : 'a -> void) : void 
    {
      for ( mutable i <- 1; i <= this.count; i <- i + 1 ) {
        f ( (this.heap.GetValue(i) :> 'a) );
      }
    }

    'b Fold (f : ('b * 'a) -> 'b,x : 'b) : 'b
    {
      mutable v <- x;
      for ( mutable i <- 1; i <= this.count; i <- i + 1 )
        v <- f (v,(this.heap.GetValue(i) :> 'a));
      v  
    }

    


  }
}
