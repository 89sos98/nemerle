/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Matching
 */
namespace Nemerle.Compiler 
{
  using Nemerle.Collections;

  using Nemerle.Compiler;
  using Nemerle.Compiler.CGexpr;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;

  using System.Reflection;
  using System.Reflection.Emit;

  
  /**
   * TODO:
   *
   * 1. the case with same patterns with different guards:
   *      match (expr) {
   *        | X when G1 => E1
   *        | X when G2 => E2
   *      };
   */


  /**
   * Description of a match pattern:
   *
   * | [pattern] when [guard] => [effect]
   *
   * Additionally, we hold an ordered list of guards that 
   * could possibly override this match.
   */
  internal class MatchPattern
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (pattern : Pattern, guard : int, effect : int, 
                 guard_is_always_true : bool)
    {
      this.guard_is_always_true <- guard_is_always_true;
      this.pattern <- pattern;
      this.guard <- guard;
      this.effect <- effect;
      overridden_by <- [];
    }
    

    /* -- PUBLIC METHODS --------------------------------------------------- */
    
    public PossiblyOverrides (match_pattern : MatchPattern) : bool
    {
      compare_patterns (pattern, match_pattern.pattern)
    }
    
    public AlwaysOverrides (match_pattern : MatchPattern) : bool
    {
      PossiblyOverrides (match_pattern) && guard_is_always_true
    }
    
    public AddOverridingPattern (match_pattern : MatchPattern) : void
    {
      overridden_by <- match_pattern :: overridden_by
    }
    
    public ReverseOverridingList () : void
    {
      overridden_by <- List.Rev (overridden_by)
    }
    
    public NeedExtraMatchChecks () : bool
    {
      !guard_is_always_true || List.Length (overridden_by) != 0
    }

    public GetEffectIndex () : int
    {
      effect
    }

    public GetPattern () : Pattern
    {
      pattern
    }
    
    public MakeMatchCondition (compare_to : CG_expr) : CG_expr
    {      
      match (pattern) {
        | P_literal (literal) =>
          CE_call (typeof (System.Boolean), CE_opcode ("=="), [compare_to; CE_literal (literal)])
        | _ => 
          Util.ice ("non-literal patterns not supported in MakeMatchCondition")
      }    
    }

    public MakeLessThanCondition (compare_to : CG_expr) : CG_expr
    {
      match (pattern) {
        | P_literal (L_string) =>
          Util.ice ("constant string patterns not supported in MakeLessThanCondition")
        | P_literal (L_bool) =>
          Util.ice ("constant boolean patterns not supported in MakeLessThanCondition")
        | P_literal (literal) =>
          CE_call (typeof (System.Boolean), CE_opcode ("<"), [compare_to; CE_literal (literal)])
        | _ => 
          Util.ice ("non-literal patterns not supported in MakeLessThanCondition")
      }    
    }

    public Dump () : void
    {
      def message =
        match (pattern) {
          | P_literal (L_string (literal)) => "P_literal L_string '" + literal + "'"
          | P_literal (L_int (literal)) => "P_literal L_int " + string_of_int (literal)
          | P_underscore => "P_underscore"
          | P_as (P_underscore, _) => "P_as/P_underscore"
          | _ => "other"
        };
        
      Message.debug (message)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    private compare_literals (l : Literal, r : Literal) : bool
    {
      match ((l, r)) {
        | (L_null, L_null) => true
        | (L_int (l), L_int (r)) => l == r
        | (L_string (l), L_string (r)) => l == r
        | (L_float (l), L_float (r)) => l == r
        | (L_char (l), L_char (r)) => l == r
        | (L_bool (l), L_bool (r)) => l == r
        | _ => false
      }
    } 
    
    private compare_tuples (l : list (Pattern), r : list (Pattern)) : bool
    {
      def walk_tuples (l : list (Pattern), r : list (Pattern)) : bool {
        match ((l, r)) {
          | ([], []) => true
          | (l :: ls, r :: rs) => 
            if (compare_patterns (l, r)) walk_tuples (ls, rs) else false
          | _ => false
        }
      };
      
      walk_tuples (l, r)
    }
    
    private compare_records (l : list (IField * Pattern), r : list (IField * Pattern)) : bool
    {
      // FIXME
      List.length (l) != List.length (r)
    }
    
    private compare_conses (_ln : Tycon, _la : Pattern, _rn : Tycon, _ra : Pattern) : bool
    {
      // FIXME
      false
    }
    
    private compare_patterns (l : Pattern, r : Pattern) : bool
    {
      match ((l, r)) {
        | (P_underscore, _) => true
        | (P_as (P_underscore, _), _) => true
        | (P_literal (l), P_literal (r)) => compare_literals (l, r)      
        | (P_tuple (l), P_tuple (r)) => compare_tuples (l, r)
        | (P_record (l), P_record (r)) => compare_records (l, r)
        | (P_cons (ln, la), P_cons (rn, ra)) => compare_conses (ln, la, rn, ra)       
        | _ => false
      }
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable pattern : Pattern;
    private mutable guard : int;
    private mutable effect : int;
    private mutable overridden_by : list (MatchPattern);
    private mutable guard_is_always_true : bool;
  }


  /**
   * Search for a matching pattern is optimized within
   * pattern blocks only.
   */
  internal class MatchBlock
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (patterns : list (MatchPattern))
    {
      this.patterns <- patterns;
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public DecidePatternOverriding () : void
    {
      def decide_pattern_overriding (head : MatchPattern, patterns : list (MatchPattern)) : list (MatchPattern)
      {
        match (patterns) {
          | pattern :: rest =>
            if (head.AlwaysOverrides (pattern)) {
              // skip patterns that are always overridden
              decide_pattern_overriding (head, rest)
            }
            else if (head.PossiblyOverrides (pattern)) {
              // add overriding information for possibly hidden patterns
              pattern.AddOverridingPattern (head);
              pattern :: decide_pattern_overriding (head, rest)
            }
            else {
              // leave the rest as is
              pattern :: decide_pattern_overriding (head, rest)
            }
          | [] => []
        }
      };  
      
      def walk_patterns (patterns : list (MatchPattern)) : void {
        match (patterns) {
          | pattern :: rest =>
            def rest = decide_pattern_overriding (pattern, rest);
            pattern.ReverseOverridingList ();
            walk_patterns (rest)
          | [] => ()
        }
      };
      
      walk_patterns (patterns)
    }

    public GetMatchPatterns () : list (MatchPattern) 
    {
      patterns
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable patterns : list (MatchPattern);
  }


  /**
   * A match construct consists of a number of blocks, 
   * guards and effects.
   */
  internal class MatchDescriptor
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    /**
     * Initializes the match descriptor. 
     * Builds the initial patterns block.
     */    
    internal this (context : CTX, result_type : System.Type, 
                   matched_expr : CG_expr, match_cases : list (Match_case))
    {
      guards <- New.SystemMap ();
      effects <- New.SystemMap ();
            
      current_guard <- -1;
      current_effect <- -1;
      
      this.context <- context;
      this.result_type <- result_type;
      this.matched_expr <- matched_expr;

      matched_expr_type <- type_of (matched_expr);
      match_over_value_type <- matched_expr_type.IsValueType;
      
      build_first_block (match_cases)
    }

    
    /* -- PUBLIC METHODS --------------------------------------------------- */

    public DecidePatternOverriding () : void
    {
      def decide_pattern_overriding (block : MatchBlock) : void {
        block.DecidePatternOverriding ()
      };
      
      List.iter (decide_pattern_overriding, blocks)
    }

    public GetMatchBlocks () : list (MatchBlock) 
    {
      blocks
    }

    public GetMatchedExpr () : CG_expr
    {
      matched_expr
    }

    public GetEffect (index : int) : CG_expr
    {
      effects.Get (index)
    }

    public GetGuard (index : int) : option (CG_expr)
    {
      guards.Get (index)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    /**
     * Builds the first block of patterns. This block will have to be either
     * split or the overriding guards information will have to be updated.
     */
    private build_first_block (match_cases : list (Match_case)) : void
    {
      mutable patterns <- [];

      def process_pattern (pattern : Pattern, guard : Expr) : void {
        current_guard <- current_guard + 1;
        def guard_is_always_true =
          match (guard) {
            | E_literal (L_bool (true)) =>
              guards <- guards.Add (current_guard, None ());
              true
            | _ => 
              guards <- guards.Add (current_guard, Some (cg_expr (context, guard)));
              false
          };
        patterns <- MatchPattern (pattern, current_guard, current_effect, 
                                  guard_is_always_true) :: patterns
      };
      
      def walk_match_cases (match_cases : list (Match_case)) : void {
        match (match_cases) {
          | [] => ()
          | match_case :: rest =>
            current_effect <- current_effect + 1;
            effects <- effects.Add (current_effect, cg_expr (context, match_case.body));
            List.iter (process_pattern, match_case.patterns);
            walk_match_cases (rest)
        }
      };
      
      walk_match_cases (match_cases);      
      blocks <- [MatchBlock (patterns)]
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable blocks : list (MatchBlock);
    private mutable guards : New.SystemMap (int, option (CG_expr));
    private mutable effects : New.SystemMap (int, CG_expr);
    private mutable current_guard : int;
    private mutable current_effect : int;

    private mutable context : CTX;
    private mutable result_type : System.Type;
    private mutable matched_expr : CG_expr;

    private mutable matched_expr_type : System.Type;
    private mutable match_over_value_type : bool;
  }
  

  /**
   * Builds an expression that performs a binary search 
   * over a value type (that'd mainly be ints and chars).
   */
  internal class MatchBinarySearch
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, 
                 patterns : list (MatchPattern),
                 continuation : option (CG_expr))
    {
      assert (List.Length (patterns) > 0);
      
      this.match_descriptor <- match_descriptor;
      this.patterns <- patterns;
      this.matched_expr <- match_descriptor.GetMatchedExpr ();
      this.continuation <- continuation;
      
      binary_search_expr <- make_binary_search (patterns)
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetBinarySearchExpr () : CG_expr
    {
      binary_search_expr
    }
    
    public DumpMatchPatterns (patterns : list (MatchPattern)) : void {
      def walk_patterns (patterns : list (MatchPattern)) : void {
        match (patterns) {
          | [] => ()
          | pattern :: rest =>
            pattern.Dump ();
            walk_patterns (rest)
        }
      };
      
      Message.debug (" -- dumping " + string_of_int (List.Length (patterns)) + " patterns --");
      walk_patterns (patterns)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    private split_patterns (patterns : list (MatchPattern)) 
      : list (MatchPattern) * MatchPattern * list (MatchPattern)
    {
      assert (List.Length (patterns) > 2);
      
      def split (patterns : list (MatchPattern), acc : list (MatchPattern), length : int) 
        : list (MatchPattern) * MatchPattern * list (MatchPattern)
      {
        if (length == 0) (List.Rev (acc), List.Head (patterns), List.Tail (patterns))
        else split (List.Tail (patterns), List.Head (patterns) :: acc, length - 1)      
      };
      
      split (patterns, [], List.Length (patterns) / 2)
    }


    private get_effect (pattern : MatchPattern) : CG_expr
    {
      match_descriptor.GetEffect (pattern.GetEffectIndex ())
    }

    
    private make_last_match (pattern : MatchPattern) : CG_expr
    {
      match (continuation) {
        | Some (continuation) =>
          Message.debug ("make_last_match: got some continuation");
          pattern.Dump ();
          CE_if (typeof (System.Boolean), pattern.MakeMatchCondition (matched_expr),
                 get_effect (pattern), continuation)
        | None => 
          Message.debug ("make_last_match: got no continuation");
          pattern.Dump ();
          get_effect (pattern)
      }
    }

    
    private make_binary_search (patterns : list (MatchPattern)) : CG_expr
    {
      match (patterns) {
        | [l] => make_last_match (l)

        | [l; r] =>
          CE_if (typeof (System.Boolean), l.MakeMatchCondition (matched_expr),
                 get_effect (l), make_last_match (r));
                         
        | patterns =>
          def (l, m, r) = split_patterns (patterns);

          Message.debug ("make_binary_search: " + string_of_int (List.length (patterns)));
          DumpMatchPatterns (l);
          DumpMatchPatterns ([m]);
          DumpMatchPatterns (r);

          CE_if (typeof (System.Boolean), m.MakeLessThanCondition (matched_expr),
                 make_binary_search (l), make_binary_search (m :: r))
      }          
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable patterns : list (MatchPattern);
    private mutable continuation : option (CG_expr);
    private mutable matched_expr : CG_expr;
    private mutable binary_search_expr : CG_expr;
  }
  
  
  /**
   * The matching module
   */
  module CGmatch 
  {
    /**
     * Matching over integers
     */
    cg_match_over_integers (match_over_type : System.Type, 
                            context : CTX, 
                            matched_expr : CG_expr, 
                            match_cases : list (Match_case)) : CG_expr
    {
      def match_descriptor = 
        MatchDescriptor (context, match_over_type, matched_expr, match_cases);
      
      def literal_pattern (pattern : MatchPattern) : bool {
        match (pattern.GetPattern ()) {
          | P_underscore => false
          | P_as (P_underscore, _) => false
          | P_literal (L_int) => true
          | _ => Util.ice ("invalid pattern type")
        }
      };
      
      def compare_literal_patterns (l : MatchPattern, r : MatchPattern) : int {
        def get_literal (pattern : MatchPattern) : int {        
          match (pattern.GetPattern ()) {
            | P_literal (L_int (literal)) => literal
            | _ => Util.ice ("invalid pattern type")
          }
        };
        
        get_literal (r) - get_literal (l)
      };
      
      def process_block (block : MatchBlock, continuation : option (CG_expr)) : CG_expr {
        def (literal_patterns, _non_literal_patterns) = 
          List.Partition (literal_pattern, block.GetMatchPatterns ());
        def sorted_literal_patterns = 
          List.Sort (compare_literal_patterns, literal_patterns);

        def binary_search = 
          MatchBinarySearch (match_descriptor, sorted_literal_patterns, continuation);

        binary_search.GetBinarySearchExpr ()
      };
    
      def walk_blocks (blocks : list (MatchBlock)) : CG_expr {
        Message.debug ("walk_blocks");
        match (blocks) {
          | [block] =>
            process_block (block, None ())
          | block :: rest =>            
            def continuation = walk_blocks (rest);
            process_block (block, Some (continuation))
          | _ => 
            Util.ice ("no blocks in match descriptor")
        }
      };
    
      Message.debug ("cg_match_over_integers");
      walk_blocks (match_descriptor.GetMatchBlocks ())
    }
  
  
    cg_pattern (ctx : CTX, val : CG_expr, pats : list (Pattern * Expr)) : CG_expr * bool * CTX * list (CG_val)
    {
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;
      mutable always_matches <- true;
      
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_literal (L_bool (true))
          
          | P_as (subpat, d) =>
            if (d.in_closure) ()
            else
              match (vals.find (d.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, CE_none ());
                  rctx <- ctx;
                  vals <- vals.add (d.id, v);
              };
            def ass = CE_assign (local_ref (rctx, d), maybe_cast (ctx, cg_type (ctx, d.ty), val));
            match (subpat) {
              | P_cons =>
                match (cgpat (val, subpat)) {
                  | (CE_if (c, e_then, e_else)) as e =>
                    CE_if (e.ty, c, CE_sequence ([ass; e_then]), e_else)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([ass; cgpat (val, subpat)])
            }
            
          | P_tuple (args) =>
            def len = List.length (args);
            def f (acc, arg)
              {
                def (pos, ex) = acc;
                def cond = cgpat (tuple_ref (CE_cast (val, tuple_type (len)), pos, len), arg);
                (pos - 1, CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false))))
              };
            def ini = (len, CE_literal (L_bool (true)));
            def (_, ex) = List.fold_left (f, ini, List.rev (args));
            ex

          | P_literal (lit) =>
            def litexpr = CE_literal (lit);
            CE_call (typeof (System.Boolean), 
                    CE_opcode ("=="), 
                    [CE_cast (val, type_of (litexpr)); litexpr])
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (ctx, pat.ty));
            def f (ex, np) {
              def (name, pat) = np;
              def cond = cgpat (CE_field_ref (val, (name : IField).GetFieldInfo ()), pat);
              CE_if (typeof (System.Boolean), cond, ex, CE_literal (L_bool (false)))
            };
            List.fold_left (f, CE_literal (L_bool (true)), List.rev (args))
          
          | P_cons (n, a) =>
            always_matches <- false;
            def tyname = n.GetSystemType ();
            def ex = CE_has_type (val, tyname);
            CE_if (typeof (System.Boolean), ex, 
                    cgpat (CE_cast (val, tyname), a), 
                    CE_literal (L_bool (false)))
        }
      };

      mutable global_always_matches <- false;

      def loop (pats) {
        match (pats) {
          | (pat, expr) :: rest =>
            always_matches <- true;
            def cond = cgpat (val, pat);
            def cond =
              match (expr) {
                | E_literal (L_bool (true)) => cond
                | _ =>
                  always_matches <- false;
                  CE_if (typeof (System.Boolean), cond, cg_expr (rctx, expr), CE_literal (L_bool (false)))
              };
            global_always_matches <- global_always_matches || always_matches;
            CE_if (typeof (System.Boolean), cond, CE_literal (L_bool (true)), loop (rest))
          | [] =>
            CE_literal (L_bool (false))
        }
      };

      def r = loop (pats);
      def collect_vals (acc : list (CG_val), _ : int, v : CG_val) : list (CG_val) { v :: acc };
      (r, global_always_matches, rctx, vals.fold (collect_vals, []))
    }

    
    /**
     * Matching over arbitrary types
     */
    cg_match_over_any_type (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr 
    {
      match (mcs) {
        | [] =>
          // FIXME: cache it
          def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.Match_failure");
          def match_failure = get_default_ctor (ctx, tc);
          CE_raise (CE_call (CE_ctor_ref (match_failure), []))

        | m :: ms =>
          // FIXME: do something with always_matches
          def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
          def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) };
          def then_part = cg_expr (ctx', m.body);
          def else_part = cg_match (t, ctx, val, ms);
          List.fold_left (mklet, CE_if (t, cond, then_part, else_part), vals)
      }
    }


    /**
     * Matching over booleans.
     */
    cg_match_over_booleans (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
    {
      def type_of_bool = typeof(System.Boolean); // FIXME: how to reflect types here?
      
      mutable vals <- Map.int_map ();
      mutable rctx <- ctx;

      mutable true_handled <- false;
      mutable false_handled <- false;
      mutable last_pattern_always_matches <- false;

      def is_always_true (expr : Expr) : bool {
        match (expr) {
          | E_literal (L_bool (true)) => true
          | _ => false
        }    
      };

      def make_cond (patterns : list (Pattern * Expr)) : CG_expr {
        match (patterns) {        
          | (P_underscore, when_expr) :: _ when is_always_true (when_expr) =>
            last_pattern_always_matches <- true;          
            CE_literal (L_bool (true))
        
          | (P_underscore, when_expr) :: rest =>
            CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))

          | (P_literal (L_bool (literal)), when_expr) :: rest when is_always_true (when_expr) =>
            def literal_already_handled = if (literal) true_handled else false_handled;          
            when (literal_already_handled) Message.warning ("unreachable pattern in matching");
            
            if (literal) true_handled <- true else false_handled <- true;
                      
            if (true_handled && false_handled) {
              last_pattern_always_matches <- true;          
              CE_literal (L_bool (true))
            }
            else {
              def literal_eq_expr =
                CE_call (type_of_bool, CE_opcode ("=="), 
                        [val; CE_literal (L_bool (literal))]);

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), make_cond (rest))
            }

          | (P_literal (L_bool (literal)), when_expr) :: rest =>
            def literal_already_handled = if (literal) true_handled else false_handled;          
            when (literal_already_handled) Message.warning ("unreachable pattern in matching");

            def opposite_handled = if (literal) false_handled else true_handled;

            if (opposite_handled) {
              CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), make_cond (rest))          
            }
            else {
              def literal_eq_expr =
                CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                        [val; CE_literal (L_bool (literal))]);

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), 
                CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), 
                  make_cond (rest)))
            }

          | (P_as (subpat, decl), _) :: rest =>
            if (decl.in_closure) ()
            else
              match (vals.find (decl.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, decl, CE_none ());
                  rctx <- ctx;
                  vals <- vals.add (decl.id, v);
              };
            def assign_expr = 
              CE_assign (local_ref (rctx, decl), maybe_cast (rctx, cg_type (ctx, decl.ty), val));
            match (subpat) {
              | P_cons =>
                match (make_cond (rest)) {
                  | CE_if (cond_expr, then_expr, else_expr) =>
                    CE_if (type_of_bool, cond_expr, CE_sequence ([assign_expr; then_expr]), else_expr)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([assign_expr; make_cond (rest)])
            }

          | [] => CE_literal (L_bool (false))

          | (P_tuple, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_tuple")
          | (P_record, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_record")
          | (P_cons, _) :: _ => Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_cons")

          | _ :: _ => 
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
        }      
      };

      def walk_match_cases (mcs : list (Match_case)) : CG_expr {
        match (mcs) {
          | [] =>
            def tc = GlobalEnv.LookupInternalType ("Nemerle.Core.Match_failure");
            def match_failure = get_default_ctor (rctx, tc);
            CE_raise (CE_call (CE_ctor_ref (match_failure), []))

          | mc :: rest =>
            def cond = make_cond (mc.patterns);
            def body = cg_expr (rctx, mc.body);
            
            if (true_handled && false_handled || last_pattern_always_matches) {
              when (List.length (rest) > 0) Message.warning ("unreachable match cases");
              body
            }
            else
              CE_if (cond, body, walk_match_cases (rest))
        }
      };

      // handle the special cases for the if/when/unless macros
      match (mcs) {
        | [then_case; else_case] =>
          match ((then_case.patterns, else_case.patterns)) {
            | ([(P_literal (L_bool (literal)), then_case_when_expr)], [(P_underscore, else_case_when_expr)]) 
                when is_always_true (then_case_when_expr) && is_always_true (else_case_when_expr) =>
                
              def literal_eq_expr =
                CE_call (typeof (System.Boolean), CE_opcode ("=="), 
                        [val; CE_literal (L_bool (literal))]);

              CE_if (t, literal_eq_expr, cg_expr (ctx, then_case.body), cg_expr (ctx, else_case.body))         
            | _ => walk_match_cases (mcs)
          }
        | _ => walk_match_cases (mcs)
      }
    }


    /**
     * Matching
     */
    internal cg_match (t : System.Type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr
    {        
      match (type_of (val).FullName) {
        | "System.Boolean" => cg_match_over_booleans (t, ctx, val, mcs)
//        | "System.Int32" => cg_match_over_integers (t, ctx, val, mcs)
        | _ => cg_match_over_any_type (t, ctx, val, mcs)
      }
    }
    
  } // end of the module

} // end of the namespace
