(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;

namespace Nemerle.Compiler {

// it is to be extended when we'll have generics
variant CG_type =
  [
    | CT_ref { name : string; }
    | CT_void
    | CT_object
    | CT_bool
    | CT_unreached
    | CT_tuple { arity : int; }
    | CT_fun { arity : int; }
  ]

class CG_member_base
  {
    ref loc : Location;
    ref name : string;
    ref extern_name : string;
    ref attrs : list (string);
    this () 
      {
        this#loc <- Location_stack.top ();
        this#name <- "";
        this#extern_name <- "";
        this#attrs <- Nil ();
      }
  }

variant CM_kind =
  [
    | CK_interface
    | CK_class
    | CK_struct
  ]
  
variant CG_member extends CG_member_base =
  [
    | CM_class
        { 
          ref ns : string;
          ref kind : CM_kind;
          ref inheritance : list (CG_type);
          ref decls : list (CG_member);
        }

    | CM_method
        { 
          parms : list (CG_val);
          ret_type : CG_type;
          ref body : CG_expr;
        }

    | CM_field
        {
          ty : CG_type;
        }
  ]
  
class CE_base
  {
    ref loc : Location;
    ref expr_ty : CG_type;
  }

record CG_val
  {
    loc : Location;
    name : string;
    ty : CG_type;
    val : CG_expr;
  }
  
variant CG_expr extends CE_base = 
  [ 
    | CE_ref { decl : CG_val; }
    | CE_global_ref { decl : CG_member; } // not class
    | CE_ctor_ref { klass : CM_class; }
    | CE_field_ref { obj : CG_expr; fld : CM_field; }
    | CE_method_ref { obj : CG_expr; meth : CM_method; }
    | CE_tuple_ref { obj : CG_expr; pos : int; }
    | CE_call { func : CG_expr; parms : list (CG_expr); }
    | CE_assign { target : CG_expr; source : CG_expr; }
    | CE_let { name : CG_val; body : CG_expr; }
    | CE_has_type { expr : CG_expr; ty : CG_type; }
    | CE_raise { exn : CG_expr; }
    | CE_if { cond : CG_expr; e_then : CG_expr; e_else : CG_expr; }
    | CE_true
    | CE_false
    | CE_try_with { body : CG_expr; exn : CG_val; handler : CG_expr; }
    | CE_try_finally { body : CG_expr; handler : CG_expr; }
    | CE_literal { val : Literal; }
    | CE_this
    | CE_skip
    | CE_cast { expr : CG_expr; ty : CG_type; }
    | CE_sequence { body : list (CG_expr); }
    | CE_tuple_ctor { exprs : list (CG_expr); }

    | CE_none
  ]
 
}
