/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections {
  using Nemerle.Assertions;

  // MutableList class, implementing some interfaces for better interaction with .NET code
  public class MutableList ['a] : ICollection ['a]
  {
    // Node class - not visible outside. Client code should use Enumerator for
    // list operations.
    [Record]
    variant Node ['a]
    {
      | Body {
        mutable prev : Node ['a];
        mutable next : Node ['a];
        mutable data : 'a;
      }
      | Head { // head guard - convenient for Enumerator
        mutable first : Node ['a];
      }
      | Tail { // tail guard - as above
        mutable last : Node ['a];
      }

        [Nemerle.OverrideObjectEquals]
        public Equals (obj : Node ['a]) : bool
        {
          System.Object.ReferenceEquals (this, obj);
        }
    }

    // beginning and end of the list for fast access to those
    mutable begin : Node ['a];
    mutable end : Node ['a];

    public this (some_list : list ['a])
    {
      // Note, that empty list contains two nodes - the guards for Enumerator
      // In such case the first node is the tail guard, and the last node is
      // the head guard.
      begin = Node.Head (null);
      end = Node.Tail (begin);
      match (begin) {
        | (Node.Head) as hd => hd.first = end;
        | _ => assert (false); // no, it is simply impossible to get here ;)
      }
      unless (some_list == null)
        foreach (item in some_list) 
          Insert (end, item);
    }

    public this ()
    {
      begin = Node.Head (null);
      end = Node.Tail (begin);
      match (begin) {
        | (Node.Head) as hd => hd.first = end;
        | _ => assert (false); // no, it is simply impossible to get here ;)
      }
    }

    concat_helper (separator : string, sb : System.Text.StringBuilder) : void
    {
      unless (IsEmpty) {
        def e = Enumerator (this);
        _ = e.MoveNext ();
        _ = sb.Append (e.Current);
        while (e.MoveNext ()) {
          _ = sb.Append (separator);
          _ = sb.Append (e.Current);
        }
      }
    }

    public override ToString () : string
    {
      def sb = System.Text.StringBuilder ("[ ");
      concat_helper (", ", sb);
      sb.Append (" ]").ToString ();
    }

    public ToString (separator : string) : string
    {
      def sb = System.Text.StringBuilder ();
      concat_helper (separator, sb);
      sb.ToString ();
    }        

    // Reverse the elements of the list in place. 
    public Reverse () : void
    {
      unless (IsEmpty) {
        mutable first = null;
        mutable last = null;

        def reverse_node (node : Node ['a]) : void {
          | (Node.Head) as hd => 
            first = hd.first;
            reverse_node (hd.first);
          | (Node.Body) as bd =>
            bd.prev <-> bd.next;
            reverse_node (bd.prev);
          | (Node.Tail) as tl => 
            last = tl.last;
        }

        reverse_node (begin);

        // Exchange head with tail
        match (end) {
          | (Node.Tail) as tl => tl.last = first;
          | _ => assert (false);
        }
        match (begin) {
          | (Node.Head) as hd => hd.first = last;
          | _ => assert (false);
        }
        // Now - inform border nodes about change
        match (first) {
          | (Node.Body) as bd => bd.next = end;
          | _ => assert (false);
        }
        match (last) {
          | (Node.Body) as bd => bd.prev = begin;
          | _ => assert (false);
        }
      } // non-empty
    }

    // Inserts item d after position pos. If pos is head, inserts at the beginning.
    // In case pos is tail, inserts item at the end (so not really after pos..)
    Insert ([NotNull] pos : Node ['a], d : 'a) : void
    {
      match (pos) {
        | (Node.Head) as hd => // at the beginning
          def node = Node.Body (pos, hd.first, d);
          match (hd.first) {
            | Node.Head => assert (false);
            | (Node.Body) as second => second.prev = node;
            | (Node.Tail) as tail => tail.last = node;
          }
          hd.first = node;
        | (Node.Body) as body => // somewhere in the middle (or end perhaps?)
          def node = Node.Body (pos, body.next, d);
          match (body.next) {
            | Node.Head => assert (false);
            | (Node.Body) as subsequent => subsequent.prev = node;
            | (Node.Tail) as tail => tail.last = node;
          }
          body.next = node;
        | (Node.Tail) as tl => // insert at the end of the list
          def node = Node.Body (tl.last, pos, d);
          match (tl.last) {
            | (Node.Head) as hd => // that was an empty list
              hd.first = node; // new beginning
            | (Node.Body) as body => // non-empty list
              body.next = node;
            | Node.Tail => assert (false);
          }
          tl.last = node;
      }
    }

    // Insert list l after position pos
    Insert ([NotNull] pos : Node ['a], l : MutableList ['a]) : void
    {
      unless (l.IsEmpty) {
        // acquire beginning and end of the list to add
        mutable lbegin = null;
        mutable lend = null;
        match (l.begin) {
          | Node.Head (first) => lbegin = first
          | _ => assert (false)
        }
        match (l.end) {
          | Node.Tail (last) => lend = last
          | _ => assert (false)
        }

        match (pos) {
          | (Node.Head) as hd => // at the very beginning
            match (hd.first) {
              | Node.Head => assert (false)
              | (Node.Body) as bd => bd.prev = lend
              | (Node.Tail) as tl => tl.last = lend
            }
            match (lend) {
              | (Node.Body) as bd => bd.next = hd.first
              | _ => assert (false)
            }
            hd.first = lbegin;
            match (hd.first) {
              | (Node.Body) as bd => bd.prev = hd
              | _ => assert (false)
            }
          | (Node.Body) as bd => // anything else actually
            match (bd.next) {
              | Node.Head => assert (false)
              | (Node.Body) as n => n.prev = lend
              | (Node.Tail) as tl => tl.last = lend
            }
            match (lend) {
              | (Node.Body) as newbd => newbd.next = bd.next
              | _ => assert (false)
            }
            bd.next = lbegin;
            match (bd.next) {
              | (Node.Body) as newbd => newbd.prev = bd
              | _ => assert (false)
            }
          | (Node.Tail) as tl => // another way of adding at the end
            match (tl.last) {
              | (Node.Head) as hd => hd.first = lbegin
              | (Node.Body) as bd => bd.next = lbegin
              | Node.Tail => assert (false)
            }
            match (lbegin) {
              | (Node.Body) as bd => bd.prev = tl.last
              | _ => assert (false)
            }
            match (lend) {
              | (Node.Body) as bd => bd.next = tl
              | _ => assert (false)
            }
            tl.last = lend;
        }

        l.Clear();             
      } // l is not empty
        
    } // Insert list   

    public Prepend (item : 'a) : void
    {
      Insert (begin, item);
    }

    public Prepend ([NotNull] l : MutableList ['a]) : void
    {
      Insert (begin, l);
    }

    public Append (item : 'a) : void
    {
      Insert (end, item);
    }

    // Append another list to an end. MutableList l will be no longer valid (and thus empty).
    public Append ([NotNull] l : MutableList ['a]) : void
    {
      Insert (end, l);
    }

    // Removes given position. It should not be any of the guards.
    Remove ([NotNull] pos : Node ['a]) : void
    {
      | Node.Head =>
        throw System.ArgumentException ("Unable to remove head of the list!");
      | Node.Tail =>
        throw System.ArgumentException ("Unable to remove tail of the list!");
      | (Node.Body) as body =>
        match (body.prev) {
          | (Node.Head) as hd => // removing beginning
            hd.first = body.next;
          | (Node.Body) as previous => // somewhere in the middle
            previous.next = body.next;
          | Node.Tail => assert (false);
        }
        match (body.next) {
          | Node.Head => assert (false);
          | (Node.Body) as next =>
            next.prev = body.prev;
          | (Node.Tail) as tl => // removing last one
            tl.last = body.prev;
        }
    }

    // Enumerator for traversing through the list and modifying it.
    // You should perhaps think of it as a kind of cursor...
    public class Enumerator ['a] : IEnumerator ['a]
    {
      mutable current : Node ['a]; // current position
      mutable coll : MutableList ['a]; // corresponding list

      public this (l : MutableList ['a]) {
        coll = l;
        current = coll.begin; // place the cursor before the sequence
      }

      public Current : 'a 
      {
        get { // get current value
          match (current) {
            | (Node.Body) as body =>
              body.data;
            | _ => throw System.ArgumentException ("Unable to read outside the list!");
          }
        }
        set { // write at current position
          match (current) {
            | (Node.Body) as body =>
              body.data = value;
            | _ => throw System.ArgumentException ("Unable to write outside the list!");
          }
        }
      }

      // Move to the next position. This is exactly what you would expect from
      // .NET Enumerator.
      public MoveNext () : bool 
      {
        match (current) {
          | Node.Head (first) => current = first;
          | Node.Body (_, next, _) => current = next;
          | Node.Tail => ();
        }
        match (current) {
          | Node.Head => assert (false);
          | Node.Body => true;
          | Node.Tail => false;
        }
      }

      // Same as above, but moves in opposite direction.
      public MovePrev () : bool
      {
        match (current) {
          | Node.Head => ();
          | Node.Body (prev, _, _) => current = prev;
          | Node.Tail (last) => current = last;
        }
        match (current) {
          | Node.Head => false;
          | Node.Body => true;
          | Node.Tail => assert (false);
        }
      }

      // Reset position to the beginning
      public Reset () : void
      {
        current = coll.begin;
      }

      // Reset position to the end - intended for use with MovePrev().
      public ResetEnd () : void
      {
        current = coll.end;
      }

      // Inserts element d after the current position of the enumerator.
      // If enumerator points past the end of the sequence, item is appended
      // at the end.
      public Insert (d : 'a) : void
      {
        coll.Insert (current, d);
      }

      public Insert ([NotNull] l : MutableList ['a]) : void
      {
        coll.Insert (current, l);
      }

      // Removes item from the list. Enumerator must point valid position
      // in the sequence! After removal, Enumerator proceedes to the next
      // position (which may be past the end of the list, when it returns
      // false).
      public Remove () : bool
      {
        match (current) {
          | Node.Body => // valid position
            def to_delete = current;
            def retval = MoveNext();
            coll.Remove (to_delete);
            retval;
          | _ => // invalid
            throw System.ArgumentException ("Trying to remove inproper item!");
        }
      }

      // Returns the underlying list
      public Collection : MutableList ['a]
      {
        get { coll; }
      }

    } // Enumerator

    // This is one is to satisfy N.C.IEnumerable
    public GetEnumerator () : Enumerator ['a]
    {
      Enumerator (this);
    }

    // Now the ICollection['a] interface implementation

    // Count the elements of the list. 
    public Count : int {
      get {
        mutable lp = 0;
        def count_them (pos : Node ['a]) : void {
          | Node.Head (first) => count_them (first);
          | (Node.Body) as body => lp += 1; count_them (body.next);
          | Node.Tail => ();
        }

        count_them (begin);
        lp;
      }
    }

    // Checks for an empty list
    public IsEmpty : bool
    {
      get {
        match (begin) {
          | Node.Head (first) => first.Equals(end);
          | _ => assert (false);
        }
      }
    }

    public Add (item : 'a) : void
    {
      Prepend (item);
    }

    //TODO: only first occurence?
    public Remove (item : 'a) : void
    {
      def e = Enumerator (this);

      def remove_loop () : void {
        when (e.MoveNext())
          if (e.Current.Equals (item))
            _ = e.Remove();
          else
            remove_loop ();
      };

      remove_loop ();
    }

    // Clears the list
    public Clear() : void
    {
      match (begin) {
        | (Node.Head) as hd => hd.first = end;
        | _ => assert (false);
      }
      match (end) {
        | (Node.Tail) as tl => tl.last = begin;
        | _ => assert (false);
      }
    }

    public First () : option ['a]
    {
      match (begin) {
        | Node.Head (first) =>
          match (first) {
            | (Node.Body) as body => Some (body.data);
            | _ => None ();
          }
        | _ => assert (false);
      }
    }

    public Contains (item : 'a) : bool
    {
      def e = Enumerator (this);

      def member () : bool {
        if (e.MoveNext ())
          if (e.Current.Equals (item))
            true;
          else
            member ();
        else
          false;
      }

      member ();
    }

    public Clone () : MutableList ['a]
    {
      def l = MutableList ();
      foreach (item in this)
        l.Append (item);
      l;
    }

    public Fold ['b] (f : 'a * 'b -> 'b, x : 'b) : 'b
    {
      mutable retval = x;
      foreach (item in this)
        retval = f (item, retval);
      retval;
    }

    public Map ['b] (f : 'a -> 'b) : MutableList ['b]
    {
      def l = MutableList();
      foreach (item in this)
        l.Append (f (item));
      l;
    }

    public Iter (f : 'a -> void) : void
    {
      foreach (item in this)
        f (item);
    }

    public ForAll (f : 'a -> bool) : bool
    {
      def e = Enumerator (this);
      def check () : bool {
        if (e.MoveNext())
          if (f (e.Current))
            check ();
          else
            false;
        else
          true;
      }
      check ();
    }

    public Exists (f : 'a -> bool) : bool
    {
      def e = Enumerator (this);
      def check () : bool {
        if (e.MoveNext())
          if (f (e.Current))
            true;
          else
            check ();
        else
          false;
      }
      check ();
    }

    public Filter (f : 'a -> bool) : void
    {
      def e = Enumerator (this);
      def filter () : void {
        if (f (e.Current))
          when (e.MoveNext ())
            filter ();
        else
          when (e.Remove ())
            filter();
      }

      when (e.MoveNext ())
        filter();
    }

    public Partition (f : 'a -> bool) : MutableList ['a] * MutableList ['a]
    {
      def does = MutableList ();
      def donot = MutableList ();
      foreach (item in this)
        if (f (item))
          does.Append (item);
        else
          donot.Append (item);
      (does, donot);
    }			

  } // MutableList
} // namespace 
