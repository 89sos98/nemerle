open Nemerle.Compiler;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler.Typedtree {

record Function_decl
  {
    fun_header : Fun_header;
    body : Expr;
  }

record Named_pattern
  {
    name : string; // FIXME
    pat : Pattern;
  }
  
variant Pattern extends Located =
  [
    | P_underscore
    | P_variable { decl : Decl; }
    | P_tuple { args : list (Pattern); }
    | P_record { args : list (Named_pattern); }
    | P_cons { name : TD_variant_option; arg : Pattern; }
  ]
  
record Match_case
  {
    loc : Location;
    pattern : Pattern;
    body : Expr;
  }
  
class Expr_base extends Located
  {
    field ref expr_ty : Type;
  }

variant Expr extends Expr_base = 
  [ 
    | E_ref { decl : Decl; }
    | E_field_ref { obj : Expr; fld : M_field; }
    | E_method_ref { obj : Expr; meth : M_function; }
    | E_call { func : Expr; parms : list (Parm); }
    | E_assign { target : Expr; source : Expr; }
    | E_let { name : Decl; val : Expr; body : Expr; }
    | E_letfun { funs : list (Function_decl); body : Expr; }
    | E_match { expr : Expr; cases : list (Match_case); }
    | E_raise { exn : Expr; }
    | E_if { cond : Expr; e_then : Expr; e_else : Expr; }
    | E_try_with { body : Expr; exn : Decl; handler : Expr; }
    | E_try_finally { body : Expr; handler : Expr; }
    | E_literal { val : Literal; }
    | E_this
    | E_type_conversion { expr : Expr; ty : Type; }  // (expr :> ty)
    | E_type_enforcement { expr : Expr; ty : Type; } // (expr : ty)
    | E_sequence { body : list (Expr); }
    | E_tuple { args : list (Expr); }
  ]

record Parm
  {
    is_ref : bool;
    expr : Expr;
    name : id;  // "" if no name given
  }

 
} // Nemerle.Compiler.Typedtree
