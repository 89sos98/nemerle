<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle semantic and syntax extensions</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        You can think about semantic and syntax extensions as system
	of compile-time transformations of code and its automatic
	generation with regard to simple rules. It can be used either
	to automate simple actions performed on similar sets of datatypes
	and fragmets of code or to enrich language with some shortcuts
	to complicated function calls or other programming tricks,
	which makes coding faster.
      </p>
      <p>
        Idea of making simple inline operations on code comes from macros,
	which many languages (especially C, C++) contained since early times
	of compiler design. We are following it in direction of much more
	powerful, and at the same time more secure (typesafe), solutions
	like Haskell template metaprogramming.
    </body>
  </section>
  <section id="features">
    <title>Key features</title>
      <body>
        <ul>
	  <li> creating functions, whose amount and type of arguments depend
	    on each other (like C printf); our system would allow various 
	    transformations resulting in encapsulation of complex function
	    calls into simple and clear code</li>
	  <li> algorithmic generation of code, which may be dependant on
	    external factors, like XML files, script programs or even remote
	    web sites </li>
	  <li> completing datatypes with automatically created methods for
	    arbitrary operations on them, e.g. reading datasets from file,
	    sending then through network or storing in SQL database </li>
	  <li> using context of compilation provided by compiler's internal
	    structures, like line number (for error reporting), names of
	    processed type, function, class or namespace </li>
	</ul>
    </body>
  </section>
  <section id="using">
    <title>What exactly extension is?</title>
      <body>
        <p>
	  Basically every extension is a function, which takes some fragment
	  of code as parameter(s). On the highest level it doesn't matter
	  if it's type definition, function call or just list of assignments.
	  Most important fact is that they are not common objects 
	  (e.g. instances of defined types, like integer numbers), but
	  their internal representation in compiler (i.e. syntax tree).
	</p>
      </body>
  </section>
</document>
