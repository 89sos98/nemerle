#
# Copyright (c) 2003 The University of Wroclaw.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#    3. The name of the University may not be used to endorse or promote
#       products derived from this software without specific prior
#       written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
# NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

program:
	{ open_decl } { namespace_or_type_decl }

open_decl:
	"open" qid ";"

namespace_or_type_decl:
	"namespace" ID "=" qid ";"
	"namespace" qid "{" { namespace_or_type_decl } "}"
	type_decl

type_header:
	ID [ typarms ] [ extends ] [ implements ]
	
typarms:
	"(" TYVAR { "," TYVAR } ")" [ "where" TYVAR ":>" ty { "," TYVAR ":>" ty } ]
		Types can be parametrized by type variables. Type variables can be constrained 
		to be subtypes of given type. One type variable can be constrained more then 
		once (that's why type variables are not constrained in "()" but in separate 
		"where" clause), it has to satisfy each constraint.
	
extends:
	"extends" ty
		Types can extend other types. Extending implies subtyping. "extends" clause
		makes all fields of extended type be fields of derived type.
		
implements:
	"implements" ty { "," ty }
		Types can implement interfaces. Defined type is subtype of each interface
		it implements. It is not possible to implement the same interface more then
		once with different actual parameters (i.e. it's illegal to say:
		"implements X('a), X('b)").

type_decl:
	attrs "type" type_header "=" type_declarator
		An alias for existing type or external type import.
	attrs "interface" type_header "{" { interface_member } "}"
	attrs "class" type_header class_body
	attrs "struct" type_header class_body
	attrs "enum" type_header "{" [ "|" ] enum_variant { "|" enum_variant } "}"
	
type_declarator:
	ty ";"
	"extern" STRING_LITERAL ";"
        
id_or_dummy:
	ID
	"_"

qid:
	ID { "." ID }

interface_member:
	[ "new" ] [ "method" ] fun_def_head ";"
        
enum_variant:
	attrs ID [ "=" expr ]

attrs:
	{ attr }

attr:
	"new"
	"public"
	"protected"
	"internal"
	"private"
	"abstract"
	"sealed"
	"volatile"
	"extern"
	"const"
	"[" ID ":" qid [ attr_args ] "]"
	
attr_args:
	"(" ")"
	"(" [ expr { "," expr } "," ] ID "=" expr { "," ID "=" expr } ")"
	"(" expr { "," expr } ")"

type_member:
	attrs "field" [ "ref" ] ID ":" ty ";"
		Member value of type. If "ref" is included -- member is mutable.
	attrs "value" [ "ref" ] ID ":" ty ";"
		Like static members in C++. If "ref" is present -- value is 
		mutable.
	attrs "method" fun_def_term
	attrs "fun" fun_def_term
	type_decl
	
fun_def_head:
	typarms ID "(" fun_parms ")" ":" ty [ "implements" qid { "," qid } ]
	typarms "this" "(" fun_parms ")"

fun_body:
	expr
	"extern" STRING_LITERAL

fun_def:
	fun_def_head "=" fun_body
	fun_def_head "=" sequence
	
fun_def_term:
	fun_def_head "=" fun_body ";"
	fun_def_head "=" sequence

ref_or_out:
	"ref"
	"out"
        
fun_parm:
	attrs [ ref_or_out ] id_or_dummy ":" ty

fun_parms:
	[ fun_parms { "," fun_parm } ]

prim_ty:
	qid
		Reference named type. It is an error to reference type with formal arguments
		without actual arguments.
	qid "(" ty { "," ty } ")"
		Reference named type with specified type arguments. There ought to be exactly
		the same number of actual and formal parameters.
	TYVAR
	"(" ty ")"
		Grouping.
	prim_ty "[" { "," } "]"
		Array type (possibly multidimensional).
	"[" [ "|" ] ty { "|" ty } "]"
		Union type.
	"void"
	"ref" prim_ty
	"out" prim_ty

ty:
	prim_ty { "*" prim_ty }
		Tuple type.
	prim_ty { "->" prim_ty }
		Type of functions.

prim_expr:
	qid
		Value reference.
	"this"
		Refernce parent type instance in method.
	"base"
	"(" expr ")"
		Allow grouping.
	"null"
	"(" ")"
	STRING_LITERAL
	NUMBER_LITERAL
	"(" expr ":>" ty ")"
		Type cast.
	"(" expr ":" ty ")"
		Type enforcement.
	prim_expr "#" qid
		Member reference.
	sequence

sequence:
	"{" expr { ";" expr } [ ";" ] "}"

expr:
	prim_expr
	prim_expr "(" [ parameter { "," parameter } ] ")"
		Function call.
	prim_expr "<-" expr
		Assignment to mutable value (global mutable value, mutable
		type member, or array member).
	prim_expr "[" expr { "," expr } "]"
		Array access.
	"let" [ "ref" ] id_or_dummy "=" expr "in" expr
		Bind name to given value. If "ref" is given -- value is mutable.
	"fun" fun_def { "and" fun_def } "in" expr
		Bind functions to given names. Functions can be mutually recursive.
	"if" expr "then" expr "else" expr
	"tymatch" expr "with" "[" [ "|" ] tymatch_case { "|" tymatch_case } "]"
		Match on runtime type structure of given value.
	"raise" expr
		Raise exception.
	"try" expr "with" "(" "?" ID ":" ty ")" expr
		Try compute first expression. If specified exception is raised -- catch it.
		Exception value is then bound to specified ID.
	"try" expr "finally" expr
	expr OPERATOR expr
	OPERATOR expr

parameter:
	[ "ref" ] expr
	[ "ref" ] ID "=" expr

tymatch_case:
	[ "{" TYVAR { "," TYVAR } "}" ] ty [ tymatch_constraints ] "=>" expr
		If tymatched value x has specified type, where variables quantified
		in front of clause satisfy specified constraints, x is assumed to have
		this type in context of expr and expr is evaluated.
	
tymatch_constraints:
	"where" tymatch_constraint { "," tymatch_constraint }
		This is logical AND.

tymatch_constraint:
	TYVAR ":>" ty
		Type variable is bound to subtype of given type.
	TYVAR "=" ty
		Type variable is bound to exactly specified type.

# vim: ai ft=conf ts=4
