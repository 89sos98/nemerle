/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
public module Tyexpr {
  public type CTX = TypingContext;

  variant Call_result
  {
    | CR_unspecified_error
    | CR_error { msg : string; }
    | CR_ok { call : Expr; sub : Subst; }
  }

  class Typing_error : System.Exception
  {
    public msg : string;
    public this (s : string) { this.msg = s; }
  }

  public type_of (expr : Expr) : Type
  {
    if (expr.expr_ty == null) Util.ice ()
    else expr.expr_ty;
  }

  fixup (expr : Expr, loc : Location, t : Type) : Expr
  {
    expr.loc = loc;
    expr.expr_ty = t;
    expr
  }

  fixup (expr : Expr, t : Type) : Expr
  {
    expr.loc = Location_stack.top ();
    expr.expr_ty = t;
    expr
  }

  public expect_type (name : string, expr : Expr, t : Type) : void
  {
    if (type_of (expr) >:> t) ()
    else
      Message.error (expr.loc, name + " was expected to have type " +
                               t.as_string () + " while it has " +
                               (type_of (expr)).as_string ())
  }

  // given an expression return list of symbols it can expand to
  make_value_reference (ctx : CTX, expr : PT.Expr, fallback : bool) : list <Expr>
  {
    def expr = ConstantFolder.FoldTopConstants (ctx.env, expr);

    def lookup_type (expr) {
      match (Util.qidl_of_expr (expr)) {
        | Some ((r, name)) =>
          name.GetEnv (ctx.env).LookupType (r, ctx.parent_type)
        | _ => None ()
      }
    };

    def unalias (ti : Tycon) {
      match (ti.GetTydecl ()) {
        | TD_alias (T_app (ti, _)) => unalias (ti)
        | _ => ti
      }
    };

    def lookup_ctors (ti : Tycon) {
      def ti = unalias (ti);
      def is_ctor (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_ctor when m.CanAccess (ctx.parent_type) => true
              | _ => false
            }
          | _ => false
        }
      };
      match (List.Filter (ti.LookupMember (".ctor"), is_ctor)) {
        | [] when !ti.IsValueType =>
          Message.fatal_error ("type `" + ti.FullName +
                               "' has no accessible constructors")
        | decls => decls
      }
    };

    def convert_symbols (acc, syms) {
      def handle_type (t : Tycon) {
        def mkctor (m : IMember) {
          def ty =
            match (m.GetMemType ()) {
              | T_fun (arg, T_void) =>
                def ret_t =
                  match (t.GetTydecl ()) {
                    | TD_variant_option =>
                      def t' = Option.UnSome (t.SuperClass ());
                      t'.GetMemType () /- t.SubtypingSubst (t')
                    | _ =>
                      t.GetMemType ()
                  };
                def ret = T_fun (arg, ret_t) /- t.FreshSubst ();
                // Message.debug ("arg " + arg.as_string () +  " ret "
                //                + ret.as_string ());
                ret
                
              | t => Util.ice ("fscked ctor type " + t.as_string ())
            };
          E_static_ref (loc = expr.loc, ty = ty, mem = m)
        };

        match (t.GetTydecl ()) {
          | TD_alias (T_app (t, _)) => handle_type (t)
          | _ =>
            match (t.GetConstantObject ()) {
              | None =>
                def res = List.Map (lookup_ctors (t), mkctor);
                if (t.IsValueType) {
                  def ty = T_fun (T_void (), t.GetMemType () /- t.FreshSubst ());
                  E_implicit_value_type_ctor (loc = expr.loc,
                                              ty = ty,
                                              tc = t) :: res
                } else res
              | Some (f) =>
                [E_constant_object_ref (loc = expr.loc, 
                                        ty = T_fun (T_void (), 
                                                    f.GetMemType () /- t.FreshSubst ()), 
                                        mem = f)]
            }
        }
      };
      
      def last_chance () {
        match ((acc, syms)) {
         | ([], [_]) => true
         | _ => false
        }
      };
        
      def can_access () {
        match (syms) {
          | Sym_type_member (x) :: _
            when x.CanAccess (ctx.parent_type) => true
          | Sym_type (t) :: _
            when t.CanAccess (ctx.parent_type) => true
          | _ => false
        }
      };

      match (syms) {
        | [] => acc
          
        | Sym_type_member (x) :: xs when x.IsStatic =>
          if (can_access ()) {
            def acc =
              match (x.GetKind ()) {
                | MK_type (t) =>
                  List.RevAppend (handle_type (t), acc)
                    
                | MK_method (m) =>
                  def name = m.GetExternName ();
                  if (!Option.IsSome (name) || Option.UnSome (name).StartsWith ("%op"))
                    E_static_ref (loc = expr.loc, ty = m.GetFreshType (),
                                  mem = x) :: acc
                  else {
                    def name = Option.UnSome (name);
                        
                    def split_at_dots (str : string) {
                      def idx = str.LastIndexOf ('.');
                      if (idx == -1) PT.E_ref (PT.Name (str))
                      else PT.E_member (split_at_dots (str.Substring (0, idx)),
                                        PT.SS_string (PT.Name (str.Substring (idx + 1))))
                    };
                    def exprs =
                      make_value_reference (ctx, split_at_dots (name),
                                            fallback = false);
                    def valid (expr) {
                      match (expr) {
                        | E_static_ref (mem) =>
                          Tyutil.types_eq (mem.GetMemType (), m.GetMemType ())
                        | _ => false
                      }
                    };
                    match (List.Filter (exprs, valid)) {
                      | [x] => x :: acc
                      | [] =>
                        Message.fatal_error ("unbound extern symbol `" + name + "'")
                      | _ =>
                        Message.fatal_error ("wrong extern symbol `" + name + "'")
                    }
                  }
                    
                | MK_property (p) =>
                  E_static_property_ref (loc = expr.loc, ty = x.GetMemType (),
                                         prop = p) :: acc
                                           
                | MK_field =>                    
                  E_static_ref (loc = expr.loc, ty = x.GetMemType (), mem = x) :: acc

                | MK_event (e) =>
                  if (e.DeclaringType.SameAs (ctx.parent_type)) {
                    def field = (e :> NemerleEvent).storage_field;
                    if (field == null)
                      acc
                    else {
                      E_static_ref (loc = expr.loc,
                                    ty = field.GetMemType (),
                                    mem = field) :: acc
                    }
                  }
                  else
                    acc
              }
              
            convert_symbols (acc, xs)
          }
          else
          {
            when (last_chance ())
              Message.error ("cannot access `" +
                             x.DeclaringType.FullName + 
                             "." + x.Name + "'");
            convert_symbols (acc, xs)
          }
          
        | Sym_type_member :: xs =>
          convert_symbols (acc, xs)
          
        | Sym_type (t) :: xs when can_access () =>
          convert_symbols (List.RevAppend (handle_type (t), acc), xs)
          
        | Sym_type (t) :: xs => 
          when (last_chance ())
            Message.error ("cannot access type `" + t.FullName + "'");
          convert_symbols (acc, xs)
      }
    };

    def error_when_empty (lst, msg) {
      match (lst) {
        | [] => Message.fatal_error (msg)
        | _ => lst
      }
    };

    Util.locate (expr.loc, {
      match (expr) {
        | PT.E_ref (n) =>
          match (ctx.LookupLocal (n)) {
            | Some (d) =>
              ctx.Closurise (d);
              d.ever_used = true;
              def ty =
                match (d.kind) {
                  | D_local_fun (h, _) =>
                    d.ty /- Tyvar.fresh_subst (h.typarms)
                  | _ => d.ty
                };
              [E_local_ref (loc = expr.loc, ty = ty, decl = d)]
              
            | None =>
              def from_this =
                match (ctx.this_ptr_decl) {
                  | Some ({ty = T_app (ti, _)}) when n.context == null =>
                    def is_instance (m : IMember) { !m.IsStatic };
                    def mem = n.GetHead ();
                    if (List.Exists (ti.LookupMember (mem), is_instance))
                      lookup_member (ctx, expr.loc,
                                     ty_expr (ctx, PT.E_this ()), mem, 
                                     error_when_not_found = false)
                    else []
                  | _ => []
                };
                
              // resolve the symbols list
              def env = n.GetEnv (ctx.env);
              def symbols_from_env = env.LookupSymbol (n.idl);
              def res = convert_symbols (from_this, symbols_from_env);

              match (res) {
                | [] =>
                  // take into account static symbols from the current type
                  def ref_name = Util.qid_of_list (n.idl);
                  def from_parent_type = ctx.parent_type.LookupMember (ref_name);
                  
                  def static_and_name_filter =
                    fun (mem : IMember) {
                      mem.Name == ref_name &&
                      (mem.Attributes %&& NemerleAttributes.Static)
                    };
                  def symbol_map =
                    fun (mem : IMember) : Symbol {
                      Sym_type_member (mem)
                    };                
                  def symbols_from_type =
                    List.Map (List.Filter (from_parent_type,
                                           static_and_name_filter), symbol_map);

                  def res = convert_symbols ([], symbols_from_type);

                  match (res) {
                    | [] =>
                      // if failed to resolve the symbols, check the possible reason                  
                      def instance_mems =
                        List.Filter (from_parent_type,
                                     fun (mem : IMember) {
                                       mem.Name == ref_name &&
                                       !(mem.Attributes %&& NemerleAttributes.Static)
                                     });

                      match (instance_mems) {
                        | [] =>
                          error_when_empty (res, "unbound symbol `" + Util.qid_of_list (n.idl) + "'")
                      
                        | _ =>
                          Message.fatal_error ("referencing an instance member `" +
                                               ref_name + "' from within a static method");
                          []
                      }
                    | _ => res
                  }
                | _ => res
              }                  
          }

        | PT.E_member (e1, PT.SS_string ({ idl = [x] })) =>
          match (lookup_type (e1)) {
            | Some (t) =>              
              def err = "unbound member `" + x + "' in type `"
                        + t.FullName + "'";
              def t = unalias (t);
              match (t.LookupMember (x)) {
                | [] =>
                  match (lookup_type (expr)) {
                    | Some (t) =>
                      convert_symbols ([], [Sym_type (t)])
                    | None =>
                      Message.fatal_error (err)
                  }
                | lst =>
                  def loop (x : IMember, acc) { 
                    if (x.IsStatic)
                      Sym_type_member (x) :: acc
                    else acc
                  };
                  def lst' = List.FoldLeft (lst, [], loop);
                  error_when_empty (convert_symbols ([], lst'), err)
              }
            | None =>
              match (lookup_type (expr)) {
                | Some (t) =>
                  convert_symbols ([], [Sym_type (t)])
                | None =>                        
                  def typed_base_expr =
                    ty_expr (ctx, e1);

                  if ((typed_base_expr matches E_literal (L_null)))
                  {
                    def base_name =
                      match (Util.qidl_of_expr (e1)) {
                        | Some ((r, _)) =>
                          Util.qid_of_list (r)
                        | _ =>
                          Util.ice ("base_name")
                      };
                    
                    def lead_in_msg =
                      "failed to find namespace or type `" +
                      base_name + "' for accessing `" + x +"'";
                        
                    if (base_name == "System" || base_name == "Nemerle") {
                      Message.error (lead_in_msg);
                      Message.hint_once ("  maybe you forgot to reference an external library?");
                      throw Recovery ()
                    }
                    else {
                      if (base_name.LastIndexOf ('.') == -1) {
                        Message.error (lead_in_msg);
                        Message.hint_once ("  maybe you're trying to use a "
                                           "static type member as an instance "
                                           "member or forgot to reference an "
                                           "external library?");
                        throw Recovery ()
                      }
                      else
                        Message.fatal_error (lead_in_msg)
                    }
                  }
                  else
                  {                    
                    lookup_member (ctx, expr.loc, typed_base_expr, x)
                  }
              }
          };

        | PT.E_member (_, PT.SS_string ({idl = _ :: _})) =>
          Message.fatal_error ("member has more than one component in name")
        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_this =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = T_app (ti, _)}); in_ctor = true} =>
              def mkthis (m : IMember) {
                E_base (loc = expr.loc,
                        ty = m.GetMemType (),
                        base_ctor = (m :> IMethod))
              };
              List.Map (lookup_ctors (ti), mkthis)

            | _ =>
              Message.fatal_error ("`this (..)' used outside constructor")
          }

        | PT.E_base =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = T_app (ti, _)}); in_ctor = true} =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  // FIXME: check access
                  def mkbase (m : IMember) {
                    E_base (loc = expr.loc,
                            ty = m.GetMemType () /- ti.SubtypingSubst (baseti),
                            base_ctor = (m :> IMethod))
                  };
                  List.Map (lookup_ctors (baseti), mkbase)

                | None =>
                  Message.fatal_error ("class " + ti.FullName +
                                       " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base (..)' used outside constructor")
          }

        | PT.E_literal (l) => 
          [E_literal (loc = expr.loc, ty = ty_literal (ctx, l), val = l)]

        | _ when fallback => [ty_expr (ctx, expr)]
        | _ => Util.ice ("evil value passed to make_value_reference")
      }
    })
  }

  
  /*
   * Given list of formal parms names and actual parms names, reorder
   * actuals to match formals. The named parameters can be preceded
   * by a series of unnamed parameters:
   *
   *   foo (e_0, e_1, x_2 = e_2, x_3 = e_3, ..., x_k = e_k)
   *
   * where x_i are the named parameter references and e_i are some
   * expressions.
   */
  reorder_named_parms (top_names : list <string>,
                       top_parms : list <Parm>, 
                       do_throw : bool) : list <Parm>
  {
    // lookup tables for names, named and unnamed parameters
    def valid_names = Hashtable (16);
    def seen_named_parms = Hashtable (16);
    def seen_unnamed_parms = Hashtable (16);

    // we will need a way to lookup the valid parameter names
    List.Iter (top_names, fun (name) { valid_names.Add (name, name) });

    // failure handler
    def fail (msg : string) : bool
    {
      if (do_throw)
        throw Typing_error (msg)
      else
        false
    }

    // the correctness verifier
    def check_names_and_parms (names : list <string>, parms : list <Parm>) : bool
    {
      | ([], []) =>
        true

      | (_, []) =>
        // always throw an error here -- we'll catch it and produce better error
        // for wrong parameters count
        def unresolved_names =
          List.Filter (top_names, fun (name : string) {
            !(seen_named_parms.Contains (name) || seen_unnamed_parms.Contains (name))
          });

        def unresolved_names =
          List.Map (unresolved_names, fun (name : string) { "`" + name + "'" });
          
        throw Typing_error ("unresolved named parameters: " +
                            NString.Concat (", ", unresolved_names))
        
      | (name :: rest_of_names, parm :: rest_of_parms) when parm.name == "" =>
        // the case for an unnamed parameter
        if (seen_named_parms.Count > 0) {
          // seen a named parameter before, error...
          fail ("unnamed parameter found after a named parameter")          
        }
        else {
          // otherwise, this is an element of the leading unnamed parameters
          seen_unnamed_parms.Add (name, parm);
          check_names_and_parms (rest_of_names, rest_of_parms)
        }

      | (_ :: rest_of_names, parm :: rest_of_parms) =>
        // a named parameter, check if no unnamed parameter has covered it before
        if (seen_unnamed_parms.ContainsKey (parm.name)) {
          // this parameter name was covered by an unnamed parameter
          fail ("keyword parameter `" + parm.name + "' already specified as an unnamed parameter")
        }
        else if (seen_named_parms.ContainsKey (parm.name)) {
          // the case for repeating parameters
          fail ("keyword parameter `" + parm.name + "' already specified")
        }
        else if (!valid_names.ContainsKey (parm.name)) {
          // whoops, no such parameter for this method :]
          fail ("no such keyword parameter `" + parm.name + "' among valid parameter names")
        }
        else {
          // OK, this has to be right...
          seen_named_parms.Add (parm.name, parm);
          check_names_and_parms (rest_of_names, rest_of_parms)
        }
      
      | _ =>
        Util.ice ("reorder_named_parms: walk")
    }

    // reordering is a matter of simple names list walk now:
    def reorder_parms (names : list <string>, acc : list <Parm>) : list <Parm>
    {
      | (name :: rest_of_names, _) =>
        if (seen_unnamed_parms.Contains (name))
          reorder_parms (rest_of_names,
                         Option.UnSome (seen_unnamed_parms.Get (name)) :: acc)
        else if (seen_named_parms.Contains (name))
          reorder_parms (rest_of_names,
                         Option.UnSome (seen_named_parms.Get (name)) :: acc)
        else
          Util.ice ("reorder_named_parms: reorder")

      | ([], _) =>
        List.Rev (acc)
    }

    if (List.Exists (top_parms, fun (parm : Parm) { parm.name != "" })) {
      match (top_names) {
        | [] when do_throw =>
          throw Typing_error ("named parameters given but formals' names cannot"
                              " be inferred")
        | [] =>
          null          
        | _ =>
          if (check_names_and_parms (top_names, top_parms))
            reorder_parms (top_names, [])
          else
            null
      }
    }
    else
      top_parms
  }

  
  // check if FN can be called with PARMS
  check_call_to (ctx : CTX, parms : list <Parm>, fn : Expr, 
                 do_throw : bool, is_var_args : bool) : Call_result
  {
    def check_arg (parm : Parm, ty : Type, arg_no, sub) : int * Subst {
      if (arg_no < 0) (arg_no, sub)
      else {
        def expr_ty = type_of (parm.expr);
        def parm_ty =
          match (ty) {
            | T_ref (t) when parm.kind == ParmKind.Ref => t
            | T_out (t) when parm.kind == ParmKind.Out => t
            | T_out =>
              if (do_throw)
                throw Typing_error (sprintf ("needed `out' in argument #%d",
                                             arg_no))
              else null
            | T_ref =>
              if (do_throw)
                throw Typing_error (sprintf ("needed `ref' in argument #%d",
                                             arg_no))
              else null
            | _ when parm.kind != ParmKind.Normal =>
              if (do_throw)
                throw Typing_error (sprintf ("argument #%d was passed "
                                             "as ref/out", arg_no))
              else null
            | _ => ty
          };
        if (parm_ty == null)
          (-1, sub)
        else
          match (Tyutil.unify (sub, expr_ty, parm_ty, true)) {
            | Some (u) =>
              (arg_no + 1, u)
            | None when do_throw =>
              throw Typing_error (sprintf ("in arg #%d needed %s got %s", 
                                           arg_no, (ty /- sub).as_string (),
                                           (expr_ty /- sub).as_string ()))
            | None => (-1, sub)
          }
      }
    };

    def formal_names = {
      def from_header (h : Fun_header) : list <string> {
        List.Map (h.parms, fun (p : Fun_parm) : string { p.name })
      };
      match (fn) {
        | E_local_ref ({kind = D_local_fun (h, _)}) =>
          from_header (h)
        | E_method_ref (_, meth, _)
        | E_static_ref (meth : IMethod) =>
          from_header (meth.GetHeader ())
        | _ => []
      }
    };

    match (Tyutil.top_expand (type_of (fn))) {
      | T_fun (from, ret) =>
        // check if we are dealing with a delegate constructor
        def delegate_tycon =
          match (fn) {
            | E_static_ref (meth : IMethod) when (meth.DeclaringType.IsDelegate &&
                                                 (meth.GetFunKind () matches FK_ctor)) =>
              Some (meth.DeclaringType)
            | _ =>
              None ()
          }

        // get the arguments for delegate constructor from the Invoke method
        def args =
          match (delegate_tycon) {
            | Some (delegate_tycon) =>
              match (delegate_tycon.LookupMember ("Invoke")) {
                | [invoke] => 
                  def invoke_ty = (invoke :> IMethod).GetMemType ();
                  [invoke_ty]
                | _ =>
                  Message.fatal_error ("cannot decide upon delegate ctor parameters")
              }
            | _ =>
              Tyutil.fun_args (from)
          }
        
        def wrong_args_cnt (extra_message) {
          if (do_throw)
            throw Typing_error ("needed " + (List.Length (args)).ToString () +
                                " parameters, got " + (List.Length (parms)).ToString () +
                                extra_message)
          else
            null
        };

        try {
          def args =
            match ((parms, args)) {
              | ([parm], _ :: _ :: _) when ! is_var_args =>
                // FIXME: it doesn't work when parm : 'a, where 'a is unconstrained
                match (Tyutil.top_expand (type_of (parm.expr))) {
                  | T_prod (types) when List.Length (types) == List.Length (args) =>
                    [T_prod (args)]
                  | _ => wrong_args_cnt ("")
                }
              | _ =>
                if (List.Length (args) == List.Length (parms) ||
                    (is_var_args && List.Length (args) <= List.Length (parms) + 1))
                  args
                else if (List.Length (args) > List.Length (parms))
                {
                  def named_parms_message =
                    try {
                      ignore (reorder_named_parms (formal_names, parms, false));
                      ""
                    }
                    catch { e : Typing_error => " (" + e.msg + ")" }
                  
                  wrong_args_cnt (named_parms_message)
                }
                else
                  wrong_args_cnt ("")
            };
          def parms =
            if (args == null) null 
            else reorder_named_parms (formal_names, parms, do_throw);
          def (argno, sub) =
            if (parms == null || args == null) (-1, null)
            else {
              def loop (arg_no, map, parms, args) {
                match ((parms, args)) {
                  | (parm :: parms, [T_array (t, 1)]) when is_var_args =>
                    def (arg_no, map) = check_arg (parm, t, arg_no, map);
                    loop (arg_no, map, parms, args) // args doesn't change
                  | ([], [_]) when is_var_args => (arg_no, map)
                  | (parm :: parms, arg :: args) =>
                    def (arg_no, map) = check_arg (parm, arg, arg_no, map);
                    loop (arg_no, map, parms, args)
                  | ([], []) => (arg_no, map)
                  | _ => assert (false)
                }
              }
              loop (1, SystemMap (), parms, args)
            }
          if (argno < 0)
            CR_unspecified_error ()
          else {
            def parms =
              if (is_var_args) {
                def split (_, _, _) {
                  | (acc, [_], lst) =>
                    def get_expr (parm : Parm) {
                      when (parm.kind != ParmKind.Normal)
                        Message.error ("ref/out parameters are not allowed with `parms'");
                      when (parm.name != "")
                        Message.error ("named parameters are not allowed with `parms'");
                      parm.expr
                    }
                    (acc, List.Map (lst, get_expr))
                  | (acc, _ :: args, x :: xs) => 
                    split (x :: acc, args, xs)
                  | _ => assert (false)
                }
                def (regular_parms, for_array) = split ([], args, parms);
                def mkarray = E_mkarray (fn.loc, List.Last (args), 
                                         for_array, [List.Length (for_array)]);
                List.Rev (Parm (mkarray) :: regular_parms)
              } else parms;
            def res_expr =
              match (fn) {
                | E_constant_object_ref (mem) =>
                  assert (parms.IsEmpty ());
                  E_static_ref (fn.loc, ret /- sub, mem)
                | E_implicit_value_type_ctor =>
                  assert (parms.IsEmpty ());
                  fn.expr_ty = ret /- sub;
                  fn
                | _ =>
                  E_call (fn.loc, ret /- sub, fn, parms)
              };
            //Message.debug ("ret type = " + (ret /- sub).as_string ());
            CR_ok (res_expr, sub)
          }
        }
        catch { x : Typing_error => CR_error (x.msg) }
        
      | ty when Tyutil.IsDelegate (ty) =>
        match (LookupMembers (ctx, ty, "Invoke")) {
          | [mem] =>
            def fn' = E_method_ref (fn.loc, mem.GetMemType (), fn, (mem :> IMethod), false);
            check_call_to (ctx, parms, fn', do_throw, is_var_args)
          | _ when do_throw =>
            CR_error ("cannot find `Invoke' method in delegate type " +
                      (type_of (fn)).as_string ())
          | _ =>
            CR_unspecified_error ()
        }
        
      | _ when do_throw =>
        CR_error ("called value has non-functional type " +
                  (type_of (fn)).as_string ())
                  
      | _ =>
        CR_unspecified_error ()
    }
  }

  transform_tail_call (ctx : CTX, ex : Expr) : Expr
  {
    match (ex) {
      | E_call ((E_local_ref (({kind = D_local_fun (h, _)}) as decl)) as fn, parms) =>
        if (ctx.in_tail_position && ctx.current_fun.id == h.id)
          E_self_tail_call (ex.loc, ex.expr_ty, parms)
        else {
          match (h.usage) {
            | FU_not_used =>
              if (decl.parent_fun.id == ctx.current_fun.id)
                h.usage = FU_used_just_once ()
              else
                h.usage = FU_used ()
            | FU_used_just_once =>
              h.usage = FU_used ()
            | FU_used | FU_used_as_first_class => ()
          };
          if (ctx.in_tail_position)
            E_tail_call (ex.loc, ex.expr_ty, fn, parms)
          else
            ex
        }
      | E_call ((E_static_ref (mem)) as fn, parms) when ctx.in_tail_position =>
        match (mem.GetKind ()) {
          | MK_method (meth) when meth.GetHeader ().id == ctx.current_fun.id =>
            E_self_tail_call (ex.loc, ex.expr_ty, parms)
          | _ =>
            E_tail_call (ex.loc, ex.expr_ty, fn, parms)
        }
      | E_call (fn, parms) when ctx.in_tail_position =>
        E_tail_call (ex.loc, ex.expr_ty, fn, parms)
      | _ => ex
    }
  }

  
  mark_as_used (expr : Expr) : void
  {
    | E_call (E_static_ref (mem : IMember), _)
    | E_call (E_method_ref (_, mem, _), _)
    | E_tail_call (E_static_ref (mem : IMember), _)
    | E_tail_call (E_method_ref (_, mem, _), _)
    | E_field_ref (_, mem)
    | E_constant_object_ref (mem)
    | E_property_ref (_, mem)
    | E_static_property_ref (mem)
    | E_method_ref (_, mem, _)
    | E_implicit_value_type_ctor (mem) =>
      mem.HasBeenUsed = true

    | E_static_ref (mem) =>
      // mark the constant variant constructor marked if referencing to its const object
      when ((mem is NemerleField) && mem.Name == "_N_constant_object")
      {
        def declaring_type = (mem.DeclaringType :> TypeBuilder);

        List.Iter (declaring_type.LookupMember (".ctor"), fun (ctor : IMember) {
          when ((ctor :> IMethod).GetHeader ().parms matches [])
            ctor.HasBeenUsed = true
        })
      }
      mem.HasBeenUsed = true
      
    | _ =>
      ()
  }

  
  resolve_overloaded_call (ctx : CTX, in_tail_pos : bool, fncs : list <Expr>,
                           parms : list <Parm>) : Expr
  {
    def is_var_args (fn) {
      | E_static_ref (meth : IMethod)
      | E_method_ref (_, meth, _) =>
        meth.IsVarArgs        
      | _ => false
    };
    
    def check_one (fn, acc) {
      match (check_call_to (ctx, parms, fn, false, false)) {
        | CR_ok (ex, sub) => (ex, sub) :: acc
        | _ => acc
      }
    };

    def check_one_va (fn, acc) {
      if (is_var_args (fn))
        match (check_call_to (ctx, parms, fn, false, true)) {
          | CR_ok (ex, sub) => (ex, sub) :: acc
          | _ => acc
        }
      else acc
    };

    def check_error (fn, acc) {
      match (check_call_to (ctx, parms, fn, true, false)) {
        | CR_error (msg) =>
          def acc = (msg, fn) :: acc;
          if (is_var_args (fn))
            match (check_call_to (ctx, parms, fn, true, true)) {
              | CR_error (msg) =>
                (msg, fn) :: acc
              | _ => assert (false)
            }
          else acc
        | _ => assert (false)
      }
    };

    mutable used_var_args = false;

    def res = List.FoldLeft (fncs, [], check_one);
    def res =
      // varargs version is used *only* if there is no match not using it
      match (res) {
        | [] => 
          used_var_args = true;
          List.FoldLeft (fncs, [], check_one_va)
        | _ => res
      };

    match (res) {
      // special case (simple)
      | [(x, sub)] =>
        mark_as_used (x);
        Tyvar.global_store (sub);
        transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x)
        
      | [] =>
        match (List.FoldLeft (fncs, [], check_error)) {
          | [(err, fn)] =>
            Message.error (err + " calling " + describe_expression (fn)); 
            throw Recovery ()
          | p =>
            Message.error ("typing error in call:");
            def print_err (err, fn) {
              Message.error ("  " + err + " calling " + describe_expression (fn)) 
            };
            List.Iter (p, print_err);
            throw Recovery ()
        }
        
      // in general we look for set of maximal argument types
      | l =>
        def get_type (ex : Expr, s : Subst) : Type * (Expr * Subst) {
          match (ex) {
            | E_call (fn, _) =>
              match (Tyutil.top_expand (type_of (fn))) {
                | T_fun (t1, _) =>
                  if (used_var_args)
                    match (List.DivideLast (Tyutil.fun_args (t1))) {
                      | ([], T_array (t, 1)) =>
                        (t, (ex, s))
                      | (fun_args, T_array (t, 1)) =>
                        (T_prod (fun_args + [t]), (ex, s))
                      | _ => assert (false)
                    }
                  else
                    (t1, (ex, s))
                | _ => Util.ice ()
              }
            | _ => Util.ice ()
          }
        };

        match (Tyutil.maximal_types (List.Map (l, get_type))) {
          | [(_, (x, sub))] =>
            mark_as_used (x);
            Tyvar.global_store (sub);
            transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x)
            
          | l =>
            def print_err (_ : Type, x : Expr * Subst) : void {
              match (x) {
                /*
                | (E_call (E_ref (d), _), _) =>
                  // FIXME: we could do better
                  Message.error (d.loc, "    functional value of type "
                                 + d.ty.as_string ())
                */
                | (E_call (ex, _), _) =>
                  Message.error ("    functional value of type "
                                 + (type_of (ex)).as_string ())
                | _ => Util.ice ("non-call")
              }
            };
            Message.error ("overloading resolution ambiguity between:");
            List.Iter (l, print_err);
            throw Recovery ()
        }
    }
  }

  public LookupMembers (ctx : CTX, t : Type, mem : string) : list <IMember>
  {
    def visited = Hashtable (10);
    def return = Hashtable (10);

    def collect_from (t) {
      match (Tyutil.top_expand (t)) {
        | T_app (ti, _) =>
          unless (visited.Contains (ti.GetId ())) {
            visited.Add (ti.GetId (), null);

            def can_access (mem : IMember) {
              when (!mem.IsStatic && 
                    mem.CanAccess (ctx.parent_type)) {
                return.Add (mem.GetId (), mem)
              }
            };
            def members = ti.LookupMember (mem);
            List.Iter (members, can_access);
          }

        | T_var (tv) =>
          unless (visited.Contains (tv.id)) {
            visited.Add (tv.id, null);
            def constraints =
              match (Tyvar.constraints (tv)) {
                | [] => [InternalType.Object]
                | lst => lst
              };
            List.Iter (constraints, collect_from)
          }

        | T_array =>
          collect_from (InternalType.Array)

        | _ => ()
      }
    };

    collect_from (t);
    return.Fold ([], fun (_, el, acc) { el :: acc })
  }

  public lookup_member (ctx : CTX, loc : Location, o : Expr, mem : string)
  : list <Expr>
  {
    lookup_member (ctx, loc, o, mem, true);
  }
  
  // lookup member MEM in type_of (O)
  // return list of how we can call it
  public lookup_member (ctx : CTX, loc : Location, o : Expr, mem : string, 
                        error_when_not_found : bool) : list <Expr>
  {
    mutable problem = "???";
    def visited = Hashtable (10);

    def collect_from (t, acc) {
      match (Tyutil.top_expand (t)) {
        | T_app (ti, args) =>
          if (visited.Contains (ti.GetId ())) acc
          else {
            visited.Add (ti.GetId (), null);

            def subst = ti.MakeSubst (args);
            def can_access (mem : IMember, acc) {
              if (!mem.IsStatic && mem.CanAccess (ctx.parent_type))
                mem.GetKind () :: acc
              else
                acc
            };
            def is_static (mem : IMember, acc) {
              if (mem.IsStatic && mem.CanAccess (ctx.parent_type))
                mem.GetKind () :: acc
              else
                acc
            };
            def members = ti.LookupMember (mem);
            def static_members = List.FoldLeft (members, [], is_static);
            def accessible_members = List.FoldLeft (members, [], can_access);
            def mems =
              match (accessible_members) {
                | [MK_field (f)] =>
                  [E_field_ref (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [MK_event (e)] when 
                    e.DeclaringType.SameAs (ctx.parent_type) &&
                    (e :> NemerleEvent).storage_field != null =>
                  def f = (e :> NemerleEvent).storage_field;
                  [E_field_ref (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [] =>
                  def (prefix, suffix) =
                    match ((members, static_members)) {
                      | ([], _) => ("unbound", "")
                      | (_, []) => ("inaccessible", "")
                      | _ => ("can't access static", " through an instance reference")
                    }
                  
                  problem =
                    prefix + " member `" + mem + "' in type `" +
                    ti.FullName + "'" + suffix;
                  []
                  
                | lst =>
                  mutable was_prop = false;
                  mutable was_meth = false;
                  def make (m) {
                    match (m) {
                      | MK_property (p) when !was_meth =>
                        was_prop = true;
                        E_property_ref (loc, Tyutil.TypeOfMemberIn (p, ti) /- subst, o, p)
                      | MK_method (m) when !was_prop =>
                        was_meth = true;
                        E_method_ref (loc, Tyutil.TypeOfMethodIn (m, ti) /- subst, o, m, false)
                      | _ =>
                        Message.fatal_error ("ambiguous member name `" + mem +
                                             "' in type `" + ti.FullName + "'")
                    }
                  };
                  List.Map (lst, make)
               };
            List.Append (mems, acc)
          }

        | T_var (tv) =>
          if (visited.Contains (tv.id)) acc
          else {
            visited.Add (tv.id, null);
            def constraints =
              match (Tyvar.constraints (tv)) {
                | [] => [InternalType.Object]
                | lst => lst
              };
            match (List.FoldLeft (constraints, acc, collect_from)) {
              | [] =>
                problem = "no constrain of " + t.as_string () +
                           " provides member `" + mem + "'";
                []
              | acc => acc
            }
          }

        | T_array =>
          collect_from (InternalType.Array, acc)

        | T_prod =>
          collect_from (InternalType.Object, acc)

        | _ =>
          problem = "type `" + t.as_string () + "' was expected to be class";
          acc
      }
    };

    match (collect_from (type_of (o), [])) {
      | [] when error_when_not_found => Message.fatal_error (problem)
      | x => x
    }
  }

  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.E_match) : Expr * Type
  {
    def itp = ctx.in_tail_position;
    def ctx = ctx.WithInTailPosition (false);
    def matched_value = ty_expr (ctx, mtch.expr);

    def do_case (c : PT.Match_case, acc) {
      def (pat, ctx') = Typattern.ty_patterns (ctx, type_of (matched_value), c.patterns);
      def body = ty_expr (ctx'.WithInTailPosition (itp), c.body);
      match (acc) {
        | (Some (t), l) =>
          match (Tyutil.unify_branches (t, type_of (body))) {
            | Some (t') => (Some (t'), Match_case (pat, body) :: l)
            | None =>
              expect_type ("match case body", body, t);
              Util.ice () // not reached
          }
        | (None, l) =>
          (Some (type_of (body)), Match_case (pat, body) :: l)
      }
    };

    match (List.FoldLeft (mtch.cases, (None (), []), do_case)) {
      | (Some (t), mcs') =>
        def mcs = List.Rev (mcs');
        Typattern.check_matching (mcs);
        (E_match (matched_value, mcs), t)
      | (None, _) =>
        Message.fatal_error ("cannot have empty match construct");
    }
  }

  ty_letfun (ctx : CTX, fs : list <PT.Function_decl>) : list <Function_decl> * CTX
  {
    def make_fun (d : PT.Function_decl) {
      def pars = {
        def h = ctx.current_fun;
        if (h.decl == null) [h]
        else
          match (h.decl.kind) {
            | D_local_fun (_, pars) => h :: pars
            | _ => Util.ice ()
          }
      };

      def h = d.header;
      def name_obj = Macros.NameOfSString (h.name);
      def (tenv, typarms) = ctx.parent_type.BindTyparms (ctx.tenv, h.typarms);
      def mkparm (p : PT.Fun_parm) : Fun_parm {
        def name = Macros.NameOfSString (p.name);
        Fun_parm (loc = p.loc, name = name.GetHead (), color = name.color,
                  ty = ctx.parent_type.BindType (tenv, p.ty), decl = null,
                  modifiers = p.modifiers)
      };
      def h' = Fun_header (
         ret_type = ctx.parent_type.BindType (tenv, h.ret_type),
         typarms = typarms,
         name = name_obj.GetHead (),
         parms = List.Map (h.parms, mkparm),
         tenv = tenv,
         loc = h.loc);

      def lv = ctx.DefineLocal (name_obj,
                                D_local_fun (h', pars), 
                                Tyutil.fun_type (h'));
      h'.decl = lv;
      h'
    };

    def headers = List.Map (fs, make_fun);
    def localvals = List.Map (headers, fun (h : Fun_header) { h.decl });
    def ctx = ctx.WithLocals (localvals);
    def do_fun (d : PT.Function_decl, h : Fun_header) : Function_decl {
      Function_decl (h, ty_function (ctx, h, d.body))
    };
    (List.Map2 (fs, headers, do_fun), ctx)
  }

  ty_sequence (ctx : CTX, l : list <PT.Expr>) : Expr
  {
    def in_tail_pos = ctx.in_tail_position;
    def orig_ctx = ctx;
    def ctx = ctx.WithInTailPosition (false);

    def go () : Expr {
      match (l) {
        | [x] => ty_expr (orig_ctx, MacroRegistry.expand_macro (ctx, x))

        | x :: xs =>
          match (MacroRegistry.expand_macro (ctx, x)) {
            | PT.E_letfun (fs) =>
              def (fs', ctx') = ty_letfun (ctx, fs);
              def body = ty_sequence (ctx'.WithInTailPosition (in_tail_pos), xs);
              fixup (E_letfun (fs', body), type_of (body))

            | (PT.E_let) as x =>
              def val = ty_expr (ctx, x.val);
              def name = match (x.name) {
                | PT.SS_string (n) => n
                | _ =>
                  Message.fatal_error ("$ operator used outside quotation "
                                       "<[ ... ]> context")
              };

              // check for mutable symbol redefinitions
              match (ctx.LookupLocal (name)) {
                | Some (l) =>
                  when (l.name == Macros.StringOfSString (x.name)) {
                    def warn =
                      if (x.is_ref && l.is_ref)
                        Some (("mutable", ""))
                      else if (!x.is_ref && l.is_ref)
                        Some (("mutable", " as non-mutable"))
                      else if (x.is_ref && !l.is_ref)
                        Some (("non-mutable", " as mutable"))
                      else
                        None ();

                    match (warn) {                    
                      | Some ((was_of_kind, is_of_kind)) =>                      
                        Message.warning (x.loc, "redefinition of a local " +
                                         was_of_kind + " value `" + l.name +
                                         "'" + is_of_kind);
                        Message.warning (l.loc, "  <-- previously seen here")
                      | _ => ()                      
                    }                      
                  }
                | _ => ()
              }
              
              def decl = ctx.DefineLocal (name, D_local_value(), type_of (val));
              decl.is_ref = x.is_ref;
              def body = ty_sequence (ctx.WithLocal (decl).
                                      WithInTailPosition (in_tail_pos), xs);
              fixup (E_let (decl, val, body), type_of (body))

            | PT.E_letpat (p, v) =>
              def body = PT.E_sequence (xs);
              def mtch = PT.E_match (v, [PT.Match_case ([(p, None ())], body)]);
              body.loc = (List.Head (xs)).loc;
              mtch.loc = p.loc;
              ty_expr (orig_ctx, mtch)

            | x =>
              def ex = ty_expr (ctx, x);
              def t = type_of (ex);
              if (t >:> T_void ()) {
                def tl = ty_sequence (orig_ctx, xs);
                fixup (E_sequence (ex, tl), type_of (tl))
              } else {
                Message.warning ("ignored computed value of type " + t.as_string ());
                Message.hint_once ("use ignore (...); to avoid the warning");

                def tmp = Util.tmpname ("ign");
                def decl = ctx.DefineLocal (tmp, 1, D_local_value (), type_of (ex));
                def body = ty_sequence (ctx.WithLocal (decl).
                                        WithInTailPosition (in_tail_pos), xs);
                fixup (E_let (decl, ex, body), type_of (body))
              }
          }
        | [] => Util.ice ("empty sequence")
      }
    };

    Util.locate ((List.Head (l)).loc, go ())
  }

  public ty_literal (_ : CTX, l : Literal) : Type
  {
    match (l) {
      | L_void => T_void ()
      | L_null =>
        match (Tyvar.free_variable ()) {
          | (T_var (tv)) as r => tv.value = TV_free_from_null (); r
          | _ => Util.ice ()
        }
      | L_byte => InternalType.Byte
      | L_sbyte => InternalType.SByte        
      | L_short => InternalType.Int16
      | L_ushort => InternalType.UInt16        
      | L_int => InternalType.Int32
      | L_uint => InternalType.UInt32        
      | L_long => InternalType.Int64
      | L_ulong => InternalType.UInt64        
      | L_char => InternalType.Char
      | L_string => InternalType.String
      | L_float => InternalType.Single
      | L_double => InternalType.Double
      | L_decimal => InternalType.Decimal        
      | L_bool => InternalType.Boolean
      | L_enum (_, tc) => T_app (tc, [])
    }
  }

  describe_expression (expr : Expr) : string
  {
    match (expr) {
      | E_local_ref (d) =>
        "a reference to local symbol `" + d.name + "'"
      | E_static_ref (m) =>
        def tyname =
          if (m.DeclaringType == null)
            ""
          else
            m.DeclaringType.FullName + ".";
        "a reference to global symbol `" + tyname + m.Name + "'"
      | E_field_ref (_, f) =>
        "a reference to field `" + f.Name + "'"
      | E_constant_object_ref (m) =>
        "a reference to constant constructor of `" + 
        m.DeclaringType.FullName + "'"
      | E_implicit_value_type_ctor (t) =>
        "a reference to implicit constructor of `" + 
        t.FullName + "'"
      | E_static_property_ref (p)
      | E_property_ref (_, p) =>
        "a reference to property `" + p.Name + "'"
      | E_method_ref (_, m, _) =>
        "a reference to method `" + m.Name + "'"
      | E_tail_call (f, _)
      | E_call (f, _) =>
        "a function call to " + describe_expression (f)
      | E_self_tail_call =>
        "self-recursive function call"
      | E_assign => "an assignment"
      | E_let => "an value binding"
      | E_letfun => "an function binding"
      | E_match => "an `match' expression"
      | E_raise => "a throw expression"
      | E_try_with => "a try...with expression"
      | E_try_finally => "a try...finally expression"
      | E_literal => "a literal value"
      | E_this => "a this pointer reference"
      | E_base => "a base class reference"
      | E_type_conversion => "a type conversion (:>)"
      | E_type_enforcement => "a type enforcement (:)"
      | E_sequence => "a sequence"
      | E_tuple => "a tuple constructor"
      | E_mkarray => "an array constructor"
      | E_array_indexer => "an array indexer reference"
      | E_typeof => "an typeof expression"
      | E_opcode => "an operator reference"
    }
  }

  is_indexer_property (prop : IProperty) : bool
  {
    def getter = prop.GetGetter ();
    def setter = prop.GetSetter ();
    (getter != null && List.Length (getter.GetHeader ().parms) != 0) ||
    (setter != null && List.Length (setter.GetHeader ().parms) != 1)
  }

  make_first_class (ctx : CTX, expr : Expr) : Expr
  {
    match (expr) {
      | E_method_ref (obj_ref, mem, _) =>
        match (Tyutil.top_expand (type_of (expr))) {
          | T_fun (from, _) =>
            def mkparm (_, acc) {
               def t = PT.Name (Util.tmpname ("parm"));
               def (fps, ps) = acc;
               (PT.Fun_parm (expr.loc, PT.SS_string (t), PT.T_infer (), 
                             Modifiers.Empty) :: fps,
                             PT.E_ref (expr.loc, t) :: ps)
            };
            def (fps, ps) = List.FoldLeft (Tyutil.fun_args (from), ([], []), mkparm);
            def ptr_name = PT.Name (Util.tmpname ("ptr"));
            def header =
              PT.Fun_header (expr.loc, PT.SS_string (PT.Name (Util.tmpname ("ml"))),
                             PT.T_infer (), fps);
            def body = PT.E_call (PT.E_member (PT.E_ref (ptr_name), 
                                  PT.SS_string (PT.Name (mem.Name))), ps);
            //def body = <[ $(ptr_name : name) . $mem_name (.. $ps) ]>;
            def lambda = PT.E_lambda (expr.loc, PT.Function_decl (header, body));
            ty_expr (ctx, PT.E_sequence ([
                PT.E_let (false, PT.SS_string (ptr_name),
                          PT.E_typed_expr (obj_ref)),
                lambda
                ]))
            //ty_expr (ctx, <[ { def $(ptr_name : name) = $(tye : typed);
            //                   $lambda
            //                 } ]>)
          | _ => Util.ice ()
        }
      | E_local_ref ({kind = D_local_fun (h, _)}) =>
        h.usage = FU_used_as_first_class ();
        expr
      | E_property_ref (_, prop) when is_indexer_property (prop) =>
        Message.fatal_error ("indexer property `" + prop.Name + 
                             "' used as first class value")
      | _ => expr
    }
  }

  public ty_expr (ctx : CTX, expr : PT.Expr) : Expr
  {
    def expr = ty_expr_with_no_properties_conversion (ctx, expr);
    def make_getter (obj, prop : IProperty, args) {
      def meth = prop.GetGetter ();
      E_call (expr.loc, expr.expr_ty, 
              E_method_ref (expr.loc, meth.GetMemType (), obj, meth, false),
              args)
    };
    def make_static_getter (prop : IProperty, args) {
      def meth = prop.GetGetter ();
      E_call (expr.loc, expr.expr_ty, 
              E_static_ref (expr.loc, meth.GetMemType (), meth),
              args)
    };
    match (expr) {
      | E_property_ref (obj, prop) => make_getter (obj, prop, [])
      | E_call (E_property_ref (obj, prop), args) => make_getter (obj, prop, args)
      | E_static_property_ref (prop) => make_static_getter (prop, [])
      | E_call (E_static_property_ref (prop), args) => make_static_getter (prop, args)
      | expr => expr
    }
  }


  convert_setter_property (_ctx : CTX, expr : Expr, val : Expr) : Expr * Type
  {
    def make_setter (obj, prop : IProperty, args)
    {
      def meth = prop.GetSetter ();
      E_call (expr.loc, T_void (), 
              E_method_ref (expr.loc, meth.GetMemType (), obj, meth, false),
              List.Append (args, [Parm (val)]))
    }
      
    def make_static_setter (prop : IProperty, args)
    {
      def meth = prop.GetSetter ();
      E_call (expr.loc, T_void (), 
              E_static_ref (expr.loc, meth.GetMemType (), meth),
              List.Append (args, [Parm (val)]))
    }
    
    def res =
      match (expr) {
        | E_property_ref (obj, prop) =>
          expect_type ("assigned value", val, type_of (expr));
          make_setter (obj, prop, [])
        | E_call (E_property_ref (obj, prop), args) =>
// FIXME: this needs a substitution from the typing context on ret_type, how to do it?
//          expect_type ("assigned value", val, prop.GetGetter ().GetHeader ().ret_type);
          make_setter (obj, prop, args)
        | E_static_property_ref (prop) =>
          expect_type ("assigned value", val, type_of (expr));
          make_static_setter (prop, [])
        | E_call (E_static_property_ref (prop), args) =>
// FIXME: this needs a substitution from the typing context on ret_type, how to do it?
//          expect_type ("assigned value", val, prop.GetGetter ().GetHeader ().ret_type);
          make_static_setter (prop, args)
        | expr =>
          expect_type ("assigned value", val, type_of (expr));
          E_assign (expr.loc, T_void (), expr, val)
      };

    (res, T_void ())
  }
  

  ty_call (ctx : CTX, in_tail_pos : bool, fnc : PT.Expr, parms : list <PT.Expr>) : Expr
  {
    def refout (name, expr) {
      match (expr) {
        | PT.E_parm_by_ref (ex)
        | PT.E_parm_out (ex) =>
          def ex = ty_expr (ctx, ex);
          unless (is_lvalue (ctx, ex, need_ref = true))
            Message.error ("ref/out parameters need lvalue but " + 
                           describe_expression (ex) + 
                           " was passed");
          def kind =
            match (expr) {
              | PT.E_parm_by_ref => ParmKind.Ref 
              | _ => ParmKind.Out
            };
          Parm (kind, ex, name)
        | ex =>
          Parm (ParmKind.Normal, ty_expr (ctx, ex), name)
      }
    };
    def fp (p : PT.Expr) {
      | <[ $(name : name) = $e ]> => refout (name.GetHead (), e)
      | e => refout ("", e)
    };

    def parms = List.Map (parms, fp);
    def fncs = make_value_reference (ctx, fnc, fallback = true);
    def ex = resolve_overloaded_call (ctx, in_tail_pos, fncs, parms);
    match (ex) {
      | E_call (E_property_ref (_, prop), _) when is_indexer_property (prop) =>
        Message.error ("attempt to call an indexer property `" + 
                       prop.Name + "'");
      | _ => ()
    };

    ex
  }
  

  is_lvalue (ctx : CTX, e : Expr, need_ref : bool) : bool
  {
    match (e) {
      | E_local_ref (d) => d.is_ref
      | E_static_ref (m) =>
        match (m.GetKind ()) {
          | MK_field (f) =>
            f.IsMutable || (ctx.current_fun.name == ".cctor" && 
                            f.DeclaringType.SameAs (ctx.parent_type))
          | MK_property (p) when !need_ref => p.IsMutable
          | _ => false
        }
      | E_static_property_ref (p) when !need_ref => p.IsMutable
      | E_field_ref (E_local_ref ({kind = D_closurised_this_ptr}), _)
        when ctx.in_ctor => true
      | E_field_ref (_, mem) => mem.IsMutable
      | E_property_ref (_, p) when !need_ref => p.IsMutable
      | E_call (E_property_ref (_, p), _) when !need_ref => p.IsMutable
      | E_array_indexer => true
      | _ => false
    }
  }

  ty_mkarray (ctx : CTX, rank : int, args : PT.Expr) : Expr * Type
  {
    def expr_list_length (e) {
      | <[ [] ]> => 0
      | <[ $_ :: $rest ]> => 1 + expr_list_length (rest)
      | _ => Message.fatal_error ("array initializer must be of form `array <rank> [ [..], .., [..] ]'")
    }

    def expr_list_flatten_and_count (e, remaining) {
      | (<[ [] ]>, 0) => []
      | (_, 0) => Message.fatal_error ("incorrectly structured array initializer");
      | (<[ [] ]>, _) => Message.fatal_error ("incorrectly structured array initializer");
      | (<[ $x :: $xs ]>, n) => x :: expr_list_flatten_and_count (xs, n - 1)
      | _ => Message.fatal_error ("array initializer must be of form `array <rank> [ [..], .., [..] ]'")
    }

    def dimensions (args, remaining_rank)
    {
      | (_, 0) => []
      | (<[ $head :: $_ ]>, n) =>
        expr_list_length (args) :: dimensions (head, n - 1)
      | _ => Message.fatal_error ("array initializer must be of form `array <rank> [ [..], .., [..] ]'")   
    }
    /* Flattens the initializers and checks that there are the correct number of them */
    def flatten (args, dims)
    {
        | (elem, []) => [elem]
        | (l, h::t) => 
          def flat = expr_list_flatten_and_count (l, h);
          List.FoldLeft (flat, [], fun (i, a) {List.Concat ([a, flatten (i, t)])})
    }

    def dimensions = dimensions (args, rank);
    def lst = flatten (args, dimensions);

    def (typed_initializers, array_type) =
      match (lst) {
        | [] => Util.ice ("empty list of initializers")
        | head :: _ =>
          def typed_head = ty_expr (ctx, head);
          def array_type = type_of (typed_head);
          def type_array_initializers (initializers) {
            match (initializers) {
              | [] => []
              | initializer :: rest =>
                def typed_initializer = ty_expr (ctx, initializer);
                expect_type ("array initializer", typed_initializer, array_type);
                typed_initializer :: type_array_initializers (rest)
            }
          };
          (E_mkarray (type_array_initializers (lst), dimensions), T_array (array_type, rank))
      };

    typed_initializers.expr_ty = array_type;
    typed_initializers.loc = Location_stack.top ();
    def fresh_name = Util.tmpname ("array_initializer");
    def decl = ctx.DefineLocal (fresh_name, 1, D_local_value (), array_type);
    def array_as_let = E_let (decl, typed_initializers, E_local_ref (decl));
    (array_as_let, array_type)
  }

  ty_indexer (ctx : CTX, obj : PT.Expr, args : list <PT.Expr>) : Expr * Type
  {
    def typed_objs =
      match (obj) {
        | <[ base ]>
        | <[ this ]> =>
          [ty_expr (ctx, obj)]
        | _ => 
          make_value_reference (ctx, obj, fallback = true);
      };

    match (typed_objs) {
      | E_property_ref (_, prop) :: _ when is_indexer_property (prop) =>
        def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });
        def args' = List.Map (typed_args, fun (x) { Parm (x) });
        def ex = resolve_overloaded_call (ctx, false, typed_objs, args');
        (ex, type_of (ex))

      | [typed_obj] =>
        match (Tyutil.top_expand (typed_obj.expr_ty)) {
          | T_array (indexer_over_type, rank) =>
            /* indexers over arrays */
            when (args.Length () != rank)
              Message.fatal_error ("wrong number of index parameters");
              
            def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });
            def typed_indexes = List.Map (typed_args, 
                                          fun (index) {
                                              expect_type ("indexer type", index, 
                                                           InternalType.Int32);
                                              index;
                                          });

            (E_array_indexer (indexer_over_type, typed_obj, typed_indexes),
             indexer_over_type)

          | T_app (tc, _) when Option.IsSome (tc.DefaultIndexerName) =>
            /* user-defined indexers */
            def member_name = Option.UnSome (tc.DefaultIndexerName);
            ty_indexer (ctx, <[ $(typed_obj : typed) . $(member_name : dyn) ]>, args)
            
          | _ =>
            Message.fatal_error (sprintf ("indexer applied to non-indexer type %s",
                                          typed_obj.expr_ty.as_string ()))
        }

      | l =>
        Message.error ("expression is ambiguous:");
        def print (ex) { Message.error ("  " + describe_expression (ex)) };
        List.Iter (l, print);
        throw Recovery ()
    }
  }
  
  
  ty_expr_with_no_properties_conversion (ctx : CTX, expr : PT.Expr) : Expr
  {
    def do_typing () : Expr * Type {
      def restart (e : PT.Expr) : Expr * Type {
        def ex = ty_expr (ctx, e);
        (ex, type_of (ex))
      };
      def bind_ty (t : PT.Type) : Type {
        ctx.parent_type.BindType (ctx.tenv, t)
      };

      def orig_ctx = ctx;
      // default to non-tail position (good for most expressions)
      def ctx = ctx.WithInTailPosition (false);

      def expr = MacroRegistry.expand_macro (ctx, expr);
     
      match (expr) {
        // this doesn't make much sense I hope
        | PT.E_let =>
          Message.fatal_error ("let binding not followed by any expression")
        | PT.E_letpat =>
          Message.fatal_error ("letpat binding not followed by any expression")
        | PT.E_letfun =>
          Message.fatal_error ("letfun binding not followed by any expression")

        | PT.E_parm_by_ref
        | PT.E_parm_out =>
          Message.fatal_error ("ref and out parameters are only allowed in function calls")

        | PT.E_lambda (d) =>
          def newname = Util.tmpname ("l");
          d.header.name = PT.SS_string (PT.Name (newname));
          def rf = PT.E_ref (PT.Name (newname));
          def lf = PT.E_letfun ([d]);
          def sq = PT.E_sequence ([lf, rf]);
          rf.loc = expr.loc;
          lf.loc = expr.loc;
          sq.loc = expr.loc;
          restart (sq)

        | PT.E_mkarray (<[ $(r : int) ]>, <[ [] ]> ) => 
          def list_of_zeros (r) {
            | 1 => [ <[ 0 ]> ]
            | _ => <[ 0 ]> :: list_of_zeros (r - 1)
          }
          restart (<[ array (..$(list_of_zeros (r))) ]>)

        | PT.E_mkarray (<[ $(rank : int) ]>, args) =>
          ty_mkarray (ctx, rank, args)

        | PT.E_mkarray (PT.E_spliced, _) => Message.fatal_error ("$ splicing outside of <[ quotation ]>")
        | PT.E_mkarray => Util.ice ("wrongly parsed array initializer")

        | PT.E_empty_array (sizes) =>
          match (sizes) {
            | [size] =>
              def fv = Tyvar.free_variable ();
              def type_of_expr = E_typeof (expr.loc,
                                           InternalType.Type, fv);
              def call_expr =
                <[ System.Array.CreateInstance ($(type_of_expr : typed), $size) ]>;
              def ex = ty_expr (ctx, call_expr);
              def ex_ty = T_array (fv, 1);
              (E_type_conversion (ex, ex_ty, ctx.IsChecked), ex_ty)
            | [size1, size2] =>
              def fv = Tyvar.free_variable ();
              def type_of_expr = E_typeof (expr.loc,
                                           InternalType.Type, fv);
              def call_expr =
                <[ System.Array.CreateInstance ($(type_of_expr : typed), $size1, $size2) ]>;
              def ex = ty_expr (ctx, call_expr);
              def ex_ty = T_array (fv, 2);
              (E_type_conversion (ex, ex_ty, ctx.IsChecked), ex_ty)
            | [size1, size2, size3] =>
              def fv = Tyvar.free_variable ();
              def type_of_expr = E_typeof (expr.loc,
                                           InternalType.Type, fv);
              def call_expr =
                <[ System.Array.CreateInstance ($(type_of_expr : typed), $size1, $size2, $size3) ]>;
              def ex = ty_expr (ctx, call_expr);
              def ex_ty = T_array (fv, 3);
              (E_type_conversion (ex, ex_ty, ctx.IsChecked), ex_ty)
            | sizes =>
              def fv = Tyvar.free_variable ();
              def type_of_expr = E_typeof (expr.loc,
                                           InternalType.Type, fv);
              def sizes_arr = <[ array $(Macros.Lift (sizes)) ]>;
              def call_expr =
                <[ System.Array.CreateInstance ($(type_of_expr : typed), $sizes_arr) ]>;
              def ex = ty_expr (ctx, call_expr);
              def ex_ty = T_array (fv, sizes.Length ());
              (E_type_conversion (ex, ex_ty, ctx.IsChecked), ex_ty)
          }

        | PT.E_indexer (obj, args) =>
          ty_indexer (ctx, obj, args)

        | (PT.E_try_with) as x =>
          def b = ty_expr (ctx, x.body);
          def exn = match (x.exn) {
            | PT.SS_string (e) => e
            | _ =>
            Message.fatal_error ("$ operator used outside quotation <[ ... ]>"
                                 " context")
          };
          def decl = ctx.DefineLocal (exn, D_exn (), bind_ty (x.exn_ty));
          def h = ty_expr (ctx.WithLocal (decl), x.handler);
          match (Tyutil.unify_branches (type_of (h), type_of (b))) {
            | Some (t) =>
              (E_try_with (b, decl, h), t)
            | None =>
              Message.fatal_error (h.loc, "try...with body has type " +
                                          (type_of (b)).as_string () +
                                          " while the handler has type " +
                                          (type_of (h)).as_string ())
          }

        | PT.E_try_finally (e1, e2) =>
          def e1 = ty_expr (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("try...finally handler", e2, T_void ());
          (E_try_finally (e1, e2), type_of (e1))

        | PT.E_typeof (t) =>
          (E_typeof (bind_ty (t)), InternalType.Type)

        | PT.E_type_conversion (e, t) =>
          // FIXME shall we check sth here ?
          def t = bind_ty (t);
          (E_type_conversion (ty_expr (ctx, e), t, ctx.IsChecked), t)

        | PT.E_type_enforcement (e, t) =>
          def ex = ty_expr (ctx, e);
          def t = bind_ty (t);
          expect_type ("type-enforced expression", ex, t);
          (E_type_enforcement (ex, t), t)

        | PT.E_ref ({ idl = n }) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              mark_as_used (x);
              (x, type_of (x))

            | l =>
              Message.error ("name `" + Util.qid_of_list (n) + "' is ambiguous:");
              def print (ex) { Message.error ("  " + describe_expression (ex)) };
              List.Iter (l, print);
              throw Recovery ()
          }

        | PT.E_member (_, PT.SS_string ({idl = mem_name})) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              mark_as_used (x);
              (x, type_of (x))

            | l =>
              Message.error ("reference to member `" + Util.qid_of_list (mem_name) + "' is ambiguous:");
              def print (ex) { Message.error ("  " + describe_expression (ex)) };
              List.Iter (l, print);
              throw Recovery ()
          }

        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_call (fnc, parms) =>
          def ex = ty_call (ctx, orig_ctx.in_tail_position, fnc, parms);
          (ex, type_of (ex))

        | PT.E_assign (e1, e2) =>
          def e1 = ty_expr_with_no_properties_conversion (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          unless (is_lvalue (ctx, e1, need_ref = false))
            Message.error ("assignment to " + describe_expression (e1) +
                           " (which is read-only)");
          convert_setter_property (ctx, e1, e2)

        | PT.E_raise (e) =>
          def ex = ty_expr (ctx, e);
          def exn_ty = InternalType.Exception;
          expect_type ("raised value", ex, exn_ty);
          (E_raise (ex), Tyvar.free_variable ())

        | PT.E_literal (l) =>
          (E_literal (l), ty_literal (ctx, l))

        | PT.E_this =>
          match (ctx.this_ptr_decl) {
            | Some (d) =>
              ctx.Closurise (d);
              (E_local_ref (d), d.ty)
            | None =>
              Message.error ("`this' used outside method");
              (E_literal (L_null ()), Tyvar.free_variable ())
          }

        | PT.E_sequence ([]) =>
          (E_literal (L_void ()), T_void ())

        | PT.E_sequence (l) =>
          def ex = ty_sequence (orig_ctx, l);
          (ex, type_of (ex))

        | PT.E_tuple (l) =>
          def self (e : PT.Expr) : Expr { ty_expr (ctx, e) };
          def parms = List.Map (l, self);
          (E_tuple (parms), T_prod (List.Map (parms, type_of)))

        | (PT.E_match) as m => ty_match (orig_ctx, m)

        | PT.E_typed_expr (tytree) => (tytree, type_of (tytree))

        | PT.E_quoted (parse_element) =>
          def lifted =
            match (parse_element) {
              | PT.SyntaxExpr (e) => Macros.quoted_expr (ctx, e)
              | PT.SyntaxType (e) => Macros.quoted_type (ctx, e)
              | PT.SyntaxPattern (e) => Macros.quoted_pattern (ctx, e)
              | PT.SyntaxCase (e) => Macros.quoted_case (ctx, e)
              | PT.SyntaxCaseGuard (a, b) => Macros.quoted_case_guard (ctx, (a, b))
              | PT.SyntaxFunDecl (e) => Macros.quoted_fundecl (ctx, e)
              | PT.SyntaxFunParm (e) => Macros.quoted_fparam (ctx, e)
              | PT.SyntaxDeclaration (e) => Macros.quoted_member (ctx, e)                
              | PT.SyntaxTType (e) => Macros.quoted_ttype (ctx, e)

              | PT.SyntaxTTycon
              | PT.SyntaxTMethod
              | PT.SyntaxTField
              | PT.SyntaxTEvent
              | PT.SyntaxTProperty
              | PT.SyntaxTFunParm => 
                Util.ice ("strange syntax element appeared in quotation")
            };
          def b = ty_expr (ctx, lifted);
          (b, type_of (b))

        | PT.E_base =>
          match (ctx) {
            | { this_ptr_decl = Some (({ty = T_app (ti, _)}) as d); } =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  def ty = T_app (baseti, Option.UnSome (ti.SuperType (baseti)));
                  ctx.Closurise (d);
                  (E_local_ref (d), ty)

                | None =>
                  Message.fatal_error ("class " + ti.FullName +
                                       " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base' reference used inside invalid type")
          }

        | PT.E_spliced | PT.E_spliced_patt =>
          Message.fatal_error ("$ macro keyword used in regular expression")

        | PT.E_expr_list =>
          Util.ice ("List of expression parameters out of any construct")

        | PT.E_macrocall  =>
          Util.ice ("Macrocalls should have been expanded already")
      }
    };

    def (ret, expr_ty) =
      try {
        Util.locate (expr.loc, do_typing ())
      } catch { _ : Recovery =>
        (E_literal (L_null ()), Tyvar.free_variable ()) };
        
    //Message.debug (expr.loc, "compilied " + describe_expression (ret) + 
    //                    if (ctx.in_tail_position) " [tp]" else "");

    fixup (ret, expr.loc, expr_ty)
  }

  check_unused_values (ctx : CTX) : void
  {
    def warned = Hashtable (50);
    
    def check_value (v : LocalValue) {
      when (!v.ever_used && v.name[0] != '_' && !warned.Contains (v.id)) {
        Message.warning (v.loc, v.kind_as_string () + " `" + v.name + 
                         "' was never used");
        Message.hint_once (v.loc, "replace name with `_' or prefix it like"
                           " `_foo' to avoid the warning");
        warned.Set (v.id, null)
      }
    };

    def mark_broken (v : LocalValue) {
      match (v.kind) {
        | D_local_fun (h, _) =>
          match (h.closure_vars) {
            | [] => ()
            | _ => 
              //Message.debug ("clovars: " + l.ToString () + " v " + v.name);
              // we cannot yet deal with expanding these to loops
              h.usage = FU_used_as_first_class ()
          }
        | _ => ()
      };
    };

    def closurise (v : LocalValue) {
      def in_clo = v.used_in.Fold (fun (_, h : Fun_header, in_clo) {
        if (in_clo) true
        else {
          // check if all functions from h to current_fun are used_just_once
          def find_defining (header : Fun_header) {
            if (header.id == ctx.current_fun.id) false
            else
              match (header.usage) {
                | FU_used_just_once => find_defining (header.decl.parent_fun)
                | _ => true
              }
          }
          find_defining (h)
        }
      }, false);
      //Message.debug ("clos: " + v.name + " " + in_clo.ToString ());
      when (in_clo) {
        match (v.kind) {
          | D_fun_parm (k) when k != ParmKind.Normal =>
            Message.error (v.loc, "cannot store ref/out parameters in" +
                           " closures (parameter `" + v.name + "')");
          | _ => ()
        };
        v.in_closure = true;
        v.parent_fun.closure_vars = v :: v.parent_fun.closure_vars;
      }
    };
    
    def locals = List.Rev (ctx.current_fun.all_locals);
    ctx.current_fun.all_locals = null; // GC it
    
    List.Iter (locals, check_value);
    List.Iter (locals, mark_broken);
    List.Iter (locals, closurise);
  }

  ty_function (ctx : CTX, h : Fun_header, b : Fun_body, toplev : bool) : Fun_body
  {
    def ctx = ctx.WithCurrentFunction (h).WithInTailPosition (true);
    
    def make_parm_decl (p : Fun_parm) {
      Util.locate (p.loc, {
        def (t, kind, is_ref) =
          match (p.ty) {
            | T_ref (t) => (t, ParmKind.Ref, true)
            | T_out (t) => (t, ParmKind.Out, true)
            | t => (t, ParmKind.Normal, false)
          };
        when (kind != ParmKind.Normal && !toplev)
          Message.error ("ref/out parameters are not supported in local methods");
        def d = ctx.DefineLocal (p.name, p.color, D_fun_parm (kind), t);
        d.is_ref = is_ref;
        p.decl = d;
        d
      })
    };

    def ctx = ctx.WithLocals (List.Map (h.parms, make_parm_decl));

    match (b) {
      | FB_parsed_expr (e) =>
        def ctx = ctx.WithTEnv (h.tenv);
        def e' = ty_expr (ctx, e);
        if (type_of (e') >:> h.ret_type) ()
        else
          Message.error (e.loc, "function return type was declared to be " +
                                h.ret_type.as_string() + " while it is " +
                                (type_of (e')).as_string ());
        check_unused_values (ctx);
        FB_typed_expr (e')
      | FB_typed_expr => Util.ice ()
      | FB_compiled_expr => Util.ice ()
      | FB_extern => b
      | FB_abstract => b
    }
  }

  ty_function (ctx : CTX, h : Fun_header, b : PT.Expr) : Expr
  {
    match (ty_function (ctx, h, FB_parsed_expr (b), toplev = false)) {
      | FB_typed_expr (e) => e
      | _ => Util.ice ()
    }
  }

  /**
   * Walk through method body typing it.
   *
   * <remarks>
   *   Typing generally involves rewriting from [Parsetree] to [Typedtree]
   *   namespace. Also entry point for expression is changed from
   *   [FB_parsed_expr] to [FB_typed_expr].
   *
   *   During typing we do few things:
   *
   *   <list>
   *     - Infer types and check if they are correct. Store information
   *       about types in resulting [Typedtree.Expr] objects.
   *     - Define (generate [LocalValue] objects) and later resolve local values.
   *     - Rewrite few redundant source language constructs into
   *       unambiguous equivalents from [Typedtree].
   *     - Bind type expressions occurring in source code.
   *     - Mark which values should go into closures.
   *   </list>
   *
   *   This is however all done in parallel to improve efficiency.
   *
   *   Documentation FIXME: overloading resolution, CTX type, more
   *   about closures, binding method implement list.
   * </remarks>
   */
  internal TypeMethod (m : NemerleMethod) : void
  {
    def ti = (m.DeclaringType :> TypeBuilder);

    def (in_ctor, is_method) =
      match (m.GetFunKind ()) {
        | FK_ctor => (true, true)
        | FK_method | FK_bound_method => (false, true)
        | _ => (false, false)
      };

    // Message.debug ("type " + m.GetName () + if (is_method) " method" else "");

    def ctx = TypingContext 
                  (in_ctor = in_ctor,
                   this_ptr_decl =
                     if (is_method)
                       Some (LocalValue ("_N_this", 0, D_closurised_this_ptr (),
                                         ti.GetMemType (), m.GetHeader ()))
                     else None (),
                   env = ti.env,
                   tenv = m.GetHeader ().tenv,
                   current_fun = m.GetHeader (),
                   locals = NemerleMap (),
                   parent_type = ti,
                   in_tail_position = true,
                   is_checked = true);
    match (ctx.this_ptr_decl) {
      | Some (decl) => 
        decl.parent_fun.all_locals = decl :: decl.parent_fun.all_locals
      | None => ()
    };
    try {
      m.fun_body = ty_function (ctx, m.GetHeader (), m.fun_body, toplev = true);
      
      when (Flags.dump_typed_tree) {
        match (m.fun_body) {
          | FB_typed_expr (expr) =>
            Message.debug (expr.loc,
                           m.DeclaringType.FullName + "." +
                           m.Name + " -> " +
                           PrettyPrint.SprintTyType (m.GetHeader ().ret_type) + ":" +
                           PrettyPrint.SprintTyExpr (Some (ctx), expr) + "\n");
          | _ => ()
        }
      }
    } catch { _ : Recovery => () }
  }
}

} // end ns
