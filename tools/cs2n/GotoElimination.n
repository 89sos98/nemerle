// Copyright (c) 2003-2005 The University of Wroclaw.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. The name of the University may not be used to endorse or promote
//       products derived from this software without specific prior
//       written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
// NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

#if GOTO_ELIMINATION

using Nemerle.Collections;

namespace Nemerle.CSharp
{
    public partial variant STree
    {
	public this ()
	{
	    depth_table = Hashtable ();
	}
	
	//FIXME: change internal -> private later
	internal eliminate_gotos (/*depth : int*/) : STree
	{
	    def get_labels (lst , acc )
	    {
		match(lst)
		{
		    | [] => acc
		    | Statement("LABEL", Tok(id) :: _) :: tail => 
		    		    
			get_labels (tail , ExtendedToken.getTextOnly (id) :: acc)
		    | _ :: tail=>
			get_labels (tail , acc)
		}
	    }

	    match(this)
	    {
		| Statement ("BLOCK", xs) as block_st => 
		    def (_, sts ,_) = cut_off_braces (xs);
		    
		    def sts_eliminated = List.Map (sts , fun (x) {x.eliminate_gotos ();} );
		    def labels = get_labels (sts_eliminated , []);

		    System.Console.WriteLine(labels);
		    
		    block_st		    

		| x => x
	    }	    
	}
	
	internal set_depth_for_labels (depth : int) : void
	{
	    match(this)
	    {
		| Statement ("LABEL", [Tok(ident), _ , st ] ) =>
		    depth_table.Add(ExtendedToken.getTextOnly (ident), depth);
		    st.set_depth_for_labels (depth);
		    
		    System.Console.WriteLine(ExtendedToken.getTextOnly (ident) + " " + depth.ToString ());
		    
		| Statement ( name , children) =>
		    if(name != "BLOCK")
			foreach(child in children)
			    child.set_depth_for_labels (depth + 1);
		    else
			foreach(child in children)
			    child.set_depth_for_labels (depth);
			
		| _ => ()
	    }
	}

	internal transform_gotos_to_conditionals () : STree
	{
	    match(this)
	    {
		| Statement ("WHEN",[when_,lp,cond,rp,maybe_goto]) as when_st=>
		    if(maybe_goto matches Statement ("GOTO",_))
			when_st
		    else
			Statement ("WHEN",[when_,lp,cond,rp,maybe_goto.transform_gotos_to_conditionals ()])
			
		| Statement ("GOTO", goto :: _ ) as goto_st=>
		    
		    def ws = get_first_whitespace (goto);

		    Statement("WHEN", [ Tok(ExtendedToken (ws,"when")), TokS(" ("), TokS(" true ") , TokS (")"), goto_st])

		| Statement ( name , children) =>
    
		    def map (lst : list [STree] )
		    {
			| [] => []
			| head :: tail => 
			    head.transform_gotos_to_conditionals () :: map(tail)
		    }
    
		    Statement (name , map (children));

		| x => x
		    
	    }
	}

	internal divide_block_into_when_sections () : list [STree]
	{
	    def make_when_section (statements) : STree
	    {
		def whitespaces = get_first_whitespace (statements);
		def block = Statement("BLOCK", Tok(ExtendedToken(whitespaces,"{")) :: statements 
					+ [Tok(ExtendedToken(whitespaces , "}"))]);
		Statement("WHEN",Tok(ExtendedToken(whitespaces,"when")) ::
				 TokS("(") :: TokS("true") :: TokS(")") :: [block])
	    }
	    
	    def walk (statements, acc1 : list[STree], acc2 : list[STree]) : list [STree]
	    {
		match(statements)
		{
		    | [] => 
			if(acc1 matches [])
			    List.Rev ( acc2 )
			else
			    List.Rev ( make_when_section (List.Rev (acc1)) :: acc2 )
		    | (Statement("LABEL", _ ) as goto_related_statement) :: tail 
		    | (Statement("GOTO", _ ) as goto_related_statement) :: tail =>
			def when1 = 
			if(acc1 matches [])
			    []
			else
			    [make_when_section (List.Rev (acc1) )];

			def when2 = make_when_section ([goto_related_statement]);

			walk (tail, [] , when2 :: when1 + acc2) 
			
		    | head :: tail =>
			walk(tail , head :: acc1 , acc2)
		}
	    }

	    def (_,sts,_) = 
	    match(this)
	    {
		| Statement("BLOCK",xs)	=> cut_off_braces (xs);
		| _ => assert (false);
	    }
	    def transformed = List.Map(sts, fun(x) {x.transform_gotos_to_conditionals ();} );

	    walk ( transformed, [] , []) 
	}		

	private new_goto_symbol () : string
        {
            new_symbol ("_return_")
        }

	private depth_table : Hashtable [string , int];
    }
}

#endif
