(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

  class PrettyPrintMacro implements IMacro {

    public static PrintExpr (expr : Expr, empty : string) : void 
    {
      match (expr) {
        | <[ $(id : var) ]> => 
          printf ("%s", id)

        | <[ $obj . $mem ]> => 
          match (mem) {
            | SS_string (mem) =>
              PrintExpr (obj, empty); printf (".%s", mem)
            | _ => Util.ice ("spliced in member")
          }
                    
        | <[ $func (.. $params) ]> =>
          def print_params (pars : list (Parm)) {
            match (pars) {
              | [] => ()
              | [x] =>
                PrintExpr (x.expr, empty + "  ")  
              | x :: xs =>
                PrintExpr (x.expr, empty + "  "); printf (", ");
                print_params (xs)
            }
          };

          PrintExpr (func, empty); printf (" (");
          print_params (params); printf (")");

        | <[ $target <- $source ]> =>
          PrintExpr (target, empty); printf (" <- ");
          PrintExpr (source, empty);

        | <[ def $name = $val ]> =>
          match (name) {
            | SS_string (nam) =>
              printf ("def %s = ", nam);
              PrintExpr (val, empty);
            | _ => Util.ice ("spliced in let")
          }

        | <[ mutable $name <- $val ]> =>
          match (name) {
            | SS_string (nam) =>
              printf ("mutable %s = ", nam);
              PrintExpr (val, empty);
            | _ => Util.ice ("spliced in mut")
          }

        | <[ def (.. $elems) = $val ]> =>
          printf ("def ("); 
          List.iter (fun (x) { PrintPattern (x); printf ("; ") }, elems);
          printf (") = ");
          PrintExpr (val, empty);

        | <[ match ($expr) {.. $cases } ]> =>
          def print_case (c : Match_case) {
            def print_guard (g : Pattern * option (Expr)) {
              match (g) {
                | <[ caseguard: $pat when $e ]> =>
                  printf ("\n%s| ", empty + "  ");
                  PrintPattern (pat);
                  printf (" when ");
                  PrintExpr (e, empty + "    ")
                | <[ caseguard: $pat ]> =>
                  printf ("\n%s| pat", empty + "  ")
              }
            };

            def <[ case: | ..$guards => $expr ]> = c;
            List.iter (print_guard, guards);
            printf (" => \n%s", empty + "    ");
            PrintExpr (expr, empty + "    ")
          };

          printf ("match ("); PrintExpr (expr, empty); printf (") {");
          List.iter (print_case, cases)

        | <[ raise $exc ]> =>
          printf ("raise "); PrintExpr (exc, empty);

        | <[ try $body with { $exn : $exn_ty => $handler } ]> => 
          printf ("try\n%s  ", empty);
          PrintExpr (body, empty + "  ");
          printf ("\n%swith {\n%s", empty, empty + "  ");
          match (exn) {
            | SS_string (exc) =>
              printf ("%s : ", exc);
              PrintType (exn_ty); printf ("=>\n%s", empty + "    ");
              PrintExpr (handler, empty + "    ")
            | _ => Util.ice ("spliced in trywith")
          }

        | <[ try $body finally $handler ]> =>
          printf ("try\n%s  ", empty);
          PrintExpr (body, empty + "  ");
          printf ("\n%sfinally\n%s  ", empty, empty);
          PrintExpr (handler, empty + "  ")

        | <[ () ]> => 
          printf ("()")

        | <[ null ]> => 
          printf ("null")

        | <[ $(val : int) ]> =>
          printf ("%d", val)

        | <[ $(val : string) ]> =>
          printf ("\"%s\"", val)

        | <[ $(val : float) ]> =>
          printf ("float")

        | <[ $(val : bool) ]> =>
          if (val) printf ("true") else printf ("false")

        | <[ $(val : char) ]> =>
          printf ("%c", val);

        | <[ this ]> =>
          printf ("this")

        | <[ base ]> => 
          printf ("base")

        | <[ typeof ($t) ]> =>
          printf ("typeof ()")

        | <[ ( $expr :> $ty ) ]> =>
          printf ("("); PrintExpr (expr, empty); printf (" :> ");
          PrintType (ty); printf (")")

        | <[ ( $expr : $ty ) ]> =>
          printf ("("); PrintExpr (expr, empty); printf (" : ");
          PrintType (ty); printf (")")

        | <[ {.. $seq } ]> =>
          printf ("{");
          List.iter (fun (x) { printf ("\n%s", empty + "  "); 
                               PrintExpr (x, empty + "  "); 
                               printf (";"); }, seq);
          printf ("\n%s}", empty)

        | <[ (.. $args) ]> =>
          printf ("(");
          List.iter (fun (x) { printf (", "); PrintExpr (x, empty) }, args);
          printf (")")

        | <[ mkarray [.. $args] ]> =>
          printf ("mkarray [");
          List.iter (fun (x) { printf ("; "); PrintExpr (x, empty) }, args);
          printf ("]")

        | <[ $obj [.. $args] ]> =>
          PrintExpr (obj, empty);
          printf ("[");
          List.iter (fun (x) { printf ("; "); PrintExpr (x, empty) }, args);
          printf ("]")

        // FIXME: lambda, funs

        | _ => printf ("other")
      }
    }

    public static PrintPattern (patt : Pattern) : void
    {
      match (patt) {
        | <[ pattern: _ ]> =>
          printf ("_")

        | <[ pattern: $(name : var) ]> =>
          printf ("%s", name)

        | <[ pattern: ($pat) as $name ]> => 
          printf ("("); PrintPattern (pat); 
          match (name) {
            | SS_string (name) =>
              printf (") as %s", name)
            | _ =>
              Util.ice ("spliced in as")
          }

        | <[ pattern: (.. $args) ]> =>
          printf ("(");
          List.iter (fun (x) { PrintPattern (x); printf (", ") }, args);
          printf (")")
        
        | <[ pattern: {.. $args } ]> =>
          def print_named_pattern (patt : string * Pattern) : void
            {
              def (name, pat) = patt;
              printf ("%s = ", name); PrintPattern (pat);
              printf ("; ")
            };
          printf ("{");
          List.iter (print_named_pattern, args);
          printf ("}")

        | <[ pattern: $name (.. []) ]> =>
          match (name) {
            | SS_string (name) =>
              printf ("%s", name)
            | _ => Util.ice ("spliced in c ()")
          }

        | <[ pattern: $name (.. $args) ]> =>
          match (name) {
            | SS_string (name) =>
              printf ("%s (", name);
              List.iter (fun (x) { PrintPattern (x); printf (", ") }, args);
              printf (")")
            | _ => Util.ice ("spliced in c (..)")
          }

        | <[ pattern: $name {.. $args} ]> =>
          match (name) {
            | SS_string (name) =>
               printf ("%s {", name);
               def print_named_pattern (patt : string * Pattern) : void
                 {
                   def (name, pat) = patt;
                   printf ("%s = ", name); PrintPattern (pat);
                   printf ("; ")
                 };
               List.iter (print_named_pattern, args);
               printf ("}")
            | _ => Util.ice ("spliced in c {..}")
          }

        | <[ pattern: $(val : int) ]> =>
          printf ("%d", val)

        | <[ pattern: $(val : string) ]> =>
          printf ("\"%s\"", val)

        | <[ pattern: $(val : bool) ]> =>
          if (val) printf ("true") else printf ("false")

        | <[ pattern: $(val : float) ]> =>
          printf ("float")

        | <[ pattern: $(val : char) ]> =>
          printf ("%c", val)

        | <[ pattern: () ]> =>
          printf ("()")

        | <[ pattern: null ]> =>
          printf ("null")

//        | <[ pattern: $name _ ]> =>
        | _ => printf ("other")
      }
    }

    public static PrintType (ty : Type) : void 
    {
      match (ty) {
        | <[ type: $tycon (.. $args) ]> =>
          match (tycon) {
            | SS_string (tycon) =>
              printf ("%s", tycon);
              def loop (l) {
                match (l) {
                  | [x] => PrintType (x)
                  | x::xs => PrintType (x); printf (" * "); loop (xs)
                  | [] => Util.ice()
                }
              };
              match (args) {
                | [] => ()
                | _ => printf (" ("); loop (args); printf (")");
              }
            | _ => Util.ice ("spliced in tycon (..)")
          }

        | <[ type: $(name : var) ]> =>
          printf ("%s", name);

        | <[ type: ref $ty ]> =>
          printf ("ref "); PrintType (ty);

        | <[ type: out $ty ]> =>
          printf ("out "); PrintType (ty);

        | <[ type: $from -> $to ]> =>
          PrintType (from); printf (" -> "); PrintType (to);

        | <[ type: void ]> =>
          printf ("void");

        | <[ type: .. $args ]> =>
          List.iter (fun (x) { PrintType (x); printf (" * ") }, args)

        | <[ type: array ($ty) ]> =>
          printf ("array ("); PrintType (ty); printf (")")

        | _ => printf ("other")
      }
    }

    public Run (ctx : Nemerle.Compiler.Tyexpr.CTX, parm : list(Parm)) : Expr 
      implements IMacro.Run 
    { 

      match (Extensions.get_params (parm)) {
	| [exp] =>
          PrintExpr (exp, "");
        | [exp; <[ $(expand : bool) ]> ] =>
          if (expand) 
            PrintExpr (MacroRegistry.expand_macro (ctx, exp), "")
          else
            PrintExpr (exp, "");
       
        | _ =>
          Message.fatal_error ("pretty_print macro suppose to take one exprsion")
      };
      printf ("\n");
      <[ () ]>
    }
    
    GetName () : string implements IMacro.GetName { "pretty_print_expr" }

    public this () {}
  }


module Macros {

  (** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => <[ [] ]>
        | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
      }
    }

  (** this method treats expression as syntax tree of list containing 
      expressions, which are arguments of variable argument constructs
      (sequence, tuple, etc.)
      it also apply given function to each argument
   *)
  decompose_list (f : Expr -> Expr, ex : Expr) : Expr
    {
      match (ex) {
        | <[ $h :: $t ]> =>
          <[ $(f (h)) :: $(decompose_list (f, t)) ]>
        | <[ [] ]> => ex
        | E_spliced (e) => e
        | E_spliced_patt (e) => ex
        | _ => 
          print_tree(ex, "");
          Message.fatal_error ("Bad expression in quoted variable arguments list: ")
          
      }
    }

  decompose_pattern_list (f : Pattern -> Expr, pa : Pattern) : Expr
    {
      match (pa) {
        | <[ pattern: Cons ($h, $t) ]> => 
          <[ $(f (h)) :: $(decompose_pattern_list (f, t)) ]>
        | <[ pattern: [] ]> => <[ [] ]>
        | P_spliced (e) => e
        | _ => Message.error ("Bad pattern in quoted variable arguments list: "); 
          print_pattern(pa, ""); f (pa)
      }
    }

  decompose_type_list (f : Type -> Expr, ty : Type) : Expr
    {
      match (ty) {
        | T_prod (types) => 
          make_quoted_list (f, types)
        | T_spliced (e) => e
        | _ => Message.error ("Bad type in quoted variable arguments list: "); 
          f (ty)
      }
    }

  quoted_sstring (st : Splicable_string) : Expr
    { match (st) {
        | SS_string (str) => 
//        | <[ $(str : name) ]> =>
          <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($(str : string)) ]>
        | SS_spliced_expr (e) => e
      }
    }

  quoted_location (loc : Location) : Expr
    {
      <[ Nemerle.Compiler.Location ($(loc.file : string), $(loc.line : int),
 	                            $(loc.column : int)) ]>
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  public quoted_type (t : Type) : Expr
  {
    match (t) {
      | <[ type: $tycon (.. $args) ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)),
                                                 $(decompose_type_list (quoted_type, ar))) ]>
	  | _ =>
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)), 
                                                 $(make_quoted_list (quoted_type, args))) ]>
        }

      | <[ type: $(name : var) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_var ($(name : string)) ]>
        
      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ty))) ]>
	
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ty))) ]>
	
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (from)),
                                             $(quoted_type (to))) ]>
	
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Parsetree.T_void () ]>
	
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quoted_type, args))) ]>

      | <[ type: array ($ty) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_array ($(quoted_type (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.T_var ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer =>
        <[ Nemerle.Compiler.Parsetree.T_infer () ]>

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(decompose_type_list (quoted_type, ar))) ]>
    }	
  }

  /// create construction tree of given call parameter
  public quoted_param (p : Parm) : Expr
    {
//      match (p) {
//        | <[ parameter: $exp = 
      <[ Nemerle.Compiler.Parsetree.Parm ($(p.is_ref : bool), 
                                          $(quoted_expr (p.expr)), 
                                          $(p.name : string)) ]>
    }


  public quoted_case_guard (pair : Pattern * option (Expr)) : Expr
    {
      match (pair) {
        | <[ caseguard: $pat when $gu ]> => 
          <[ ($(quoted_pattern (pat)), Some ($(quoted_expr (gu)))) ]>
        | <[ caseguard: $pat ]> =>
          <[ ($(quoted_pattern (pat)), None ()) ]>
      }
    }

  public quoted_case (cas : Match_case) : Expr
    {
      def <[ case: | ..$guards => $expr ]> = cas;

      match (guards) {
        | [(P_patt_list (args), None)] =>
          <[ Nemerle.Compiler.Parsetree.Match_case ($(decompose_pattern_list (quoted_pattern,
             args)), $(quoted_expr (expr))) ]>
        | _ =>
          <[ Nemerle.Compiler.Parsetree.Match_case ($(make_quoted_list (quoted_case_guard, 
            guards)), $(quoted_expr (expr))) ]>
      }
    }

  public quoted_expr (expr : Expr) : Expr 
    {
      def quoted_funheader ( h : Fun_header ) : Expr
        {
          def quoted_fparam (p : Fun_parm) : Expr
            {
    	      <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_location (p.loc)),
                                                      $(p.name : string),
	                                              $(quoted_type (p.ty))) ]>
  	    };
            
          <[ Nemerle.Compiler.Parsetree.Fun_header ($(quoted_location (h.loc)),
                                                    $(h.name : string),
	    	      				    $(quoted_type (h.ret_type)),
                                                    $(make_quoted_list (quoted_fparam, h.parms))) ]>
        };
        
      def quoted_fundecl (d : Function_decl) : Expr
        {
          <[ Nemerle.Compiler.Parsetree.Function_decl ($(quoted_funheader (d.header)),
 	                                               $(quoted_expr (d.body))) ]>
	};

      match (expr) {
        | <[ $(id : var) ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_ref ($(id : string)) ]>

        | <[ $obj . $mem ]> => 
          <[ Nemerle.Compiler.Parsetree.E_member ($(quoted_expr (obj)),
                                                  $(quoted_sstring (mem))) ]>

        | <[ $func (.. $params) ]> =>
          match (params) {
            | [ { expr = E_expr_list (args) }] =>
              <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)),
                                                    $(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)), 
                                                    $(make_quoted_list (quoted_param, params))) ]>
          }

        | <[ $target <- $source ]> =>
          <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (target)), 
                                                  $(quoted_expr (source))) ]>

        | <[ def $name = $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(false : bool), 
                                               $(quoted_sstring (name)), 
                                               $(quoted_expr (val))) ]>

        | <[ mutable $name <- $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(true : bool), 
                                               $(quoted_sstring (name)), 
                                               $(quoted_expr (val))) ]>

	| <[ def (.. $elems) = $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (P_tuple (elems))), 
                                                  $(quoted_expr (val))) ]>

        | <[ def .. $funs ]> =>
          match (funs) {
            | [(_, E_expr_list (args))] =>
              <[ Nemerle.Compiler.Parsetree.E_letfun ($(decompose_list (quoted_expr, args))) ]>
            | _ =>
  	      <[ Nemerle.Compiler.Parsetree.E_letfun ($(make_quoted_list (quoted_fundecl, funs))) ]>
          }

//        | <[ fun ($args) : $ty { $body }
	| E_lambda (decl) =>
	  <[ Nemerle.Compiler.Parsetree.E_lambda ($(quoted_fundecl (decl))) ]>

        | <[ match ($expr) {.. $cases } ]> =>
          match (cases) {
            | [cas] when match (cas.patterns) { | [] => true | _ => false } =>
              match (cas.body) {
                | E_expr_list (e) =>
   	          <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                       $(decompose_list (quoted_expr, e))) ]>
                | _ =>
                  Util.ice ("parser generated strange match_case")
              }
            | _ =>
   	      <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                                                     $(make_quoted_list (quoted_case, cases))) ]>
          }

	| <[ raise $exc ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (exc))) ]>

	| <[ try $body with { $exn : $exn_ty => $handler } ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_try_with ($(quoted_expr (body)), 
                                                    $(quoted_sstring (exn)),
                                                    $(quoted_type (exn_ty)), 
                                                    $(quoted_expr (handler))) ]>

        | <[ try $body finally $handler ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (body)), 
                                                       $(quoted_expr (handler))) ]>

        | <[ () ]> => 
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ null ]> => 
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_null ()) ]>

        | <[ $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ $(val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

        | <[ $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ this ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_this () ]>

        | <[ base ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_base () ]>

        | <[ typeof ($t) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_typeof ($(quoted_type (t))) ]>

        | <[ ( $expr :> $ty ) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (expr)),
	                                                   $(quoted_type (ty))) ]>

        | <[ ( $expr : $ty ) ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (expr)),
	                                                    $(quoted_type (ty))) ]>

	| <[ {.. $seq } ]> =>
          match (seq) {
            | [E_expr_list (seq)] =>
              <[ Nemerle.Compiler.Parsetree.E_sequence ($(decompose_list (quoted_expr, seq))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_sequence ($(make_quoted_list (quoted_expr, seq))) ]>
          }

	| <[ (.. $args) ]> =>
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_tuple ($(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quoted_expr, args))) ]>
          }

    	| <[ mkarray [.. $args] ]> =>
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_mkarray ($(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_mkarray ($(make_quoted_list (quoted_expr, args))) ]>
          }
	
        | <[ $obj [.. $args] ]> =>  
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_indexer ($(quoted_expr (obj)),
                                                       $(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_indexer ($(quoted_expr (obj)),
                                                       $(make_quoted_list (quoted_expr, args))) ]>
          }

        // rest of constructs must be in not quoted form, because they define
        // internal data structures
	| E_spliced (e) => e

        | E_spliced_patt => expr

        | E_spliced_literal (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.E_ref ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($val)) ]>
            | "name" => 
              <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($val) ]>
            | "typed" => 
              <[ Nemerle.Compiler.Parsetree.E_typed_expr ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in expression")
          }

	| E_quoted => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_typed_expr (e) => 
	  Message.fatal_error ("You've got beer from me for generating such a code...");
        | E_expr_list =>
          // print location
	  Message.debug ("list of expression parameters outside of any construct");
          Util.ice ("List of expression parameters outside of any construct")
        | E_letpat =>
          Util.ice ("Bad construction of E_letpat")
      };
    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction
      tree 
   *)	  
  public quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | <[ pattern: _ ]> => <[ Nemerle.Compiler.Parsetree.P_underscore () ]>

        | <[ pattern: $(name : var) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_variable ($(name : string)) ]>

        | <[ pattern: ($pat) as $name ]> => 
          <[ Nemerle.Compiler.Parsetree.P_as ($(quoted_pattern (pat)), 
                                              $(quoted_sstring (name))) ]>

        | <[ pattern: (.. $args) ]> =>
          match (args) {
            | [P_patt_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(decompose_pattern_list (quoted_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(make_quoted_list (quoted_pattern, args))) ]>
          }
        
        | <[ pattern: {.. $args } ]> =>
          def quoted_named_pattern (patt : string * Pattern) : Expr
            {
              def (name, pat) = patt;
              <[ ($(name : string), $(quoted_pattern (pat))) ]>
            };
             
          match (args) {
            | [(_, P_patt_list (args))] =>
              <[ Nemerle.Compiler.Parsetree.P_record 
                   ($(decompose_pattern_list (quoted_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_record
                   ($(make_quoted_list (quoted_named_pattern, args))) ]>
          }

        | <[ pattern: $name (.. []) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                         Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        | <[ pattern: $name (.. $args) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (P_tuple (args)))) ]>

        | <[ pattern: $name {.. $args} ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (P_record (args)))) ]>

        | <[ pattern: $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ pattern: $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ pattern: $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ pattern: $(val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

        | <[ pattern: $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ pattern: () ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ pattern: null ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_null ()) ]>

//        | <[ pattern: $name _ ]> =>
        | P_cons (name, P_underscore) =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
             Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        // rest of constructs must be in not quoted form, because they define
        // internal data structures
	| P_spliced (e) => e

        | P_spliced_literal (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.P_variable ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($val)) ]>
            | "name" => 
              <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in pattern")
          }

        | P_quoted =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_patt_list (args) =>
          decompose_pattern_list (quoted_pattern, args)
//          Util.ice ("Variable pattern arguments list appears outside of proper construct")
        | P_cons (_, p) =>
          print_string("name "); print_pattern(p, "");
          Util.ice ("Bad constructed P_cons")
      } 
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  public expr_to_pattern (exp : Expr) : Pattern 
    {
      def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
        match (pars) {
          | [] => 
            match (acc) {
	      | [] => P_underscore ()
	      | _ => P_tuple (List.rev (acc))
            }
          | x::xs => convert_params (xs, expr_to_pattern (x.expr) :: acc)
        }
      };

      def flat_member (obj) {
        def collect_member (obj : Expr, acc : list(string)) : list (string) {
          match (obj) {
            | E_ref (id) => id :: acc
            | E_member (head, SS_string (id)) => collect_member (head, id :: acc)
            | _ => Util.ice ("Corrupted member while flatting member expr -> pattern")
          }
        };
        match (collect_member (obj, [])) {
          | x :: xs =>
            def inter = List.fold_left (
              fun (sb : System.Text.StringBuilder, s : string) : System.Text.StringBuilder 
                { sb.Append ("." + s) }, 
              System.Text.StringBuilder (x), xs);
            inter.ToString ()
          | _ =>
            Util.ice ("collect_member returned empty list")
        }
      };

      match (exp) {
        | <[ $(id : var) ]> => P_cons (SS_string (id), P_underscore ())
        | <[ $constr (.. $pars) ]> =>
          def con = flat_member (constr);
          match (Env.LookupExactType (con)) {
            | Some (tcon) =>
              match (tcon.GetTydecl ()) {
                | Typedtree.TD_variant_option =>
                  P_cons (SS_string (con), convert_params (pars, []))                  
                | Typedtree.TD_class  =>
                  // we lose informations about constructor here, but as it's 
                  // compiler internal computation we can ignore it
                  convert_params (pars, [])
                | _ =>
                  Util.ice ("expression generated from quotation has nor variant"
                            + " neither class constructor")
              }
            | None =>
              Util.ice ("expression generated from quotation has broken constructor")
          }

        | <[ (..$elems) ]> => <[ pattern: (..$(List.map (expr_to_pattern, elems))) ]>

        | E_literal (lit) => P_literal (lit)
          
	| E_spliced_patt (p) => p
        
        | _ => 
          print_tree (exp, "");
          Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
      }
    }

  // DEBUG SECTION

  public print_tree (exp : Expr, empty : string) : void
    {
      def convert_params (pars : list (Parm)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_tree (x.expr, empty + "  "); convert_params (xs )
        }
      };

      print_string (empty);

      def print_literal (lit : Literal ) : void
        {
	  match (lit) {
	    | L_string (s) => print_string (s)
            | L_int (i) => print_string (string_of_int (i))
	    | _ => print_string ("some literal")
          }
        };

      match (exp) {
        | E_ref (id) => print_string ("E_ref ("); print_string (id); print_endline (")")
        | E_call (E_ref (constr), params) => 
          print_string ("E_call (E_ref ("); print_string (constr); print_endline ("),");
          convert_params (params);
          print_string (empty);
	  print_endline (")")
        | E_call (constr, params) => 
          printf("E_call (\n"); print_tree(constr, empty + "  "); convert_params(params);
          printf("%s)\n", empty)
        | E_literal (lit) => print_string ("E_literal ("); print_literal (lit); print_endline (")")
	| E_sequence (seq) =>
	  print_endline("E_sequence ("); 
	  def pr (e : Expr ) : void { print_tree (e, empty + "  "); };
	  List.iter (pr, seq);
	  print_endline(empty + ")")

	| E_tuple (args) =>
	  print_endline ("tuple")
        | E_member (o, SS_string (x)) =>
          printf("E_member (\n"); print_tree (o, empty + "  ");
	  print_endline (empty + "  " + x + ")");
        | E_member (o, _) =>
	  print_endline ("member spliced");
          print_tree (o, empty)
    	| E_assign => 
	  print_endline ("assign ")
    	| E_let  => 
	  print_endline ("let ")
    	| E_letpat  => 
	  print_endline ("letpat ")
    	| E_letfun => 
	  print_endline ("letfun ")
    	| E_lambda => 
	  print_endline ("lambda ")
    	| E_match  => 
	  print_endline ("match ")
    	| E_raise  => 
	  print_endline ("raise ")
    	| E_try_with => 
	  print_endline ("Bad constructed quoted expression in print - try_with ")
    	| E_try_finally => 
	  print_endline ("Bad constructed quoted expression in print - try_finally ")
    	| E_this => 
	  print_endline ("Bad constructed quoted expression in print - this ")
    	| E_typeof => 
	  print_endline ("Bad constructed quoted expression in print - typeof ")
    	| E_type_conversion => 
	  print_endline ("Bad constructed quoted expression in print - type_conversion ")
    	| E_type_enforcement => 
	  print_endline ("Bad constructed quoted expression in print - type_enforc ")
    	| E_quoted => 
	  print_endline ("Bad constructed quoted expression in print - quoted ")
    	| E_spliced => 
	  print_endline ("Bad constructed quoted expression in print - spliced ")
    	| E_mkarray => 
	  print_endline ("Bad constructed quoted expression in print - mkarray ")
    	| E_indexer => 
	  print_endline ("Bad constructed quoted expression in print - indexer ")
    	| E_base => 
	  print_endline ("Bad constructed quoted expression in print - base ")
    	| E_spliced_patt => 
	  print_endline ("Bad constructed quoted expression in print - spliced_patt ")
    	| E_expr_list => 
	  print_endline ("Bad constructed quoted expression in print - expr_list ")
        | _ =>
          print_endline ("other")
      }
    }

  public print_pattern (pat : Pattern, empty : string) : void
    {
      def convert_params (pars : list (Pattern)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_pattern (x, empty + "  "); convert_params (xs)
        }
      };

      def print_args (args : list (string * Pattern)) : void {
	match (args) {
	  | [] => ()
	  | x::xs => 
            def (name, pat) = x;
            print_string (empty + "  "); print_string (name); print_endline(" = "); 
            print_pattern (pat, empty + "    "); print_args (xs)
 	}  
      };

      print_string (empty);

      match (pat) {
        | P_cons (SS_string (id), arg) => print_string ("P_cons ("); print_string (id); 
          print_endline (","); print_pattern (arg, empty + "  "); print_string (empty); 
          print_endline (")")
        | P_underscore => print_endline ("P_under")
        | P_record (args) => 
	   print_endline ("P_record (");
	   print_args (args); print_string (empty); print_endline (")")
        | P_tuple (args) => print_endline ("P_tuple ("); convert_params (args); 
            print_string (empty); print_endline (")")
        | _ => 
	   print_endline ("other")
      }
    }

}
} // end ns
