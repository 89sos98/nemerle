(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open System;
open System.IO;
open System.Text;
open System.Collections;

namespace Nemerle.Compiler {

type LexerInterface = extern "yyParser.yyInput";

 class Token {
  public static mutable NUMBER_LITERAL : int;
  public static mutable CHAR_LITERAL : int;
  public static mutable ID : int;
  public static mutable TYVAR : int;
  public static mutable STRING_LITERAL : int;
  public static mutable OP1 : int;
  public static mutable OP2 : int;
  public static mutable OP3 : int;
  public static mutable OP4 : int;
  public static mutable OP5 : int;
  public static mutable OP6 : int;
  public static mutable OP7 : int;
  public static mutable KW_ABSTRACT : int;
  public static mutable KW_CONST : int;
  public static mutable KW_EXTERN : int;
  public static mutable KW_INTERNAL : int;
  public static mutable KW_NEW : int;
  public static mutable KW_PRIVATE : int;
  public static mutable KW_PROTECTED : int;
  public static mutable KW_SEALED : int;
  public static mutable KW_VOLATILE : int;
  public static mutable KW_NAMESPACE : int;
  public static mutable KW_BASE : int;
  public static mutable KW_CLASS : int;
  public static mutable KW_ENUM : int;
  public static mutable KW_EXTENDS : int;
  public static mutable KW_FINALLY : int;
  public static mutable KW_IN : int;
  public static mutable KW_NULL : int;
  public static mutable KW_OUT : int;
  public static mutable KW_PUBLIC : int;
  public static mutable KW_RAISE : int;
  public static mutable KW_REF : int;
  public static mutable KW_STRUCT : int;
  public static mutable KW_THIS : int;
  public static mutable KW_VARIANT : int;
  public static mutable KW_INTERFACE : int;
  public static mutable KW_IMPLEMENTS : int;
  public static mutable KW_WHERE : int;
  public static mutable KW_TYPE : int;
  public static mutable KW_LET : int;
  public static mutable KW_FUN : int;
  public static mutable KW_AND : int;
  public static mutable KW_TYMATCH : int;
  public static mutable KW_WITH : int;
  public static mutable KW_TRY : int;
  public static mutable KW_OPEN : int;
  public static mutable KW_VOID : int;
  public static mutable KW_IF : int;
  public static mutable KW_THEN : int;
  public static mutable KW_ELSE : int;
  public static mutable KW_AS : int;
  public static mutable KW_MATCH : int;
  public static mutable KW_STATIC : int;
  public static mutable KW_MUTABLE : int;
  public static mutable KW_DEF : int;
  public static mutable KW_MODULE : int;
  public static mutable KW_ENSURE : int;
  public static mutable KW_REQUIRE : int;
  public static mutable KW_ARRAY : int;
  public static mutable KW_MKARRAY : int;
  public static mutable COLON_MORE : int;
  public static mutable LESS_MINUS : int;
  public static mutable MINUS_MORE : int;
  public static mutable EQ_MORE : int;
  public static mutable COLON_COLON : int;
  public static mutable LESS_SQBRAC : int;
  public static mutable SQBRAC_MORE : int;
  public static mutable KW_MACRO : int;
  public static mutable KW_PATTERN : int;
  public static mutable LAZY_AND : int;
  public static mutable LAZY_OR : int;
  public static mutable ERROR : int;
  public static mutable UNARY : int;
  public static mutable yyErrorCode : int;

  public static init() : void {
    NUMBER_LITERAL <- 257;
    CHAR_LITERAL <- 258;
    ID <- 259;
    TYVAR <- 260;
    STRING_LITERAL <- 261;
    OP1 <- 262;
    OP2 <- 263;
    OP3 <- 264;
    OP4 <- 265;
    OP5 <- 266;
    OP6 <- 267;
    OP7 <- 268;
    KW_ABSTRACT <- 269;
    KW_CONST <- 270;
    KW_EXTERN <- 271;
    KW_INTERNAL <- 272;
    KW_NEW <- 273;
    KW_PRIVATE <- 274;
    KW_PROTECTED <- 275;
    KW_SEALED <- 276;
    KW_VOLATILE <- 277;
    KW_NAMESPACE <- 278;
    KW_BASE <- 279;
    KW_CLASS <- 280;
    KW_ENUM <- 281;
    KW_EXTENDS <- 282;
    KW_FINALLY <- 283;
    KW_IN <- 284;
    KW_NULL <- 285;
    KW_OUT <- 286;
    KW_PUBLIC <- 287;
    KW_RAISE <- 288;
    KW_REF <- 289;
    KW_STRUCT <- 290;
    KW_THIS <- 291;
    KW_VARIANT <- 292;
    KW_INTERFACE <- 293;
    KW_IMPLEMENTS <- 294;
    KW_WHERE <- 295;
    KW_TYPE <- 296;
    KW_LET <- 297;
    KW_FUN <- 298;
    KW_AND <- 299;
    KW_TYMATCH <- 300;
    KW_WITH <- 301;
    KW_TRY <- 302;
    KW_OPEN <- 303;
    KW_VOID <- 304;
    KW_IF <- 305;
    KW_THEN <- 306;
    KW_ELSE <- 307;
    KW_AS <- 308;
    KW_MATCH <- 309;
    KW_STATIC <- 310;
    KW_MUTABLE <- 311;
    KW_DEF <- 312;
    KW_MODULE <- 313;
    KW_ENSURE <- 314;
    KW_REQUIRE <- 315;
    KW_ARRAY <- 316;
    KW_MKARRAY <- 317;
    COLON_MORE <- 318;
    LESS_MINUS <- 319;
    MINUS_MORE <- 320;
    EQ_MORE <- 321;
    COLON_COLON <- 322;
    LESS_SQBRAC <- 323;
    SQBRAC_MORE <- 324;
    KW_MACRO <- 325;
    KW_PATTERN <- 326;
    LAZY_AND <- 327;
    LAZY_OR <- 328;
    ERROR <- 329;
    UNARY <- 330;
    yyErrorCode <- 256;
  }
 }

class Lexer extends LexerInterface
{
  file : System.IO.FileStream;
  file_name : string;
  mutable val : Object;
  mutable line : int;
  mutable col : int;
  mutable putback : int;
  
  last_line : int;
  last_col : int;
  mutable cur_tok : int;
  
  static mutable keywords : System.Collections.Hashtable;
  
  public this (fn : string)
    {
      this.file_name <- fn;
      this.file <- System.IO.FileStream (fn, (3 :> System.IO.FileMode));
(* FileMode.Open, but we don't support enums yet*)
      this.line <- 1;
      this.col <- 1;
      this.putback <- -1;
      this.cur_tok <- -1;
      Token.init();
    }

  do_read () : int
    {
      def ch = this.file.ReadByte();
      if ((ch : char) == '\n') {
	this.line <- this.line + 1;
	this.col <- 1;
      } 
      else
        this.col <- this.col + 1;
      ch
    }
	
  read () : int
    {
      if (this.putback == -1)
        this.do_read()
      else {
	def c = this.putback;
	this.putback <- -1;
	c
      }
    }

  peek() : int
    {
      if (this.putback == -1)
        this.putback <- this.do_read()
      else ();
      this.putback
    }

  is_id_beg(ch : int) : bool
    {
      ((ch : char) >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_'
    }

  is_digit(ch : int) : bool
    {
      ch >= '0' && ch <= '9'
    }

  is_opchar(ch : int) : bool
    {
      match (ch) {
	| '=' => true
	| '<' => true
	| '>' => true
	| '@' => true
	| '^' => true
	| '|' => true
	| '&' => true
	| '+' => true
	| '-' => true
	| '*' => true
	| '/' => true
	| '$' => true
	| '%' => true
	| '!' => true
	| '?' => true
	| '~' => true
	| '.' => true
	| ':' => true
	| '#' => true
	| '[' => true
	| ']' => true
	| _ => false
      }
    }

  skip_comment () : void
    {
      mutable ch <- ' ';
      mutable seen_star <- false;
      
      def loop () : void
	{
	  ch <- this.read();
	  if (seen_star && ch == ')')
	    ()
	  else {
	    if (ch == '*')
	      seen_star <- true
	    else
	      seen_star <- false;
	    loop ()
	  }
	};
      loop ()
    }

  get_op(tok : int, first_ch : int) : int
    {
      mutable buf <- System.Text.StringBuilder();
      
      buf <- buf.Append ((first_ch : char));

      def eat_opchars () : void
	{
	  if (this.is_opchar (this.peek ())) {
	    buf <- buf.Append ((this.read () : char));
	    eat_opchars ()
	  }
	  else
	    ()
	};
	
      eat_opchars ();
      def s = buf.ToString();
	
      this.val <- s;

      match (s) {
	| "*" => first_ch
	| "=" => first_ch
	| "?" => first_ch
	| "|" => first_ch
	| "$" => first_ch
	| "]" => first_ch
	| "<-" => Token.LESS_MINUS
	| "->" => Token.MINUS_MORE
	| "=>" => Token.EQ_MORE
	| "<[" => Token.LESS_SQBRAC
	| "]>" => Token.SQBRAC_MORE
	| "&&" => Token.LAZY_AND
	| "||" => Token.LAZY_OR
	| _ => tok
      }
    }

  get_number (first_ch : int) : int
    {
      mutable buf <- System.Text.StringBuilder();
      
      buf <- buf.Append ((first_ch : char));

      def eat_digits () : void
	{
	  if (this.is_digit (this.peek ())) {
	    buf <- buf.Append ((this.read () : char));
	    eat_digits ()
	  }
	  else
	    ()
	};

      eat_digits ();  
      this.val <- System.Int32.Parse (buf.ToString ());

      Token.NUMBER_LITERAL
    }

  get_id (first_ch : int) : int
    {
      if (first_ch == '\'' && !this.is_id_beg (this.peek ())) {
	this.get_char()
      } 
      else {
	mutable buf <- System.Text.StringBuilder();
	
	buf <- buf.Append ((first_ch : char));
	
	def eat_alphanum () : void
	  {
	    if (this.is_id_beg (this.peek ()) || 
              this.is_digit (this.peek ()) || this.peek() == '\'') {
	      buf <- buf.Append ((this.read () : char));
	      eat_alphanum ()
	    }
	    else
	      ()
	  };
	    
	eat_alphanum ();
	def str = buf.ToString ();
	
	if (first_ch == '\'' && str.Length == 2 && str[1] == '\'') {
	  this.val <- (((str[0] : int)) : Object);
	  Token.CHAR_LITERAL
	}
	else {
	  this.val <- (str : Object);
	  
	  if (first_ch == '\'')
	    Token.TYVAR
	  else {
	    init_keywords();
	    
	    if (keywords[str] != null)
	      (keywords[str] :> int)
	    else
	      Token.ID
	  }
	}
      }
    }

  escape_value (ch : int) : int
    {
      match (ch) {
	| 'n' => '\n'
	| 't' => '\t'
	| 'r' => '\r'
	| 'b' => '\b'
	| '"' => '"'
	| '\'' => '\''
	| '\\' => '\\'
	| _ => -1
      }
    }
    
  error(msg : string) : int
    {
      Message.error (this.get_current_location (), msg);
      Token.ERROR
    }

  get_char () : int
    {
      def ret = this.get_string('\'');
      if (ret == Token.ERROR)
        ret
      else {
	def v = (this.val :> string);
	if (v.Length == 0)
  	  this.error ("empty character literal")
	else {
	  if (v.Length != 1)
	    this.error("character literal too long")
	  else {
	    this.val <- (v[0] : int);
	    Token.CHAR_LITERAL;
	  }
	}
      }
    }

  get_string(end_ch : char) : int
    {
      def buf = StringBuilder();
      mutable ch <- -1;
		
      def loop () : option (int)
	{
	  if (ch != end_ch) {
	    ch <- this.read();
	    match (ch) {
	      | '\\' =>
	        ch <- this.read();
	      	def esc = this.escape_value(ch);
		if (esc == -1)
		  Some (error("invalid escape in string literal"))
		else {
		  buf.Append ((esc : char));
		  ch <- ' ';
		  loop ()
		}

	      | '\n' =>
	        error ("newline in string literal")

              | n =>
                if (n == -1)
	          error ("EOF in string literal")
                else
  	          if (ch != end_ch) {
	            buf.Append((ch : char));
		    loop ()
	       	  }
	       	  else 
 	            None ()
	    }
	  }
          else
            None ()
       	};
       
      match (loop ()) {
       	| Some (err) => err
       	| None =>
	  this.val <- buf.ToString ();
     
          Token.STRING_LITERAL
      }
    }

  get_quoted_op () : int
    {
      def _ = this.get_op(Token.ID, this.read());
      if (this.peek() != '`') {
	def _ = this.read();
	this.error("invalid character in quoted op")
      }
      else {
	def _ = this.read();
	Token.ID
      }
    }

  get_double_quoted_id () : int
    {
      mutable buf <- StringBuilder();
      mutable ch <- -1;

      def loop () : option (int)
        {
          if (ch != '`') {
            ch <- this.read();
            
            match (ch) {
              | '`' =>
                if (this.read() != '`')
                  Some (this.error("invalid character in double quoted id"))
                else {
              	  if (ch != '`') buf <- buf.Append ((ch : char))
                  else ();
                  loop ()
                }
              | '\n' =>
                Some (error("newline in double quoted id"))
              | _ =>
                Some (error("EOF in double quoted id"))
            }
          }
          else
            None ()
        };
        
      match (loop ()) {
        | Some(e) => e
        | _ =>
          this.val <- buf.ToString ();
          Token.ID
      }
    }
		
  get_quoted_id () : int
    {
      mutable buf <- StringBuilder ();
      mutable ch <- -1;
		
      def loop () : option (int)
        {
          if (ch != '`') {
            ch <- this.read();

            match (ch) {
              | '`' =>
                if (ch != '`')
                  buf <- buf.Append ((ch : char))
                else ();
                loop ()
              | '\n' =>
                Some (error("newline in infix id"))
              | _ =>
                Some (error("EOF in infix id"))
            }
          }
          else
            None ()
        };

      match (loop ()) {
        | Some (e) => e
        | _ =>
          this.val <- buf.ToString ();
          Token.OP4
      }
    }

  get_token () : int
    {
      def last_line = this.line;
      def last_col = this.col;
      mutable ch <- this.read();
		
      match (ch) {
        | ' ' => this.get_token ()
        | '\t' => this.get_token ()
        | '\r' => this.get_token ()
        | '\n' => this.get_token()
        | '"' => this.get_string('"')

        | '`' =>
          if (this.peek () == '`') {
            this.read();
            this.get_double_quoted_id()
          }
          else if (this.is_opchar (this.peek ())) {
            this.get_quoted_op()
          } else this.get_quoted_id()

        | '\'' => this.get_id('\'')

        | '(' =>
          if (this.peek () == '*') {
            this.read();
            this.skip_comment();
            this.get_token()
          } else ch

        | ':' =>
          if (this.peek () == '>') {
            this.read();
            Token.COLON_MORE
          } else if (this.peek () == ':') {
            this.read();
            Token.COLON_COLON
          } else ch

        | '{' => ch
        | '}' => ch
        | '[' => ch
        | ',' => ch
        | ';' => ch
        | '.' => ch
        | ')' => ch
        | '#' => ch
        | '\\' => ch

        | '*' =>
          if (this.peek () == '*')
            this.get_op(Token.OP1, ch)
          else
            this.get_op(Token.OP2, ch)

        | '/' =>
          if (this.peek () == '/') {
            ch <- this.read ();

            def loop () : void {
              if (ch != '\n' && ch != -1) {
                ch <- this.read();
                loop ()
              }
              else
                ()
            };
            loop ();
            this.get_token()
          } else
            this.get_op(Token.OP2, ch)
				
        | '%' => this.get_op(Token.OP2, ch)
        | '+' => this.get_op(Token.OP3, ch)
        | '-' => this.get_op(Token.OP3, ch)
        | '@' => this.get_op(Token.OP4, ch)
        | '^' => this.get_op(Token.OP4, ch)
        | '$' => this.get_op(Token.OP4, ch)
        | '~' => this.get_op(Token.OP4, ch)
        | '?' => this.get_op(Token.OP4, ch)
        | '=' => this.get_op(Token.OP5, ch)
        | '<' => this.get_op(Token.OP5, ch)
        | '>' => this.get_op(Token.OP5, ch)
        | '!' => this.get_op(Token.OP5, ch)
        | ']' => this.get_op(Token.OP5, ch)
        | '&' => this.get_op(Token.OP6, ch)
	| '|' => this.get_op(Token.OP7, ch)

        | n =>
          if (n == -1) -1
          else
            if (this.is_digit (ch))
              this.get_number (ch)
            else
              if (this.is_id_beg (ch))
                this.get_id (ch)
              else
                this.error("invalid character")
      }      
    }

  public get_location () : Location
    {
      Location(this.file_name, this.last_line, this.last_col)
    }

  public get_current_location () : Location
    {
      Location(this.file_name, this.line, this.col)
    }

  // yyParser.yyInput
  public advance () : bool
    {
      this.cur_tok <- this.get_token();
      this.cur_tok != -1
    }
    
  public token () : int
    {
      if (this.cur_tok == -1)
        Util.ice ("attempt to read beyond end of file")
      else
       this.cur_tok
    }

  public value () : Object
    {
      this.val
    }
	
  static init_keywords() : void
    {
      if (keywords != null)
        ()
      else {
        keywords <- Hashtable();
        keywords["_"] <- ('_' : int);
        keywords["abstract"] <- Token.KW_ABSTRACT;
        keywords["const"] <- Token.KW_CONST;
        keywords["extern"] <- Token.KW_EXTERN;
        keywords["internal"] <- Token.KW_INTERNAL;
        keywords["new"] <- Token.KW_NEW;
        keywords["private"] <- Token.KW_PRIVATE;
        keywords["protected"] <- Token.KW_PROTECTED;
        keywords["sealed"] <- Token.KW_SEALED;
        keywords["volatile"] <- Token.KW_VOLATILE;
        keywords["class"] <- Token.KW_CLASS;
        keywords["enum"] <- Token.KW_ENUM;
        keywords["extends"] <- Token.KW_EXTENDS;
        keywords["finally"] <- Token.KW_FINALLY;
        keywords["in"] <- Token.KW_IN;
        keywords["null"] <- Token.KW_NULL;
        keywords["out"] <- Token.KW_OUT;
        keywords["public"] <- Token.KW_PUBLIC;
        keywords["raise"] <- Token.KW_RAISE;
        keywords["ref"] <- Token.KW_REF;
        keywords["struct"] <- Token.KW_STRUCT;
        keywords["this"] <- Token.KW_THIS;
        keywords["variant"] <- Token.KW_VARIANT;
        keywords["interface"] <- Token.KW_INTERFACE;
        keywords["implements"] <- Token.KW_IMPLEMENTS;
        keywords["namespace"] <- Token.KW_NAMESPACE;
        keywords["where"] <- Token.KW_WHERE;
        keywords["type"] <- Token.KW_TYPE;
        keywords["let"] <- Token.KW_LET;
        keywords["fun"] <- Token.KW_FUN;
        keywords["and"] <- Token.KW_AND;
        keywords["tymatch"] <- Token.KW_TYMATCH;
        keywords["with"] <- Token.KW_WITH;
        keywords["try"] <- Token.KW_TRY;
        keywords["open"] <- Token.KW_OPEN;
        keywords["void"] <- Token.KW_VOID;
        keywords["base"] <- Token.KW_BASE;
        keywords["if"] <- Token.KW_IF;
        keywords["then"] <- Token.KW_THEN;
        keywords["else"] <- Token.KW_ELSE;
        keywords["as"] <- Token.KW_AS;
        keywords["match"] <- Token.KW_MATCH;
        keywords["static"] <- Token.KW_STATIC;
        keywords["mutable"] <- Token.KW_MUTABLE;
        keywords["def"] <- Token.KW_DEF;
        keywords["module"] <- Token.KW_MODULE;
        keywords["require"] <- Token.KW_REQUIRE;
        keywords["ensure"] <- Token.KW_ENSURE;
        keywords["array"] <- Token.KW_ARRAY;
        keywords["mkarray"] <- Token.KW_MKARRAY;
        keywords["macro"] <- Token.KW_MACRO;
//                keywords["pattern"] <- Token.KW_PATTERN;
      }
    }
} // end class Lexer
} // end ns
