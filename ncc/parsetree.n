/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler.Parsetree {


public variant SyntaxElement {
  | SyntaxExpr { body : PExpr; }
  | SyntaxType { body : Type; }
  | SyntaxCase { body : MatchCase; }
  | SyntaxCaseGuard { body : PExpr; guard : option <PExpr>; }
  | SyntaxFunDecl { body : Function_decl; }
  | SyntaxFunParm { body : Fun_parm; }
  | SyntaxTType { body : Type; }

  | SyntaxDeclaration { body : ClassMember; }    
  | SyntaxTTypeBuilder { body : TypeBuilder; }
  | SyntaxTField { body : NemerleField; }
  | SyntaxTMethod { body : NemerleMethod; }
  | SyntaxTProperty { body : NemerleProperty; }
  | SyntaxTEvent { body : NemerleEvent; }
  | SyntaxTFunParm { body : Typedtree.Fun_parm; }
}

[Record]
public class DeclarationBase : Located
{
  public mutable name : Splicable_string;
  public mutable modifiers : Modifiers;

  public Name : string {
    get { Macros.NameOfSString (name).Id }
  }

  public Attributes : NemerleAttributes {
    get { modifiers.mods }
    set { modifiers.mods = value }
  }
}

[Record]
public class Constraint
{
  public tyvar : string * int;
  public ty : Type;
}

[Record]
public class Typarms
{
  public tyvars : list <string * int>;
  public constraints : list <Constraint>;
  
  public static Empty : Typarms = Typarms ([], []);
}

[Record]
public variant TopDeclaration : DeclarationBase
{
  | Namespace { decls : list <TopDeclaration>; }
  | Using 
  | UsingAlias { alias : string; }
  | Attribute { body : PExpr; }

  | Class {
    typarms : Typarms;
    mutable t_extends : list <Type>;
    decls : list <ClassMember>;
  }
  | Alias {
    typarms : Typarms;
    ty : Type;
  }
  | Interface {
    typarms : Typarms;
    mutable t_extends : list <Type>;
    methods : list <ClassMember>; // only iface_member
  } 
  | Variant {
    typarms : Typarms;
    mutable t_extends : list <Type>;
    mutable decls : list <ClassMember>;
  }
  | VariantOption { decls : list <ClassMember>; }
    
  | Macro {
    header : Fun_header;
    synt : list <PExpr>;
    expr : PExpr;
  }
  | Delegate { header : Fun_header; }
  | Enum {
    t_extends : list <Type>;
    decls : list<ClassMember>;
  }

  public this () { base (Splicable_string.SS_string (Name ([])), Modifiers.Empty) }
}

[Record]
public variant ClassMember : DeclarationBase
{
  | TypeDeclaration { td : TopDeclaration; }
  | Field { ty : Type; }
  | Function { 
      header : Fun_header;
      mutable kind : Fun_kind;
      mutable body : Fun_body;
    }
  | Property {
      ty : Type;
      prop_ty : Type;
      dims : list <Fun_parm>; // parameters of indexer property
      mutable get : option <ClassMember>;
      mutable set : option <ClassMember>;
    }
  | Event {
      ty : Type;
      mutable add : option <ClassMember>;
      mutable remove : option <ClassMember>;
    }
  | EnumOption { value : option <PExpr>; }

  /** accessible only for ClassMember.Function, when its Fun_body is not typed or compiled */
  public Body : PExpr {
    get {
      match (this) {
        | ClassMember.Function { body = bd } =>
          match (bd) {
            | Fun_body.FB_parsed_expr (expr) => expr
            | Fun_body.FB_typed_expr =>
              Message.error ("Body of typed method is not accessible");
              null
            | Fun_body.FB_compiled_expr =>
              Message.error ("Body of compiled method is not accessible");
              null
            | Fun_body.FB_extern 
            | Fun_body.FB_abstract => <[ () ]>
          }
        | _ =>
          Message.error ("Body is accessible only for ClassMember.Function variant option");
          null
      }
    }
    set {
      match (this) {
        | (ClassMember.Function) as fn =>
          fn.body = Fun_body.FB_parsed_expr (value);
        | _ =>
          Message.error ("Body is accessible only for ClassMember.Function variant option")
      }
    }
  }
}

/** class encapsulating name of variable for purpose of
    quotation and renaming
 */    
public class Name : Nemerle.IComparable <Name>
{
  public idl : list <string>;  
  public color : int;
  public context : GlobalEnv;

  public this (idl : list<string>)
  {
    this.idl = idl;
    this.color = TypingContext.MacroColor;
    this.context = null; // no global context
  }
  
  public this (id : string)
  {
    this.color = TypingContext.MacroColor;
    this.context = null; // no global context
    idl = [id]
  }

  public this (id : list <string>, color : int, context : GlobalEnv)
  {
    this.color = color;
    this.context = context;
    idl = id;
  }

  static public NameInCurrentColor (id : list <string>, context : GlobalEnv) : Name
  {
    Name (id, TypingContext.MacroColor, context)
  }


  /** returns the first part of the name (in most cases it is entime name)
   */
  public Id : string
  {
    get { Nemerle.Collections.List.Head (idl) }
  }

  /** return fully qualified name stored in this instance (in most cases it doesnt
                                                           differ from Id)
   */                                                           
  public FullId : string
  {
    get { Nemerle.Utility.NString.Concat (".", idl) }
  }

  public Equals (other : Name) : bool
  {
    color == other.color && lexicographic_compare (idl, other.idl) == 0
  }
  
  public CompareTo (other : Name) : int
  {
    if (color == other.color || color < 0 || other.color < 0)
      lexicographic_compare (idl, other.idl)
    else
      color - other.color
  }

  lexicographic_compare (my : list <string>, oth : list <string>) : int {
    | (x :: xs, y :: ys) =>
      if (x == y) lexicographic_compare (xs, ys)
      else string.CompareOrdinal (x, y)
    | ([], []) => 0
    | (_, []) => 1
    | ([], _) => -1
  }
  
  public GetEnv (default : GlobalEnv) : GlobalEnv
  {
    if (context != null)
      context
    else
      default
  }
}

[Record]
public variant Splicable_string : Located 
{
  | SS_string { body : Name; }
//  | Splicable_string.SS_int { body : int; }    
  | SS_spliced_expr { expr : PExpr; }
}

[Record]
public variant Splicable_int : Located
{
  | SI_int { body : int; }
  | SI_spliced_expr { expr : PExpr; }
}

public variant Type
{
  | T_app {
      tycon : Splicable_string;
      args : list <Type>;
    }
  | T_ref { t : Type; }
  | T_out { t : Type; }
  | T_fun { from : Type; to : Type; }
  | T_void
  | T_prod { args : list <Type>; }
  | T_array { t : Type; rank : Splicable_int; }
  | T_infer

  | T_spliced { expr : PExpr; }
  | T_type_list { body: Type; }
  
  | T_typed { body : Typedtree.Type; }
}

public class Fun_parm : DeclarationBase
{
  public ty : Type;
  public this (name : Splicable_string, ty : Type, modifiers : Modifiers) 
  {
    base (Location.Default, name, modifiers);
    this.ty = ty;
  }
  public this (loc : Location, name : Splicable_string, ty : Type,
               modifiers : Modifiers) 
  {
    base (loc, name, modifiers);      
    this.ty = ty;
  }
}
  
public class Fun_header : Located
{
  public typarms : Typarms;
  public mutable name : Splicable_string;
  public ret_type : Type;
  public parms : list <Fun_parm>;

  public this () {}
  public this (loc : Location, name : Splicable_string, ret_type : Type, 
               parms : list <Fun_parm>) 
  {
    base (loc);
    this.typarms = Typarms.Empty;
    this.name = name;
    this.ret_type = ret_type;
    this.parms = parms;
  }
  
  public this (typarms : Typarms, 
               name : Splicable_string, 
               ret_type : Type, 
               parms : list <Fun_parm>) 
  {
    this.typarms = typarms;
    this.name = name;
    this.ret_type = ret_type;
    this.parms = parms;
  }

  public this (loc : Location,
               typarms : Typarms, 
               name : Splicable_string, 
               ret_type : Type, 
               parms : list <Fun_parm>) 
  {
    base (loc);
    this.typarms = typarms;
    this.name = name;
    this.ret_type = ret_type;
    this.parms = parms;
  }
}

[Record]
public class Function_decl
{
  public header : Fun_header;
  public mutable body : PExpr;
}

[Record]
public class MatchCase
{
  public this (patterns : list <PExpr * option <PExpr>>, body : PExpr)
  {
    this (patterns, body, false)
  }
    
  public patterns : list <PExpr * option <PExpr>>;
  public body : PExpr;
  public disable_warnings : bool;
}

[Record]
public variant PExpr : Located 
{
  | E_Underscore
  | E_As { pat : PExpr; name : Splicable_string; }
  | E_DefPattern { pattern : PExpr; val : PExpr; }
  | E_Match { expr : PExpr; cases : list <MatchCase>; }
  | E_Application { func : PExpr; arg : PExpr; }    
 
  | E_ref { name : Name; }
  | E_member { obj : PExpr; member : Splicable_string; }
  | E_call { func : PExpr; parms : list <PExpr>; }
  | E_assign { target : PExpr; source : PExpr; }
  | E_let { is_ref : bool; name : Splicable_string; val : PExpr; }
  | E_letfun { funs : list <Function_decl>; }
  | E_lambda { decl : Function_decl; }
  | E_raise { exn : PExpr; }
  | E_try_with { body : PExpr; exn : Splicable_string; exn_ty : Type; 
            handler : PExpr; }
  | E_try_finally { body : PExpr; handler : PExpr; }
  | E_literal { val : Literal; }
  | E_this
  | E_base
  | E_typeof { ty : Type; }
  | E_type_conversion { expr : PExpr; ty : Type; }  // (expr :> ty)
  | E_type_enforcement { expr : PExpr; ty : Type; } // (expr : ty)
  | E_sequence { body : list <PExpr>; }
  | E_tuple { args : list <PExpr>; }
  | E_mkarray { rank : PExpr; args : PExpr; }
  | E_empty_array { sizes : list <PExpr>; }
  | E_indexer { obj : PExpr; args : list <PExpr>; }

  | E_parm_by_ref { parm : PExpr; }
  | E_parm_out { parm : PExpr; }

  // macros stuff    
  | E_macrocall { name : Name; ns : GlobalEnv.NamespaceND;
             parms : list <SyntaxElement>; }
  | E_quoted { body : SyntaxElement; }
  | E_spliced { body : PExpr; }
  | E_expr_list { body : PExpr; }
  | E_typed_expr { body : Typedtree.Expr; }
  | E_typed_pattern { body : Typedtree.Pattern; }  
}
} // Nemerle.Compiler

