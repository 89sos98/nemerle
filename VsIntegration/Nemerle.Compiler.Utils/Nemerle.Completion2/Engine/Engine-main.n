using System;
using System.IO;
using System.Diagnostics;
using System.Linq;

using SCG = System.Collections.Generic;
using SR  = System.Reflection;

using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Utility;
using Nemerle.Compiler.Utils;

using Typed         = Nemerle.Compiler.Typedtree;
using TExpr         = Nemerle.Compiler.Typedtree.TExpr;
using LibRefManager = Nemerle.Completion2.Factories.IntelliSenseModeLibraryReferenceManager;
using Pair          = System.Collections.Generic.KeyValuePair;

namespace Nemerle.Completion2
{
  public partial class Engine : ManagerClass
  {
    private static _parse_lock      : object = object();
    public event   TypedtreeCreated : EventHandler;

    public ParseTopDeclarations(source : ISource) : list[TopDeclaration]
    {
      if (IsProjectAvailable) // Get cached TopDeclaration-s.  VladD2: This is not thread safe!
        this.Project.CompileUnits.GetTopDeclarations(source.FileIndex);
      else ParceCompileUnit(source).TopDeclarations
    }
    
    /// Makes the typed tree (namespace tree) and constructs compile 
    /// unit collection.
    public BuildTypeTree() : void
    {
      lock (_parse_lock)
      try
      {
        TypeTreeVersion++;
        Trace.WriteLine(">>>> ##### Build types tree!");

        def init() : void
        {
          _currentMessages = SCG.List(32);

          this.Options.OutputFileName = this._callback.ProjectName;

          RestoreManagerClassInstance();

          InitCompiler();

          // we must clean the nodes from current program - note that this 
          // behaviour is automatically provided by Run, but completion
          // engine does not use it at the moment.. :(
          if (Options.PersistentLibraries)
            LibrariesManager.RemoveInternalExtensionMethods();
          else
          {
            // Get assembly references from IDE.
            def asmRefs = _callback.GetAssemblyReferences().ToArray();
            // Update library list.
            LibRefManager.UpdateAssemblies(asmRefs);

            try
            {
              mutable ex;

              foreach (asm in asmRefs) // Add all asseblies into compiler
                try { LibrariesManager.AddLibrary(asm); }
                catch
                {
                  | _ is AssemblyFindException => ()
                  | e => when (ex == null) ex = e
                }

              LoadExternalLibraries(); // reload types information

              when (ex != null)
                throw ex;
            }
            catch
            {
              | e =>
                def errorMag =
                  if (LibRefManager.UnresolvedAssms.Count > 0)
                  {
                    $"Error: $(e.Message)\r\n\r\n"
                    + LibRefManager.UnresolvedAssms.Values.ToString("\r\n\r\n")
                    + "\r\n\r\nTry recompile solution or referenced assembies!";
                  }
                  else $"Error: $(e.Message)\r\n\r\n";

                _callback.ShowMessage(errorMag, MessageType.Error);
            }
          }
          
          // next time Init is called, we won't reload libs
          Options.PersistentLibraries = true;
    #pragma warning disable 618 // Obsolete
          _project = null; // in other locations you must use ResetNamespaceTree()!
    #pragma warning restore 618 // Obsolete
          _namespaces.Clear();
          _decls = null;
          _compileUnits = null;
          this.Hierarchy = TypesManager (this);
          _isCanBeReset = true;
        }

        init();

        def projSources = ProjectSources;
        def expandArray(ary, newLen, expandFactor = 1)
        {
          if (newLen > ary.Length)
          {
            def newArray = array(newLen * expandFactor);
            ary.CopyTo(newArray, 0);
            newArray;
          }
          else ary
        }
        
        _compileUnits = array(Nemerle.Compiler.Location.GetIndexArrayLength());

        foreach (fileIndex in Sources.GetFileIndices())
        {
          _compileUnits = expandArray(_compileUnits, fileIndex + 1, 2);
          def source = projSources.GetSource(fileIndex);
          _compileUnits[fileIndex] = ParceCompileUnit(source);
        }
         
        // create N.C.TypeBuilders for all parsed types and add them to namespace hierarchy
        try
        {
            //Trace.WriteLine("!!! Begin >>>>");
            foreach (compilerUnit when compilerUnit != null in _compileUnits)
              foreach (topDecl in compilerUnit.TopDeclarations)
              {
                //Output.WriteLine($"------- $topDecl: $(topDecl.Name)");
                //Output.WriteLine(topDecl.Location);
                when (topDecl.name is Splicable.Name && topDecl.ParsedName.context != null)
                  ScanningPipeline(topDecl);
              }
            //Trace.WriteLine("!!! End <<<<");
        }
        catch { | _e => Trace.WriteLine(_e); }

        // xz. Looks like it's building types' tree and is resolving references.
        try { this.Hierarchy.Run(); }
        catch { | _e => Trace.WriteLine(_e); }

        def nsTree = NameTree.NamespaceTree;


#pragma warning disable 618 // Obsolete
        _project = Project(
          this, 
          CompileUnitCollection(this, _compileUnits),
          nsTree,
          _currentMessages.ToList());

        _rowProject = _project;
        
        when (TypedtreeCreated != null)
          TypedtreeCreated(_project, EventArgs.Empty);
#pragma warning restore 618 // Obsolete

        Trace.WriteLine("<<<< ##### Build types tree finish!");
      }
      finally
      {
        when (Hierarchy != null)
          Hierarchy.Dispose();

        ReportTopLevelErrors();
        _currentMessages = null;
        LastParseTime = DateTime.Now;
      }
    }

    public ParceCompileUnit(source : ISource) : CompileUnit
    {
      lock (_parse_lock)
      {
				RestoreManagerClassInstance();
        def fileIndex = source.FileIndex;
        _namespaces.Clear();
        _decls        = [];
        def code      = source.GetText();
        def lexer     = LexerString(this, code, Location(fileIndex, 1, 1));
        def topDecls  = try { ParsingPipeline(lexer) }
                       catch { | _ => [] }; //!!! теряем сообщение!
        def endLoc    = lexer.Location;
        def loc       = Location(fileIndex, 1, 1, endLoc.EndLine, endLoc.EndColumn);
        def insideEnv = match (_decls.Find(_ is Decl.Using))
                        { | Some(Decl.Using as u) => u.AfterEnv | _ => CoreEnv };
        def topNs     = Decl.Namespace(loc, _decls.Rev(), [], [], CoreEnv, insideEnv, loc, topDecls);
        _decls        = [];
        assert2(_namespaces.Count == 0);

        // Данная функция подключает полученный список TopDeclaration-ов в пространсва имен к которым
        // они пренадлежат.
        // Go through namespaces for each file.
        
        def addTypes(ns, topDeclarations) : void
        {
          def getNsDeclList(ns, acc = SCG.List())
          {
            acc.Add(ns);

            foreach (subNs is Decl.Namespace in ns.Decls)
              _ = getNsDeclList(subNs, acc);

            acc
          }
          
          def typesGroupedByNs = topDeclarations.GroupBy(
                d => match (d.TryGetEnv()) { | Some(env) => env | _ => null }).AsList();

          def nsDeclList = getNsDeclList(ns).AsList();
          def join = nsDeclList.Join(typesGroupedByNs, 
                nsDecl => nsDecl.InsideEnv,
                group  => group.Key,
                x      => x);
          foreach ((nsDecl, group) in join)
            foreach (topDeclaration in group)
              nsDecl.Decls ::= Decl.Type(topDeclaration.Location, topDeclaration);
        }
        
        addTypes(topNs, topDecls);
        
        CompileUnit(topNs, topDecls.Rev(), lexer.Regions.Rev());
      }
    }

    // HACK: see usings
    public static VeryBigNumber = 1000000;
  } // end class Engine
} // end namespace
