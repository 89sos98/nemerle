(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.CGexpr;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

module CGexpr {
  mutable cg_members : Int_map (CG_member);
  
  lookup_field (decl : M_field) : CM_field {
    match (cg_members.find (decl.id)) {
      | Some (r) => (r :> CM_field)
      | None =>
        def m = (CM_field (cg_type (decl.ty)) :> CM_field);
        m.name <- decl.name;
        m.attrs <- cg_attrs (decl.modifiers);
        cg_members <- cg_members.add (decl.id, m);
        m
    }
  }

  lookup_value (decl : M_value) : CM_field {
    match (cg_members.find (decl.id)) {
      | Some (r) => (r :> CM_field)
      | None =>
        def m = (CM_field (cg_type (decl.ty)) :> CM_field);
        m.name <- decl.name;
        m.attrs <- cg_attrs (decl.modifiers);
        make_static (m);
        cg_members <- cg_members.add (decl.id, m);
        m
    }
  }

  lookup_function (h : Fun_header) : CM_method {
    match (cg_members.find (h.id)) {
      | Some (r) => (r :> CM_method)
      | None =>
        def m = cg_header (h);
        cg_members <- cg_members.add (h.id, m);
        m
    }
  }

  lookup_class (ti : Tyinfo) : CM_class {
    match (cg_members.find (ti.id)) {
      | Some (r) => (r :> CM_class)
      | None =>
        def inh = List.map (cg_type, ti.direct_supertypes ());
        def r = (CM_class ("", CK_class (), inh, Nil ()) :> CM_class);
        r.loc <- ti.loc;
        r.name <- ti.name;
        r.attrs <- cg_attrs (ti.modifiers);
        cg_members <- cg_members.add (ti.id, r);
        r
    }
  }
    
  cg_type (t : Type) : CG_type {
    match (Tyutil.top_expand (t)) {
      | T_void => CT_void ()
      | T_prod (l) => CT_tuple (List.length (l))
      | T_fun (args, _) => CT_fun (List.length (Tyutil.fun_args (args)))
      | T_var (tv) =>
        match (Tyvar.constraints (tv)) {
          | Nil => CT_object ()
          | Cons (t, _) => cg_type (t)
        }
      | T_app (ti, _) => 
        match (ti.tydecl) {
          | TD_external (x) => 
            if (x == "object") CT_object ()
            else CT_ref (x)
          | _ => CT_ref (ti.fullname())
        }
      | T_ref => Util.ice ("FIXME: cg ref")
      | T_out => Util.ice ("FIXME: cg out")
      | T_array (at) => CT_array (cg_type (at))
    }
  }

  mutable closures : list (CG_member);

  class CTX
    {
      mutable current_fun : Decl;
      mutable current_closure : option (CG_val);
      mutable closure_fields : Int_map (CM_field);
      mutable closure_ptrs : Int_map (CM_field);
      mutable locals : Int_map (CG_val);
    }

  copy_ctx (c : CTX) : CTX {
    CTX (current_fun = c.current_fun,
         current_closure = c.current_closure,
         closure_fields = c.closure_fields,
         closure_ptrs = c.closure_ptrs,
         locals = c.locals)
  }

  empty_ctx () : CTX {
    CTX (current_fun = null,
         current_closure = None (),
         closure_fields = Map.int_map (),
         closure_ptrs = Map.int_map (),
         locals = Map.int_map ())
  }

  store_in_closure (ctx : CTX, d : Decl, val : CG_expr) : CG_expr
    {
      def rf = CE_field_ref (CE_ref (Util.unsome (ctx.current_closure)),
                             ctx.closure_fields.get (d.id));
      CE_assign (rf, val);
    }

  store_local (ctx : CTX, d : Decl, val : CG_expr) : CTX * CG_val {
    if (d.in_closure) {
      def assign = store_in_closure (ctx, d, val);
      def cgv = CG_val (loc = d.loc, 
                        name = "_N_dummy_" + string_of_int (Util.next_id ()), 
                        ty = CT_void (), 
                        val = assign);
      (copy_ctx (ctx), cgv)
    } else {
      def cgv = CG_val (loc = d.loc, 
                        name = decl_uniq_name(d), 
                        ty = cg_type (d.ty), 
                        val = val);
      def ctx' = copy_ctx (ctx);
      ctx'.locals <- ctx.locals.add (d.id, cgv);
      (ctx', cgv)
    }
  }

  closure_ref (ctx : CTX, fn : Decl) : CG_expr {
    if (ctx.current_fun.id == fn.id)
      CE_ref (Util.unsome (ctx.current_closure))
    else
      CE_field_ref (CE_this (), ctx.closure_ptrs.get (fn.id))
  }

  null_value (t : CG_type) : CG_expr {
    match (t) {
      | CT_bool => CE_false ()
      | CT_ref (n) =>
        if (n == "int") CE_literal (L_int (0))
        else if (n == "char") CE_literal (L_char (0))
        else if (n == "bool") CE_false ()
        else if (n == "float") CE_literal (L_int (0)) // FIXME ?
        else CE_literal (L_null ())
      | _ => CE_literal (L_null ())
    }
  }

  cg_pattern (ctx : CTX, val : CG_expr, pat : Pattern) : CG_expr * bool * CTX * list (CG_val)
    {
      mutable vals <- Nil ();
      mutable rctx <- ctx;
      mutable always_matches <- true;
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_true ()
          
          | P_variable (d) =>
            if (d.in_closure) ()
            else {
              def (ctx, v) = store_local (rctx, d, null_value (cg_type (d.ty)));
              rctx <- ctx;
              vals <- Cons (v, vals);
            };
            def ass = CE_assign (val_ref (rctx, d), maybe_cast (d.ty, val));
            CE_sequence (Cons (ass, Cons (CE_true (), Nil ())))
            
          | P_tuple (args) =>
            def len = List.length (args);
            def f (acc : int * CG_expr, arg : Pattern) : int * CG_expr
              {
                def (pos, ex) = acc;
                def cond = cgpat (CE_tuple_ref (CE_cast (val, CT_tuple (len)), pos), arg);
                (pos - 1, CE_if (CT_bool (), cond, ex, CE_false ()))
              }
            def ini = (len - 1, CE_true ());
            def (_, ex) = List.fold_left (f, ini, List.rev (args));
            ex

          | P_literal (lit) =>
            def eq = 
              match (Env.lookup_global ("Nemerle.Core.==")) {
                | {kind = D_class_member (M_function (h, _, _))} => lookup_function (h)
                | _ => Util.ice ()
              };
            CE_call (CE_global_ref (eq), [val; CE_literal (lit)])
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (pat.ty));
            def f (ex : CG_expr, arg : Named_pattern) : CG_expr 
              {
                def cond = cgpat (CE_field_ref (val, lookup_field (arg.name)), arg.pat);
                CE_if (CT_bool (), cond, ex, CE_false ())
              }
            List.fold_left (f, CE_true (), List.rev (args))
          
          | P_cons (n, a) =>
            always_matches <- false;
            def tyname = CT_ref (n.fullname());
            def ex = CE_has_type (val, tyname);
            CE_if (CT_bool (), ex, cgpat (CE_cast (val, tyname), a), CE_false ())
        }
      }

      def r = cgpat (val, pat);
      (r, always_matches, rctx, vals);
    }

  cg_match (t : CG_type, ctx : CTX, val : CG_expr, mcs : list (Match_case)) : CG_expr {
    match (mcs) {
      | Nil =>
        def match_failure =
          match (Env.lookup_global ("Nemerle.Core.Match_failure")) {
            | {kind = D_type (x)} => lookup_class (x)
            | _ => Util.ice ()
          };
        CE_raise (CE_call (CE_ctor_ref (match_failure), Nil ()))

      | Cons (m, ms) =>
        def (cond, always_matches, ctx', vals) = cg_pattern (ctx, val, m.pattern);
        def mklet (acc : CG_expr, v : CG_val) : CG_expr { CE_let (v, acc) }
        def then_part = cg_expr (ctx', m.body);
        def else_part = cg_match (t, ctx, val, ms);
        List.fold_left (mklet, CE_if (t, cond, then_part, else_part), vals)
    }
  }

  mutable lambda_proxies : Int_map (CM_class);

  val_ref (ctx : CTX, d : Decl) : CG_expr {
    if (d.in_closure) {
      def defined_in = Util.unsome (d.parent_fun);
      CE_field_ref (closure_ref (ctx, defined_in), 
                    ctx.closure_fields.get (d.id))
    } else
      match (d.kind) {
        | D_class_member (M_value v) => 
          CE_global_ref (lookup_value (v))
          
        | D_class_member (M_function f) =>
          if (lambda_proxies == null) lambda_proxies <- Map.int_map ()
          else ();
          def lc =
            match (lambda_proxies.find (f.id)) {
              | Some (lc) => lc
              | None =>
                def lc = make_lambda_class (ctx, Env.global_by_id (f.id));
                def mkparm (v : CG_val) : CG_expr 
                  {
                    def t = v.ty;
                    v.ty <- CT_object ();
                    CE_cast (CE_ref (v), t)
                  }
                def fn = cg_header (f.header);
                fn.body <- CE_call (CE_global_ref (lookup_function (f.header)), 
                                    List.map (mkparm, fn.parms));
                lc.decls <- List.cons ((fn : CG_member));
                lc.extern_name <- lc.name;
                fn.name <- "apply";
                fn.attrs <- List.cons ("public");
                fn.ret_type <- CT_object ();
                closures <- Cons ((lc : CG_member), closures);
                lambda_proxies <- lambda_proxies.add (f.id, lc);
                lc
            };
          CE_call (CE_ctor_ref (lc), Nil ())

        | D_class_member => Util.ice ()

        | _ => 
          if (ctx.locals.mem (d.id))
            CE_ref (ctx.locals.get (d.id))
          else {
            Message.debug ("undef " + d.name + " = " + string_of_int (d.id));
            Util.ice ("ref to undef val " + d.name)
          }
      }
  }

  tmp () : string {
    "_N_ct" + string_of_int (Util.next_id ())
  }

  maybe_cast (needed_type : Type, ex : CG_expr) : CG_expr {
    match ((CGflat.type_of (ex), cg_type (needed_type))) {
      | (CT_object, CT_object) => ex
      | (CT_object, t) => CE_cast (ex, t)
      | (CT_ref (n1), CT_ref (n2)) =>
        if (n1 == n2) ex else CE_cast (ex, CT_ref (n2))
      | _ => ex
    }
  }

  raw_cg_expr (ctx : CTX, inex : Expr) : CG_expr
    {
      def self (e : Expr) : CG_expr { cg_expr (ctx, e) }
      match (inex) {
        | E_ref (d) => 
          val_ref (ctx, d)

        | E_field_ref (o, f) =>
          maybe_cast (inex.expr_ty, CE_field_ref (self (o), lookup_field (f)))

        | E_method_ref => Util.ice ()

        | E_call (f, ps) =>
          def mkp (p : Parm) : CG_expr { self (p.expr) }
          def callable =
            match (f) {
              | E_ref ({kind = D_class_member (M_function f)}) =>
                def ti = f.tyinfo;
                match (f.kind) {
                  | FK_ctor =>
                    CE_ctor_ref (lookup_class (ti))
                  | _ =>
                    CE_global_ref (lookup_function (f.header))
                }
              | E_method_ref (o, m) => 
                CE_method_ref (self (o), lookup_function (m.header))
              | _ =>
                def fldname = "Nemerle.Func" + string_of_int (List.length (ps)) + ".apply";
                def fldref =
                  match (Env.lookup_global (fldname)) {
                    | {kind = D_class_member (M_function {header = h})} => 
                      lookup_function (h)
                    | _ => Util.ice ()
                  };
                CE_method_ref (self (f), fldref)
            };
          maybe_cast (inex.expr_ty, CE_call (callable, List.map (mkp, ps)))

        | E_assign (e1, e2) =>
          CE_assign (self (e1), self (e2))
          
        | E_array (initializers) =>
          CE_array (List.map (self, initializers))

        | E_indexer (obj, args) =>
          CE_indexer (self (obj), List.map (self, args));

        | E_let (d, v, b) =>
          def (ctx', cgv) = store_local (ctx, d, self (v));
          CE_let (cgv, cg_expr (ctx', b))

        | E_letfun (fs, body) =>
          mutable l <- Nil ();
          def store (ctx : CTX, f : Function_decl) : CTX 
            {
              def cl = make_lambda_class (ctx, f.decl);
              def ct = make_lambda_ctor (ctx, f.decl, cl);
              def (ctx, val) = store_local (ctx, f.decl, ct);
              l <- Cons ((val, cl), l);
              ctx
            }

          def ctx = List.fold_left (store, ctx, fs);
          
          def fill (f : Function_decl, acc : CG_val * CM_class) : void 
            {
              def (val, cl) = acc;
              closures <- Cons ((cl : CG_member), closures);
              fill_lambda_class (ctx, f.decl, f.body, cl)
            }

          List.iter2 (fill, fs, List.rev (l));

          def mklet (acc : CG_expr, x : CG_val * CM_class) : CG_expr
            {
              def (val, cl) = x;
              CE_let (val, acc)
            }

          List.fold_left (mklet, cg_expr (ctx, body), l)

        | E_match (e, mcs) =>
          def v =
            CG_val (loc = e.loc, 
                    name = tmp (),
                    ty = cg_type (e.expr_ty), 
                    val = cg_expr (ctx, e));
          CE_let (v, cg_match (cg_type (inex.expr_ty), ctx, CE_ref (v), mcs))

        | E_raise (e) =>
          CE_raise (cg_expr (ctx, e))

        | E_if (cond, e1, e2) =>
          CE_if (cg_type (inex.expr_ty), 
                 cg_expr (ctx, cond), 
                 cg_expr (ctx, e1), 
                 cg_expr (ctx, e2))

        | E_try_with (body, exn, handler) =>
          def body = cg_expr (ctx, body);
          // FIXME: this is broken for exn values to go into closure
          def (ctx', v) = store_local (ctx, exn, CE_none ());
          def handler = cg_expr (ctx', handler);
          CE_try_with (body, v, handler)

        | E_try_finally (e1, e2) =>
          CE_try_finally (cg_expr (ctx, e1), cg_expr (ctx, e2))

        | E_literal (l) => 
          CE_literal (l)

        | E_this => 
          CE_this ()

        | E_type_conversion (e, t) => 
          CE_cast (cg_expr (ctx, e), cg_type (t))

        | E_type_enforcement (e, _) =>
          cg_expr (ctx, e)

        | E_sequence (e1, e2) =>
          CE_sequence (List.cons (cg_expr (ctx, e1), cg_expr (ctx, e2)))

        | E_tuple (l) =>
          CE_tuple_ctor (List.map (self, l))
      }
    }

  cg_expr (ctx : CTX, ex : Expr) : CG_expr {
    Util.locate (ex.loc, fun () : CG_expr {
        def e = raw_cg_expr (ctx, ex);
        e.loc <- ex.loc;
        e
      })
  }

  fixup_function (f : M_function) : CM_method
    {
      def m = lookup_function (f.header);
      m.attrs <- cg_attrs (f.modifiers);
      def fd = Env.global_by_id (f.id);
      def ti = f.tyinfo;
      match (f.kind) {
        | FK_bound_method => ()
        | FK_method => Util.ice ()
        | FK_static_ctor => 
          {
            m.name <- ti.basename ();
            m.ret_type <- CT_unreached ();
            m.attrs <- Cons ("static", Nil ())
          }
        | FK_ctor => 
          {
            m.name <- ti.basename ();
            m.ret_type <- CT_unreached ()
          }
        | FK_function => make_static (m)
        | FK_iface_method => Util.ice ()
      };
      m
    }

  mangle (s : string) : string = 
    extern "Nemerle.Compiler.CS_glue.mangle";

  decl_uniq_name (d : Decl) : string {
    mangle (d.name) + "_" + string_of_int (d.id)
  }

  prepare_ctx_for_fun (ctx : CTX, fn : Decl) : CTX
    {
      def mk_clo_fld (d : Decl) : CG_member
        {
          def f = CM_field (cg_type (d.ty));
          f.name <- decl_uniq_name (d);
          f.attrs <- Cons ("internal", Nil ());
          f.loc <- d.loc;
          f
        }
  
      def mk_clo_var (clo_vars : Int_map (CM_field), d : Decl, v : CG_member) 
                     : Int_map (CM_field) {
        clo_vars.add (d.id, (v :> CM_field))
      }
    
      def ctx =
        {
          def h = fn.fun_header ();
          if (h.closure_vars == null) Util.ice () else ();
          match (h.closure_vars) {
            | Nil => 
              def ctx = copy_ctx (ctx);
              ctx.current_closure <- None ();
              ctx

            | Cons =>
              def fields = List.map (mk_clo_fld, h.closure_vars);
              def clovars = List.fold_left2 (mk_clo_var, ctx.closure_fields, 
                                             h.closure_vars, fields);
              def cloclass = (CM_class ("", CK_class (), Nil (), fields) :> CM_class);
              def cloclname = "_N_cl_" + decl_uniq_name (fn);
              def clotype = CT_ref (cloclname);
              def cloexpr = CE_call (CE_ctor_ref (cloclass), Nil ());
              def cloval = CG_val (fn.loc, "_N_closure", clotype, cloexpr);
              def ctx = copy_ctx (ctx);

              cloclass.name <- cloclname;
              cloclass.loc <- fn.loc;
              closures <- Cons ((cloclass : CG_member), closures); // push it
              ctx.closure_fields <- clovars;
              ctx.current_closure <- Some (cloval);
              ctx
          }
        };
        
      ctx.closure_ptrs <- Map.int_map ();
      ctx.locals <- Map.int_map ();
      ctx.current_fun <- fn;
      ctx
    }

  get_fn_header (fn : Decl) : Fun_header {
    match (fn.kind) {
      | D_local_fun (h, _) => h
      | D_class_member (M_function {header = h}) => h
      | _ => Util.ice ()
    }
  }

  make_lambda_class (ctx : CTX, fn : Decl) : CM_class
    {
      def h = get_fn_header (fn);
      def funty = CT_fun (List.length (h.parms));
      def lambdaclass = CM_class ("", CK_class (), List.cons (funty), Nil ());
      lambdaclass.name <- decl_uniq_name (fn);
      (lambdaclass :> CM_class)
    }

  make_lambda_ctor (ctx : CTX, fn : Decl, cl : CM_class) : CG_expr
    {
      def pars =
        match (fn.kind) {
          | D_local_fun (_, pars) => pars
          | _ => Nil ()
        };
      def loop (acc : list (CG_expr), fn : Decl) : list (CG_expr) {
        match ((fn.fun_header ()).closure_vars) {
          | Cons => Cons (closure_ref (ctx, fn), acc)
          | Nil => acc
        }
      }
      CE_call (CE_ctor_ref (cl), List.fold_left (loop, Nil (), pars))
    }

  fill_lambda_class (ctx : CTX, fn : Decl, body : Expr, lambdaclass : CM_class) : void
    {
      def make_ctor (mems : list (CG_member)) : CG_member
        {
          def mkparm (f : CG_member) : CG_val {
            CG_val (loc = f.loc, name = f.name,
                    ty = (f :> CM_field).ty, val = CE_none ())
          }
          def mkassign (p : CG_val, f : CG_member) : CG_expr {
            CE_assign (CE_field_ref (CE_this (), (f :> CM_field)), CE_ref (p))
          }
            
          def parms = List.map (mkparm, mems);
          def assigns = List.map2 (mkassign, parms, mems);
          def meth = CM_method (parms, CT_unreached (), CE_sequence (assigns));
          meth.name <- decl_uniq_name (fn);
          meth.attrs <- Cons ("internal", Nil ());
          meth
        }
        
      def (hd, meth, pars) = 
        match (fn.kind) {
          | D_local_fun (h, pars) => (h, lookup_function (h), pars)
          | _ => Util.ice ()
        };

      def ctx = prepare_ctx_for_fun (ctx, fn);
      def mkcloptr (acc : list (CG_member), fn : Decl) : list (CG_member) {
        match ((fn.fun_header ()).closure_vars) {
          | Cons => 
            def clotype = CT_ref ("_N_cl_" + decl_uniq_name (fn));
            def fld = CM_field (clotype);
            fld.name <- decl_uniq_name (fn);
            ctx.closure_ptrs <- ctx.closure_ptrs.add (fn.id, (fld :> CM_field));
            Cons (fld, acc)
          | Nil => acc
        }
      }
      def fields = List.fold_left (mkcloptr, Nil (), pars);
      def set_obj_parm (v : CG_val) : void { v.ty <- CT_object () }
      def members = Cons (make_ctor (fields), Cons ((meth : CG_member), fields));
      
      lambdaclass.decls <- members;
      List.iter (set_obj_parm, meth.parms);
      meth.name <- "apply";
      meth.attrs <- List.cons ("public");
      meth.ret_type <- CT_object ();
      meth.body <- cg_fun_body (ctx, hd, meth, body)
    }

  cg_fun_body (ctx : CTX, hd : Fun_header, meth : CM_method, body : Expr) : CG_expr
    {
      def ctx' = copy_ctx (ctx);
      mutable assigns <- Nil ();
      mutable vals <- Nil ();
      
      def loadparm (parm_val : CG_val, fp : Fun_parm) : void
        {
          def parm = fp.decl;
          def needed_type = cg_type (fp.decl.ty);
          def need_downcast =
            match ((needed_type, parm_val.ty)) {
              | (CT_object, CT_object) => false
              | (_, CT_object) => true
              | _ => false
            };

          if (parm.in_closure) {
            def a =
              CE_assign (val_ref (ctx, parm), 
                         if (need_downcast) 
                           CE_cast (CE_ref (parm_val), needed_type)
                         else CE_ref (parm_val));
            assigns <- Cons (a, assigns)
          } else {
            def v =
              if (need_downcast) {
                def v = CG_val (loc = fp.decl.loc, 
                                name = "_N_" + parm_val.name + "_" + 
                                       string_of_int (Util.next_id ()),
                                ty = needed_type, 
                                val = CE_cast (CE_ref (parm_val), needed_type));
                vals <- Cons (v, vals);
                v
              } else parm_val;
            ctx'.locals <- ctx'.locals.add (parm.id, v)
          }
        }

      def store_this (d : Decl) : void {
        match (d.kind) {
          | D_closurised_this_ptr =>
            if (d.in_closure)
              assigns <- Cons (CE_assign (val_ref (ctx, d), CE_this ()), assigns)
            else ()
          | _ => ()
        }
      }

      List.iter2 (loadparm, meth.parms, hd.parms);
      List.iter (store_this, (ctx.current_fun.fun_header ()).closure_vars);
      
      def body = cg_expr (ctx', body);
      def buildlet (e : CG_expr, v : CG_val) : CG_expr { CE_let (v, e) }
      def body =
        List.fold_left (buildlet, 
                        CE_sequence (List.rev (Cons (body, assigns))),
                        vals);
                        
      match (ctx.current_closure) {
        | Some (v) => CE_let (v, body)
        | None => body
      };
    }

  cg_global_fun (ctx : CTX, fn : Decl, body : Expr) : CG_member
    {
      def ctx = prepare_ctx_for_fun (ctx, fn);
      def (hd, meth) =
        match (fn.kind) {
          | D_class_member (M_function f) => (f.header, fixup_function (f))
          | _ => Util.ice ()
        };
      meth.body <- cg_fun_body (ctx, hd, meth, body);
      meth
    }
    
  cg_header (h : Fun_header) : CM_method
    {
      def mkparm (p : Fun_parm) : CG_val {
        CG_val (loc = Location_stack.top (),
                name = p.name, 
                ty = cg_type (p.ty),
                val = CE_none ())
      }
      def m = CM_method (parms = List.map (mkparm, h.parms), 
                         ret_type = cg_type (h.ret_type),
                         body = CE_none ());
      m.name <- h.name;
      (m :> CM_method)
    }

  cg_attrs (mods : list (Modifier)) : list (string)
    {
      def cg_attr (a : Modifier) : string {
        match (a) {
          | Mod_public => "public"
          | Mod_private => "private"
          | Mod_new => "new"
          | Mod_protected => "protected"
          | Mod_internal => "internal"
          | Mod_abstract => "abstract"
          | Mod_sealed => "sealed"
          | Mod_static => ""
        }
      }
        
      def is_public (m : Modifier) : bool {
        match (m) { Mod_public => true | _ => false }
      }
      def is_priv (m : Modifier) : bool {
        match (m) { Mod_private => true | Mod_protected => true | _ => false }
      }

      def mods =
        if (List.exists (is_public, mods)) mods
        else if (List.exists (is_priv, mods)) mods
        else Cons (Mod_public (), mods);
        
      List.map (cg_attr, mods);
    }

  make_static (m : CG_member) : void {
    m.attrs <- Cons ("static", m.attrs)
  }

  cg_decl (decl : Class_member) : list (CG_member) {
    Util.locate (decl.loc, fun () : list (CG_member) {
      match (decl) {
        | M_value v => 
          def v' = lookup_value (v);
          match (v.kind) {
            | Val_normal =>
              List.cons ((v' : CG_member))
            | Val_extern (n) =>
              {
                v'.extern_name <- n;
                Nil ()
              }
          }

        | M_field v => List.cons ((lookup_field (v) : CG_member))

        | M_function f =>
          match (f.body) {
            | FB_extern (n) =>
              def m = lookup_function (f.header);
              m.extern_name <- n; 
              Nil ()
            | FB_parsed_expr => Util.ice ()
            | FB_typed_expr (body) =>
              def decl = Env.global_by_id (f.id);
              CGexpr.closures <- Nil ();
              def mem = cg_global_fun (empty_ctx (), decl, body);
              match (f.kind) {
                | FK_bound_method (impl) =>
                  def mkparm (ifp : CG_val, methp : CG_val) : CG_expr {
                    CE_cast (CE_ref (ifp), methp.ty)
                  }
                  def make_impl_wrapper (d : Decl) : CG_member {
                    match (d.kind) {
                      | D_class_member (M_function f) =>
                        def mem = (mem :> CM_method);
                        def m = cg_header (f.header);
                        m.body <- CE_call (CE_method_ref (CE_this (), mem),
                                           List.map2 (mkparm, m.parms, mem.parms));
                        m.name <- f.tyinfo.name + "." + f.name;
                        m
                      | _ => Util.ice ()
                    }
                  }
                  List.append (List.map (make_impl_wrapper, impl), 
                               Cons (mem, CGexpr.closures))
                | _ => 
                  Cons (mem, CGexpr.closures)
              }
            | FB_abstract =>
              List.cons ((fixup_function (f) :> CG_member))
          }
      }})
  }
  
  cg_list_decl (decls : list (Class_member)) : list (CG_member) {
    List.concat (List.map (cg_decl, decls))
  }
    
  cg_list_tydecl (decls : list (Tyinfo)) : list (CG_member)
    {
      def f (x : Tyinfo) : list (CG_member) {
        List.map (fun (x : CM_class) : CG_member { x }, cg_tydecl (x))
      }
      List.concat (List.map (f, decls))
    }
    
  cg_tydecl (ti : Tyinfo) : list (CM_class)
    {
      def make_cm (decl : Tyinfo, kind : CM_kind) : CM_class
        {
          def r = lookup_class (decl);
          r.kind <- kind;
          r
        }

      def members = ti.member_list;
      
      match (ti.tydecl) {
        | TD_interface =>
          def mkmember (m : Class_member) : CG_member {
            match (m) {
              | M_function {kind = FK_iface_method (new_flag); header = h} =>
                def m = cg_header (h);
                if (new_flag) m.attrs <- Cons ("new", m.attrs) else ();
                m
              | _ => Util.ice ()
            }
          }
          def cm = make_cm (ti, CK_interface ());
          cm.decls <- List.map (mkmember, members);
          List.cons (cm)

        | TD_variant =>
          def mkopt (m : Tyinfo) : CG_member {
            match (m.tydecl) {
              | TD_variant_option =>
                def cm = make_cm (m, CK_class ());
                cm.inheritance <- List.cons (cg_type (ti.generic_type ()));
                cm.decls <- cg_list_decl (m.member_list);
                cm
              | _ => Util.ice ()
            }
          }
          def cm = make_cm (ti, CK_class ());
          cm.decls <- List.map (mkopt, ti.contained_types);
          List.cons (cm)

        | TD_class =>
          def cm = make_cm (ti, CK_class ());
          cm.decls <- List.append (cg_list_tydecl (ti.contained_types), cg_list_decl (members));
          List.cons (cm)

        | TD_variant_option => Util.ice ()
          
        | TD_external => Nil ()
        // C# doesn't seem to provide typedef, not sure about CLS though
        | TD_alias => Nil () 
      }
    }
  
  set_extern_name (pref : string, decls : list (CG_member)) : void
    {
      def set_en (m : CG_member) : void 
        {
          if (m.extern_name == "")
            m.extern_name <- pref + m.name
          else ();
          match (m) {
            | CM_class c => set_extern_name (pref + c.name + ".", c.decls)
            | _ => ()
          }
        }
      List.iter (set_en, decls)
    }

  run () : list (CM_class)
    {
      mutable gres <- Nil ();
    
      def run_cg_tydecl (decl : Tyinfo) : void
        {
          def set_ns (cmc : CM_class) : void
            {
              cmc.ns <- decl.env.current_namespace;
              set_extern_name (cmc.ns, Cons ((cmc : CG_member), Nil ()))
            }
          def res = Util.locate (decl.loc, fun () : list (CM_class)  
                                              { cg_tydecl (decl) });
          List.iter (set_ns, res);
          gres <- Cons (res, gres)
        }
      
      cg_members <- Map.int_map ();
      Tyinfo.top_iter (run_cg_tydecl);
      List.concat (gres);
    }

} // end module
} // end ns
