open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Parsetree;
open Nemerle.Compiler.Extensions;

namespace Nemerle.Compiler {

  class Extensions
    {
      fun lc (ex : Expr) : Expr {
        letfun f (x : int, e : Expr) : int { 
          e#loc <- Location_stack.top (); x 
        } in {
          Treeutil.expr_walk (f, 0, ex);
          ex
        }
      }
      
      fun implicit_ctor (par : Type_decl, decls : list (Class_member)) : Class_member =
        letfun collect (acc : list (Expr) * list (Fun_parm), decl : Class_member) 
                        : list (Expr) * list (Fun_parm) =
          match decl with [
            | M_field (?t, _) =>
              let n = decl#name in
              let fp = Fun_parm (Location_stack.top (), n, t) in 
              let ex = E_assign (E_member (E_this (), n), E_ref (n)) in
              let (?es, ?ps) = acc in
              (Cons (ex, es), Cons (fp, ps))

            | _ => acc
          ]
        in 
        let (?assigns, ?parms) = List.fold_left (collect, (Nil (), Nil ()), decls) in
        let fh = Fun_header (Location_stack.top (), ".ctor", T_void (), List.rev (parms)) in
        let body = lc (E_sequence (assigns)) in
        let f = M_function (fh, FK_ctor (), FB_expr (body)) in {
          Tyvars.set_parms (fh#id, Nil ());
          Tyinfo.infos <- Tyinfo.infos#add (f#id, Tyinfo.lookup (par#id));
          f#modifiers <- Nil();
          f#name <- ".ctor";
          f#env <- par#env;
          match par with [
            | TD_variant_option =>
              Env.add_global (Env.strip_last_part (Tyinfo.td_name (par) + "."), f)
            | _ => ()
          ];
          Env.add_global (Tyinfo.td_name (par) + ".", f);
          f
        };
    }
  
} // end ns
