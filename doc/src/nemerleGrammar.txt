#
# Copyright (c) 2003 The University of Wroclaw.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#    1. Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    2. Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#    3. The name of the University may not be used to endorse or promote
#       products derived from this software without specific prior
#       written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
# NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

decl:
	"open" qid ";"
		Import all value and type names from namespace [qid] into current 
		namespace.
	"use" qid [ "." "*" ] ";"
	"namespace" qid "{" { decl } "}"
		Make all [decl] reside in namespace [qid].
	"namespace" ID "=" qid ";"
		Define an alias named [ID] for namespace [qid].
	type_decl

type_decl:
	attrs "class" ID type_parms inheritance class_body
		Define new class named [ID].
	attrs "struct" ID type_parms inheritance class_body
		Like class declaration, but instances of this type are passed by
		value, not by reference.
	attrs "module" ID type_parms class_body
		Define class that has no methods nor members, only static values
		and functions.
	attrs "interface" ID type_parms inheritance class_body
		Define interface. Interfaces can only contain method declarations.
	attrs "type" ID type_parms "=" "[" [ "|" ] datatype_ctor { "|" datatype_ctor } "]"
		Define discriminating union a.k.a. sum datatype.
	attrs "type" ID type_parms "=" type_expr ";"
		Define an alias for existing type.
	attrs "type" ID type_parms "=" "{" ID ":" type_expr { ";" ID ":" type_expr } [ ";" ] "}"
		Define record type. Syntactic sugar for 
		"class name { public member id1 : t1; ... }".
	attrs "exception" datatype_ctor ";" 
		Define exception. Syntactic sugar for "class name : System.Exception { ... }".

type_parms:
	[ "(" TYVAR { "," TYVAR } ")" [ "where" TYVAR ":" type_app { "," TYVAR ":" type_app } ] ]
		Formal parameters of type. Each type variable can be restricted
		to subtypes of given class or interface.

inheritance:
	[ ":" type_app { "," type_app } ]
		Name type class inherits (first type, or none if first type is 
		interface), and interfaces it implements (following types).

qid:
	{ ID "." } ID
		Identifier qualified with namespace.

class_body:
	"{" { class_decl } "}"

datatype_ctor:
	ID 
	ID "of" type_expr
	ID "of" class_body
		Member of discriminating union.

class_decl:
	attrs "member" qid [ ":" type_expr ] [ "=" expr ] ";"
		Define instance value of given class. Not allowed in interfaces nor
		modules. Additionally member can be enforced to have given type
		and initialized.
	attrs "method" [ "rec" ] qid method_body
		Define instance method. Qualified identifier can be used to resolve
		which interface method will conform to. Not allowed in interfaces nor
		modules.
	attrs "method" qid ":" type_expr ";"
		Define virtual method with no implementation. This is the only thing
		allowed in interface.
	attrs "value" qid [ ":" type_expr ] [ "=" expr ] ";"
		Define class (static) value, optionally enforce type and initialize.
	attrs "value" [ "rec" ] qid method_body
		Define class (static) function.
	attrs "value" [ "rec" ] "(" overloaded_operator ")" method_body
		Overload operator.

block:
	"{" [ expr { ";" expr } [ ";" ] ] "}"
	
method_body:
	"(" formal_parms ")" "=" expr ";"
	"(" formal_parms ")" block
	matching

formal_parms:
	[ ID [ ":" type_expr ] { "," ID [ ":" type_expr ] } ]
		If types of formal parameters are omitted, they are inferred.

primary_type_expr:
	TYVAR
	type_app
	"(" type_expr ")"

type_expr:
	primary_type_expr
	primary_type_expr {+ "*" primary_type_expr }+
		Tuple type.
	type_expr "->" type_expr
		Function type.
	"mutable" type_expr

type_app:
	qid [ "(" type_expr { "," type_expr } ")" ]

primary_expr:
	"(" expr  ")"
	"(" expr ":" type_expr ")"
		Enforce expression to have given type. It does not perform any
		conversion, it only affects type inference algorithm.
	"(" expr ":>" type_expr ")"
		Type coercion (cast).
	qid
	"(" ")"
		Constant of type "void".
	NUMBER_LITERAL
	STRING_LITERAL
	"true"
	"false"
	"null"
	primary_expr "#" qid
		Member access.
	primary_expr "[" expr { "," expr } "]"
		Array/string indexing.

expr:
	primary_expr
	block
	binary
	unary
	primary_expr call_parms
		Call.
	"fun" "(" formal_parms ")" "->" expr
		Lambda expression.
	"fun" matching
		Syntactic sugar for: "fun (x) -> match x with ...".
	"(" expr {+ "," expr }+ ")"
		Tuple value.
	"if" expr "then" expr "else" expr
	"match" expr "with" matching
	"let" bindings "in" expr
	"let" "rec" bindings "in" expr
	primary_expr "<-" expr
		Assignment.
	"raise" primary_expr call_parms
	"try" expr "with" matching
	"{" qid "=" expr { ";" qid "=" expr } [ ";" ] "}"
		Record expression.
	"{" expr "with" qid "=" expr { ";" qid "=" expr } [ ";" ] "}"
		Record copy with update.
	"[" [ expr { ";" expr } [ ";" ] ] "]"
		List expression.
	"[|" expr { ";" expr } [ ";" ] "|]"
		Array expression.
	"while" expr block
	"for" ID "=" expr "to" expr block
	"for" ID "=" expr "downto" expr block

call_parms:
	"(" [ expr { "," expr } ] ")"

binary:
	expr "+" expr
	expr "-" expr
	expr "*" expr
	expr "/" expr
	expr "%" expr
	expr "::" expr
		List construction.
	expr "||" expr
	expr "&&" expr
	expr "<" expr
	expr ">" expr
	expr "<=" expr
	expr ">=" expr
	expr "==" expr
	expr "!=" expr

overloaded_operator:
	"+"
	"-"
	"*"
	"/"
	"%"
	"::"
	"||"
	"&&"
	"<"
	">"
	"<="
	">="
	"=="
	"!="

unary:
	"-" expr
	"not" expr
	"ref" expr
		Pass mutable value as reference. Allowed only in function
		call parameters.

matching:
	"[" [ "|" ] pattern "->" expr { "|" pattern "->" expr } "]" 

binding:
	ID [ ":" type_expr ] "=" expr
	ID "(" formal_parms ")" "=" expr
	ID "(" formal_parms ")" block
	ID matching
	"(" ID {+ "," ID }+ ")" "=" expr

bindings:
	binding { "and" binding }
		Make bindings simultaneously.
	binding { ";" binding }
		Make bindings sequentially.

primary_pattern:
	"_"
		Match-all pattern.
	"(" ")"
	"(" pattern [ ":" type_expr ] ")"
	"(" pattern {+ "," pattern }+ ")"
		Tuple pattern.

pattern:
	pattern "as" "?" ID
		Give name to pattern.
	"?" ID
		Pattern variable.
	qid
	qid primary_pattern
	"{" qid "=" pattern { ";" qid "=" pattern } [ ";" ] "}"
	"[" [ pattern { ";" pattern } [ ";" ] ] "]"
	pattern "::" pattern
	pattern "when" expr
	pattern "|" pattern

attr:
	"public" 
	"protected"
	"internal"
	"private"
	"new"
	"sealed" 
	"abstract"
	"mutable"
	"override"
	"virtual"

attrs:
	{ attr }

# vim: ai ft=conf ts=4
