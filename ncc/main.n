/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is the main compiler file. But all it does it running parser
 * (parser.n) and transferring control to Passes.run function (from
 * passes.n).
 *
 * Main file also catches some exceptions.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

[assembly: System.Reflection.AssemblyTitle("Nemerle Language Compiler")]
[assembly: System.Reflection.AssemblyDescription("Nemerle (http://nemerle.org) Language Compiler")]
[assembly: System.Reflection.AssemblyCompany("University of Wroclaw")]
[assembly: System.Reflection.AssemblyProduct("Nemerle Language Compiler")]
[assembly: System.Reflection.AssemblyCopyright("Copyright @ University of Wroclaw 2003, 2004")]

[assembly: System.Reflection.AssemblyVersion("0.2.1.99")]
[assembly: System.Reflection.AssemblyKeyFile("../misc/keys/Nemerle.Compiler.snk")]

namespace Nemerle.Compiler 
{
  module MainClass
  {
    public Main () : void
    {
      Message.InitOutput (System.Console.Out);
      try {
        do_main ()
      } catch {
        | e : System.IO.FileNotFoundException =>
          Message.error (e.Message)
        | e : Recovery =>
          bomb (e, "got Recovery exception")
        | e : BailOutException =>
          bomb (e, "got bail out exception")
        | e : System.ArgumentException =>
          bomb (e, "got ArgumentException (" + e.Message + ")")
        | e : MatchFailureException =>
          bomb (e, "got MatchFailureException exception")
        | e : ICE =>
          bomb (e, e.msg)
        | e : AssertionException =>
          bomb (e, e.Message)
        | e : AssemblyFindException =>
          Message.error (e.Message);
          System.Environment.Exit (3);
        | e : System.Exception =>
          bomb (e, "got some unknown exception " + e.Message)
      };

      Message.maybe_bailout();
    }
    
    bomb (e : System.Exception, msg : string) : void
    {
      Passes.KillProgressBar ();
      Message.maybe_bailout (true);
      Message.error (sprintf ("internal compiler error: %s\n%s\n", msg, e.StackTrace));
      System.Environment.Exit (2);
    }

    do_main () : void {
      mutable files = [];

      def print_version () {
        System.Console.Error.Write ("Nemerle Compiler (ncc) version 0.2.1.99 (SVN)\n"
                                    "(c) 2003, 2004 University of Wroclaw,"
                                    " All rights reserved.\n");
        System.Environment.Exit (0);
      };

      mutable help_opts = [];                  
      def print_help () {
        System.Console.WriteLine (Getopt.Usage (help_opts));
        System.Environment.Exit (0);
      };

      def split_opt (s) {
        if (s == null)
          []
        else {
          def split = NString.Split (s, array [' ', '\t', '\n', '\r']);
          def split = List.Map (split, fun (x : string) { x.Trim () });
          List.Filter (split, fun (x) { x != "" })
        }
      };
      
      def execute_pkgconfig (opt : string) {
        def pkg = System.Diagnostics.Process ();
        pkg.StartInfo.FileName = "pkg-config"; 
        pkg.StartInfo.Arguments = ("--libs " + opt);
        pkg.StartInfo.RedirectStandardOutput = true;
        pkg.StartInfo.RedirectStandardError = true;        
        pkg.StartInfo.UseShellExecute = false;
        mutable result = "";
        try {
          ignore (pkg.Start ());
          result = pkg.StandardOutput.ReadLine ();
          pkg.WaitForExit ();
        } catch { 
          | _ : System.Exception =>
            Message.warning ("pkg-config execution failed")
        };
        match (split_opt (result)) {
          | [] => ["-r", opt]
          | x => x
        }
      };
      def execute_fromfile (s : string) {
        try {
          // Create an instance of StreamReader to read from a file.
          // The using statement also closes the StreamReader.
          mutable result = "";
          using (sr = System.IO.StreamReader(s))
            result = sr.ReadToEnd ();
          split_opt (result)
        } catch {
          | _ : System.Exception =>
            Message.error ("cannot read response file `" + s + "'");
            []
        }  
      };

      def set_target (_) {
        | "winexe"
        | "wexe"
        | "win" =>
          Options.TargetIsLibrary = false;
          Options.TargetIsWinexe = true;
        | "lib"
        | "library"
        | "dll" =>
          Options.TargetIsLibrary = true;
        | "exe"
        | "console" =>
          Options.TargetIsLibrary = false;
          Options.TargetIsWinexe = false;
        | x =>
          Getopt.Error ($ "invalid target `$(x)'");
          System.Environment.Exit (1);
      }

      def opts = [
        Getopt.CliOption.String (name = "-doc", 
                     aliases = [], 
                     help = "Output XML documentation of program's class hierarchy",
                     handler = fun (x) { 
                       Options.XmlDoc = true;
                       XmlDoc.OutputFileName = x;
                       LexerFile.store_comments = true;
                     }),
        Getopt.CliOption.String (name = "-target", 
                     aliases = ["-t"],
                     help = "Specifies the target (exe, library, winexe)",
                     handler = set_target),
        Getopt.CliOption.String (name = "-out",
                       aliases = ["-o"],
                       help = "Output file name",
                       handler = fun (s) { Options.OutputFileName = s }),
        Getopt.CliOption.String (name = "-reference",
                       aliases = ["-r", "-ref"],
                       help = "Link specified assembly",
                       handler = fun (s) { Options.ReferencedLibraries = 
                         s :: Options.ReferencedLibraries
                       }),
        Getopt.CliOption.String (name = "-library-path",
                       aliases = ["-lib", "-L"],
                       help = "Add specified directory to library search path",
                       handler = LibraryReferenceManager.AddSearchDirectory),

        Getopt.CliOption.String (name = "-define",
                       aliases = ["-def", "-D"],
                       help = "Define preprocessor symbol for conditional compilation",
                       handler = fun (x) { LexerFile.command_defines.Set (x, true) }),

        Getopt.CliOption.String (name = "-resource",
                       aliases = ["-res"],
                       help = "Embed resource file to output",
                       handler = fun (x) {
                         CGIL.AddResource (x);
                       }),

        Getopt.CliOption.String (name = "-linkresource",
                       aliases = ["-linkres"],
                       help = "Link resource file from output assembly",
                       handler = fun (x) {
                         CGIL.AddLinkedResource (x);
                       }),

        Getopt.CliOption.Flag (name = "-debug", 
                     aliases = [],
                     help = "Enable debug symbols generation",
                     handler = fun () { Options.EmitDebug = true; }),
                       
        Getopt.CliOption.SubstitutionString (name = "-pkg-config",
                       aliases = ["-pkg", "-p"],
                       help = "Link to assemblies listed by pkg-config run on"
                              " given string",
                       substitute = execute_pkgconfig),

        Getopt.CliOption.SubstitutionString (name = "-from-file",
                       aliases = ["@"],
                       help = "Read command line options from given file", 
                       substitute = execute_fromfile),
                       
        Getopt.CliOption.Flag (name = "--dump-typed-tree", 
                     aliases = ["-dt"],
                     help = "Pretty prints the typed tree on stdout",
                     handler = fun () { Options.DumpTypedTree = true; }),
                     
        Getopt.CliOption.Flag (name = "-no-stdmacros",
                     help = "Do not load standard macros",
                     handler = fun () { Options.DoNotLoadMacros = true }),
        Getopt.CliOption.Flag (name = "-no-stdlib",
                     help = "Do not load Nemerle.dll",
                     handler = fun () { Options.DoNotLoadStdlib = true }),
        Getopt.CliOption.Flag (name = "-use-loaded-corlib",
                     help = "Use already loaded mscorlib.dll and System.dll",
                     handler = fun () { Options.UseLoadedCorlib = true }),
                          
        Getopt.CliOption.Flag (name = "-ignore-confusion",
                     help = "Output stack trace even when seen errors",
                     handler = fun () { Options.IgnoreConfusion = true }),
        Getopt.CliOption.Flag (name = "-throw-on-error",
                     help = "Output stack trace on first error",
                     handler = fun () { 
                       Options.ThrowOnError = true; 
                       Options.IgnoreConfusion = true; 
                     }),
        Getopt.CliOption.Flag (name = "-general-tail-call-opt",
                     aliases = ["-Ot"],
                     help = "Enable general tail call optimization",
                     handler = fun () { Options.GeneralTailCallOpt = true }),

        Getopt.CliOption.Flag (name = "-boolean-constant-matching-opt",
                     aliases = ["-Obcm"],
                     help = "Enable boolean constant matching optimization",
                     handler = fun () {
                       Options.ConstantBooleanMatchingOpt = true
                     }),
        Getopt.CliOption.Flag (name = "-ordinal-constant-matching-opt",
                     aliases = ["-Oocm"],
                     help = "Enable ordinal constant matching optimization",
                     handler = fun () {
                       Options.ConstantOrdinalMatchingOpt = true
                     }),
        Getopt.CliOption.Flag (name = "-string-constant-matching-opt",
                     aliases = ["-Oscm"],
                     help = "Enable string constant matching optimization",
                     handler = fun () {
                       Options.ConstantStringMatchingOpt = true
                     }),
      
        Getopt.CliOption.Flag (name = "-target-library",
                     aliases = ["-tdll"],
                     help = "Build a library [OBSOLETED by -t:]",
                     handler = fun () { Options.TargetIsLibrary = true; }),
        Getopt.CliOption.Flag (name = "-target-exe",
                     aliases = ["-texe"],
                     help = "Build an executable file [OBSOLETED by -t:]",
                     handler = fun () { Options.TargetIsLibrary = false; }),
                     
        Getopt.CliOption.Flag (name = "-no-color",
                     help = "Disable ANSI coloring of error/warning/hint messages",
                     handler = fun () { Options.ColorMessages = false }),
        Getopt.CliOption.Flag (name = "-pedantic-lexer",
                     help = "Enable some pedantic checks for illegal characters"
                     " in input stream",
                     handler = fun () { Options.PedanticLexer = true }),
        Getopt.CliOption.Flag (name = "-global-unused-symbols-warnings",
                     help = "Print the warnings about globally unused symbols",
                     handler = fun () { Options.GlobalUnusedSymbolsWarnings = true }),
        Getopt.CliOption.Flag (name = "-no-enum-flags-warnings",
                     aliases = ["-Wno-enum"],
                     help = "Do not print warnings about usage of bit operations"
                            " on enums without correct attribute",
                     handler = fun () { Options.EnumFlagsWarnings = false }),
        Getopt.CliOption.Flag (name = "-no-ignored-value-warnings",
                     aliases = ["-Wno-ignore"],
                     help = "Do not print warnings about ignoring computed values",
                     handler = fun () { Options.IgnoredValueWarnings = false }),
        Getopt.CliOption.Flag (name = "-no-progress-bar",
                     aliases = ["-q"],
                     help = "Disable progress bar",
                     handler = fun () { Options.ProgressBar = false; }),
        Getopt.CliOption.Flag (name = "-version",
                     aliases = ["-V"],
                     help = "Output version information and exit",
                     handler = print_version),
        Getopt.CliOption.Flag (name = "-help",
                     aliases = ["-h"],
                     help = "Display this usage message and exit",
                     handler = print_help),
        Getopt.CliOption.NonOption (name = "",
                          help = "Specify file to compile",
                          handler = fun (s) { files = s :: files })
      ];
      help_opts = opts;

      Getopt.Parse (opts);

      match (files) {
        | [] =>
          Getopt.Error ("need at least one file to compile\n" + Getopt.Usage (opts))
        | _ =>
          LibraryReferenceManager.Init ();

          def this_dir = typeof (MainClass).Assembly.Location;

          LibraryReferenceManager.AddSearchDirectory (
            LibraryReferenceManager.DirectoryOfCodebase (this_dir));

          // run compilation of given files
          Passes.Run (files)
      }
    }
  }
}
