/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

namespace Nemerle.Compiler {

public interface INumericType
{
  Zero : object { get; }
  One : object { get; }
  IsSigned : bool { get; }
  IsInteger : bool { get; }
  SystemType : System.Type { get; }
  Binary (is_checked : bool, op : string, x : object, y : object) : object;
  Unary (is_checked : bool, op : string, x : object) : object;
  FromLiteral (_ : Literal) : object;
  ToLiteral (_ : object) : Literal;
  GetNemerleType () : MType;
  GetTypeInfo () : TypeInfo;
}

public module NumericType
{
  types : Hashtable [string, INumericType];
  types_by_id : Hashtable [int, INumericType];
  
  public ByName (name : string) : option [INumericType]
  {
    types.Get (name)
  }

  public ByLiteral (lit : Literal) : option [INumericType]
  {
    def name =
      match (lit) {
        | Literal.Int => "System.Int32"
        | Literal.Long => "System.Int64"
        | Literal.SByte => "System.SByte"
        | Literal.Byte => "System.Byte"
        | Literal.Short => "System.Int16"
        | Literal.UShort => "System.UInt16"
        | Literal.UInt => "System.UInt32"
        | Literal.ULong => "System.UInt64"
        | _ => ""
      };
    types.Get (name)
  }

  public IsNumericType (tc : TypeInfo) : bool
  {
    types_by_id.Contains (tc.GetId ())
  }

  this ()
  {
    def type_list = [
      ("System.Int16", Int16 () : INumericType),
      ("System.UInt16", UInt16 () : INumericType),
      ("System.Int32", Int32 () : INumericType),
      ("System.UInt32", UInt32 () : INumericType),
      ("System.Int64", Int64 () : INumericType),
      ("System.UInt64", UInt64 () : INumericType),
      ("System.Double", Double () : INumericType),
      ("System.Single", Single () : INumericType),
      ("System.Byte", Byte () : INumericType),
      ("System.SByte", SByte () : INumericType),
      ("System.Char", Char () : INumericType)
    ];
    types = Hashtable ();
    types_by_id = Hashtable ();
    foreach ((name, ty : INumericType) in type_list)  { 
      types_by_id.Add (ty.GetTypeInfo ().GetId (), ty);
      types.Add (name, ty);
    }
  }

  public class Char : INumericType
  {
    public Zero : object
    {
      get { Util.ice ("invalid operation for char") } 
    }
    
    public One : object
    {
      get { Util.ice ("invalid operation for char") }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Char }
    }
    
    public Binary (_ : bool, _ : string, _ : object, _ : object) : object
    {
      Util.ice ("invalid operation for char")
    }

    public Unary (_ : bool, _ : string, _ : object) : object
    {
      Util.ice ("invalid operation for char")
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Char (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Char (x :> System.Char)
    }

    public GetNemerleType () : MType
    {
      InternalType.Char
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Char_tc
    }

    public this () {}
  }



// Begin generated code
// Please edit ../misc/gen-ints.n, and not this file
  public class SByte : INumericType
  {
    public Zero : object
    {
      get { 0B } 
    }
    
    public One : object
    {
      get { 1B }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.SByte }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.SByte);
      def y = (y :> System.SByte);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid SByte operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid SByte operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.SByte;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid SByte operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid SByte operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.SByte (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.SByte (x :> System.SByte)
    }

    public GetNemerleType () : MType
    {
      InternalType.SByte
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.SByte_tc
    }

    public this () {}
  }


  public class Byte : INumericType
  {
    public Zero : object
    {
      get { 0UB } 
    }
    
    public One : object
    {
      get { 1UB }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Byte }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.Byte);
      def y = (y :> System.Byte);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid Byte operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid Byte operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.Byte;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid Byte operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid Byte operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Byte (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Byte (x :> System.Byte)
    }

    public GetNemerleType () : MType
    {
      InternalType.Byte
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Byte_tc
    }

    public this () {}
  }


  public class Int16 : INumericType
  {
    public Zero : object
    {
      get { 0S } 
    }
    
    public One : object
    {
      get { 1S }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Int16 }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.Int16);
      def y = (y :> System.Int16);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid Short operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid Short operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.Int16;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid Short operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid Short operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Short (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Short (x :> System.Int16)
    }

    public GetNemerleType () : MType
    {
      InternalType.Int16
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Int16_tc
    }

    public this () {}
  }


  public class UInt16 : INumericType
  {
    public Zero : object
    {
      get { 0US } 
    }
    
    public One : object
    {
      get { 1US }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.UInt16 }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.UInt16);
      def y = (y :> System.UInt16);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid UShort operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid UShort operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.UInt16;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid UShort operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid UShort operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.UShort (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.UShort (x :> System.UInt16)
    }

    public GetNemerleType () : MType
    {
      InternalType.UInt16
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.UInt16_tc
    }

    public this () {}
  }


  public class Int32 : INumericType
  {
    public Zero : object
    {
      get { 0 } 
    }
    
    public One : object
    {
      get { 1 }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Int32 }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.Int32);
      def y = (y :> System.Int32);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid Int operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid Int operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.Int32;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid Int operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid Int operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Int (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Int (x :> System.Int32)
    }

    public GetNemerleType () : MType
    {
      InternalType.Int32
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Int32_tc
    }

    public this () {}
  }


  public class UInt32 : INumericType
  {
    public Zero : object
    {
      get { 0U } 
    }
    
    public One : object
    {
      get { 1U }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.UInt32 }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.UInt32);
      def y = (y :> System.UInt32);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid UInt operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid UInt operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.UInt32;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid UInt operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid UInt operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.UInt (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.UInt (x :> System.UInt32)
    }

    public GetNemerleType () : MType
    {
      InternalType.UInt32
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.UInt32_tc
    }

    public this () {}
  }


  public class Int64 : INumericType
  {
    public Zero : object
    {
      get { 0L } 
    }
    
    public One : object
    {
      get { 1L }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Int64 }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.Int64);
      def y = (y :> System.Int64);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid Long operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid Long operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.Int64;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid Long operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "-" => -x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid Long operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Long (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Long (x :> System.Int64)
    }

    public GetNemerleType () : MType
    {
      InternalType.Int64
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Int64_tc
    }

    public this () {}
  }


  public class UInt64 : INumericType
  {
    public Zero : object
    {
      get { 0UL } 
    }
    
    public One : object
    {
      get { 1UL }
    }

    public IsInteger : bool
    {
      get { true }
    }
    
    public IsSigned : bool
    {
      get { false }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.UInt64 }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.UInt64);
      def y = (y :> System.UInt64);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | "&" => (x %& y) :> object
          | "|" => (x %| y) :> object
          | "^" => (x %^ y) :> object
          | "%&" => (x %& y) :> object
          | "%|" => (x %| y) :> object
          | "%^" => (x %^ y) :> object
          | "<<" => (x << (y :> int)) :> object
          | ">>" => (x >> (y :> int)) :> object
          | _ => 
            null
            // Util.ice ("invalid ULong operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | "%&" => (x %& y) :> object
            | "%|" => (x %| y) :> object
            | "%^" => (x %^ y) :> object
            | "&" => (x %& y) :> object
            | "|" => (x %| y) :> object
            | "^" => (x %^ y) :> object
            | "<<" => (x << (y :> int)) :> object
            | ">>" => (x >> (y :> int)) :> object
            | _ => 
              null
              // Util.ice ("invalid ULong operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.UInt64;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "~" => ~x :> object
          | _ =>
            null
            // Util.ice ("invalid ULong operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "~" => ~x :> object
            | _ =>
              null
              // Util.ice ("invalid ULong operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.ULong (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.ULong (x :> System.UInt64)
    }

    public GetNemerleType () : MType
    {
      InternalType.UInt64
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.UInt64_tc
    }

    public this () {}
  }


  public class Single : INumericType
  {
    public Zero : object
    {
      get { 0.0F } 
    }
    
    public One : object
    {
      get { 1.0F }
    }

    public IsInteger : bool
    {
      get { false }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Single }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.Single);
      def y = (y :> System.Single);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | _ => 
            null
            // Util.ice ("invalid Float operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | _ => 
              null
              // Util.ice ("invalid Float operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.Single;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "-" => -x :> object
          | _ =>
            null
            // Util.ice ("invalid Float operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "-" => -x :> object
            | _ =>
              null
              // Util.ice ("invalid Float operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Float (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Float (x :> System.Single)
    }

    public GetNemerleType () : MType
    {
      InternalType.Single
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Single_tc
    }

    public this () {}
  }


  public class Double : INumericType
  {
    public Zero : object
    {
      get { 0.0 } 
    }
    
    public One : object
    {
      get { 1.0 }
    }

    public IsInteger : bool
    {
      get { false }
    }
    
    public IsSigned : bool
    {
      get { true }
    }
    
    public SystemType : System.Type {
      get { Nemerle.Compiler.SystemType.Double }
    }
    
    public Binary (is_checked : bool, name : string, x : object, y : object) : object
    {
      def x = (x :> System.Double);
      def y = (y :> System.Double);
      if (is_checked)
        match (name) {
          | "+" => (x + y) :> object
          | "-" => (x - y) :> object
          | "*" => (x * y) :> object
          | "/" => (x / y) :> object
          | "%" => (x % y) :> object
          | _ => 
            null
            // Util.ice ("invalid Double operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => (x + y) :> object
            | "-" => (x - y) :> object
            | "*" => (x * y) :> object
            | "/" => (x / y) :> object
            | "%" => (x % y) :> object
            | _ => 
              null
              // Util.ice ("invalid Double operator `" + name + "'")
          }
        }
    }

    public Unary (is_checked : bool, name : string, x : object) : object
    {
      def x = x :> System.Double;
      if (is_checked)
        match (name) {
          | "+" => +x :> object
        | "-" => -x :> object
          | _ =>
            null
            // Util.ice ("invalid Double operator `" + name + "'")
        }
      else
        unchecked {
          match (name) {
            | "+" => +x :> object
        | "-" => -x :> object
            | _ =>
              null
              // Util.ice ("invalid Double operator `" + name + "'")
          }
        }
    }

    public FromLiteral (lit : Literal) : object
    {
      | Literal.Double (x) => x : object
      | _ => null
    }

    public ToLiteral (x : object) : Literal
    {
      Literal.Double (x :> System.Double)
    }

    public GetNemerleType () : MType
    {
      InternalType.Double
    }

    public GetTypeInfo () : TypeInfo
    {
      InternalType.Double_tc
    }

    public this () {}
  }

// End generated code

}
} // end namespace
