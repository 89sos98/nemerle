\documentclass{article}
\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{polski}
\usepackage[latin2]{inputenc}

\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\kw}[1]{{\textcolor{kwcolor}{\tt #1}}}

\definecolor{kwcolor}{rgb}{0.2,0.4,0.0}
\definecolor{lgray}{rgb}{0.8,0.8,0.8}

\title{The Nemerle Project Report}
\author{Leszek Pacholski, Micha{\l} Moskal}

\begin{document}
\maketitle

\section{Introduction}

The objective of the Nemerle project is to create a high--level
general purpouse, statically typed, programming language. The language supports
object--oriented, functional and imperative programming paradigms.
The functional part is bundled with type inference and pattern matching.

The language was designed for the \net\ since the very beginning.
The design of the \net\ platform had great impact on it.

Another thing worth mentioning here is support for a powerful,
Turing--complete metaprogramming system, which is interesting from
both practical and theoretical point of view.

\section{Reasons}

\subsection{Why \net\ ?}

The \net\ platform was choosen because of several
pragmatical reasons. It provides a wide variety of libraries,
has reasonable support for multilanguage programming,
provides an efficient runtime environment (including a garbage
collector and Just--In--Time compiler) with the possibility
of generating code on the fly. Last but not least the executable
files genarated by the compiler are portable -- they can be used
on several architectures and operating systems using one
of the available implementations of the \net\ platform
(Microsoft \net, Mono, DotGNU, Rotor).

\subsection{Why a new language, from a user perspective?}

The idea that can attract users is the ability of easily
combining obiect--oriented design with functional implementations.
A user can design an application or a library at the high level using the
familar model known from C\# but implement the method bodies
in a functional style. This allows for smooth switch from object--oriented
to functional programming paradigm, in areas where it is more applicable.
Moreover the resulting library can be used from other object--oriented
\net\ languages without any additional hessle.

Nemerle doesn't force the programmer to use functional paradigm. It provides
easy access to both object--oriented and imperative features. User
can even choose to ignore functional features and program as he would
in C\#, with minor syntactic differences.

Back when the project started two years ago we had a far more ML--like
language than we have today. After a year of extensions, semantic and
syntactic changes we ended up creating something that could be called
Extended C\# with better functional programming support.

One of our goal was to ease code maintainance. We for example consider
type inference helpful here -- the idea is that the information that
can be thought out by the simple type inference algorithm is redundant
anyway and immedietly clear to the programmer. And reducing amount
of redundant information clearlt help with program readabilty, which in
turn helps code maintaince.

Another thing that can help with maintaince is wise use of macros. They
provide a way to avoid repetitive code, which should help both with
readability. Additionaly, a macro once tested will always produce correct
code, which one cannot tell about a programmer coding the same SQL 
query execution over and over again.

\subsection{Why a new language, from a computer scientist perspective?}

From the computer scientist point of view there can be only one
main reasons for creating programming languages: to experiment.

Main areas here was the meta--programming system, type inference
algorithms for class--based object--oriented languages, and programming
language design in general.

Another good reason was to excercise and experiment with 
System.Reflection.Emit especially with respect to generation
of code using generics. We actully have found quite a few of
limitations there.


\subsection{Type inference with deferral}

One of the outcomes of the project is a novel type inference algorithm
for class based object--oriented languages. It was the topic of Michal
Moskal's MSc thesis.

The main idea behind the algorithm is to defer certain typing actions
(like object member and overload resolution) until enough information
is given.

For example in the following snippet:
\begin{verbatim}
   def call_foo (x) { x.foo () }
   someList.Iter (call_foo)
\end{verbatim}
one cannot easily type \texttt{x.foo} by looking just at the
\texttt{call\_foo} function definition, because there can be
more than one class with a member called \texttt{foo}.

A similar, yet slightly different, example is:
\begin{verbatim}
   def my_add (x, y) { x + y }
   my_add (2, 3)
\end{verbatim}
where the symbol \texttt{+} cannot be resolved without
first guessing \texttt{x} and \texttt{y} types.

However in both examples it is easy to find out the correct
types by looking at how the function is used. So the idea would be
to leave typing actions depending on yet unknown types for later.
They are stored in a queue and executed after typing of method body
is done.

Experimentation shows this works quite well in practice. The need for
type annotations has been greatly reduced. There virtually no cases
where annotations are required on local function parameters.

The type inference algorithm has to take macros into account. For
example the \texttt{foreach} macro needs to known the type of collection
it is iterating over to generate proper code. We resolve this issue
by leaving up to the macro the decision if it has enough information,
or if it wants to defer parts of its execution for later, when
more typing information is available.

\section{Macros}

Very important outcome of the Nemerle project is mature meta--programming
system. It featres macros -- dynamically loaded compiler modules,
that can transform, generate and analyse programs.

Macros have broad possibilities of interaction with the compiler.
They can alter the parser to extend the syntax of the language.
There are several possibilites here:
\begin{itemize}
\item let macro invocation look like a regular function invocation,
      this is the default, no special rules are required
\item add a yacc--like rule, for example
\begin{verbatim}
syntax ("return", Optional (expr))
syntax ("if", "(", cond, ")", e1, Optional (";"), "else", e2)
\end{verbatim}
\item add a yacc--like rule with special RawToken parameter,
      which allows a list of lexing symbols to be passed
      to the macro and interpreted in any way, example invocation
      of such a macro would look like this:
\begin{verbatim}
def mydoc = xml <foo bar="baz">Qux<nux/></foo>;
\end{verbatim}
   the tokens after \texttt{xml} are not a valid Nemerle expression
   though they are lexically valid, so macro can process them as it wish
\end{itemize}

Macros can also obtain information about types of objects they are
working on. This can (and should to get proper user experience) be 
combined with deferal, as explained later.

As macros are regular Nemerle programs they can read external
files, connect to databases  and in general do almost anything.
This can be useful to for example generat classes from XML Schema,
or to check if given SQL query is valid and what would it return
at compile time.

One important, from both practical and theoretical, feature of the macro 
system is hygiene. It means that the macro system will protect accidential
name clashes between indetifiers introduced by the macro and by the user.
It is however still possible to break hygine if desired -- one example
would be string interpolation macro. It takes a string like 
\texttt{"foo x=\$bar"} and changes it to \texttt{"foo x=" + bar.ToString()}.
Here in the code generated by the macro the symbol \texttt{bar} should
capture name bound in the outer scope.

\subsection{Uses of macros}

Macros are good for implementation of small, domain specific sublanguages
of the host Nemerle language. Example such languages could be
regular expressions, XPath, XML itself, \texttt{printf} and \texttt{scanf}
\%--languages, SQL and so on. The macro can inspect the syntax
at compile time and report any error it finds. Later it can generate code,
or just pass it to some library functions.

Specialized sublanguages are often simpler to use than complex
API, therefore we see ease of implemntation of such languages
one of the main advantages of Nemerle in the Real World setting.

Another important use  are various extensions of the language
-- things expressible in the ``core'' language, but very often
used, therfore deserving a simple syntax. A good example is
the \texttt{foreach} loop, \texttt{using} expression or the
entire assertion system (simple \texttt{assert} macro together
with \texttt{requires}/\texttt{ensures} declarations for
Design by Contract). 

Yet another example is automatic implementation of various
design pattern (like the proxy pattern).

Macro system can be seen as an extended form of 
\textit{Aspect Oriented Programming}. It doesn't limit
itself to certain cut--points, or a limited set of actions
to be performed on the code though -- this can be seen as a 
disadvantage, as it may allow for too much flexibility on
the programmer side. It is however possible to write a set
of macros to restrict functionality to the regular AOP patterns. 

\subsection{Example use of macro}
This macro checks syntax and type validity of a query at compile-time
(by connecting to a database). It creates code, which uses {\tt SqlParameter}
to pass value of {\it myval} to {\tt SqlCommand} securely.

\begin{verbatim}
def myval = "Kate";
sqlloop ("SELECT * FROM employee WHERE"
         " firstname = $myval", dbcon) 
{
  printf ("%s %s\n", firstname, lastname)
}
\end{verbatim}


\section{The project}

The main part of the project is undoubtably the compiler.
There are however several releated subprojects that we will
discuss in this section.

\subsection{Compiler and language}

The most important things about the compiler are the
fact that it is bootstraping (which means it is written
in Nemerle and can compile itself) and it uses runtime
generics extensively.

The most recent version of the compiler is 0.9.0 released
on September 14th, 2005. It targets MS .NET August CTP
and Mono 1.1.9. Earlier versions of runtimes are not
supported because of numerous bugs in S.R.E. APIs.

\subsection{Projects using Nemerle}

\begin{itemize}
  \item Sioux -- HTTP/application server (founded from the grant)
  \item cs2n -- C\# to Nemerle converter (founded from the grant)
  \item nemish -- Nemerle Interactive Shell
  \item Speagram TRS programming system
  \item Asper IDE/editor
  \item NAnt build system plugin
  \item CodeDom generator (ASP.NET support)
  \item Code Completion Engine
  \item IDE integration (VS.NET, \#D, MD)
\end{itemize}


\subsection{Impact and community}

We believe we had some impact on both MS .NET and Mono runtimes
with our bugreports. We have reported several issues in S.R.E.
mostly related to generic code generation. We have also found one
serious bug in static field initialization in generic classes.
Even more issues were reported to the Mono team, as their
runtime is much less mature.

\subsubsection{Community}

We use a mailing list and (till recently) web forum for communication
and general community building. The mailing list has about 70 subscribers.
Our webpage is wiki--based, which makes external user contributions
in the documentation area easy. The contributions do happen.

Michal Moskal had a course about Nemerle at the Computer Science
Institute. We plan to start a free, open--for-all, online course
on October 1st.  


\subsection{TODO}

\begin{itemize}
  \item 1.0 stable release approaching
  \item more IDE integration
  \item more community building
  \item LINQ extensions
\end{itemize}

\end{document}

% vim: language=english
