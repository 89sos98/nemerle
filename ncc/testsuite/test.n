(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met :
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *) 


(* Requires $nempath/lib/hashtable.n, $nempath/lib/list.n, $nempath/lib/getopt.n and $nempath/lib/option.n *)
    
// NO-TEST

  open System;
  open System.Diagnostics;
  open System.ComponentModel;
  open System.IO;
  open System.Text.RegularExpressions;
  open System.String;
  open Nemerle.Collections;
  open Nemerle.Collections.List;
  open Nemerle.Utility;


  public class End_test extends System.Exception
  {
    public this () {}
  }

  public class Tester
  {

    private dnet_runtime : string;
    private nem_path : string;
    private dlls_path : string;
    private nem_runtime : string;
    private verbose : int;
    private no_test_regexp : Regex;
    private ref_regexp : Regex;
    private inc_regexp : Regex;
    private bo_regexp : Regex;  
    private eo_regexp : Regex;
    private bi_regexp : Regex;  
    private ei_regexp : Regex;
    private err_regexp : Regex;
    private warn_regexp : Regex;
    private ok_regexp : Regex;
    private get_short_filename : Regex;  
    private mutable no_test : bool;
    private mutable filename : string;
    private mutable filename_short : string;
    private mutable checked_msg : Hashtable (string, string);
    private mutable warn_lines : Hashtable (string, Regex);
    private mutable err_lines : Hashtable (string, Regex);
    private mutable err_overall_count : int;
    private mutable ok_lines : Hashtable (string, string);
    private mutable is_reading_output : bool;
    private mutable expected_output : list (string);
    private mutable ref_dlls : list (string);
    private mutable inc_files : list (string);
    private mutable was_output : bool;
    private mutable is_reading_input : bool;
    private mutable input : list (string);
    private mutable error_log : StreamWriter;
    private mutable was_error_header : bool;
    private mutable log_file_created : bool;

    public this (dnet_runtime : string, nem_path : string, dlls_path : string, nem_comp : string, verbose : int)
    {

      this.dnet_runtime <- dnet_runtime;
      this.nem_path <- nem_path;
      this.dlls_path <- dlls_path;
      this.nem_runtime <- nem_comp;
      this.verbose <- verbose;
      no_test_regexp <- Regex ("//\\s*NO-TEST");
      ref_regexp <- Regex ("//\\s*REFERENCE\\s{0,1}:\\s*(?<1>.*)$");
      inc_regexp <- Regex ("//\\s*INCLUDE\\s{0,1}:\\s*(?<1>.*)$");
      bo_regexp <- Regex ("^BEGIN-OUTPUT");  
      eo_regexp <- Regex ("^END-OUTPUT");  
      bi_regexp <- Regex ("^BEGIN-INPUT");  
      ei_regexp <- Regex ("^END-INPUT");  
      err_regexp <- Regex ("//\\s*E:\\s*(?<1>.*)$");
      err_overall_count <- 0;
      warn_regexp <- Regex ("//\\s*W:\\s*(?<1>.*)$");
      ok_regexp <- Regex ("//\\s*OK\\s{0,1}.*$");
      get_short_filename <- Regex ("(?<1>[^/]{1,}\\.n)$");
      error_log <- null;
      log_file_created <- false;
      Init ("");
      
   }

    private Init (filename : string) : void
    {
      checked_msg <- Hashtable ();
      this.filename <- filename;
      when (filename != "")
        filename_short <- get_short_filename.Match (filename).Groups[1].ToString ();
      warn_lines <- Hashtable ();
      err_lines <- Hashtable ();
      ok_lines <- Hashtable ();
      is_reading_output <- false;
      expected_output <- Nil ();
      ref_dlls <- Nil ();
      inc_files <- Nil ();
      was_output <- false;
      is_reading_input <- false;
      input <- Nil ();
      no_test <- false;
      was_error_header <- false;
      when (error_log!= null) 
      {
        error_log.Close ();
        error_log <- null
      }
    }

    private CheckLine (str : string, line_index : int) : void    
    {

      if (eo_regexp.IsMatch (str))
      {
        is_reading_output <- false
      }
      else
        if (ei_regexp.IsMatch (str))
        {
          is_reading_input <- false
        }
      else
        if (is_reading_output)
        {
          expected_output <- (str :: (expected_output))
        }
      else 
        if (is_reading_input)
        {
          input <- (str :: (input))
        }
        else 
        {
          def err_match = err_regexp.Match (str);
          if (err_match.Success)
          {
            err_lines.Add (string_of_int (line_index), Regex ((err_match.Groups[1]).ToString ()))
          }
          else
          {
            def warn_match = warn_regexp.Match (str);
            if (warn_match.Success)
            {
              warn_lines.Add (string_of_int (line_index), Regex (warn_match.Groups[1].ToString ()))
            }
            else
              if (bo_regexp.IsMatch (str))
              {
                is_reading_output <- true;
                was_output <- true
              } 
            else
              if (bi_regexp.IsMatch (str))
              {
                is_reading_input <- true
              } 
            else
              if (ok_regexp.IsMatch (str))
              {
                ok_lines.Add (string_of_int (line_index), "")
              }
            else
            {
              def ref_match = ref_regexp.Match (str);
              if (ref_match.Success)
                ref_dlls <- ref_match.Groups[1].ToString () :: ref_dlls
              else 
              {
                def inc_match = inc_regexp.Match (str);
                if (inc_match.Success)
                  inc_files <- inc_match.Groups[1].ToString () :: inc_files
                else
                  when (no_test_regexp.IsMatch (str))
                    raise End_test ()
              }
            }
          }
        }      
    }

    private GetLineAndMsgType (out_str : string) : int*string
    {
      def out_line_match = (Regex (":(?<1>\\d*):\\d*:\\s+(?<2>.*)$")).Match (out_str);
      if (out_line_match.Success) 
      {
        def line_number = ((out_line_match.Groups[1]).ToString ());
        def msg_type_str = ((out_line_match.Groups[2]).ToString ());
        if (msg_type_str.IndexOf ("error:") != (- 1))
          (0, line_number)
        else
          if (msg_type_str.IndexOf ("warning:") != (- 1))
            (1, line_number)
        else 
            (- 1, line_number)
      }
      else
      {
        (- 1, "")
      }
    }

    private HandleMsg (out_str : string) : bool
    {
      match (GetLineAndMsgType (out_str)) {
        | (0, line) =>  
            match (err_lines.Get (line)) {
              | Some (err) => 
                  when (err.Match (out_str).Success && (!checked_msg.Contains (line)))
                    checked_msg.Add (line, "");
                  true          
              | None => 
                  if ((err_lines.Count ()) == 0)
                    false
                  else
                  {
                    match (ok_lines.Get (line)) {
                      | Some (_) => false
                      | None => true
                    }
                  }
            }
        | (1, line) =>
            match (warn_lines.Get (line)) {
              | Some (warn) =>
                  when (warn.Match (out_str).Success && (!checked_msg.Contains (line)))
                    checked_msg.Add (line, "");
                  true
              | None => (warn_lines.Count () != 0)
            }
        | _ => true
      }     
    }

    private NemerleTest () : bool
    {
      mutable nem_compile <- Process ();
      def args =
            if (dnet_runtime.Length > 0) 
            {
              nem_compile.StartInfo.FileName <- dnet_runtime; 
              nem_runtime + " " 
            } 
            else
            {
              nem_compile.StartInfo.FileName <- nem_runtime;
              "" 
            };
           

      def add_dll_ref (acc, f)
          {
            acc + " -reference:"+ dlls_path + f
          };
      def args = List.fold_left (add_dll_ref, args, ref_dlls);
      def add_library_file (acc, f) 
          {
            acc + " " + nem_path + "/lib/" + f
          };
      def args = List.fold_left (add_library_file, args, 
          ["core.n"; "aliases.n"; "list.n"; "input.n" ; "tree.n" ; "icollection.n" ; "getopt.n"; "queue.n"; 
    "stack.n"; "hashtable.n" ; "option.n"; "linkedlist.n"]);
      def add_include_file (acc, f)
          {
            acc + " " + f;
          };
      def args = List.fold_left (add_include_file, args, inc_files);
      def args =
            if (was_output)
              args + " -out:out.exe -texe"
            else
              args + " -out:out.dll -tdll";
      nem_compile.StartInfo.Arguments <- (args + " " + filename);
      nem_compile.StartInfo.RedirectStandardOutput <- true;
      nem_compile.StartInfo.UseShellExecute <- false;
      try 
      {
        def _ = nem_compile.Start ();
        mutable nem_output <- nem_compile.StandardOutput.ReadLine ();
        nem_compile.WaitForExit ();
        mutable is_ok <- true;
        while (nem_output != null)
        {
          when (this.verbose > 0)
            print_endline ("VERB-NEM : " + nem_output);
          unless (HandleMsg (nem_output))
          {
            HandleErrorMsg ("Unexpected Nemerle compiler's message :\n"+nem_output);
            is_ok <- false
          };
          nem_output <- nem_compile.StandardOutput.ReadLine ()
        }; 
        def Check (line : string, msg : Regex) : void
            {
              match (checked_msg.Get (line)) {
                | Some (_) => ()
                | None => 
                    HandleErrorMsg ("Expected error:\n\""+msg.ToString () +"\"\n hasn't occured in line:"+line);
                    is_ok <- false
              }
            };
        err_lines.Iter (Check);
        def Check (line : string, msg : Regex) : void
            {
              match (checked_msg.Get (line)) {
                | Some (_) => ()
                | None => 
                    HandleErrorMsg ("Expected warning:\n\""+msg.ToString () +"\"\n hasn't occured in line:"+line);
                    is_ok <- false
              }
            };
        warn_lines.Iter (Check);
        if (nem_compile.ExitCode != 0 && nem_compile.ExitCode != 1)
        {
          HandleErrorMsg ("Nemerle compiler reported internal error");
          false
        }
        else 
          is_ok 
      }
      with { 
        _ : Win32Exception  =>
          HandleErrorMsg ("Error occured while running Nemerle compiler");
          false
      }
    }

    private TestOutput () : bool
    {
      try 
      {
        mutable runtime <- Process ();
        if (dnet_runtime.Length> 0) 
        {
          runtime.StartInfo.FileName <- dnet_runtime;
          runtime.StartInfo.Arguments <- "./out.exe";
        } 
        else
        {
          runtime.StartInfo.FileName <- "./out.exe";
          runtime.StartInfo.Arguments <- "";
        };
        runtime.StartInfo.RedirectStandardOutput <- true;
        runtime.StartInfo.UseShellExecute <- false;
        runtime.StartInfo.RedirectStandardInput <- true;
        def _ = runtime.Start ();
        def WriteInput (in_list : list (string), input : StreamWriter) : void
            {
              match (in_list) {
                | Nil => ()
                | h :: tl => 
                    input.WriteLine (h);
                    WriteInput (tl, input)
              }
            };
        WriteInput (input, runtime.StandardInput);
        runtime.WaitForExit ();
        def CheckOutput (in_list : list (string), output : string, is_ok : bool) : bool
            {
              match ((in_list, output)) {
                | (Nil, null) => is_ok
                | (Nil, _) => 
                    HandleErrorMsg ("Runtime output is longer than it should be");
                    false
                | (_, null) => HandleErrorMsg ("Unexpected end of runtime output");
                    false
                | (h :: tl, str) => 
                    when (verbose > 1) 
                      print_endline ("VERB-RUN : " + output);
                    if (h.Equals (str))
                      CheckOutput (tl, runtime.StandardOutput.ReadLine (), is_ok)
                    else
                    {
                      HandleErrorMsg ("Runtime output : \n\""+str+"\"\ndoes not match expected : \n\""+h+"\"");
                      CheckOutput (tl, runtime.StandardOutput.ReadLine (), false) 
                    }    
              }
            };
        CheckOutput (expected_output, runtime.StandardOutput.ReadLine (), true)
      }
      with {
        _ : Win32Exception =>
          HandleErrorMsg ("Error occured while running the program");
          false
      }
    }

    private HandleErrorMsg (str : string) : void
    {
      if (error_log == null) 
      {
        print_endline ("failed\n"+str);
        if (log_file_created)
          error_log <- File.AppendText ("test_error.log")
        else 
        {
          error_log <- File.CreateText ("test_error.log");
          log_file_created <- true
        }
      }
      else
        print_endline (str);
      when (!was_error_header) 
      {
        error_log.WriteLine ("-------------------------");
        error_log.WriteLine ("Test of "+filename);
        error_log.WriteLine ("-------------------------");
        was_error_header <- true
      };
      error_log.WriteLine (str);
      error_log.WriteLine ("-------------------------")
    }

    public AttachFile (filename : string) : bool
    {
      try 
      {      
        Init (filename);
        def reader = File.OpenText (filename);
        mutable temp_str <- reader.ReadLine ();
        mutable index <- 1;  
        while (temp_str != null)
        {
          CheckLine (temp_str, index);
          index <- index+1;
          temp_str <- reader.ReadLine ();
        };
        reader.Close ();
        expected_output <- List.rev (expected_output);
        input <- List.rev (input);
        true 
      } 
      with {
        | _ : End_test => 
            no_test <- true;
            true
        | err : Exception =>
            if (filename_short.Equals (""))
              print_string ("Testing "+filename+"...")
            else
              print_string ("Testing "+filename_short+"...");
            err_overall_count <- err_overall_count+1;
            try
              raise err
            with {
              | _ : FileNotFoundException =>
                  HandleErrorMsg ("File \""+filename+"\" does not exist")
              | _ : DirectoryNotFoundException =>
                  HandleErrorMsg ("This path \""+filename+"\" is invalid")
              | _ : PathTooLongException =>
                  HandleErrorMsg ("This path \""+filename+"\" is invalid")
              | _ : Exception =>
                  HandleErrorMsg ("Error occured while reading the file")
            };
            false
      }
    }

    public Test () : void 
    {
      print_string ("Testing "+filename_short+"...");
      if (no_test)
        print_endline ("skipped")
      else 
      {
        when (verbose > 0)
          print_endline ("");
        try
        {
          if (NemerleTest ()) 
          {
            if (err_lines.Count () == 0)
            {
              try
              {
                if (was_output)
                {
                  if (TestOutput ())
                    print_endline ("passed")
                  else 
                  {
                    HandleErrorMsg ("Runtime test failed");
                    err_overall_count <- err_overall_count+1
                  }
                }
                else
                {
                  print_endline ("passed")
                }
              } 
              with {
                _ : Win32Exception => 
                  HandleErrorMsg ("Error occured while running testcase")
              }
            }
            else
              print_endline ("passed")
          }
          else
          {
            HandleErrorMsg ("Nemerle compile test failed");
            err_overall_count <- err_overall_count+1
          }
        }
        with {
          _ : Win32Exception => 
            HandleErrorMsg ("Error occured while running Nemerle compiler")
        }
      }
    }

    public GetReport () : int
    {
      when (error_log!= null) 
      {
        error_log.Close ();
        error_log <- null
      };
      if (err_overall_count == 0) 
      {
        print_endline ("All tests passed");
        0
      }
      else
      {
        print_endline (string_of_int (err_overall_count) +" of tests failed\nSee test_error.log file for details");
        1
      }
    }

    public static Main () : int 
    { 
      mutable dnet_env <- "";
      mutable nem_comp <- "../ncc2.exe";
      mutable nem_path <- "../../";
      mutable dlls_path <- "";
      mutable verbose <- 0;
      mutable test_files <- Nil ();
      def opts = [
          Getopt.String      (name = "-n", 
                            aliases = ["-ncc"], 
                            help = "use this Nemerle compiler (default : \"../ncc2.exe\") ",
                            handler = fun (s) { nem_comp <- s; });
          Getopt.String      (name = "-p", 
                            aliases = ["-nem_path"], 
                            help = "the path to the root of Nemerle directory (default : \"../../\") ",
                            handler = fun (s) { nem_path <- s; });
          Getopt.String      (name = "-dll", 
                            aliases = ["-dll_path"], 
                            help = "the path to the dlls directory (default : \"./\") ",
                            handler = fun (s) { dlls_path <- (s : String).Trim (); });
          Getopt.String      (name = "-r", 
                            aliases = ["-runtime"], 
                            help = "use this .Net runtime engine (default : none) ",
                            handler = fun (s) { dnet_env <- (s : String).Trim (); });
          Getopt.Flag        (name = "-v", 
                            aliases = ["-verbose"], 
                            help = "prints all Nemerle output (default : off) ",
                            handler = fun () { verbose <- verbose + 1; });
          Getopt.Flag        (name = "-vv",  
                            help = "prints all Nemerle and runtime output (default : off) ",
                            handler = fun () { verbose <- verbose + 2; });
          Getopt.NonOption     (name = "", 
                            help = "specify file (s) to be tested (default : All *.n files from current directory) ",
                            handler = fun (s) { test_files <- s :: test_files; });
          ];
      Getopt.Parse (opts);
      def tester = Tester (dnet_env, nem_path, dlls_path, nem_comp, verbose);
      when (List.is_empty (test_files)) 
      {
        def str = Directory.GetFiles (Directory.GetCurrentDirectory (), "*.n");
        mutable fcounter <- ((str : Array).Length- 1);
        while (fcounter >= 0)
        {
// For Windows compatibility :
          test_files <- (str[fcounter].Replace ("\\", "/")) :: test_files;
          fcounter <- fcounter - 1
        }
      };
      def test_from_list (file_list : list (string)) : void 
          {
            match (file_list) {
              | file :: tl => 
                  when (tester.AttachFile (file))
                    tester.Test ();
                  test_from_list (tl)
              | Nil => ()
            }
          };
      test_from_list (test_files);
      tester.GetReport ()
    }

  }
