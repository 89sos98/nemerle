(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

module CGflat {
  // string in tree for fast concatenation
  variant String_tree {
    | ST_leaf { data : string; }
    | ST_node { left : String_tree; right : String_tree; }
  }

  (**
   * <summary>Describes a part of generated C# source code.</summary>
   * <remarks>
   *   In both variants, the [val] field denotes a C# statement. The [pre] 
   *   field in [CS_complex] is a *statement* to be executed *before*
   *   [val] is referenced. [val] is always an expression in C#, though 
   *   it can have side effects (like calling functions).
   * </remarks>
   *)
  variant CS_code {
    /// a simple instruction
    | CS_simple { val : String_tree; }    
    /// a complex instruction, requiring some precalculations
    | CS_complex { pre : String_tree; val : String_tree; }
  }

  mutable base_class_ctor : String_tree;

  is_complex (c : CS_code) : bool { 
    match (c) { CS_complex => true | _ => false }
  }

  add_st (s1 : String_tree, s2 : String_tree) : String_tree
    { ST_node (s1, s2) }
  
  add_st (s1 : string, s2 : String_tree) : String_tree
    { ST_node (ST_leaf (s1), s2) }
  
  add_st (s1 : String_tree, s2 : string) : String_tree
    { ST_node (s1, ST_leaf (s2)) }
  
  @++ (s1 : String_tree, s2 : String_tree) : String_tree = 
    extern "Nemerle.Compiler.CGflat.add_st";

  @++ (s1 : string, s2 : String_tree) : String_tree =
    extern "Nemerle.Compiler.CGflat.add_st";

  @++ (s1 : String_tree, s2 : string) : String_tree =
    extern "Nemerle.Compiler.CGflat.add_st";

  class_type (c : CM_class) : CG_type
    { CT_ref (c.ns + c.name) }

  csref (c : CS_code) : String_tree {
    match (c) {
      | CS_simple (s) => s
      | CS_complex (_, s) => s
    }
  }

  mono (e : CS_code, rf : String_tree) : CS_code {
    match (e) {
      | CS_simple (_) => CS_simple (rf)
      | CS_complex (p, _) => CS_complex (p, rf)
    }
  }

  public is_dummy_type (t : CG_type) : bool {
    match (t) {
      | CT_void => true
      | CT_unreached => true
      | _ => false
    }
  }

  st_concat (sep : string, nodes : list (String_tree)) : String_tree {
    match (nodes) {
      | [] => ST_leaf ("")
      | [x] => x
      | x :: xs => x ++ sep ++ st_concat (sep, xs)
    }
  }
  
  s_concat (sep : string, nodes : list (string)) : String_tree {
    match (nodes) {
      | [] => ST_leaf ("")
      | x :: xs => ST_leaf (x) ++ sep ++ s_concat (sep, xs)
    }
  }
  
  flat_ty (t : CG_type) : String_tree
    { 
      def s (t : CG_type) : string {
        match (t) {
          | CT_ref (n) => n
          | CT_void => "void"
          | CT_object => "object"
          | CT_bool => "bool"
          | CT_unreached => "unreached"
          | CT_tuple (n) => "Nemerle.Tuple" + string_of_int (n)
          | CT_fun (n) => "Nemerle.Func" + string_of_int (n)
          | CT_array (at) => s (at) + "[]"
        }
      };
      ST_leaf (s (t));
    }

  // only for short strings (like function name)
  st_flatten (s : String_tree) : string {
    match (s) {
      | ST_leaf (x) => x
      | ST_node (l, r) => st_flatten (l) + st_flatten (r)
    }
  }

  flat_call (pref : String_tree, es : list (CG_expr)) : CS_code
    {
      def es' = List.map (flat, es);
      def (pre, es) =
        if (List.exists (is_complex, es')) {
          mutable pre <- ST_leaf ("");
          def f (x : CG_expr, fx : CS_code) : CS_code
            {
              def (p, r) = make_complex (fx);
              def n = Util.tmpname ("fc");
              def df = flat_ty (type_of (x)) ++ " " ++ n ++ " = " ++ r ++ ";\n";
              pre <- pre ++ p ++ df;
              CS_simple (ST_leaf (n))
            };
          // r needs to be in def, since computing it triggers pre update
          def r = List.map2 (f, es, es');
          (Some (pre), r)
        } else (None (), es');
      
      def body = {
        def fname = st_flatten (pref);
        if (fname.StartsWith ("%op")) {
          def opname = fname.Substring(3, fname.Length - 3);
          match (List.map (csref, es)) {
            | [e1; e2] =>
              "(" ++ e1 ++ " " ++ opname ++ " " ++ e2 ++ ")"
            | [e] =>
              "(" + opname + " " ++ e ++ ")"
            | _ => Util.ice ()
          };
        } else {
          pref ++ "(" ++ st_concat (",\n", List.map (csref, es)) ++ ")"
        }
      };

      match (pre) {
        | None => CS_simple (body)
        | Some (x) => CS_complex (x, body)
      };
    }

  make_complex (ex : CS_code) : String_tree * String_tree {
    match (ex) {
      | CS_complex (x, y) => (x, y)
      | CS_simple (x) => (ST_leaf (""), x)
    }
  }

  quote (s : string) : string {
    def buf = System.Text.StringBuilder (s.Length * 2);

    for (mutable i <- 0; i < s.Length; i <- i + 1)
      match (s[i]) {
        | '\n' => ignore (buf.Append ("\\n"))
        | '\t' => ignore (buf.Append ("\\t"))

        | '\"' | '\'' | '\\' =>
          ignore (buf.Append ('\\'));
          ignore (buf.Append (s[i]))

        | c => ignore (buf.Append (c))
      };

    buf.ToString ()
  }

  is_raise (ex : CG_expr) : bool {
    match (ex) {
      | CE_raise (_) => true
      | CE_restart => true
      | CE_cast (e, _) => is_raise (e)
      | CE_let (_, e) => is_raise (e)
      | CE_sequence (seq) => List.exists (is_raise, seq)
      | _ => false
    }
  }

  pretty_print_list (exs : list(CG_expr), acc : string) : string {
    match (exs) {
      | [] => acc
      | ex :: rest => pretty_print_list (rest, acc + pretty_print (ex))
    }
  }

  pretty_print (ex : CG_expr) : string {
    match (ex) {
      | CE_ref (_decl) => "CE_ref; "
      | CE_global_ref (_decl) => "CE_global_ref; "
      | CE_ctor_ref (_klass, _) => "CE_ctor_ref; "
      | CE_default_ctor_ref (_klass) => "CE_ctor_ref; " 
      | CE_field_ref (_obj, _fld) => "CE_field_ref; "
      | CE_property_ref (_obj, _prop) => "CE_property_ref; "
      | CE_method_ref (_obj, _meth) => "CE_method_ref; "
      | CE_tuple_ref (_obj, _pos) => "CE_tuple_ref; "
      | CE_call (_func, _parms) => "CE_call; "
      | CE_assign (target, source) => 
        pretty_print (target) + " = " + pretty_print (source) + "; "
      | CE_let (name, body) => 
        "let " + name.name + " = " + pretty_print (name.val) + " in " + pretty_print (body) + "; "
      | CE_has_type (_expr, _ty) => "CE_has_type; "
      | CE_raise (_exn) => "CE_raise; "
      | CE_if (_ty, cond, e_then, e_else) => 
        "if (" + pretty_print (cond) + ") " + pretty_print (e_then) + " else " + pretty_print (e_else) + "; "
      | CE_try_with => "CE_try_with; "
      | CE_try_finally => "CE_try_finally; "
      | CE_literal => "CE_literal; "
      | CE_this => "CE_this; "
      | CE_base => "CE_base; "
      | CE_skip => "CE_skip; "
      | CE_cast (expr, _ty) => "CE_cast { " + pretty_print (expr) + " } "
      | CE_sequence (body) => "{ " + pretty_print_list (body, "") + " }; "
      | CE_tuple_ctor (_exprs) => "CE_tuple_ctor; "
      | CE_none => "CE_none"
      | CE_mkarray (_, initializers) => "CE_mkarray { " + pretty_print_list (initializers, "") + " }; "
      | CE_indexer (_, _, obj, args) => "CE_indexer " + pretty_print (obj) + "[" + pretty_print_list (args, "") + "]" + "; "
      | CE_array_indexer (_, obj, args) => "CE_array_indexer " + pretty_print (obj) + "[" + pretty_print_list (args, "") + "]" + "; "
      | CE_block (expr) => "CE_block { " + pretty_print (expr) + " }; "
      | CE_restart => "CE_restart; "
    }
  }

  simplify (ex : CS_code) : CS_code {
    def isnull (st) {
      match (st) {
        | ST_leaf ("") => true
        | ST_leaf (_) => false
        | ST_node (a, b) => isnull (a) && isnull (b)
      }
    };
    match (ex) {
      | CS_complex (pre, x) when isnull (pre) => CS_simple (x)
      | x => x
    }
  }

  flat (ex : CG_expr) : CS_code {
    match (ex) {
      | CE_ref (d) => CS_simple (ST_leaf (d.name))
      | CE_global_ref (m) =>
        def n = if (m.extern_name != "") m.extern_name else m.name;
        CS_simple (ST_leaf (n))      
      | CE_field_ref (e, f) =>
        def e = flat (e);
        mono (e, csref (e) ++ "." ++ f.name)
      | CE_property_ref (e, p) =>
        def e = flat (e);
        mono (e, csref (e) ++ "." ++ p.name)

      | CE_tuple_ref (e, n) => 
        def e = flat (e);
        mono (e, csref (e) ++ ".field" ++ string_of_int (n + 1))

      | CE_call (e, es) => 
        match ((e, flat (e))) {
          | (CE_base, CS_simple (s)) => 
            match (flat_call (s, es)) {
              | CS_simple (s) => base_class_ctor <- s; CS_simple (ST_leaf (""))
              | _ => Util.ice ("complex expressions in base call")
            }
          | (_, CS_simple (s)) => flat_call (s, es)
          | (_, CS_complex (pref, v)) => 
            Util.ice ("CE_call on a complex instruction (" + st_flatten(pref) + ": " + st_flatten(v) + ")")
        }
          
      | CE_assign (e1, e2) =>
        def (p1, r1) = make_complex (flat (e1));
        def (p2, r2) = make_complex (flat (e2));
        CS_complex (p1 ++ p2, r1 ++ " = " ++ r2)
        
      | CE_indexer (_, _, obj, args) =>
        def (obj_pre, obj_val) = make_complex (flat (obj));
        mutable indexers_pre <- ST_leaf ("");
        def serialize (e : CG_expr) : String_tree {
          def (pre, val) = make_complex (flat (e));
          indexers_pre <- indexers_pre ++ pre;
          val
        };
        def concat (acc : String_tree, indexers : list (CG_expr)) : String_tree {
          match (indexers) {
            | [] =>
              acc ++ ST_leaf ("]")
            | [indexer] =>          
              acc ++ serialize (indexer) ++ ST_leaf ("]")
            | indexer :: rest =>
              concat (acc ++ serialize (indexer) ++ ST_leaf (", "), rest)
          }
        };
        def indexers_val = concat (ST_leaf ("["), args);
        simplify (CS_complex (obj_pre ++ indexers_pre, obj_val ++ indexers_val))


      | CE_array_indexer (_, obj, args) =>
        def (obj_pre, obj_val) = make_complex (flat (obj));
        mutable indexers_pre <- ST_leaf ("");
        def serialize (e : CG_expr) : String_tree {
          def (pre, val) = make_complex (flat (e));
          indexers_pre <- indexers_pre ++ pre;
          val
        };
        def concat (acc : String_tree, indexers : list (CG_expr)) : String_tree {
          match (indexers) {
            | [] =>
              acc ++ ST_leaf ("]")
            | [indexer] =>          
              acc ++ serialize (indexer) ++ ST_leaf ("]")
            | indexer :: rest =>
              concat (acc ++ serialize (indexer) ++ ST_leaf (", "), rest)
          }
        };
        def indexers_val = concat (ST_leaf ("["), args);
        simplify (CS_complex (obj_pre ++ indexers_pre, obj_val ++ indexers_val))

        
      | CE_let (v, e) =>
        match (v.val) {
          | CE_none =>
            def (p, r) = make_complex (flat (e));
            CS_complex (flat_ty (v.ty) ++ " " ++ v.name ++ ";\n" ++ p, r)
          | _ =>
            def (p, r) = make_complex (flat (v.val));
            def pref = 
              if (is_dummy_type (v.ty))
                p ++ side_effect_run (r)
              else
                p ++ flat_ty (v.ty) ++ " " ++ v.name ++ " = " ++ r ++ ";\n";
            def (p, r) = make_complex (flat (e));
            CS_complex (pref ++ p, r)
        }
        
      | CE_has_type (e, t) =>
        def e = flat (e);
        mono (e, "((" ++ csref (e) ++ " == null &&" ++ 
                 " Nemerle.Core.Null_match.raise_self ()) || (" 
                 ++ csref (e) ++ " is " ++ flat_ty (t) ++ "))")
        
      | CE_raise (x) =>
        def (p, r) = make_complex (flat (x));
        CS_complex (p ++ "throw " ++ r ++ ";\n", ST_leaf ("null"))

(*    It for some reason fails.

      | CE_if (_, CE_literal (L_bool (true)), e, _) =>
         Message.debug ("In if (true), subexpr is: " + pretty_print (e));
         flat (e)
      | CE_if (_, CE_literal (L_bool (false)), _, e) =>
         Message.debug ("In if (false), subexpr is: " + pretty_print (e));
         flat (e)
*)

      | CE_if (t, c, e1', e2') =>
        (*Message.debug ("if{" + pretty_print (e1') +"}else{" +pretty_print (e2')+"}");*)
        def (p1, c) = make_complex (flat (c));
        def (p2, e1) = make_complex (flat (e1'));
        def (p3, e2) = make_complex (flat (e2'));
        if (is_dummy_type (t))
          CS_complex (p1 ++ 
                      "if (" ++ c ++ ") {\n" ++
                        p2 ++
                        side_effect_run (e1) ++
                      "} else {\n" ++
                        p3 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf ("null"))
        else {
          def tmpname = Util.tmpname ("it");
          def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
          (* Skip unnecessary (and sometimes compilation breaking) tmpname
             assignments after throw. *)
          CS_complex (p1 ++ df ++ 
                      "if (" ++ c ++ ") {\n" ++
                        (if (is_raise (e1')) p2 else (p2 ++ tmpname ++ " = " ++ e1 ++ ";\n")) ++
                      "} else {\n" ++
                        (if (is_raise (e2')) p3 else (p3 ++ tmpname ++ " = " ++ e2 ++ ";\n")) ++
                      "}\n", ST_leaf (tmpname))
        }
        
      | CE_try_with (e1', v, e2') =>
        def (p1, e1) = make_complex (flat (e1'));
        def (p2, e2) = make_complex (flat (e2'));
        def t = type_of (e1');
        if (is_dummy_type (t))
          CS_complex ("try {\n" ++
                        p1 ++
                        side_effect_run (e1) ++
                      "} catch (" ++ flat_ty (v.ty) ++ " " ++ v.name ++ ") {\n" ++
                        p2 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf ("null"))
        else {
          def tmpname = Util.tmpname ("tw");
          def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
          CS_complex (df ++
                      "try {\n" ++
                        p1 ++
                        tmpname ++ " = " ++ e1 ++ ";\n" ++
                      "} catch (" ++ flat_ty (v.ty) ++ " " ++ v.name ++ ") {\n" ++
                        p2 ++
                        tmpname ++ " = " ++ e2 ++ ";\n" ++
                      "}\n", ST_leaf (tmpname))
        }
                    
      | CE_try_finally (e1', e2') =>
        def (p1, e1) = make_complex (flat (e1'));
        def (p2, e2) = make_complex (flat (e2'));
        def t = type_of (e1');
        if (is_dummy_type (t))
          CS_complex ("try {\n" ++
                        p1 ++
                        side_effect_run (e1) ++
                      "} finally {\n" ++
                        p2 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf ("null"))
        else {
          def tmpname = Util.tmpname ("tf");
          def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
          CS_complex (df ++
                      "try {\n" ++
                        p1 ++
                        tmpname ++ " = " ++ e1 ++ ";\n" ++
                      "} finally {\n" ++
                        p2 ++
                        side_effect_run (e2) ++
                      "}\n", ST_leaf (tmpname))
        }
                    
      | CE_literal (l) =>
        def s =
          match (l) {
            | L_void => "null"
            | L_null => "null"
            | L_int (k) => string_of_int (k)
            | L_bool (v) => if (v) "true" else "false"
            | L_char (k) => 
              "((char)" + System.Convert.ToString (System.Convert.ToInt32 (k)) + ")"
            | L_string (s) => "\"" + quote (s) + "\""
            | L_float (f) => string_of_int (f) + ".0" // FIXME
          };
        CS_simple (ST_leaf (s))
        
      | CE_mkarray (_, initializers) =>
        mutable pref <- ST_leaf ("");
        def serialize (e : CG_expr) : String_tree {
          def (pre, val) = make_complex (flat (e));
          pref <- pref ++ pre;
          val
        };
        def concat (acc : String_tree, initializers : list (CG_expr)) : String_tree {
          match (initializers) {
            | [] =>
              acc ++ ST_leaf (" }")
            | [initializer] =>          
              acc ++ serialize (initializer) ++ ST_leaf (" }")
            | initializer :: rest =>
              concat (acc ++ serialize (initializer) ++ ST_leaf (", "), rest)
          }
        };
        def body = concat (ST_leaf ("{ "), initializers);
        CS_complex (pref, body)
        
      | CE_this => CS_simple (ST_leaf ("this"))
      | CE_base => CS_simple (ST_leaf ("base"))
      | CE_skip => CS_simple (ST_leaf ("null"))
      
      | CE_cast (e, CT_void) => flat (e) // C# doesn't like (void)foo
      
      | CE_cast (e, t) =>
        def e = flat (e); 
        mono (e, "((" ++ flat_ty (t) ++ ")" ++ csref (e) ++ ")")
        
      | CE_sequence ([]) => CS_simple (ST_leaf ("null"))

      | CE_sequence (body) =>
        def cutoff_after_raise (e : list (CG_expr), acc : list (CG_expr)) : list (CG_expr) {
          match (e) {
            | [] => List.rev (acc)
            // FIXME: use the "as" construct here
            | CE_raise (expr) :: _ => 
              cutoff_after_raise ([], CE_raise (expr) :: acc) 
            | CE_restart :: _ => 
              cutoff_after_raise ([], CE_restart () :: acc) 
            | expr :: rest => 
              cutoff_after_raise (rest, expr :: acc)
          }
        };
        def serialize (e : CG_expr) : String_tree
          {
            def (pre, r) = make_complex (flat (e));
            pre ++ side_effect_run (r)
          };
        def concat (acc : String_tree, es : list (CG_expr)) : CS_code {
          match (es) {
            | [x] => 
              def (pre, r) = make_complex (flat (x));
              CS_complex (acc ++ pre, r)
            | CE_skip :: xs =>
              concat (acc, xs)
            | x :: xs =>
              concat (acc ++ serialize (x), xs)
            | [] => CS_simple (ST_leaf ("null"))
          }
        };

        concat (ST_leaf (""), cutoff_after_raise (body, []))
      
      | CE_tuple_ctor (es) =>
        flat_call (ST_leaf ("new Nemerle.Tuple") ++ string_of_int (List.length (es)), es)
      
      | CE_default_ctor_ref (c) => 
        if (c.extern_name == "") 
          Util.ice ("empty extern name " + c.ns + ":" + c.name)
        else
          CS_simple (ST_leaf ("new " + c.extern_name))
      
      | CE_ctor_ref (c, _) => 
        if (c.extern_name == "") 
          Util.ice ("empty extern name " + c.ns + ":" + c.name)
        else
          CS_simple (ST_leaf ("new " + c.extern_name))

      | CE_method_ref (e, f) => 
        def e = flat (e); 
        mono (e, csref (e) ++ "." ++ f.name)

      | CE_block (e) =>
        def (pref, val) = make_complex (flat (e));
        CS_complex ("_N_block_beg:\n" ++ pref, val)

      | CE_restart =>
        CS_complex (ST_leaf ("goto _N_block_beg;"), ST_leaf ("null"))

      | CE_none => Util.ice ()
    }
  }

  public type_of (ex : CG_expr) : CG_type {
    match (ex) {
      | CE_ref (d) => d.ty
      | CE_global_ref ((CM_field) as f) => f.ty
      | CE_global_ref ((CM_property) as p) => p.ty
      | CE_field_ref (_, f) => f.ty
      | CE_property_ref (_, p) => p.ty
      | CE_tuple_ref => CT_object ()
      | CE_call (CE_global_ref ((CM_method) as m), _) => m.ret_type
      | CE_call (CE_method_ref (_, m), _) => m.ret_type
      | CE_call (CE_default_ctor_ref (c), _) => class_type (c)
      | CE_call (CE_ctor_ref (c, _), _) => class_type (c) 
      | CE_call (CE_base, _) => CT_void ()
      | CE_call => Util.ice ()
      | CE_assign => CT_void ()
      | CE_let (_, b) => type_of (b)
      | CE_has_type => CT_bool ()
      | CE_raise => CT_unreached ()
      | CE_if (t, _, _, _) => t
      | CE_try_with (e, _, _) => type_of (e)
      | CE_try_finally (e, _) => type_of (e)
      | CE_literal (l) => 
        match (l) {
          | L_void => CT_void ()
          | L_null => CT_object ()
          | L_int => CT_ref ("int")
          | L_char => CT_ref ("char")
          | L_string => CT_ref ("string")
          | L_float => CT_ref ("float")
          | L_bool => CT_ref ("bool")
        }
      | CE_this => CT_object () // cheat a bit
      | CE_skip => CT_void ()
      | CE_cast (_, t) => t
      | CE_sequence (b) => type_of (List.last (b))
      | CE_tuple_ctor (es) => CT_tuple (List.length (es))
      // can't tell
      | CE_none => Util.ice ()
      // these are supported only as part of call
      | CE_global_ref (CM_method) => Util.ice ()
      | CE_global_ref (CM_class) => Util.ice ()
      | CE_default_ctor_ref => Util.ice ()
      | CE_ctor_ref => Util.ice ()
      | CE_method_ref => Util.ice ()
      | CE_base => Util.ice ()
      | CE_mkarray (element_type, _) => CT_array (element_type)
      | CE_indexer (t, _, _, _) => t
      | CE_array_indexer (t, _, _) => t
      | CE_block (expr) => type_of (expr)
      | CE_restart => CT_void ()
    }
  }

  print_st (s : String_tree) : void {
    match (s) {
      | ST_leaf (d) => write_string (d)
      | ST_node (l, r) => { print_st (l); print_st (r) }
    }
  }

  side_effect_run (x : String_tree) : String_tree {
    match (x) {
      | ST_leaf (s) => 
        if (s == "null") ST_leaf ("")
        else x ++ ";\n"
      | _ => x ++ ";\n"
    }
  }

  (**
   * Converts a Nemerle to some kind of an XML string
   *)
  emit_nemerle_type_attr (encoded_type : string) : String_tree {

    ST_leaf ("[Nemerle.TypeAttribute(\"") 
      ++ ST_leaf (encoded_type) ++ 
    ST_leaf ("\")]\n")
  }


  flat_member (m : CG_member) : void {
    match (m) {
      | (CM_class) as m =>
        def variant_attribute =
          match (m.kind) {          
            | CK_variant => "[Nemerle.VariantAttribute()]\n"
            | CK_variant_option (encoded_type) => 
              "[Nemerle.VariantOptionAttribute(\"" + encoded_type + "\")]\n"
            | _ => ""
          };
        def k = 
          match (m.kind) { 
            | CK_class => "class" 
            | CK_struct => "struct" 
            | CK_interface => "interface"
            | CK_variant => "class"
            | CK_variant_option (_) => "class"
          };
        def inh =
          match (m.inheritance) {
            | [] => ST_leaf ("")
            | _ => " : " ++ st_concat (", ", List.map (flat_ty, m.inheritance))
          };
        print_st (ST_leaf (variant_attribute) ++ s_concat (" ", m.attrs) ++ " " ++ k ++ 
                  " " ++ m.name ++ inh ++ " {\n");
        List.iter (flat_member, m.decls);
        print_st (ST_leaf ("} // end of ") ++ k ++ " " ++ m.name ++ "\n")

     | (CM_field) as m =>
       print_st (emit_nemerle_type_attr (m.encoded_type) ++ s_concat (" ", m.attrs) ++ " " ++ flat_ty (m.ty) ++ 
                 " " ++ m.name ++ ";\n")
                 
     | CM_property =>
       Message.fatal_error ("emitting properties is not supported yet")
                        
     | (CM_method) as m =>
       CGopt.tail_call_optimize (m);
       def mkparm (v : CG_val) : String_tree {
         flat_ty (v.ty) ++ " " ++ v.name
       };
       def rett = 
         match (m.ret_type) {
           | CT_unreached => ST_leaf ("")
           | _ => flat_ty (m.ret_type)
         };

       print_st (emit_nemerle_type_attr (m.encoded_type) ++ s_concat (" ", m.attrs) ++ " " ++ rett ++ "\n" ++ 
                 m.name ++ "(" ++ st_concat (", ", List.map (mkparm, m.parms)) ++ ")");

       match (m.body) {
         | CE_none => print_st (ST_leaf (";\n"))
         | _ =>
           def (pref, r) = make_complex (flat (m.body));
           def ret =
             if (is_dummy_type (m.ret_type))
               side_effect_run (r)
             else
               if (is_dummy_type (type_of (m.body)))
                 side_effect_run (r) ++ "return null;\n"
               else
                 "return " ++ r ++ ";\n";
                 
           when (base_class_ctor != null) {
             print_st (" : " ++ base_class_ctor ++ "\n");
             base_class_ctor <- null
           };
         
           print_st ("\n{\n" ++ pref ++ ret ++ "} // end of fun " ++ m.name ++ "\n")
       }
   }
  }

  preflat () : void 
  {
    write_string ("/* code automatically generated by the Nemerle compiler */\n");
    write_string ("using System.Reflection;\n");
    write_string ("using System.Runtime.CompilerServices;\n");
    write_string ("[assembly: AssemblyConfiguration(\"ContainsNemerleTypes\")]\n\n");  
  }
    
  mutable output_file : System.IO.StreamWriter;

  write_string (s : string) : void {
    when (output_file == null)
      output_file <- System.IO.StreamWriter("out.cs");
    output_file.Write(s)
  }

  close_file () : void {
    output_file.Close ();
    output_file <- null;
  }

  (** 
   * Output objects from cgtree.n as a textual C# code. 
   *
   * <remarks>
   *   This module will be replaced by IL assembler or byte code generator.
   * </remarks>
   *)
  public run (decls : list (CM_class)) : void
  {
    def flat_top_member (x : CM_class) : void {      
      if (x.ns != "") {
        print_st (ST_leaf ("namespace " + Util.get_ns (x.ns) + " {\n"));
        flat_member (x);
        print_st (ST_leaf ("} // end ns\n"))
      } else flat_member (x)
    };

    preflat ();
    List.iter (flat_top_member, decls);
    close_file ();
  }

} // end module
} // end namespace
