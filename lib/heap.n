/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;

namespace Nemerle.Collections {
  public class EmptyHeap extends System.Exception
  {
    public msg : string;
    public this (msg : string) { this.msg <- msg; }
  }

  /**
   * General usage heap, can be used as priority queue.
   */
  public class Heap('a) where 'a :> System.IComparable {

    /** array that stores the heap, elements are stored in heap[1]..heap[count] */
    private mutable heap  : array('a);
    /** size of array */
    private mutable size  : int;
    /** number of elements that are in the heap wright now */
    private mutable count : int;

    /** 
     * Private constructor, do not use from outside this class.
     */
    private this() 
    {
    }

    /** 
     * Creates new heap that will initialy contain elements from array a,
     * all elements are copied into the heap, so later modifications of a
     * do not influence the heap. This operation takes time O(n), where n 
     * is number of elements in array a.
     */
    public this(a : array('a)) {
      size <- a.Length;
      count <- a.Length;
      heap <- (System.Array.CreateInstance(typeof(System.IComparable),size+1) :> array('a));
      a.CopyTo(heap,1);
      build_heap ();
    }

    /**
     * Creates new emtpy heap with initial equal to supplied argument.
     */
    public this(size : int) {
      def realSize = if ( size >= 10 ) 
        size
      else
        10;
        heap <- (System.Array.CreateInstance(typeof(System.IComparable),realSize+1) :> array('a));
      this.size <- realSize;
      count <- 0;
    }

    /**
     * Grows up the table that is used to store heap elements multiplying size by 2.
     */
    private grow_up() : void {
      def newSize = 2 * size;
      def newHeap = (System.Array.CreateInstance(typeof(System.IComparable),newSize+1) :> array('a));

      heap.CopyTo(newHeap,0);

      heap <- newHeap;
      size <- newSize;
    }

    /**
     * Checks if element at index k is greater than element at index l.
     */
    private is_greater(k : int, l : int) : bool {
      def kVal = heap[k];
      def lVal = heap[l];
      kVal.CompareTo(lVal) > 0;
    }

    /**
     * Swaps elements at index k and l.
     */
    private swap(k : int, l : int) : void {
      def kVal = heap[k];
      heap[k] <- heap[l];
      heap[l] <- kVal;
    }

    /**
     * Calculates index of parent of element at index i.
     */
    private parent(i : int) : int {
      i / 2
    }

    /**
     * Calculates index of left child of element at index i.
     */
    private left(i : int) : int {
      2 * i
    }

    /**
     * Calculates index of right child of element at index i.
     */
    private right(i : int) : int {
      2 * i + 1
    }

    /**
     * Repeairs heap structure starting from element at index i, moving down.
     * For explanations see Cormen,Leiserson,Rivest "Introduction to algorithms".
     */
    private heapify(i : int) : void {
      def l = left(i);
      def r = right(i);
      mutable largest <- 0;
      if ( l <= count && is_greater(l,i) ) 
        largest <- l
      else
        largest <- i;
      if ( r <= count && is_greater(r,largest) )
        largest <- r
      else
        ();
      if ( largest != i ) {
        swap(i,largest);
        heapify(largest)
      } else 
        ();
    }

    /**
     * Builds heap from elements stored in this.heap array. 
     * This is done in time O(size).
     */
    private build_heap() : void {
      for ( mutable i <- count / 2; i >= 1; i <- i - 1 )
        heapify(i);
    }

    /**
     * Inserts new element into the heap.
     */
    public Insert(x : 'a) : void {
      if ( count >= size )
        grow_up ()
      else 
        ();
      count <- count + 1;
      mutable i <- count;
      while ( i > 1 && x.CompareTo(heap[parent(i)]) > 0 ) {
        heap[i] <- heap[parent(i)];
        i <- parent(i)
      };
      heap[i] <- x;
    }

    /**
     * Returns first (with maximal priority) element from the heap
     * without removing it.
     * Throws EmptyHeap exception.
     */
    public Top() : ('a) {
      if ( count == 0 )
        throw EmptyHeap("Empty heap exception")
      else 
        heap[1]
    }
    
    /**
     * Returns first (with maximal priority) element from the heap,
     * removing it.
     * Throws EmptyHeap exception.
     */
    public ExtractFirst() : ('a) {
      if ( count < 1 )
        throw EmptyHeap("Empty heap exception")
      else {
        def result = (heap[1] :> ('a));
        heap[1] <- heap[count];
        count <- count - 1;
        heapify(1);
        result
      } 
    }

    /**
     * Checks if heap is empty.
     */
    public IsEmpty () : bool {
      count == 0
    }

    /**
     * Returns number of elements in heap.
     */
    public Count () : int {
      count
    }

    /**
     * Returns number of elements that heap can store without growing up.
     */
    public Size () : int {
      size
    }

    /**
     * Creates new heap of elements of type 'b. New heap is totally independent, i.e.
     * any changes in original heap do not influence the second one and vice versa.
     */
    public 'b where 'b :> System.IComparable 
    Map(f : 'a -> 'b) : Heap('b) 
    {
      def newHeapArray = (System.Array.CreateInstance(typeof(System.IComparable),size+1) :> array('b));
      for ( mutable i <- 1; i <= count; i <- i + 1 ) {
        newHeapArray[i] <- f ( heap[i] );
      };
      def newHeap = Heap ();
      newHeap.heap  <- newHeapArray;
      newHeap.count <- count;
      newHeap.size  <- size;
      newHeap.build_heap ();
      newHeap
    }

    /**
     * Calls specified function for all elements of heap.
     */
    public Iter(f : 'a -> void) : void 
    {
      for ( mutable i <- 1; i <= count; i <- i + 1 ) {
        f ( heap[i] );
      }
    }

    /**
     * Folds heap elements useing specified function and initial value.
     */
    public 'b Fold (f : ('b * 'a) -> 'b,x : 'b) : 'b
    {
      mutable v <- x;
      for ( mutable i <- 1; i <= count; i <- i + 1 )
        v <- f (v,heap[i]);
      v  
    }
  }
}
