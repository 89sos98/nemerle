(*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Compiler;
  open Nemerle.Compiler.Tyops;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Collections;
  
  open System.Reflection;
  open System.Reflection.Emit;


  (**
   * The CGIL tree holds information about types and their members.
   *)
  variant CGIL_tree {
    | CGIL_class { type_builder : TypeBuilder; subtree : list (CGIL_tree); }
    | CGIL_field { class_name : string; field : CM_field; field_builder : FieldBuilder; }
    | CGIL_constructor { class_name : string; constructor : CM_method; constructor_builder : ConstructorBuilder; }
    | CGIL_method { class_name : string; method : CM_method; method_builder : MethodBuilder; }
  }


  (**
   * An IL code generator
   *)
  public class CGIL
  {
    (* -- PUBLIC CONSTRUCTORS ---------------------------------------------- *)
    
    (** 
     * Outputs objects from cgtree.n as IL code. 
     *)
    public this (decls : list (CM_class), target_exe : bool, 
                 output_file_name : string)
    {
      (* create the type builder queue *)
      this._type_builder_queue <- Queue ();
      
      (* create the member builders storage *)
      _classes <- Hashtable ();
            
      (* create a weak assembly name and define a dynamic assembly *)
      this._assembly_name <- System.Reflection.AssemblyName ();
      this._assembly_name.Version <- System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name <- "NemerleGeneratedAssembly"; // FIXME

      this._assembly_builder <- 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      (* create a dynamic module *)
      this._module_builder <- 
        this._assembly_builder.DefineDynamicModule ("NemerleGeneratedModule", 
                                                    output_file_name, true); // FIXME

      when (target_exe) {
        this._need_entry_point <- true;
        this._entry_point <- None ();
      };

      (* select the classes that have to be generated separately *)
      def (aux_decls, standard_decls) =
        this.select_aux_and_standard_decls (decls);

      (* process the declarations *)
      def add_classes (decl) { this.make_class (decl, null) };
      def add_declarations (tree) { this.add_declarations (tree, null) }; // FIXME: aargh
      def add_implementations (tree) { this.add_implementations (tree) }; // FIXME: aargh

      (* emit the auxiliary declarations *)
      this._emit_nemerle_attributes <- false;

      def aux_classes_tree = List.map (add_classes, aux_decls);
      def aux_declarations_tree = List.map (add_declarations, aux_classes_tree);
      def _ = List.map (add_implementations, aux_declarations_tree);

      (* execute the type builder queue *)
      create_types_in_queue ();

      (* emit all the other declarations *)
      this._emit_nemerle_attributes <- true;

      def classes_tree = List.map (add_classes, standard_decls);
      def declarations_tree = List.map (add_declarations, classes_tree);
      def _ = List.map (add_implementations, declarations_tree);

      (* execute the type builder queue *)
      create_types_in_queue ();

      (* set the entry point *)
      match ((this._need_entry_point, this._entry_point)) {
        | (true, Some (entry_point_method_info)) =>
          _assembly_builder.SetEntryPoint (entry_point_method_info, PEFileKinds.ConsoleApplication)
        | (true, None) =>
          Message.error ("no suitable entry point (Main function) found")
        | _ => ()
      };

      (* save the assembly *)
      this._assembly_builder.Save (output_file_name);
    }



    (* -- PRIVATE METHODS -------------------------------------------------- *)

    (**
     * Calls the CreateType method for all the elements in the queue.
     * The queue is cleared after the types have been created.
     *)
    private create_types_in_queue () : void
    {
      def create_type (tb : TypeBuilder) : void {
        // Message.debug ("CreateType " + tb.FullName);
        def _ = tb.CreateType ();
        ()
      };      
    
      _type_builder_queue.iter (create_type);
      _type_builder_queue.clear ();
    }
    
    (**
     * Splits the declarations into two separate lists. The first list
     * will be processed in the first order (typically you'll want to
     * put all the auxiliary definitions there).
     *)
    private select_aux_and_standard_decls (decls : list (CM_class)) : list (CM_class) * list (CM_class)
    {
      def is_aux (decl : CM_class) : bool {
        match (decl.ns + decl.name) {
          | "Nemerle.Func0"
          | "Nemerle.Func1"
          | "Nemerle.Func2"
          | "Nemerle.Func3"
          | "Nemerle.Func4"
          | "Nemerle.Func5"
          | "Nemerle.Func6"
          | "Nemerle.TypeAttribute"
          | "Nemerle.VariantAttribute"
          | "Nemerle.VariantOptionAttribute" => true
          | _ => false
        }
      };
      
      List.partition (is_aux, decls)
    }
    
    
    (**
     * Builds a Nemerle type attribute
     *)
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.TypeAttribute", false, false);
      def constructor_param_types = mkarray [reflect_type ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     * Builds a Nemerle variant attribute
     *)
    private make_nemerle_variant_attribute () : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.VariantAttribute", false, false);
      def constructor_info = attr_type.GetConstructor (mkarray []);
      def attr_builder = CustomAttributeBuilder (constructor_info, (mkarray [] :> array (System.Object)));
      attr_builder
    }
    

    (**
     * Builds a Nemerle variant option attribute
     *)
    private make_nemerle_variant_option_attribute (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.VariantOptionAttribute", false, false);
      def constructor_param_types = mkarray [reflect_type ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }



    (**
     * A search for a (possibly partial) type of a given name is executed.
     * The partial types in the local module builder are always searched.
     * If specified, the external declarations and the currently loaded
     * types are scanned, too.
     *)
    private reflect_type (type_name : string, scan_externals : bool, scan_system : bool) : System.Type
    {
      (*
Michal Moskal (23:13)
def tc = GlobalEnv.LookupExactType("Foo.bar")
i GetTyconKind () -- tam bedzie S.Type      
      *)
      
      // FIXME: this is a hack, how can we fix it in earlier stages?
      def type_name =
        match (type_name) {
          | "char" => "System.Char"
          | "int" => "System.Int32"
          | other => other
        };
                    
      def ty = this._module_builder.GetType (type_name);
      if (ty != null) ty
      else {
        def ty = null; // FIXME: search in GlobalEnv.externals here!
        if (ty != null && scan_externals) ty
        else {
          def ty = System.Type.GetType (type_name);
          if (ty != null && scan_system) ty
          else {
            // brute, brute, brute hack...
            def last_dot = type_name.LastIndexOf ('.');
            
            if (last_dot != -1) {
              def dot_to_plus = type_name.Substring (0, last_dot) + 
                "+" + type_name.Substring (last_dot + 1);
              reflect_type (dot_to_plus, scan_externals, scan_system);
            }
            else {
              Message.warning ("CGIL: unable to reflect type: " + type_name);
              typeof (System.Object)
            }
          }
        }
      }    
    }


    (**
     * Same as above, but always searches in externals and System.
     *)
    internal reflect_type (type_name : string) : System.Type
    {
      reflect_type (type_name, true, true)
    }


    (**
     * Converts a CG type to it's closest approximation as a System.Type
     *)
    internal reflect_nemerle_type (ty : CG_type) : System.Type
    {
      match (ty) {
        | CT_array (t) => 
          def internal_type = reflect_nemerle_type (t);          
          this.reflect_type (internal_type.FullName + "[]", true, true)

        | CT_ref (name) =>
          match (name) {
            | "bool" => typeof (System.Boolean)
            | "int" => typeof (System.Int32)
            | "string" => typeof (System.String)
            | _ => this.reflect_type (name, true, true)
          }
        
        | CT_tuple (arity) =>
          this.reflect_type ("Nemerle.Tuple" + string_of_int (arity), false, false)
          
        | CT_fun (arity) =>
          this.reflect_type ("Nemerle.Func" + string_of_int (arity), false, false)
          
        | CT_void => typeof(System.Void)
        | CT_object => typeof(System.Object)
        | CT_bool => typeof(System.Bool)
        
        | CT_unreached => Util.ice ("nemerle_to_framework_type:CT_unreached")
      }          
    }

    (**
     *
     *)
    internal split_global_ref (global_ref : string) : string * string
    {
      def last_dot = global_ref.LastIndexOf ('.');
      assert (last_dot != -1);

      (global_ref.Substring (0, last_dot), global_ref.Substring (last_dot + 1))
    }    
    
    (**
     *
     *)
    internal is_value_type (ty : CG_type) : bool 
    {
      match (ty) {
        | CT_bool => true
        | CT_ref (name) =>
          match (name) {
            // FIXME: add all the other types here (System.Type::IsValueType)
            // FIXME: implement intelligent type name unaliasing
            // FIXME: move this function to tyutil or wherever it belongs...
            | "bool" 
            | "System.Boolean"
            | "char" 
            | "System.Char"
            | "int"
            | "Int32"
            | "System.Int32"
            | "float"
            | "System.Single"
            | "System.Double" 
            | "System.Reflection.MethodAttributes" 
            | "System.Reflection.FieldAttributes" 
            | "System.Reflection.MemberTypes" 
            | "System.Reflection.Emit.OpCode" => true
            | _ => false
          }
        | _ => false
      }    
    }
    
    
    (**
     * Converts Nemerle field modifiers to the CLI field attributes.
     *)
    private make_field_attributes (attrs : list (Modifier)) : FieldAttributes
    {
      def process_modifier (modifier : Modifier) : FieldAttributes {
        match (modifier) {
          | Mod_public => FieldAttributes.Public
          | Mod_private => FieldAttributes.Private
          | Mod_new => Util.ice ("Mod_new is not supported for fields")
          | Mod_protected => FieldAttributes.Family
          | Mod_internal => FieldAttributes.FamORAssem
          | Mod_abstract => Util.ice ("Mod_abstract is not supported for fields")
          | Mod_virtual => Util.ice ("Mod_virtual is not supported for fields")
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for fields")
          | Mod_static => FieldAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for fields")
          | Mod_module => Util.ice ("Mod_module is not supported for fields")
          | Mod_macro => Util.ice ("Mod_macro is not supported for fields")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) %| this.make_field_attributes (rest)
        | [] =>
          FieldAttributes.PrivateScope
      }
    }


    (**
     * Converts Nemerle method modifiers to the CLI method attributes.
     *)
    private make_method_attributes (attrs : list (Modifier)) : MethodAttributes
    {
      def process_modifier (modifier : Modifier) : MethodAttributes {
        match (modifier) {
          | Mod_public => MethodAttributes.Public
          | Mod_private => MethodAttributes.Private
          | Mod_new => MethodAttributes.NewSlot
          | Mod_protected => MethodAttributes.Family
          | Mod_internal => MethodAttributes.FamORAssem
          | Mod_abstract => MethodAttributes.Abstract
          | Mod_virtual => MethodAttributes.Virtual
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for methods")
          | Mod_static => MethodAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for methods")
          | Mod_module => Util.ice ("Mod_module is not supported for methods")
          | Mod_macro => Util.ice ("Mod_macro is not supported for methods")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) %| this.make_method_attributes (rest)
        | [] =>
          MethodAttributes.HideBySig
      }
    }


    (**
     * Checks if the given method is static
     *)
    internal is_static_method (method : CM_method) : bool
    {
      def is_mod_static (modifier : Modifier) : bool {
        match (modifier) {
          | Mod_static => true
          | _ => false
        }
      };

      List.exists (is_mod_static, method.modifiers)
    }


    (**
     * Checks if the given field is static
     *)
    internal is_static_field (field : CM_field) : bool
    {
      def is_mod_static (modifier : Modifier) : bool {
        match (modifier) {
          | Mod_static => true
          | _ => false
        }
      };

      List.exists (is_mod_static, field.modifiers)
    }


    (**
     * Converts a System.Type list to a System.Type array.
     * FIXME: mkarray (x) won't work here as the list's length is not know.
     *)  
    internal type_list_to_type_array (x : list (System.Type)) : array (System.Type) {

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), List.length (x)) :> array (System.Type));
      
      def loop (index : int, x : list (System.Type)) : void {        
        match (x) {
          | head :: tail =>
            result [index] <- (head :> System.Type);
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }


    (**
     * Reads the inheritance list of a class and retrieves the base
     * type and builds the array of interfaces implemented by the class.
     *)
    private determine_inheritance (m : CM_class) : (System.Type * array (System.Type))
    {
      def walk_parents (parents : list (CG_type), 
                        extends_acc : list (System.Type), 
                        implements_acc : list (System.Type)) 
                        : list (System.Type) * list (System.Type) 
      {
        def find_parent_type (parent_name : string, rest : list (CG_type)) 
                                    : list (System.Type) * list (System.Type) {
          def incomplete_type = get_class_by_name (parent_name);

          match (incomplete_type) {
            | Some (({ kind = CK_interface }) as incomplete_type) =>
              def incomplete_type = Option.unsome (incomplete_type.type_builder);
              walk_parents (rest, extends_acc, (incomplete_type :> System.Type) :: implements_acc)
            | Some (incomplete_type) =>
              def incomplete_type = Option.unsome (incomplete_type.type_builder);
              walk_parents (rest, (incomplete_type :> System.Type) :: extends_acc, implements_acc)
            | None =>
              // FIXME: search in externals
              def external_type = reflect_type (parent_name);
              assert (external_type != null);
              
              if (external_type.IsInterface)
                walk_parents (rest, extends_acc, external_type :: implements_acc)
              else                               
                walk_parents (rest, external_type :: extends_acc, implements_acc)
          }        
        };
        
        match (parents) {
          | [] => (extends_acc, implements_acc)
          | parent :: rest =>
            match (parent) {
              | CT_tuple (arity) => find_parent_type ("Nemerle.Tuple" + string_of_int (arity), rest)
              | CT_fun (arity) => find_parent_type ("Nemerle.Func" + string_of_int (arity), rest)
              | CT_ref (parent_name) => find_parent_type (parent_name, rest)
              
              | CT_object =>
                walk_parents (rest, typeof (System.Object) :: extends_acc, implements_acc)
                              
              | _ => Util.ice ("determine_inheritance: invalid type in parents list")
            }
        }
      };
        
      def (extends_list, implements_list) = walk_parents (m.inheritance, [], []);
    
      def dump_list (l : list (System.Type)) : string {
        match (l) {
          | [] => ""
          | [t] => t.FullName
          | t :: ts => t.FullName + ", " + dump_list (ts)
        }
      };

(*            
      Message.debug ("determine inheritance of " + m.extern_name + ": " + 
        dump_list (extends_list) + " / " + dump_list (implements_list)); 
*)
      
      def extends_type =
        match (extends_list) {
          | [] => typeof (System.Object)
          | [ty] => ty
          | _ => Util.ice ("class " + m.extern_name + " extends more than one base type")
        };
        
      (extends_type, type_list_to_type_array (implements_list))
    }
  
  
    (**
     *
     *)
    internal get_class_by_name (class_name : string) : option (CM_class)
    {
      _classes.Get (plus_to_dot (class_name))
    }
    

    (**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     *)
    private make_class (klass : CM_class, type_builder : TypeBuilder) : CGIL_tree
    {       
      (* store the class pointer for later use *)
      _classes.Add (klass.extern_name, klass);
      
      (* create optional custom attributes for this type *)
      def custom_attribute =
        match (klass.kind) {          
          | CK_variant => 
            this.make_nemerle_variant_attribute ()
          | CK_variant_option (encoded_type) =>
            this.make_nemerle_variant_option_attribute (encoded_type)
          | _ => null
        };

      (* decide the new type attributes *)
      mutable is_interface <- false;
      
      def type_kind_attrs = 
        match (klass.kind) { 
          | CK_class => TypeAttributes.Class
          | CK_struct => Util.ice ("CK_struct")
          | CK_interface => 
            is_interface <- true;
            TypeAttributes.Interface %| TypeAttributes.Abstract
          | CK_variant => TypeAttributes.Class
          | CK_variant_option (_) => TypeAttributes.Class
        };
        
      def attrs = type_kind_attrs;

      (* determine the inheritance relation for this type *)
      def (extends_class', implements_interfaces) = this.determine_inheritance (klass);
      def extends_class = if (is_interface) null else extends_class';

      (* create the type builder for a top-level or nested class declaration *)      
      def new_type_builder = 
        if (type_builder == null)
          this._module_builder.DefineType (klass.ns + klass.name, TypeAttributes.Public %| attrs, 
                                          extends_class, implements_interfaces)
        else
          type_builder.DefineNestedType (klass.name, TypeAttributes.NestedPublic %| attrs,
                                        extends_class, implements_interfaces);

      // Message.debug ("make_class " + new_type_builder.FullName);

      when (custom_attribute != null && this._emit_nemerle_attributes) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      klass.type_builder <- Some (new_type_builder);

      this._type_builder_queue.add (new_type_builder);

      (* add a default constructor, if none present *)
      unless (is_interface) { add_default_constructor (klass) };

      (* create the type builder's CGIL subtree *)
      def new_type_name = plus_to_dot (new_type_builder.FullName);
            
      def walk_members (decls : list (CG_member)) : list (CGIL_tree) {
        match (decls) {
          | decl :: rest => 
            this.make_subtree (klass, new_type_name, decl, new_type_builder) 
              :: walk_members (rest)
          | [] => []
        }
      };
      
      CGIL_class (new_type_builder, walk_members (klass.decls))    
    }


    (**
     * Adds a default constructor if necessary
     *)
    private add_default_constructor (klass : CM_class) : void
    {
      def is_ctor (m : CG_member) : bool {
        match (m) {
          | (CM_method) as m =>
            match (m.ret_type) {
              | CT_unreached => true
              | _ => false
            }
          | _ => false
        }
      };
      
      unless (List.exists (is_ctor, klass.decls)) {      
        def ctor = CM_method (Tyutil.encode_type_to_string (T_void ()), [], 
                              CT_unreached (), CE_skip (), [], None (), None ());

        ctor.name <- klass.extern_name + "..ctor";
        ctor.extern_name <- klass.extern_name + "..ctor";
        ctor.modifiers <- [Mod_public ()];
        ctor.attrs <- ["public"];
        
        klass.decls <- ctor :: klass.decls;
      }
    }


    (**
     *
     *)
    internal plus_to_dot (type_name : string) : string
    {
      type_name.Replace ('+', '.')
    }


    (**
     * This method walks the declarations tree, creating partial types
     * and building the CGIL tree of the compilation unit.
     *)
    make_subtree (parent_class : CM_class, parent_class_name : string, 
                  m : CG_member, type_builder : TypeBuilder) : CGIL_tree
    {
      assert (type_builder != null);
      
      match (m) {
        | (CM_class) as m =>
          this.make_class (m, type_builder)

        | (CM_field) as f =>
          CGIL_field (parent_class_name, f, null)
                               
        | CM_property =>
          Message.fatal_error ("emitting properties is not supported yet")
                            
        | (CM_method) as m =>
          // CGopt.tail_call_optimize (m);
          
          match (m.ret_type) {
            | CT_unreached =>
              mark_default_constructor (parent_class, m);              
              CGIL_constructor (parent_class_name, m, null)
            | _ => CGIL_method (parent_class_name, m, null)
          }
      }          
    }


    (**
     * If no default constructor has been selected yet, the provided method
     * is marked as the class' default constructor. Otherwise, the new constructor
     * is memorized only if it's parameters list has zero length. This should be
     * a good heuristic to handle the CE_default_ctor_ref issue (which is generated
     * before relevant constructor CM_method is ever built).
     *)
    mark_default_constructor (klass : CM_class, ctor : CM_method) : void
    {
      when (Option.is_none (klass.default_ctor) || List.length (ctor.parms) == 0) {
        klass.default_ctor <- Some (ctor)
      }
    }


    (**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     *)
    add_declarations (m : CGIL_tree, type_builder : TypeBuilder) : CGIL_tree
    {
      match (m) {
        | CGIL_class (class_type_builder, members) =>
          def walk_members (decls : list (CGIL_tree)) : list (CGIL_tree) {
            match (decls) {
              | decl :: rest => 
                this.add_declarations (decl, class_type_builder) :: walk_members (rest)
              | [] => []
            }
          };          
          CGIL_class (class_type_builder, walk_members (members))    

        | CGIL_field (class_name, field, _) =>
          assert (type_builder != null);
                    
          def field_builder = 
            type_builder.DefineField (field.name, 
                                      this.reflect_nemerle_type (field.ty), 
                                      this.make_field_attributes (field.modifiers));

          when (this._emit_nemerle_attributes) {
            field_builder.SetCustomAttribute (this.make_nemerle_type_attr (field.encoded_type));
          };
          
          field.field_builder <- Some (field_builder);
                    
          CGIL_field (class_name, field, field_builder)
                            
        | CGIL_constructor (class_name, constructor, _) =>
          assert (type_builder != null);

          this.make_constructor_skeleton (class_name, constructor, type_builder)

        | CGIL_method (class_name, method, _) =>
          assert (type_builder != null);

          this.make_method_skeleton (class_name, method, type_builder)
      }          
    }


    (**
     * This method adds implementations to methods, where applicable...
     *)
    private add_implementations (tree : CGIL_tree) : CGIL_tree
    {
      match (tree) {
        | CGIL_class (type_builder, subtree) => 
          def walk_branches (branch) { this.add_implementations (branch) }; // FIXME: aargh
          CGIL_class (type_builder, List.map (walk_branches, subtree))
          
        | (CGIL_constructor (class_name, constructor, constructor_builder)) as member =>
          this.add_constructor_body (class_name, constructor, constructor_builder);
          member
        
        | (CGIL_method (class_name, method, method_builder)) as member =>
          this.add_method_body (class_name, method, method_builder);
          member
        
        | member => member
      }
    }


    (**
     *
     *)
    private make_constructor_skeleton (class_name : string, m : CM_method, type_builder : TypeBuilder) : CGIL_tree
    {
      (* build the parameter types array *)      
      def mkparm (v : CG_val) : System.Type {
        this.reflect_nemerle_type (v.ty)
      };

      def parm_types_list = List.map (mkparm, m.parms);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      (* create the constructor builder *)
      def constructor_builder = 
        type_builder.DefineConstructor (make_method_attributes (m.modifiers),
                                        CallingConventions.Standard, parm_types_array);

      m.ctor_builder <- Some (constructor_builder);

      CGIL_constructor (class_name, m, constructor_builder)
    }

    

    (**
     *
     *)    
    private add_constructor_body (class_name : string, constructor : CM_method, constructor_builder : ConstructorBuilder) : void
    {
      def il_generator = constructor_builder.GetILGenerator ();

      unless (CodeGenerator.has_base_ctor_call (constructor.body) || is_static_method (constructor)) {      
        // Message.debug ("class " + class_name + " does not have a base ctor call, adding a default one");
        
        def class_type = reflect_type (class_name);
        def base_type = 
          if (class_type.BaseType == null)
            typeof(System.Object)
          else
            class_type.BaseType;

        // Message.debug ("add_constructor_body " + class_name + ", base class: " + base_type.FullName);

        def internal_base_class = get_class_by_name (base_type.FullName);
        
        def default_ctor_info =
          match (internal_base_class) {
            | Some (internal_base_class) =>
              def default_ctor = Option.unsome (internal_base_class.default_ctor);
              (Option.unsome (default_ctor.ctor_builder) :> ConstructorInfo)
            | None =>
              base_type.GetConstructor (BindingFlags.NonPublic %| BindingFlags.Public %| 
                                        BindingFlags.Instance, null, System.Type.EmptyTypes, null)
          };
        assert (default_ctor_info != null);

        il_generator.Emit (OpCodes.Ldarg_0);
        il_generator.Emit (OpCodes.Call, default_ctor_info);
      };

      (* emit the constructor body, add the RET instruction only if it will be reachable *)
      def cg = CodeGenerator (this, il_generator, class_name, constructor);
      
      unless (cg.emit ()) {        
        il_generator.Emit (OpCodes.Ret);
      }
    }


    (**
     *
     *)
    private make_method_skeleton (class_name : string, m : CM_method, type_builder : TypeBuilder) : CGIL_tree
    {
      (* build the return type and parameter types *)
      def mkparm (v : CG_val) : System.Type {
        this.reflect_nemerle_type (v.ty)
      };

      def return_type = reflect_nemerle_type (m.ret_type);

      def parm_types_list = List.map (mkparm, m.parms);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      (* add the method to the type builder *)
      def modifiers =
        match (m.implemented_methods) {
          | [] => m.modifiers
          | _ => Mod_virtual () :: m.modifiers
        };
      
      def method_builder = 
        type_builder.DefineMethod (m.name, make_method_attributes (modifiers),
                                   return_type, parm_types_array);

(*
      Message.debug ("added method builder to " + m.extern_name + 
        " / PL:" + string_of_int (List.length (parm_types_list)) +
        " / HC:" + string_of_int (method_builder.GetHashCode ()) +
        " / ID:" + string_of_int (m.id));
*)
        
      m.method_builder <- Some (method_builder);

      CGIL_method (class_name, m, method_builder)
    }


    (**
     *
     *)
    private add_method_body (class_name : string, method : CM_method, method_builder : MethodBuilder) : void
    { 
(*
      Message.debug ("adding method body to " + method.extern_name + 
        " / PL:" + string_of_int (List.length (method.parms)) +
        " / HC:" + string_of_int ((Option.unsome (method.method_builder)).GetHashCode ()) +
        " / ID:" + string_of_int (method.id));
*)

      when (_need_entry_point && method.name == "Main" && method_builder.IsStatic) {
        match (_entry_point) {
          | Some =>
            Message.error ("ambiguous match for entry point candidate in type " + 
                           method_builder.DeclaringType.FullName);
          | None =>
            _entry_point <- Some ((method_builder : MethodInfo))
        }
      };
      
      (* update the overriding relationships *)
      def mk_parm (parm : CG_val) : System.Type {
        reflect_nemerle_type (parm.ty)
      };

      def method_parms = List.map (mk_parm, method.parms);
      def method_info = (method_builder :> MethodInfo);
      def incomplete_type = Option.unsome (get_class_by_name (class_name));
      def type_builder = Option.unsome (incomplete_type.type_builder);
      
      def update_override (overridden : CM_method) : void {
        def overridden_info = get_method_info (overridden, method_parms);

(*
        Message.debug ("update_override: " + overridden.extern_name + " / " + 
          string_of_int (List.length (overridden.parms)) + 
          " / MHC:" + string_of_int (method_info.GetHashCode ()) +
          " / OHC:" + string_of_int (overridden_info.GetHashCode ()) +
          " / OID:" + string_of_int (overridden.id));
*)
        
        type_builder.DefineMethodOverride (method_info, overridden_info)
      };
      
      List.iter (update_override, method.implemented_methods);
      
      (* emit the method body, add the RET instruction only if it will be reachable *)
      def il_generator = method_builder.GetILGenerator ();

      def cg = CodeGenerator (this, il_generator, class_name, method);

      unless (cg.emit ())        
        il_generator.Emit (OpCodes.Ret)
    }


    (**
     *
     *)
    internal get_ctor_info (ctor : CM_method, parm_types_list : list (System.Type)) : ConstructorInfo
    {      
      if (Option.is_some (ctor.ctor_builder)) {
        def ctor_builder = Option.unsome (ctor.ctor_builder);
        
        (ctor_builder :> ConstructorInfo)
      }
      else {
        def class_name = (ctor.extern_name).Substring (0, (ctor.extern_name).Length - 6);

        def class_type = reflect_type (class_name);

        if (class_type != null) {
          def parm_types_array = type_list_to_type_array (parm_types_list);

          def ctor_info =
            class_type.GetConstructor (BindingFlags.Public %| BindingFlags.Instance %|
                                       BindingFlags.FlattenHierarchy, null, parm_types_array, null);
          assert (ctor_info != null);
          
          ctor_info
        }
        else {

          Message.fatal_error ("could not find constructor for class " + class_name)
        }
      }
    }


    (**
     * Returns an internal (built in the current assembly) method info.
     * This is a fail-sale for the 'extern' renames.
     *)
    internal get_internal_ctor_info (klass : CM_class, parm_types_list : list (System.Type)) : option (ConstructorInfo)
    {
      def walk_parms (declared : list (System.Type), needed : list (System.Type)) : bool {
        match ((declared, needed)) {
          | ([], []) => 
            true
          | (declared :: declared_rest, needed :: needed_rest) =>
            if (declared.FullName == needed.FullName || needed.IsSubclassOf (declared))
              walk_parms (declared_rest, needed_rest)
            else false
          | _ => Util.ice ("failed to walk the parameters")
        }
      };
      
      def is_good_match (decl : CM_method) : bool {
        if (Option.is_none (decl.ctor_builder)) false
        else {
          if (List.length (decl.parms) == List.length (parm_types_list)) {
            (* build the parameter types array *)      
            def mkparm (v : CG_val) : System.Type {
              this.reflect_nemerle_type (v.ty)
            };

            def declared_parms = List.map (mkparm, decl.parms);

            walk_parms (declared_parms, parm_types_list);
          }
          else 
            false
        }
      };
            
      def walk_decls (decls : list (CG_member)) : option (ConstructorInfo) {
        match (decls) {
          | [] => None ()
          | (CM_method) as decl :: _ when is_good_match (decl) =>
            Some ((Option.unsome (decl.ctor_builder) :> ConstructorInfo))
          | _ :: rest => walk_decls (rest)
        }
      };          

      walk_decls (klass.decls)
    }


    (**
     * Returns a ConstructorInfo for a class described by a CM_class object
     *)
    internal get_ctor_info (klass : CM_class, parm_types_list : list (System.Type)) : ConstructorInfo
    {
      match (get_internal_ctor_info (klass, parm_types_list)) {
        | Some (ctor_info) => ctor_info
        | None =>
          if (Option.is_some (klass.default_ctor)) {
            Message.warning ("get_ctor_info: had to resort to default_ctor");
            def ctor = Option.unsome (klass.default_ctor);
            get_ctor_info (ctor, parm_types_list)
          }
          else {
            // FIXME: search the externals
            def class_type = reflect_type (klass.extern_name);

            if (class_type != null) {
              def parm_types_array = type_list_to_type_array (parm_types_list);

              def ctor_info = 
                class_type.GetConstructor (BindingFlags.Public %| BindingFlags.Instance %| 
                                          BindingFlags.FlattenHierarchy, null, parm_types_array, null);
              assert (ctor_info != null);
              
              ctor_info
            }
            else {

              Message.fatal_error ("could not find default constructor for class " + klass.extern_name)
            }
          }
      }
    }


    (**
     *
     *)
    internal get_external_method_info (class_name : string, method_name : string, is_static : bool,
                                       parm_types_list : list (System.Type)) : MethodInfo
    {
      def class_type = reflect_type (class_name);

      if (class_type != null) {
        def parm_types_array = type_list_to_type_array (parm_types_list);

        def binding_flags =
          if (is_static) BindingFlags.Static
          else BindingFlags.Instance;
 
        def method_info =
          class_type.GetMethod (method_name, binding_flags %| BindingFlags.Public %|
                                BindingFlags.FlattenHierarchy, null, parm_types_array, null);
        assert (method_info != null);
        
        method_info
      }
      else {

        Message.fatal_error ("could not find method " + class_name + "." + method_name)
      }    
    }


    (**
     * Returns an internal (built in the current assembly) method info.
     * This is a fail-sale for the 'extern' renames.
     *
     * FIXME: this will fail for overloaded methods.
     *)
    internal get_internal_method_info (class_name : string, method_name : string, 
                                       parm_types_list : list (System.Type)) : option (MethodInfo)
    {
      Message.debug ("get_internal_method_info " + class_name + "::" + method_name);
      
      def incomplete_type = get_class_by_name (class_name);

      def walk_parms (declared : list (System.Type), needed : list (System.Type)) : bool {
        match ((declared, needed)) {
          | ([], []) => 
            Message.debug ("walk_parms successful");
            true
          | (declared :: declared_rest, needed :: needed_rest) =>
            Message.debug ("walk_parms D:" + declared.FullName + ", N: " + needed.FullName);
            if (declared.FullName == needed.FullName || needed.IsSubclassOf (declared))
              walk_parms (declared_rest, needed_rest)
            else {
              Message.debug ("walk_parms failed due to no subclassing relation");            
              false
            }
          | _ => Util.ice ("failed to walk the parameters")
        }
      };
      
      def is_good_match (decl : CM_method) : bool {
        Message.debug ("is_good_match " + decl.extern_name + " / " + decl.name);
        if (Option.is_none (decl.method_builder) || decl.name != method_name) false
        else {
          if (List.length (decl.parms) == List.length (parm_types_list)) {
            (* build the parameter types array *)      
            def mkparm (v : CG_val) : System.Type {
              this.reflect_nemerle_type (v.ty)
            };

            def declared_parms = List.map (mkparm, decl.parms);

            walk_parms (declared_parms, parm_types_list);
          }
          else 
            false
        }
      };


      match (incomplete_type) {
        | Some (incomplete_type) =>          
          def walk_decls (decls : list (CG_member)) : option (MethodInfo) {
            match (decls) {
              | [] => None ()
              | (CM_method) as decl :: _ when is_good_match (decl) =>
                assert (Option.is_some (decl.method_builder), "could not find method builder for " + 
                                                               class_name + "." + method_name);
                Some ((Option.unsome (decl.method_builder) :> MethodInfo))
              | _ :: rest => walk_decls (rest)
            }
          };          
          walk_decls (incomplete_type.decls)    
        
        | None => None ()
      }      
    }


    (**
     *
     *)
    internal get_method_info (method : CM_method, parm_types_list : list (System.Type)) : MethodInfo
    {      
      if (Option.is_some (method.method_builder)) {
        // Message.debug ("INTERNAL method.name: " + method.name + ", method.extern_name: " + method.extern_name);

        def method_builder = Option.unsome (method.method_builder);
        
        (method_builder :> MethodInfo)
      }
      else {
        def (class_name, method_name) = split_global_ref (method.extern_name);

        def internal_method_info = get_internal_method_info (class_name, method_name, parm_types_list);
        
        match (internal_method_info) {
          | Some (internal_method_info) => 
            // Message.debug ("INTERNAL (RETRY) method.name: " + method.name + ", method.extern_name: " + method.extern_name);
            internal_method_info
          | None =>
            // Message.debug ("EXTERNAL method.name: " + method.name + ", method.extern_name: " + method.extern_name);

            get_external_method_info (class_name, method_name, is_static_method (method), parm_types_list)
        }
      }
    }



    (**
     * Returns an internal or external field info
     *)
    internal get_field_info (field : CM_field) : FieldInfo
    {
      match (field.field_builder) {
        | Some (field_builder) => (field_builder :> FieldInfo)
        | None =>
          def (class_name, field_name) = split_global_ref (field.extern_name);

          def class_type = reflect_type (class_name);

          if (class_type != null) {

            def binding_flags =
              if (is_static_field (field)) BindingFlags.Static
              else BindingFlags.Instance;
 
            def field_info =
              class_type.GetField (field_name, binding_flags %| BindingFlags.Public %|
                                   BindingFlags.FlattenHierarchy);
                                   
            assert (field_info != null, "could not find field " + class_name + "." + field_name);
            
            field_info
          }
          else {
          
            Message.fatal_error ("could not find field " + class_name + "." + field_name)
          }
      }
    }


    (**
     * Returns an internal (built in the current assembly) field info.
     * This is used to access tuple fields.
     *)
    internal get_internal_field_info (class_name : string, field_name : string) : FieldInfo
    {
      def incomplete_type = get_class_by_name (class_name);
      assert (Option.is_some (incomplete_type), "class " + class_name + " not found amoung internal types");
      
      def decls = (Option.unsome (incomplete_type)).decls;
      
      def walk_decls (decls : list (CG_member)) : FieldInfo {
        match (decls) {
          | [] => Message.fatal_error ("could not find field " + class_name + "." + field_name)
          | (CM_field) as decl :: _ when decl.name == field_name =>
            assert (Option.is_some (decl.field_builder), "could not find field builder for " + 
                                                          class_name + "." + field_name);
            Option.unsome (decl.field_builder)
          | _ :: rest => walk_decls (rest)
        }
      };
      
      walk_decls (decls)    
    }


    (* -- PRIVATE FIELDS --------------------------------------------------- *)

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _type_builder_queue : Queue (TypeBuilder);
    private mutable _emit_nemerle_attributes : bool;
    private mutable _classes : Hashtable (string, CM_class);
    private mutable _need_entry_point : bool;
    private mutable _entry_point : option (MethodInfo);
  }



  (* ----------------------------------------------------------------------- *)
  (* -- CODE GENERATOR CLASS ----------------------------------------------- *)
  (* ----------------------------------------------------------------------- *)

  (**
   *
   *)
  internal class CodeGenerator
  {
    private mutable _cgil : CGIL;
    private mutable _ilg : ILGenerator;
    private mutable _class_name : string;
    private mutable _method : CM_method;
    private mutable _method_name : string;
    private mutable _method_body : CG_expr;
    private mutable _parms : list (CG_val);
    private mutable _is_static_method : bool;
    private mutable _tail_call_block_label : Label;


    (**
     *
     *)
    internal this (cgil : CGIL, ilg : ILGenerator, class_name : string, method : CM_method)
    {
      _cgil <- cgil;
      _ilg <- ilg;
      _class_name <- class_name;
      _method <- method;
      _method_name <- method.extern_name;
      _method_body <- method.body;
      _parms <- method.parms;
      _is_static_method <- _cgil.is_static_method (method);
    }


    (**
     * Emits the method body. Returns true if the expression ended
     * with a control flow terminating instruction (like throw)
     * -- meaning that the current branch has to be cut off in
     * order to avoid dead code emission.
     *)
    internal emit () : bool 
    {
      Message.debug (" -- EMITTING " + _method_name + " --\n");

      def cutoff = emit (_method_body);
      
      (* load a null onto the stack so that the [let _ = expr] has something to pop *)
      when (!cutoff && !is_dummy_type (_method.ret_type) && is_dummy_type (type_of (_method.body)))
        _ilg.Emit (OpCodes.Ldnull);
        
      cutoff
    }


    (**
     * Emits an expression.
     *)
    private emit (expr : CG_expr) : bool 
    {
      Message.debug ("CGIL: emit: " + pretty_print (expr));

      match (expr) {

        (* -- SEQUENCING --------------------------------------------------- *)

        (* emits a sequence of expressions *)
        | CE_sequence (expr_seq) =>
          def emit_sequence (expr_seq : list (CG_expr)) : bool {
            match (expr_seq) {
              | [] => false
              | [expr] => emit (expr)
              | expr :: rest =>
                if (emit (expr)) true
                else {
                  when (increases_stack_height (expr)) _ilg.Emit (OpCodes.Pop);
                  emit_sequence (rest)
                }
            }
          };

          emit_sequence (expr_seq)

        (* emits the local value definition *)
        | CE_let (let_val, let_in) =>
          match (let_val.val) {
            | CE_none =>
              let_val.local_slot <- _ilg.DeclareLocal (_cgil.reflect_nemerle_type (let_val.ty));
              let_val.local_slot.SetLocalSymInfo (let_val.name);

              emit (let_in)

            | _ =>
              if (emit (let_val.val)) true
              else {
                unless (is_dummy_type (let_val.ty)) {
                  let_val.local_slot <- _ilg.DeclareLocal (_cgil.reflect_nemerle_type (let_val.ty));
                  let_val.local_slot.SetLocalSymInfo (let_val.name);
                  _ilg.Emit (OpCodes.Stloc, let_val.local_slot)
                };

                emit (let_in)
              }
          };


        (* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ *)

        (* emits the if (true) instruction *)
        | CE_if (_, CE_literal (L_bool (true)), e1, _) =>
          emit (e1)

        (* emits the if (false) instruction *)
        | CE_if (_, CE_literal (L_bool (false)), _, e2) =>
          emit (e2)

        (* emits the if/then/else construction *)
        | CE_if (_, c, e1, e2) =>
          if (emit (c)) true
          else {
            def label_condition_else = _ilg.DefineLabel ();
            def label_condition_fi = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Brfalse, label_condition_else);
            
            def cutoff_then = emit (e1);
            unless (cutoff_then) { _ilg.Emit (OpCodes.Br, label_condition_fi) };

            _ilg.MarkLabel (label_condition_else);
            def cutoff_else = emit (e2);

            _ilg.MarkLabel (label_condition_fi);
            cutoff_then && cutoff_else
          }


        (* emit a type check construction *)
        | CE_has_type (expr, ty) =>
          if (emit (expr)) true
          else {
            def label_condition_not_null = _ilg.DefineLabel ();
            def label_condition_has_type = _ilg.DefineLabel ();
            def label_condition_continue = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Dup);
            _ilg.Emit (OpCodes.Brtrue, label_condition_not_null);

            emit_raise ("Nemerle.Core.Null_match");

            _ilg.MarkLabel (label_condition_not_null);

            def ty = _cgil.reflect_nemerle_type (ty);
            assert (ty != null);

            _ilg.Emit (OpCodes.Isinst, ty);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Br_S, label_condition_continue);
            _ilg.MarkLabel (label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.MarkLabel (label_condition_continue);
            false
          }


        (* -- TYPE CONVERSIONS --------------------------------------------- *)

        (* special case: do not cast values to the CT_void type *)
        | CE_cast (expr, CT_void) =>
          def cutoff = emit (expr);
          Message.debug ("FIXME: CE_cast to CT_void, type: " + pretty_print_type (type_of (expr)));
          Message.debug ("FIXME: CE_cast to CT_void, expr: " + pretty_print (expr));
          unless (cutoff || is_dummy_type (type_of (expr))) _ilg.Emit (OpCodes.Pop);
          cutoff

        (* box value types, cast all the other types to System.Object *)
        | CE_cast (expr, CT_object)
        | CE_cast (expr, CT_ref ("System.Object")) =>
          if (emit (expr)) true
          else {
            def type_of_expr = type_of (expr);

            if (_cgil.is_value_type (type_of_expr))
              _ilg.Emit (OpCodes.Box, _cgil.reflect_nemerle_type (type_of_expr))
            else
              _ilg.Emit (OpCodes.Castclass, typeof(System.Object));

            false
          }

        (* unbox, convert or upcast / downcast *)
        | CE_cast (expr, cast_to_type) =>
          if (emit (expr)) true
          else {
            if (_cgil.is_value_type (cast_to_type)) {
              def type_of_expr = type_of (expr);

              if (_cgil.is_value_type (type_of_expr)) {
                unless (is_same_value_type (type_of_expr, cast_to_type)) {                
                  (* conversion between value types *)
                  match ((type_of_expr, cast_to_type)) {
                    | (CT_ref ("char"), CT_ref ("int"))
                    | (CT_ref ("char"), CT_ref ("System.Int32"))
                    | (CT_ref ("System.Char"), CT_ref ("int")) // FIXME: normalize the type names earlier
                    | (CT_ref ("System.Char"), CT_ref ("System.Int32")) =>
                      _ilg.Emit (OpCodes.Conv_I4)
                    | (CT_ref ("int"), CT_ref ("char"))
                    | (CT_ref ("int"), CT_ref ("System.Char"))
                    | (CT_ref ("System.Int32"), CT_ref ("char")) // FIXME: normalize the type names earlier
                    | (CT_ref ("System.Int32"), CT_ref ("System.Char")) =>
                      _ilg.Emit (OpCodes.Conv_Ovf_U2)
                    | (CT_ref ("int"), CT_ref ("System.Reflection.MemberTypes"))
                    | (CT_ref ("System.Int32"), CT_ref ("System.Reflection.MemberTypes"))
                    | (CT_ref ("int"), CT_ref ("System.Reflection.FieldAttributes"))
                    | (CT_ref ("System.Int32"), CT_ref ("System.Reflection.FieldAttributes"))
                    | (CT_ref ("int"), CT_ref ("System.Reflection.MethodAttributes"))
                    | (CT_ref ("System.Int32"), CT_ref ("System.Reflection.MethodAttributes")) => 
                      ()
                    | _ =>
                      Message.debug ("FIXME: CE_cast from " + pretty_print_type (type_of_expr) +
                                                    " to " + pretty_print_type (cast_to_type));
                  }
                }
              }
              else {
                (* unboxing returns a pointer to a value *)
                _ilg.Emit (OpCodes.Unbox, _cgil.reflect_nemerle_type (cast_to_type));
                emit_ldind_for_value_type (cast_to_type)
              }
            }
            else {
              (* upcasting / downcasting *)
              _ilg.Emit (OpCodes.Castclass, _cgil.reflect_nemerle_type (cast_to_type))
            };

            false
          }



        (* -- REFERENCES --------------------------------------------------- *)

        (* load the value of a local variable or a method parameter *)
        | CE_ref (decl) => 
          match (find_parm (decl.name)) {
            | Some ((_, index)) =>
              match (index) {
                | 0 => _ilg.Emit (OpCodes.Ldarg_0)
                | 1 => _ilg.Emit (OpCodes.Ldarg_1)
                | 2 => _ilg.Emit (OpCodes.Ldarg_2)
                | 3 => _ilg.Emit (OpCodes.Ldarg_3)
                | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, index)
                | _ => _ilg.Emit (OpCodes.Ldarg, index)
              }
            | None =>
              Message.debug ("FIXME: CE_ref " + decl.name);
              assert (decl.local_slot != null);
              _ilg.Emit (OpCodes.Ldloc, decl.local_slot)
          };
          false


        (* load the value of a field *)
        | CE_field_ref (base_object, field) =>
          if (emit (base_object)) true
          else {
            def field_info = 
              _cgil.get_field_info (field);
              
            _ilg.Emit (OpCodes.Ldfld, field_info);
            false
          }


        (* load the value of a static field *)
        | CE_global_ref ((CM_field) as field) =>
          def field_info = 
            _cgil.get_field_info (field);
              
          (* check if we're talking about an enum *)
          def (class_name, field_name) = _cgil.split_global_ref (field.extern_name);
          
          Message.debug ("FIXME: CE_global_ref (CM_field) " + class_name + "::" + field_name);

          def base_class_type = 
            _cgil.reflect_type (class_name);
              
          if (base_class_type.IsEnum) {
          
            Message.debug ("FIXME: dealing with an enum...");

            def value = (System.Enum.Parse (base_class_type, field_name) :> int);

            Message.debug ("FIXME: value is: " + string_of_int (value));

            match (value) {
              | 0 => _ilg.Emit (OpCodes.Ldc_I4_0)
              | 1 => _ilg.Emit (OpCodes.Ldc_I4_1)
              | 2 => _ilg.Emit (OpCodes.Ldc_I4_2)
              | 3 => _ilg.Emit (OpCodes.Ldc_I4_3)
              | 4 => _ilg.Emit (OpCodes.Ldc_I4_4)
              | 5 => _ilg.Emit (OpCodes.Ldc_I4_5)
              | 6 => _ilg.Emit (OpCodes.Ldc_I4_6)
              | 7 => _ilg.Emit (OpCodes.Ldc_I4_7)
              | 8 => _ilg.Emit (OpCodes.Ldc_I4_8)
              | k when k >= -128 && k <= 127 => _ilg.Emit (OpCodes.Ldc_I4_S, k)
              | k => _ilg.Emit (OpCodes.Ldc_I4, k)            
            }            
          }
          else _ilg.Emit (OpCodes.Ldsfld, field_info);
          false


        (* load the value of a property *)
        | CE_property_ref (base_object, prop) =>
          if (emit (base_object)) true
          else {
            def base_class_type = 
              _cgil.reflect_nemerle_type (type_of (base_object));
            assert (base_class_type != null);
            
            def method_info = 
              _cgil.get_external_method_info (base_class_type.FullName,
                                              "get_" + prop.name, false, []);
                                                          
            assert (method_info != null, "CE_property_ref unable to fetch " + 
              base_class_type.FullName + ".get_" + prop.name + " method");

            if (base_class_type.IsValueType)
              _ilg.Emit (OpCodes.Call, method_info)            
            else
              _ilg.Emit (OpCodes.Callvirt, method_info);
            false
          }


        (* load the value of a parametrized property *)
        | CE_indexer (_, prop, base_object, indexer_parms) =>
          if (emit (base_object)) true
          else {
            def base_class_type = 
              _cgil.reflect_nemerle_type (type_of (base_object));
            assert (base_class_type != null);

            // FIXME: using indexer_parms here is asking for trouble...            
            def method_info = 
              _cgil.get_external_method_info (base_class_type.FullName,
                                              "get_" + prop.name, false, 
                                              make_expr_call_parms (indexer_parms));
                                              
            assert (method_info != null, "CE_indexer unable to fetch " + 
              base_class_type.FullName + ".get_" + prop.name + " method");

            if (emit_call_parameters (indexer_parms)) true
            else {
              if (base_class_type.IsValueType)
                _ilg.Emit (OpCodes.Call, method_info)            
              else
                _ilg.Emit (OpCodes.Callvirt, method_info);
              false
            }
          }


        (* load the value of a property *)
        | CE_global_ref ((CM_property) as prop) =>
          def (class_name, prop_name) = _cgil.split_global_ref (prop.extern_name);
          
          def method_info = 
            _cgil.get_external_method_info (class_name, "get_" + prop_name, true, []);

          assert (method_info != null, "CE_global_ref (CM_property) unable to fetch " + 
            class_name + ".get_" + prop_name + " static method");

          _ilg.Emit (OpCodes.Call, method_info);
          false


        (* load the value of a tuple element *)
        | CE_tuple_ref (tuple_object, field_index) => 
          if (emit (tuple_object)) true
          else {
            def tuple_type = 
              _cgil.reflect_nemerle_type (type_of (tuple_object));
              
            assert (tuple_type != null);

            def field_info = 
              _cgil.get_internal_field_info (tuple_type.FullName, "field" + string_of_int (field_index + 1));
              
            _ilg.Emit (OpCodes.Ldfld, field_info);
            false
          }


        (* load an array element *)
        | CE_array_indexer (element_type, array_obj, [index]) =>
          if (emit (array_obj)) true
          else {          
            if (emit (index)) true
            else {
              emit_array_load_opcode (element_type);
              false
            }
          }
        
        | CE_array_indexer => 
          Util.ice ("multidimensional arrays should be accessed by means of properties")


        (* -- ASSIGNMENTS -------------------------------------------------- *)

        (* FIXME *)
        | CE_assign (CE_cast (expr, _), val) =>
          // Message.debug ("FIXME: warning, working around the CE_cast () <- val bug");
          emit (CE_assign (expr, val))

        (* assignment to a local variable *)
        // FIXME: what about out/ref parameters?
        | CE_assign (CE_ref (local_var), val) =>
          if (local_var.local_slot != null) {
            if (emit (val)) true
            else {
              _ilg.Emit (OpCodes.Stloc, local_var.local_slot);
              false
            }
          } else {
            Message.debug (expr.loc, "FIXME: assignment to a null slot " + local_var.name);
            _ilg.Emit (OpCodes.Ldstr, "assignment to a null slot");
            false
          }

        (* assignment to a field *)
        | CE_assign (CE_field_ref (base_object, field), val) =>
          def field_info = 
            _cgil.get_field_info (field);

          if (emit (base_object)) true
          else if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stfld, field_info);
            false
          }


        (* assignment to a static field *)
        | CE_assign (CE_global_ref ((CM_field) as field), val) =>
          if (emit (val)) true
          else {
            def field_info = 
              _cgil.get_field_info (field);
          
            _ilg.Emit (OpCodes.Stsfld, field_info);
            false
          }


        (* assignment to a property *)
        | CE_assign (CE_property_ref (base_object, prop), val) =>
          if (emit (base_object)) true
          else {
            def base_class_type = 
              _cgil.reflect_nemerle_type (type_of (base_object));
            assert (base_class_type != null);
            
            def method_info = base_class_type.GetMethod ("set_" + prop.name);
            assert (method_info != null, "CE_property_ref unable to fetch " + 
              base_class_type.FullName + ".set_" + prop.name + " method");

            if (emit (val)) true
            else {
              if (base_class_type.IsValueType)
                _ilg.Emit (OpCodes.Call, method_info)            
              else
                _ilg.Emit (OpCodes.Callvirt, method_info);
              false
            }
          }


        (* assignment to a parametrized property *)
        | CE_assign (CE_indexer (_, prop, base_object, indexer_parms), val) =>
          if (emit (base_object)) true
          else {
            def base_class_type = 
              _cgil.reflect_nemerle_type (type_of (base_object));
            assert (base_class_type != null);

            // FIXME: using indexer_parms here is asking for trouble...
            def method_parms = List.append (indexer_parms, [val]);
            
            def method_info = 
              _cgil.get_external_method_info (base_class_type.FullName,
                                              "set_" + prop.name, false, 
                                              make_expr_call_parms (method_parms));
                                              
            assert (method_info != null, "CE_assign CE_indexer unable to fetch " + 
              base_class_type.FullName + ".set_" + prop.name + " method");

            if (emit_call_parameters (method_parms)) true
            else {
              if (base_class_type.IsValueType)
                _ilg.Emit (OpCodes.Call, method_info)            
              else
                _ilg.Emit (OpCodes.Callvirt, method_info);
              false
            }
          }


        (* assignment to a tuple element *)
(*
        | CE_assign (CE_tuple_ref (tuple_object, index), val) =>
          if (emit (tuple_object)) true
          else {
            def tuple_type = 
              _cgil.reflect_nemerle_type (type_of (tuple_object));
              
            assert (tuple_type != null);

            def field_info = 
              _cgil.get_field_info (tuple_type.FullName + ".field" + string_of_int (field_index + 1));
              
            assert (Option.is_some (field_info));

            _ilg.Emit (OpCodes.Ldfld, Option.unsome (field_info));
            false
          }
*)


        (* assignment to an array element *)
        | CE_assign (CE_array_indexer (element_type, array_obj, [index]), val) =>
          if (emit (array_obj)) true
          else {          
            if (emit (index)) true
            else {
              if (emit (val)) true
              else {
                emit_array_store_opcode (element_type);
                false
              }
            }
          }
        
        | CE_assign (CE_array_indexer, _) => 
          Util.ice ("multidimensional arrays should be accessed by means of properties")


        (* -- CALLS -------------------------------------------------------- *)

        (* call the base constructor *)
        | CE_call (CE_base (base_class), ctor_params) =>          
          _ilg.Emit (OpCodes.Ldarg_0);

          if (emit_call_parameters (ctor_params)) true
          else {
            def ctor_info = _cgil.get_ctor_info (base_class, make_expr_call_parms (ctor_params));

            _ilg.Emit (OpCodes.Call, ctor_info);
            false
          }


        (* create a new object *)
        | CE_call (CE_default_ctor_ref (ctor_class), ctor_params) =>
          if (emit_call_parameters (ctor_params)) true
          else {
            def ctor_info = _cgil.get_ctor_info (ctor_class, make_expr_call_parms (ctor_params));

            _ilg.Emit (OpCodes.Newobj, ctor_info);
            false
          }


        (* create a new object *)
        | CE_call (CE_ctor_ref (_, ctor), ctor_params) =>
          if (emit_call_parameters (ctor_params)) true
          else {
            def ctor_info = _cgil.get_ctor_info (ctor, make_call_parms (ctor.parms));
            
            _ilg.Emit (OpCodes.Newobj, ctor_info);
            false
          }


        (* create a new tuple *)
        | CE_tuple_ctor (tuple_elems) =>
          if (emit_call_parameters (tuple_elems)) true
          else {
            def ctor_info = get_tuple_constructor (List.length (tuple_elems));
            
            _ilg.Emit (OpCodes.Newobj, ctor_info);
            false
          }
          

        (* emit a call to an instance method, basing on an instance field's contents *)
        | CE_call (CE_method_ref (CE_field_ref (base_object, field), method), method_params) => 
          if (emit (base_object)) true
          else {
            def base_class_type = _cgil.reflect_nemerle_type (field.ty);
            assert (base_class_type != null);
            
            def field_info = 
              _cgil.get_field_info (field);
              
            if (base_class_type.IsValueType)
              _ilg.Emit (OpCodes.Ldflda, field_info)
            else
              _ilg.Emit (OpCodes.Ldfld, field_info);

            def method_info = 
              _cgil.get_method_info (method, make_call_parms (method.parms));

            if (emit_call_parameters (method_params)) true
            else {
              if (base_class_type.IsValueType)
                _ilg.Emit (OpCodes.Call, method_info)
              else
                _ilg.Emit (OpCodes.Callvirt, method_info);
              false
            }
          }


        (* emit a call to an instance method, basing on a static field's contents *)
        | CE_call (CE_method_ref (CE_global_ref ((CM_field) as field), method), method_params) => 
          def base_class_type = _cgil.reflect_nemerle_type (field.ty);
          assert (base_class_type != null);

          def field_info = 
            _cgil.get_field_info (field);
              
          if (base_class_type.IsValueType)
            _ilg.Emit (OpCodes.Ldsflda, field_info)
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);
          
          def method_info = 
            _cgil.get_method_info (method, make_call_parms (method.parms));

          if (emit_call_parameters (method_params)) true
          else {
            if (base_class_type.IsValueType)
              _ilg.Emit (OpCodes.Call, method_info)
            else
              _ilg.Emit (OpCodes.Callvirt, method_info);
            false
          }



        (* emit a call to an instance method, basing on a parameter or a local variable *)
        | CE_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method), method_params) => 
          def base_class_type = _cgil.reflect_nemerle_type (decl.ty);
          assert (base_class_type != null);
          
          def method_info = 
            _cgil.get_method_info (method, make_call_parms (method.parms));

          if (base_class_type.IsValueType) {
            match (find_parm (decl.name)) {
              | Some ((_, index)) =>
                match (index) {
                  | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, index)
                  | _ => _ilg.Emit (OpCodes.Ldarga, index)
                }
              | None =>
                assert (decl.local_slot != null);
                _ilg.Emit (OpCodes.Ldloca, decl.local_slot)
            }
          }
          else {
            def _ = emit (decl_ref); ()
          };
          
          if (emit_call_parameters (method_params)) true
          else {
            if (base_class_type.IsValueType)
              _ilg.Emit (OpCodes.Call, method_info)
            else
              _ilg.Emit (OpCodes.Callvirt, method_info);
            false
          }


        (* emit a call to an instance method *)
        | CE_call (CE_method_ref (base_object, method), method_params) => 
          // Message.debug ("CE_call CE_method to " + method.extern_name + "/" + string_of_int (method.id));
          // Message.debug ("base object is: " + pretty_print (base_object));
          
          if (emit (base_object)) true
          else {
            def base_class_type = 
              _cgil.reflect_nemerle_type (type_of (base_object));
            assert (base_class_type != null);
            
            def method_info = 
              _cgil.get_method_info (method, make_call_parms (method.parms));

            if (emit_call_parameters (method_params)) true
            else {
              if (base_class_type.IsValueType)
                _ilg.Emit (OpCodes.Call, method_info)            
              else
                _ilg.Emit (OpCodes.Callvirt, method_info);
              false
            }
          }


        (* emit a call to a static method *)
        | CE_call (CE_global_ref ((CM_method) as m), parms) =>
          if (emit_call_parameters (parms)) true
          else {
            match (m.extern_name) {
              // FIXME: add type information to the %op notation
              // FIXME: add the checked/unchecked flags
              // FIXME: handle the overloaded operators properly (see == and != for System.String)
              | "%op+" => 
                when (List.length (parms) == 1) _ilg.Emit (OpCodes.Ldc_I4_0); // FIXME: unary plus
                _ilg.Emit (OpCodes.Add_Ovf);
              | "%op-" => 
                when (List.length (parms) == 1) _ilg.Emit (OpCodes.Ldc_I4_0); // FIXME: unary minus
                _ilg.Emit (OpCodes.Sub_Ovf);
              | "%op*" => _ilg.Emit (OpCodes.Mul_Ovf);
              | "%op/" => _ilg.Emit (OpCodes.Div);
              | "%op%" => _ilg.Emit (OpCodes.Rem);
              | "%op|" => _ilg.Emit (OpCodes.Or);
              | "%op&" => _ilg.Emit (OpCodes.And);
              | "%op!" =>
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq);                
              | "%op==" => _ilg.Emit (OpCodes.Ceq);
              | "%op!=" => 
                _ilg.Emit (OpCodes.Ceq);
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq);
              | "%op<" => emit_compare (OpCodes.Blt_S)
              | "%op>" => emit_compare (OpCodes.Bgt_S)
              | "%op<=" => emit_compare (OpCodes.Ble_S)
              | "%op>=" => emit_compare (OpCodes.Bge_S)
              | _ =>
                // Message.debug ("CE_call (CE_global_ref (" + m.extern_name + "), _)");
                              
                def method_info =
                  _cgil.get_method_info (m, make_call_parms (m.parms));

                _ilg.Emit (OpCodes.Call, method_info)
            };

            false
          }


        (* -- TAIL CALLS --------------------------------------------------- *)

        // FIXME: convert this to tailcall/call

        (* marks a method as tail calling *)
        | CE_block (_) =>
          Util.ice ()
          //_tail_call_block_label <- _ilg.DefineLabel ();
          //emit (expr)


        (* restarts the method execution *)
        | CE_restart =>
          Util.ice ()
          //_ilg.Emit (OpCodes.Br, _tail_call_block_label);
          //true


        (* -- EXCEPTION HANDLING ------------------------------------------- *)

        (* raise an exception *)
        | CE_raise (exc) =>
          if (emit (exc)) true
          else {
            _ilg.Emit (OpCodes.Throw);
            true
          }


        (* emit the try/with construction *)
        | CE_try_with (try_expr, catch_val, catch_expr) =>          
          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff = emit (try_expr);

          def ignore_try_result = cutoff || is_dummy_type (type_of (try_expr));
          mutable try_result <- null;

          unless (ignore_try_result) {
            try_result <- _ilg.DeclareLocal (_cgil.reflect_nemerle_type (type_of (try_expr)));
            _ilg.Emit (OpCodes.Stloc, try_result)
          };
          
          _ilg.BeginCatchBlock (_cgil.reflect_nemerle_type (catch_val.ty));

          catch_val.local_slot <- _ilg.DeclareLocal (_cgil.reflect_nemerle_type (catch_val.ty));
          catch_val.local_slot.SetLocalSymInfo (catch_val.name);

          _ilg.Emit (OpCodes.Stloc, catch_val.local_slot);
          
          def _ = emit (catch_expr);
          
          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        | CE_try_finally (try_expr, finally_expr) =>
          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff = emit (try_expr);

          def ignore_try_result = cutoff || is_dummy_type (type_of (try_expr));
          mutable try_result <- null;

          unless (ignore_try_result) {
            try_result <- _ilg.DeclareLocal (_cgil.reflect_nemerle_type (type_of (try_expr)));
            _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          def _ = emit (finally_expr);

          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        (* -- MISC --------------------------------------------------------- *)

        (* loads the 'this' pointer on the evaluation stack *)
        | CE_this =>
          assert (!_is_static_method);

          _ilg.Emit (OpCodes.Ldarg_0);
          false


        (* loads a literal on the evaluation stack *)
        | CE_literal (l) =>
          emit_literal (l);
          false


        (* creates a new array, given a list of initializers *)
        | CE_mkarray (element_type, initializers) =>           
          def framework_element_type = _cgil.reflect_nemerle_type (element_type);
          def array_type = _cgil.reflect_type (framework_element_type.FullName + "[]");
          assert (array_type != null, "cannot reflect an array of " + framework_element_type.FullName);
          
          def local_slot = _ilg.DeclareLocal (array_type);
                    
          _ilg.Emit (OpCodes.Ldc_I4, List.length (initializers));
          _ilg.Emit (OpCodes.Newarr, framework_element_type);

          _ilg.Emit (OpCodes.Stloc, local_slot);

          def load_elements (index : int, elements : list (CG_expr)) : bool {
            match (elements) {
              | [] => false
              | element :: rest =>
                _ilg.Emit (OpCodes.Ldloc, local_slot);
                _ilg.Emit (OpCodes.Ldc_I4, index);                
                if (emit (element)) true
                else {
                  emit_array_store_opcode (element_type);
                  load_elements (index + 1, rest)
                }
            }
          };

          def cutoff = load_elements (0, initializers);          
          unless (cutoff) _ilg.Emit (OpCodes.Ldloc, local_slot);          
          cutoff


        (* a non-interrupting NOP instruction *)
        | CE_skip => false
        
        
        (* an interrupting NOP instruction *)
        | CE_none => true

        | _ =>
          Message.warning ("FIXME: unmatched: " + pretty_print (expr));
          false
      }
    }


    (**
     * Checks if two given types denote the same value type.
     * FIXME: this is a workaround for the type system not expanding type aliases.
     *)
    private is_same_value_type (l : CG_type, r : CG_type) : bool
    {
      match ((l, r)) {
        | (CT_bool, CT_bool)
        | (CT_ref ("System.Boolean"), CT_ref ("bool"))
        | (CT_ref ("bool"), CT_ref ("System.Boolean"))
        | (CT_ref ("System.Char"), CT_ref ("char"))
        | (CT_ref ("char"), CT_ref ("System.Char"))
        | (CT_ref ("System.Int32"), CT_ref ("int"))
        | (CT_ref ("int"), CT_ref ("System.Int32"))
        | (CT_ref (l_name), CT_ref (r_name)) when l_name == r_name => true
        | _ => false        
      }
    }


    (**
     * Emits a STELEM instruction for a given type
     *)
    private emit_array_store_opcode (ty : CG_type) : void
    {
      def opcode =
        match (ty) {
          | CT_bool
          | CT_ref ("System.SByte") 
          | CT_ref ("System.Boolean")
          | CT_ref ("System.Byte") => OpCodes.Stelem_I1
          | CT_ref ("System.Char")
          | CT_ref ("System.Int16")
          | CT_ref ("System.UInt16") => OpCodes.Stelem_I2
          | CT_ref ("System.Int32")
          | CT_ref ("System.UInt32") => OpCodes.Stelem_I4
          | CT_ref ("System.Int64")
          | CT_ref ("System.UInt64") => OpCodes.Stelem_I8
          | CT_ref ("System.Single") => OpCodes.Stelem_R4
          | CT_ref ("System.Double") => OpCodes.Stelem_R8
          | CT_object 
          | CT_array
          | CT_tuple
          | CT_fun
          | CT_ref => OpCodes.Stelem_Ref
          | _ => Util.ice ("invalid array element type")         
        };
        
      _ilg.Emit (opcode)          
    }


    (**
     * Emits a LDELEM instruction for a given type
     *)
    private emit_array_load_opcode (ty : CG_type) : void
    {
      def opcode =
        match (ty) {
          | CT_bool
          | CT_ref ("System.SByte") 
          | CT_ref ("System.Boolean")
          | CT_ref ("System.Byte") => OpCodes.Ldelem_I1
          | CT_ref ("System.Char")
          | CT_ref ("System.Int16")
          | CT_ref ("System.UInt16") => OpCodes.Ldelem_I2
          | CT_ref ("System.Int32")
          | CT_ref ("System.UInt32") => OpCodes.Ldelem_I4
          | CT_ref ("System.Int64")
          | CT_ref ("System.UInt64") => OpCodes.Ldelem_I8
          | CT_ref ("System.Single") => OpCodes.Ldelem_R4
          | CT_ref ("System.Double") => OpCodes.Ldelem_R8
          | CT_object 
          | CT_array
          | CT_tuple
          | CT_fun
          | CT_ref => OpCodes.Ldelem_Ref
          | _ => Util.ice ("invalid array element type")         
        };
        
      _ilg.Emit (opcode)          
    }


    (**
     * Checks if a given expression increases stack height. This is used 
     * while flattening the middle elements of a CE_sequence to decide 
     * if it is necessary to emit a POP instruction or not.
     *)
    private increases_stack_height (expr : CG_expr) : bool
    {
      match (expr) {
        | CE_let => false
        | _ =>
          match (type_of (expr)) {
            | CT_void
            | CT_ref ("System.Void") => false
            | _ => true
          }
      }
    }
    
   

    (**
     * Emits a LDIND instruction for a given value type
     *)
    private emit_ldind_for_value_type (ty : CG_type) : void
    {
      match (ty) {
        | CT_ref ("System.Reflection.MethodAttributes") => 
          _ilg.Emit (OpCodes.Ldobj, typeof(System.Reflection.MethodAttributes))
        | CT_ref ("System.Reflection.FieldAttributes") => 
          _ilg.Emit (OpCodes.Ldobj, typeof(System.Reflection.FieldAttributes))
        | CT_ref ("System.Reflection.MemberTypes") => 
          _ilg.Emit (OpCodes.Ldobj, typeof(System.Reflection.MemberTypes))
        | CT_ref ("System.Reflection.Emit.OpCode") => 
          _ilg.Emit (OpCodes.Ldobj, typeof(System.Reflection.Emit.OpCode))
        | _ =>
          def opcode =
            match (ty) {
              | CT_bool
              | CT_ref ("bool") 
              | CT_ref ("System.SByte") 
              | CT_ref ("System.Boolean") => OpCodes.Ldind_I1
              | CT_ref ("System.Byte") => OpCodes.Ldind_U1
              | CT_ref ("char")
              | CT_ref ("System.Char")
              | CT_ref ("System.Int16") => OpCodes.Ldind_I2
              | CT_ref ("System.UInt16") => OpCodes.Ldind_U2
              | CT_ref ("int")
              | CT_ref ("System.Int32") => OpCodes.Ldind_I4
              | CT_ref ("System.UInt32") => OpCodes.Ldind_U4
              | CT_ref ("System.Int64") => OpCodes.Ldind_I8
              | CT_ref ("System.UInt64") => Util.ice ("how to ldind System.UInt64?") // FIXME
              | CT_ref ("System.Single") => OpCodes.Ldind_R4
              | CT_ref ("System.Double") => OpCodes.Ldind_R8
              | CT_ref (unknown) => Util.ice ("not a recognized value type: " + unknown)
              | _ => Util.ice ("not a recognized value type") // FIXME
            };
            
          _ilg.Emit (opcode)
      }
    }


    (**
     * Returns a tuple constructor
     *)
    private get_tuple_constructor (arity : int) : ConstructorInfo
    {
      def class_name = "Nemerle.Tuple" + string_of_int (arity);
      
      def tuple_class' = _cgil.get_class_by_name (class_name);
      assert (Option.is_some (tuple_class'), class_name + " not found");

      def tuple_class = Option.unsome (tuple_class');      
      assert (Option.is_some (tuple_class.default_ctor), 
        class_name + " does not have a default ctor exposed");
      def default_ctor = Option.unsome (tuple_class.default_ctor);

      assert (List.length (default_ctor.parms) == arity, 
        class_name + "'s default ctor has wrong arity (expected " + string_of_int (arity) + 
        ", got " + string_of_int (List.length (default_ctor.parms)) + ")");

      assert (Option.is_some (default_ctor.ctor_builder),
        class_name + "'s default ctor does not have the ctor builder exposed");

      (Option.unsome (default_ctor.ctor_builder) :> ConstructorInfo)
    }


    (**
     * This method checks if a given expression contains 
     * a call to a class' base constructor.
     *)     
    internal static has_base_ctor_call (expr : CG_expr) : bool 
    {        
      match (expr) {
        | CE_sequence ([]) => false
        | CE_sequence (body) => List.exists (has_base_ctor_call, body)
        | CE_call (CE_base (_), _) => true
        | CE_cast (expr, _)
        | CE_block (expr) => has_base_ctor_call (expr)
        | _ => false
      }
    }


    (**
     * Emits a literal
     *)
    private emit_literal (l : Literal) : void
    {
      match (l) {
        | L_void => ()
        | L_null => _ilg.Emit (OpCodes.Ldnull)

        | L_int (-1) => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | L_int (0) => _ilg.Emit (OpCodes.Ldc_I4_0)
        | L_int (1) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_int (2) => _ilg.Emit (OpCodes.Ldc_I4_2)
        | L_int (3) => _ilg.Emit (OpCodes.Ldc_I4_3)
        | L_int (4) => _ilg.Emit (OpCodes.Ldc_I4_4)
        | L_int (5) => _ilg.Emit (OpCodes.Ldc_I4_5)
        | L_int (6) => _ilg.Emit (OpCodes.Ldc_I4_6)
        | L_int (7) => _ilg.Emit (OpCodes.Ldc_I4_7)
        | L_int (8) => _ilg.Emit (OpCodes.Ldc_I4_8)
        | L_int (k) when k >= -128 && k <= 127 => _ilg.Emit (OpCodes.Ldc_I4_S, k)
        | L_int (k) => _ilg.Emit (OpCodes.Ldc_I4, k)

        | L_char (k) when (k :> int) <= 127 => _ilg.Emit (OpCodes.Ldc_I4_S, (k :> int))
        | L_char (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
        
        | L_bool (true) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)

        | L_string (s) => _ilg.Emit (OpCodes.Ldstr, s)
        | L_float (_) => Util.ice ("CGIL: emit_il: CE_literal: L_float")
      }
    }


    (**
     * Emits a list of expressions. This is used to emit call parameters,
     * specialization allows better error messages here.
     *)
    private emit_call_parameters (parms : list (CG_expr)) : bool
    {
      match (parms) {
        | [] => false
        | parm :: rest =>
          if (emit (parm)) {
            Message.warning ("a control-flow terminating call parameter in " + _method_name);
            true
          }
          else emit_call_parameters (rest)
      }
    }


    (**
     *
     *)
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }


    (**
     *
     *)
    private make_call_parms (parms : list (CG_val)) : list (System.Type)
    {
      def mk_parm (parm : CG_val) : System.Type {
        _cgil.reflect_nemerle_type (parm.ty)
      };

      List.map (mk_parm, parms)    
    }


    (**
     *
     *)
    private make_expr_call_parms (parms : list (CG_expr)) : list (System.Type)
    {
      def mk_parm (parm : CG_expr) : System.Type {
        _cgil.reflect_nemerle_type (type_of (parm))
      };

      List.map (mk_parm, parms)
    }


    (**
     * Emits a code that raises an exception, using the exception 
     * class' default constructor.
     *
     * FIXME: this only works for types being built
     *)
    private emit_raise (exception_name : string) : void
    {
      def klass = Option.unsome (_cgil.get_class_by_name (exception_name));
      def ctor_info = _cgil.get_ctor_info (klass, []);

      _ilg.Emit (OpCodes.Newobj, ctor_info);
      _ilg.Emit (OpCodes.Throw)
    }

    
    (**
     * FIXME: put these values in a lookup table?
     *)
    private find_parm (parm_name : string) : option (CG_val * int)
    {
      def arg_index_offset = if (_is_static_method) 0 else 1;

      def find_parm_by_name (parms : list (CG_val), index) {
        match (parms) {
          | [] => None ()
          | parm :: rest =>
            if (parm.name == parm_name)
              Some ((parm, index))
            else
              find_parm_by_name (rest, index + 1)
        }
      };

      find_parm_by_name (_parms, arg_index_offset);
    }


    (**
     *
     *)
    private class_type (c : CM_class) : CG_type
    { 
      CT_ref (c.ns + c.name) 
    }


    (**
     *
     *)
    type_of (ex : CG_expr) : CG_type 
    {
      match (ex) {
        | CE_ref (d) => d.ty
        | CE_global_ref ((CM_field) as f) => f.ty
        | CE_global_ref ((CM_property) as p) => p.ty
        | CE_field_ref (_, f) => f.ty
        | CE_property_ref (_, p) => p.ty
        | CE_tuple_ref => CT_object ()
        | CE_call (CE_global_ref ((CM_method) as m), _) => m.ret_type
        | CE_call (CE_method_ref (_, m), _) => m.ret_type
        | CE_call (CE_default_ctor_ref (c), _) => class_type (c)
        | CE_call (CE_ctor_ref (c, _), _) => class_type (c)
        | CE_call (CE_base, _) => CT_void ()
        | CE_call => Util.ice ()
        | CE_assign => CT_void ()
        | CE_let (_, b) => type_of (b)
        | CE_has_type => CT_bool ()
        | CE_raise => CT_unreached ()
        | CE_if (t, _, _, _) => t
        | CE_try_with (e, _, _) => type_of (e)
        | CE_try_finally (e, _) => type_of (e)
        | CE_literal (l) => 
          match (l) {
            | L_void => CT_void ()
            | L_null => CT_object ()
            | L_int => CT_ref ("int")
            | L_char => CT_ref ("char")
            | L_string => CT_ref ("string")
            | L_float => CT_ref ("float")
            | L_bool => CT_ref ("bool")
          }
        | CE_this => CT_ref (_class_name)
        | CE_skip => CT_void ()
        | CE_cast (_, t) => t
        | CE_sequence (b) => type_of (List.last (b))
        | CE_tuple_ctor (es) => CT_tuple (List.length (es))
        // can't tell
        | CE_none => Util.ice ()
        // these are supported only as part of call
        | CE_global_ref (CM_method) => Util.ice ()
        | CE_global_ref (CM_class) => Util.ice ()
        | CE_default_ctor_ref => Util.ice ()
        | CE_ctor_ref => Util.ice ()
        | CE_method_ref => Util.ice ()
        | CE_base => Util.ice ()
        | CE_mkarray (element_type, _) => CT_array (element_type)
        | CE_indexer (t, _, _, _) => t
        | CE_array_indexer (t, _, _) => t
        | CE_block (expr) => type_of (expr)
        | CE_restart => CT_void ()
      }
    }


    (**
     *
     *)
    pretty_print_list (exs : list (CG_expr), acc : string) : string 
    {
      match (exs) {
        | [] => acc
        | ex :: rest => pretty_print_list (rest, acc + pretty_print (ex))
      }
    }


    (**
     *
     *)
    pretty_print (ex : CG_expr) : string 
    {
      match (ex) {
        | CE_ref (decl) => "CE_ref (" + decl.name + "); "
        | CE_global_ref (decl) => "CE_global_ref (" + decl.name + "); "
        | CE_default_ctor_ref (klass) => "CE_default_ctor_ref (" + klass.name + "); "
        | CE_ctor_ref (klass, _) => "CE_ctor_ref (" + klass.name + "); "
        | CE_field_ref (_, fld) => "CE_field_ref (" + fld.name +"); "
        | CE_property_ref (_, prop) => "CE_property_ref " + prop.name + "; "
        | CE_method_ref (_, meth) => "CE_method_ref (" + meth.name + "); "
        | CE_tuple_ref (_, pos) => "CE_tuple_ref (" + string_of_int (pos) + "); "
        | CE_call (func, parms) => "CE_call " + pretty_print (func) + " (" + pretty_print_list (parms, "") + "); "
        | CE_assign (target, source) => 
          pretty_print (target) + " <- " + pretty_print (source) + "; "
        | CE_let (name, body) => 
          "let " + name.name + " = " + pretty_print (name.val) + " in " + pretty_print (body) + "; "
        | CE_has_type (_, ty) => "CE_has_type (" + pretty_print_type (ty) + "); "
        | CE_raise (exn) => "CE_raise (" + pretty_print (exn) + "); "
        | CE_if (_, cond, e_then, e_else) => 
          "if (" + pretty_print (cond) + ") " + pretty_print (e_then) + " else " + pretty_print (e_else) + "; "
        | CE_try_with => "CE_try_with; "
        | CE_try_finally => "CE_try_finally; "
        | CE_literal => "CE_literal; "
        | CE_this => "CE_this; "
        | CE_base => "CE_base; "
        | CE_skip => "CE_skip; "
        | CE_cast (expr, ty) => "CE_cast < " + pretty_print (expr) + " to " + pretty_print_type (ty) + "> "
        | CE_sequence (body) => "{ " + pretty_print_list (body, "") + " }; "
        | CE_tuple_ctor (exprs) => "CE_tuple_ctor (" + pretty_print_list (exprs, "") + "); "
        | CE_none => "CE_none"
        | CE_mkarray (_, initializers) => "CE_mkarray { " + pretty_print_list (initializers, "") + " }; "
        | CE_indexer (_, _, obj, args) => "CE_indexer " + pretty_print (obj) + "[" + pretty_print_list (args, "") + "]" + "; "
        | CE_array_indexer (_, obj, args) => "CE_indexer " + pretty_print (obj) + "[" + pretty_print_list (args, "") + "]" + "; "
        | CE_block (expr) => "CE_block { " + pretty_print (expr) + " }; "
        | CE_restart => "CE_restart; "
      }
    }


    (**
     * Pretty prints a type
     *)
    private pretty_print_type (ty : CG_type) : string
    {
      match (ty) {
        | CT_ref (name) => "CT_ref (" + name + ")"
        | CT_void => "CT_void"
        | CT_object => "CT_object"
        | CT_bool => "CT_bool"
        | CT_unreached => "CT_unreached"
        | CT_tuple (arity) => "CT_tuple/" + string_of_int (arity)
        | CT_fun (arity) => "CT_fun/" + string_of_int (arity)
        | CT_array (ty) => "CT_array (" + pretty_print_type (ty) + ")"
      }     
    }


    (**
     *
     *)
    private is_dummy_type (t : CG_type) : bool 
    {
      match (t) {
        | CT_void => true
        | CT_unreached => true
        | _ => false
      }
    }
  } (* end of the class *)
  
} (* end of the namespace *)
