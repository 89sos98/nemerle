(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open List;

variant list ('a) =
  [
    | Cons { hd : 'a; tl : list ('a); }
    | Nil {}
  ]

class List
  {
    static ('a) append (x : list ('a), y : list ('a)) : list ('a) =
      match x with [
        | Nil => y
        | Cons ?x => Cons (x#hd, append (x#tl, y))
      ];

    // blah. otherwise @ is used as symbol name
    static ('a) `@` (x : list ('a), y : list ('a)) : list ('a) = extern "List.append";

    static ('a, 'b) map (f : 'a -> 'b, x : list ('a)) : list ('b) = 
      match x with [
        | Nil => Nil ()
        | Cons ?x => Cons (f (x#hd), map (f, x#tl))
      ];

    static ('a, 'b, 'c) map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) = 
      match (x, y) with [
        | (Nil, Nil) => Nil ()
        | (Cons (?x, ?xs), Cons (?y, ?ys)) => Cons (f (x, y), map2 (f, xs, ys))
        | _ => raise Invalid_argument("List.map2")
      ];

    static ('a) length (x : list ('a)) : int =
      letfun loop (acc : int, x : list ('a)) : int =
        match x with [
          | Cons ?x => loop (acc + 1, x#tl)
          | _ => acc
        ] in loop (0, x);

    static ('a, 'b) fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b =
      match l with [
        | Nil ?_ => acc
        | Cons ?l => fold_left (f, f (acc, l#hd), l#tl)
      ];

    static ('a) iter (f : 'a -> void, l : list ('a)) : void =
      letfun i (dummy : int, e : 'a) : int { f (e); dummy } in
      let _ = fold_left (i, 0, l) in
      ();

    static ('a) exists (f : 'a -> bool, l : list ('a)) : bool =
      match l with [
        | Nil => false
        | Cons (?h, ?t) => if f(h) then true else exists(f, t)
      ];

    static ('a, 'b, 'c) fold_left2 (f : 'c * 'a  * 'b -> 'c, acc : 'c, a : list ('a), b : list ('b)) : 'c =
      match (a, b) with [
        | (Nil, Nil) => acc
        | (Cons (?x, ?xs), Cons (?y, ?ys)) => fold_left2 (f, f (acc, x, y), xs, ys)
        | _ => raise Invalid_argument("List.fold_left2")
      ];
      
    static ('a, 'b) iter2 (f : 'a  * 'b -> void, a : list ('a), b : list ('b)) : void =
      match (a, b) with [
        | (Nil, Nil) => ()
        | (Cons (?x, ?xs), Cons (?y, ?ys)) => { f (x, y); iter2 (f, xs, ys) }
        | _ => raise Invalid_argument("List.iter2")
      ];

    static ('a, 'b) forall2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool =
      match (a, b) with [
        | (Nil, Nil) => true
        | (Cons (?x, ?xs), Cons (?y, ?ys)) =>
          if f (x, y) then forall2 (f, xs, ys)
          else false
        | _ => raise Invalid_argument("List.forall2")
      ];

    static ('a) forall (f : 'a -> bool, l : list ('a)) : bool =
      match l with [
        | Cons (?x, ?xs) =>
          if f (x) then forall (f, xs)
          else false
        | Nil => true
      ];

    static ('a) filter (f : 'a -> bool, l : list ('a)) : list ('a) =
      match l with [
        | Cons (?x, ?xs) =>
          if f (x) then Cons (x, filter (f, xs))
          else filter (f, xs)
        | Nil => Nil ()
      ];

    static ('a) cons (e1 : 'a) : list ('a) =
      Cons (e1, Nil ());
      
    static ('a) cons (e1 : 'a, e2 : 'a) : list ('a) =
      Cons (e1, cons (e2));
      
    static ('a) cons (e1 : 'a, e2 : 'a, e3 : 'a) : list ('a) =
      Cons (e1, cons (e2, e3));

    static ('a) rev (l : list ('a)) : list ('a)=
      letfun loop (acc : list ('a), l : list ('a)) : list ('a) =
        match l with [
          | Cons (?x, ?xs) => loop (Cons (x, acc), xs)
          | Nil => acc
        ] in loop (Nil (), l);

    static ('a) concat (l : list (list ('a))) : list ('a) =
      fold_left(append, Nil(), rev(l));
  }
