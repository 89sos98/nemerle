(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Macros {

  (** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => <[ Nil () ]>
        | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
      }
    }

  (** this method treats expression as syntax tree of list containing 
      expressions, which are arguments of variable argument constructs
      (sequence, tuple, etc.)
      it also apply given function to each argument
   *)
  decompose_list (f : Expr -> Expr, ex : Expr) : Expr
    {
      match (ex) {
        | <[ Cons ($h, $t) ]> =>
          <[ $(f (h)) :: $(decompose_list (f, t)) ]>
        | <[ Nil () ]> => ex
        | E_list (exprs) => make_quoted_list (f, exprs)
        | E_list_cons (head, tail) =>
          <[ $(f (head)) :: $(decompose_list (f, tail)) ]>
        | E_unquoted (e) => e
        | E_unquoted_patt (e) => ex
        | _ => Message.error ("Bad expression in quoted variable arguments list: "); 
          print_tree(ex, ""); f (ex)
      }
    }

  decompose_pattern_list (f : Pattern -> Expr, pa : Pattern) : Expr
    {
      match (pa) {
        | <[ pattern: Cons ($h, $t) ]> => 
          <[ $(f (h)) :: $(decompose_pattern_list (f, t)) ]>
        | P_cons (SS_string ("Nil"), _) => <[ Nil () ]>
//        | <[ pattern: Nil ]> => <[ Nil () ]>
        | P_list (patts) => make_quoted_list (f, patts)
        | P_list_cons (head, tail) =>
          <[ $(f (head)) :: $(decompose_pattern_list (f, tail)) ]>
        | P_unquoted (e) => e
        | _ => Message.error ("Bad pattern in quoted variable arguments list: "); 
          print_pattern(pa, ""); f (pa)
      }
    }

  decompose_type_list (f : Type -> Expr, ty : Type) : Expr
    {
      match (ty) {
        | T_prod (types) => 
          make_quoted_list (f, types)
        | T_unquoted (e) => e
        | _ => Message.error ("Bad type in quoted variable arguments list: "); 
          f (ty)
      }
    }

  quoted_sstring (st : Splicable_string) : Expr
    { match (st) {
        | SS_string (str) => 
          <[ Nemerle.Compiler.Parsetree.Splicable_string.SS_string ($(str : string)) ]>
        | SS_spliced_expr (e) => e
      }
    }

  quoted_literal (lit : Literal) : Expr
    {
      match (lit) {
        | L_void => <[ Nemerle.Compiler.L_void () ]>

       | L_null => <[ Nemerle.Compiler.L_null () ]>

       | L_int (val) =>
          <[ Nemerle.Compiler.L_int ($(val : int)) ]>

       | L_string (val) =>
          <[ Nemerle.Compiler.L_string ($(val : string)) ]>

       | L_float (val) =>
         <[ Nemerle.Compiler.L_float ($(val : float)) ]>

       | L_char (val) =>
         <[ Nemerle.Compiler.L_char ($(val : char)) ]>

       | L_bool (val) =>
         <[ Nemerle.Compiler.L_bool ($(val : bool)) ]>
      }
    }

  quoted_location (loc : Location) : Expr
    {
      <[ Nemerle.Compiler.Location ($(loc.file : string), $(loc.line : int),
 	                            $(loc.column : int)) ]>
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  public quoted_type (t : Type) : Expr
  {
    match (t) {
      | <[ type: $tycon (.. $args) ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)),
                                                 $(decompose_type_list (quoted_type, ar))) ]>
	  | _ =>
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)), 
                                                 $(make_quoted_list (quoted_type, args))) ]>
        }

      | T_var (name) => 
        <[ Nemerle.Compiler.Parsetree.T_var ($(name : string)) ]>
        
      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ty))) ]>
	
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ty))) ]>
	
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (from)), 
                                             $(quoted_type (to))) ]>
	
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Parsetree.T_void () ]>
	
      | T_infer =>
        <[ Nemerle.Compiler.Parsetree.T_infer () ]>
	
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quoted_type, args))) ]>

      | <[ type: array ($ty) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_array ($(quoted_type (ty))) ]>

      | T_unquoted (e) => e

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(decompose_type_list (quoted_type, ar))) ]>
    }	
  }

  public quoted_expr (expr : Expr) : Expr 
    {
      def quoted_funheader ( h : Fun_header ) : Expr
        {
          def quoted_param (p : Fun_parm) : Expr
            {
    	      <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_location (p.loc)),
                                                      $(p.name : string),
	                                              $(quoted_type (p.ty))) ]>
  	    };
    
          <[ Nemerle.Compiler.Parsetree.Fun_header ($(quoted_location (h.loc)),
                                                    $(h.name : string),
	    	      				    $(quoted_type (h.ret_type)),
  		      				    $(make_quoted_list (quoted_param, h.parms))) ]>
        };
    
      def quoted_fundecl (d : Function_decl) : Expr
        {
  	  <[ Nemerle.Compiler.Parsetree.Function_decl ($(quoted_funheader (d.header)),
 	                                               $(quoted_expr (d.body))) ]>
	};

      match (expr) {
        | <[ $(id : var) ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_ref ($(id : string)) ]>

        | <[ $obj . $mem ]> => 
                   <[ Nemerle.Compiler.Parsetree.E_member ($(quoted_expr (obj)),
                                                           $(quoted_sstring (mem))) ]>

//        | <[ $func (.. $params) ]> =>
	| E_call (func, params) =>
	  // create construction tree of given call parameter
	  def quoted_param (p : Parm) : Expr
	    {
              <[ Nemerle.Compiler.Parsetree.Parm ($(p.is_ref : bool), 
                                                  $(quoted_expr (p.expr)), 
                                                  $(p.name : string)) ]>
	    };

          <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)), 
                                                $(make_quoted_list (quoted_param, params))) ]>

        | <[ $target <- $source ]> =>
          <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (target)), 
                                                  $(quoted_expr (source))) ]>

        | <[ def $name = $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(false : bool), 
                                               $(quoted_sstring (name)), 
                                               $(quoted_expr (val))) ]>

        | <[ mutable $name <- $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(true : bool), 
                                               $(quoted_sstring (name)), 
                                               $(quoted_expr (val))) ]>

	| <[ def (.. $elems) = $val ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (P_tuple (elems))), 
                                                  $(quoted_expr (val))) ]>

        // <[ def $f (.. $args) : $ty ]> =>
	| E_letfun (funs) =>
	  <[ Nemerle.Compiler.Parsetree.E_letfun ($(make_quoted_list (quoted_fundecl, funs))) ]>

        // <[ fun ($args) : $ty { $body }
	| E_lambda (decl) =>
	  <[ Nemerle.Compiler.Parsetree.E_lambda ($(quoted_fundecl (decl))) ]>

//      | <[ match ($expr) {.. $cases } ]> =>
	| E_match (expr, cases) =>
	  def quoted_case (cas : Match_case) : Expr
	    {
              def guarded_pattern(pair : Pattern * option (Expr)) : Expr
                {
                  match (pair) {
                    | (pat, Some(gu)) =>
                        <[ ($(quoted_pattern (pat)), Some ($(quoted_expr (gu)))) ]>
                    | (pat, None) =>
                        <[ ($(quoted_pattern (pat)), None ()) ]>
                  }
                };
      
	      <[ Nemerle.Compiler.Parsetree.Match_case ($(make_quoted_list (guarded_pattern, 
                 cas.patterns)), $(quoted_expr (cas.body))) ]>
	    };
	
    	  <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                                                 $(make_quoted_list (quoted_case, cases))) ]>

	| <[ raise $exc ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (exc))) ]>

	| <[ try $body with $exn : $exn_ty => $handler ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_try_with ($(quoted_expr (body)), 
                                                    $(quoted_sstring (exn)),
                                                    $(quoted_type (exn_ty)), 
                                                    $(quoted_expr (handler))) ]>

        | <[ try $body finally $handler ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (body)), 
                                                       $(quoted_expr (handler))) ]>

        | <[ () ]> => 
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ null ]> => 
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_null ()) ]>

        | <[ $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ $(val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

        | <[ $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ this ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_this () ]>

        | <[ base ]> => 
	  <[ Nemerle.Compiler.Parsetree.E_base () ]>

        | <[ typeof ($t) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_typeof ($(quoted_type (t))) ]>

        | <[ ( $expr :> $ty ) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (expr)),
	                                                   $(quoted_type (ty))) ]>

        | <[ ( $expr : $ty ) ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (expr)),
	                                                    $(quoted_type (ty))) ]>

	| <[ {.. $seq } ]> =>
          match (seq) {
            | [E_expr_list (seq)] =>
              <[ Nemerle.Compiler.Parsetree.E_sequence ($(decompose_list (quoted_expr, seq))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_sequence ($(make_quoted_list (quoted_expr, seq))) ]>
          }

	| <[ (.. $args) ]> =>
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_tuple ($(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quoted_expr, args))) ]>
          }

    	| <[ mkarray [.. $args] ]> =>
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_mkarray ($(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_mkarray ($(make_quoted_list (quoted_expr, args))) ]>
          }
	
        | <[ $obj [.. $args] ]> =>  
          match (args) {
            | [E_expr_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.E_indexer ($(quoted_expr (obj)),
                                                       $(decompose_list (quoted_expr, args))) ]>
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_indexer ($(quoted_expr (obj)),
                                                       $(make_quoted_list (quoted_expr, args))) ]>
          }

        // rest of constructs must be in unquoted form, because they define
        // internal data structures
	| E_unquoted (e) => e

        | E_unquoted_patt => expr

        | E_spliced_literal (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.E_ref ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($val)) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in expression")
          }

    	| E_list (args) =>
	  // we lift up generated list, because it was designed to be spliced
          // not returned and it's being evaluated by typechecker
          def 'a id (x : 'a) : 'a { x; };
 	  quoted_expr (make_quoted_list (id, args))

        | E_list_cons (hd, tl) =>
	  // here we first compute what compiler should have given us in form of 
          // Cons constructor and then lift it up
          quoted_expr (<[ Cons ($(hd), $(tl)) ]>)

	| E_quoted_expr (e) => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_quoted_patt (e) => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_quoted_type (e) => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_quoted_texpr (e) => 
	  Message.fatal_error ("You've got beer from me for generating such a code...");
        | E_expr_list =>
          // print location
	  Message.debug ("list of expression parameters outside of any construct");
          Util.ice ("List of expression parameters outside of any construct")
        | E_letpat =>
          Util.ice ("Bad construction of E_letpat")
      };
    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction
      tree 
   *)	  
  public quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | <[ pattern: _ ]> => <[ Nemerle.Compiler.Parsetree.P_underscore () ]>

//        | <[ pattern: $(name : var) ]> =>
        | P_variable (name) => 
          <[ Nemerle.Compiler.Parsetree.P_variable ($(name : string)) ]>

        | <[ pattern: ($pat) as $name ]> => 
          <[ Nemerle.Compiler.Parsetree.P_as ($(quoted_pattern (pat)), 
                                              $(quoted_sstring (name))) ]>

        | <[ pattern: (.. $args) ]> =>
          match (args) {
            | [P_patt_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(decompose_pattern_list (quoted_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(make_quoted_list (quoted_pattern, args))) ]>
          }
        
        // | <[ pattern: {.. $args } ]> =>
        | P_record (args) => 
          def quoted_named_pattern (patt : Named_pattern) : Expr
            {
              <[ Nemerle.Compiler.Parsetree.Named_pattern 
                   ($(patt.name : string), $(quoted_pattern (patt.pat))) ]>
            };
             
           <[ Nemerle.Compiler.Parsetree.
              P_record ($(make_quoted_list (quoted_named_pattern, args))) ]>

        | <[ pattern: $name (.. []) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                         Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        | <[ pattern: $name (.. $args) ]> =>
          def tupl = quoted_pattern (P_tuple (args));
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), $tupl) ]>

//        | <[ pattern: $name {.. $args} ]> =>
        | P_cons (name, (P_record) as arg) => 
//          def reco = quoted_pattern (P_record (args));
          def reco = quoted_pattern (arg);
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), $reco) ]>

//        | <[ pattern: $(lit : int) ]> =>
//          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($(lit : int)) ]>

        | P_literal (lit) =>
  	  <[ Nemerle.Compiler.Parsetree.P_literal ($(quoted_literal (lit))) ]>

//        | <[ pattern: $name _ ]> =>
        | P_cons (name, P_underscore) =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
             Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        // rest of constructs must be in unquoted form, because they define
        // internal data structures
	| P_unquoted (e) => e

        | P_spliced_literal (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.P_variable ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($val)) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in pattern")
          }

        | P_list (args) =>
	  // we lift up generated list, because it was designed to be spliced not returned
	  // and it's being evaluated by typechecker
 	  quoted_pattern (expr_to_pattern (make_quoted_list (quoted_pattern, args)));

        | P_list_cons (hd, tl) =>
	  // here we first compute what compiler should have given us in form of 
          // Cons constructor and then lift it up
          quoted_pattern (expr_to_pattern (<[ P_cons (SS_string ("Cons"), 
                                                      P_tuple ($(quoted_pattern (hd)), 
                                                               $(quoted_pattern (tl)))) ]>));

        | P_quoted_expr =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_quoted_patt => 
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_quoted_type =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_patt_list =>
          Util.ice ("Variable pattern arguments list appears outside of proper construct")
        | P_cons (_, p) =>
          print_string("name "); print_pattern(p, "");
          Util.ice ("Bad constructed P_cons")
      } 
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  public expr_to_pattern (exp : Expr) : Pattern 
    {
      def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
        match (pars) {
          | [] => 
            match (acc) {
	      | [] => P_underscore ()
	      | _ => P_tuple (List.rev (acc))
            }
          | x::xs => convert_params (xs, expr_to_pattern (x.expr) :: acc)
        }
      };

      def flat_member (obj : Expr) : Expr {
        def collect_member (obj : Expr, acc : list(string)) : list (string) {
          match (obj) {
            | E_ref (id) => id :: acc
            | E_member (head, SS_string (id)) => collect_member (head, id :: acc)
            | _ => Util.ice ("Corrupted member while flatting member expr -> pattern")
          }
        };
        match (collect_member (obj, [])) {
          | x :: xs =>
            def inter = List.fold_left (
              fun (sb : System.Text.StringBuilder, s : string) : System.Text.StringBuilder 
                { sb.Append ("." + s) }, 
              System.Text.StringBuilder (x), xs);
            E_ref (inter.ToString ())
          | _ =>
            Util.ice ("collect_member returned empty list")
        }
      };

      match (exp) {
        | <[ $(id : var) ]> => P_cons (SS_string (id), P_underscore ())
        | E_call (constr, pars) =>
          match ((flat_member (constr), pars)) {
            | (E_ref ("Nemerle.Compiler.Parsetree.Parm"), 
               [{ expr = is_ref }; { expr = constr }; { expr = name  }]) => 
              P_record ([Named_pattern ("is_ref", expr_to_pattern (is_ref));
                         Named_pattern ("expr", expr_to_pattern (constr));
                         Named_pattern ("name", expr_to_pattern (name))])
            | (E_ref (con), _) => 
              P_cons (SS_string (con), convert_params (pars, []))
            | _ =>
              Util.ice ("flat_member returned not E_ref")
          }
        | E_literal (lit) => P_literal (lit)

	| E_unquoted_patt (p) => p

        | _ => 
          print_tree (exp, "");
          Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
      }
    }

  // DEBUG SECTION

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  public print_tree (exp : Expr, empty : string) : void
    {
      def convert_params (pars : list (Parm)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_tree (x.expr, empty + "  "); convert_params (xs )
        }
      };

      print_string (empty);

      def print_literal (lit : Literal ) : void
        {
	  match (lit) {
	    | L_string (s) => print_string (s)
            | L_int (i) => print_string (string_of_int (i))
	    | _ => print_string ("some literal")
          }
        };

      match (exp) {
        | E_ref (id) => print_string ("E_ref ("); print_string (id); print_endline (")")
        | E_call (E_ref (constr), params) => 
          print_string ("E_call (E_ref ("); print_string (constr); print_endline ("),");
          convert_params (params);
          print_string (empty);
	  print_endline (")")
        | E_call (constr, params) => 
          printf("E_call (\n"); print_tree(constr, empty + "  "); convert_params(params);
          printf("%s)\n", empty)
        | E_literal (lit) => print_string ("E_literal ("); print_literal (lit); print_endline (")")
	| E_list (args) =>      
     	  print_endline("E_list (");
	  def pr (e : Expr ) : void { print_tree (e, empty + "  "); };
	  def _ = List.map (pr, args);
	  print_endline(empty + ")");
	  ()
	| E_list_cons =>           
	  print_endline ("Bad constructed quoted expression in print - list_cons ")
	| E_sequence (seq) =>
	  print_endline("E_sequence ("); 
	  def pr (e : Expr ) : void { print_tree (e, empty + "  "); };
	  def _ = List.map (pr, seq);
	  print_endline(empty + ")")

	| E_tuple (args) =>
	  print_endline ("tuple")
        | E_member (o, SS_string (x)) =>
          printf("E_member (\n"); print_tree (o, empty + "  ");
	  print_endline (empty + "  " + x + ")");
        | E_member (o, _) =>
	  print_endline ("member spliced");
          print_tree (o, empty)
    	| E_assign => 
	  print_endline ("assign ")
    	| E_let  => 
	  print_endline ("let ")
    	| E_letpat  => 
	  print_endline ("letpat ")
    	| E_letfun => 
	  print_endline ("letfun ")
    	| E_lambda => 
	  print_endline ("lambda ")
    	| E_match  => 
	  print_endline ("match ")
    	| E_raise  => 
	  print_endline ("raise ")
    	| E_try_with => 
	  print_endline ("Bad constructed quoted expression in print - try_with ")
    	| E_try_finally => 
	  print_endline ("Bad constructed quoted expression in print - try_finally ")
    	| E_this => 
	  print_endline ("Bad constructed quoted expression in print - this ")
    	| E_typeof => 
	  print_endline ("Bad constructed quoted expression in print - typeof ")
    	| E_type_conversion => 
	  print_endline ("Bad constructed quoted expression in print - type_conversion ")
    	| E_type_enforcement => 
	  print_endline ("Bad constructed quoted expression in print - type_enforc ")
    	| E_quoted_expr => 
	  print_endline ("Bad constructed quoted expression in print - quoted_ex ")
    	| E_quoted_patt => 
	  print_endline ("Bad constructed quoted expression in print - quoted_patt ")
    	| E_quoted_type => 
	  print_endline ("Bad constructed quoted expression in print - quoted_ty ")
    	| E_quoted_texpr => 
	  print_endline ("Bad constructed quoted expression in print - quoted_ty ")
    	| E_unquoted => 
	  print_endline ("Bad constructed quoted expression in print - unquoted ")
    	| E_mkarray => 
	  print_endline ("Bad constructed quoted expression in print - mkarray ")
    	| E_indexer => 
	  print_endline ("Bad constructed quoted expression in print - indexer ")
    	| E_base => 
	  print_endline ("Bad constructed quoted expression in print - base ")
    	| E_unquoted_patt => 
	  print_endline ("Bad constructed quoted expression in print - unquoted_patt ")
    	| E_expr_list => 
	  print_endline ("Bad constructed quoted expression in print - expr_list ")
        | _ =>
          print_endline ("other")
      }
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  public print_pattern (pat : Pattern, empty : string) : void
    {
      def convert_params (pars : list (Pattern)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_pattern (x, empty + "  "); convert_params (xs)
        }
      };

      def print_args (args : list (Named_pattern)) : void {
	match (args) {
	  | [] => ()
	  | x::xs => print_string (empty + "  "); print_string (x.name); print_endline(" = "); 
                     print_pattern (x.pat, empty + "    "); print_args (xs)
 	}  
      };

      print_string (empty);

      match (pat) {
        | P_cons (SS_string (id), arg) => print_string ("P_cons ("); print_string (id); 
          print_endline (","); print_pattern (arg, empty + "  "); print_string (empty); 
          print_endline (")")
        | P_underscore => print_endline ("P_under")
        | P_record (args) => 
	   print_endline ("P_record (");
	   print_args (args); print_string (empty); print_endline (")")
        | P_tuple (args) => print_endline ("P_tuple ("); convert_params (args); 
            print_string (empty); print_endline (")")
        | _ => 
	   print_endline ("other")
      }
    }

}
} // end ns
