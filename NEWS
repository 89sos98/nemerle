0.2.9, Mar 22 2005
  This is preview release before 0.3.0, which is real soon now. There
  are lots of changes in this version -- the parser and the typer
  (which constitute more then half of the compiler) have been replaced
  by entirely new implementations.

  There is a number of backward incompatible changes in this release.
  Most of them were previously discussed on the mailing list, and
  received rather good feedback other only generate warnings in this
  release. We apologize for both. We hope they make Nemerle a better
  language. On the plus side -- we should be now far closer to certain
  language stabilization point.

  0.3.0 should bring implicit conversions, List iterators as list[T] methods
  and maybe some more goodies.
  
  Incompatible language changes:
    * Variant options are now nested inside enclosing variant, so their
      names need to be prefixed with variant name. For example:
        variant Foo { | A | B { x : int; } }
        ...
        def x = Foo.A ();
        match (some_foo) {
          | Foo.B (3) => ...
	  | _ => ...
        }
      You can mark variant with [ExternallyVisibleOptions] to import its
      options outside the variant or open variant name with 'using'. 
      More details in this thread:
      http://nemerle.org/mailman/pipermail/devel-en/2004-September/000256.html
    * Generic types use now [] instead of <>. That is there is 'list [int]' not
      'list <int>'. This is the second (and hopefuly last ;-) time we change it.
      More details in this thread:
      http://nemerle.org/mailman/pipermail/devel-en/2004-September/000259.html
    * Record patterns like '{ foo = 42; bar = 3 }' are now deprecated. New 'where'
      patterns have been introduced, to explicitly mark the class used for 
      matching:
        | Foo.Bar where (x = 3, y = Qux) => ...
        | Foo.Bar where (3, Qux) => ...
      Variant patterns now also support field names:
        | Deep.Though (x = 7) => ...
    * The ':' operator in patterns should from now on be only used to statically
      enforce type. Runtime type checks should be performed with the 'is' 
      operator which uses the same syntax:
        match (some_list) {
          | (x : int) :: xs => OverloadedFunction (x); loop (xs)
	  | [] => {}
        }

        match (some_expr) {
          | x is Foo => ...
	  | x is Bar => ...
	  | _ => ...
        }
      Trying to use ':' or 'is' in the other context will rise warning. It 
      will be hard error for ':' used as 'is' in future release.
    * The catch handler syntax has been changed to reflect change in 
      matching:
        try {
	  ...
	} catch {
	  | foo is SomeException => ...
	  | bar is Exception => ...
	  // or | bar => ...
	  // or | _ => ...
	}
    * Macros can no longer be nested in classes
  
    
  Language additions:
    * Added <<, >>, |, ^ and & operators. %|, %^ and %& remain there.
    * It is now possible to ignore values like this:
        _ = ignore_me (17);
    * It is now possible to assign stuff to tuples, like this:
        mutable x = 7;
	mutable y = "foo";
	(x, y) = (42, "bar");
    * Function parameters can be now marked 'mutable'.
    * The 'partial' modifier on classes is now supported.
    * '{ def _ = foo; }' is now allowed without the additional '()'
      at the end.
    * New 'throw;' expression to rethrow the exception.
    * The type inference engine has been replaced by a new one:
      - code like this compiles fine:
          def foo (x) { x.bar () }
	  List.Map (some_list, foo)
	when the type of 'some_list' is known.
      - overloading resolution now works when passing functional values:
          List.Sort (some_list, string.Compare)
      - variant option's constructors have now proper type, that is there
        is no longer need to 'SomeVariant.Option () :> SomeVariant.Option'
      - stuff like 'array [A (), B ()]' should now work (if 'A' and 'B' have a 
        common supertype)
    * Add 'repeat (times) body' language construct

  Library changes:
    * IMap.Fold used to use reverse parameter order then other fold 
      functions. It is fixed now.
    * A new Set class has been added.
    * Nemerle.Collections.Vector is now enumerable (patch by nuffer).
    * New functions in List:
      - MapFromArray
      - GetElementType
      - Contains
      - ContainsRef
      - FirstN
      - ToString (separator : string)
    * List Length() and IsEmpty() are now properties.
    * New functions in Option:
      - Iter
      - GetHashCode override
    * Stack.Top() is now a read/write property.
    
  Macro library changes:
    * Concurrency macros based on implementation of Polyphonic C# 
      has been added (implemented by Ricardo).
    * The foreach macro now uses semantics consistent with matching:
      foreach (s : string in foo) requires elements of foo to be of
      statically known type string, foreach (s :> string in foo)
      casts each element of foo to string (raising exception in case
      of problems) and foreach (s is string in foo) executes the loop
      body only for strings in foo.
    * Assertions macros now have new syntax extensions available. They can be
      used like in http://nemerle.org/macrouse.html#designbycontract
    * Added macro library for type-safe SQL operations with MS SQL Server
    * Diagnostics macros now have parameterless Trace macro and 'time' macro
      for measuring performance of some chunk of code
    * Quotations of patterns, types and expressions are now unified to simple use
      of <[ some code ]>
    * Added OverrideObjectEquals macro for automating overriding of
      Equals (object) method with type-safe Equals (SomeType) method

  Other stuff:
    * Parser has been changed, it gives better error recovery, forward
      lookup and capability of deferring parsing in syntax extensions 
      (see http://nemerle.org/mailman/pipermail/devel-en/2005-March/000427.html)
    * We have a new tool -- a C# to Nemerle converter. It produces
      human-readable Nemerle sources. 
    * We have added over 300 converted testcases from MCS. ncc
      behaves now far more sane and C#-like especially at the class level.
    * The -doc switch can be now used with NDoc.
    * Some warnings can be now disabled by-number, there is also -warn
      warning level switch.
    * Simple Nemerle interactive shell has been included in the distribution.
    * The debug symbol output should work under MS.NET.
    * The Sioux webserver has been greatly extended.
    * A syntax highlighting file for Midnight Commander editor.
    * The htmldumper tool has been written -- it creates pretty Nemerle 
      sources for the web.
    * It should be now easier to compile Nemerle on Windows using MinGW.
    * Lots of performance work -- in the compiler, the library and the 
      generated code.
    * Lots of bugs hunted.


0.2.1, Sep 18 2004
  This is a bugfix release to quickly fix issues found in 0.2.0.
  
    * Include *.snk key files in source tarball.
    * Fix bug with typing of write-only properties.
    * Allow $ "$$" to mean "$". Patch by Mike Roome.
    * Bitwise operators on enums without [Flags] generate warnings now,
      instead of errors.
    * value__ enum fields are now marked with rtspecialname (fixes
      verification problem).
    * try-blocks found inside of expressions now generate errors instead of
      invalid IL, it is going be investigated later.
    * The compiler now looks for libraries in directory it was run from.
    * 'foreach' macro can now take arbitrary pattern as argument, like

      foreach ((Some (x), y) in collection) {
        print (x, y)
      }

    * Fixed a few minor bugs in heap implementation, defining of command-line 
      preprocessor symbols, pretty printing of macro expressions, etc.
    
0.2.0, Sep 12 2004
  This version makes the Nemerle language full CLS consumer and producer.
  A number of non-CLS features are also in place, for C# compatibility,
  but we do not yet support CLSCompliant attribute checking. Any lack
  in CLS compliance is a bug now.

  The language:
    * Multidimensional arrays are now supported. This features was
      implemented by Ricardo Fernandez Pascual. The syntax for array
      types is: array <3, int> for three-dimensional int array (int[,,]).
      array <2> [[1, 2], [2, 3]] and array (2, 2) can be used for array
      object construction.
    * Fields can be now embedded in properties:
    
        public Foo : int {
          mutable foo : int;
          set { foo = value; }
          get { foo }
        }
	
      They are invisible outside the property.
    * base.foo() and base.foo now work properly.
    * Attribute targets (like [assembly: ]) are now supported. This finishes
      custom attributes support.
    * @"foo""bar" works now as described (as in C#, "foo\"bar"). Patch
      by Scott Fleckenstein.
    * The () can be now omitted in (foo :> int) and (foo : int).
    * A typecase:
        
	match (foo ()) {
	  | x : SomeType => x.field_of_sometype
	  | x : SomeOtherType => ...
	  | x : object => // always matches
	}
	
      The `:' pattern can be also used inside other patterns:
        
	match (foo ()) {
	  | [x : Foo] => ..
	  | _ => ..
	}

      The `is' operator, known from C# has also been added.
    * The `matches' operator has been added for one case matching:

      expr matches pattern == 
      match (expr) { pattern => true | _ => false }

      It is to be reconsidered, if `is' can be used for both purposes.
    * The `volatile' modifier is now respected and supported.
    * checked/unchecked are now supported, as seen in C#.
    * Other instance ctors can be now called from current ctor, using 
      'this(...)' syntax.
    * Delegates can be now produced.
    * Structs (classes that are value types, i.e. they are passed by
      value) are now supported. Tuple2 and Tuple3 internal types are now
      structs for efficiency.
    * Varargs functions (using `params' keyword, before array argument)
      are now supported.
    * All value objects have now implicit parameterless constructor,
      like in C#.
    * Usage of the `<-' operator (where `=' should be used) now generates
      a warning. It will be removed in a release or two.
    * The implicit constructor for value types can now be used. For example:
    
        def x = int ();
        def y = SDL_Event ();
    
    * Indexers can be now defined. Non-default indexers can be now
      referenced.

        public Item [x : int] : string { get { item [x] } }
        public FooBar [x : int, y : string] : int { 
          get { foo (x, y) }
          set { set_foo (x, y, value) }
        }

      The default indexer is always called `Item' currently. It can be
      accessed using x[3] as well as x.Item[3].
    * Enums can now be declared with expressions as values.
    * An implicit empty class ctor is now added as in C#.
    * `namespace X = G.D;' is now `using X = G.D;' (as in C#). The former
      form usage generates a warning.
    * New cool string interpolation feature -- the `$' operator is now
      shorthand to Nemerle.IO.sprint, example usage:

	def x = 40;
	def y = 42;
        System.Console.Write ($ "$(x + 2) == $y\n")

      Any expression can be used in $(...), but there might be problems
      with embedded strings and so on. It is meant to be used with simple
      expressions like array/field access, method call and so on.
    * The `==' has no fallback to reference equality now. This means, that
      if a class and its base classes have no overload for the `=='
      operator, then using `==' on it is an error. There are two
      exceptions: if (at least) one side of the `==' operator is
      (exactly) of the System.Object type, or one side of the `=='
      is the null literal, then reference equality is checked.
      A few bugs in the compiler was pointed out by this (more restrictive
      then in C#) feature. The same goes for the `!=' operator.
      
      All that means, that given:

        class A { }
        class B : A {
          public static @== (_ : B, _ : B) : bool { true }
        }

      The following is OK:

        (A () : object) == (A () : object) // false
        (A () : object) == A ()            // false
	A () == null                       // false
	(null : A) == null                 // true
	B () == B ()                       // true
	B () == null                       // true
	(B () : object) == null            // false
	(B () : object) == (B () : object) // false

      And the following are errors:
	
        A () == A ()
	A () == (null : A) // (null : A) is not null literal
	(B () : A) == (B () : A)
      
      
  The library:
    * Bugfixes in queue implementation.
    * Nemerle.Utility.Pair module added, with 3 little functions.
    * The foreach() macro is now optimized when used on arrays and lists.
    * Lots of reworking and rewrites, particularly introducing properties
      instead of methods here and there [[Pawel, maybe you can describe it?]]

  The compiler:
    * KeyFile, AssemblyName and Version attributes are now supported, with
      their special semantic meaning derived from C#.
    * -r option can now load assemblies from the GAC by strong name.
    * Nemerle assemblies can now be stored in the GAC, make install uses
      gacutil now. Beware of make boot problems, when the same version of
      Nemerle is installed in the GAC. Mono 1.0 is now required under Unix.
    * Fixes in constant loading, particularly decimals.
    * Using the obsolete `<-' assignment operator triggers now a warning.
    * New -resource and -linkresource switches for embedding/linking 
      resources into executables.
    * Lots of other bugfixes.

  Other stuff:
    * Sioux has been extended, generalized and documented.
    * CodeDomProvider for Nemerle has been submitted by Atsushi Enomoto.
      There is some preliminary work on XSP supporting Nemerle ASP.NET pages.
    * Async methods macros have been written by Ricardo Fernandez Pascual.

  
0.1.4, Jun 29 2004
  This is yet another incremental release before 0.2.0.

  The language:
    * The assignment operator <- has been changed to =. This was a long
      discussed issue. <- is still available, it will be deprecated in 
      0.2.0, and removed later. Please convert your sources, under Unix:
      
        perl -p -i -e 's/<-/=/g' *.n
	
      should do the trick.
    * The `;' is now optional after `}' in expressions. That is both:
    
        while (cond) { ... };
        foo ()
	
      and
      
        while (cond) { ... }
        foo ()
	
      are correct.
    * Expressions starting with keywords have now much lower priority.
      In particular:
      
        foo += fun (_) {...};
	
      needs to be now written like this:

        foo += (fun (_) {...});

      Sorry. This is however to be reconsidered.
    * 1_000_000 is now proper literal (like in Ada or Perl).
    * ref and out parameters are supported now.
    * try {...} catch {...} finally {...} is now proper code, 
      try { f () } catch {...} is too, but try f () catch {...} is not.

  The library:
    * Tuple and list types now provide proper ToString(), Equals() and 
      GetHashCode() methods.
    * List.Sort() was sorting in the opposite direction, we fixed that. Please
      update your sources.

  The compiler:
    * Some fixes to attribute support, in particular attribute classes
      can be defined and used in the same compilation.
    * Several new checks (like requiring implemented interface methods 
      to be public etc).
    * Several bugfixes.

  Other stuff:
    * Added examples written by students during Nemerle course. Some new
      OpenGL/SDL examples by Kamil.

  
0.1.3, May 30 2004
  This is an incremental release before 0.2.0, it has some more .NET
  connectivity features, although a few things are still missing (before
  we can call Nemerle a CLS extender).

  New language features in this release:
    * Properties and events can be now defined. Syntax is mostly the
      same as in C#.
    * Basic custom attribute support has been added. We do not support 
      attribute targets nor attributes on parameters yet.
    * Enums can be now defined.
    * +=, -=, *= etc operator on numbers.
    * Delegates can be now invoked like d() (not only d.Invoke()). 
      += and -= operators are overloaded for events and delegates to do
      The Right Thing(tm).
    * Macros can be now defined on declarations (types, methods, fields 
      etc). They are run using attribute syntax.
    * Preprocessor supporting conditional compilation has been added. 
      It shares semantics with one from C#, -define (aka -D) flag is also 
      supported.
    * Methods can be now defined inside variants. Thus a few library
      changes, like addition of ToString and + operator to list type.
    * Operators can be now overloaded (in addition to adding new).
    * Fields in classes can now have initializers (these are added
      to ctor).

  Other stuff:
    * External types are now stored in a specially crafted tree. All types
      are loaded on startup, but this saves time later.
    * Syntax extensions tied to macros are now activated only within
      namespace of given macro.
    * -pkg-config switch has been added, so external libraries (like
      Gtk#) can be easily linked, using -pkg:gtk-sharp.
    * -no-stdlib option now prevents mscorlib.dll and System.dll from being
      loaded, -library-path now works for them too.
    * ncc can now handle @response files.
    * Matching is being reworked, matching on variants is now a lot faster 
      than it used to be.
    * Some hacks to allow mono GAC usage (available in mono 0.91+, we do *not*
      require this beta version though).
    * There is new [Record] macro that adds record like constructor to given 
      class, there is no automatic constructor creation except for variant
      options now.
    * API for changing types from macros is being constantly reworked
      and improved.
    * List.Member and the like instead of physical == equality use Equals()
      method.
    * Several bugfixes, some critical, as usual.

0.1.2.1, Apr 30 2004
  This is just a quickfix -- some files were missing in tarball. There
  is also a slight macro documentation fix.

0.1.2, Apr 28 2004
  This release brings several important bugfixes, more documentation
  (great thanks to our techwriter for making it more readable) and
  improvements in macro subsystem.

    * Macros are now hygienic -- that is each macro invocation introduces
      new virtual namespace for generated names. See meta-programming paper
      for details.
    * Macros themselves now sits in namespaces. Notable example is printf,
      that is now Nemerle.IO.printf. You will need to update your sources.
      Common macros (like if and while) are in Nemerle.Core, so no changes
      are needed.
    * Symbols in macro quotations are now bound to their global meaning
      (e.g. imported namespaces, nesting in modules) at the place of 
      quotation definition, not the place of macro use.
    * The <-> operator now properly computes each expression just once.
    * Loading assembly with -r flag now loads also all assemblies
      referenced by it.
    * New integer operators <<, >>, %|, %& and %^ for common bitwise
      functions.
    * New -- and ++ prefix operators for decrement/increment (both return
      void).
    * Events can be now accessed with add_EventName and remove_EventName,
      no +=/-= syntax yet.
    * Full support for various integer and floating point types (like uint,
      long, double etc). Literals like 0u, 0l, 3.14f are now also supported.
    * System.Windows.Forms examples can now be compiled.
    * "foo" "bar" is now single string literal.
    * Added preliminary SQL helper macros.
    * Reordered parameters of Fold and Map in Hashtable to match List.
    * Few fixes in error messages.
    * Several other bugfixes (particularly with code generation and boxing).
    * Compiler now properly checks if type of field/method is as accessible
      as the field/method itself.
    * Resolved some lengthy compilation issues with Gtk# and 
      System.Windows.Forms types.
    * Resolved problem with literal fields on Windows.
    * Under Unix we now require mono 0.31 or later,

0.1.1, Feb 24 2004
  This is mainly bugfix release.
  
    * Fix bugs with tail call elimination (that lead to stack overflows 
      with simple loops).
    * Introduce new optimization of tail-loops, that doesn't require any
      allocations now.
    * Add -o alias for -out command line option, so ncc behaves in more
      standard way.
    * Fix type cast in foreach macro, it should now work.


0.1.0, Feb 17 2004
  First public release.
