/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Pretty printing of the parse and typed trees
 */

using System.Text;
 
using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler.Parsetree;
namespace TT = Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler
{
  public module PrettyPrint
  {
    /* ------------------------------------------------------------------------ */
    /* -- PARSE TREE ---------------------------------------------------------- */
    /* ------------------------------------------------------------------------ */
    
    SprintExpr (ctx : option<TypingContext>, expr : Expr, indentation : string,
                acc : StringBuilder) : void 
    {
      def add (x : string) { ignore (acc.Append (x)) };
    
      def expr = 
        match (ctx) {
          | Some (c) => MacroRegistry.expand_macro (c, expr)
          | _ => expr
        };

      def print_tparms (pars) {
        add ("<");
        add (NString.Concat (", ", List.Map (pars, Pair.First)));
        add (">")
      };

      def print_tconstraints (cts : list <Constraint>) {
        | [] => ()
        | x :: xs =>
          add (sprintf ("where %s : ", Pair.First (x.tyvar)));
          SprintType (x.ty, acc);
          print_tconstraints (xs)
      };

      def print_funparms (fps) {
        def print_funparm (p : Fun_parm) {
          | <[ funparm: $(n : name) : $ty ]> =>
            add (List.Head (n.idl) + " : ");
            SprintType (ty, acc)
          
          | <[ funparm: params $(n : name) : $ty ]> =>
            add (sprintf ("params %s : ", List.Head (n.idl)));
            SprintType (ty, acc)
          
          | <[ funparm: $(n : name) : $ty = $expr ]> =>
            add (sprintf ("params %s : ", List.Head (n.idl)));
            SprintType (ty, acc);
            add (" = ");
            SprintExpr (ctx, expr, indentation, acc)

          | _ => add ("spliced funparm name")
        };

        NString.SeparatedCalls (", ", fps, print_funparm, acc)
      };

      def sprint_ss (x) {
        | SS_string (n) =>
          add (n.GetId ())
        | SS_spliced_expr (e) =>
          add ("$(");
          SprintExpr (ctx, e, indentation, acc);
          add (")");
      }
      
      match (expr) {
        | <[ $(id : name) ]> => 
          add (id.GetHead ())

        | <[ $obj . $mem ]> => 
          SprintExpr (ctx, obj, indentation, acc); add ("."); sprint_ss (mem)

        | <[ [] ]> => add ("[]")

        | <[ $x :: $xs ]> =>
          SprintExpr (ctx, x, indentation, acc);  
          add (" :: "); SprintExpr (ctx, xs, indentation, acc)

        | <[ $func (.. $parms) ]> =>
          def print_parm (p : Expr) {
            match (p) {
              | <[ $(n : name) = $expr ]> =>
                match (n.idl) {
                  | [] => ()
                  | x :: _ => add (x + " = ")
                };
                SprintExpr (ctx, expr, indentation + "  ", acc)
              | _ =>
                SprintExpr (ctx, p, indentation + "  ", acc)
            }
          };
          match ((func, parms)) {
            | (<[ $({idl = [x]} : name) ]>, [e]) when LexerBase.IsOperator (x) =>
              add (x);
              print_parm (e)

            | (<[ $({idl = [x]} : name) ]>, [e1, e2]) when LexerBase.IsOperator (x) =>
              print_parm (e1);
              add (" " + x + " ");
              print_parm (e2);            

            | _ =>
              SprintExpr (ctx, func, indentation, acc); add (" (");
              NString.SeparatedCalls (", ", parms, print_parm, acc);             
              add (")");
          }

        | <[ $target = $source ]> =>
          SprintExpr (ctx, target, indentation, acc); add (" = ");
          SprintExpr (ctx, source, indentation, acc);

        | <[ def $n = $val ]> =>
          add ("def "); sprint_ss (n);
          add (" = "); SprintExpr (ctx, val, indentation, acc)

        | <[ mutable $n = $val ]> =>
          add ("mutable "); sprint_ss (n);
          add (" = "); SprintExpr (ctx, val, indentation, acc)

        | <[ def (.. $elems) = $val ]> =>
          add ("def (");
          def pp (x) { SprintPattern (x, acc) };
          NString.SeparatedCalls (", ", elems, pp, acc); 
          add (") = ");
          SprintExpr (ctx, val, indentation, acc);

        | <[ match ($expr) {.. $cases } ]> =>
          def print_case (c : Match_case) {
            def print_guard (g : Pattern * option <Expr>) {
              | <[ caseguard: $pat when $e ]> =>
                add (sprintf ("\n%s| ", indentation + "  "));
                SprintPattern (pat, acc);
                add (" when ");
                SprintExpr (ctx, e, indentation + "    ", acc)
              | <[ caseguard: $pat ]> =>
                add (sprintf ("\n%s| ", indentation + "  ")); 
                SprintPattern (pat, acc);
            };

            def <[ case: | ..$guards => $expr ]> = c;
            List.Iter (guards, print_guard);
            add (sprintf (" => \n%s", indentation + "    "));
            SprintExpr (ctx, expr, indentation + "    ", acc)
          };

          add ("match ("); 
          SprintExpr (ctx, expr, indentation, acc); add (") {");
          List.Iter (cases, print_case);
          add (sprintf ("\n%s}", indentation))

        | <[ throw $exc ]> =>
          add ("throw "); SprintExpr (ctx, exc, indentation, acc);

        | <[ try $body catch { $exn : $exn_ty => $handler } ]> => 
          add (sprintf ("try\n%s  ", indentation));
          SprintExpr (ctx, body, indentation + "  ", acc);
          add (sprintf ("\n%swith {\n%s", indentation, indentation + "  "));
          sprint_ss (exn); add (" : ");
          SprintType (exn_ty, acc);
          add (sprintf ("=>\n%s", indentation + "    "));
          SprintExpr (ctx, handler, indentation + "    ", acc)

        | <[ try $body finally $handler ]> =>
          add (sprintf ("try\n%s  ", indentation));
          SprintExpr (ctx, body, indentation + "  ", acc);
          add (sprintf ("\n%sfinally\n%s  ", indentation, indentation));
          SprintExpr (ctx, handler, indentation + "  ", acc)

        | E_literal (lit) =>
          add (lit.ToString ())

        | <[ this ]> =>
          add ("this")

        | <[ base ]> => 
          add ("base")

        | <[ typeof ($t) ]> =>
          add ("typeof ("); SprintType (t, acc); add (")")

        | <[ ( $expr :> $ty ) ]> =>
          add ("("); SprintExpr (ctx, expr, indentation, acc); add (" :> ");
          SprintType (ty, acc); add (")")

        | <[ ( $expr : $ty ) ]> =>
          add ("("); SprintExpr (ctx, expr, indentation, acc); 
          add (" : "); SprintType (ty, acc); add (")")

        | <[ {.. $seq } ]> =>
          match (seq) {
            | [e] =>
              SprintExpr (ctx, e, indentation, acc)
            | _ =>
              add ("{");
              NString.SeparatedCalls (";", seq, fun (x) { 
                add (sprintf ("\n%s", indentation + "  ")); 
                SprintExpr (ctx, x, indentation + "  ", acc); 
              }, acc);
              add (sprintf ("\n%s}", indentation))
          }

        | <[ (.. $args) ]> =>
          add ("(");
          NString.SeparatedCalls (", ", args, fun (x) { 
            SprintExpr (ctx, x, indentation, acc) 
          }, acc);
          add (")")

        | <[ array (..$args) ]> =>
          add ("array (");
          NString.SeparatedCalls (", ", args, fun (x) { 
            SprintExpr (ctx, x, indentation, acc) 
          }, acc);

        | <[ ref $e ]> => add ("ref "); SprintExpr (ctx, e, indentation, acc)

        | <[ out $e ]> => add ("ref "); SprintExpr (ctx, e, indentation, acc)

        | <[ array $args ]> =>
          add ("array ");
          SprintExpr (ctx, args, indentation, acc);

        | <[ array < $rank > $args ]> =>
          add ("array <");
          SprintExpr (ctx, rank, indentation, acc);
          add ("> ");
          SprintExpr (ctx, args, indentation, acc);

        | <[ $obj [.. $args] ]> =>
          SprintExpr (ctx, obj, indentation, acc);
          add ("[");
          NString.SeparatedCalls (", ", args, fun (x) { 
            SprintExpr (ctx, x, indentation, acc) 
          }, acc);
          add ("]")

        | <[ fun < ..$tparms> (..$args) : $ty where ..$tconstrs $body ]> =>
          add ("fun "); print_tparms (tparms);
          add (" ("); print_funparms (args); add (") ");
          add (": "); SprintType (ty, acc); add (" ");
          print_tconstraints (tconstrs); add (" ");
          SprintExpr (ctx, body, indentation, acc)

        | <[ def ..$funs ]> =>
          def print_fun (f : Function_decl) {
            | <[ fundecl: $(n : name) < ..$tparms> (..$args)
                 where .. $tconstrs $body ]> =>
              add (n.GetId () + " "); print_tparms (tparms);
              add (" ("); print_funparms (args); add (") ");
              print_tconstraints (tconstrs); add (" ");
              SprintExpr (ctx, body, indentation, acc)
            | _ => add ("spliced fun name")
          };
        
          add ("def ");
          NString.SeparatedCalls ("\nand ", funs, print_fun, acc)

        | E_macrocall (_, namespc, parms) =>
          match (namespc.Value) {
            | GlobalEnv.MacroCall (m) =>
              def (key, rules, _) = m.SyntaxExtension ();
              mutable parms_left = parms;
              add (key + " ");
              def print_gel (x) { 
                | Parser.GE_keyword (k) => add (" "); add (k); add (" ")
                | Parser.GE_operator (")") => add (") ")
                | Parser.GE_operator ("}") => add ("} ")                
                | Parser.GE_operator (o) => add (o)
                | Parser.GE_optional (g) => print_gel (g)
                | Parser.GE_expression =>
                  match (List.Head (parms_left)) {
                    | SyntaxExpr (e) =>
                      SprintExpr (ctx, e, indentation, acc);
                    | _ =>
                      Message.fatal_error ("types of parameters do not match"
                                           " definition of macro")
                  };
                  parms_left = List.Tail (parms_left);
                | _ => () 
              };
              List.Iter (rules, print_gel);
            | _ => add ("macro_call")
          }

        | E_spliced (e) =>
          add ("$("); SprintExpr (ctx, e, indentation, acc); add (")");

        | E_spliced_patt (p) =>
          add ("$("); SprintPattern (p, acc); add (")");

        | E_expr_list (e) =>
          add (".."); SprintExpr (ctx, e, indentation, acc); 

        | E_quoted  =>
          //        add ("<[ "); SprintExpr (ctx, e, indentation, acc); add (" ]>");
          add ("quoted");

        | E_typed_expr (e) =>
          SprintTyExpr (ctx, e, None (), false, indentation, acc)

        | E_spliced_special => Util.ice ("Bad construction of E_spliced_special")

        | E_letpat => Util.ice ("Bad construction of E_letpat")
        | E_lambda => Util.ice ("Bad construction of E_lambda")
        
//      | _ => add ("other")
      }
    }

    public SprintExpr (ctx : option<TypingContext>, expr : Expr) : string
    {
      def result = StringBuilder ();
      SprintExpr (ctx, expr, "", result);
      result.ToString ()    
    }

    public PrintExpr (ctx : option<TypingContext>, expr : Expr) : void
    {
      printf ("%s\n", SprintExpr (ctx, expr))
    }

    public PrintPattern (pat : Pattern) : void
    {
      def acc = StringBuilder ();
      SprintPattern (pat, acc);
      printf ("%s\n", acc.ToString ())
    }

    public SprintPattern (patt : Pattern, acc : StringBuilder) : void
    {
      def add (x : string) { ignore (acc.Append (x)) };
      def print_named_pattern (patt : string * Pattern) : void
      {
        def (name, pat) = patt;
        add (sprintf ("%s = ", name)); SprintPattern (pat, acc);
      };
    
      match (patt) {
        | <[ pattern: _ ]> =>
          add ("_")

        | <[ pattern: $(n : name) ]> =>
          add (n.GetId ())

        | <[ pattern: ($pat) as $(n : name) ]> => 
          add ("("); SprintPattern (pat, acc); 
          add (") as "); add (n.GetId ())

        | <[ pattern: [] ]> => add ("[]")

        | <[ pattern: $x :: $xs ]> => 
          SprintPattern (x, acc); add (" :: "); SprintPattern (xs, acc)

        | <[ pattern: (.. $args) ]> =>
          add ("(");
          NString.SeparatedCalls (", ", args, fun (x) {
            SprintPattern (x, acc);
          }, acc);
          add (")")

        | <[ pattern: {.. $args } ]> =>
          add ("{");
          NString.SeparatedCalls ("; ", args, print_named_pattern, acc);
          add ("}")

        | <[ pattern: $(n : name) (.. $args) ]> =>
          add (n.GetId ()); add (" (");
          NString.SeparatedCalls (", ", args, fun (x) {
            SprintPattern (x, acc)
          }, acc);
          add (")");

        | <[ pattern: $(n : name) {.. $args} ]> =>
          add (n.GetId ()); add (" {");
          NString.SeparatedCalls ("; ", args, print_named_pattern, acc);          
          add ("}")

        | <[ pattern: $(val : int) ]> =>
          add (val.ToString ())

        | <[ pattern: $(val : string) ]> =>
          add (sprintf ("\"%s\"", val))

        | <[ pattern: $(val : bool) ]> =>
          if (val) add ("true") else add ("false")

        | <[ pattern: $(val : float) ]> =>
          add (val.ToString ())

        | <[ pattern: $(val : char) ]> =>
          add (val.ToString ())

        | <[ pattern: () ]> =>
          add ("()")

        | <[ pattern: null ]> =>
          add ("null")

        | <[ pattern: $(n : name) _ ]> =>
          add (n.GetId ())

        | P_spliced (e) =>
          add ("$("); SprintExpr (None (), e, "", acc); add (")");

        | P_has_type (p, t) =>
          SprintPattern (p, acc); add (" : "); SprintType (t, acc);

        | _ => add ("other");
      }
    }

    public SprintType (ty : Type, acc : StringBuilder) : void 
    {
      def add (x : string) { ignore (acc.Append (x)) };
    
      match (ty) {
        | <[ type: $(tycon : name) < .. $args> ]> =>
         add (tycon.GetId ());
         match (args) {
           | [] => ()
           | _ => add (" <");
             NString.SeparatedCalls (" * ", args, fun (x) {
               SprintType (x, acc)
             }, acc);
             add (">");
         }

        | <[ type: $(n : name) ]> =>
          add (n.GetId ());

        | <[ type: ref $ty ]> =>
          add ("ref "); SprintType (ty, acc);

        | <[ type: out $ty ]> =>
          add ("out "); SprintType (ty, acc);

        | <[ type: $from -> $to ]> =>
          SprintType (from, acc); add (" -> "); SprintType (to, acc);

        | <[ type: void ]> =>
          add ("void");

        | <[ type: .. $args ]> =>
          NString.SeparatedCalls (" * ", args, fun (x) {
            SprintType (x, acc);
          }, acc);

        | <[ type: array < $(1 : int), $ty > ]> =>
          add ("array <"); SprintType (ty, acc); add (">")

        | <[ type: array < $(rank : int), $ty > ]> =>
          add ("array <"); add (rank.ToString ()); add (", "); 
          SprintType (ty, acc); add (">")

        | _ => add ("other")
      }
    }



    /* ------------------------------------------------------------------------ */
    /* -- TYPED TREE ---------------------------------------------------------- */
    /* ------------------------------------------------------------------------ */


    /* -- MATCHING ---------------------------------------------------------- */
    
    /**
     * Pretty prints a match ('expr') { 'match_cases' } instruction.
     * This is a string generating wrapper for SprintTyMatch/6.
     */
    public SprintTyMatch (ctx : option <TypingContext>,
                          expr : TT.Expr,
                          match_cases : list <TT.Match_case>) : string
    {
      def result = StringBuilder ();
      ignore (result.Append ("\n"));
      SprintTyMatch (ctx, expr, None (), match_cases, "", result);
      ignore (result.Append ("\n"));
      result.ToString ()          
    }
    

    /**
     * Pretty prints a match ('expr') { 'match_cases' } instruction.
     */
    public SprintTyMatch (ctx : option <TypingContext>,
                          expr : TT.Expr,
                          current_fun_name : option <string>,
                          match_cases : list <TT.Match_case>,
                          indentation : string,
                          result : StringBuilder) : void
    {
      def append (x : string) { ignore (result.Append (x)) }
      def indent () { append (indentation) }

      def recurse (expr : TT.Expr) {
        SprintTyExpr (ctx, expr, current_fun_name, false, indentation, result)
      }
      def recurse_and_indent (expr : TT.Expr) {
        SprintTyExpr (ctx, expr, current_fun_name, true, indentation + "    ", result)
      }
      def recurse_and_short_indent (expr : TT.Expr) {
        SprintTyExpr (ctx, expr, current_fun_name, true, indentation + "  ", result)
      }
        
      def print_pattern (pattern : TT.Pattern)
      {
        | TT.P_underscore => append ("_")
        | TT.P_as (TT.P_has_type (tycon), decl) =>
          append (decl.name + " : " + tycon.FullName)          
        | TT.P_as (pat /* Pattern */, decl /* LocalValue */) =>
          append ("(");
          print_pattern (pat);
          append (") as " + decl.name)
        | TT.P_has_type =>
          Util.ice ("SprintTyMatch: P_has_type")
        | TT.P_tuple (args /* list <Pattern> */) =>
          append ("(");
          def loop (args) {
            | [] => ()
            | [arg] =>
              print_pattern (arg)
            | arg :: args =>
              print_pattern (arg);
              append (", ");
              loop (args)
          };
          loop (args);
          append (")")         

        // records
        | TT.P_record (args /* list <IField * TT.Pattern> */) =>
          def print_record_field (fld : IField, pat : TT.Pattern)
          {
            append (fld.Name + " = ");
            print_pattern (pat)
          }          

          def loop (args) {
            | [] => ()
            | [(fld, pat)] =>
              print_record_field (fld, pat)
            | (fld, pat) :: rest =>
              print_record_field (fld, pat);
              append ("; ");
              loop (rest)
          }
          
          append ("{");
          loop (args);
          append ("}")

        // variant constructors
        | TT.P_cons (name /* Tycon */, TT.P_underscore /* Pattern */) =>
          append (name.FullName)
        | TT.P_cons (name /* Tycon */, (TT.P_record) as arg /* Pattern */) =>
          append (name.FullName + " ");
          print_pattern (arg);   
        | TT.P_cons (name /* Tycon */, arg /* Pattern */) =>
          append (name.FullName + " (");          
          print_pattern (arg);
          append (")")

        // literals
        | TT.P_literal (lit /* Literal */) =>
          append (lit.ToString ())
      }
      
      def print_patterns (patterns : list <TT.Pattern * TT.Expr>)
      {
        def do_print (pattern, guard, terminator)
        {
          indent ();
          append ("  | ");
          print_pattern (pattern);

          match (guard) {
            | TT.E_literal (L_bool (true)) => ()
            | _ =>
              append (" when ");
              recurse (guard);
          }
          
          append (terminator)
        }
        
        match (patterns) {
          | [(pattern, guard)] =>
            do_print (pattern, guard, " =>\n")
          | (pattern, guard) :: rest =>
            do_print (pattern, guard, "\n");
            print_patterns (rest)
          | _ => ()
        }
      }
      
      def print_match_cases (cases : list <TT.Match_case>)
      {
        | (patterns, body) :: rest =>
          print_patterns (patterns);
          recurse_and_indent (body);
          append ("\n");
          print_match_cases (rest)          
        | _ => ()      
      }

      def collapse_match_like_constructions () : bool
      {
        def expr_is_bool (expr)
        {
          match (Tyexpr.type_of (expr)) {
            | TT.T_app (tycon, []) =>
              tycon.FullName == "System.Boolean" ||
              tycon.FullName == "Nemerle.Core.bool"
            | _ =>
              false
          }
        }

        def case_is_true (case : TT.Match_case) {
          (case.patterns matches [(TT.P_literal (L_bool (true)), TT.E_literal (L_bool (true)))])
        }
        def case_is_false (case : TT.Match_case) {
          (case.patterns matches [(TT.P_literal (L_bool (false)), TT.E_literal (L_bool (true)))])
        }
        def case_is_wildcard (case : TT.Match_case) {
          (case.patterns matches [(TT.P_underscore, TT.E_literal (L_bool (true)))])
        }
        def case_is_ty_check (case : TT.Match_case) {
          (case.patterns matches [(TT.P_as (TT.P_has_type, _), TT.E_literal (L_bool (true)))])
        }
        def expr_is_true (expr : TT.Expr) {
          (expr matches TT.E_literal (L_bool (true)))
        }
        def expr_is_false (expr : TT.Expr) {
          (expr matches TT.E_literal (L_bool (false)))
        }        
        def expr_is_unit (expr : TT.Expr) {
          (expr matches TT.E_literal (L_void))
        }

        def matching_over_bool =
          expr_is_bool (expr);
        
        match (match_cases) {
          | [then_case, else_case] =>
            def then_is_true = case_is_true (then_case);
            def then_is_false = case_is_false (then_case);
            def then_is_ty_check = case_is_ty_check (then_case);
            def else_is_wildcard = case_is_wildcard (else_case);

            def then_body_is_true = expr_is_true (then_case.body);
            def then_body_is_false = expr_is_false (then_case.body);
            def else_body_is_unit = expr_is_unit (else_case.body);
            def else_body_is_true = expr_is_true (else_case.body);
            def else_body_is_false = expr_is_false (else_case.body);
            def else_body_is_bool = expr_is_bool (else_case.body);

            def is_if =
              matching_over_bool && then_is_true && else_is_wildcard;
            def is_when =
              matching_over_bool && then_is_true &&
              else_is_wildcard && else_body_is_unit;
            def is_unless =
              matching_over_bool && then_is_false &&
              else_is_wildcard && else_body_is_unit;

            def is_and_and =
              matching_over_bool && then_is_false &&
              then_body_is_false && else_is_wildcard && else_body_is_bool;

            def is_or_or =
              matching_over_bool && then_is_true &&
              then_body_is_true && else_is_wildcard && else_body_is_bool;

            def is_is =
              then_body_is_true && then_is_ty_check &&
              else_is_wildcard && else_body_is_false;

            def is_matches =
              then_body_is_true && else_is_wildcard && else_body_is_false;
                  
            def is_redundant =
              matching_over_bool &&
              then_is_true && then_body_is_true &&
              else_is_wildcard && else_body_is_false ||
              then_is_false && then_body_is_false &&
              else_is_wildcard && else_body_is_true;

            if (is_redundant) {
              append ("(");
              recurse (expr);
              append (")");
              true
            }
            else if (is_or_or || is_and_and) {
              append ("(");
              recurse (expr);
              append (if (is_or_or) " || " else " && ");
              recurse (else_case.body);
              append (")");
              true
            }
            else if (is_when || is_unless) {
              append ((if (is_when) "when" else "unless") + " (");
              recurse (expr);
              append (") {\n");
              recurse_and_short_indent (then_case.body);
              append ("\n" + indentation + "}");
              true
            }
            else if (is_if)
            {
              append ("if (");
              recurse (expr);
              append (") {\n");
              recurse_and_short_indent (then_case.body);
              append ("\n" + indentation + "}\n" + indentation + "else {\n");
              recurse_and_short_indent (else_case.body);
              append ("\n" + indentation + "}");
              true
            }
            else if (is_is)
            {
              append ("(");
              recurse (expr);
              append (" is ");
              match (then_case.patterns) {
                | [(TT.P_as (TT.P_has_type (ty), _), _)] =>
                  append (strip_nemerle_core_dot_prefix (ty.FullName));
                | _ =>
                  Util.ice ("SprintTyMatch: is_is")
              }
              append (")");
              true
            }
            else if (is_matches)
            {
              append ("(");
              recurse (expr);
              append (" matches ");
              match (then_case.patterns) {
                | [(then_pat, _)] =>
                  print_pattern (then_pat)
                | _ =>
                  Util.ice ("SprintTyMatch: is_matches")
              }
              append (")");
              true
            }
            else
              false

          | _ =>
            false
        }
      }

      unless (collapse_match_like_constructions ())
      {
        append ("match (");
        recurse (expr);
        append (") {\n");
      
        print_match_cases (match_cases);

        indent ();
        append ("}")
      }
    }


    /* -- TYPES ------------------------------------------------------------- */
    
    /**
     * Pretty prints a type, as found in typed trees.
     */
    public SprintTyType (ty : TT.Type) : string
    {
      def result = StringBuilder ();
      def append (x : string) { ignore (result.Append (x)) }
      
      def print_types_list (types : list <TT.Type>, separator : string)
      {
        match (types) {
          | [ty] =>
            print_type (ty)
          | ty :: rest =>
            print_type (ty);
            append (separator);
            print_types_list (rest, separator)
          | _ => ()
        }
      }
      and print_type (ty : TT.Type)
      {
        | TT.T_app (tycon, []) =>
          append (strip_nemerle_core_dot_prefix (tycon.FullName))
                    
        | TT.T_app (tycon, args) =>
          append (strip_nemerle_core_dot_prefix (tycon.FullName) + " <");
          print_types_list (args, " * ");
          append (">")
          
        | TT.T_var (tyvar) =>
          append (tyvar.name)

        | TT.T_ref (ty) =>
          append ("ref ");
          print_type (ty)
          
        | TT.T_out (ty) =>
          append ("out ");
          print_type (ty)
          
        | TT.T_fun (from, to) =>
          print_type (from);
          append (" -> ");          
          print_type (to)
          
        | TT.T_void =>
          append ("void")
          
        | TT.T_prod (args) =>
          print_types_list (args, " * ")
          
        | TT.T_array (ty, rank) =>
          append ("array <");
          when (rank > 1) append (rank.ToString () + ", ");
          print_type (ty);
          append (">")
      }

      print_type (ty);
      result.ToString ()
    }


    /* -- EXPRESSIONS ------------------------------------------------------- */

    /**
     * Pretty prints a typed tree expression.
     */
    public SprintTyExpr (ctx : option <TypingContext>, expr : TT.Expr) : string
    {
      def result = StringBuilder ();
      ignore (result.Append ("\n"));
      SprintTyExpr (ctx, expr, None (), false, "", result);
      ignore (result.Append ("\n"));
      result.ToString ()    
    }
    
    
    /**
     * Pretty prints a typed tree expression.
     */
    public SprintTyExpr (ctx : option <TypingContext>,
                         expr : TT.Expr,
                         current_fun_name : option <string>,
                         is_top_level : bool,
                         indentation : string,
                         result : StringBuilder) : void
    {
      def append (x : string) { ignore (result.Append (x)) }
      def indent () { append (indentation) }

      def recurse (expr : TT.Expr) {
        SprintTyExpr (ctx, expr, current_fun_name, false, indentation, result)
      }
      def recurse_no_indent (expr : TT.Expr) {
        SprintTyExpr (ctx, expr, current_fun_name, true, indentation, result)
      }
      def recurse_and_indent (expr : TT.Expr) {
        SprintTyExpr (ctx, expr, current_fun_name, true, indentation + "  ", result)
      }

      def print_type (ty : TT.Type) {
        append (SprintTyType (ty))
      }
      
      def print_expr_list (begin : string, args : list <TT.Expr>,
                           separator : string, end : string)
      {
        append (begin);
        NString.SeparatedCalls (separator, args, recurse, result);
        append (end)
      }      

      def print_fun_call_parms (parms : list <TT.Parm>)
      {
        NString.SeparatedCalls (", ", parms, fun (parm : TT.Parm) { recurse (parm.expr) }, result)
      }
 
      def is_list_cons (mem : IMember)
      {
        mem.DeclaringType.FullName == "Nemerle.Core.Cons" && mem.Name == ".ctor"
      }

      def is_list_nil (mem : IMember)
      {
        mem.DeclaringType.FullName == "Nemerle.Core.Nil" && mem.Name == "_N_constant_object"
      }
      
      // checks if an expression needs to be put in curly braces
      def need_curly_braces (expr : TT.Expr)
      {
        | TT.E_let => true
        | TT.E_letfun => true
        | TT.E_sequence => true
        | TT.E_field_ref (obj, _)
        | TT.E_property_ref (obj, _)
        | TT.E_method_ref (obj, _, _)
        | TT.E_array_indexer (_, obj, _) =>
          need_curly_braces (obj)
        | TT.E_assign (target, source) =>
          need_curly_braces (target) || need_curly_braces (source)
        | TT.E_raise (exn) =>
          need_curly_braces (exn)
        | _ => false
      }

      
      // prints a list, using the [,] and :: shortcuts for Cons where appropriate
      def print_list_constructors (cons : TT.Expr)
      {
        def walk_tree (cons : TT.Expr, acc : list <TT.Expr>) : list <TT.Expr> * bool
        {
          match (cons) {
            | TT.E_call (TT.E_static_ref (mem), parms) when is_list_cons (mem)
            | TT.E_tail_call (TT.E_static_ref (mem), parms) when is_list_cons (mem) =>
              match (parms) {
                | [head, tail] =>
                  walk_tree (tail.expr, head.expr :: acc)
                | _ =>
                  Util.ice ("SprintTyExpr/flatten_list/walk_list_tree")
                }
              
            | TT.E_static_ref (mem) when is_list_nil (mem) =>
              (List.Rev (acc), true)

            | _ =>
              (List.Rev (cons :: acc), false)
          }
        }

        def (flattened_list, ended_with_nil) =
          walk_tree (cons, []);

        if (ended_with_nil)
          print_expr_list ("[", flattened_list, ", ", "]")
        else
          print_expr_list ("", flattened_list, " :: ", "")
      }


      // prints a local function declaration
      def print_local_fun_decl (title : string, fun_decl : TT.Function_decl)
      {      
        append (title + " " +
                print_fun_typarms (fun_decl.header.typarms) +
                fun_decl.header.name + " " +
                print_fun_parms (fun_decl.header.parms) + " : " +
                SprintTyType (fun_decl.header.ret_type) + " {\n");

        // change the current function's name when recursing
        SprintTyExpr (ctx, fun_decl.body, Some (fun_decl.header.name),
                      true, indentation + "  ", result);

        append ("\n" + indentation + "}\n")
      }   


      // indent the top level expressions
      when (is_top_level) indent ();
      
      match (expr) {
        // reference building
        | TT.E_local_ref (decl /* LocalValue */) =>          
          append (decl.name)
          
        | TT.E_static_ref (mem /* IMember */) =>
          def ty_name =
            strip_nemerle_core_dot_prefix (mem.DeclaringType.FullName);
          def co_name = mem.Name;
          
          if (is_list_nil (mem)) {
            append ("[]")
          }
          else {
            append (ty_name);

            unless (co_name == ".ctor") {
              append ("." + co_name)
            }
          }
          
        | TT.E_field_ref (obj /* Expr */, fld /* IField */) =>
          recurse (obj);
          append ("." + fld.Name)
          
        | TT.E_constant_object_ref (mem /* IField */) =>
          append (mem.DeclaringType.FullName + "." + mem.Name);
          
        | TT.E_implicit_value_type_ctor (t /* Tycon */) =>
          append (t.FullName + " ()");
          
        | TT.E_property_ref (obj /* Expr */, prop /* IProperty */) =>
          recurse (obj);
          append ("." + prop.Name)
          
        | TT.E_static_property_ref (prop /* IProperty */) =>
          append (prop.DeclaringType.FullName + "." + prop.Name)

        // FIXME: handle the 'notvirtual' flag
        | TT.E_method_ref (obj /* Expr */, meth /* IMethod */, _ /* notvirtual : bool */) =>
          recurse (obj);
          append ("." + meth.Name)          


        // the special case for unary operators
        | TT.E_call (TT.E_opcode (name), [parm]) =>
          append (name);
          append ("(");
          recurse (parm.expr);
          append (")");

        // the special case for infix binary operators
        | TT.E_call (TT.E_opcode (name), [parm1, parm2]) =>
          append ("(");
          recurse (parm1.expr);
          append (" " + name + " ");
          recurse (parm2.expr);
          append (")")

        // pretty print the list constructors
        | TT.E_call (TT.E_static_ref (mem), _) when is_list_cons (mem)
        | TT.E_tail_call (TT.E_static_ref (mem), _) when is_list_cons (mem) =>
          print_list_constructors (expr)
              
        // write all the other calls in prefix form 
        | TT.E_call (func /* Expr */, parms /* list <Parm> */)
        | TT.E_tail_call (func /* Expr */, parms /* list <Parm> */) =>
          recurse (func);
          append (" (");
          print_fun_call_parms (parms);
          append (")")
                  
        | TT.E_self_tail_call (parms /* list <Parm> */) =>
          match (current_fun_name) {
            | Some (fun_name) => append (fun_name)
            | _ =>
              assert (Option.IsSome (ctx));
              append (Option.UnSome (ctx).current_fun.name)
          }          
          append (" (");
          print_fun_call_parms (parms);
          append (")")


        // assignment
        | TT.E_assign (target /* Expr */, source /* Expr */) =>
          recurse (target);
          append (" = ");
          recurse (source);

          
        // local definitions
        | TT.E_let (name /* LocalValue */, val /* Expr */, body /* Expr */) =>
          if (need_curly_braces (val))
          {
            append ("def " + name.name + " = {\n");
            recurse_and_indent (val);
            append ("\n" + indentation + "};\n");
            recurse_no_indent (body)
          }
          else
          {
            append ("def " + name.name + " = ");
            recurse (val);
            append (";\n");
            recurse_no_indent (body)
          }

        // local function definitions can be grouped using the 'and' keyword
        | TT.E_letfun (funs /* list <Function_decl> */, body /* Expr */) =>
          match (funs) {
            | fun_decl :: rest =>
              print_local_fun_decl ("def", fun_decl);
              List.Iter (rest, fun (fun_decl) { print_local_fun_decl ("and", fun_decl) })
            | _ => Util.ice ("TT.E_letfun with no function declarations")
          }
          recurse_no_indent (body)

          
        // the 'match' instruction is handled separately
        | TT.E_match (expr /* Expr */, cases /* list <Match_case> */) =>
          SprintTyMatch (ctx, expr, current_fun_name, cases, indentation, result)


        // exception handling
        | TT.E_raise (exn /* Expr */) =>
          append ("throw ");
          recurse (exn)
          
        | TT.E_try_with (body /* Expr */, exn /* LocalValue */, handler /* Expr */) =>
          append ("try {\n");
          recurse_and_indent (body);
          append ("\n" + indentation + "} catch {\n  " + indentation + exn.name + " : ");
          print_type (exn.ty);
          append (" =>\n");
          recurse_and_indent (handler);
          append ("\n" + indentation + "}")
          
        | TT.E_try_finally (body /* Expr */, handler /* Expr */) =>
          append ("try {\n");
          recurse_and_indent (body);
          append ("\n" + indentation +"} finally {\n");
          recurse_and_indent (handler);
          append ("\n" + indentation + "}")


        // 'this' and 'base' objects
        | TT.E_this =>
          append ("this");
          
        | TT.E_base /* (base_ctor : IMethod) */ =>
          append ("base")


        // type related nodes
        // FIXME: checked/unchecked
        | TT.E_type_conversion (expr /* Expr */, target_type /* Type */, _) =>
          append ("(");
          recurse (expr);
          append (" :> ");
          print_type (target_type);
          append (")")
          
        | TT.E_type_enforcement (expr /* Expr */, target_type /* Type */) =>
          append ("(");
          recurse (expr);
          append (" : ");
          print_type (target_type);
          append (")")

        | TT.E_typeof (target_type /* Type */) =>
          append ("typeof (");
          print_type (target_type);
          append (")")

          
        // array related nodes
        | TT.E_mkarray (args : list <TT.Expr>, _ /* dimensions : list <int> */) =>
          append ("array ");
          print_expr_list (" [", args, ", ", "]")
                    
        | TT.E_array_indexer (_ /* over_type : Type */, obj /* Expr */, args /* list <Expr> */) =>
          recurse (obj);
          print_expr_list (" [", args, ", ", "]")
          

        // loading of a literal
        | TT.E_literal (val /* Literal */) =>
          append (val.ToString ())


        // other nodes
        | TT.E_sequence (e1 /* Expr */, e2 /* Expr */) =>
          recurse (e1);
          append (";\n");
          recurse_no_indent (e2);
          
        | TT.E_tuple (args /* list <Expr> */) =>
          print_expr_list ("(", args, ", ", ")")                    

        | TT.E_opcode (name /* string */) =>
          append (name)
      }
    }

    
    /* -- PRIVATE METHODS --------------------------------------------------- */

    /**
     * Strips the 'Nemerle.Core.' prefix from type names
     */
    private strip_nemerle_core_dot_prefix (tyname : string) : string
    {
      if (tyname.StartsWith ("Nemerle.Core."))
        tyname.Substring (13)
      else
        tyname
    }


    /**
     * Prints a type parameters of a function declaration
     */
    private print_fun_typarms (typarms : list <Tyvar.T>) : string
    {
      def result = StringBuilder ();

      def append (x : string) { ignore (result.Append (x)) }
        
      append ("<");
      NString.SeparatedCalls (", ", typarms,
                              fun (typarm : Tyvar.T) { append (typarm.name) },
                              result);
      append ("> ");

      if (result.Length > 3) result.ToString () else ""
    }


    /**
     * Prints the parameters of a function declaration
     */
    private print_fun_parms (parms : list <TT.Fun_parm>) : string
    {      
      def result = StringBuilder ();
      
      def append (x : string) { ignore (result.Append (x)) }

      append ("(");
      NString.SeparatedCalls (", ", parms,
                              fun (parm : TT.Fun_parm) {
                                append (parm.name + " : " + SprintTyType (parm.ty))
                              }, result);
      append (")");

      result.ToString ()
    }
  }
}

/*** END OF FILE ***/
