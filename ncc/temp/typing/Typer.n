/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  /** A class responsible for typing a single (global or local) function.  */
  public class Typer
  {
    is_instance_ctor : bool;
    is_method : bool;
    env : GlobalEnv;
    tenv : Tyvar.TEnv;
    current_fun : Fun_header;
    current_type : TypeBuilder;
    parent_typer : option <Typer>;
    outer_context : OuterContext;
    mutable local_context : LocalContext;

    static solver : Solver = Solver ();

    /** Represent a context common to a set of functions typed together. */
    class OuterContext
    {
      public suspended1 : Queue [DelayedTyping];
      public suspended2 : Queue [DelayedTyping];

      public this ()
      {
        suspended1 = Queue ();
        suspended2 = Queue ();
      }
    }


    MaybeAddBaseCall () : void
    {
      when (is_instance_ctor && !m.DeclaringType.IsValueType)
        match (m.fun_body) {
          | FunBody.Parsed (expr) =>
            match (expr) {
              | PT.PExpr.Sequence (<[ base (.. $_) ]> :: _) => ()
              | PT.PExpr.Sequence (<[ this (.. $_) ]> :: _) => ()
              | PT.PExpr.Sequence =>
                Util.locate (expr.loc,
                  m.fun_body = FunBody.Parsed (<[ { base (); $expr } ]>)
                )
              | _ => assert (false)
            }
          | _ => ()
        }
    }


    MaybeDumpTypedTree () : void
    {
      when (Flags.dump_typed_tree) {
        match (current_fun.fun_body) {
          | FunBody.Typed (expr) =>
            Message.debug (expr.loc, $ "$current_type.$(current_fun.name) -> "
                                       "$(current_fun.ret_type) : " +
                                     PrettyPrint.SprintTyExpr (Some (ctx), expr) + "\n")
          | _ => ()
        }
      }
    }


    // FIXME: copy doc from TypeMethod
    /** Walk through method body typing it. */
    public this (m : NemerleMethod)
    {
      current_type = m.DeclaringType :> TypeBuilder;
      parent_typer = None ();
      env = parent_type.env;
      current_fun = m.GetHeader ();
      tenv = current_fun.tenv;

      outer_context = OuterContext ();
      local_context = LocalContext.Empty;

      match (m.GetFunKind ()) {
        | FunKind.Constructor =>
          is_instance_ctor = true;
          is_method = true;
        | FunKind.Method | FunKind.BoundMethod =>
          is_method = true;
        | _ => ()
      }

      MaybeAddBaseCall ();
      RunTyper ();
      MaybeDumpTypedTree ();
    }

    /** Walk through a local function body typing it. */
    public this (parent : Typer, fn : Fun_header)
    {
      parent_typer = Some (parent);

      // copy from parent
      current_type = parent.current_type;
      outer_context = parent.outer_context;
      local_context = parent.local_context;
      is_method = parent.is_method;
      is_instance_ctor = parent.is_instance_ctor;
      env = parent.env;

      current_fun = fn;
      tenv = current_fun.tenv; // FIXME

      RunTyper ();
    }

    IsTopLevel : bool
    {
      get { parent_typer matches Some }
    }

    AddLocal (name : PT.Name, local : LocalValue) : void
    {
      local_context = local_context.WithLocal (name, local);
    }

    RunTyper () : void
    {
      foreach (p : Fun_parm in current_fun.parms) {
        Util.locate (p.loc, {
          when (p.kind != ParmKind.Normal && !IsTopLevel)
            Message.error ("ref/out parameters are not supported in local methods");
          def is_mutable = p.modifiers.mods %&& NemerleAttributes.Mutable;
          def l = LocalValue (current_fun, p.name, p.ty,
                              LocalValue.Kind.FunParm (p.kind),
                              is_mutable = is_mutable);
          AddLocal (PT.Name (p.name, p.color, null), l)
          p.decl = l;
        })
      }

      match (current_fun.body) {
        | FunBody.Parsed (e) =>
          def e' = TypeExpr (e, current_fun.ret_type);
          current_fun.body = FunBody.Typed (e');
        | FunBody.Typed => assert (false)
        | FunBody.Compiled => assert (false)
        | FunBody.Extern
        | FunBody.Abstract => ()
      }
    }


    TypeExpr (e : PT.PExpr, expected : TyVar) : TExpr
    {
      Util.locate (e.loc, {
        // FIXME: expand macros here
        def e' = DoType (e, expected);
        e'.ty = expected;
        e'
      })
    }


    TypeOf (expr : TExpr) : TyVar
    {
      if (expr.ty == null) Util.ice ("type of TT.TExpr was not initialized")
      else expr.ty;
    }


    DefineLocal (name : PT.Name, ty : TyVar,
                 kind : LocalValue.Kind, is_mutable : bool) : LocalValue
    {
       LocalValue (current_fun, name.Id, ty, kind, is_mutable)
    }


    MonoType (m : MType, src : string) : TyVar
    {
      def tv = solver.MonoType (m);
      tv.AddSource (src);
      tv
    }


    FreshTyVar (src : string) : TyVar
    {
      def tv = solver.FreshTyVar ();
      tv.AddSource (src);
      tv
    }


    AtLeast (m : MType, src : string) : TyVar
    {
      def tv = solver.FreshTyVar ();
      tv.AddSource (src);
      tv.Require (m);
      tv
    }
    
    
    [Nemerle.NotImplemented]
    Delay (expr : PT.PExpr, reason : string) : TExpr
    {
    }


    /** Filter out wrong nodes, and if more then one left -- make the
        [Overloaded] node, and register it.

        Wrong node is [Error] node, or one type of which cannot unify with
        [expected].
        
        Nodes are registered only if solver stack is empty. */
    [Nemerle.NotImplemented]
    MakeOverloadedNode (exprs : list [TExpr], expected : TyVar) : TExpr
    {
    }


    [Nemerle.NotImplemented]
    PushLocals () : void
    {
    }


    [Nemerle.NotImplemented]
    PopLocals () : void
    {
    }

    /** Run given typing action, without possiblity of any error messages. */
    TryTyping (fn : void -> TExpr) : TExpr
    {
      solver.PushState ();
      def is_wrong = IsError (fn ());
      solver.PopState ();
      if (is_wrong)
        TExpr.Error ()
      else
        // we cannot reuse the previous result, since it's has been
        // popped off the stack
        fn ()
    }

    IsError (expr : TExpr) : bool
    {
      expr matches TExpr.Error
    }


    TypeMember (obj : PT.PExpr, mem_name : string, expected : TyVar) : TExpr
    {
      // XXX we should add a bound here, that the type should have the
      // field mem_name
      def tv = FreshTyVar ("left hand side of the dot");
      def obj = TypeExpr (obj, tv);
      if (tv.IsFixed) {
        def mems = Hashtable ();
        def visited = Hashtable ();
        mutable res = [];

        def lookup (t) {
          | MType.Class (tc, args) when (! visited.Contains (tc.GetId ())) =>
            visited [tc.GetId ()] = null;
            foreach (mem : IMember in tc.LookupMember (mem_name))
              when (!mems.Contains (mem.GetId ())) {
                mems [mem.GetId ()] = null;
                when (!mem.IsStatic && mem.CanAccess (current_type)) {
                  def ty =
                    match (mem) {
                      | meth : IMethod =>
                        meth.GetFreshType ()
                      | mem : IMember =>
                        mem.GetMemType ()
                    };
                  def ty = tc.SubtypingSubst (mem.DeclaringType).Apply (ty);
                  def ty = tc.MakeSubst (args).Apply (ty);
                  res = TExpr.Member (ty, obj, mem) :: res;
                }
              }
          | MType.TyVar (tv) =>
            List.Iter (tv.Constraints, lookup)
          | MType.Array =>
            lookup (InternalType.Array)
          | MType.Intersection (lst) =>
            List.Iter (lst, lookup)
          | _ => ()
        }
        lookup (Option.UnSome (tv.LowerBound));
        MakeOverloadedNode (res, expected)
      } else if (IsError (obj)) {
        obj
      } else {
        // FIXME: here we should traverse all type paths from lower to
        // upper bound and look how this field is defined there, and finally
        // add maybe-more-specific lower bound
        if (cannot_delay) {
          Message.error ($ "cannot find determine proper type for `$(tv)', "
                           "to find member `$(mem_name)'");
          TExpr.Error ()
        } else
          Delay (<[ $(obj : typed) . $mem_name ]>)
      }
    }


    InterpretGlobals (symbols : list [Symbol], expected : TyVar) : TExpr
    {
    }


    TypeName (name : PT.Name, expected : TyVar) : TExpr
    {
      match (name.idl) {
        | [_] when local_context.FindLocal (name) matches Some =>
          def local = Option.UnSome (local_context.FindLocal (name));
          expected.Unify (local.Type);
          LocalRef (local)

        | _ =>
          def from_this =
            match (name.idl) {
              | [name] when is_method =>
                TryTyping (fun () { TypeMember (<[ this ]>, name, expected) })
              | _ => TExpr.Error ()
            };
          def globals = name.GetEnv (env).LookupSymbol (name.idl);
          def from_global =
            InterpretGlobals (globals, expected);
          MakeOverloadedNode ([from_this, from_global], expected)
      }
    }

    
    DoType (expression : PT.PExpr, expected : TyVar) : TExpr
    {
      match (expression) {
        | PT.PExpr.ParmByRef
        | PT.PExpr.ParmOut =>
          Message.fatal_error ("ref and out parameters are only allowed in function calls")


        // FIXME: this should be macro
        | PT.PExpr.Lambda (d) =>
          def newname = Util.tmpname ("l");
          d.header.name = PT.Splicable.Name (PT.Name (newname));
          def sq = PT.PExpr.Sequence ([PT.PExpr.DefFunctions ([d]),
                                       PT.PExpr.Ref (PT.Name (newname))]);
          TypeExpr (sq, expected)


        // array [...]
        | PT.PExpr.Array (<[ $(r : int) ]>, <[ [] ]> ) =>
          def list_of_zeros (r) {
            | 1 => [ <[ 0 ]> ]
            | _ => <[ 0 ]> :: list_of_zeros (r - 1)
          }
          TypeExpr (<[ array (..$(list_of_zeros (r))) ]>, expected)


        | PT.PExpr.Array (<[ $(rank : int) ]>, args) =>
          TypeArray (rank, args, expected)


        | PT.PExpr.Array (PT.PExpr.Spliced, _) =>
          Message.fatal_error ("$ splicing outside of <[ quotation ]>")


        | PT.PExpr.Array => Util.ice ("wrongly parsed array initializer")


        | PT.PExpr.EmptyArray (sizes) =>
          mutable size = 0;
          def tsizes = List.Map (sizes, fun (x) {
            ++size;
            def tv = MonoType (InternalType.Int32, "array size initializer");
            TypeExpr (x, tv)
          });
          expected.Unify (MType.Array (FreshTyVar ("empty array object"), size));
          TExpr.Array ([], tsizes)


        | PT.PExpr.Indexer (obj, args) =>
          TypeIndexer (obj, args, expected)


        | (PT.PExpr.TryWith) as x =>
          def res1 = FreshTyVar ("try block result");
          def res2 = FreshTyVar ("catch handler result");
          expected.Provide (res1);
          expected.Provide (res2);
          def body = TypeExpr (x.body, res1);
          def exn = match (x.exn) {
            | PT.Splicable.Name (e) => e
            | _ =>
            Message.fatal_error ("$ operator used outside quotation <[ ... ]>"
                                 " context")
          };
          def decl = DefineLocal (exn, BindType (x.exn_ty),
                                  LocalValue.Kind.ExceptionValue (), false);
          PushLocals ();
          try {
            AddLocal (exn, decl);
            def handler = TypeExpr (x.handler, res2);
          } finally {
            PopLocals ();
          }

          TExpr.TryWith (body, decl, handler)


        | PT.PExpr.TryFinally (e1, e2) =>
          expected.AddSource ("try-finally result");
          def body = TypeExpr (e1, expected);
          def tv = FreshTyVar ("finally {...} result");
          def handler = TypeExpr (e2, tv);
          TExpr.TryFinally (body, handler)


        | PT.PExpr.Typeof (t) =>
          expected.Unify (InternalType.Type);
          TExpr.TypeOf (BindType (t))


        | PT.PExpr.TypeConversion (e, t) =>
          def t = BindType (t);
          expected.Unify (t);

          def fv = FreshTyVar ("type-cast body");
          def e' = TypeExpr (e, fv);

          if (fv.IsFixed)
            TypeConversion (e', t)
          else
            // FIXME: can we do better?
            if (cannot_delay)
              Message.fatal_error ("the type of type-casted expression "
                                   "cannot be deduced")
            else Delay (expression)


        | PT.PExpr.TypeEnforcement (e, t) =>
          def t = BindType (t);
          def fv = AtLeast (t, "type-enforcement body");
          expected.Unify (t);
          def e = TypeExpr (e, fv);
          TExpr.TypeEnforcement (e, t)


        | PT.PExpr.Ref (name) =>
          TypeName (name, expected)
          
        | PT.PExpr.Member (obj, PT.Splicable.Name (name)) =>
          assert (List.Length (name.idl) == 1);
          def mem_name = name.Id;
          match (Util.qidl_of_expr (expression)) {
            | Some ((idl, name)) => 
              def name' = PT.Name (idl, name.color, name.context);
              def res1 = TryTyping (fun () {
                TypeName (name', expected)
              });
              def res2 = TryTyping (fun () {
                TypeMember (obj, mem_name, expected) 
              });

              if (IsError (res1) && IsError (res2))
                // run the typing again, so it will present
                // the error message if needed
                TypeName (name', expected)
              else
                MakeOverloadedNode ([res1, res2], expected)

            | None => TypeMember (obj, mem_name, expected)
          }


        | PT.PExpr.Member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")


        | PT.PExpr.Call (fnc, parms) =>
          TypeCall (fnc, parms, expected)


        | PT.PExpr.Assign (PT.PExpr.Tuple (vars), e2) =>
          expected.Unify (MonoType (MType.Void (), "assignment result"));
          def tempnames = List.Map (vars, fun (_) { <[ $(Macros.NewSymbol () : name) ]> });
          def assigns = List.Map2 (vars, tempnames, fun (x, y) { <[ $x = $y ]> });
          def expr = <[
            def (..$tempnames) = $e2;
            {..$assigns }
          ]>;
          TypeExpr (expr, expected)


        | PT.PExpr.Assign (PT.PExpr.Wildcard, e2) =>
          expected.Unify (MonoType (MType.Void (), "assignment result"));
          TypeExpr (<[ def _ = $e2 ]>, expected)


        | PT.PExpr.Assign (e1, e2) =>
          expected.Unify (MonoType (MType.Void (), "assignment result"));
          def target_type = FreshTyVar ("assignment target");
          def source_type = FreshTyVar ("assignment source");
          source_type.Require (target_type);
          def e1 = TypeLValue (e1, target_type, need_ref = false);
          def e2 = TypeExpr (e2, source_type);
          TExpr.Assign (e1, e2)


        | PT.PExpr.Throw (e) =>
          def ty = AtLeast (InternalType.Exception, "thrown value");
          def e = TypeExpr (e, ty);
          TExpr.Throw (e)


        | PT.PExpr.Literal (l) =>
          TypeLiteral (l, expected)


        | PT.PExpr.This =>
          if (is_method) {
            expected.Unify (current_type.GetMemType ());
            TExpr.This ()
          } else
            Message.fatal_error ("`this' used outside method");


        | PT.PExpr.Base =>
          if (is_method) {
            def baseti = Option.UnSome (current_type.SuperClass ());
            def parms = Option.UnSome (ti.SuperType (baseti));
            def parms = List.Map (parms, solver.MonoType);
            def ty = MType.Class (baseti, parms);
            expected.Unify (ty);
            TExpr.This ()
          } else
            Message.fatal_error ("`base' used outside method");


        | PT.PExpr.Sequence ([]) =>
          expected.Unify (MType.Void ());
          TExpr.Literal (Literal.Void ())


        | PT.PExpr.Sequence (l) =>
          TypeSequence (l, expected)


        | PT.PExpr.Tuple (l) =>
          mutable res_exprs = [];
          mutable res_types = [];
          foreach (e in l) {
            def tv1 = FreshTyVar ("tuple component");
            def tv2 = FreshTyVar ("tuple component");
            tv1.Require (tv2);
            def e = TypeExpr (e, tv1);
            res_exprs = e :: res_exprs;
            res_types = tv2 :: res_types;
          }
          expected.Unify (MType.Tuple (res_types));
          TExpr.Tuple (res_exprs)


        | (PT.PExpr.Match) as m =>
          TypeMatch (m, expected)


        | PT.PExpr.Typed (tytree) =>
          expected.Unify (TypeOf (tytree));
          tytree


        | PT.PExpr.Quoted (parse_element) =>
          def lifted =
            match (parse_element) {
              | PT.SyntaxElement.Expression (e) => Macros.quoted_expr (ctx, e)
              | PT.SyntaxElement.Type (e) => Macros.quoted_type (ctx, e)
              | PT.SyntaxElement.MatchCase (e) => Macros.QuotedMatchCase (ctx, e)
              | PT.SyntaxElement.MatchCaseGuard (a, b) => Macros.QuotedCaseGuard (ctx, (a, b))
              | PT.SyntaxElement.Function (e) => Macros.quoted_fundecl (ctx, e)
              | PT.SyntaxElement.Parameter (e) => Macros.quoted_fparam (ctx, e)
              | PT.SyntaxElement.ClassMember (e) => Macros.quoted_member (ctx, e)
              | PT.SyntaxElement.TType (e) => Macros.quoted_ttype (ctx, e)

              | PT.SyntaxElement.TypeBuilder
              | PT.SyntaxElement.MethodBuilder
              | PT.SyntaxElement.FieldBuilder
              | PT.SyntaxElement.EventBuilder
              | PT.SyntaxElement.PropertyBuilder
              | PT.SyntaxElement.ParameterBuilder =>
                Util.ice ("strange syntax element appeared in quotation")
            };
          TypeExpr (lifted, expected)


        | PT.PExpr.Spliced =>
          Message.fatal_error ("$ macro keyword used in regular expression")
          

        | PT.PExpr.Wildcard | PT.PExpr.Application | PT.PExpr.As =>
          Message.fatal_error ("pattern expression inside raw expression")
          

        | PT.PExpr.Ellipsis =>
          Util.ice ("List of expression parameters out of any construct")
          

        | PT.PExpr.MacroCall  =>
          Util.ice ("Macrocalls should have been expanded already")


        | PT.PExpr.TypedPattern  =>
          Util.ice ("typed pattern in raw expr")
      }
    }

    TypeConversion (expr : TExpr, ty : MType) : TExpr
    {
            def has_xpl =
              match (t) {
                | MType.Class (tinfo, _) =>
                  !tinfo.LookupMember ("op_Explicit").IsEmpty ()
                | _ => false
              };
          t = Tyutil.top_expand (bind_ty (t));
          def val = ty_expr (ctx, e);
          def valt = Tyutil.top_expand (val.ty);
          def conv = match (valt) {
            | TType.Class (tinfo, _) =>
              def loop (mems : list [IMember]) {
                | mem :: xs when mem.IsStatic =>
                  match (mem.GetMemType ()) {
                    | TType.Function (_, to) when Tyutil.types_eq (to, t) =>
                      Some (TExpr.Call (TExpr.StaticRef (mem), [Parm (val)]))
                    | _ => loop (xs)
                  }
                | _ :: xs => loop (xs)
                | _ => None ()
              }
              loop (tinfo.LookupMember ("op_Explicit"))

            | _ => None ()
          }
          match (conv) {
            | Some (x) => (x, t)
            | None =>
              if (Tyutil.is_value_type (t) || Tyutil.is_value_type (valt))
                // FIXME: do more conservative checking
                (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
              else
                if (t >:> valt)
                  (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
                else if (valt >:> t)
                  (val, t) /// nothing to be done, warn about redundancy of cast?
                else {
                  // FIXME: unfortunately we use some forbidden casts in compiler
                  // Message.error ($"cannot convert type `$(Tyutil.string_of_type (val.ty))'"
                  //               " to `$(Tyutil.string_of_type (t))'");
                  // (val, val.ty)
                  (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
                }
          }
    }


  }
}


  squash_type_duplicates (lst : list [Symbol]) : list [Symbol]
  {
    def ht = Hashtable ();
    def unalias (ti : TypeInfo) {
      match (ti.GetTydecl ()) {
        | TypeDeclaration.Alias (TType.Class (ti, _)) => unalias (ti)
        | _ => ti
      }
    }
    List.Filter (lst, fun (_) {
      | Symbol.Type (ti) =>
        def ti = unalias (ti);
        if (ht.Contains (ti.GetId ()))
          false
        else {
          ht [ti.GetId ()] = null;
          true
        }
      | _ => true
    })
  }

  // given an expression return list of symbols it can expand to
  make_value_reference (ctx : CTX, expr : PT.PExpr, fallback : bool) : list
  [TExpr]
  {
    def lookup_type (expr) {
      match (Util.qidl_of_expr (expr)) {
        | Some ((r, name)) =>
          name.GetEnv (ctx.env).LookupType (r, ctx.parent_type)
        | _ => None ()
      }
    };

    def unalias (ti : TypeInfo) {
      match (ti.GetTydecl ()) {
        | TypeDeclaration.Alias (TType.Class (ti, _)) => unalias (ti)
        | _ => ti
      }
    };

    def lookup_ctors (ti : TypeInfo) {
      def ti = unalias (ti);
      def is_ctor (m : IMember) {
        match (m.GetKind ()) {
          | MemberKind.Method (m) =>
            match (m.GetFunKind ()) {
              | FunKind.Constructor when m.CanAccess (ctx.parent_type) => true
              | _ => false
            }
          | _ => false
        }
      };
      match (List.Filter (ti.LookupMember (".ctor"), is_ctor)) {
        | [] when !ti.IsValueType =>
          Message.fatal_error ($"type `$(ti.FullName)' has no accessible constructors")
        | decls => decls
      }
    };

    def convert_symbols (acc, syms) {
      def syms = squash_type_duplicates (syms);

      def handle_type_construction (t : TypeInfo) {
        def mkctor (m : IMember) {
          def ty =
            match (m.GetMemType ()) {
              | TType.Function (arg, TType.Void) =>
                def ret_t =
                  match (t.GetTydecl ()) {
                    | TypeDeclaration.VariantOption =>
                      def t' = Option.UnSome (t.SuperClass ());
                      t'.GetMemType () /- t.SubtypingSubst (t')
                    | _ =>
                      t.GetMemType ()
                  };
                def ret = TType.Function (arg, ret_t) /- t.FreshSubst ();
                // Message.debug ($ "arg $arg ret $ret");
                ret

              | t => Util.ice ($ "fscked ctor type $t")
            };
          TExpr.StaticRef (loc = expr.loc, ty = ty, mem = m)
        };

        match (t.GetTydecl ()) {
          | TypeDeclaration.Alias (TType.Class (t, _)) => handle_type_construction (t)
          | _ =>
            if (t.Attributes %&& NemerleAttributes.Abstract)
              Message.fatal_error ($"type `$(t.FullName)' is abstract and cannot be constructed");
            else
              match (t.GetConstantObject ()) {
                | None =>
                  def is_empty_ctor (e) {
                    type_of (e) matches TType.Function (TType.Void, _)
                  }
                  def res = List.Map (lookup_ctors (t), mkctor);
                  if (t.IsValueType && !List.Exists (res, is_empty_ctor)) {
                    def ty = TType.Function (TType.Void (), t.GetMemType () /- t.FreshSubst ());
                    TExpr.ImplicitValueTypeCtor (loc = expr.loc,
                                                ty = ty,
                                                tc = t) :: res
                  } else res
                | Some (f) =>
                  [TExpr.ConstantObjectRef (loc = expr.loc,
                                          ty = TType.Function (TType.Void (),
                                                      f.GetMemType () /-
                                                      t.FreshSubst ()),
                                          mem = f)]
              }
          }
      };

      def last_chance () {
        match ((acc, syms)) {
         | ([], [_]) => true
         | _ => false
        }
      };

      def can_access (sym) {
        | Symbol.TypeMember (x) => x.CanAccess (ctx.parent_type)
        | Symbol.Type (t) => t.CanAccess (ctx.parent_type)
      };

      match (syms) {
        | [] => acc

        | (Symbol.TypeMember (x) as sym) :: xs when x.IsStatic =>
          if (can_access (sym)) {
            def acc =
              match (x.GetKind ()) {
                | MemberKind.Type (t) =>
                  List.RevAppend (handle_type_construction (t), acc)

                | MemberKind.Method (m) =>
                  match (m.GetExternName ()) {
                    | None =>
                      TExpr.StaticRef (loc = expr.loc, ty = m.GetFreshType (),
                                    mem = x) :: acc

                    | Some (name) =>
                      def split_at_dots (str : string) {
                        def idx = str.LastIndexOf ('.');
                        if (idx == -1) PT.PExpr.Ref (PT.Name (str))
                        else PT.PExpr.Member (split_at_dots (str.Substring (0, idx)),
                                          PT.Splicable.Name (PT.Name (str.Substring
                                          (idx + 1))))
                      };
                      def exprs =
                        make_value_reference (ctx, split_at_dots (name),
                                              fallback = false);
                      def valid (expr) {
                        match (expr) {
                          | TExpr.StaticRef (mem) =>
                            Tyutil.types_eq (mem.GetMemType (), m.GetMemType ())
                          | _ => false
                        }
                      };
                      match (List.Filter (exprs, valid)) {
                        | [x] => x :: acc
                        | [] =>
                          Message.fatal_error ("unbound extern symbol `" + name +
                          "'")
                        | _ =>
                          Message.fatal_error ("wrong extern symbol `" + name +
                          "'")
                      }
                  }

                | MemberKind.Property (p) =>
                  TExpr.StaticPropertyRef (loc = expr.loc, ty = x.GetMemType (),
                                         prop = p) :: acc

                | MemberKind.Field =>
                  TExpr.StaticRef (loc = expr.loc, ty = x.GetMemType (), mem = x)
                  :: acc

                | MemberKind.Event (e) =>
                  if (e.DeclaringType.SameAs (ctx.parent_type)) {
                    def field = (e :> NemerleEvent).storage_field;
                    if (field == null)
                      acc
                    else {
                      TExpr.StaticRef (loc = expr.loc, ty = field.GetMemType (),
                                    mem = field) :: acc
                    }
                  }
                  else
                    acc
              }

            convert_symbols (acc, xs)
          }
          else
          {
            when (last_chance ())
              Message.error ($"cannot access `$(x.DeclaringType.FullName).$(x.Name)'");
            convert_symbols (acc, xs)
          }

        | Symbol.TypeMember :: xs => convert_symbols (acc, xs)

        | (Symbol.Type (t) as sym) :: xs when can_access (sym) =>
          convert_symbols (List.RevAppend (handle_type_construction (t), acc), xs)

        | Symbol.Type (t) :: xs =>
          when (last_chance ())
            Message.error ("cannot access type `" + t.FullName + "'");
          convert_symbols (acc, xs)
      }
    };

    def error_when_empty (lst, msg) {
      match (lst) {
        | [] => Message.fatal_error (msg)
        | _ => lst
      }
    };

    Util.locate (expr.loc, {
      match (expr) {
        | PT.PExpr.Ref (n) =>
          match (ctx.LookupLocal (n)) {
            | Some (d) =>
              ctx.Closurise (d);
              d.ever_used = true;
              def ty =
                match (d.kind) {
                  | LocalValueKind.Function (h, _) =>
                    d.ty /- Tyvar.fresh_subst (h.typarms)
                  | _ => d.ty
                };
              [TExpr.LocalRef (loc = expr.loc, ty = ty, decl = d)]

            | None =>
              def from_this =
                match (ctx.this_ptr_decl) {
                  | Some ({ty = TType.Class (ti, _)}) =>
                    def is_instance (m : IMember) { !m.IsStatic };
                    def mem = n.Id;
                    if (List.Exists (ti.LookupMember (mem), is_instance))
                      lookup_member (ctx, expr.loc,
                                     ty_expr (ctx, PT.PExpr.This ()), mem,
                                     error_when_not_found = false)
                    else []
                  | _ => []
                };

              // resolve the symbols list
              def env = n.GetEnv (ctx.env);
              def symbols_from_env = env.LookupSymbol (n.idl);
              def res = convert_symbols (from_this, symbols_from_env);

              match (res) {
                | [] =>
                  // take into account static symbols from the current type
                  def ref_name = Util.qid_of_list (n.idl);
                  def from_parent_type = ctx.parent_type.LookupMember (ref_name);

                  def static_and_name_filter (mem : IMember) {
                      mem.Name == ref_name &&
                      (mem.Attributes %&& NemerleAttributes.Static)
                  };
                  def symbol_map (mem : IMember) : Symbol {
                      Symbol.TypeMember (mem)
                  };
                  def symbols_from_type =
                    List.Map (List.Filter (from_parent_type,
                                           static_and_name_filter), symbol_map);

                  def res = convert_symbols ([], symbols_from_type);

                  match (res) {
                    | [] =>
                      // if failed to resolve the symbols, check the possible reason
                      def instance_mems =
                        List.Filter (from_parent_type,
                                     fun (mem : IMember) {
                                       mem.Name == ref_name &&
                                       !(mem.Attributes %&&
                                       NemerleAttributes.Static)
                                     });

                      match (instance_mems) {
                        | [] =>
                          error_when_empty (res, "unbound symbol `" +
                          Util.qid_of_list (n.idl) + "'")

                        | _ =>
                          Message.fatal_error ("referencing an instance member `" +
                                               ref_name + "' from within a static method");
                          []
                      }
                    | _ => res
                  }
                | _ => res
              }
          }

        | PT.PExpr.Member (e1, PT.Splicable.Name ({ idl = [x] })) =>
          match (lookup_type (e1)) {
            | Some (t) =>
              def err = $"unbound member `$(x)' in type `$(t.FullName)'";
              def t = unalias (t);
              match (t.LookupMember (x)) {
                | [] =>
                  match (lookup_type (expr)) {
                    | Some (t) =>
                      convert_symbols ([], [Symbol.Type (t)])
                    | None =>
                      Message.fatal_error (err)
                  }
                | lst =>
                  def loop (x : IMember, acc) {
                    if (x.IsStatic)
                      Symbol.TypeMember (x) :: acc
                    else acc
                  };
                  def lst' = List.FoldLeft (lst, [], loop);
                  error_when_empty (convert_symbols ([], lst'), err)
              }
            | None =>
              match (lookup_type (expr)) {
                | Some (t) => convert_symbols ([], [Symbol.Type (t)])
                | None =>
                  def typed_base_expr = ty_expr (ctx, e1);

                  if (typed_base_expr matches TExpr.Literal (Literal.Null))
                  {
                    def base_name =
                      match (Util.qidl_of_expr (e1)) {
                        | Some ((r, _)) =>
                          Util.qid_of_list (r)
                        | _ =>
                          Util.ice ("base_name")
                      };

                    def lead_in_msg =
                      "failed to find namespace or type `" +
                      base_name + "' for accessing `" + x +"'";

                    if (base_name == "System" || base_name == "Nemerle") {
                      Message.error (lead_in_msg);
                      Message.hint_once ("  maybe you forgot to reference an external library?");
                      throw Recovery ()
                    }
                    else {
                      if (base_name.LastIndexOf ('.') == -1) {
                        Message.error (lead_in_msg);
                        Message.hint_once ("  maybe you're trying to use a "
                                           "static type member as an instance "
                                           "member or forgot to reference an "
                                           "external library?");
                        throw Recovery ()
                      }
                      else
                        Message.fatal_error (lead_in_msg)
                    }
                  }
                  else
                  {
                    lookup_member (ctx, expr.loc, typed_base_expr, x)
                  }
              }
          };

        | PT.PExpr.Member (_, PT.Splicable.Name ({idl = _ :: _})) =>
          Message.fatal_error ("member has more than one component in name")
        | PT.PExpr.Member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.PExpr.This =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = TType.Class (ti, _)}); in_ctor = true} =>
              def mkthis (m : IMember) {
                TExpr.Base (loc = expr.loc,
                        ty = m.GetMemType (),
                        base_ctor = (m :> IMethod))
              };
              List.Map (lookup_ctors (ti), mkthis)

            | _ =>
              Message.fatal_error ("`this (..)' used outside constructor")
          }

        | PT.PExpr.Base =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = TType.Class (ti, _)}); in_ctor = true} =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  // FIXME: check access
                  def mkbase (m : IMember) {
                    TExpr.Base (loc = expr.loc,
                            ty = m.GetMemType () /- ti.SubtypingSubst (baseti),
                            base_ctor = (m :> IMethod))
                  };
                  List.Map (lookup_ctors (baseti), mkbase)

                | None =>
                  Message.fatal_error ("class " + ti.FullName +
                                       " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base (..)' used outside constructor")
          }

        | PT.PExpr.Literal (l) =>
          [TExpr.Literal (loc = expr.loc, ty = ty_literal (ctx, l), val = l)]

        | _ when fallback => [ty_expr (ctx, expr)]
        | _ => Util.ice ("evil value passed to make_value_reference")
      }
    })
  }


  /*
   * Given list of formal parms names and actual parms names, reorder
   * actuals to match formals. The named parameters can be preceded
   * by a series of unnamed parameters:
   *
   *   bar (e_0, e_1, x_2 = e_2, x_3 = e_3, ..., x_k = e_k)
   *
   * where x_i are the named parameter references and e_i are some
   * expressions.
   */
  reorder_named_parms (top_names : list [string],
                       top_parms : list [Parm],
                       do_throw : bool) : list [Parm]
  {
    // lookup tables for names, named and unnamed parameters
    def valid_names = Hashtable (16);
    def seen_named_parms = Hashtable (16);
    def seen_unnamed_parms = Hashtable (16);

    // we will need a way to lookup the valid parameter names
    foreach (name in top_names) {
      assert (name != null);
      assert (!valid_names.ContainsKey (name));
      valid_names.Add (name, name)
    }

    // failure handler
    def fail (msg : string) : bool
    {
      if (do_throw)
        throw Typing_error (msg)
      else
        false
    }

    // the correctness verifier
    def check_names_and_parms (names : list [string], parms : list [Parm]) : bool
    {
      | ([], []) =>
        true

      | (_, []) =>
        // always throw an error here -- we'll catch it and produce better error
        // for wrong parameters count
        def unresolved_names =
          List.Filter (top_names, fun (name : string) {
            !(seen_named_parms.Contains (name) || seen_unnamed_parms.Contains (name))
          });

        def unresolved_names =
          List.Map (unresolved_names, fun (name : string) { "`" + name + "'" });

        throw Typing_error ("unresolved named parameters: " +
                            NString.Concat (", ", unresolved_names))

      | (name :: rest_of_names, parm :: rest_of_parms) when parm.name == "" =>
        // the case for an unnamed parameter
        if (seen_named_parms.Count > 0) {
          // seen a named parameter before, error...
          fail ("unnamed parameter found after a named parameter")
        }
        else {
          // otherwise, this is an element of the leading unnamed parameters
          seen_unnamed_parms.Add (name, parm);
          check_names_and_parms (rest_of_names, rest_of_parms)
        }

      | (_ :: rest_of_names, parm :: rest_of_parms) =>
        // a named parameter, check if no unnamed parameter has covered it before
        if (seen_unnamed_parms.ContainsKey (parm.name)) {
          // this parameter name was covered by an unnamed parameter
          fail ("keyword parameter `" + parm.name + "' already specified as an unnamed parameter")
        }
        else if (seen_named_parms.ContainsKey (parm.name)) {
          // the case for repeating parameters
          fail ("keyword parameter `" + parm.name + "' already specified")
        }
        else if (!valid_names.ContainsKey (parm.name)) {
          // whoops, no such parameter for this method :]
          fail ("no such keyword parameter `" + parm.name + "' among valid parameter names")
        }
        else {
          // OK, this has to be right...
          seen_named_parms.Add (parm.name, parm);
          check_names_and_parms (rest_of_names, rest_of_parms)
        }

      | _ =>
        Util.ice ("reorder_named_parms: walk")
    }

    // reordering is a matter of simple names list walk now:
    def reorder_parms (names : list [string], acc : list [Parm]) : list [Parm]
    {
      | (name :: rest_of_names, _) =>
        if (seen_unnamed_parms.Contains (name))
          reorder_parms (rest_of_names,
                         Option.UnSome (seen_unnamed_parms.Get (name)) :: acc)
        else if (seen_named_parms.Contains (name))
          reorder_parms (rest_of_names,
                         Option.UnSome (seen_named_parms.Get (name)) :: acc)
        else
          Util.ice ("reorder_named_parms: reorder")

      | ([], _) =>
        List.Rev (acc)
    }

    if (List.Exists (top_parms, fun (parm : Parm) { parm.name != "" })) {
      match (top_names) {
        | [] when do_throw =>
          throw Typing_error ("named parameters given but formals' names cannot"
                              " be inferred")
        | [] =>
          null
        | _ =>
          if (check_names_and_parms (top_names, top_parms))
            reorder_parms (top_names, [])
          else
            null
      }
    }
    else
      top_parms
  }


  // check if FN can be called with PARMS
  check_call_to (ctx : CTX, parms : list [Parm], fn : TExpr,
                 do_throw : bool, is_var_args : bool) : CallResult
  {
    def check_arg (parm : Parm, ty : TType, arg_no, sub) : int * Subst {
      if (arg_no < 0) (arg_no, sub)
      else {
        def expr_ty = type_of (parm.expr);
        def parm_ty =
          match (ty) {
            | TType.ByRef (t) when parm.kind == ParmKind.Ref => t
            | TType.Out (t) when parm.kind == ParmKind.Out => t
            | TType.Out =>
              if (do_throw)
                throw Typing_error ($ "needed `out' in argument #$arg_no")
              else null
            | TType.ByRef =>
              if (do_throw)
                throw Typing_error ($ "needed `ref' in argument #$arg_no")
              else null
            | _ when parm.kind != ParmKind.Normal =>
              if (do_throw)
                throw Typing_error ($ "argument #$arg_no was passed as ref/out")
              else null
            | _ => ty
          };
        if (parm_ty == null)
          (-1, sub)
        else
          match (Tyutil.unify (sub, expr_ty, parm_ty, true)) {
            | Some (u) =>
              (arg_no + 1, u)
            | None when do_throw =>
              throw Typing_error ($ "in arg #$arg_no needed $(ty /- sub) "
                                    "got $(expr_ty /- sub)")
            | None => (-1, sub)
          }
      }
    };

    def formal_names = {
      def from_header (h : Fun_header) : list [string] {
        List.Map (h.parms, fun (p : Fun_parm) : string { p.name })
      };
      match (fn) {
        | TExpr.LocalRef ({kind = LocalValueKind.Function (h, _)}) =>
          from_header (h)
        | TExpr.MethodRef (_, meth, _)
        | TExpr.StaticRef (meth : IMethod) =>
          from_header (meth.GetHeader ())
        | _ => []
      }
    };

    match (Tyutil.top_expand (type_of (fn))) {
      | TType.Function (from, ret) =>
        // check if we are dealing with a delegate constructor
        def delegate_tycon =
          match (fn) {
            | TExpr.StaticRef (meth : IMethod) when (meth.DeclaringType.IsDelegate &&
                                                 (meth.GetFunKind () matches FunKind.Constructor)) =>
              Some (meth.DeclaringType)
            | _ =>
              None ()
          }

        // get the arguments for delegate constructor from the Invoke method
        def args =
          match (delegate_tycon) {
            | Some (delegate_tycon) =>
              match (delegate_tycon.LookupMember ("Invoke")) {
                | [invoke] =>
                  def invoke_ty = (invoke :> IMethod).GetMemType ();
                  [invoke_ty]
                | _ =>
                  Message.fatal_error ("cannot decide upon delegate ctor parameters")
              }
            | _ =>
              Tyutil.fun_args (from)
          }

        def wrong_args_cnt (extra_message) {
          if (do_throw)
            throw Typing_error ("needed " + (List.Length (args)).ToString () +
                                " parameters, got " + (List.Length (parms)).ToString () +
                                extra_message)
          else
            null
        };

        try {
          def args =
            match ((parms, args)) {
              | ([parm], _ :: _ :: _) when ! is_var_args =>
                // FIXME: it doesn't work when parm : 'a, where 'a is unconstrained
                match (Tyutil.top_expand (type_of (parm.expr))) {
                  | TType.Product (types) when List.Length (types) == List.Length (args) =>
                    [TType.Product (args)]
                  | _ => wrong_args_cnt ("")
                }
              | _ =>
                if (List.Length (args) == List.Length (parms) ||
                    (is_var_args && List.Length (args) <= List.Length (parms) + 1))
                  args
                else if (List.Length (args) > List.Length (parms) && !is_var_args)
                {
                  def named_parms_message =
                    try {
                      ignore (reorder_named_parms (formal_names, parms, false));
                      ""
                    }
                    catch { e : Typing_error => " (" + e.msg + ")" }

                  wrong_args_cnt (named_parms_message)
                }
                else
                  wrong_args_cnt ("")
            };
          def parms =
            if (args == null) null
            else reorder_named_parms (formal_names, parms, do_throw);
          def (argno, sub) =
            if (parms == null || args == null) (-1, null)
            else {
              def loop (arg_no, map, parms, args) {
                match ((parms, args)) {
                  | (parm :: parms, [TType.Array (t, 1)]) when is_var_args =>
                    def (arg_no, map) = check_arg (parm, t, arg_no, map);
                    loop (arg_no, map, parms, args) // args doesn't change
                  | ([], [_]) when is_var_args => (arg_no, map)
                  | (parm :: parms, arg :: args) =>
                    def (arg_no, map) = check_arg (parm, arg, arg_no, map);
                    loop (arg_no, map, parms, args)
                  | ([], []) => (arg_no, map)
                  | _ => assert (false)
                }
              }
              loop (1, SystemMap (), parms, args)
            }
          if (argno < 0)
            CallResult.Unspecified_error ()
          else {
            def parms =
              if (is_var_args) {
                def split (_, _, _) {
                  | (acc, [_], lst) =>
                    def get_expr (parm : Parm) {
                      when (parm.kind != ParmKind.Normal)
                        Message.error ("ref/out parameters are not allowed with `parms'");
                      when (parm.name != "")
                        Message.error ("named parameters are not allowed with `parms'");
                      parm.expr
                    }
                    (acc, List.Map (lst, get_expr))
                  | (acc, _ :: args, x :: xs) =>
                    split (x :: acc, args, xs)
                  | _ => assert (false)
                }
                def (regular_parms, for_array) = split ([], args, parms);
                def mkarray = TExpr.Array (fn.loc, List.Last (args),
                                         for_array, [TExpr.Literal (Literal.Int (List.Length (for_array)))]);
                List.Rev (Parm (mkarray) :: regular_parms)
              } else parms;
            def res_expr =
              match (fn) {
                | TExpr.ConstantObjectRef (mem) =>
                  assert (parms.IsEmpty ());
                  TExpr.StaticRef (fn.loc, ret /- sub, mem)
                | TExpr.ImplicitValueTypeCtor =>
                  assert (parms.IsEmpty ());
                  fn.ty = ret /- sub;
                  fn
                | _ =>
                  TExpr.Call (fn.loc, ret /- sub, fn, parms)
              };
            CallResult.Ok (res_expr, sub)
          }
        }
        catch { x : Typing_error => CallResult.Error (x.msg) }

      | ty when Tyutil.IsDelegate (ty) =>
        match (LookupMembers (ctx, ty, "Invoke")) {
          | [mem] =>
            def fn' = TExpr.MethodRef (fn.loc, mem.GetMemType (), fn, (mem :> IMethod), false);
            check_call_to (ctx, parms, fn', do_throw, is_var_args)
          | _ when do_throw =>
            CallResult.Error ($ "cannot find `Invoke' method in delegate type $(type_of (fn))")
          | _ =>
            CallResult.Unspecified_error ()
        }

      | _ when do_throw =>
        CallResult.Error ($ "called value has non-functional type $(type_of (fn))")

      | _ =>
        CallResult.Unspecified_error ()
    }
  }

  resolve_overloaded_call (ctx : CTX, in_tail_pos : bool, fncs : list [TExpr],
                           parms : list [Parm]) : TExpr
  {
    def is_var_args (fn) {
      | TExpr.StaticRef (meth : IMethod)
      | TExpr.MethodRef (_, meth, _)
      | TExpr.Base (meth) =>
        meth.IsVarArgs
      | _ => false
    };

    def check_one (fn, acc) {
      match (check_call_to (ctx, parms, fn, false, false)) {
        | CallResult.Ok (ex, sub) => (ex, sub) :: acc
        | _ => acc
      }
    };

    def check_one_va (fn, acc) {
      if (is_var_args (fn))
        match (check_call_to (ctx, parms, fn, false, true)) {
          | CallResult.Ok (ex, sub) => (ex, sub) :: acc
          | _ => acc
        }
      else acc
    };

    def check_error (fn, acc) {
      match (check_call_to (ctx, parms, fn, true, false)) {
        | CallResult.Error (msg) =>
          def acc = (msg, fn) :: acc;
          if (is_var_args (fn))
            match (check_call_to (ctx, parms, fn, true, true)) {
              | CallResult.Error (msg) =>
                (msg, fn) :: acc
              | _ => assert (false)
            }
          else acc
        | _ => assert (false)
      }
    };

    mutable used_var_args = false;

    def res = List.FoldLeft (fncs, [], check_one);
    def res =
      // varargs version is used *only* if there is no match not using it
      match (res) {
        | [] =>
          used_var_args = true;
          List.FoldLeft (fncs, [], check_one_va)
        | _ => res
      };

    match (res) {
      // special case (simple)
      | [(x, sub)] =>
        Tyvar.global_store (sub);
        def x = transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x);
        mark_as_used (ctx, x);

      | [] =>
        match (List.FoldLeft (fncs, [], check_error)) {
          | [(err, fn)] =>
            Message.error (err + " calling " + describe_expression (fn));
            throw Recovery ()
          | p =>
            Message.error ("typing error in call:");
            foreach ((err, fn) in p)
              Message.error ("  " + err + " calling " + describe_expression (fn));
            throw Recovery ()
        }

      // in general we look for set of maximal argument types
      | l =>
        def get_type (ex : TExpr, s : Subst) : TType * (TExpr * Subst) {
          match (ex) {
            | TExpr.Call (fn, _) =>
              match (Tyutil.top_expand (type_of (fn))) {
                | TType.Function (t1, _) =>
                  if (used_var_args)
                    match (List.DivideLast (Tyutil.fun_args (t1))) {
                      | ([], TType.Array (t, 1)) =>
                        (t, (ex, s))
                      | (fun_args, TType.Array (t, 1)) =>
                        (TType.Product (fun_args + [t]), (ex, s))
                      | _ => assert (false)
                    }
                  else
                    (t1, (ex, s))
                | _ => Util.ice ()
              }
            | _ => Util.ice ()
          }
        };

        match (Tyutil.maximal_types (List.Map (l, get_type))) {
          | [(_, (x, sub))] =>
            Tyvar.global_store (sub);
            def x = transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x);
            mark_as_used (ctx, x);

          | l =>
            Message.error ("overloading resolution ambiguity between:");
            foreach ((_ : TType, (TExpr.Call (ex, _), _) : TExpr * Subst) in l) {
              def ex_t = type_of (ex);
              Message.error ($ "    functional value of type $ex_t")
            }
            /*
            | (TExpr.Call (TExpr.E_ref (d), _), _) =>
              // FIXME: we could do better
              Message.error (d.loc, $ "    functional value of type $(d.ty)")
            */
            throw Recovery ()
        }
    }
  }

  public lookup_member (ctx : CTX, loc : Location, o : TExpr, mem : string)
  : list [TExpr]
  {
    lookup_member (ctx, loc, o, mem, true);
  }

  // lookup member MEM in type_of (O)
  // return list of how we can call it
  public lookup_member (ctx : CTX, loc : Location, o : TExpr, mem : string,
                        error_when_not_found : bool) : list [TExpr]
  {
    mutable problem = "???";
    def visited = Hashtable (10);

    def collect_from (t, acc) {
      match (Tyutil.top_expand (t)) {
        | TType.Class (ti, args) =>
          if (visited.Contains (ti.GetId ())) acc
          else {
            visited.Add (ti.GetId (), null);

            def subst = ti.MakeSubst (args);
            def can_access (mem : IMember, acc) {
              if (!mem.IsStatic && mem.CanAccess (ctx.parent_type))
                mem.GetKind () :: acc
              else
                acc
            };
            def members = ti.LookupMember (mem);
            def accessible_members = List.FoldLeft (members, [], can_access);
            def mems =
              match (accessible_members) {
                | [MemberKind.Field (f)] =>
                  [TExpr.FieldMember (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [MemberKind.Event (e)] when
                    e.DeclaringType.SameAs (ctx.parent_type) &&
                    (e :> NemerleEvent).storage_field != null =>
                  def f = (e :> NemerleEvent).storage_field;
                  [TExpr.FieldMember (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [] =>
                  def is_static (mem : IMember, acc) {
                    if (mem.IsStatic && mem.CanAccess (ctx.parent_type))
                      mem.GetKind () :: acc
                    else
                      acc
                  };
                  def static_members = List.FoldLeft (members, [], is_static);
                  def (prefix, suffix) =
                    match ((members, static_members)) {
                      | ([], _) => ("unbound", "")
                      | (_, []) => ("inaccessible", "")
                      | _ => ("can't access static", " through an instance reference")
                    }

                  problem =
                    prefix + " member `" + mem + "' in type `" +
                    ti.FullName + "'" + suffix;
                  []

                | lst =>
                  mutable was_prop = false;
                  mutable was_meth = false;
                  def make (m) {
                    match (m) {
                      | MemberKind.Property (p) when !was_meth =>
                        was_prop = true;
                        def ty = Tyutil.TypeOfMemberIn (p, ti) /- subst;
                        //Message.debug (loc, $ "prop $(p.Name) : $ty");
                        TExpr.PropertyMember (loc, ty, o, p)
                      | MemberKind.Method (m) when !was_prop =>
                        was_meth = true;
                        TExpr.MethodRef (loc, Tyutil.TypeOfMethodIn (m, ti) /- subst, o, m, false)
                      | _ =>
                        Message.fatal_error ("ambiguous member name `" + mem +
                                             "' in type `" + ti.FullName + "'")
                    }
                  };
                  List.Map (lst, make)
               };
            List.Append (mems, acc)
          }

        | TType.Variable (tv) =>
          if (visited.Contains (tv.id)) acc
          else {
            visited.Add (tv.id, null);
            def constraints =
              match (Tyvar.constraints (tv)) {
                | [] => [InternalType.Object]
                | lst => lst
              };
            match (List.FoldLeft (constraints, acc, collect_from)) {
              | [] =>
                problem = $ "no constrain of $t provides member `$(mem)'";
                []
              | acc => acc
            }
          }

        | TType.Array =>
          collect_from (InternalType.Array, acc)

        | TType.Product =>
          collect_from (InternalType.Object, acc)

        | _ =>
          problem = $ "type $t was expected to be class";
          acc
      }
    };

    match (collect_from (type_of (o), [])) {
      | [] when error_when_not_found => Message.fatal_error (problem)
      | x => x
    }
  }

  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.PExpr.Match) : TExpr * TType
  {
    def itp = ctx.in_tail_position;
    def ctx = ctx.WithInTailPosition (false);
    def matched_value = ty_expr (ctx, mtch.expr);
    mutable disable_warnings = false;

    def do_case (c : PT.MatchCase, acc) {
      when (c.disable_warnings) disable_warnings = true;
      def (pat, ctx') = PatternTyping.TypePatterns (ctx, type_of (matched_value), c.patterns);
      def body = ty_expr (ctx'.WithInTailPosition (itp), c.body);
      match (acc) {
        | (Some (t), l) =>
          match (Tyutil.unify_branches (t, type_of (body))) {
            | Some (t') => (Some (t'), Match_case (pat, body) :: l)
            | None =>
              expect_type ("match case body", body, t);
              Util.ice () // not reached
          }
        | (None, l) =>
          (Some (type_of (body)), Match_case (pat, body) :: l)
      }
    };

    match (List.FoldLeft (mtch.cases, (None (), []), do_case)) {
      | (Some (t), mcs') =>
        def mcs = List.Rev (mcs');
        unless (disable_warnings) PatternTyping.check_matching (mcs);
        foreach (mc : Match_case in mcs) {
          mc.patterns =
            List.Map (mc.patterns,
                      fun (p, e) {
                         (PatternTyping.strip_enums (p), e)
                      })
        }
        (TExpr.Match (matched_value, mcs), t)
      | (None, _) =>
        Message.fatal_error ("cannot have empty match construct");
    }
  }

  ty_letfun (ctx : CTX, fs : list [PT.Function_decl]) : list [Function_decl] * CTX
  {
    def make_fun (d : PT.Function_decl) {
      def pars = {
        def h = ctx.current_fun;
        if (h.decl == null) [h]
        else
          match (h.decl.kind) {
            | LocalValueKind.Function (_, pars) => h :: pars
            | _ => Util.ice ()
          }
      };

      def h = d.header;
      def name_obj = h.name.GetName ();
      def (tenv, typarms) = ctx.parent_type.BindTyparms (ctx.tenv, h.typarms);
      def mkparm (p : PT.Fun_parm) : Fun_parm {
        def name = p.name.GetName ();
        Fun_parm (loc = p.loc, name = name.Id, color = name.color,
                  ty = ctx.parent_type.BindType (tenv, p.ty), decl = null,
                  modifiers = p.modifiers)
      };
      def h' = Fun_header (
         ret_type = ctx.parent_type.BindType (tenv, h.ret_type),
         typarms = typarms,
         name = name_obj.Id,
         parms = List.Map (h.parms, mkparm),
         tenv = tenv,
         loc = h.loc);

      def lv = ctx.DefineLocal (name_obj,
                                LocalValueKind.Function (h', pars),
                                Tyutil.fun_type (h'));
      h'.decl = lv;
      h'
    };

    def headers = List.Map (fs, make_fun);
    def localvals = List.Map (headers, fun (h : Fun_header) { h.decl });
    def ctx = ctx.WithLocals (localvals);
    def do_fun (d : PT.Function_decl, h : Fun_header) : Function_decl {
      Function_decl (h, ty_function (ctx, h, d.body))
    };
    (List.Map2 (fs, headers, do_fun), ctx)
  }

  ty_sequence (ctx : CTX, l : list [PT.PExpr]) : TExpr
  {
    def in_tail_pos = ctx.in_tail_position;
    def orig_ctx = ctx;
    def ctx = ctx.WithInTailPosition (false);

    def go () : TExpr {
      match (l) {
        | [x] =>
          def x = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, x);
          ty_expr (orig_ctx, MacroRegistry.expand_macro (orig_ctx, ctx, x))

        | x :: xs =>
          def x = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, x);
          match (MacroRegistry.expand_macro (ctx, ctx, x)) {
            | PT.PExpr.DefFunctions (fs) =>
              def (fs', ctx') = ty_letfun (ctx, fs);
              def body = ty_sequence (ctx'.WithInTailPosition (in_tail_pos), xs);
              fixup (TExpr.DefFunctionsIn (fs', body), type_of (body))

            | (PT.PExpr.Define) as x =>
              def val = ty_expr (ctx, x.val);
              def name = match (x.name) {
                | PT.Splicable.Name (n) => n
                | _ =>
                  Message.fatal_error ("$ operator used outside quotation "
                                       "<[ ... ]> context")
              };

              // check for mutable symbol redefinitions
              match (ctx.LookupLocal (name)) {
                | Some (l) when l.name == x.name.GetName ().Id =>
                  def warn =
                    if (x.is_ref && l.is_ref)
                      Some (("mutable", ""))
                    else if (!x.is_ref && l.is_ref)
                      Some (("mutable", " as non-mutable"))
                    else if (x.is_ref && !l.is_ref)
                      Some (("non-mutable", " as mutable"))
                    else
                      None ();

                  match (warn) {
                    | Some ((was_of_kind, is_of_kind)) =>
                      Message.warning (x.loc, "redefinition of a local " +
                                       was_of_kind + " value `" + l.name +
                                       "'" + is_of_kind);
                      Message.warning (l.loc, "  <-- previously seen here")
                    | _ => ()
                  }
                | _ => ()
              }

              def decl = ctx.DefineLocal (name, LocalValueKind.LocalVariable(), type_of (val));
              decl.is_ref = x.is_ref;
              def body = ty_sequence (ctx.WithLocal (decl).
                                      WithInTailPosition (in_tail_pos), xs);
              fixup (TExpr.DefValIn (decl, val, body), type_of (body))

            | PT.PExpr.DefPattern (p, v) =>
              def body = PT.PExpr.Sequence (xs);
              def mtch = PT.PExpr.Match (p.loc, v, [PT.MatchCase ([(p, None ())], body)]);
              body.loc = (List.Head (xs)).loc;
              ty_expr (orig_ctx, mtch)

            | x =>
              def ex = ty_expr (ctx, x);
              def t = type_of (ex);
              if (t >:> TType.Void ()) {
                def tl = ty_sequence (orig_ctx, xs);
                fixup (TExpr.Sequence (ex, tl), type_of (tl))
              }
              else {
                when (Flags.ignored_value_warnings) {
                  Message.warning ($ "ignored computed value of type $t");
                  Message.hint_once ("use _ = ...; or -Wno-ignore to avoid the warning");
                }

                def tmp = Util.tmpname ("ign");
                def decl = ctx.DefineLocal (tmp, 1, LocalValueKind.LocalVariable (), type_of (ex));
                def body = ty_sequence (ctx.WithLocal (decl).
                                        WithInTailPosition (in_tail_pos), xs);
                fixup (TExpr.DefValIn (decl, ex, body), type_of (body))
              }
          }
        | [] => Util.ice ("empty sequence")
      }
    };

    Util.locate ((List.Head (l)).loc, go ())
  }

  public ty_literal (_ : CTX, l : Literal) : TType
  {
    match (l) {
      | Literal.Void => TType.Void ()
      | Literal.Null =>
        match (Tyvar.free_variable ()) {
          | (TType.Variable (tv)) as r => tv.value = TvValue.FreeFromNull (); r
          | _ => Util.ice ()
        }
      | Literal.Byte => InternalType.Byte
      | Literal.SByte => InternalType.SByte
      | Literal.Short => InternalType.Int16
      | Literal.UShort => InternalType.UInt16
      | Literal.Int => InternalType.Int32
      | Literal.UInt => InternalType.UInt32
      | Literal.Long => InternalType.Int64
      | Literal.ULong => InternalType.UInt64
      | Literal.Char => InternalType.Char
      | Literal.String => InternalType.String
      | Literal.Float => InternalType.Single
      | Literal.Double => InternalType.Double
      | Literal.Decimal => InternalType.Decimal
      | Literal.Bool => InternalType.Boolean
      | Literal.Enum (_, tc) => TType.Class (tc, [])
    }
  }

  describe_expression (expr : TExpr) : string
  {
    match (expr) {
      | TExpr.LocalRef (d) =>
        "a reference to local symbol `" + d.name + "'"
      | TExpr.StaticRef (m) =>
        def tyname =
          if (m.DeclaringType == null)
            ""
          else
            m.DeclaringType.FullName + ".";
        "a reference to global symbol `" + tyname + m.Name + "'"
      | TExpr.FieldMember (_, f) =>
        "a reference to field `" + f.Name + "'"
      | TExpr.ConstantObjectRef (m) =>
        "a reference to constant constructor of `" +
        m.DeclaringType.FullName + "'"
      | TExpr.ImplicitValueTypeCtor (t) =>
        "a reference to implicit constructor of `" +
        t.FullName + "'"
      | TExpr.StaticPropertyRef (p)
      | TExpr.PropertyMember (_, p) =>
        "a reference to property `" + p.Name + "'"
      | TExpr.MethodRef (_, m, _) =>
        "a reference to method `" + m.Name + "'"
      | TExpr.TailCall (f, _)
      | TExpr.Call (f, _) =>
        "a function call to " + describe_expression (f)
      | TExpr.SelfTailCall =>
        "self-recursive function call"
      | TExpr.Assign => "an assignment"
      | TExpr.DefValIn => "a value binding"
      | TExpr.DefFunctionsIn => "a function binding"
      | TExpr.Match => "a `match' expression"
      | TExpr.Throw => "a throw expression"
      | TExpr.TryWith => "a try...with expression"
      | TExpr.TryFinally => "a try...finally expression"
      | TExpr.Literal => "a literal value"
      | TExpr.This => "a this pointer reference"
      | TExpr.Base => "a base class reference"
      | TExpr.TypeConversion => "a type conversion (:>)"
      | TExpr.TypeEnforcement => "a type enforcement (:)"
      | TExpr.Sequence => "a sequence"
      | TExpr.Tuple => "a tuple constructor"
      | TExpr.Array => "an array constructor"
      | TExpr.ArrayIndexer => "an array indexer reference"
      | TExpr.TypeOf => "a typeof expression"
      | TExpr.OpCode => "an operator reference"
    }
  }

  is_indexer_property (prop : IProperty) : bool
  {
    def getter = prop.GetGetter ();
    def setter = prop.GetSetter ();
    (getter != null && (getter.GetHeader ().parms matches _ :: _)) ||
    (setter != null && !(setter.GetHeader ().parms matches [_]))
  }

  make_first_class (ctx : CTX, expr : TExpr) : TExpr
  {
    match (expr) {
      | TExpr.MethodRef (obj_ref, mem, _) =>
        match (Tyutil.top_expand (type_of (expr))) {
          | TType.Function (from, _) =>
            def mkparm (_, acc) {
               def t = PT.Name (Util.tmpname ("parm"));
               def (fps, ps) = acc;
               (PT.Fun_parm (expr.loc, PT.Splicable.Name (t), PT.PType.Infer (),
                             Modifiers.Empty) :: fps,
                             PT.PExpr.Ref (expr.loc, t) :: ps)
            };
            def (fps, ps) = List.FoldLeft (Tyutil.fun_args (from), ([], []), mkparm);
            def ptr_name = PT.Name (Util.tmpname ("ptr"));
            def header =
              PT.Fun_header (expr.loc, PT.Splicable.Name (PT.Name (Util.tmpname ("ml"))),
                             PT.PType.Infer (), fps);
            def body = PT.PExpr.Call (PT.PExpr.Member (PT.PExpr.Ref (ptr_name),
                                  PT.Splicable.Name (PT.Name (mem.Name))), ps);
            //def body = <[ $(ptr_name : name) . $mem_name (.. $ps) ]>;
            def lambda = PT.PExpr.Lambda (expr.loc, PT.Function_decl (header, body));
            ty_expr (ctx, PT.PExpr.Sequence ([
                PT.PExpr.Define (false, PT.Splicable.Name (ptr_name),
                          PT.PExpr.Typed (obj_ref)),
                lambda
                ]))
            //ty_expr (ctx, <[ { def $(ptr_name : name) = $(tye : typed);
            //                   $lambda
            //                 } ]>)
          | _ => Util.ice ()
        }
      | TExpr.LocalRef ({kind = LocalValueKind.Function (h, _)}) =>
        h.usage = FunctionUsage.UsedAsFirstClass;
        expr
      | TExpr.PropertyMember (_, prop) when is_indexer_property (prop) =>
        Message.fatal_error ("indexer property `" + prop.Name +
                             "' used as first class value")
      | _ => expr
    }
  }

  public ty_expr (ctx : CTX, expr : PT.PExpr) : TExpr
  {
    def expr = ty_expr_with_no_properties_conversion (ctx, expr);
    def make_getter (obj, prop : IProperty, args) {
      def meth = prop.GetGetter ();
      TExpr.Call (expr.loc, expr.ty,
              TExpr.MethodRef (expr.loc, meth.GetMemType (), obj, meth, false),
              args)
    };
    def make_static_getter (prop : IProperty, args) {
      def meth = prop.GetGetter ();
      TExpr.Call (expr.loc, expr.ty,
              TExpr.StaticRef (expr.loc, meth.GetMemType (), meth),
              args)
    };
    match (expr) {
      | TExpr.PropertyMember (obj, prop) => make_getter (obj, prop, [])
      | TExpr.Call (TExpr.PropertyMember (obj, prop), args) => make_getter (obj, prop, args)
      | TExpr.StaticPropertyRef (prop) => make_static_getter (prop, [])
      | TExpr.Call (TExpr.StaticPropertyRef (prop), args) => make_static_getter (prop, args)
      | expr => expr
    }
  }


  convert_setter_property (_ctx : CTX, expr : TExpr, val : TExpr) : TExpr * TType
  {
    def make_setter (obj, prop : IProperty, args)
    {
      def meth = prop.GetSetter ();
      TExpr.Call (expr.loc, TType.Void (),
              TExpr.MethodRef (expr.loc, meth.GetMemType (), obj, meth, false),
              List.Append (args, [Parm (val)]))
    }

    def make_static_setter (prop : IProperty, args)
    {
      def meth = prop.GetSetter ();
      TExpr.Call (expr.loc, TType.Void (),
              TExpr.StaticRef (expr.loc, meth.GetMemType (), meth),
              List.Append (args, [Parm (val)]))
    }

    expect_type ("assigned value", val, type_of (expr));

    def res =
      match (expr) {
        | TExpr.PropertyMember (obj, prop) =>
          make_setter (obj, prop, [])
        | TExpr.Call (TExpr.PropertyMember (obj, prop), args) =>
          make_setter (obj, prop, args)
        | TExpr.StaticPropertyRef (prop) =>
          make_static_setter (prop, [])
        | TExpr.Call (TExpr.StaticPropertyRef (prop), args) =>
          make_static_setter (prop, args)
        | expr =>
          TExpr.Assign (expr.loc, TType.Void (), expr, val)
      };

    (res, TType.Void ())
  }


  ty_call (ctx : CTX, in_tail_pos : bool, fnc : PT.PExpr, parms : list [PT.PExpr]) : TExpr
  {
    def refout (name, expr) {
      match (expr) {
        | PT.PExpr.ParmByRef (ex)
        | PT.PExpr.ParmOut (ex) =>
          def ex = ty_expr (ctx, ex);
          unless (is_lvalue (ctx, ex, need_ref = true))
            Message.error ("ref/out parameters need lvalue but " +
                           describe_expression (ex) +
                           " was passed");
          def kind =
            match (expr) {
              | PT.PExpr.ParmByRef => ParmKind.Ref
              | _ => ParmKind.Out
            };
          Parm (kind, ex, name)
        | ex =>
          Parm (ParmKind.Normal, ty_expr (ctx, ex), name)
      }
    };
    def fp (p : PT.PExpr) {
      | <[ $(name : name) = $e ]> => refout (name.Id, e)
      | e => refout ("", e)
    };

    def parms = List.Map (parms, fp);
    def fncs = make_value_reference (ctx, fnc, fallback = true);
    def ex = resolve_overloaded_call (ctx, in_tail_pos, fncs, parms);
    match (ex) {
      | TExpr.Call (TExpr.PropertyMember (_, prop), _) when is_indexer_property (prop) =>
        Message.error ("attempt to call an indexer property `" +
                       prop.Name + "'");
      | _ => ()
    };

    ex
  }


  is_lvalue (ctx : CTX, e : TExpr, need_ref : bool) : bool
  {
    match (e) {
      | TExpr.LocalRef (d) => d.is_ref
      | TExpr.StaticRef (m) =>
        match (m.GetKind ()) {
          | MemberKind.Field (f) =>
            f.IsMutable || (ctx.current_fun.name == ".cctor" &&
                            f.DeclaringType.SameAs (ctx.parent_type))
          | MemberKind.Property (p) when !need_ref => p.IsMutable
          | _ => false
        }
      | TExpr.StaticPropertyRef (p) when !need_ref => p.IsMutable
      | TExpr.FieldMember (TExpr.LocalRef ({kind = LocalValueKind.ClosurisedThis}), _)
        when ctx.in_ctor => true
      | TExpr.FieldMember (_, mem) => mem.IsMutable
      | TExpr.PropertyMember (_, p) when !need_ref => p.IsMutable
      | TExpr.Call (TExpr.PropertyMember (_, p), _) when !need_ref => p.IsMutable
      | TExpr.ArrayIndexer => true
      | _ => false
    }
  }

  ty_mkarray (ctx : CTX, rank : int, args : PT.PExpr) : TExpr * TType
  {
    def expr_list_length (e) {
      | <[ [] ]> => 0
      | <[ $_ :: $rest ]> => 1 + expr_list_length (rest)
      | _ => Message.fatal_error ("array initializer must be of form `array [rank] [ [..], .., [..] ]'")
    }

    def expr_list_flatten_and_count (e, remaining) {
      | (<[ [] ]>, 0) => []
      | (_, 0) => Message.fatal_error ("incorrectly structured array initializer");
      | (<[ [] ]>, _) => Message.fatal_error ("incorrectly structured array initializer");
      | (<[ $x :: $xs ]>, n) => x :: expr_list_flatten_and_count (xs, n - 1)
      | _ => Message.fatal_error ("array initializer must be of form `array [rank] [ [..], .., [..] ]'")
    }

    def dimensions (args, remaining_rank)
    {
      | (_, 0) => []
      | (<[ $head :: $_ ]>, n) =>
        expr_list_length (args) :: dimensions (head, n - 1)
      | _ => Message.fatal_error ("array initializer must be of form `array [rank] [ [..], .., [..] ]'")
    }
    /* Flattens the initializers and checks that there are the correct number of them */
    def flatten (args, dims)
    {
        | (elem, []) => [elem]
        | (l, h::t) =>
          def flat = expr_list_flatten_and_count (l, h);
          List.FoldLeft (flat, [], fun (i, a) {List.Concat ([a, flatten (i, t)])})
    }

    def dimensions = dimensions (args, rank);
    def lst = flatten (args, dimensions);
    def dimensions = List.Map (dimensions, fun (x) { TExpr.Literal (Literal.Int (x)) });

    match (lst) {
      | [] => Util.ice ("empty list of initializers")
      | head :: _ =>
        def typed_head = ty_expr (ctx, head);
        def array_type = type_of (typed_head);
        def type_array_initializers (initializers) {
          match (initializers) {
            | [] => []
            | initializer :: rest =>
              def typed_initializer = ty_expr (ctx, initializer);
              expect_type ("array initializer", typed_initializer, array_type);
              typed_initializer :: type_array_initializers (rest)
          }
        };
        (TExpr.Array (type_array_initializers (lst), dimensions), TType.Array (array_type, rank))
    };
  }

  ty_indexer (ctx : CTX, obj : PT.PExpr, args : list [PT.PExpr]) : TExpr * TType
  {
    def typed_objs =
      match (obj) {
        | <[ base ]>
        | <[ this ]> =>
          [ty_expr (ctx, obj)]
        | _ =>
          make_value_reference (ctx, obj, fallback = true);
      };

    match (typed_objs) {
      | TExpr.PropertyMember (_, prop) :: _ when is_indexer_property (prop) =>
        def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });
        def args' = List.Map (typed_args, fun (x) { Parm (x) });
        def ex = resolve_overloaded_call (ctx, false, typed_objs, args');
        (ex, type_of (ex))

      | [typed_obj] =>
        match (Tyutil.top_expand (typed_obj.ty)) {
          | TType.Array (indexer_over_type, rank) =>
            /* indexers over arrays */
            def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });

            mutable args_amount = rank;
            foreach (index in typed_args) {
              expect_type ("indexer type", index, InternalType.Int32);
              --args_amount;
            }
            when (args_amount != 0)
              Message.fatal_error ("wrong number of index parameters");

            (TExpr.ArrayIndexer (indexer_over_type, typed_obj, typed_args),
             indexer_over_type)

          | TType.Class (tc, _) when Option.IsSome (tc.DefaultIndexerName) =>
            /* user-defined indexers */
            def member_name = Option.UnSome (tc.DefaultIndexerName);
            ty_indexer (ctx, <[ $(typed_obj : typed) . $(member_name : dyn) ]>, args)

          | _ =>
            def ty = typed_obj.ty;
            Message.fatal_error ($ "indexer applied to non-indexer type $ty")
        }

      | l =>
        Message.error ("expression is ambiguous:");
        foreach (ex in l) Message.error ("  " + describe_expression (ex));
        throw Recovery ()
    }
  }


