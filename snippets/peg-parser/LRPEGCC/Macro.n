using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;

using LRPEGCC.GrammarCreator;

namespace LRPEGCC
{
  macro Gramar (_rules : Token)
  syntax ("grammar", _rules)
  {
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
      | e is Exception =>
        Message.Error(tb.Location,  $"Exception $e");
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      //assert2(false);
      def grammar = CreateGrammar(typer, tb, startRule, rules);
        
      def compiler = RuleCompiler();
      
      mutable str = "";
      
      def tyParam = 
        match (tb.GetDirectSuperTypes())
        {
          | FixedType.Class(_, [tyParam]) :: _ => <[ $(tyParam : typed) ]>
          | _ => 
            Message.Error(tb.Location,  "Base type of Grammar must have one type parametr.");
            <[ object ]>
            
        };

      foreach (name in grammar.Names)
      {
        def rule          = grammar.GetRule(name);
        rule.UpdateIndecis();
        def body          = compiler.CompileRule(rule);
        
        def resultType : PExpr = // Make type parametr name
          match (rule)
          {
            | Rule.CaptureNamedTerminalSymbol            => <[ Nemerle.Peg.NToken ]>
            | Rule.Capture(argType = RuleType.NType(ty)) => <[ Nemerle.Peg.VToken[$ty] ]>
            | Rule.Capture(argType = argType) as c => 
              Message.Error($"Wrong return type ($argType) in '$(c.name)' rule");
              <[ Nemerle.Peg.NToken ]>
            | _                                          =>
              Message.Error($"Top level rule must be Capture. ($(rule.GetType().Name) $rule)");
              <[ Nemerle.Peg.NToken ]>
          };
        
        def method = <[decl:
          private $(compiler.DecorateRuleName(name) : dyn)(pos : int, result : ref $resultType, text : string) : int
          {
            mutable c : char;
            _ = c; // eliminate wornint "a local value c was never used"
            $body;
          }
        ]>;
        _ = tb.DefineWithSource(method);
        str = str + method.ToString() + "\n" + body.ToString() + "\n\n";
      }
            
      _ = tb.DefineWithSource(<[decl:
        protected override DoParse(text : string) : int * Nemerle.Peg.VToken[$tyParam]
        {
          mutable result : Nemerle.Peg.VToken[$tyParam];
          def pos = $(compiler.DecorateRuleName(grammar.StartRuleName) : dyn)(0, ref result, text);
          
          (pos, result)
        }
      ]>);
      
      
      tb.Define(<[decl:
        public override ToString() : string
        {
          $(str : string);
        }
      ]>);
    }
  }
}
