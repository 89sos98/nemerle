<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle Language Reference</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document presents in semi-formal way syntax and semantics
        of the Nemerle language. It is not meant to be a tutorial.
      </p>
      <p>
        We often refer to <tt>.NET</tt> terminology [FIXME: reference it].
      </p>
    </body>
  </section>


  <section id="lexical">
    <title>Lexical Conventions</title>
    <body>
      <p>
        Programs are written using the Unicode character set.  Every
        Nemerle source file is reduced to a sequence of lexical units
        (tokens).
      </p>
    </body>
    <subsection id="tokens">
      <title>Tokens</title>
      <body>
        <p>
	  There are five classes of lexical tokens: 
        </p>
        <ul>
          <li>identifiers</li>
          <li>type variables</li>
          <li>keywords</li>
          <li>literals</li>
          <li>blanks</li>
        </ul>
<code>
(* A comment. *)
// Also a comment

foo               // identifier
foo_bar foo' foo3 // other identifiers
'a                // type variable 
10                // integer literal
0xff              // hexadecimal integer literal
0o666             // octal integer literal
0b101             // binary integer literal
'a'               // character literal
'\n'              // also a character literal
"foo\nbar"        // string literal
@"x\n"            // same as "x\\n"
@if               // keyword used as identifier
</code>
      </body>
    </subsection>
    <subsection id="blanks">
      <title>Blanks</title>
      <body>
        <p>
	  Spaces, vertical, and horizontal tabulation characters,
	  new-page, and new-line characters, and comments (called blanks
	  altogether) are discarded, but can separate other lexical tokens.
	</p>
        <p>
	  A traditional comment begin with <tt>(*</tt>, and end with
	  <tt>*)</tt>.  A end-of-line comment begin with <tt>//</tt>,
	  and end with line terminator (ASCII LF character).
	</p>
      </body>
    </subsection>
    <subsection id="type-variables">
      <title>Type variables</title>
      <body>
        <p>
          Type variables start with apostrophe (<tt>'</tt>) and consists of
          characters allowed in identifiers, but cannot contain apostrophe.
	</p>
      </body>
    </subsection>
    <subsection id="identifiers">
      <title>Identifiers</title>
      <body>
        <p>
	  Ordinary identifiers consist of letters, digits, underscores
	  and apostrophe, but cannot begin with a digit nor an apostrophe.
	  Identifiers may be quoted with the <tt>@</tt> character, which
	  is stripped. It removes any lexical and syntactic meaning from
	  the following string of characters until blank, thus enabling
	  programmer to use keywords as identifiers.
	</p>
	<p>
	  Symbolic identifiers consist of following characters: 
          <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>@</tt>,
          <tt>^</tt>, <tt>|</tt>, <tt>&amp;</tt>, <tt>+</tt>, <tt>-</tt>,
          <tt>*</tt>, <tt>/</tt>, <tt>$</tt>, <tt>%</tt>, <tt>!</tt>,
          <tt>?</tt>, <tt>~</tt>, <tt>.</tt>, <tt>:</tt>, <tt>#</tt>.
          Symbolic identifiers may be used, wherever ordinary
	  identifiers may, but have additional property of being used
	  as infix operators.
	</p>
      </body>
    </subsection>
    <subsection id="keywords">
      <title>Keywords</title>
      <body>
        <p>
	  Following identifiers are used as keywords, and may not be
	  used in any other context unquoted:
          <tt>_</tt>, <tt>abstract</tt>, <tt>and</tt>, <tt>array</tt>,
          <tt>as</tt>, <tt>base</tt>, <tt>class</tt>, <tt>const</tt>,
          <tt>def</tt>, <tt>else</tt>, <tt>ensure</tt>, <tt>enum</tt>,
          <tt>extends</tt>, <tt>extern</tt>, <tt>finally</tt>,
          <tt>fun</tt>, <tt>if</tt>, <tt>implements</tt>,
          <tt>in</tt>, <tt>interface</tt>, <tt>internal</tt>,
          <tt>let</tt>, <tt>macro</tt>, <tt>match</tt>,
          <tt>module</tt>, <tt>mutable</tt>, <tt>namespace</tt>,
          <tt>new</tt>, <tt>null</tt>, <tt>open</tt>, <tt>out</tt>,
          <tt>private</tt>, <tt>protected</tt>, <tt>public</tt>,
          <tt>raise</tt>, <tt>ref</tt>, <tt>require</tt>, <tt>sealed</tt>,
          <tt>static</tt>, <tt>struct</tt>, <tt>then</tt>, <tt>this</tt>,
          <tt>try</tt>, <tt>tymatch</tt>, <tt>type</tt>, <tt>variant</tt>,
          <tt>void</tt>, <tt>volatile</tt>, <tt>where</tt>, <tt>with</tt>.
        </p>
        <p>
          Following infix identifiers are keywords:
          <tt>=</tt>, <tt>$</tt>, <tt>?</tt>, <tt>|</tt>, <tt>&lt;-</tt>,
          <tt>-&gt;</tt>, <tt>=&gt;</tt>, <tt>&lt;[</tt>, <tt>]></tt>,
          <tt>&amp;&amp;</tt>, <tt>||</tt>.
	</p>
      </body>
    </subsection>
    <subsection id="literals">
      <title>Literals</title>
      <body>
        <p>
          There are few kinds of literals:
	</p>
        <ul>
          <li>
            String literals, enclosed in <tt>""</tt>. Compiler processes
            backslash escapes much like in C#.
          </li>
          <li>
            Raw string literals, written like ordinary string literals,
            but prefixed with <tt>@</tt>. Escapes are not processed.
          </li>
          <li>
            Character literals, enclosed in <tt>'</tt>. Escapes are
            processed.
          </li>
          <li>
            Integer literals, possibly prefixed with <tt>0x</tt>,
            <tt>0o</tt> or <tt>0b</tt> to donate hexadecimal, octal or
            binary encoding respectively.
          </li>
        </ul>
      </body>
    </subsection>
  </section>


  <section id="compilation-units">
    <title>Compilation units</title>
    <body>
      <rule name="compilation_unit">
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
      </rule>
      <p>
        Nemerle program consists of one or more compilation
        units. Compilation units are files with <tt>.n</tt> suffix.
        Compilation unit consists of namespace-related declarations and
        types within them.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="open"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Add specified namespace (which can be type or namespace name,
        unlike in C#) to symbol search path.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <special-terminal name="IDENTIFIER"/>
        <terminal name="="/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Define alias for namespace. After <tt>namespace Foo =
        Bar.Baz;</tt> any reference to <tt>Foo.bar</tt> will be expanded
        to <tt>Bar.Baz.bar</tt>.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name="{"/>
        <repeat>
          <non-terminal name="top_declaration"/>
        </repeat>
        <terminal name="}"/>
      </rule>
      <p>
        Put declarations within specified namespace. Namespaces can
        be nested.
      </p>
      <rule name="toplevel_declaration">
        <non-terminal name="type_declaration"/>
      </rule>
      <p>
        Define new type.
      </p>
    </body>
  </section>


  <section id="misc">
    <title>Stuff that doesn't fit anywhere else</title>
    <body>
      <rule name="identifier_or_dummy">
        <special-terminal name="IDENTIFIER"/>
      </rule>
      <rule name="identifier_or_dummy">
        <terminal name="_"/>
      </rule>
      <p>
        In several places it is possible to use keyword <tt>_</tt> to donate intent
        to ignore parameter. Semantics of <tt>_</tt> in such places is to generate
        new temporary name.
      </p>
      <rule name="qualified_identifier">
        <special-terminal name="IDENTIFIER"/>
        <repeat>
          <terminal name="."/>
          <special-terminal name="IDENTIFIER"/>
        </repeat>
      </rule>
      <p>
        Identifiers can be often qualified with namespaces.
      </p>
    </body>
  </section>


  <section id="types">
    <title>Types</title>
    <body>
      <p>
        Types are defined at the top level, within namespaces or within
        other types. Defining type within namespace affects its name --
        it's prefixed with namespace name. Defining type with other type
        additionally affects accessibility of type. The rules here are
        the same as in .NET.
      </p>
      <rule name="type_header">
        <special-terminal name="IDENTIFIER"/>
        <optional>
          <non-terminal name="type_parameters"/>
        </optional>
        <optional>
          <terminal name="extends"/>
          <non-terminal name="type"/>
        </optional>
        <optional>
          <terminal name="implements"/>
          <non-terminal name="type"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="type"/>
          </repeat>
        </optional>
      </rule>
      <rule name="type_parameters">
        <terminal name="("/>
        <special-terminal name="TYPE_VARIABLE"/>
        <repeat>
          <terminal name=","/>
          <special-terminal name="TYPE_VARIABLE"/>
        </repeat>
        <terminal name=")"/>
        <optional>
          <non-terminal name="where_constraints"/>
        </optional>
      </rule>
      <rule name="where_constraints">
        <terminal name="where"/>
        <special-terminal name="TYPE_VARIABLE"/>
        <terminal name=":&gt;"/>
        <non-terminal name="type"/>
        <repeat>
          <terminal name=","/>
          <special-terminal name="TYPE_VARIABLE"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
        </repeat>
      </rule>
    </body>
    <subsection id="type-alias">
      <title>Type alias</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="extern-type">
      <title>External type declaration</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="interface-def">
      <title>Interface definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="interface"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="interface_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="class-def">
      <title>Class definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="class"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="module-def">
      <title>Module definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="module"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="variant-def">
      <title>Variant definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="variant"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="variant_option"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
        <rule name="variant_option">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <terminal name="{"/>
            <repeat>
              <non-terminal name="field_def"/>
            </repeat>
            <terminal name="}"/>
          </optional>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="attributes">
    <title>Attributes</title>
    <body>
      <p>
        The semantics of attributes is the same as in C#.
      </p>
      <rule name="attributes">
        <repeat>
          <non-terminal name="attribute"/>
        </repeat>
      </rule>
      <rule name="attribute">
        <terminal name="new"/>
      </rule>
      <rule name="attribute">
        <terminal name="public"/>
      </rule>
      <rule name="attribute">
        <terminal name="protected"/>
      </rule>
      <rule name="attribute">
        <terminal name="internal"/>
      </rule>
      <rule name="attribute">
        <terminal name="private"/>
      </rule>
      <rule name="attribute">
        <terminal name="abstract"/>
      </rule>
      <rule name="attribute">
        <terminal name="sealed"/>
      </rule>
      <rule name="attribute">
        <terminal name="static"/>
      </rule>
    </body>
  </section>


  <section id="type-members">
    <title>Declarations within types</title>
    <body>
      <rule name="type_member">
        <non-terminal name="field_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="method_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="type_declaration"/>
      </rule>
    </body>
    <subsection id="field-def">
      <title>Field definition</title>
      <body>
        <rule name="field_definition">
          <non-terminal name="attributes"/>
          <optional>
            <terminal name="mutable"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
      </body>
    </subsection>
    <subsection id="interface-mem-def">
      <title>Interface member</title>
      <body>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <non-terminal name="method_header"/>
          <terminal name=";"/>
        </rule>
      </body>
    </subsection>
    <subsection id="method-def">
      <title>Method definition</title>
      <body>
        <rule name="method_definition">
          <non-terminal name="attributes"/>
          <non-terminal name="method_header"/>
          <non-terminal name="method_body"/>
        </rule>
      </body>
    </subsection>
    <subsection id="method-head">
      <title>Method header</title>
      <body>
        <rule name="method_type_parameters">
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
        </rule>
        <rule name="method_header">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <non-terminal name="method_implements"/>
        </rule>
        <rule name="method_header">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="this"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
        </rule>
        <rule name="method_implements">
          <optional>
            <terminal name="implements"/>
            <non-terminal name="qualified_identifier"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="qualified_identifier"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-parms">
      <title>Method parameters</title>
      <body>
        <rule name="method_parameter">
          <non-terminal name="identifier_or_dummy"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
        </rule>
        <rule name="method_parameters">
          <optional>
            <non-terminal name="method_parameters"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="method_parameter"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-body">
      <title>Method body</title>
      <body>
        <rule name="method_body">
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <rule name="method_body">
          <non-terminal name="block"/>
        </rule>
      </body>
    </subsection>
  </section>


  <section id="type-expressions">
    <title>Type expressions</title>
    <body>
      <rule name="primary_type">
        <non-terminal name="qualified_identifier"/>
        <optional>
          <terminal name="("/>
          <non-terminal name="type"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="type"/>
          </repeat>
          <terminal name=")"/>
        </optional>
      </rule>
      <rule name="primary_type">
        <special-terminal name="TYPE_VARIABLE"/>
      </rule>
      <rule name="primary_type">
        <terminal name="("/>
        <non-terminal name="type"/>
        <terminal name=")"/>
      </rule>
      <rule name="primary_type">
        <terminal name="void"/>
      </rule>
      <rule name="primary_type">
        <terminal name="ref"/>
        <non-terminal name="primary_type"/>
      </rule>
      <rule name="primary_type">
        <terminal name="out"/>
        <non-terminal name="primary_type"/>
      </rule>
      <rule name="type">
        <non-terminal name="primary_type"/>
        <repeat>
          <terminal name="*"/>
          <non-terminal name="primary_type"/>
        </repeat>
      </rule>
      <rule name="type">
        <non-terminal name="primary_type"/>
        <repeat>
          <terminal name="-&gt;"/>
          <non-terminal name="primary_type"/>
        </repeat>
      </rule>
    </body>
  </section>


  <section id="literal-exprs">
    <title>Literal expressions</title>
    <body>
      <p>
        These are used in expressions and patterns.
      </p>
    </body>
    <subsection id="boolean-lit">
      <title>Boolean</title>
      <body>
        <rule name="literal">
          <terminal name="true"/>
        </rule>
        <rule name="literal">
          <terminal name="false"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="null-lit">
      <title>Null</title>
      <body>
        <rule name="literal">
          <terminal name="null"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="void-lit">
      <title>Void</title>
      <body>
        <rule name="literal">
          <terminal name="("/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="string-lit">
      <title>String</title>
      <body>
        <rule name="literal">
          <special-terminal name="STRING_LITERAL"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="number">
      <title>Number</title>
      <body>
        <rule name="literal">
          <special-terminal name="NUMBER_LITERAL"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="character">
      <title>Character</title>
      <body>
        <rule name="literal">
          <special-terminal name="CHARACTER_LITERAL"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="prim-expressions">
    <title>Primary expressions</title>
    <body>
      <p>
        Primary expressions is grammar category referring to expressions
        that have closed structure and are otherwise simple. Primary
        expressions and plain expressions do not differ at the semantic
        level.
      </p>
    </body>
    <subsection id="literal-ref">
      <title>Literal expression</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="literal"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="variable-ref">
      <title>Variable reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="qualified_identifier"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="this-ref">
      <title>this pointer reference</title>
      <body>
        <rule name="primary_expr">
          <terminal name="this"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="grouping">
      <title>Grouping expression</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="type-cast">
      <title>Type cast</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="type-enf">
      <title>Type enforcement</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="member-ref">
      <title>Member reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="primary_expr"/>
          <terminal name="."/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ctor">
      <title>Tuple constructor</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <repeat-plus>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat-plus>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="indexer-ref">
      <title>Indexer reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="expr"/>
          <terminal name="["/>
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>

  
  <section id="expressions">
    <title>Expressions</title>
    <body>
       <p>
       </p>
    </body>
    <subsection id="prim-expr-ref">
      <title>Primary expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="call">
      <title>Function call</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="("/>
          <optional>
            <non-terminal name="parameter"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="parameter"/>
            </repeat>
          </optional>
          <terminal name=")"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="assign">
      <title>Assignment</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="match-expr">
      <title>Match expression</title>
      <body>
        <rule name="expr">
          <terminal name="match"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="raise-expr">
      <title>Raise expression</title>
      <body>
        <rule name="expr">
          <terminal name="raise"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-with">
      <title>Try..with expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="with"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="try_with_handler"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="try_with_handler"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-finally">
      <title>Try..finally expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="finally"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="unary-op">
      <title>Unary operator application</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="binary-op">
      <title>Binary operator application</title>
      <body>
        <rule name="expr">
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="block-ref">
      <title>Block expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="block"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="array-ctor">
      <title>Array constructor</title>
      <body>
        <rule name="expr">
          <terminal name="array"/>
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="expr"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="value-def">
      <title>Value definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="identifier_or_dummy"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="tuple_pattern"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="local-fun-def">
      <title>Local function definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="method_header"/>
          <non-terminal name="block"/>
          <repeat>
            <terminal name="and"/>
            <non-terminal name="method_header"/>
            <non-terminal name="block"/>
          </repeat>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="mutable-def">
      <title>Mutable value definition</title>
      <body>
        <rule name="expr">
          <terminal name="mutable"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>

    <!-- expressions that are (or in principle can be) macros start here -->
    <subsection id="if-expr">
      <title>Conditional expression</title>
      <body>
        <rule name="expr">
          <terminal name="if"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
          <terminal name="else"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="while-expr">
      <title>While loop</title>
      <body>
        <rule name="expr">
          <terminal name="while"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="when-expr">
      <title>When expression</title>
      <body>
        <rule name="expr">
          <terminal name="when"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="unless-expr">
      <title>Unless expression</title>
      <body>
        <rule name="expr">
          <terminal name="unless"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="lambda-expr">
      <title>Lambda expression</title>
      <body>
        <rule name="expr">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="fun"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="list-expr">
      <title>List constructor</title>
      <body>
        <rule name="expr">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="expr"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="expression-helpers">
    <title>Expression helpers</title>
    <body>
      <p>
        This section describes some constructs used in Expressions
        section.
      </p>
    </body>
    <subsection id="sequence">
      <title>Sequence</title>
      <body>
        <rule name="sequence">
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=";"/>
            <non-terminal name="expr"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="block">
      <title>Block</title>
      <body>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="sequence"/>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-with-handler">
      <title>Try..with handler</title>
      <body>
        <rule name="try_with_handler">
          <non-terminal name="identifier_or_dummy"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name="=&gt;"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="fun-parm">
      <title>Function parameter</title>
      <body>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="match-case">
      <title>Match case</title>
      <body>
        <rule name="guarded_pattern">
          <non-terminal name="pattern"/>
          <optional>
            <terminal name="when"/>
            <non-terminal name="expr"/>
          </optional>
        </rule>
        <p>
        </p>
        <rule name="match_case">
          <non-terminal name="guarded_pattern"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="guarded_pattern"/>
          </repeat>
          <terminal name="=&gt;"/>
          <non-terminal name="sequence"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
  </section>


  <section id="patterns">
    <title>Patterns</title>
    <body>
      <rule name="pattern">
        <special-terminal name="IDENTIFIER"/>
      </rule>
      <rule name="pattern">
        <non-terminal name="qualified_identifier"/>
        <optional>
          <non-terminal name="pattern"/>
        </optional>
      </rule>
      <rule name="pattern">
        <terminal name="_"/>
      </rule>
      <rule name="pattern">
        <terminal name="{"/>
        <special-terminal name="IDENTIFIER"/>
        <terminal name="="/>
        <non-terminal name="pattern"/>
        <repeat>
          <terminal name=";"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="pattern"/>
        </repeat>
        <optional>
          <terminal name=";"/>
        </optional>
        <terminal name="}"/>
      </rule>
      <rule name="pattern">
        <non-terminal name="tuple_pattern"/>
      </rule>
      <rule name="pattern">
        <terminal name="("/>
        <non-terminal name="pattern"/>
        <terminal name=")"/>
      </rule>
      <rule name="pattern">
        <terminal name="("/>
        <non-terminal name="pattern"/>
        <terminal name=")"/>
        <terminal name="as"/>
        <special-terminal name="IDENTIFIER"/>
      </rule>
      <rule name="pattern">
        <non-terminal name="pattern"/>
        <terminal name="::"/>
        <non-terminal name="pattern"/>
      </rule>
      <rule name="pattern">
        <terminal name="["/>
        <optional>
          <repeat>
            <non-terminal name="pattern"/>
            <terminal name=";"/>
          </repeat>
          <non-terminal name="pattern"/>
          <optional>
            <terminal name=";"/>
          </optional>
        </optional>
        <terminal name="]"/>
      </rule>
      <rule name="pattern">
        <special-terminal name="STRING_LITERAL"/>
      </rule>
      <rule name="pattern">
        <special-terminal name="NUMBER_LITERAL"/>
      </rule>
      <rule name="pattern">
        <special-terminal name="CHARACTER_LITERAL"/>
      </rule>
      <rule name="pattern">
        <terminal name="true"/>
      </rule>
      <rule name="pattern">
        <terminal name="false"/>
      </rule>
      <rule name="tuple_pattern">
        <terminal name="("/>
        <non-terminal name="pattern"/>
        <repeat-plus>
          <terminal name=","/>
          <non-terminal name="pattern"/>
        </repeat-plus>
        <terminal name=")"/>
      </rule>
    </body>
  </section>


  <section id="macros">
    <title>Macros</title>
    <body>
      <p>
        Please refer to <link>macros.html</link> for now.
      </p>
    </body>
  </section>


    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
