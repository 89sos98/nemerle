/*
 * Copyright (c) 2005 Kamil Skalski <nazgul at nemerle.org>
 * Copyright (c) 2005-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


using System;
using System.IO;
using System.Collections;
using System.Reflection;

using Microsoft.Build.Framework;
using Microsoft.Build.Tasks;
using Microsoft.Build.Utilities;
using Microsoft.Win32;

using Nemerle.Utility;

[assembly: AssemblyVersionFromSVN ("0.9.4.SVN")]

namespace Nemerle.Tools.MSBuildTask
{
  [Record]
  class p {
    public a : string;
    public b : int;
    public c : int;
    public d : int;
    public e : int;
  }

  public class Ncc : ManagedCompiler
  {
    protected override ToolName : string
    {
      get { "ncc.exe"; }
    }

    private static FindExecutable(toolName : string) : string
    {
      def my_file = Uri(typeof(Ncc).Assembly.CodeBase).LocalPath;
      def ncc_file = Path.Combine (Path.GetDirectoryName(my_file), toolName);

      if (File.Exists(ncc_file))
      {
        // The tool found in the same folder.
        //
        ncc_file;
      }
      else
      {
        // Query the shell association.
        //

        def regKey = Registry.LocalMachine.OpenSubKey(
            $@"SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\$toolName");

        if (regKey != null)
        {
           // The tool is registered with the Shell API.
           //
           regKey.GetValue(null) :> string;
        }
        else
        {
          // Return the tool name itself.
          // The environment will search common paths for the tool.
          //
          toolName;
        }
      }
    }
    
    protected override GenerateFullPathToTool () : string
    {
      FindExecutable(ToolName);
    } 
  
    protected override AddResponseFileCommands(commandLine : CommandLineBuilderExtension) : void
    {
      commandLine.AppendSwitch ("/no-color");
      commandLine.AppendSwitchIfNotNull("/lib:", base.AdditionalLibPaths, ",");
      commandLine.AppendSwitchIfNotNull("/nowarn:", this.DisabledWarnings, ",");
      when (NoStdLib)
        commandLine.AppendSwitch("/no-stdlib");
      when (NoStdMacros)
        commandLine.AppendSwitch("/no-stdmacros");
      when (!GreedyReferences)
        commandLine.AppendSwitch("/greedy-references:-");
      when (WarningLevel != 4)
        commandLine.AppendSwitchIfNotNull("/warn:", WarningLevel.ToString());
      when (IndentationSyntax)
        commandLine.AppendSwitch("/indentation-syntax");
      commandLine.AppendSwitchIfNotNull("/doc:", this.DocumentationFile);
      commandLine.AppendSwitchUnquotedIfNotNull("/define:", base.DefineConstants);

      Bag ["Optimize"] = null; // prevent standard handling by ManagedCompiler      
      
      base.AddResponseFileCommands(commandLine);

      when (base.ResponseFiles != null)
      {
        def items = base.ResponseFiles;
        foreach (it in items)
          commandLine.AppendSwitchIfNotNull("/fromfile:", it.ItemSpec);
      }
      
      when (base.References != null)
      {
        def items = base.References;
        foreach (it in items)
          commandLine.AppendSwitchIfNotNull("/ref:", it.ItemSpec);
      }
      
    }

    protected override LogEventsFromTextOutput(singleLine : string, _ : MessageImportance) : void
    {
      // System.Diagnostics.Trace.Assert(false);

      def get_location (before) : p {
        def str = singleLine.Substring (0, singleLine.IndexOf (before));
        if (string.IsNullOrEmpty (str)) p(null, 0,0,0,0)
        else {
          def parts = str.Split (':');
          match (parts.Length) {
            | 2 with file = parts[0] => p(Path.GetFullPath(file), 0, 0, 0, 0)
            | 4 => p(Path.GetFullPath(parts[0]), int.Parse (parts[1]), int.Parse (parts[2]), int.Parse (parts[1]), int.Parse (parts[2]))
            | 6 => p(Path.GetFullPath(parts[0]), int.Parse (parts[1]), int.Parse (parts[2]), int.Parse (parts[3]), int.Parse (parts[4]))
            | _ => p(null, 0,0,0,0)
          }
        }
      }
 
      def tryReport(tagStr, func)
      {
        def index = singleLine.IndexOf (tagStr);
        if (index != -1)
        {
          def (file, l1, c1, l2, c2) = get_location (tagStr);
          func (file, l1, c1, l2, c2, singleLine.Substring (index + if (tagStr == "hint:") 0 else tagStr.Length + 1));
          true
        }
        else false
      }

      def logError  (file, l1, c1, l2, c2, msg) { Log.LogError   (null, null, null, file, l1, c1, l2, c2, msg) }
      def logWarning(file, l1, c1, l2, c2, msg) { Log.LogWarning (null, null, null, file, l1, c1, l2, c2, msg) }

      _ = tryReport ("error:", logError) || tryReport ("warning:", logWarning)
       || tryReport ("debug:", logError) || tryReport ("hint:",    logWarning)
       || Log.LogMessageFromText(singleLine, MessageImportance.High);
    }

    protected override GetResponseFileSwitch(responseFilePath : string) : string
    {
      "/from-file:\"" + responseFilePath + "\"";
    }

    /*protected override LogToolCommand(message : string) : void
    {
      _ = Log.LogMessageFromText("Command:", MessageImportance.Low);
      _ = Log.LogMessageFromText(message, MessageImportance.Normal);
    }*/

    [Accessor (flags = WantSetter)]
    mutable _disabled_warnings : array [string];

    [Accessor (flags = WantSetter)]
    mutable _documentation_file : string;

    [Accessor (flags = WantSetter)]
    mutable _no_std_lib : bool = false;

    [Accessor (flags = WantSetter)]
    mutable _no_std_macros : bool = false;

    [Accessor (flags = WantSetter)]
    mutable _warning_level : int = 4;

    [Accessor (flags = WantSetter)]
    mutable _warnings_as_errors : bool;

    [Accessor (flags = WantSetter)]
    mutable _greedy_references : bool = true;

    [Accessor (flags = WantSetter)]
    mutable _indentation_syntax : bool = false;

  }
}
