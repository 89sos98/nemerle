/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections 
{ 
  /**
   * Exception throws by queue service function where queue is empty.
   */
  class EmptyQueue extends System.Exception 
  {
    public this () {}
  }


  /**
   * Class representing first-in-first-out queue.
   * n operations of inserting/takeing should take time O(n)
   */
  class Queue <'a> 
    implements ICollection<'a>
  {
    /** first part of queue */
    mutable first : list <'a>;
    /** second part of queue */
    mutable last  : list <'a>;

    /** Creates new empty queue. */
    public this () {
      this.first <- [];
      this.last  <- [];
    }


    /** Ensures that if there are any elements in the queue, then the first list is not empty. */
    private move () : void {
      match (this.first) {
        | [] => this.first <- List.Rev (this.last)
        | _  => ()
      }
    }

    /**
     * Appends element at the end of queue.
     */
    public Add (x : 'a) : void 
      {
        this.last <- x :: this.last;
      }
     
    /**
     * Alias for Add(x).
     */
    public Push (x : 'a) : void {
      this.Add (x)
    }
     
    /**
     * Returns first element from the queue, removeing it, throws EmptyQueue exception if none found.
     */
    public Take () : 'a {
      this.move ();
      match (this.first) {
        | x :: xs => 
          this.first <- xs;
          x
        | [] => throw EmptyQueue ()
      }
    }

    /**
     * Alias for Take().
     */
    public Pop () : 'a {
      this.Take ()
    }

    /**
     * Returns first element from the queue, without removeing it.
     * Throws EmptyQueue exception if none found.
     */
    public Peek () : 'a {
      this.move ();
      match (this.first) {
        | x :: _ => x
        | [] => throw EmptyCollection ("Nemerle.Collections.Queue")
      }
    }

    /**
     * Alias for Peek().
     */
    public Top () : 'a {
      this.Peek ()
    }

    /** 
     * Returns some element from the queue, implements ICollection.First.
     */
    public First () : option<'a> {
      this.move ();
      match (this.first) {
        | x :: _ => Some(x)
        | [] => None ()
      }
    }

    /**
     * Clears the queue (removeing all the elements from the queue).
     */
    public Clear () : void {
      this.first <- [];
      this.last  <- [];
    }

    /**
     * Creates new queue with the same elements as this one. 
     * New queue is independent, i.e. changes in this queue will
     * not effect the new one.
     */
    public Copy () : Queue <'a> {
      def q =  Queue();
      q.first <- List.Copy(this.first);
      q.last  <- List.Copy(this.last);
      q
    }

    /**
     * Checks if queue is empty.
     */
    public IsEmpty () : bool {
      this.move ();
      match (this.first) {
        | [] => true
        | _  => false
      }
    }

    /**
     * Returns number of elements in the queue.
     */
    public Length () : int {
      List.Length (this.first) + List.Length (this.last)
    }

    /**
     * Alias for Length().
     */
    public Size () : int { 
      Length () 
    }

      
    /**
     * Calls supplied function for all elements of queue.
     */
    public Iter (f : 'a -> void) : void {
      this.move ();
      List.Iter (f, this.first);
    }

    /**
     * Folds elements of queue with supplied function and initial value.
     */
    public 'b Fold (f : 'b * 'a -> 'b, x : 'b) : 'b {
      this.move ();
      List.FoldLeft (f, x, this.first)
    }

    /**
     * Transfers all elements from queue q to this queue.
     */
    public Transfer (q : Queue<'a>) : void {
      first <- List.Append(first,List.Rev(last));
      last  <- List.Rev(List.Append(q.first,q.last));
      q.first <- [];
      q.last  <- [];
    }

    /**
     * Checks if supplied element is member of this queue.
     */
    public Member (x : 'a) : bool {
      List.Memq(x,this.first) || List.Memq(x,this.last)
    }

    /**
     * Removes supplied element from this queue.
     */
    public Remove (x : 'a) : void{
      this.first <- List.Remove(x,this.first);
      this.last <- List.Remove(x,this.last);
      move ()
    }

    /**
     * Checks if all elements of queue satisfy predicate.
     */
    public ForAll (f : 'a -> bool) : bool {
      List.ForAll (f,this.first) && List.ForAll (f,this.last)
    }

    /**
     * Checks if there exists member of this queue that satisfy predicate.
     */
    public Exists (f : 'a -> bool) : bool {
      List.Exists (f,this.first) || List.Exists (f,this.last)
    }

    /**
     * Removes from queue all elements that do not satisfy predicate.
     */
    public Filter (f : 'a -> bool) : void {
      this.first <- List.Filter(f,this.first);
      this.last  <- List.Filter(f,this.last);
      move ()
    }

    /**
     * Maps queue to new queue useing supplied function.
     * New queue is independent.
     */
    public 'b Map (f : 'a -> 'b) : ICollection <'b> {
      def q = Queue ();
      q.first <- List.Map(f,this.first);
      q.last  <- List.Map(f,this.last);
      q
    }

    /**
     * Partitions this queue into two queues: first one with elements that satisfy predicate,
     * second one with other ones.
     */
    public Partition (f : 'a -> bool): Queue<'a> * Queue<'a> {
      def sat    = Queue ();
      def nonsat = Queue ();
      def (s,n) = List.Partition(f,this.first);
      sat.first <- s; 
      nonsat.first <- n;
      def (s,n) = List.Partition(f,this.last);
      sat.last <- s;
      nonsat.last <- n;
      sat.move ();
      nonsat.move ();
      (sat,nonsat)
    }

    /**
     * Returns enumerator for elements of this queue.
     */
    public GetEnumerator() : IEnumerator<'a> {
      ListEnumerator(List.Append(this.first,this.last))
    }

  } /* end of class Queue */
} /* end of namespace */

