/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections
{
  /**
   * This is a wrapper collection for Nemerle lists. 
   */
  public class LinkedList <'a> : ICollection <'a>
  {
    /* -- PUBLIC CONSTRUCTORS ----------------------------------------------- */
    
    public this ()
    {
      m_list = []
    }

    public this (some_list : list <'a>)
    {
      m_list = some_list
    }


    /* -- PUBLIC PROPERTIES ------------------------------------------------- */
    
    public IsEmpty : bool
    {
      get
      {
        List.IsEmpty (m_list)
      }
    }

    public Count : int
    {
      get
      {
        List.Length (m_list)
      }
    }


    /* -- PUBLIC METHODS ---------------------------------------------------- */
    
    public override ToString () : string
    {
      m_list.ToString ()
    }

    public override Equals (o : System.Object) : bool
    {
      m_list.Equals (o)
    }
      
    public Add (x : 'a) : void
    {
      m_list = x :: m_list
    }
      
    public Remove (x : 'a) : void
    {
      m_list = List.Remove (m_list, x)
    }

    public First () : option <'a>
    {
      match (m_list) {
        | x :: _ => Some (x)
        | _ => None ()
      }
    }
      
    public Clear () : void
    {
      m_list = []
    }
     
    public Contains (x : 'a) : bool
    {
      List.Member (m_list, x)
    }
      
    public Clone () : ICollection <'a>
    {
      def li = LinkedList ();
      li.m_list = List.Copy (m_list);
      li
    }

    
    /**
     * Reverses the order of the elements in this list
     */
    public Reverse () : void
    {
      m_list = List.Rev (m_list)
    }

    
    public Fold <'b> (f : 'a * 'b -> 'b, x : 'b) : 'b
    {
      List.FoldLeft (m_list, x, f)
    }
      
    public Map <'b>  (f : 'a -> 'b) : ICollection<'b>
    {
      def li = LinkedList ();
      li.m_list = List.Map (m_list, f);
      li
    }

    public Iter (f : 'a -> void) : void
    {
      List.Iter (m_list, f)
    }
    
    public ForAll (f : 'a -> bool) : bool
    {
      List.ForAll (m_list, f)
    }

    public Exists (f : 'a -> bool) : bool
    {
      List.Exists (m_list, f)
    }

    public Filter (f : 'a -> bool) : void
    {
      m_list = List.Filter (m_list, f)
    }
    
    public Partition (f : 'a -> bool) : ICollection <'a> * ICollection <'a>
    {
      def (s, n) = List.Partition (m_list, f);
      (LinkedList (s), LinkedList (n))
    }
      
    public GetEnumerator () : IEnumerator <'a>
    {
      ListEnumerator (m_list)
    }


    /* -- PRIVATE FIELDS ---------------------------------------------------- */
    
    private mutable m_list : list <'a>;
  }
}
