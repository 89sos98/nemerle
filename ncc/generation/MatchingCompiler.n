/*
 * Copyright (c) 2004, 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Matching
 */
namespace Nemerle.Compiler 
{
  using Nemerle.Collections;

  using Nemerle.Compiler.CompileTypedTree;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Compiler.MatchingCompiler;

  using System.Reflection;
  using System.Reflection.Emit;


  /**
   * A match effect
   */
  class MatchEffect
  {
    public this (index : int, effect : TExpr)
    {
      m_index = index;
      m_effect = effect;
    }
    
    [Nemerle.Assertions.Ensures (value >= 0)]
    public GetIndex () : int
    {
      m_index
    }
    
    public GetEffect () :TExpr
    {
      m_effect
    }

#if EXTRAMATCHINGDEBUG    
    public Dump () : void
    {
      Message.Debug ("MatchEffect::Dump: " + m_index.ToString ());
    }
#endif 
            
    private mutable m_index : int;
    private mutable m_effect :TExpr;
  }
  
  
  /**
   * Top-level pattern with a guard and effect index
   */
  class MatchClause
  {
    public this (pattern : Pattern, guard : TExpr, effect : int)
    {
      m_pattern = pattern;

      if (guard_is_always_true (guard))
        m_guard = None ()
      else
        m_guard = Some (guard);

      m_effect = effect;
    }
        
    public GetPattern () : Pattern
    {
      m_pattern
    }
    
    public GetEffect () : int
    {
      m_effect
    }      

    private guard_is_always_true (guard : TExpr) : bool
    {
      match (guard) {
        | TExpr.Literal (Literal.Bool (true)) => 
          true
          
        | _ =>
          false
      }
    }

    public Dump () : void
    {
      def dump_pattern (pattern : Pattern) 
      {      
        match (pattern) {
          | Pattern.Wildcard => 
            "Wildcard"

          | Pattern.As (as_pattern, decl) => 
            "As (" + dump_pattern (as_pattern) + ", '" + decl.Name + "')"

          | Pattern.Tuple (args) =>
            "Tuple {" + List.FoldLeft (
              args, "", 
              fun (tuple_pattern, desc : string) { 
                (if (desc.Length > 0) desc + ", " else "") + dump_pattern (tuple_pattern)
              }
            ) + "}"

          | Pattern.Record (args) =>
            "Record {" + List.FoldLeft (
              args, "", 
              fun (field_and_tuple_pattern, desc) {
                def (field, tuple_pattern) = field_and_tuple_pattern;
                                                
                (if (desc.Length > 0) desc + ", " else "") +
                 field.Name + ":" + dump_pattern (tuple_pattern)
              }
            ) + "}"

          | Pattern.Application (name, arg) =>
            "Application (" + name.FullName + ", " + dump_pattern (arg) + ")"

          | Pattern.Enum (fld, l) =>
            $ "Enum ($(fld.Name), $l)"
            
          | Pattern.Literal (l) =>
            $ "Literal ($l)"

          | Pattern.HasType (t) =>
            "HasType (" + t.FullName + ")"

          | Pattern.Error => "Error"
        }
      };
    
      Message.Debug ("MatchClause::Dump: " + dump_pattern (m_pattern))
    }


    /**
     * Builds a pattern-matcher expression
     */
    public BuildMatchExpr (ctx : CTX, 
                           vals : SystemMap [int, CG_val], 
                           val : CExpr) : CTX * SystemMap [int, CG_val] * CExpr 
    {
      m_vals = vals;
      m_ctx = ctx;
      
      def pattern_expr =
        Util.locate (m_pattern.Location, build_pattern_expr (val, m_pattern, true));

      def guarded_expr =
        if (Option.IsSome (m_guard))
          CExpr.If (SystemType.Boolean,
                 pattern_expr,
                 cg_expr (m_ctx, Option.UnSome (m_guard)),
                 CExpr.FalseLiteral)
        else
          pattern_expr;
        
      (m_ctx, m_vals, guarded_expr)
    }


    /**
     * Builds an expression that evaluates to true if the pattern matches a value
     */
    private build_pattern_expr (val : CExpr, pattern : Pattern, is_top_level : bool) : CExpr
    {
      match (pattern) {
        | Pattern.Error => assert (false)

        | Pattern.Wildcard => 
          //FIXME: check for non-nullness of non-value types
          CExpr.TrueLiteral

        | Pattern.Literal (lit) =>
          MatchingCompiler.emit_compare_with (val, lit)
        
        | Pattern.HasType (ti) =>
          CExpr.HasType (val, ti.GetSystemType ())

        | Pattern.Application (cons_name, Pattern.Wildcard) =>
          assert (! (cons_name.GetTydecl () matches TypeDeclaration.Alias));

          if (is_top_level)
            // no nullness check is required here -- it is guaranteed by the effects switch
            CExpr.TrueLiteral
          else {
            def tyname = cons_name.GetSystemType ();
            CExpr.HasType (val, tyname)
          }
          
        | Pattern.Application (cons_name, subpattern) =>
          assert (! (cons_name.GetTydecl () matches TypeDeclaration.Alias));

          def tyname = cons_name.GetSystemType ();
          def cast_expr = CExpr.Cast (val, tyname, true);

          if (is_top_level) {
            // no nullness check is required here -- it is guaranteed by the effects switch
            build_pattern_expr (cast_expr, subpattern, false)
          }
          else {
            def has_type_expr = CExpr.HasType (val, tyname);
                    
            CExpr.If (SystemType.Boolean,          
                      has_type_expr,
                      build_pattern_expr (cast_expr, subpattern, false),
                      CExpr.FalseLiteral)
          }

        | Pattern.As (subpattern, decl) =>
          unless (decl.InClosure)
            match (m_vals.Find (decl.Id)) {
              | Some => ()
              | None =>
                def (new_ctx, v) = store_local (m_ctx, decl, CExpr.Nop ());
                m_ctx = new_ctx;
                m_vals = m_vals.Add (decl.Id, v);
            };
              
          def assign_expr = 
            CExpr.Assign (local_ref (m_ctx, decl, true),
                          maybe_cast (m_ctx, decl.Type.Fix ().GetSystemType (), val));

          match (build_pattern_expr (val, subpattern, false)) {
            | (CExpr.If (c, e_then, e_else)) as e =>
              CExpr.If (e.ty, c, CExpr.Sequence ([assign_expr, e_then]), e_else)
            | expr =>
              CExpr.If (SystemType.Boolean, expr, 
                        CExpr.Sequence ([assign_expr, CExpr.TrueLiteral]), CExpr.FalseLiteral)
          }

        | Pattern.Tuple (args) =>
          def len = List.Length (args);

          def f (arg, acc)
          {
            def (pos, ex) = acc;
            def cond = 
              build_pattern_expr (
                CompileTypedMethod.tuple_ref (CExpr.Cast (val, CompileTypedMethod.tuple_type (len),
                                                          true), pos, len), 
                arg, 
                false
              );
                                  
            (pos - 1, CExpr.If (SystemType.Boolean, 
                                cond, ex, CExpr.FalseLiteral))
          };

          def ini = (len, CExpr.TrueLiteral);            
          def (_, ex) = List.FoldLeft (List.Rev (args), ini, f);
          ex
            
        | Pattern.Record (args) =>
          def val = CExpr.Cast (val, pattern.GetSystemType (), true);
            
          def f (np, ex) 
          {
            def (name, pat) = np;
            def cond = 
              build_pattern_expr (build_record_field_ref (val, name), pat, false);
              
            CExpr.If (SystemType.Boolean, cond, ex, CExpr.FalseLiteral)
          };
          
          List.FoldLeft (List.Rev (args), CExpr.TrueLiteral, f)

        | Pattern.Enum => assert (false)
      }
    }
    
    private mutable m_pattern : Pattern;
    private mutable m_guard : option [TExpr];
    private mutable m_effect : int;

    private mutable m_vals : SystemMap [int, CG_val];
    private mutable m_ctx : CTX;
  }



  /* -- MATCH COLLECTOR ---------------------------------------------------- */
  
  /**
   * Collects match effects and clauses
   */
  class MatchCollector
  {
    public this (matchType : System.Type, ctx : CTX, cases : list [Match_case])
    {
      m_ctx = ctx;
      m_vals = SystemMap ();
      m_matchType = matchType;
      
      collect_cases (cases, [], 0, [])
    }
  
    public GetClauses () : list [MatchClause]
    {
      m_clauses
    }

    public IsTopLevelMatchingOverCons () : bool
    {
      def walk_clauses (clauses : list [MatchClause]) 
      {
        | [] => false            
        | clause :: rest =>
          match (clause.GetPattern ()) {
            | Pattern.Application => true
            | _ => walk_clauses (rest)
          } 
      };
      
      walk_clauses (m_clauses)
    }
  
    public GetTopLevelConsName () : TypeInfo
    {
      assert (IsTopLevelMatchingOverCons ());

      def walk_clauses (clauses : list [MatchClause]) 
      {
        | [] => Util.ice ("MatchCollector::GetTopLevelConsName")
        | clause :: rest =>
          match (clause.GetPattern ()) {
            | Pattern.Application (name, _) => name
            | _ => walk_clauses (rest)
          } 
      };
      
      walk_clauses (m_clauses)
    }

    public BuildEffectsSwitch (ctx : CTX, matching_expr : CExpr) : CExpr
    {
      def walk_effects (effects : list [MatchEffect]) : list [int * CExpr]
      {
        | [] => []
        | effect :: rest =>
          def effect_expr = cg_expr (ctx, effect.GetEffect ());
          
          (effect.GetIndex (), effect_expr) :: walk_effects (rest)
      };

      def match_failure_expr =
        CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []));

      CExpr.Switch (
        m_matchType,
        matching_expr,
        Some (match_failure_expr),
        walk_effects (m_effects)
      )
    }


    private collect_cases (cases : list [Match_case], 
                           effects : list [MatchEffect], 
                           effects_counter : int,
                           clauses : list [MatchClause]) : void
    {
      match (cases) {
        | [] =>
          m_effects = List.Rev (effects);
          m_clauses = List.Rev (clauses)
          
        | case :: rest =>
          def walk_patterns (patterns : list [Pattern * TExpr], 
                             new_clauses : list [MatchClause]) {
            match (patterns) {
              | [] => new_clauses // they will be reversed when all cases are processed
              | (pattern, guard) :: rest =>
                def new_clause =
                  MatchClause (
                    pattern, 
                    guard, 
                    effects_counter
                  );
                          
                walk_patterns (rest, new_clause :: new_clauses) 
            }                             
          };
    
          def new_effect =
            MatchEffect (
              effects_counter, 
              case.body
            );
            
          def new_clauses = walk_patterns (case.patterns, []);
                  
          collect_cases (
            rest, 
            new_effect :: effects, 
            effects_counter + 1, 
            List.Append (new_clauses, clauses)
          )
      }
    }
  
    private mutable m_effects : list [MatchEffect];
    private mutable m_clauses : list [MatchClause];

    private mutable m_vals : SystemMap [int, CG_val];
    private mutable m_matchType : System.Type;
    private mutable m_ctx : CTX;
  }



  /* ----------------------------------------------------------------------- */
  /* -- MATCHING PROBLEM CATEGORIZATION ------------------------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Recognized matching problem categories
   */
  variant MatchProblemCategory {
    | MPC_cons_list_like
    | MPC_cons_tree_like
    | MPC_cons_sparse
    | MPC_cons_sparse_with_const
    | MPC_cons_general
    | MPC_other
  }


  /**
   * A set of heuristics used to categorize matching problems.
   */
  class MatchProblemCategorizer
  {
    public this (variant_options : list [TypeInfo], match_collector : MatchCollector)
    {
      m_variant_options = variant_options;
      m_match_collector = match_collector;
            
      m_variant_names = SystemMap ();
      m_const_variant_names = SystemMap ();
            
      m_const_variants = [];

      m_variants_lookup = SystemMap ();
      
      m_non_const_variants_used = [];
      m_const_variants_used = [];
          
      categorize_match_problem ()
    }
    
    
    /**
     * Returns the category of the matching problem
     */
    public GetCategory () : MatchProblemCategory
    {
#if EXTRAMATCHINGDEBUG
      Message.Debug ("MatchProblemCategorizer::GetCategory: " + m_category.ToString ());
#endif

      m_category
    }
    
    
    /**
     * Returns the list of constant variants
     */
    public GetConstVariants () : list [TypeInfo * FieldInfo]
    {
      m_const_variants
    }


    /**
     * Returns the list of used const variants
     */
    public GetConstVariantsUsed () : list [TypeInfo * FieldInfo]
    {
      m_const_variants_used
    }


    /**
     * Returns the list of used non-const variants
     */
    public GetNonConstVariantsUsed () : list [TypeInfo]
    {
      m_non_const_variants_used    
    }
    
    
    /*
     * Calculates some statistics on the variant options. 
     * Collect the field infos of the const variants for later use.
     */
    private calculate_variant_statistics (variant_options : list [TypeInfo]) : void
    {
      match (variant_options) {
        | variant_option :: rest =>
          match (MatchingCompiler.get_constant_object (variant_option)) {
            | Some (const_variant_field_info) => 
              m_const_variant_names =
                m_const_variant_names.Add (variant_option.FullName, 0);

              m_const_variants =
                (variant_option, const_variant_field_info) :: m_const_variants;

              ++m_const_variants_count
              
            | _ => ()
          };

          m_variant_names =
            m_variant_names.Add (variant_option.FullName, 0);
          
          m_variants_lookup =
            m_variants_lookup.Add (variant_option.FullName, variant_option);
          
          calculate_variant_statistics (rest)
          
        | [] => ()
      }
    }


    /*
     * Calculates some statistics on clauses
     */    
    private calculate_clause_statistics (clauses : list [MatchClause]) : void
    {
      def increase_occurence_count (name : string)
      {
        def occurence_count =
          m_variant_names.Get (name);
    
        m_variant_names =
          m_variant_names.Replace (name, occurence_count + 1);
      
        ++m_cons_patterns_count;
      };

      def increase_const_occurence_count (name : string)
      {
        def occurence_count =
          m_const_variant_names.Get (name);
    
        m_const_variant_names =
          m_const_variant_names.Replace (name, occurence_count + 1);
      
        ++m_const_cons_patterns_count;
      };
      
      def classify_pattern (pattern : Pattern) : void
      {
        match (pattern) {
          | Pattern.As (subpattern, _) => 
            classify_pattern (subpattern)
            
          | Pattern.Application (name, _) =>
            def name = 
              name.FullName;
                    
            increase_occurence_count (name);
            
            when (m_const_variant_names.Member (name))
              increase_const_occurence_count (name);
            
          | _ => ()
        }
      };
      
      match (clauses) {
        | clause :: rest =>
          ++m_patterns_count;
          classify_pattern (clause.GetPattern ());
                  
          calculate_clause_statistics (rest)
          
        | [] => ()      
      }
    }


    /*
     * Calculates how many variants have actually been used in clauses
     */
    private count_unique_variants_in_clauses () : void
    {
      def variant_iterator (key : string, value : int) : void
      {
        when (value != 0) {
          def variant_option =
            m_variants_lookup.Get (key);

          ++m_unique_cons_patterns_count;
          
          match (m_const_variant_names.Find (key)) {
            | Some (value) when value != 0 =>                
              def const_variant_field_info =
                Option.UnSome (MatchingCompiler.get_constant_object (variant_option));
                
              m_const_variants_used =
                (variant_option, const_variant_field_info) :: m_const_variants_used;
            
              ++m_unique_const_cons_patterns_count
              
            | _ =>
              m_non_const_variants_used =
                variant_option :: m_non_const_variants_used
          }
        }
      };
      
      m_variant_names.Iter (variant_iterator)
    }


    /*
     * Applies some heuristics to categorize the matching problem
     */    
    private categorize_match_problem () : void
    {
      // step one: count the variants
      m_variants_count = List.Length (m_variant_options);
      
      calculate_variant_statistics (m_variant_options);

      // step two: count the patterns      
      calculate_clause_statistics (m_match_collector.GetClauses ());
      
      // step three: check which variants have actually been used
      count_unique_variants_in_clauses ();
      
      // step four: given above statistics, decide the category of the problem
      m_category =
        if (m_variants_count == 0 || m_cons_patterns_count == 0)
          MatchProblemCategory.MPC_other ()
        else {
          if (m_variants_count <= 2 && m_const_variants_count >= 1)
            MatchProblemCategory.MPC_cons_list_like ()
          else if (m_variants_count == 3 && m_const_variants_count >= 1)
            MatchProblemCategory.MPC_cons_tree_like ()
          else if (m_unique_cons_patterns_count <= 3 && 
                   m_unique_const_cons_patterns_count >= 1)
            MatchProblemCategory.MPC_cons_sparse_with_const ()
          else if (m_unique_cons_patterns_count <= 2)
            MatchProblemCategory.MPC_cons_sparse ()
          else
            MatchProblemCategory.MPC_cons_general ()
        }      
    }

    // input data        
    private mutable m_variant_options : list [TypeInfo];
    private mutable m_match_collector : MatchCollector;

    // pattern statistics
    private mutable m_patterns_count : int;
    private mutable m_cons_patterns_count : int;
    private mutable m_const_cons_patterns_count : int;
    
    // unique variants in patterns statistics
    private mutable m_unique_cons_patterns_count : int;
    private mutable m_unique_const_cons_patterns_count : int;
    
    // variants statistics
    private mutable m_variants_count : int;
    private mutable m_const_variants_count : int;

    // names of the variants and their usage counts
    private mutable m_variant_names : SystemMap [string, int];
    private mutable m_const_variant_names : SystemMap [string, int];
    
    // the list of constant variant options
    private mutable m_const_variants : list [TypeInfo * FieldInfo];
    
    // variants lookup table
    private mutable m_variants_lookup : SystemMap [string, TypeInfo];

    // the lists of constant/non-constant variants that actually have been used
    private mutable m_non_const_variants_used : list [TypeInfo];
    private mutable m_const_variants_used : list [TypeInfo * FieldInfo];
    
    // the calculated category of the matching problem
    private mutable m_category : MatchProblemCategory;
  }
  

  
  /* ----------------------------------------------------------------------- */
  /* -- MATCHING OVER VARIANT CONSTRUCTORS CODE GENERATOR ------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Matching over variant constructors code generator
   */
  class MatchingOverVariantCons
  {
    public this (ctx : CTX, val : CExpr, match_collector : MatchCollector)
    {
      m_ctx = ctx;
      m_val = val;
      m_vals = SystemMap ();    
      m_match_collector = match_collector;
    
      def (variant_options, variant_code_method_info) =
        fetch_variant_options ();

      m_variant_options = variant_options;
  
      m_variant_code_call_expr =
        CExpr.Call (SystemType.Int32, 
                    CExpr.MethodRef (val, variant_code_method_info, false), 
                    []);

      m_match_categorizer =
        MatchProblemCategorizer (variant_options, match_collector);
        
      match (m_match_categorizer.GetCategory ()) {
        | MatchProblemCategory.MPC_cons_list_like => 
          create_list_like_matcher ()

        | MatchProblemCategory.MPC_cons_sparse_with_const
        | MatchProblemCategory.MPC_cons_sparse =>
          create_sparse_matcher ()

        | _ => create_general_matcher ()
      }
    }


    /**
     * Returns the resulting matcher
     */
    public GetMatcher () : CExpr
    {
      m_matcher
    }


    /**
     * Returns the method info for the _N_GetVariantCode method defined in a given tycon
     */
    private get_variant_code_method (variant_tycon : TypeInfo) : System.Reflection.MethodInfo 
    {
      def members = 
        variant_tycon.LookupMember ("_N_GetVariantCode");
      
      match (members) {
        | [variant_code_method] =>
          def variant_code_method = 
            (variant_code_method :> IMethod);
          
          variant_code_method.GetMethodInfo ()
        
        | _ =>
          Util.ice ("MatchingOverVariantCons::get_variant_code_method: expected "
                    "exactly one _N_GetVariantCode method")
      }      
    }


    /**
     * Returns the list of variants we're matching over at the top level
     * and the info on the _N_GetVariantCode method.
     */
    private fetch_variant_options () : list [TypeInfo] * MethodInfo
    {
      def name = 
        m_match_collector.GetTopLevelConsName ();
        
      def variant_tycon =
        match (name.GetDirectSuperTypes ()) {
          | [ty] => ty.tycon
          | _ => Util.ice ("MatchingOverVariantCons::fetch_variant_options: "
                           "got more than one directsupertypes")
        };

      def variant_options =
        match (variant_tycon.GetTydecl ()) {
          | TypeDeclaration.Variant (members) => members
          | _ => Util.ice ("wrong tydecl in variant")
        };              

      (variant_options, get_variant_code_method (variant_tycon))
    }


    /**
     * Returns a list of clauses that have to do with a variant option
     */
    private collect_variant_related_clauses (variant_option : TypeInfo) : list [MatchClause]
    {
      def variant_full_name = variant_option.FullName;
        
      def walk_clauses (clauses : list [MatchClause], 
                        acc : list [MatchClause]) : list [MatchClause]
      {
        match (clauses) {
          | [] => List.Rev (acc)
            
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | Pattern.As (Pattern.Application (name, _), _)
              | Pattern.Application (name, _) =>
                if (name.FullName == variant_full_name)
                  walk_clauses (rest, clause :: acc)
                else
                  walk_clauses (rest, acc);

              | Pattern.As (Pattern.Wildcard, _) | Pattern.Wildcard  =>
                walk_clauses (rest, clause :: acc)

              | Pattern.As (Pattern.HasType (ty), _) | Pattern.HasType (ty) =>
                if (ty.Equals (variant_option))
                  walk_clauses (rest, clause :: acc)
                else
                  walk_clauses (rest, acc);

              | Pattern.Literal (Literal.Null) =>
                Message.FatalError ("sorry, null patterns are not yet supported in mix with variant options");
                //walk_clauses (rest, clause :: acc)
                 
              | _ =>
                clause.Dump ();
                Util.ice ("MatchingOverVariantCons::collect_variant_related_clauses: "
                          "wrong pattern (see the dump above)")
            }
        }
      };
      
      walk_clauses (m_match_collector.GetClauses (), [])
    }


    /**
     * Returns a list of clauses that do not have anything in common with a variant option
     */
    private collect_variant_unrelated_clauses () : list [MatchClause]
    {
      def walk_clauses (clauses : list [MatchClause], acc)
      {
        match (clauses) {
          | [] => List.Rev (acc)
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | Pattern.As (Pattern.Application, _) | Pattern.Application =>
                walk_clauses (rest, acc);

              | Pattern.As (Pattern.Wildcard, _) | Pattern.Wildcard =>
                walk_clauses (rest, clause :: acc)

              | Pattern.As (Pattern.HasType, _) | Pattern.HasType =>
                walk_clauses (rest, clause :: acc);
                
              | _ =>
                clause.Dump ();
                Util.ice ("MatchingOverVariantCons::collect_variant_unrelated_clauses: "
                          "wrong pattern (see the dump above)")
            }
        }
      };
      walk_clauses (m_match_collector.GetClauses (), [])
    }


    /**
     * Performs the last step of matcher generation: wraps the matcher
     * expression with CExpr.Define bindings of Pattern.As-induced variables.
     */
    private finalize_matcher (matcher : CExpr) : void
    {
      def mklet (_ : int, val : CG_val, acc : CExpr) : CExpr
      { 
        CExpr.Define (val, acc) 
      };
      
      m_matcher = m_vals.Fold (matcher, mklet)
    }
    

    /**
     * Binds clauses, creating an expression that evaluates to
     * an integer denoting the effect of each of the clauses.
     * We can perform a CExpr.Switch over that later.
     */
    private bind_clauses_for_switch (clauses : list [MatchClause]) : CExpr
    {
      match (clauses) {          
        | clause :: rest =>
          def (new_ctx, new_vals, clause_expr) =
            clause.BuildMatchExpr (m_ctx, m_vals, m_val);
            
          m_ctx = new_ctx;
          m_vals = new_vals;
            
          CExpr.If (SystemType.Boolean,          
                 clause_expr,
                 CExpr.Literal (Literal.FromInt (clause.GetEffect ())),
                 bind_clauses_for_switch (rest))

        | [] => CExpr.Literal (Literal.Integer (1, true, InternalType.Int32))
      }          
    }

    
    /**
     * Creates a sparse matcher for top-level variants.
     */
    private create_sparse_matcher () : void
    {
      // collects and bind clauses, builds the corresponding CExpr.HasType expression
      def process_variant (some_variant : TypeInfo) : CExpr * CExpr
      {
        def some_clauses =
          collect_variant_related_clauses (some_variant);

        def some_clauses_effect_expr =
          bind_clauses_for_switch (some_clauses);

        assert (! (some_variant.GetTydecl () matches TypeDeclaration.Alias));
        
        def some_has_type_expr =
          CExpr.HasType (m_val, some_variant.GetSystemType ());
          
        (some_has_type_expr, some_clauses_effect_expr)
      };

      // get the matchers for the variant unrelated clauses
      def unrelated_clauses = collect_variant_unrelated_clauses ();

      def unrelated_clauses_effect_expr =
        match (unrelated_clauses) {
          | [] => CExpr.Literal (Literal.Integer (1, true, InternalType.Int32))
          | _ => bind_clauses_for_switch (unrelated_clauses)
        };
            
      // get the matchers for the variant options used
      def fold_non_const_variants (some_variant : TypeInfo, matcher_expr_acc : CExpr) : CExpr
      {
        def (some_has_type_expr, some_clauses_effect_expr) =
          process_variant (some_variant);

        CExpr.If (
          SystemType.Int32, 
          some_has_type_expr,
          some_clauses_effect_expr,
          matcher_expr_acc
        )        
      };
      
      def non_const_matcher_expr =
        List.FoldLeft (
          m_match_categorizer.GetNonConstVariantsUsed (), 
          unrelated_clauses_effect_expr,
          fold_non_const_variants
        );

      // build the comparers for the const variants
      def fold_const_variants (const_cons : TypeInfo * FieldInfo, matcher_expr_acc : CExpr) : CExpr
      {
        def (some_variant, const_cons_field_info) = 
          const_cons;
        
        def (_, some_clauses_effect_expr) =
          process_variant (some_variant);

        def compare_to_const_expr =
          CExpr.Call (SystemType.Boolean, CExpr.Opcode ("==.ref"),
                  [m_val, CExpr.GlobalRef (const_cons_field_info)]);
            
        CExpr.If (SystemType.Int32,
               compare_to_const_expr,
               some_clauses_effect_expr,
               matcher_expr_acc);
      };

      def matcher_expr =
        List.FoldLeft (
          m_match_categorizer.GetConstVariantsUsed (),
          CExpr.Sequence ([CExpr.NotNull (m_val), non_const_matcher_expr]),
          fold_const_variants
        );

      // builds the effects switch and wrap the matcher with appropriate CExpr.Defines
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, matcher_expr);

      finalize_matcher (effects_switch)      
    }


    /**
     * Creates a matcher for top-level list-like variants
     *
     * NOTE: we could have two constant constructors here
     */
    private create_list_like_matcher () : void
    {
      // get the tycons for the variant options
      def (const_cons_tycon, const_cons_field_info) =
        match (m_match_categorizer.GetConstVariants ()) {
          | const_cons :: _ => const_cons
          | _ => Util.ice ("MatchingOverVariantCons::create_list_like_matcher: "
                           "expected at least one constant variant constructor")
        };

      def non_const_cons_tycon =
        match (m_variant_options) {
          | [left, right] => if (left.Equals (const_cons_tycon)) right else left
          | x :: _ => x
          | _ => Util.ice ("MatchingOverVariantCons::create_list_like_matcher: "
                           "expected some variant options")
        };

      // categorize the clauses, build the effects expressions
      def const_clauses =
        collect_variant_related_clauses (const_cons_tycon);

      def const_clauses_effect_expr =
        bind_clauses_for_switch (const_clauses);
        
      def non_const_clauses =
        collect_variant_related_clauses (non_const_cons_tycon);

      def non_const_clauses_effect_expr =
        bind_clauses_for_switch (non_const_clauses);

      // build the variant checking expression
      def compare_to_const_expr =
        CExpr.Call (SystemType.Boolean, CExpr.Opcode ("==.ref"),
                [m_val, CExpr.GlobalRef (const_cons_field_info)]);

      def non_const_check_expr =
        CExpr.Sequence ([CExpr.NotNull (m_val), non_const_clauses_effect_expr]);
            
      def const_check_expr =
        CExpr.If (SystemType.Int32,
               compare_to_const_expr,
               const_clauses_effect_expr,
               non_const_check_expr);

      // builds the effects switch and wrap the matcher with appropriate CExpr.Defines
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, const_check_expr);

      finalize_matcher (effects_switch)      
    }
/*
    private contains_nullcheck () : bool
    {
      def walk_clauses (clauses : list [MatchClause])
      {
        | [] => false
        | x :: xs =>
          match (x.GetPattern ()) {
            | Pattern.Literal (Literal.Null) => true
            | _ => walk_clauses (xs)
          }
      };
      walk_clauses (m_match_collector.GetClauses ())
    }
  */ 

    /**
     * Builds a general matcher over constructors on the top level
     */
    private create_general_matcher () : void
    {
      def walk_variant_options (index : int, variant_options : list [TypeInfo]) : list [int * CExpr]
      {
        match (variant_options) {
          | variant_option :: rest =>
#if EXTRAMATCHINGDEBUG
            Message.Debug (index.ToString () + ": " + variant_option.FullName);
#endif

            def patterns =
              collect_variant_related_clauses (variant_option);

            def effect_expr =
              bind_clauses_for_switch (patterns);
            
            (index, effect_expr) :: walk_variant_options (index + 1, rest)
            
          | [] => []
        }
      };

#if EXTRAMATCHINGDEBUG
      Message.Debug ("walking variant options of type " + variant_tyinfo.FullName);
#endif

      def cons_switch_cases =
        walk_variant_options (0, m_variant_options);
        
      def cons_switch =
        CExpr.Switch (
          SystemType.Int32,
          m_variant_code_call_expr,
          Some (CExpr.Literal (Literal.Integer (1, true, InternalType.Int32))),
          cons_switch_cases
        );
        
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, cons_switch);

      def guarded_effects_switch =
//        if (contains_nullcheck ()) effects_switch
//        else
          CExpr.Sequence ([CExpr.NotNull (m_val), effects_switch]);

      finalize_matcher (guarded_effects_switch)
    }  


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable m_ctx : CTX;
    private mutable m_val : CExpr;
    private mutable m_vals : SystemMap [int, CG_val];
    private mutable m_match_collector : MatchCollector;
    private mutable m_variant_options : list [TypeInfo];
    private mutable m_variant_code_call_expr : CExpr;
    private mutable m_match_categorizer : MatchProblemCategorizer;
    
    // the resulting matcher
    private mutable m_matcher : CExpr; 
  }




  /* ----------------------------------------------------------------------- */  
  /* --  OLD APPROACH ------------------------------------------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Description of a match pattern:
   *
   * | [pattern] when [guard] => [effect]
   *
   * Additionally, we hold an ordered list of guards that 
   * could possibly override this match.
   */
  class MatchPattern
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, pattern : Pattern, 
                 guard : int, effect : int, guard_is_always_true : bool,
                 as_pattern_val : option [CG_val])
    {
      this.guard_is_always_true = guard_is_always_true;
      this.match_descriptor = match_descriptor;
      this.as_pattern_val = as_pattern_val;
      this.pattern = pattern;
      this.guard = guard;
      this.effect = effect;
      overriden_by = [];
    }
    

    /* -- PUBLIC METHODS --------------------------------------------------- */
    
    public PossiblyOverrides (match_pattern : MatchPattern) : bool
    {
      compare_patterns (pattern, match_pattern.pattern)
    }
        
    public AlwaysOverrides (match_pattern : MatchPattern) : bool
    {
      PossiblyOverrides (match_pattern) && guard_is_always_true
    }
    
    public AddOverridingPattern (match_pattern : MatchPattern) : void
    {
      overriden_by = match_pattern :: overriden_by
    }
    
    public ReverseOverridingList () : void
    {
      overriden_by = List.Rev (overriden_by)
    }
    
    public GetPattern () : Pattern
    {
      pattern
    }

    public GetOverridingPatterns () : list [MatchPattern]
    {
      overriden_by
    }    
    
    public SetOverridingPatterns (overriden_by : list [MatchPattern]) : void
    {
      this.overriden_by = overriden_by
    }
    
    public IsUnderscore () : bool
    {
      match (pattern) {
        | Pattern.Wildcard => true
        | Pattern.As (Pattern.Wildcard, _) => true
        | _ => false
      }
    }

    public Location : Location
    {
      get { pattern.loc }
    }

    /**
     * Returns true if a pattern is an ordinal constant (an int 
     * or a char) -- possibly hidden beyond the 'as' construct.
     */
    public static IsOrdinalLiteral (pattern : MatchPattern) : bool
    {
      def is_good_literal (lit) {
        | Literal.Integer | Literal.Char => true
        | Literal.Enum (l, _) => is_good_literal (l)
        | _ => false
      }

      match (pattern.GetPattern ()) {
        | Pattern.Wildcard => false
        | Pattern.As (Pattern.Wildcard, _) => false
        | Pattern.As (Pattern.Literal (lit), _) => is_good_literal (lit)
        | Pattern.Literal (lit) => is_good_literal (lit)
        | z => Util.ice ("invalid pattern type: " + z.ToString ())
      }    
    }


    /**
     * Returns true if a pattern is a string constant 
     * (possibly hidden beyond the 'as' construct).
     */
    public static IsStringLiteral (pattern : MatchPattern) : bool
    {
      match (pattern.GetPattern ()) {
        | Pattern.Wildcard => false
        | Pattern.As (Pattern.Wildcard, _) => false
        | Pattern.As (Pattern.Literal (Literal.String), _) => true
        | Pattern.Literal (Literal.String) => true
        | _ => Util.ice ("invalid pattern type")
      }    
    }


    public MakeGuardExpr (continuation : option [CExpr]) : CExpr
    {
      def guard_expr =
        match (match_descriptor.GetGuard (guard)) {
          | Some (guard) => 
            assert (Option.IsSome (continuation),
                    "need to have a continuation if guards can fail");
            
            CExpr.If (match_descriptor.GetResultType (), guard,
                   match_descriptor.GetEffect (effect), 
                   Option.UnSome (continuation))
                  
          | None => 
            match_descriptor.GetEffect (effect)
        };
      
      collect_overriding_patterns (overriden_by, guard_expr);
    }


    /**
     * Comparison function that can be used by the List.Sort function
     */
    public static Compare (l : MatchPattern, r : MatchPattern) : int
    {
      def is_string_pattern =
        match (l.GetPattern ()) {
          | Pattern.Literal (Literal.String)
          | Pattern.As (Pattern.Literal (Literal.String), _) => true
          | _ => false
        };
        
      if (is_string_pattern) {
        def get_literal (pattern : MatchPattern) : string {
          match (pattern.GetPattern ()) {
            | Pattern.Literal (Literal.String (literal)) => literal
            | Pattern.As (Pattern.Literal (Literal.String (literal)), _) => literal
            | _ => Util.ice ("invalid pattern type")
          }
        };
        
        System.String.CompareOrdinal (get_literal (r), get_literal (l))
      }
      else {
        // compare instead of subtract, because of overflow possibility
        MatchBinarySearch.get_int_from_pattern (l).CompareTo 
          (MatchBinarySearch.get_int_from_pattern (r))
      }
    }


    public MakeMatchExpr (compare_to : CExpr, continuation : CExpr) : CExpr
    {
      match (pattern) {
        | Pattern.Literal (literal) =>
          def eq_expr = MatchingCompiler.emit_compare_with (compare_to, literal);

          def guard_expr =
            match (match_descriptor.GetGuard (guard)) {
              | Some (guard) => 
                CExpr.If (match_descriptor.GetResultType (), guard, 
                       match_descriptor.GetEffect (effect), continuation)
              | None =>
                match_descriptor.GetEffect (effect)
            };

          def overriding_expr =
            collect_overriding_patterns (overriden_by, guard_expr);
            
          CExpr.If (match_descriptor.GetResultType (), eq_expr, overriding_expr,
                 continuation)

        | Pattern.Wildcard =>
          def guard_expr =
            match (match_descriptor.GetGuard (guard)) {
              | Some (guard) => 
                CExpr.If (match_descriptor.GetResultType (), guard,
                       match_descriptor.GetEffect (effect), continuation)              
              | None => 
                match_descriptor.GetEffect (effect)
            };

          collect_overriding_patterns (overriden_by, guard_expr)
              
        | Pattern.As (subpattern, _) =>
          def subpattern = 
            MatchPattern (match_descriptor, subpattern, guard, 
                          effect, true, None ());
  
          subpattern.SetOverridingPatterns (GetOverridingPatterns ());
          
          CExpr.Define (Option.UnSome (as_pattern_val), 
                  subpattern.MakeMatchExpr (compare_to, continuation))
          
          /*
          match (subpat) {
            | Pattern.Application =>
              match (cgpat (val, subpat)) {
                | (CExpr.If (c, e_then, e_else)) as e =>
                  CExpr.If (e.ty, c, CExpr.Sequence ([ass; e_then]), e_else)
                | _ => Util.ice ()
              }
            | _ =>
              CExpr.Sequence ([ass; cgpat (val, subpat)])
          }
          */
          
        | _ => 
          Util.ice ("pattern type not supported in MakeMatchExpr")
      }
    }
    
    
    public MakeLessThanCondition (compare_to : CExpr) : CExpr
    {
      match (pattern) {
        | Pattern.Literal (Literal.String) =>
          Util.ice ("constant string patterns not supported in MakeLessThanCondition")
        | Pattern.Literal (Literal.Bool) =>
          Util.ice ("constant boolean patterns not supported in MakeLessThanCondition")
        | Pattern.Literal (literal) =>
          assert (literal != null);
          CExpr.Call (SystemType.Boolean, CExpr.Opcode ("<.s"),
                   [compare_to, CExpr.Literal (literal)])
        | _ => 
          Util.ice ("non-literal patterns not supported in MakeLessThanCondition")
      }    
    }

#if EXTRAMATCHINGDEBUG
    public Dump () : void
    {
      def message =
        match (pattern) {
          | Pattern.Literal (Literal.String (literal)) => "Literal Literal.String '" + literal + "'"
          | Pattern.Literal (Literal.Integer (literal)) => "Literal Literal.Integer " + literal.ToString ()
          | Pattern.Literal (Literal.Char (literal)) => "Literal Literal.Char " + 
            (literal :> int).ToString ()
          | Pattern.Wildcard => "Wildcard"
          | Pattern.As (Pattern.Wildcard, _) => "As/Wildcard"
          | _ => "other"
        };
        
      Message.Debug (message)
    }
#endif

    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    private collect_overriding_patterns (overriden_by : list [MatchPattern], 
                                         continuation : CExpr) : CExpr
    {
      match (overriden_by) {
        | [] => continuation
        | pattern :: rest =>
          // Message.Debug (pattern.GetLocation (),
          //                "this pattern is sometimes overriding");
          def continuation = pattern.MakeGuardExpr (Some (continuation));
          collect_overriding_patterns (rest, continuation)
      }
    }
    
    
    private compare_literals (l : Literal, r : Literal) : bool
    {
      match ((l, r)) {
        | (Literal.Null, Literal.Null) => true
        | (Literal.String (l), Literal.String (r)) => l == r
        | (Literal.Float (l), Literal.Float (r)) => l == r
        | (Literal.Char (l), Literal.Char (r)) => l == r
        | (Literal.Bool (l), Literal.Bool (r)) => l == r
        | (Literal.Integer (v1, n1, _), Literal.Integer (v2, n2, _)) =>
          v1 == v2 && n1 == n2
        | _ => false
      }
    } 
    
    private compare_tuples (l : list [Pattern], r : list [Pattern]) : bool
    {
      def walk_tuples (l : list [Pattern], r : list [Pattern]) : bool {
        match ((l, r)) {
          | ([], []) => true
          | (l :: ls, r :: rs) => 
            if (compare_patterns (l, r)) walk_tuples (ls, rs) else false
          | _ => false
        }
      };
      
      walk_tuples (l, r)
    }
    
    private compare_records (l : list [IMember * Pattern],
                             r : list [IMember * Pattern]) : bool
    {
      // FIXME
      List.Length (l) != List.Length (r)
    }
    
    private compare_conses (_ln : TypeInfo, _la : Pattern, _rn : TypeInfo,
                            _ra : Pattern) : bool
    {
      // FIXME
      false
    }
    
    private compare_patterns (l : Pattern, r : Pattern) : bool
    {
      match ((l, r)) {
        | (Pattern.Wildcard, _) => true
        | (Pattern.As (Pattern.Wildcard, _), _) => true
        | (Pattern.Literal (l), Pattern.Literal (r)) => compare_literals (l, r)      
        | (Pattern.Tuple (l), Pattern.Tuple (r)) => compare_tuples (l, r)
        | (Pattern.Record (l), Pattern.Record (r)) => compare_records (l, r)
        | (Pattern.Application (ln, la), Pattern.Application (rn, ra)) => compare_conses (ln, la, rn, ra)       
        | _ => false
      }
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable pattern : Pattern;
    private mutable guard : int;
    private mutable effect : int;
    private mutable as_pattern_val : option [CG_val];
    private mutable overriden_by : list [MatchPattern];
    private mutable guard_is_always_true : bool;
  }


  /**
   * Search for a matching pattern is optimized within
   * pattern blocks only.
   */
  class MatchBlock
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (patterns : list [MatchPattern])
    {
      this.patterns = patterns;
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public RemoveOverridenPatterns () : void
    {
      def walk_patterns (patterns : list [MatchPattern]) : list [MatchPattern] {
        | [] => []
        | head :: tail =>
          def overrides (pattern : MatchPattern) : bool {
            if (head.AlwaysOverrides (pattern)) {
              Message.Warning (head.Location, "this pattern overrides pattern:");
              Message.Warning (pattern.Location, "pattern is redundant");
              false
            }
            else true              
          };
          head :: walk_patterns (List.Filter (tail, overrides))
      };
      
      patterns = walk_patterns (patterns)
    }


    public DecidePatternOverriding () : void
    {
      mutable current_pattern_can_be_skipped = false;
      
      def decide_pattern_overriding (head : MatchPattern, 
                           patterns : list [MatchPattern]) : list [MatchPattern]
      {        
        match (patterns) {
          | pattern :: rest =>
            // Message.Debug (pattern.Location, "comparing to this pattern");
            if (head.PossiblyOverrides (pattern)) {
              // add overriding information for possibly hidden patterns
              pattern.AddOverridingPattern (head);
              unless (head.IsUnderscore ()) current_pattern_can_be_skipped = true;
              pattern :: decide_pattern_overriding (head, rest)
            }
            else {
              // leave the rest as is
              pattern :: decide_pattern_overriding (head, rest)
            }
          | [] => []
        }
      };  
      
      def walk_patterns (patterns : list [MatchPattern]) : list [MatchPattern] {
        match (patterns) {
          | pattern :: rest =>
            current_pattern_can_be_skipped = false;
            // Message.Debug (pattern.Location, "deciding overriding for this pattern");
            def rest = decide_pattern_overriding (pattern, rest);
            pattern.ReverseOverridingList ();
            if (!current_pattern_can_be_skipped) {
              // Message.Debug (pattern.Location, "keeping this pattern");
              pattern :: walk_patterns (rest)
            }
            else {
              // Message.Debug (pattern.Location, "skipping this pattern");
              walk_patterns (rest)
            }
          | [] => []
        }
      };
      
      patterns = walk_patterns (patterns)
    }

    public GetMatchPatterns () : list [MatchPattern] 
    {
      patterns
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable patterns : list [MatchPattern];
  }


  /**
   * A match construct consists of a number of blocks, 
   * guards and effects.
   */
  class MatchDescriptor
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    /**
     * Initializes the match descriptor. 
     * Builds the initial patterns block.
     */    
    public this (context : CTX, result_type : System.Type, 
                 matched_expr : CExpr, match_cases : list [Match_case])
    {
      vals = SystemMap ();
      guards = SystemMap ();
      effects = SystemMap ();
            
      current_guard = -1;
      current_effect = -1;
      
      this.context = context;
      this.result_type = result_type;
      this.matched_expr = matched_expr;

      matched_expr_type = matched_expr.SystemType;
      match_over_value_type = matched_expr_type.IsValueType;
      
      build_first_block (match_cases)
    }

    
    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetResultType () : System.Type
    {
      result_type
    }
    
    public GetMatchBlocks () : list [MatchBlock] 
    {
      blocks
    }

    public GetMatchedExpr () : CExpr
    {
      matched_expr
    }

    public GetEffect (index : int) : CExpr
    {
      effects.Get (index)
    }

    public GetGuard (index : int) : option [CExpr]
    {
      if (index == -1) None () else guards.Get (index)
    }

    public MakeAsPatternAssignment (decl : LocalValue) : CExpr * CG_val
    {      
      mutable as_pattern_val = null;
      
      unless (decl.InClosure) {
        match (vals.Find (decl.Id)) {
          | Some (val) =>
            as_pattern_val = val
          | None =>
            def (context, val) = store_local (context, decl, CExpr.Nop ());
            this.context = context;
            as_pattern_val = val;
            vals = vals.Add (decl.Id, val);
        }
      };
      
      def assign_expr =
        CExpr.Assign (local_ref (context, decl, true), 
                      maybe_cast (context, decl.Type.Fix ().GetSystemType (), matched_expr));
                               
      (assign_expr, as_pattern_val)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    /**
     * Builds the first block of patterns. This block will have to be either
     * split or the overriding guards information will have to be updated.
     */
    private build_first_block (match_cases : list [Match_case]) : void
    {
      mutable patterns = [];

      def process_pattern (pattern : Pattern, guard : TExpr) : void {
        current_guard = current_guard + 1;
        mutable previous_as_pattern_val = None ();
     
        // FIXME: 'as' nesting   
        def guard =
          match (pattern) {
            | Pattern.As (_, decl) =>
              def (assign_expr, as_pattern_val) = MakeAsPatternAssignment (decl); 
              previous_as_pattern_val = Some (as_pattern_val);
              CExpr.Sequence ([assign_expr, cg_expr (context, guard)])
            | _ => 
              cg_expr (context, guard)
          };
          
        def guard_is_always_true =
          match (guard) {
            | CExpr.Literal (Literal.Bool (true)) =>
              guards = guards.Add (current_guard, None ());
              true
            | _ =>
              guards = guards.Add (current_guard, Some (guard));
              false
          };
          
        def pattern =
          MatchPattern (this, pattern, current_guard, current_effect, 
                        guard_is_always_true, previous_as_pattern_val);

        patterns = pattern :: patterns
      };
      
      def walk_match_cases (match_cases : list [Match_case]) : void {
        match (match_cases) {
          | [] => ()
          | match_case :: rest =>
            current_effect = current_effect + 1;
            List.Iter (match_case.patterns, process_pattern);
            effects = effects.Add (current_effect, cg_expr (context, match_case.body));
            walk_match_cases (rest)
        }
      };
      
      walk_match_cases (match_cases);
      patterns = List.Rev (patterns);
      def block = MatchBlock (patterns);
      block.RemoveOverridenPatterns ();
      block.DecidePatternOverriding ();
      blocks = [block]
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable blocks : list [MatchBlock];
    private mutable guards : SystemMap [int, option [CExpr]];
    private mutable effects : SystemMap [int, CExpr];
    private mutable current_guard : int;
    private mutable current_effect : int;
    private mutable vals : SystemMap [int, CG_val];
    
    private mutable context : CTX;
    private mutable result_type : System.Type;
    private mutable matched_expr : CExpr;

    private mutable matched_expr_type : System.Type;
    private mutable match_over_value_type : bool;
  }
  

  /**
   * Builds an expression that performs a binary search 
   * over a value type (that'd mainly be ints and chars).
   */
  class MatchBinarySearch
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, 
                 patterns : list [MatchPattern],
                 continuation : option [CExpr])
    {
      assert (List.Length (patterns) > 0);
      
      this.match_descriptor = match_descriptor;
      this.patterns = patterns;
      this.matched_expr = match_descriptor.GetMatchedExpr ();
      this.continuation = continuation;
      
      binary_search_expr = make_binary_search_top_level (patterns)
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetBinarySearchExpr () : CExpr
    {
      binary_search_expr
    }
    
#if EXTRAMATCHINGDEBUG    
    public DumpMatchPatterns (patterns : list [MatchPattern]) : void {
      def walk_patterns (patterns : list [MatchPattern]) : void {
        match (patterns) {
          | [] => ()
          | pattern :: rest =>
            pattern.Dump ();
            walk_patterns (rest)
        }
      };
      
      Message.Debug (" -- dumping " + (List.Length (patterns)).ToString ()
                     + " patterns --");
      walk_patterns (patterns)
    }
#endif

    internal static get_int_from_pattern (pattern : MatchPattern) : int {        
      def get_int_from_literal (_) {
        | Literal.Integer (AsInt = Some (literal)) => literal
        | Literal.Char (literal) => literal :> int
        | Literal.Enum (l, _) => get_int_from_literal (l)
        | z => Util.ice ("invalid literal: " + z.ToString ())
      }

      match (pattern.GetPattern ()) {
        | Pattern.Literal (literal) 
        | Pattern.As (Pattern.Literal (literal), _) => get_int_from_literal (literal)
        | _ => Util.ice ("invalid pattern type")
      }
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    private split_patterns (patterns : list [MatchPattern]) 
      : list [MatchPattern] * MatchPattern * list [MatchPattern]
    {
      assert (List.Length (patterns) > 2);
      
      def split (patterns : list [MatchPattern], acc : list [MatchPattern], length : int) 
        : list [MatchPattern] * MatchPattern * list [MatchPattern]
      {
        if (length == 0) (List.Rev (acc), List.Head (patterns), List.Tail (patterns))
        else split (List.Tail (patterns), List.Head (patterns) :: acc, length - 1)      
      };
      
      split (patterns, [], List.Length (patterns) / 2)
    }


    private split_patterns_by_sign (patterns : list [MatchPattern]) 
      : list [MatchPattern] * list [MatchPattern]
    {
      def split (patterns : list [MatchPattern], acc_neg : list [MatchPattern],
                 acc_pos : list [MatchPattern])
          : list [MatchPattern] * list [MatchPattern]
      {
        match (patterns) {
          | [] => (List.Rev (acc_neg), List.Rev (acc_pos))
          | pattern :: rest =>
            match (pattern.GetPattern ()) {
              | Pattern.Literal (Literal.Integer (_, true, _)) =>
                split (rest, pattern :: acc_neg, acc_pos)

              | _ => split (rest, acc_neg, pattern :: acc_pos)
            };
        }            
      };
      
      split (patterns, [], [])
    }


    private make_last_match (pattern : MatchPattern) : CExpr
    {
      match (continuation) {
        | Some (continuation) =>
          pattern.MakeMatchExpr (matched_expr, continuation)          
        | None => 
          Util.ice ("last match case need to have continuation")
      }
    }

    /** Create switch for given integer patterns.
     *  Makes normalization of range in which patterns are contained.
     *
     * It is assumed, that this function will be called for small ranges
     * (smallest and largest value are quite near)
     */
    private make_switched_block (patterns : list [MatchPattern]) : CExpr 
    {
      def head = get_int_from_pattern (List.Head (patterns));
      def expr = 
        if (head != 0) 
          // unchecked subtraction of minimal possible value in the range
          // results in all possible value mapped to [0..range_span] range
          CExpr.Call (CExpr.Opcode ("-.f"), [matched_expr, CExpr.Literal (Literal.FromInt (head))])
        else
          matched_expr;

      def walk_patterns (patterns : list [MatchPattern]) : list [int * CExpr] {
        match (patterns) {
          | pattern :: rest =>
            def idx = unchecked (get_int_from_pattern (pattern) - head);
            (idx, pattern.MakeGuardExpr (continuation)) :: walk_patterns (rest)

          | [] => []
        }            
      };
      CExpr.Switch (expr, continuation, walk_patterns (patterns))
    }

    
    private make_binary_search (patterns : list [MatchPattern]) : CExpr
    {
      match (patterns) {
        | [l] => make_last_match (l)

        | [l, r] =>
          l.MakeMatchExpr (matched_expr, make_last_match (r))
                                   
        | patterns =>
          def literal_span = System.Math.Abs (unchecked {
            MatchBinarySearch.get_int_from_pattern (List.Head (patterns)) -
            MatchBinarySearch.get_int_from_pattern (List.Last (patterns))
          });
          if (literal_span > 8 && literal_span / List.Length (patterns) > 3) {
            def (l, m, r) = split_patterns (patterns);

            CExpr.If (match_descriptor.GetResultType (),
                      m.MakeLessThanCondition (matched_expr),
                      make_binary_search (l), make_binary_search (m :: r))
          }
          else
            make_switched_block (patterns)
      }          
    }


    /**
     * Handle the special case when some of the patterns have negative
     * literals and some positive -- it could disrupt the CExpr.Switch emitter
     */
    private make_binary_search_top_level (patterns : list [MatchPattern]) : CExpr
    {      
      def can_be_negative =
        match (List.Head (patterns).GetPattern ()) {
          | Pattern.Literal (Literal.Integer) => true
          | _ => false
        };

      if (can_be_negative) {        
        def (negative, positive) = split_patterns_by_sign (patterns);

        if (List.Length (negative) == 0) 
          make_binary_search (positive)
        else if (List.Length (positive) == 0) 
          make_binary_search (negative)
        else {
          def less_than_zero_expr = 
            CExpr.Call (SystemType.Boolean, CExpr.Opcode ("<.s"),
                    [matched_expr, CExpr.Literal (Literal.Integer (0, false, InternalType.Int32))]);

          CExpr.If (match_descriptor.GetResultType (), less_than_zero_expr,
                 make_binary_search (negative), make_binary_search (positive))
        }
      }
      else
        make_binary_search (patterns)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable patterns : list [MatchPattern];
    private mutable continuation : option [CExpr];
    private mutable matched_expr : CExpr;
    private mutable binary_search_expr : CExpr;
  }
  
  
  /**
   * The matching module
   */
  module MatchingCompiler 
  {
    // handle both IField and IProperty
    internal build_record_field_ref (val : CExpr, member : IMember) : CExpr
    {
      match (member) {
        | field is IField =>
          CExpr.FieldRef (val, field.GetFieldInfo ())
          
        | prop is IProperty =>
          CExpr.Call (CExpr.MethodRef (val, prop.GetGetter ().GetMethodInfo (), false), [])

        | _ => assert (false)
      }
    }

    
    /**
     * Emit comparison code with specific literal.
     */
    public emit_compare_with (compare_to : CExpr, literal : Literal) : CExpr
    {
      def method =
        match (literal) {
          | Literal.String =>
            CExpr.GlobalRef (SystemType.String_opEquality)
          | Literal.Decimal =>
            CExpr.GlobalRef (SystemType.Decimal_opEquality)
          | _ =>
            CExpr.Opcode ("==") 
        };
      assert (literal != null);
      def (compare_to, lit) =
        if (compare_to.SystemType.IsValueType)
          (compare_to,
           CExpr.Cast (CExpr.Literal (literal), compare_to.SystemType, true))
        else 
          (CExpr.Cast (compare_to, literal.GetSystemType (), true),
           CExpr.Literal (literal));
      CExpr.Call (SystemType.Boolean, method, [compare_to, lit])
    }


    
    /**
     * Creates an expression that will raise the MatchFailureException
     */
    private raise_match_failure_exception_expr (_match_descriptor : MatchDescriptor)
            : CExpr
    {
      CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []))
    }


    /**
     * Creates a series of CExpr.If checking if any of the patterns matches.
     */
    private combine_patterns (match_descriptor : MatchDescriptor, 
                              continuation : option [CExpr],
                              patterns : list [MatchPattern]) : option [CExpr]
    {             
      def match_failure_expr =
        raise_match_failure_exception_expr (match_descriptor);

      def walk_patterns (continuation : option [CExpr],
                         patterns : list [MatchPattern]) : option [CExpr] {      
        match (patterns) {
          | [] => continuation
          | pattern :: rest =>            
            def continuation =
              match (continuation) {
                | Some (continuation) =>
                  pattern.MakeMatchExpr (match_descriptor.GetMatchedExpr (), 
                                         continuation)
                | None =>
                  pattern.MakeMatchExpr (match_descriptor.GetMatchedExpr (), 
                                         match_failure_expr)
              };
            walk_patterns (Some (continuation), rest)
        }
      };

      walk_patterns (continuation, List.Rev (patterns))
    }    
    
    
    /**
     * Matching over ordinal types (integers, chars, etc.)
     */
    cg_match_over_ordinals (match_over_type : System.Type, 
                            context : CTX, 
                            matched_expr : CExpr, 
                            match_cases : list [Match_case]) : CExpr
    {
      def match_descriptor = 
        MatchDescriptor (context, match_over_type, matched_expr, match_cases);

      def process_block (block : MatchBlock, continuation : option [CExpr])
          : CExpr
      {
        def (literal_patterns, non_literal_patterns) = 
          List.Partition (block.GetMatchPatterns (), MatchPattern.IsOrdinalLiteral);

        def continuation = combine_patterns (match_descriptor, continuation, 
                                             non_literal_patterns);

        match (literal_patterns) {
          | [] => Option.UnSome (continuation)
          | _ =>
            def sorted_literal_patterns = 
              List.Sort (literal_patterns, MatchPattern.Compare);
  
            def binary_search = 
              MatchBinarySearch (match_descriptor, sorted_literal_patterns,
                                 continuation);

            binary_search.GetBinarySearchExpr ()
        }
      };
    
      def walk_blocks (blocks : list [MatchBlock]) : CExpr {
        | [block] => process_block (block, None ())
          
        | block :: rest =>            
          def continuation = walk_blocks (rest);
          process_block (block, Some (continuation))
          
        | _ => Util.ice ("no blocks in match descriptor")
      };
    
      walk_blocks (match_descriptor.GetMatchBlocks ())
    }  


    /**
     * Matching over constant string
     */
    cg_match_over_strings (match_over_type : System.Type, 
                           context : CTX, 
                           matched_expr : CExpr, 
                           match_cases : list [Match_case]) : CExpr
    {
      def match_descriptor = 
        MatchDescriptor (context, match_over_type, matched_expr, match_cases);
    
      def process_block (block : MatchBlock, continuation : option [CExpr]) : CExpr {
        def (literal_patterns, non_literal_patterns) = 
          List.Partition (block.GetMatchPatterns (), MatchPattern.IsStringLiteral);

        def continuation = combine_patterns (match_descriptor, continuation, 
                                             non_literal_patterns);

        match (literal_patterns) {
          | [] => Option.UnSome (continuation)
          | _ =>
            def sorted_literal_patterns = 
              List.Sort (literal_patterns, MatchPattern.Compare);
  
            // FIXME
            Option.UnSome (combine_patterns (match_descriptor, continuation,
                                             sorted_literal_patterns))
        }
      };
    
      def walk_blocks (blocks : list [MatchBlock]) : CExpr {
        match (blocks) {
          | [block] =>
            process_block (block, None ())
          | block :: rest =>            
            def continuation = walk_blocks (rest);
            process_block (block, Some (continuation))
          | _ => 
            Util.ice ("no blocks in match descriptor")
        }
      };
    
      walk_blocks (match_descriptor.GetMatchBlocks ())
    }
  
  
    cg_pattern (ctx : CTX, val : CExpr, pats : list [Pattern * TExpr])
    : CExpr * bool * CTX * list [CG_val]
    {
      mutable vals = SystemMap ();
      mutable rctx = ctx;
      mutable always_matches = true;
      
      def cgpat (val : CExpr, pat : Pattern) : CExpr {
        match (pat) {
          | Pattern.Wildcard => CExpr.TrueLiteral
          
          | Pattern.As (subpat, d) =>
            if (d.InClosure) ()
            else
              match (vals.Find (d.Id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, CExpr.Nop ());
                  rctx = ctx;
                  vals = vals.Add (d.Id, v);
              };
            def ass = CExpr.Assign (local_ref (rctx, d, true),
                                    maybe_cast (ctx, d.Type.Fix ().GetSystemType (), val));
            match (subpat) {
              | Pattern.Application =>
                match (cgpat (val, subpat)) {
                  | (CExpr.If (c, e_then, e_else)) as e =>
                    CExpr.If (e.ty, c, CExpr.Sequence ([ass, e_then]), e_else)
                  | _ => Util.ice ()
                }

              | Pattern.HasType (ti) =>
                CExpr.If (SystemType.Boolean, 
                       CExpr.HasType (val, ti.GetSystemType ()),
                       CExpr.Sequence ([ass, CExpr.TrueLiteral]),
                       CExpr.FalseLiteral)

              | _ =>
                CExpr.Sequence ([ass, cgpat (val, subpat)])
            }
            
          | Pattern.Tuple (args) =>
            def len = List.Length (args);
            def f (arg, acc)
              {
                def (pos, ex) = acc;
                def cond = cgpat (CompileTypedMethod.tuple_ref (CExpr.Cast (val, CompileTypedMethod.tuple_type (len), true),
                                             pos, len), arg);
                (pos - 1, CExpr.If (SystemType.Boolean, cond, ex,
                                    CExpr.FalseLiteral))
              };
            def ini = (len, CExpr.TrueLiteral);
            def (_, ex) = List.FoldLeft (List.Rev (args), ini, f);
            ex

          | Pattern.Literal (lit) =>
            emit_compare_with (val, lit)
            
          | Pattern.Record (args) =>
            def val = CExpr.Cast (val, pat.GetSystemType (), true);
            def f (np, ex) {
              def (name, pat) = np;
              def cond = cgpat (build_record_field_ref (val, name), pat);
              CExpr.If (SystemType.Boolean, cond, ex, CExpr.FalseLiteral)
            };
            List.FoldLeft (List.Rev (args), CExpr.TrueLiteral, f)
          
          | Pattern.Application (n, a) =>
            assert (! (n.GetTydecl () matches TypeDeclaration.Alias));

            always_matches = false;
            def tyname = n.GetSystemType ();
            def ex = CExpr.HasType (val, tyname);
            CExpr.If (SystemType.Boolean, ex, 
                      cgpat (CExpr.Cast (val, tyname, true), a), 
                      CExpr.FalseLiteral)

          | Pattern.HasType (ti) =>
            always_matches = false;
            CExpr.HasType (val, ti.GetSystemType ())

          | Pattern.Enum => assert (false)

          | Pattern.Error => assert (false)
        }
      };

      mutable global_always_matches = false;

      def loop (pats) {
        match (pats) {
          | (pat : Pattern, expr) :: rest =>
            always_matches = true;
            def cond = Util.locate (pat.Location, cgpat (val, pat));
            def cond =
              match (expr) {
                | TExpr.Literal (Literal.Bool (true)) => cond
                | _ =>
                  always_matches = false;
                  CExpr.If (SystemType.Boolean, cond, cg_expr (rctx, expr),
                            CExpr.FalseLiteral)
              };
            global_always_matches = global_always_matches || always_matches;
            CExpr.If (SystemType.Boolean, cond, CExpr.TrueLiteral, loop (rest))
            
          | [] => CExpr.FalseLiteral
        }
      };

      def r = loop (pats);
      def collect_vals (_ : int, v : CG_val, acc : list [CG_val]) : list [CG_val] { 
        v :: acc };
      (r, global_always_matches, rctx, vals.Fold ([], collect_vals))
    }

    
    /**
     * Matching over arbitrary types
     */    
    cg_match_general (t : System.Type, ctx : CTX, val : CExpr,
                      mcs : list [Match_case]) : CExpr 
    {
      match (mcs) {
        | [] =>
          CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []))

        | m :: ms =>
          // FIXME: do something with always_matches
          def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
          def mklet (v : CG_val, acc : CExpr) : CExpr { CExpr.Define (v, acc) };
          def then_part = cg_expr (ctx', m.body);
          def else_part = cg_match_general (t, ctx, val, ms);
          List.FoldLeft (vals, CExpr.If (t, cond, then_part, else_part), mklet)
      }
    }
    
    
    /**
     * Returns the constant object for a parameterless variant constructor
     */
    public get_constant_object (variant_tycon : TypeInfo) : option [FieldInfo]
    {
      def members = 
        variant_tycon.LookupMember ("_N_constant_object");
      
      match (members) {
        | [] => 
          None ()
        
        | [constant_object_field] =>
          def constant_object_field =
            (constant_object_field :> IField);
                        
          Some (constant_object_field.GetFieldInfo ())

        | _ =>
          Util.ice ("get_constant_object: expected zero or exactly one _N_constant_object fields")
      }          
    }
           

    /**
     * Matching over arbitrary types
     */
    cg_match_over_any_type (t : System.Type, ctx : CTX, val : CExpr,
                            mcs : list [Match_case]) : CExpr 
    {
      def match_collector = MatchCollector (t, ctx, mcs);
        
      if (match_collector.IsTopLevelMatchingOverCons ()) {
        def matcher_generator =
          MatchingOverVariantCons (ctx, val, match_collector);
          
        matcher_generator.GetMatcher ()
      }
      else
        cg_match_general (t, ctx, val, mcs)        
    }


    /**
     * Matching over booleans.
     */
    cg_match_over_booleans (t : System.Type, ctx : CTX, val : CExpr,
                            mcs : list [Match_case]) : CExpr
    {
      mutable vals = SystemMap ();
      mutable rctx = ctx;

      mutable true_handled = false;
      mutable false_handled = false;
      mutable last_pattern_always_matches = false;

      def is_always_true (expr : TExpr) : bool {
        match (expr) {
          | TExpr.Literal (Literal.Bool (true)) => true
          | _ => false
        }    
      };

      def make_cond (patterns : list [Pattern * TExpr]) : CExpr {
        match (patterns) {        
          | (Pattern.Wildcard, when_expr) :: _ when is_always_true (when_expr) =>
            last_pattern_always_matches = true;          
            CExpr.TrueLiteral
        
          | (Pattern.Wildcard, when_expr) :: rest =>
            CExpr.If (SystemType.Boolean, cg_expr (rctx, when_expr),
                      CExpr.TrueLiteral, make_cond (rest))

          | (Pattern.Literal (Literal.Bool (literal)), when_expr) :: rest
            when is_always_true (when_expr)
            =>
            def literal_already_handled = if (literal) true_handled else false_handled;   
            when (literal_already_handled)
              Message.Warning ("unreachable pattern in matching");
            
            if (literal) true_handled = true else false_handled = true;
                      
            if (true_handled && false_handled) {
              last_pattern_always_matches = true;          
              CExpr.TrueLiteral
            }
            else {
              if (literal) 
                CExpr.If (SystemType.Boolean, val,
                          CExpr.TrueLiteral, make_cond (rest))
              else
                CExpr.If (SystemType.Boolean, val,
                          make_cond (rest), CExpr.TrueLiteral)
            }

          | (Pattern.Literal (Literal.Bool (literal)), when_expr) :: rest =>
            def literal_already_handled = if (literal) true_handled else false_handled;
            when (literal_already_handled)
              Message.Warning ("unreachable pattern in matching");

            def opposite_handled = if (literal) false_handled else true_handled;

            if (opposite_handled) {
              CExpr.If (SystemType.Boolean, cg_expr (rctx, when_expr),
                        CExpr.TrueLiteral, make_cond (rest))          
            }
            else {
              def not_handled = CExpr.If (SystemType.Boolean, cg_expr (rctx, when_expr), 
                                          CExpr.TrueLiteral, make_cond (rest));
              if (literal)
                CExpr.If (SystemType.Boolean, val, CExpr.TrueLiteral, not_handled)
              else                              
                CExpr.If (SystemType.Boolean, val, not_handled, CExpr.TrueLiteral)                 
            }

          | (Pattern.As (Pattern.Wildcard, decl), when_expr) :: _
            when is_always_true (when_expr) =>
            if (decl.InClosure) ()
            else
              match (vals.Find (decl.Id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, decl, CExpr.Nop ());
                  rctx = ctx;
                  vals = vals.Add (decl.Id, v);
              };
            last_pattern_always_matches = true;
            def assign_expr = 
              CExpr.Assign (local_ref (rctx, decl, true),
                            maybe_cast (rctx, decl.Type.Fix ().GetSystemType (), val));
            assign_expr

          | [] => CExpr.FalseLiteral

          | (Pattern.Tuple, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind Pattern.Tuple")
          | (Pattern.Record, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind Pattern.Record")
          | (Pattern.Application, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind Pattern.Application")

          | _ :: _ => 
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
        }      
      };

      def walk_match_cases (mcs : list [Match_case]) : CExpr {
        match (mcs) {
          | [] =>
            CExpr.Throw (CExpr.Call (CExpr.ConstructorRef (InternalType.MatchFailureException_ctor), []))

          | mc :: rest =>
            def cond = make_cond (mc.patterns);
            def body = cg_expr (rctx, mc.body);
            
            def vals' = vals;
            vals = SystemMap ();
            
            def body =
              if (true_handled && false_handled || last_pattern_always_matches) {
                // should be handled already anyway, and here there is no way
                // to disable this warning (from @foreach)
                // unless (rest matches []) Message.Warning ("unreachable match cases");
                match (cond) {
                  | CExpr.Assign =>
                    CExpr.Sequence ([cond, body])
                  | _ => body
                }
              }
              else
                CExpr.If (body.SystemType, cond, body, walk_match_cases (rest));

            vals'.Fold (body, fun (_, val, acc) { CExpr.Define (val, acc) })
        }
      };

      // handle the special cases for the if/when/unless macros
      match (mcs) {
        | [then_case, else_case] =>
          match ((then_case.patterns, else_case.patterns)) {
            | ([(Pattern.Literal (Literal.Bool (literal)), then_case_when_expr)],
               [(Pattern.Wildcard, else_case_when_expr)]) 
              when is_always_true (then_case_when_expr) &&
                   is_always_true (else_case_when_expr) =>
              if (literal)
                CExpr.If (t, val, cg_expr (ctx, then_case.body),
                       cg_expr (ctx, else_case.body))
              else
                CExpr.If (t, val, cg_expr (ctx, else_case.body), 
                       cg_expr (ctx, then_case.body));
                                              
            | _ => walk_match_cases (mcs)
          }
        | _ => walk_match_cases (mcs)
      }
    }


    /**
     * Matching
     */
    public Run (t : System.Type, ctx : CTX, val : CExpr,
                mcs : list [Match_case]) : CExpr
    {
      def valt = val.SystemType;
      // here we choose whether to use some optimized matching algorithm or
      // just most general one
      if (Options.ConstantBooleanMatchingOpt && valt.Equals (SystemType.Boolean))
        cg_match_over_booleans (t, ctx, val, mcs)
      else if (Options.ConstantOrdinalMatchingOpt && 
        (valt.Equals (SystemType.Char) || valt.Equals (SystemType.Int32)))
        cg_match_over_ordinals (t, ctx, val, mcs)
      else if (Options.ConstantStringMatchingOpt && valt.Equals (SystemType.String)) 
        cg_match_over_strings (t, ctx, val, mcs)
      else
        cg_match_over_any_type (t, ctx, val, mcs)
    }
   
  } // end of the module

} // end of the namespace
