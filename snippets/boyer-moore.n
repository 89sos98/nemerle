(* ------------------------------------------------------------------------- *)
(*   Knuth-Morris-Pratt exact string matching algorithm                      *)
(*                                                                           *)
(*   See ESMAJ: http://www-igm.univ-mlv.fr/~lecroq/string/node8.html         *)
(* ------------------------------------------------------------------------- *)


class PrefixFunction
{
  private mutable _prefix_function : array (int);
  private mutable _pattern : array (char);
  private mutable _pattern_length : int;

  public this (pattern : string)
  {
    this._pattern <- pattern.ToCharArray ();
    this._pattern_length <- pattern.Length;

    this._prefix_function <- 
      (System.Array.CreateInstance (this._pattern_length.GetType (), this._pattern_length + 1) :> array (int));

    this.calculate_prefix_function ()  
  }

  public this (pattern : array (char), length : int)
  {
    this._pattern <- pattern;
    this._pattern_length <- length;

    this._prefix_function <- 
      (System.Array.CreateInstance (this._pattern_length.GetType (), this._pattern_length + 1) :> array (int));

    this.calculate_prefix_function ()  
  }

  public Get (index : int) : int {
  
    this._prefix_function [index]
  }

  private calculate_prefix_function () : void 
  {
    mutable i <- 0;
    mutable j <- -1;
    
    this._prefix_function [0] <- -1;
    
    def loop () : void {
    
      if (i < this._pattern_length) {
      
        def inner_loop () : void {
                
          if (j > -1 && this._pattern [i] != this._pattern [j]) {
            j <- this._prefix_function [j];
            inner_loop ()
          }
          else ()
        };
        
        inner_loop ();
        
        i <- i + 1;
        j <- j + 1;
        
        if (i < this._pattern_length && this._pattern [i] == this._pattern [j])
          this._prefix_function [i] <- this._prefix_function [j]
        else
          this._prefix_function [i] <- j;
          
        loop ()        
      }
      else ()    
    };
    
    loop ()
  }
}

class LastOccurrenceFunction
{
  private mutable _last_occurrence_function : array (int);
  
  private mutable _pattern : array (char);
  private mutable _pattern_length : int;

  public this (pattern : string)
  {
    this._pattern <- pattern.ToCharArray ();
    this._pattern_length <- pattern.Length;

    this._last_occurrence_function <- 
      (System.Array.CreateInstance (this._pattern_length.GetType (), 256) :> array (int));

    this.calculate_last_occurrence_function ()  
  }

  public Get (character : char) : int {
  
    this._last_occurrence_function [(character :> int)]
  }

  private calculate_last_occurrence_function () : void 
  {
    def loop (index : int) : void {
    
      if (index < this._pattern_length) {
      
        if ((this._pattern [index] :> int) >= 256)
          raise Invalid_argument ("_pattern")
        else ();

        this._last_occurrence_function [ (this._pattern [index] :> int) ] <- index;
                
        loop (index + 1)
      }
      else ()
    };
    
    loop (0)
  }
}


class GoodSuffixFunction
{
  private mutable _good_suffix_function : array (int);
  
  private mutable _pattern : array (char);
  private mutable _reversed_pattern : array (char);
  private mutable _pattern_length : int;

  private mutable _prefix_function : PrefixFunction;
  private mutable _reversed_prefix_function : PrefixFunction;

  public this (pattern : string)
  {
    this._pattern <- pattern.ToCharArray ();
    this._reversed_pattern <- pattern.ToCharArray ();
    this._pattern_length <- pattern.Length;

    this.reverse_string (this._reversed_pattern, this._pattern_length);

    this._prefix_function <- PrefixFunction (pattern);
    this._reversed_prefix_function <- PrefixFunction (this._reversed_pattern, this._pattern_length);

    this._good_suffix_function <- 
      (System.Array.CreateInstance (this._pattern_length.GetType (), this._pattern_length + 1) :> array (int));

    this.calculate_good_suffix_function ()  
  }

  public Get (index : int) : int {
  
    this._good_suffix_function [index + 1]
  }

  private calculate_good_suffix_function () : void 
  {
    def pattern_m_minus_pi_m = this._pattern_length - this._prefix_function.Get (this._pattern_length);

    def loop1 (index : int) : void {
    
      if (index <= this._pattern_length) {
      
        this._good_suffix_function [index] <- pattern_m_minus_pi_m;
        loop1 (index + 1)
      }
      else ()
    };
    
    loop1 (0);
    
    def loop2 (index : int) : void {
    
      if (index <= this._pattern_length) {
      
        def j = this._pattern_length - this._reversed_prefix_function.Get (index);
        
        if (this._good_suffix_function [j] > index - this._reversed_prefix_function.Get (index))
          this._good_suffix_function [j] <- index - this._reversed_prefix_function.Get (index)
        else ();
      
        loop2 (index + 1)
      }
      else ()
    };
    
    loop2 (1)
  }
  
  private reverse_string (text : array (char), length : int) : void 
  {
    def loop (index : int) : void {
    
      if (index <= length / 2) {
      
        def t = text [length - index - 1];
        text [length - index - 1] <- text [index];
        text [index] <- t;
      
        loop (index + 1)
      }
      else ()
    };
    
    loop (0)
  }
}

class BM
{
  private mutable _pattern : array (char);
  private mutable _pattern_length : int;

  private mutable _last_occurrence_function : LastOccurrenceFunction;
  private mutable _good_suffix_function : GoodSuffixFunction;

  public this (pattern : string) 
  {
    this._pattern <- pattern.ToCharArray ();
    this._pattern_length <- pattern.Length;

    this._last_occurrence_function <- LastOccurrenceFunction (pattern);
    this._good_suffix_function <- GoodSuffixFunction (pattern);    
  }
  

  public Search (text : string) : option (int) {
  
    def text_length = text.Length;
    def text = text.ToCharArray ();
    
    mutable s <- 0;
    
    def loop () : option (int) {
    
      if (s < text_length - this._pattern_length) {
      
        mutable j <- this._pattern_length - 1;
      
        def inner_loop () : void {
        
          if (j > 0 && this._pattern [j] == text [s + j]) {
            j <- j - 1;
            inner_loop ()
          }
          else ()
        };
        
        inner_loop ();

        if (j == -1)
          Some (s)
        else {
          s <- s + Max (this._good_suffix_function.Get (j),
                        j - this._last_occurrence_function.Get (text [s + j]));
          loop ()
        }
      }
      else None ()
    };
    
    loop ()    
  }

  private static Max (x : int, y : int) : int {
  
    if (x < y) y else x;
  }

  
  public static Main () : void {
  
    def r = BM ("ziemi egipskiej");
    
    match (r.Search ("Jam jest Pan Bóg twój, który Ciê wywiód³ z ziemi egipskiej, z domu niewoli")) {
      | Some (i) => print_endline ("Found at position " + string_of_int (i + 1))
      | None => print_endline ("Not found")
    }
  }
}
