<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle grammar</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document includes the Nemerle language grammar with small
        comments (one, two sentences for each production; please refer
        to <link>coreNemDesc.html</link> for more info).
      </p>
      <p>
        Grammar described here is still subject to change, although
        its basic shape should remain.
      </p>
    </body>
  </section>
  <section id="lexical">
    <title>Lexical Conventions</title>
    <body>
      <p>
        Programs are written using the Unicode character set.  Every
        Nemerle source file is reduced to a sequence of lexical units
        (tokens).
      </p>
    </body>
    <subsection id="tokens">
      <title>Tokens</title>
      <body>
        <p>
	  There are five classes of lexical tokens: 
        </p>
        <ul>
          <li>identifiers</li>
          <li>type variables</li>
          <li>keywords</li>
          <li>literals</li>
          <li>blanks</li>
        </ul>
<code>
(* A comment. *)
// Also a comment

foo               // identifier
foo_bar foo' foo3 // other identifiers
'a                // type variable 
10                // integer literal
0xff              // hexadecimal integer literal
0o666             // octal integer literal
0b101             // binary integer literal
'a'               // character literal
'\n'              // also a character literal
"foo\nbar"        // string literal
@"x\n"            // same as "x\\n"
@if               // keyword used as identifier
</code>
      </body>
    </subsection>
    <subsection id="blanks">
      <title>Blanks</title>
      <body>
        <p>
	  Spaces, vertical, and horizontal tabulation characters,
	  new-page, and new-line characters, and comments (called blanks
	  altogether) are discarded, but can separate other lexical tokens.
	</p>
        <p>
	  A traditional comment begin with <tt>(*</tt>, and end with
	  <tt>*)</tt>.  A end-of-line comment begin with <tt>//</tt>,
	  and end with line terminator (ASCII LF character).
	</p>
      </body>
    </subsection>
    <subsection id="type-variables">
      <title>Type variables</title>
      <body>
        <p>
          Type variables start with apostrophe (<tt>'</tt>) and consists of
          characters allowed in identifiers, but cannot contain apostrophe.
	</p>
      </body>
    </subsection>
    <subsection id="identifiers">
      <title>Identifiers</title>
      <body>
        <p>
	  Ordinary identifiers consist of letters, digits, underscores
	  and apostrophe, but cannot begin with a digit nor an apostrophe.
	  Identifiers may be quoted with the <tt>@</tt> character, which
	  is stripped. Apostrophe removes any lexical and syntactic
	  meaning from the following string of characters until blank,
	  thus enabling programmer to use keywords as identifiers.
	</p>
	<p>
	  Symbolic identifiers consist of following characters: 
          <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>@</tt>,
          <tt>^</tt>, <tt>|</tt>, <tt>&amp;</tt>, <tt>+</tt>, <tt>-</tt>,
          <tt>*</tt>, <tt>/</tt>, <tt>$</tt>, <tt>%</tt>, <tt>!</tt>,
          <tt>?</tt>, <tt>~</tt>, <tt>.</tt>, <tt>:</tt>, <tt>#</tt>.
          Symbolic identifiers may be used, wherever ordinary
	  identifiers may, but have additional property of being used
	  as infix operators.
	</p>
      </body>
    </subsection>
    <subsection id="keywords">
      <title>Keywords</title>
      <body>
        <p>
	  Following identifiers are used as keywords, and may not be
	  used in any other context unquoted:
          <tt>_</tt>, <tt>abstract</tt>, <tt>and</tt>, <tt>array</tt>,
          <tt>as</tt>, <tt>base</tt>, <tt>class</tt>, <tt>const</tt>,
          <tt>def</tt>, <tt>else</tt>, <tt>ensure</tt>, <tt>enum</tt>,
          <tt>extends</tt>, <tt>extern</tt>, <tt>finally</tt>,
          <tt>fun</tt>, <tt>if</tt>, <tt>implements</tt>,
          <tt>in</tt>, <tt>interface</tt>, <tt>internal</tt>,
          <tt>let</tt>, <tt>macro</tt>, <tt>match</tt>,
          <tt>module</tt>, <tt>mutable</tt>, <tt>namespace</tt>,
          <tt>new</tt>, <tt>null</tt>, <tt>open</tt>, <tt>out</tt>,
          <tt>private</tt>, <tt>protected</tt>, <tt>public</tt>,
          <tt>raise</tt>, <tt>ref</tt>, <tt>require</tt>, <tt>sealed</tt>,
          <tt>static</tt>, <tt>struct</tt>, <tt>then</tt>, <tt>this</tt>,
          <tt>try</tt>, <tt>tymatch</tt>, <tt>type</tt>, <tt>variant</tt>,
          <tt>void</tt>, <tt>volatile</tt>, <tt>where</tt>, <tt>with</tt>.
        </p>
        <p>
          Following infix identifiers are keywords:
          <tt>=</tt>, <tt>$</tt>, <tt>?</tt>, <tt>|</tt>, <tt>&lt;-</tt>,
          <tt>-&gt;</tt>, <tt>=&gt;</tt>, <tt>&lt;[</tt>, <tt>]></tt>,
          <tt>&amp;&amp;</tt>, <tt>||</tt>.
	</p>
      </body>
    </subsection>
    <subsection id="literals">
      <title>Literals</title>
      <body>
        <p>
          There are few kinds of literals:
	</p>
        <ul>
          <li>
            String literals, enclosed in <tt>""</tt>. Compiler processes
            backslash escapes much like in C#.
          </li>
          <li>
            Raw string literals, written like ordinary string literals,
            but prefixed with <tt>@</tt>. Escapes are not processed.
          </li>
          <li>
            Character literals, enclosed in <tt>'</tt>. Escapes are
            processed.
          </li>
          <li>
            Integer literals, possibly prefixed with <tt>0x</tt>,
            <tt>0o</tt> or <tt>0b</tt> to donate hexadecimal, octal or
            binary encoding respectively.
          </li>
        </ul>
      </body>
    </subsection>
  </section>
  <section id="gram">
    <title>The grammar</title>
    <xi:include href="../grammar.xml" />
  </section>
    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
