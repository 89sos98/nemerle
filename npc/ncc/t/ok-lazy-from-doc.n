
interface I_Comparable_To ('a)
{ 
  compare_to (_ : 'a) : int;
}   

interface I_Runnable ('a)
{
  run () : 'a;
} 

interface I_Set ('a)
{   
  add (elem : 'a) : void;
  mem (elem : 'a) : bool;
  ('b) fold (f : 'a * 'b -> 'b, init : 'b) : 'b;
} 

class Lazy ('a)
  implements
    I_Comparable_To(Lazy('a)),
    I_Runnable('a)
{
  (* There is no real-life reason it needs integer key, except
     that will put this stuff into tree. *)
  field key : int;
  field fnc : void -> 'a;

  method run () : 'a
    implements I_Runnable.run
  =
    (this # fnc) ();

  method compare_to (that : Lazy('a)) : int
    implements I_Comparable_To.compare_to
  =
    this # key - that # key;
}

class Cached_Lazy ('a)
  extends Lazy ('a)
  implements
    I_Comparable_To(Lazy('a)),
    I_Runnable('a)
{
  (* key and fnc fields are automagically copied. *)
  field ref cache : 'a;

  method run () : 'a implements I_Runnable.run =
    if this # cache == null then
      let v = this # fnc () in
      { this # cache <- v; v }
    else
      this # cache;
}
