/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler;
using Nemerle.Utility;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public variant Symbol
{
  | Sym_type { tycon : Tycon; }
  | Sym_type_member { member : IMember; }
}

public class GlobalEnv 
  {
    static mutable types : Hashtable <string, Tycon>;
    static mutable macro_context : int;
    static macro_contexts : Hashtable <string, int>;
    static mutable imported_contexts : array <GlobalEnv>;
    static mutable macro_context_class : ITypeModifier;

    static this () {
      types <- Hashtable (2000);
      macro_context <- 0;
      macro_contexts <- Hashtable (100);
      imported_contexts <- null;
      Empty <- GlobalEnv ();
      Core <- Empty.AddOpenNamespace ("Nemerle.Core")
                   .AddOpenNamespace ("Nemerle.Core.Aliases");
    }

    open_namespaces : list <string>;
    current_namespace : string;
    namespace_aliases : SystemMap <string, string>;
    mutable macro_ctx_cache : int;

    public static AddType (name : string, t : Tycon) : void {
      match (types.Get (name)) {
        | Some (t') when t'.SameAs (t) => ()
        | Some (t') =>
          Message.error (t.GetLocation (), "redefinition of type `" + name + "'");
          Message.error (t'.GetLocation (), "first defined here")
        | None => 
          types.Add (name, t)
      }
    }
    
    expand_namespace_aliases (sym : string) : string {
      def ns = Util.get_ns (sym);
      if (ns == "") sym
      else
        match (namespace_aliases.Find (ns)) {
          | Some (r) => r + "." + sym.Substring (sym.LastIndexOf ('.') + 1)
          | None => sym
        }
    }

    // to be used by Tyinfo only
    internal DefineClass (parent : option <Tyinfo>,
                          attrs : list <Modifier>,
                          name : string,
                          typarms : PT.Typarms,
                          extends_list : list <PT.Type>) : ITypeModifier
    {
      def fullname = current_namespace + name;
      def idx = name.LastIndexOf ('.');
      def (namesp, name) = 
        if (idx == -1)
          ("", name)
        else
          (name.Substring (0, idx), name.Substring (idx + 1));
      def decl = PT.TD_class (name, attrs, typarms, extends_list, []);
      assert (Option.IsNone (parent) || namesp == "");
      def env = 
        match (parent) {
          | Some (par) =>
            assert (namesp == "");
            assert (this == par.env);
            this
          | None when namesp == "" => 
            this
          | None => 
            this.EnterIntoNamespace (current_namespace + namesp)
        };
      def tyinfo = Tyinfo (parent, None (), env.AddOpenNamespace (fullname), decl);
      AddType (fullname, tyinfo);
      tyinfo.FixupDefinedClass ();
      tyinfo
    }
    
    public DefineClass (attrs : list <Modifier>,
                        name : string,
                        typarms : PT.Typarms,
                        extendeds_list : list <PT.Type>) : ITypeModifier
    {
      DefineClass (None (), attrs, name, typarms, extendeds_list)
    }
    
    public DefineClass (attrs : list <Modifier>,
                        name : string,
                        extendeds_list : list <PT.Type>) : ITypeModifier
    {
      DefineClass (None (), attrs, name, PT.Typarms ([], []), extendeds_list)
    }

    public static LookupInternalType (name : string) : Tycon {
      match (LookupExactType (name)) {
        | Some (t) => t
        | None => Util.ice ("unbound internal type " + name)
      }
    }

    public static LookupExactType (name : string) : option <Tycon> {
      //Message.debug ("let " + name);
      match (types.Get (name)) {
        | (Some) as r => r
        | None =>
          def res = LibraryReferenceManager.LookupType (name);
          // this is just speed cache
          match (res) {
            | Some (tc) => types.Set (name, tc)
            | None => ()
          };
          res
      }
    }

    public GetType (name : string, from : Tycon) : Tycon
    {
      match (LookupType (name, from)) {
        | Some (r) => r
        | _ =>
          def idx = name.LastIndexOf ('.');
          if (idx == -1)
            Message.fatal_error ("unbound type name `" + name.Replace ('+', '.') + "'")
          else
            GetType (name.Substring (0, idx) + "+" + name.Substring (idx + 1), from)
      }
    }

    public LookupType (name : string) : option <Tycon> 
    {
      LookupType (name, null)
    }
    
    public LookupType (name : string, from : Tycon) : option <Tycon>
    {
      def name = expand_namespace_aliases (name);
      match (LookupExactType (name)) {
        | (Some (t)) as r when from == null || t.CanAccess (from) => r
        | _ =>
          def check_access (x) {
            | Some (t) when from == null || (t : Tycon).CanAccess (from) => x
            | _ => None ()
          };
          def collect (pref, res) {
            match ((res, check_access (LookupExactType (pref + "." + name)))) {
              | (x, None) | (None, x) => x
              | (Some (x), Some (y)) when x.SameAs (y) => res
              | (Some (x), Some (y)) =>
                Message.error ("type name `" + name + "' is ambiguous, it could be:");
                Message.error (x.GetLocation (), "   this declaration");
                Message.error (y.GetLocation (), "   or this declaration");
                res
            }
          };
          List.FoldLeft (current_namespace :: open_namespaces, None (), collect)
      }
    }
    
    public LookupSymbol (name : string) : list <Symbol> {
      def visited = Hashtable (10);
      def lookup_members (pref, acc) {
        match (LookupExactType (pref)) {
          | Some (t) when ! visited.Contains (t.GetId ()) => 
            def encapsulate (m : IMember, acc) {
              match (m.GetKind ()) {
                | MK_type => acc // nested types already added
                | _ => Sym_type_member (m) :: acc
              }
            };
            def members = t.LookupMember (name);
            visited.Add (t.GetId (), null);
            List.FoldLeft (members, acc, encapsulate)
          | _ => acc
        }
      };
      def types =
        match (LookupType (name)) {
          | Some (t) => [Sym_type (t)]
          | None => []
        };
      List.FoldLeft (open_namespaces, types, lookup_members);
    }

    public AddOpenNamespace (ns : string) : GlobalEnv
    {
      GlobalEnv (List.Append (open_namespaces, [ns]),
                 current_namespace, namespace_aliases)
    }

    public AddNamespaceAlias (short_name : string, long_name : string) : GlobalEnv
    {
      GlobalEnv (open_namespaces, current_namespace,
                 namespace_aliases.Add (short_name, long_name))
    }
    
    public EnterIntoNamespace (pref : string) : GlobalEnv
    {
      def new_name = current_namespace + pref;
      GlobalEnv (List.Append (open_namespaces, [new_name]), new_name + ".",
                 namespace_aliases)
    }

    this () 
    {
      current_namespace <- "";
      open_namespaces <- [];
      namespace_aliases <- SystemMap ();
      macro_ctx_cache <- -1;
    }

    this (o : list <string>, c : string, n : SystemMap <string, string>)
    {
      current_namespace <- c;
      open_namespaces <- o;
      namespace_aliases <- n;
      macro_ctx_cache <- -1;
    }

    /** Creates environment described by given string encoded for purpose
        of storing macro contexts */
    public this (coded : string)
    {
      mutable state <- 0;
      mutable last <- 0;
      mutable short <- "";
      
      current_namespace <- "";
      open_namespaces <- [];
      namespace_aliases <- SystemMap ();
      macro_ctx_cache <- -1;
      
      for (mutable i <- 1; i < coded.Length; ++i) {
        match ((state, coded[i])) {
          | (0, '&') =>
            current_namespace <- coded.Substring (0, i);
            state <- 1;
            last <- i + 1;
           
          | (1, '#') =>
            open_namespaces <- coded.Substring (last, i - last) :: open_namespaces;
            last <- i + 1;
            
          | (1, '&') =>
            open_namespaces <- coded.Substring (last, i - last) :: open_namespaces;
            state <- 2;
            last <- i + 1;

          | (2, '#') | (2, '&') =>
            namespace_aliases <- namespace_aliases.
              Add (short, coded.Substring (last, i - last));
            last <- i + 1;

          | (2, '=') =>
            short <- coded.Substring (last, i - last);
            last <- i + 1;

          | _ => ()
        }
      }
    }
    
    public GetCurrentNamespace () : string
    {
      current_namespace
    }

    // the format is Current.Namespace.&open.ns1#open.ns2&al1=alias.one#al2=alias.two&
    public GetMacroContext () : int
    {
      when (macro_ctx_cache == -1) {
        when (macro_context_class == null)
          prepare_macro_context_class ();
        
        def cmp (x, y) { System.String.CompareOrdinal (x,y) };
        def collect (k, v, acc) { k + "=" + v :: acc };

        def aliases = List.Sort (namespace_aliases.Fold (collect, []), cmp);
        def spaces = List.Sort (open_namespaces, cmp);
        def coded_al = NString.Concat ("#", aliases);
        def coded_ns = NString.Concat ("#", spaces);
        def coded = System.Text.StringBuilder (current_namespace + "&");
        ignore (coded.Append (coded_ns + "&"));
        ignore (coded.Append (coded_al + "&"));
        match (macro_contexts.Get (coded.ToString ())) {
          | None =>
            ++macro_context;
            macro_contexts.Add (coded.ToString (), macro_context);
            macro_ctx_cache <- macro_context  
          | Some (ctx) =>
            macro_ctx_cache <- ctx
        }
      };
      macro_ctx_cache
    }

    private static LiftMacroContexts () : Parsetree.Expr
    {
      def ar = array (macro_context);
      macro_contexts.Iter (fun (k, v) {ar[v - 1] <- k});
      def make_expr (s) {
        assert (s != null); 
        <[ $(s : string) ]>
      };
      <[ array [.. $(List.Map (List.FromArray (ar), make_expr))] ]>
    }

    private static prepare_macro_context_class () : void
    {
      def ty = GlobalEnv.Core.DefineClass ([Mod_internal ()], "_N_MacroContexts", []);
      
      ty.DefineField ([Mod_private (), Mod_static ()], 
                      "serialized", 
                      <[ type: array <string> ]>);
      ty.DefineField ([Mod_private (), Mod_static ()], 
                      "contexts", 
                      <[ type: array <Nemerle.Compiler.GlobalEnv> ]>);
      ty.DefineMethod ([Mod_static (), Mod_internal ()], <[ fundecl:
        Get (no : int) : Nemerle.Compiler.GlobalEnv
        {
          when (_N_MacroContexts.contexts[no - 1] == null)
            _N_MacroContexts.contexts[no - 1] <- 
                Nemerle.Compiler.GlobalEnv (_N_MacroContexts.serialized[no - 1]);
          _N_MacroContexts.contexts[no - 1]
        }
      ]>);
      ty.DefineMethod ([Mod_private ()], <[ fundecl: @this () : void {} ]>);

      macro_context_class <- ty;
    }

    internal static FinishMacroContextClass () : void
    {
      def ty = macro_context_class;
      when (ty != null) {
        ty.DefineMethod ([Mod_static ()], <[ fundecl:
          @this () : void
          {
            _N_MacroContexts.serialized <- $(LiftMacroContexts ());
            _N_MacroContexts.contexts <- array ($(macro_context : int));
          } 
        ]>);
        ty.Compile ();
      }
    }

    public static Empty : GlobalEnv;
    public static Core : GlobalEnv;
  }
} // ns
