/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

using Nemerle.Collections;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

  /** MACROS EXTENDING SYNTAX OF LANGUAGE */

  /** specialized macro for [if] condition with good warning messages,
      it performs typing of given expressions to check their type
      correctness
   */
  macro @if (cond, e1, e2)
  syntax ("if", "(", cond, ")", e1, Optional (";"), "else", e2) 
  {
    def tcond = ty_expr (Nemerle.Macros.ImplicitCTX (), cond);
    def bool_ty = <[ ttype: bool ]>;
    expect_type ("if condition", tcond, bool_ty);
    
    <[ 
      match ($(tcond : typed)) { 
        | true => $e1 
        | _ => $e2
      } 
    ]>
  }

  /** this macro provides convenient way to write a simple while loop,
      which performs execution of [body] parameter as long as
      [condition] is true
    */
  macro @while (cond, body)
  syntax ("while", "(", cond, ")", body) 
  {
    def loop = Nemerle.Macros.Symbol (Util.tmpname ("while_"));

    <[ 
      def $(loop : name) () : void {
        when ($cond) { $body; $(loop : name) () }
      }; 
      $(loop : name) (); 
    ]>
  }

  /** shortcut for [if (cond) body else ()] */
  macro @when (cond, body)
  syntax ("when", "(", cond, ")", body) 
  {
    <[ match ($cond) { | true => $body | _ => () } ]>
  }

  macro @for (init, cond, change, body)
  syntax ("for", "(", Optional (init), ";", Optional (cond), ";",
          Optional (change), ")", body) 
  {
    def init = if (init != null) init else <[ () ]>;
    def cond = if (cond != null) cond else <[ true ]>;
    def change = if (change != null) change else <[ () ]>;    

    def loop = Nemerle.Macros.Symbol (Util.tmpname ("for_"));
    
    <[ 
      $init;
      def $(loop : name) () : void {
        when ($cond) { $body; $change; $(loop : name) () }
      };
      $(loop : name) ();
    ]>
  }

  /** shortcut for [if (cond) () else body] */
  macro @unless (cond, body)
  syntax ("unless", "(", cond, ")", body) 
  {
    <[ match ($cond) { | false => $body | _ => () } ]>
  }

  /** macro providing C# 'using' functionality
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_8.asp  
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vclrfusingstatement.asp
   */
  macro @using (body, params args : array <expr>)
  syntax ("using", "(", args, ")", body) 
  {
    def maybe_valuetype_dispose (nm, typed_expr) {
      def tc = Tyutil.GetTypeTycon (Tyexpr.type_of (typed_expr));
      if (tc != null && tc.IsValueType)
        <[ ($(nm : name) :> System.IDisposable).Dispose () ]>
      else
        <[
          when ($(nm : name) != null)
            ($(nm : name) :> System.IDisposable).Dispose ()
        ]>
    };
    
    def len = args.Length;
    def store_exprs (i, preexprs, postexprs) {
      if (i < len) {
        def x = Macros.NewSymbol ();
        match (args[i]) {
          | <[ $(str : name) = $e ]> =>
            def ex = Tyexpr.ty_expr (Nemerle.Macros.ImplicitCTX (), e);            
           
            store_exprs (i + 1, <[ def $(str : name) = $(ex : typed) ]> :: preexprs, 
                         maybe_valuetype_dispose (str, ex) :: postexprs)
          | e =>
            def ex = Tyexpr.ty_expr (Nemerle.Macros.ImplicitCTX (), e);
            
            store_exprs (i + 1, <[ def $(x : name) = $(ex : typed) ]> :: preexprs,
                         maybe_valuetype_dispose (x, ex) :: postexprs)
        }
      }
      else
        (preexprs, postexprs)
    };

    def (preexps, postexps) = store_exprs (0, [], []);
    List.FoldLeft2 (preexps, postexps, <[ $body ]>, fun (pre, post, acc) {
      <[ $pre; try { $acc } finally { $post } ]>
    });
  }

  macro @lock (x, body)
  syntax ("lock", "(", x, ")", body)
  {
    <[ 
      System.Threading.Monitor.Enter ($x);
      try {
        $body
      } finally {
        System.Threading.Monitor.Exit ($x);
      }
    ]>
  }

  macro dowhile (cond, body) 
  syntax ("do", body, "while", "(", cond, ")") 
  {
    def loop = Nemerle.Macros.Symbol (Util.tmpname ("do_while_"));

    <[ 
      def $(loop : name) () {
        $body; 
        when ($cond) $(loop : name) ();
      };
      $(loop : name) ()
    ]>
  }

  /**
   * The 'foreach' macro introduces a construction equivalent
   * to C#'s 'foreach' keyword, iterating over a collection.
   */
  macro @foreach (iter : funparm, collection, body)
  syntax ("foreach", "(", iter, "in", collection, ")", body)
  {
    match (iter) {
      | <[ funparm: $(iname : name) : $ty ]> =>
        <[ 
          def enumerator = $collection.GetEnumerator ();
          def loop () {
            when (enumerator.MoveNext ()) {
              def $(iname : name) = (enumerator.Current :> $ty);
              $body;
              loop ();
            }
          };
          try {
            loop ()
          } finally {
            match (enumerator) {
              | (x : System.IDisposable) => x.Dispose ();
              | _ => ()
            }
          }
       ]>
      | _ =>
        Message.fatal_error ("iterator in foreach must be an identifier" +
                             "with optional type")
    }
  }

  macro ignore (e) 
  {
    <[ def _ = $e; () ]>
  }

  macro assert (cond, message = <[ "" ]>) 
  {
    match (cond) {
      | <[ false ]> =>
        // skip cond in this case so it gets 'a type
        <[ throw AssertionException ($(cond.loc.file : string), 
                                     $(cond.loc.line : int),
                                     "", $message) ]>
      | _ =>
        <[ unless ($cond) 
             throw AssertionException ($(cond.loc.file : string), 
                                       $(cond.loc.line : int),
                                       $(PrettyPrint.SprintExpr (None (), cond) : string),
                                       $message) ]>
    }
  }

  macro abort (message = <[ "" ]>) 
  {
    <[ throw AssertionException ($(message.loc.file : string), 
                                 $(message.loc.line : int), $message) ]>
  }

  /** MACROS EXTENDING TYPE SYSTEM OF LANGUAGE */

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
                       
  macro Record (par : TypeBuilder)
  {
    def make_ctor (base_ctor : IMember) {
      def base_ctor = (base_ctor :> IMethod);
      def (ctor_parms, base_call) =
        if (base_ctor == null)
          ([], <[ base () ]>)
        else {
          def pp = base_ctor.GetHeader ().parms;
          def callparms = List.Map (pp, fun (fp : Fun_parm) {
            <[ $(Macros.UseSiteSymbol (fp.name) : name) ]>
          });
          (List.Map (pp, fun (fp : Fun_parm) {
             def nm = Macros.UseSiteSymbol (fp.name);
             <[ funparm: $(nm : name) : $(fp.ty : typed) ]>
           }),
           <[ base (..$callparms) ]>)
        };

      def flds = par.GetFields (BindingFlags.DeclaredOnly %|
                                BindingFlags.Public %|
                                BindingFlags.NonPublic %|
                                BindingFlags.Instance);

      def collect (mem : IField, acc) {
        def n = Macros.UseSiteSymbol (mem.Name);
        def fp = <[ funparm: $(n : name) : $(mem.GetMemType () : typed) ]>;
        def ex = <[ this.$(n : name) = $(n : name) ]>;
        def (es, ps) = acc;
        (ex :: es, fp :: ps)
      };
      def (assigns, parms) = List.FoldLeft (flds, ([], []), collect);
      
      def body = <[ { ..$(base_call :: assigns) } ]>;
      body.loc = par.GetLocation ();
      
      def attrs = Modifiers (mods = 
        match (par.GetTydecl ()) {
          | TD_variant => NemerleAttributes.Protected
          | _ => NemerleAttributes.Public
        }, attrs = []);
        
      def parms = List.Append (ctor_parms, List.Rev (parms));
      def meth = <[ decl: ..$attrs this (..$parms) $body ]>;
      meth.loc = par.GetLocation ();
      meth
    };
      
    match (par.SuperClass ()) {
      | Some (baseti) =>
        def ctors = baseti.GetConstructors (BindingFlags.Instance %|
                                            BindingFlags.Public %|
                                            BindingFlags.NonPublic %|
                                            BindingFlags.DeclaredOnly);
        match (ctors) {
          | [] => 
            match (baseti.GetTydecl ()) {
              | TD_variant => par.Define (make_ctor (null))
              | _ =>
                Message.fatal_error ("type `" + baseti.GetFullName () + "' (base of `" + 
                                     par.GetFullName () +
                                     "') has no constructors, cannot "
                                     "generate default constructor")
            }
          | decls =>
            List.Iter (decls, fun (x) { par.Define (make_ctor (x)) })
        }
      | None =>
        par.Define (make_ctor (null))
    }
  }

  
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Field,
                       Inherited = false, AllowMultiple = false)]
  macro StaticInitializer (t : TypeBuilder, f : FieldBuilder, val)
  {
    def is_static = f.Attributes %&& NemerleAttributes.Static;
    def static_attr =
      if (is_static) BindingFlags.Static
      else BindingFlags.Instance;
    def mems = t.GetConstructors (static_attr %| BindingFlags.Public %|
                                  BindingFlags.NonPublic %|
                                  BindingFlags.DeclaredOnly);
    def fieldName = Macros.UseSiteSymbol (f.Name);
    def typeName = Macros.UseSiteSymbol (t.Name);

    def (init, base_ctor) =
      if (is_static)
        (<[ $(typeName : name).$(fieldName : name) = $val ]>, <[ () ]>)
      else
        (<[ this.$(fieldName : name) = $val ]>, <[ base () ]>);

    // given existing constructor, insert call to base constructor
    // at its beginning 
    def inject (ctor : NemerleMethod) {
      def bd = ctor.Body;
      def nbody =
        match (bd) {
          | <[ {.. $(e :: rest) } ]> =>
            match (e) {
              | <[ base (..$_) ]> => <[ $e; $init; {.. $rest } ]>
              | <[ this (..$_) ]> => bd
              | _ => <[ $base_ctor; $init; $bd ]>
            }
          | _ => <[ $base_ctor; $init; $bd ]>
        };
      ctor.Body = nbody
    };
    match (mems) {
      | [] =>
        if (is_static) 
          t.Define (<[ decl: static public this () { $init } ]>)
        else
          t.Define (<[ decl: public this () { $base_ctor; $init } ]>)
      | _ =>
        List.Iter ((mems :> list <NemerleMethod>), inject)
    }
  }
  
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Property,
                       Inherited = false, AllowMultiple = true)]
  macro PropertyEmbeddedField (t : TypeBuilder, p : PropertyBuilder, field_box)
  {
    match (field_box) { 
      | <[ fun (..$([val])) { ..$_ } ]> =>
        if (p.Attributes %&& NemerleAttributes.Static) {
          val.modifiers.mods |= NemerleAttributes.Static;
          t.Define (<[ decl: ..$(val.modifiers) $(val.name) : $(val.ty); ]>)
        }
        else
          t.Define (<[ decl: ..$(val.modifiers) $(val.name) : $(val.ty); ]>)
      | _ =>
        Message.fatal_error (field_box.loc, "malformed PropertyEmbeddedField (ICE?)")
    }
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Event,
                       Inherited = false, AllowMultiple = true)]
  macro EventEmbeddedField (t : TypeBuilder, p : EventBuilder, field_box)
  {
    match (field_box) { 
      | <[ fun (..$([val])) { ..$_ } ]> =>
        if (p.Attributes %&& NemerleAttributes.Static) {
          val.modifiers.mods |= NemerleAttributes.Static;
          t.Define (<[ decl: ..$(val.modifiers) $(val.name) : $(val.ty); ]>)
        }
        else
          t.Define (<[ decl: ..$(val.modifiers) $(val.name) : $(val.ty); ]>)
      | _ =>
        Message.fatal_error (field_box.loc, "malformed EventEmbeddedField (ICE?)")
    }
  }
}

namespace Nemerle.Compiler.Util {
  macro locate (l, body) {
    <[
      def pushpop = $l != null && $l != Located.default_loc;
      when (pushpop) Location_stack.push ($l);
      try { $body } finally { when (pushpop) Location_stack.pop () }
    ]>
  }
}

namespace Nemerle.Macros {


  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method,
                       Inherited = true, AllowMultiple = false)]
  macro Hygienic (_ : TypeBuilder, m : ParsedMethod) {
    m.Body = <[
      TypingContext.PushNewColor (TypingContext.MacroUseColor,
                                  TypingContext.MacroUseContext);
      def result = $(m.Body);
      TypingContext.PopColor ();
      result
    ]>;
  }


  macro DefineCTX (ctx) {
    <[ def $(Nemerle.Compiler.Macros.GetImplicitCTXName () : name) = $ctx ]>
  }

  macro ImplicitCTX () {
    <[ $(Nemerle.Compiler.Macros.GetImplicitCTXName () : name) ]>
  }  
  
  /** creates new symbol with given id and current global context */
  macro Symbol (id)
  {
    def nr = Nemerle.Macros.ImplicitCTX ().env.GetMacroContext ();
    <[ PT.Name.NameInCurrentColor (Nemerle.Utility.NString.Split ($id, array ['.']), 
                                   $("_N_MacroContexts" : dyn).Get ($(nr : int))) ]>
  }

  macro pretty_print_expr (exp, expand : bool)
  {
    def ctx = if (expand) Some (Nemerle.Macros.ImplicitCTX ()) else None ();
    PrettyPrint.PrintExpr (ctx, exp);
    <[ () ]>
  }
}

namespace Nemerle.Extensions {
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro TupleToString (t : TypeBuilder) {
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|          
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);
    def appends = 
      List.RevMap (flds, fun (x : IField) { 
        def nm = Macros.UseSiteSymbol (x.Name);
        <[ ignore (str.Append ($(nm : name).ToString ())); ]>
      });
    def body_seq =
      List.FoldLeft (List.Tail (appends), List.Head (appends) ::
                     [<[ ignore (str.Append (")")); str.ToString () ]>], fun (x, acc) {
        x :: <[ ignore (str.Append (", ")) ]> :: acc
      });
    def body_seq = <[ def str = System.Text.StringBuilder ("(") ]> :: body_seq;
    t.Define (<[ decl:
      public override ToString () : string { ..$body_seq }
    ]>);
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro StructuralEquality (t : TypeBuilder) {
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);
    def body = 
      List.FoldLeft (flds, <[ true ]>, fun (x : IField, acc) { 
        def nm = Macros.UseSiteSymbol (x.Name);
        <[ $acc && $(nm : name).Equals (tup.$(nm : name)) ]>
      });
    def tname = Macros.UseSiteSymbol (t.Name);
    def full = <[ if (o.GetType () == this.GetType ()){
                    def tup = (o :> $(tname : name));
                    $body
                  } else false ]>;
    t.Define (<[ decl:
      public override Equals (o : System.Object) : bool { $full }
    ]>);
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro StructuralHashCode (t : TypeBuilder) {
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|          
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);

    def body = 
      List.FoldLeft (flds, <[ 0 ]>, fun (x : IField, acc) {
        def nm = Macros.UseSiteSymbol (x.Name);
        <[ $acc %^ $(nm : name).GetHashCode () ]>
      });
    t.Define (<[ decl:
      public override GetHashCode () : int {
        $body
      }
    ]>);
  }
  
  /** MACROS, WHICH WE CAN DO BETTER THAN HASKELL */

  macro SelectFromTuple (k : int, n : int, tupl)
  {
    def symb = Macros.NewSymbol ();
    mutable tup = [];
    for (mutable i = n; i > 0; --i)
      if (i == k)
        tup = <[ pattern: $(symb : name) ]> :: tup
      else
        tup = <[ pattern: _ ]> :: tup;

    <[ def (.. $tup) = $tupl; $(symb : name) ]>
  }

  macro TupleMap (f, tup)
  {
    match (tup) {
      | <[ (.. $elms) ]> =>
        def mapped = List.Map (elms, fun (e) { <[ $f ($e) ]> });
        <[ (.. $mapped) ]>
      | _ => 
        Message.fatal_error ("'TupleMap' macro expects function and tuple")
      }
  }

  macro PrintTuple (tup, size : int)
  {
    def symbols = array (size);
    mutable pvars = [];
    for (mutable i = size - 1; i >= 0; --i) {
      symbols[i] = Macros.NewSymbol ();
      pvars = <[ pattern: $(symbols[i] : name) ]> :: pvars;
    };
    mutable exps = [];
    for (mutable i = size - 1; i >= 0; --i)
      exps = <[ System.Console.WriteLine ($(symbols[i] : name)) ]> :: exps;

    exps = <[ def (.. $pvars) = $tup ]> :: exps;
    <[ {.. $exps } ]>
  }

  macro PrintTupleTyped (tup)
  {
    match (type_of (ty_expr (Nemerle.Macros.ImplicitCTX (), tup))) {
      | T_prod (args) =>
        def size = List.Length (args);
        def symbols = array (size);
        mutable pvars = [];
        for (mutable i = size - 1; i >= 0; --i) {
          symbols[i] = Macros.NewSymbol ();
          pvars = <[ pattern: $(symbols[i] : name) ]> :: pvars;
        };
        mutable exps = [];
        for (mutable i = size - 1; i >= 0; --i)
          exps = <[ System.Console.WriteLine ($(symbols[i] : name)) ]> :: exps;
          
        exps = <[ def (.. $pvars) = $tup ]> :: exps;
        <[ {.. $exps } ]>
      | _ => 
        Message.fatal_error ("expected tuple")
    }
  }
} // end ns

namespace Nemerle.Diagnostics {

  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method)]
  macro Trace (_ : TypeBuilder, m : ParsedMethod, tracecall) {
    def line = Macros.UseSiteSymbol ("line");
    def file = Macros.UseSiteSymbol ("file");
    def meth = Macros.UseSiteSymbol ("method");
    def add (x) {
      | <[ {.. $seq } ]> =>
        def nseq = 
        List.Flatten (List.Map (seq, fun (e : Parsetree.Expr) { 
          [<[
             def $(line : name) = $(e.loc.line : int);
             $tracecall;
           ]>, e]
        }));
        <[ { ..$nseq } ]>
      | _ => x
    };
    def bod = Macros.TraverseExpr (None (), m.Body, add);
    m.Body = <[ 
      def $(file : name) = $(m.Body.loc.file : string);
      def $(meth : name) = $(m.Name : string);
      $bod;
    ]>
  }
}
