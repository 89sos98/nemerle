(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyexpr;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Tyexpr {

  variant Call_result
    {
      | CR_error { msg : string; }
      | CR_ok { call : Expr; sub : Subst; }
    }

  class Typing_error extends System.Exception
    {
      public msg : string;
      public this (s : string) { this.msg <- s; }
    }

  public type_of (expr : Expr) : Type {
    if (expr.expr_ty == null) Util.ice ()
    else expr.expr_ty;
  }
    
  fixup (expr : Expr, loc : Location, t : Type) : Expr 
    {
      expr.loc <- loc;
      expr.expr_ty <- t;
      expr
    }

  fixup (expr : Expr, t : Type) : Expr 
    {
      expr.loc <- Location_stack.top ();
      expr.expr_ty <- t;
      expr
    }

  public expect_type (name : string, expr : Expr, t : Type) : void {
    if (type_of (expr) >> t) ()
    else
      Message.error (expr.loc, name + " was expected to have type " + 
                               t.as_string () + " while it has " +
                               (type_of (expr)).as_string ())
  }

  closurise (env : Env, x : Decl) : bool
    {
      //Message.debug ("tryclo " + x.name + " = " + string_of_int (x.id));
      match (x.parent_fun) {
        | Some (d) =>
          def this_fn = Util.unsome (env.parent_fun);
          if (d.id == this_fn.id) false
          else
            if (x.in_closure) true
            else {
              //Message.debug ("clo " + x.name + " = " + string_of_int (x.id));
              x.in_closure <- true;
              def h = d.fun_header ();
              h.closure_vars <- x :: h.closure_vars;
              true
            }
        | None => false
      }
    }

  make_ref (env : Env, loc : Location, x : Decl) : Expr
    {
      match (x.kind) {
        | D_class_member (M_value) => ()
        | D_class_member (M_function {kind = FK_function}) => ()
        | D_class_member (M_function {kind = FK_ctor}) => ()
        | D_class_member (M_property {is_static = true}) => ()
        | D_class_member (_) =>
          Message.fatal_error ("`" + x.name + "' does not refer to value");
        | D_type (_) =>
          Message.fatal_error ("`" + x.name + "' does not refer to value");
        | _ => ()
      };
      def _ = closurise (env, x);

      if (x.ty == null) Util.ice ("null type " + x.name) else ();

      def t =
        match (x.kind) {
          | D_class_member (M_function {tyinfo = ti; id = id; kind = FK_ctor}) => 
            match (x.ty) {
              | T_fun (args, T_void) =>
                def ti =
                  match (ti.tydecl) {
                    | TD_variant_option => ti.enclosing_tyinfo ()
                    | _ => ti
                  };
                T_fun (args, ti.generic_type ()) /- ti.fresh_subst ()
              | _ => Util.ice ()
            }
          | D_class_member (M_function {header = h}) => 
            x.ty /- Tyvar.fresh_subst (h.typarms)
          | D_local_fun (h, _) =>
            x.ty /- Tyvar.fresh_subst (h.typarms)
          | _ => x.ty
        };
      fixup (E_ref (x), loc, t)
    }

  // given list of formal parms names and actual parms names,
  // reorder actuals to match formals
  reorder_named_parms (names : list (string), parms : list (Parm)) : list (Parm)
    {
      def is_named (p : Parm) : bool { p.name != "" };
      mutable seen_kw <- false;

      def loop (acc : list (Parm), names : list (string), 
                parms : list (Parm)) : list (Parm) {
        match ((parms, names)) {
          | (p :: ps, n :: ns) =>
            if (p.name == "")
              if (seen_kw)
                raise Typing_error ("unnamed parameters after named")
              else
                loop (p :: acc, ns, ps)
            else {
              seen_kw <- true;
              def lookup (parms : list (Parm)) : Parm * list (Parm) {
                match (parms) {
                  | p :: ps =>
                    if (p.name == n)
                      (p, ps)
                    else {
                      def (r, ps) = lookup (ps);
                      (r, p :: ps)
                    }
                  | [] =>
                    raise Typing_error ("keyword parameter `" + n + "' not found")
                }
              };
              def (p, ps) = lookup (parms);
              loop (p :: acc, ns, ps)
            }
          | ([], []) => List.rev (acc)
          | _ => Util.ice ()
        }
      };
      if (List.exists (is_named, parms))
        match (names) {
          | [] =>
            raise Typing_error ("named parameters given but formals' names cannot be inferred")
          | _ =>
            loop ([], names, parms)
        }
      else
        parms
    }

  // check if FN can be called with PARMS
  check_call_to (parms : list (Parm), fn : Expr) : Call_result
    {
      def check_arg (ctx : int * Subst, parm : Parm, ty : Type) : int * Subst
        {
          def (arg_no, sub) = ctx;
          match (Tyutil.unify (sub, type_of (parm.expr), ty, true)) {
            | Some (u) => (arg_no + 1, u)
            | None =>
              raise Typing_error ("in arg #" + string_of_int (arg_no) + " needed " +
                                  ty.as_string () + " got " +
                                  (type_of (parm.expr)).as_string ())
          }
        };
        
      
      def formal_names =
        {
          def from_header (h : Fun_header) : list (string) {
            List.map (fun (p : Fun_parm) : string { p.name }, h.parms)
          };
          match (fn) {
            | E_ref ({kind = D_local_fun (h, _)}) => 
              from_header (h)
            | E_ref ({kind = D_class_member (M_function {header = h})}) =>
              from_header (h)
            | E_method_ref (_, {header = h}) =>
              from_header (h)
            | _ => []
          }
        };

      match (Tyutil.top_expand (type_of (fn))) {
        | T_fun (args, ret) =>
          def args = Tyutil.fun_args (args);
          if (List.length (args) != List.length (parms))
            CR_error ("needed " + string_of_int (List.length (args)) + 
                      " parameters, got " + 
                      string_of_int (List.length (parms)))
          else
            try {
              def parms = reorder_named_parms (formal_names, parms);
              def (_, sub) =
                List.fold_left2 (check_arg, (1, Map.int_map ()), parms, args);
              def ex = E_call (fn, parms);
              ex.loc <- fn.loc;
              ex.expr_ty <- ret /- sub;
              CR_ok (ex, sub)
            } with x : Typing_error =>
              CR_error (x.msg)
          
        | _ =>
          CR_error ("called value has non-functional type " + 
                    (type_of (fn)).as_string ())
      }
    }

  resolve_overloaded_call (fncs : list (Expr), parms : list (Parm)) : Expr
    {
      match (fncs) { [] => Util.ice () | _ => () };
      def check_one (ctx : list (string) * list (Expr * Subst), fn : Expr) 
                    : list (string) * list (Expr * Subst)
        {
          def (errs, rets) = ctx;
          match (check_call_to (parms, fn)) {
            | CR_ok (ex, sub) => (errs, (ex, sub) :: rets)
            | CR_error (e) => ((e :: errs), rets)
          }
        };

      match (List.fold_left (check_one, ([], []), fncs)) {
        // special case (simple)
        | (_, [(x, sub)]) => 
          Tyvar.global_store (sub); 
          x
        | (p, []) =>
          Message.error ("typing error in call");
          def print_err (err : string) : void { Message.error ("  " + err) };
          // FIXME: include location of function that failed
          List.iter (print_err, p);
          raise Recovery ()
        // in general we look for set of maximal argument types
        | (_, l) =>
          def get_type (ex : Expr, s : Subst) : Type * (Expr * Subst) {
            match (ex) {
              | E_call (fn, _) =>
                match (Tyutil.top_expand (type_of (fn))) {
                  | T_fun (t1, _) => (t1, (ex, s))
                  | _ => Util.ice ()
                }
              | _ => Util.ice ()
            }
          };
          
          match (Tyutil.maximal_types (List.map (get_type, l))) {
            | [(_, (x, sub))] =>
              Tyvar.global_store (sub); 
              x
            | l =>
              def print_err (_ : Type, x : Expr * Subst) : void {
                match (x) {
                  | (E_call (E_ref (d), _), _) =>
                    // FIXME: we could do better
                    Message.error (d.loc, "    functional value of type " + d.ty.as_string ())
                  | (E_call (ex, _), _) =>
                    Message.error ("    functional value of type " + (type_of (ex)).as_string ())
                  | _ => Util.ice ()
                }
              };
              Message.error ("overloading resolution ambiguity between:");
              List.iter (print_err, l);
              raise Recovery ()
          }
      }
    }

  (**
   * Checks if a given property is defined in the expression
   *)
  has_property (loc : Location, o : Expr, mem : string) : bool
  {
    def collect_from (ctx : list (Expr) * Int_map (int), t : Type) 
                      : list (Expr) * Int_map (int)
    {
      def t' = Tyutil.top_expand (t);
      def (acc, visited) = ctx;

      match (t') {
        | T_app (ti, args) =>
          def subst = ti.make_subst (args);
          if (visited.mem (ti.id)) ctx
          else {
            def visited = visited.add (ti.id, 0);
            def mem_ref (ex : Expr, m : Class_member) : Expr {
              fixup (ex, loc, ti.member_type (m) /- subst)
            };
            match (ti.lookup_property (mem)) {
              | Some (p) => (mem_ref (E_property_ref (o, p), p) :: acc, visited)              
              | _ => ctx
            }                      
          }

        | T_var (tv) =>
          if (visited.mem (tv.id)) ctx
          else {
            def visited = visited.add (tv.id, 0);
            def types = Tyvar.constraints (tv);
            List.fold_left (collect_from, (acc, visited), types)
          }

        | _ => ctx
      }
    };

    match (collect_from (([], Map.int_map ()), type_of (o))) {
      | ([], _) => false
      | _ => true
    }  
  }
  

  // lookup member MEM in type_of (O)
  // return list of how we can call it
  lookup_member (loc : Location, o : Expr, mem : string) : list (Expr)
    {
      mutable problem <- "???";
      
      def collect_from (ctx : list (Expr) * Int_map (int), t : Type) 
                       : list (Expr) * Int_map (int)
        {
          def t' = Tyutil.top_expand (t);
          def (acc, visited) = ctx;
          match (t') {
            | T_app (ti, args) =>
              def subst = ti.make_subst (args);
              if (visited.mem (ti.id)) ctx
              else {
                def visited = visited.add (ti.id, 0);
                def mem_ref (ex : Expr, m : Class_member) : Expr {
                  fixup (ex, loc, ti.member_type (m) /- subst)
                };
                match (ti.lookup_field (mem)) {
                  | Some (f) => 
                    (mem_ref (E_field_ref (o, f), f) :: acc, visited)
                   
                  | None =>
                    match (ti.lookup_method (mem)) {
                      | [] =>
                        match (ti.lookup_property (mem)) {
                          | Some (p) =>
                            (mem_ref (E_property_ref (o, p), p) :: acc, visited)
                          
                          | _ =>
                            problem <- "unbound member `" + mem + "' in type `" + 
                                       ti.fullname () + "'";
                            ctx
                        }                      
                      | l =>
                        def make_meth (m : M_function) : Expr
                          {
                            def ex = mem_ref (E_method_ref (o, m), m);
                            def sub = Tyvar.fresh_subst (m.header.typarms);
                            ex.expr_ty <- type_of (ex) /- sub;
                            ex
                          };
                        (List.append (List.map (make_meth, l), acc), visited)
                    }
                }
              }

            | T_var (tv) =>
              if (visited.mem (tv.id)) ctx
              else {
                def visited = visited.add (tv.id, 0);
                def types = Tyvar.constraints (tv);
                def ctx = List.fold_left (collect_from, (acc, visited), types);
                match (ctx) {
                  | ([], _) =>
                    problem <- "no constrain of " + t.as_string () + 
                               " provides member `" + mem + "'";
                    ctx
                  | _ => ctx
                }
              }
              
            | T_ref (t) =>
              collect_from (ctx, t) // FIXME: this is a quick hack for Kamil
              
            | _ =>
              problem <- "type `" + t.as_string () + "' was expected to be class";
              ctx
          }
        };

      match (collect_from (([], Map.int_map ()), type_of (o))) {
        | ([], _) =>
          Message.fatal_error (problem)
        | (x, _) => x
      }
    }


  is_a_field (loc : Location, o : Expr, fld : string) : bool {
    match (lookup_member (loc, o, fld)) {
      | [E_field_ref] => true
      | _ => false
    }
  }

  is_a_property (loc : Location, o : Expr, fld : string) : bool {
    match (lookup_member (loc, o, fld)) {
      | [E_property_ref] => true
      | _ => false
    }
  }
 
  // wrapper over lookup_member to find exactly one matching field 
  // and otherwise bailout
  public lookup_field (loc : Location, o : Expr, fld : string) : E_field_ref {
    match (lookup_member (loc, o, fld)) {
      | [(E_field_ref) as x] => x
      | _ => Util.ice ()
    }
  }

  // wrapper over lookup_member to find exactly one matching property
  // and otherwise bailout
  lookup_property (loc : Location, o : Expr, fld : string) : E_property_ref {
    match (lookup_member (loc, o, fld)) {
      | [(E_property_ref) as x] => x
      | _ => Util.ice ()
    }
  }
          
  public class CTX
    {
      public this_ptr_decl : option (Decl);
      public in_ctor : bool;
      public env : Env;
      public tenv : Tyvar.TEnv;

      public this (this_ptr_decl : option (Decl),
                   in_ctor : bool, env : Env, tenv : Tyvar.TEnv)
        {
          this.this_ptr_decl <- this_ptr_decl;
          this.in_ctor <- in_ctor;
          this.env <- env;
          this.tenv <- tenv;
        }

      public with_env (e : Env) : CTX {
        CTX (this.this_ptr_decl, this.in_ctor, e, this.tenv)
      }
        
      public with_tenv (e : Tyvar.TEnv) : CTX {
        CTX (this.this_ptr_decl, this.in_ctor, this.env, e)
      }
    }

  // given an expression return list of symbols it can expand to (so we can
  // later call resolve_overloaded_call)
  make_callables (ctx : CTX, fnc : PT.Expr) : list (Expr)
    {
      def fnc = convert_member_to_qid (ctx, fnc);
      
      def is_ctor (d : Decl) {
        match (d.kind) {
          | D_class_member (M_function (_, FK_ctor, _)) => true
          | _ => false
        }
      };
      
      match (fnc) {
        | PT.E_ref (n) =>
          match (ctx.env.bare_lookup (n)) {
            | [] =>
              Message.fatal_error ("unbound symbol `" + n + "'")

            | l =>
              def convert_ctor (acc : list (Decl), d : Decl) : list (Decl) {
                match (d.kind) {
                  | D_type =>
                    def decls = ctx.env.bare_lookup (d.name + "..ctor");
                    List.append (List.filter (is_ctor, decls), acc)
                  | _ => d :: acc
                }
              };
              match (List.fold_left (convert_ctor, [], l)) {
                | [] => 
                  Message.fatal_error ("type `" + n + "' has no constructors")
                | decls => 
                  List.map (fun (x : Decl) : Expr { make_ref (ctx.env, fnc.loc, x) }, decls)
              }
          }
            
        | PT.E_member (o, PT.SS_string (mem)) =>
          lookup_member (fnc.loc, ty_expr (ctx, o), mem)

        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_base =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = T_app (ti, _)}); in_ctor = true} =>
              match (ti.superclass ()) {
                | Some (baseti) =>
                  def decls = ctx.env.bare_lookup (baseti.fullname () + "..ctor");
                  match (List.filter (is_ctor, decls)) {
                    | [] => 
                      Message.fatal_error ("type `" + baseti.fullname () + "' has no constructors")
                    | decls => 
                      def mkbase (d : Decl) {
                        def e = E_base ();
                        e.expr_ty <- d.ty /- ti.subtyping_subst (baseti);
                        e.loc <- fnc.loc;
                        e
                      };
                      List.map (mkbase, decls)
                  }
                | None =>
                  Message.fatal_error ("class " + ti.fullname () + " has no base class")
              }
            | _ => 
              Message.fatal_error ("`base' used outside constructor")
          }

        | x =>
          [ty_expr (ctx, x)]
      }
    }

  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.E_match) : Expr * Type
    {
      def matched_value = ty_expr (ctx, mtch.expr);
    
      def do_case (acc : option (Type) * list (Match_case), 
                   c : PT.Match_case) : option (Type) * list (Match_case)
        {
          def (pat, pat_env) = Typattern.ty_patterns (ctx, type_of (matched_value), c.patterns);
          def body = ty_expr (ctx.with_env (pat_env), c.body);
          match (acc) {
            | (Some (t), l) =>
              match (Tyutil.unify_branches (t, type_of (body))) {
                | Some (t') => (Some (t'), Match_case (pat, body) :: l)
                | None =>
                  expect_type ("match case body", body, t);
                  Util.ice () // not reached
              }
            | (None, l) =>
              (Some (type_of (body)), Match_case (pat, body) :: l)
          }
        };

      match (List.fold_left (do_case, (None (), []), mtch.cases)) {
        | (Some (t), mcs') =>
          def mcs = List.rev (mcs');
          Typattern.check_matching (mcs);
          (E_match (matched_value, mcs), t)
        | (None, _) =>
          Message.fatal_error ("cannot have empty match construct");
      }
    }

  ty_letfun (ctx : CTX, fs : list (PT.Function_decl)) : list (Function_decl) * Env
    {
      def add_fun (acc : Env * list (Decl), d : PT.Function_decl) : Env * list (Decl)
        {
          def (env, ds) = acc;
          
          def this_fn = Util.unsome (env.parent_fun);
          def pars =
            match (this_fn) {
              | {kind = D_local_fun (_, pars)} => this_fn :: pars
              | {kind = D_class_member (M_function)} => [this_fn]
              | _ => Util.ice ()
            };
          def h = d.header;
          def (tenv, typarms) = ctx.tenv.add_typarms (env, h.typarms);
          def mkparm (p : PT.Fun_parm) : Fun_parm {
            Fun_parm (loc = p.loc, name = p.name, ty = tenv.bind (env, p.ty), decl = null)
          };
          def h' = Fun_header (
             ret_type = tenv.bind (env, h.ret_type),
             typarms = typarms,
             name = h.name,
             parms = List.map (mkparm, h.parms),
             id = Util.next_id (),
             closure_vars = [],
             tenv = tenv,
             loc = h.loc);
          
          def (env, d) =
            env.add_local (d.header.name, D_local_fun (h', pars), Tyutil.fun_type (h'));
            
          (env, d :: ds)
        };
        
      def (env', decls) = List.fold_left (add_fun, (ctx.env, []), fs);
      def do_fun (d : PT.Function_decl, dc : Decl) : Function_decl
        {
          def env = env'.copy ();
          env.parent_fun <- Some (dc);
          match (dc.kind) {
            | D_local_fun (h, _) =>
              Function_decl (dc, ty_function (ctx.with_env (env), h, d.body))
            | _ => Util.ice ()
          }
        };
      (List.map2 (do_fun, fs, List.rev (decls)), env')
    }

  ty_sequence (ctx : CTX, l : list (PT.Expr)) : Expr
    {
      def go () : Expr {
        match (l) {
          | [x] => ty_expr (ctx, x)

          | PT.E_letfun (fs) :: xs =>
            def (fs', env') = ty_letfun (ctx, fs);
            def body = ty_sequence (ctx.with_env (env'), xs);
            fixup (E_letfun (fs', body), type_of (body))

          | (PT.E_let) as x :: xs =>
            def val = ty_expr (ctx, x.val);
            def name = match (x.name) {
              | PT.SS_string (n) => n
              | _ => 
                Message.fatal_error ("$ operator used outside quotation <[ ... ]> context")
            };
            def (env', decl) = ctx.env.add_local (name, D_local_value(), type_of (val));
            decl.is_ref <- x.is_ref;
            def body = ty_sequence (ctx.with_env (env'), xs);
            fixup (E_let (decl, val, body), type_of (body))

          | PT.E_letpat (p, v) :: xs =>
            def body = PT.E_sequence (xs);
            def mtch = PT.E_match (v, [PT.Match_case ([(p, None ())], body)]);
            body.loc <- (List.head (xs)).loc;
            mtch.loc <- p.loc;
            ty_expr (ctx, mtch)
            
          | x :: xs =>
            def ex = ty_expr (ctx, x);
            def t = type_of (ex);
            if (t >> T_void ()) {
              def tl = ty_sequence (ctx, xs);
              fixup (E_sequence (ex, tl), type_of (tl))
            } else {
              Message.warning ("ignored computed value of type " + t.as_string ());
              Message.hint ("use def _ = ... ; to avoid the warning");
              
              def tmp = "_N_ign" + string_of_int (Util.next_id ());
              def (env', decl) = ctx.env.add_local (tmp, D_local_value (), type_of (ex));
              def body = ty_sequence (ctx.with_env (env'), xs);
              fixup (E_let (decl, ex, body), type_of (body))
            }
          | [] => Util.ice ("empty sequence")
        }
      };
        
      Util.locate ((List.head (l)).loc, go)
    }

  public ty_literal (ctx : CTX, l : Literal) : Type {
    match (l) {
      | L_void => T_void ()
      | L_null => Tyvar.free_variable ()
      | L_int => Tyutil.make_tapp (ctx.env, "Nemerle.Core.Aliases.int")
      | L_char => Tyutil.make_tapp (ctx.env, "Nemerle.Core.Aliases.char")
      | L_string => Tyutil.make_tapp (ctx.env, "Nemerle.Core.Aliases.string")
      | L_float => Tyutil.make_tapp (ctx.env, "Nemerle.Core.Aliases.float")
      | L_bool => Tyutil.make_tapp (ctx.env, "Nemerle.Core.Aliases.bool")
    }
  }

  convert_member_to_qid (ctx : CTX, expr : PT.Expr) : PT.Expr {
    def ret =
      match (expr) {
        | PT.E_member (obj, PT.SS_string (member_name)) =>
          match (convert_member_to_qid (ctx, obj)) {
            | PT.E_ref (n) =>
              def is_value (x : Decl) : bool {
                match (x.kind) {
                  | D_type => false
                  | _ => true
                }
              };

              if (!List.exists (is_value, ctx.env.bare_lookup (n)))
                PT.E_ref (n + "." + member_name)
              else
                expr
            | x => PT.E_member (x, PT.SS_string (member_name))
          }
        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator used outside quotation <[ ... ]> context")
        | _ => expr
      };
    ret.loc <- expr.loc;
    ret
  }

  public ty_expr (ctx : CTX, expr : PT.Expr) : Expr {
    def do_typing () : Expr * Type {
      def restart (e : PT.Expr) : Expr * Type {
        def ex = ty_expr (ctx, e);
        (ex, type_of (ex))
      };
      def bind_ty (t : PT.Type) : Type {
        ctx.tenv.bind (ctx.env, t)
      };

      def make_cons (e1 : PT.Expr, e2 : PT.Expr) : PT.Expr {
        def r = PT.E_ref ("Cons");  // FIXME
        def c = PT.E_call (r, [PT.Parm (e1); PT.Parm (e2)]);
        r.loc <- e1.loc;
        c.loc <- e1.loc;
        c
      };

      def make_nil () : PT.Expr {
        def r = PT.E_ref ("Nil");  // FIXME
        def c = PT.E_call (r, []);
        r.loc <- Location_stack.top ();
        c.loc <- Location_stack.top ();
        c
      };

      def expr = MacroRegistry.expand_macro (expr);

      match (expr) {
        // this doesn't make much sense I hope
        | PT.E_let => Message.fatal_error ("let binding not followed by any expression")
        | PT.E_letpat => Message.fatal_error ("letpat binding not followed by any expression")
        | PT.E_letfun => Message.fatal_error ("letfun binding not followed by any expression")
            
        | PT.E_lambda (d) =>
          def rf = PT.E_ref (d.header.name);
          def lf = PT.E_letfun ([d]);
          def sq = PT.E_sequence ([lf; rf]);
          rf.loc <- expr.loc;
          lf.loc <- expr.loc;
          sq.loc <- expr.loc;
          restart (sq)

        | PT.E_list (lst) =>
          def mklst (lst : list (PT.Expr)) : PT.Expr {
            match (lst) {
              | x :: xs => make_cons (x, mklst (xs))
              | [] => make_nil ()
            }
          };
          restart (mklst (lst))

        | PT.E_list_cons (e1, e2) =>
          restart (make_cons (e1, e2))
          
        | PT.E_mkarray (lst) =>
          def (typed_initializers, array_type) =
            match (lst) {
              | [] => (E_mkarray ([]), T_array (Tyvar.free_variable ()))
              | head :: _ =>
                def typed_head = ty_expr (ctx, head);
                def array_type = type_of (typed_head);
                def type_array_initializers (initializers : list (PT.Expr)) : list (Expr) {
                  match (initializers) {
                    | [] => []
                    | initializer :: rest => 
                      def typed_initializer = ty_expr (ctx, initializer);
                      expect_type ("array initializer", typed_initializer, array_type);
                      typed_initializer :: type_array_initializers (rest)
                  }
                };
                (E_mkarray (type_array_initializers (lst)), T_array (array_type))
            };          
          def fresh_name = "_N_array_initializer_" + string_of_int (Util.next_id ());
          def (env', decl) = ctx.env.add_local (fresh_name, D_local_value (), array_type);
          decl.is_ref <- false;
          def array_as_let = E_let (decl, typed_initializers, E_ref (decl));
          array_as_let.loc <- expr.loc;
          (array_as_let, array_type)

        // FIXME: allow for multi-dimensional indexers
        | PT.E_indexer (obj, args) =>
          def ty_args (arg : PT.Expr) : Expr {
            ty_expr (ctx, arg);
          };
        
          def typed_obj = ty_expr (ctx, obj);                    
          def typed_args = List.map (ty_args, args);
          
          match (typed_obj.expr_ty) {
            | T_array (indexer_over_type) =>
              (* indexers over arrays *)              
              def typed_index = 
                match (typed_args) {
                  | [index] => index
                  | [] => Message.fatal_error ("empty indexer applied to indexer type")                  
                  // FIXME: allow for multi-dimensional indexers
                  | _ => Message.fatal_error ("multi-dimensional indexers not supported yet") 
                };
              expect_type ("indexer type", typed_index, Tyutil.make_tapp (ctx.env, "Nemerle.Core.Aliases.int"));
              (E_indexer (indexer_over_type, typed_obj, [typed_index]), indexer_over_type)

            | T_app (ti, args) =>
              (* indexers over the Item or Chars property *)            
              def check_for_indexer_property (prop_name : string) : option (Expr * Type) {
                if (has_property (expr.loc, typed_obj, prop_name)) {
                  def ex = lookup_property (expr.loc, typed_obj, prop_name);
                  def indexer_over_type = ex.prop.ty;

                (** FIXME: add type checking and overloading verification
                  if (List.length (typed_args) != List.length (ex.prop.indexer_parameters))
                    Message.fatal_error (
                      "wrong arity of the " + prop_name + " indexer application (have " +
                      string_of_int (List.length (typed_args)) + ", expected " +
                      string_of_int (List.length (ex.prop.indexer_parameters)) + 
                      " parameters)"
                    )
                  else ();
                *)

                  Some ((E_indexer (indexer_over_type, typed_obj, typed_args), indexer_over_type))
                }
                else None ()
              };
              
              match (check_for_indexer_property ("Chars")) {
                | Some (e) => e
                | None => 
                  match (check_for_indexer_property ("Item")) {
                    | Some (e) => e
                    | None => 
                      Message.fatal_error ("indexer applied to non-indexer type (Chars or Item property required)") 
                  }                
              }
            | _ =>
              Message.fatal_error ("indexer applied to non-indexer type (Chars or Item property required): " +
                Tyutil.string_of_type (typed_obj.expr_ty))
          }
                        
        | (PT.E_try_with) as x =>
          def b = ty_expr (ctx, x.body);
          def exn = match (x.exn) {
            | PT.SS_string (e) => e
            | _ =>
              Message.fatal_error ("$ operator used outside quotation <[ ... ]> context")
          };
          def (env', decl) = ctx.env.add_local (exn, D_exn (), bind_ty (x.exn_ty));
          def h = ty_expr (ctx.with_env (env'), x.handler);
          match (Tyutil.unify_branches (type_of (h), type_of (b))) {
            | Some (t) =>
              (E_try_with (b, decl, h), t)
            | None =>
              Message.fatal_error (h.loc, 
                                   "try...with body has type " + 
                                   (type_of (b)).as_string () +
                                   " while the handler has type " + 
                                   (type_of (h)).as_string ())
          }

        | PT.E_try_finally (e1, e2) =>
          def e1 = ty_expr (ctx, e1);
          def e2 = ty_expr (ctx, e2); 
          expect_type ("try...finally handler", e2, T_void ());
          (E_try_finally (e1, e2), type_of (e1))

        | PT.E_type_conversion (e, t) =>
          // FIXME shall we check sth here ?
          def t = bind_ty (t);
          (E_type_conversion (ty_expr (ctx, e), t), t)
          
        | PT.E_type_enforcement (e, t) =>
          def ex = ty_expr (ctx, e);
          def t = bind_ty (t);
          expect_type ("type-enforced expression", ex, t);
          (E_type_enforcement (ex, t), t)

        | PT.E_ref (n) =>
          def ex =
            match (ctx.env.bare_lookup (n)) {
              | [] =>
                Message.fatal_error ("unbound symbol `" + n + "'")

              | [x] => make_ref (ctx.env, expr.loc, x)

              | l =>
                def print (d : Decl) : void { Message.error(d.loc, "  - this") };
                Message.error ("name `" + n + "' is ambiguous:");
                List.iter (print, l);
                raise Recovery ()
            };
          (ex, type_of (ex))

        | PT.E_member =>
          match (convert_member_to_qid (ctx, expr)) {
            | PT.E_member (o, PT.SS_string (fld_or_prop)) =>
              def tye = ty_expr (ctx, o);
              if (is_a_field (expr.loc, tye, fld_or_prop)) {
                def ex = lookup_field (expr.loc, tye, fld_or_prop);
                ((ex : Expr), type_of (ex))          
              }
              else if (is_a_property (expr.loc, tye, fld_or_prop)) {
                def ex = lookup_property (expr.loc, tye, fld_or_prop);
                ((ex : Expr), type_of (ex))          
              }
              else {
                // FIXME: better error message when is it for example multibound field
                Message.fatal_error ("member `" + fld_or_prop + 
                                      "' was expected to be a field or a property")
              }
            | PT.E_member (_, _) =>
               Message.fatal_error ("$ operator outside quotation <[ ... ]> context")
            | e => restart (e)
          }

        | PT.E_call (fnc, parms) =>
          def fp (p : PT.Parm) : Parm
            {
              def ex = ty_expr (ctx, p.expr);
              Parm (p.is_ref, ex, p.name)
            };
          def parms = List.map (fp, parms);
          def fncs = make_callables (ctx, fnc);
          def ex = resolve_overloaded_call (fncs, parms);
          def res (v : int) : Expr * Type { (E_literal (L_int (v)), type_of (ex)) };
          match (ex) {
            | E_call (E_ref ({kind = D_class_member (M_function {body = FB_extern (op)})}), 
                      [{expr = E_literal (L_int (x1))}; {expr = E_literal (L_int (x2))}]) =>
              match (op) {
                | "%op+" => res (x1 + x2)
                | "%op-" => res (x1 - x2)
                | "%op/" => res (x1 / x2)
                | "%op%" => res (x1 % x2)
                | "%op*" => res (x1 * x2)
                | _ => (ex, type_of (ex))
              }
              
            | E_call (E_ref ({kind = D_class_member (M_function {body = FB_extern (op)})}), 
                             [{expr = E_literal (L_int (x))}]) =>
              match (op) {
                | "%op+" => res (x)
                | "%op-" => res (-x)
                | _ => (ex, type_of (ex))
              }
            | _ => (ex, type_of (ex))
          }

        | PT.E_assign (e1, e2) =>
          def e1 = ty_expr (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("assigned value", e2, type_of (e1));
          def is_lval =
            match (e1) {
              | E_ref (d) => d.is_ref
              | E_field_ref (E_this, mem) => 
                if (ctx.in_ctor) true else mem.is_ref
              | E_field_ref (_, mem) => mem.is_ref
              | E_property_ref (_, {set_methods = []}) => false
              | E_property_ref (_, {set_methods = _}) => true
              | E_indexer => true //FIXME: are all the indexers writeable?
              | _ => false
            };
          if (is_lval) () else Message.error ("assignment to read-only location");
          (E_assign (e1, e2), T_void ())

        | PT.E_raise (e) =>
          def ex = ty_expr (ctx, e);
          def exn_ty = Tyutil.make_tapp (ctx.env, "System.Exception");
          expect_type ("raised value", ex, exn_ty);
          (E_raise (ex), Tyvar.free_variable ())

        | PT.E_literal (l) => 
          (E_literal (l), ty_literal (ctx, l))

        | PT.E_this => 
          match (ctx.this_ptr_decl) {
            | Some (d) =>
              def e =
                if (closurise (ctx.env, d)) E_ref (d)
                else E_this ();
              (e, d.ty)
            | None =>
              Message.error ("`this' used outside method");
              (E_literal (L_null ()), Tyvar.free_variable ())
          }

        | PT.E_sequence ([]) =>
          (E_literal (L_void ()), T_void ())
        
        | PT.E_sequence (l) =>
          def ex = ty_sequence (ctx, l);
          (ex, type_of (ex))

        | PT.E_tuple (l) =>
          def self (e : PT.Expr) : Expr { ty_expr (ctx, e) };
          def parms = List.map (self, l);
          (E_tuple (parms), T_prod (List.map (type_of, parms)))

        | (PT.E_match) as m => ty_match (ctx, m)

	| PT.E_quoted_expr (e) => 
	  def b = ty_expr (ctx, Macros.quoted_expr (e));
	  (b, type_of (b))

	| PT.E_quoted_patt (e) => 
	  def b = ty_expr (ctx, Macros.quoted_pattern (e));
	  (b, type_of (b))

	| PT.E_quoted_type (e) => 
	  def b = ty_expr (ctx, Macros.quoted_type (e));
	  (b, type_of (b))

        | PT.E_base =>
	  Message.fatal_error ("`base' can be only used to call base class constructor")

	| PT.E_unquoted | PT.E_unquoted_patt => 
	  Message.fatal_error ("$ macro keyword used in regular expression")

        | PT.E_expr_list =>  
          Util.ice ("List of expression parameters out of any construct")
      }
    };

    def (ret, expr_ty) = 
      try
        Util.locate (expr.loc, do_typing)
      with x : Recovery => 
        (E_literal (L_null ()), Tyvar.free_variable ());
    fixup (ret, expr.loc, expr_ty)
  }

  ty_function (ctx : CTX, h : Fun_header, b : Fun_body) : Fun_body
    {
      def add_parm (env : Env, p : Fun_parm) : Env {
        Util.locate (p.loc, fun () : Env { 
                              def (env, d) = env.add_local (p.name, D_fun_parm (), p.ty);
                              p.decl <- d;
                              env
                           })
      };
      def (de_tuple, env') = 
        match (h.parms) {
          | [single_parm] =>
            // We need to convert things like:
            // foo (x : int * int) : int { bar } 
            //    ===>
            // foo (_1 : int, _2 : int) : int { def x = (_1, _2); bar }
            // To be consistent.
            match (Tyutil.top_expand (single_parm.ty)) {
              | T_prod (types) =>
                mutable parms <- [];
                def mkparm (env : Env, t : Type) : Env {
                  def name = "_N_tuple_arg_" + string_of_int (Util.next_id ());
                  def (env, d) = env.add_local (name, D_fun_parm (), t);
                  def fp = Fun_parm (loc = single_parm.loc, 
                                     name = name,
                                     ty = t,
                                     decl = d);
                  parms <- fp :: parms;
                  env
                };
                def env = List.fold_left (mkparm, ctx.env, types);
                def (env, decl) = env.add_local (single_parm.name, D_local_value (), single_parm.ty);
                h.parms <- List.rev (parms);
                def mkref (p : Fun_parm) : Expr { 
                  fixup (E_ref (p.decl), p.loc, p.ty)
                };
                def val = fixup (E_tuple (List.map (mkref, h.parms)), 
                                 single_parm.loc, single_parm.ty);
                (Some ((decl, val)), env)
              | _ => 
                (None (), List.fold_left (add_parm, ctx.env, h.parms))
            }
          | _ => 
            (None (), List.fold_left (add_parm, ctx.env, h.parms))
        };
      match (b) {
        | FB_parsed_expr (e) => 
          def ctx = (ctx.with_env (env')).with_tenv (h.tenv);
          def e' = ty_expr (ctx, e);
          def e' =
            match (de_tuple) {
              | Some ((d, v)) => fixup (E_let (d, v, e'), v.loc, type_of (e'))
              | None => e'
            };
          if (type_of (e') >> h.ret_type) ()
          else
            Message.error (e.loc, "function return type was declared to be " +
                                  h.ret_type.as_string() + " while it is " +
                                  (type_of (e')).as_string ());
          FB_typed_expr (e')
        | FB_typed_expr => Util.ice ()
        | FB_extern => b
        | FB_abstract => b
      }
    }
    
  ty_function (ctx : CTX, h : Fun_header, b : PT.Expr) : Expr {
    match (ty_function (ctx, h, FB_parsed_expr (b))) {
      | FB_typed_expr (e) => e
      | _ => Util.ice ()
    }
  }

  bind_impl (env : Env, fd : Decl, name : string) : Decl
    {
      def is_method (d : Decl) : bool {
        match (d.kind) {
          | D_class_member (M_function {kind = FK_iface_method}) => true
          | _ => false
        }
      };
        
      def ti = 
        match (fd.kind) {
          | D_class_member ((M_function) as f) => f.tyinfo
          | _ => Util.ice ()  
        };

      def is_correct_method (d : Decl) : bool {
        match (d.kind) {
          | D_class_member ((M_function) as f') =>
            fd.ty >> (d.ty /- ti.subtyping_subst (f'.tyinfo))
          | _ => Util.ice ()
        }
      };

      match (List.filter (is_method, env.bare_lookup (name))) {
        | [] =>
          Message.fatal_error ("unbound interface method `" + name + "'")
        | syms =>
          match (List.filter (is_correct_method, syms)) {
            | [] =>
              Message.fatal_error ("none of type signatures of interface method `" + 
                                   name + "' matches `" + fd.name + "'")
            | [x] => x
            | _ =>
              // FIXME: not quite sure
              Message.fatal_error ("more then one type signature of interface method `" + 
                                   name + "' matches `" + fd.name + "'")
          }
      }
    }

  (** 
   * Walk through members of given [Tyinfo] object.  Type all 
   * declarations found.
   *
   * <remarks>
   *   Typing generally involves rewriting from [Parsetree] to [Typedtree]
   *   namespace. Also entry point for expression is changed from
   *   [FB_parsed_expr] to [FB_typed_expr].
   *
   *   During typing we do few things:
   * 
   *   <list>
   *     - Infer types and check if they are correct. Store information
   *       about types in resulting [Typedtree.Expr] objects.
   *     - Define (generate [Decl] objects) and later resolve local values.
   *     - Rewrite few redundant source language constructs into
   *       unambiguous equivalents from [Typedtree].
   *     - Bind type expressions occurring in source code.
   *     - Mark which values should go into closures. 
   *   </list>
   *
   *   This is however all done in parallel to improve efficiency.
   *
   *   Documentation FIXME: overloading resolution, CTX type, more
   *   about closures, binding method implement list.
   * </remarks>
   *)
  handle_tyinfo_members (ti : Tyinfo) : void 
    {
      def handle_decl (decl : Class_member) : void {
        match (decl) {
          | (M_function) as f =>
            def in_ctor = match (f.kind) { FK_ctor => true | _ => false };
            def is_method = match (f.kind) { FK_ctor => true | FK_method => true | _ => false };
            def our_decl = Env.global_by_id (f.id);
            def ctx = CTX (in_ctor = in_ctor, 
                           this_ptr_decl = 
                             if (is_method) 
                               Some (Decl ("_N_this", D_closurised_this_ptr (), 
                                           ti.generic_type (), our_decl))
                             else None (),
                           env = ti.env.copy (),
                           tenv = f.header.tenv);

            match (f.kind) {
              | FK_method (impl) =>
                f.kind <- FK_bound_method (List.map (fun (s : string) : Decl 
                                                             { bind_impl (ti.env, our_decl, s) },
                                                              impl))
              | _ => ()
            };
            ctx.env.parent_fun <- Some (our_decl);
            try
              f.body <- ty_function (ctx, f.header, f.body)
            with x : Recovery => ()
          | _ => ()
        }
      };
      List.iter (handle_decl, ti.member_list);
    }

  (** The main typing function.  *)
  public run () : void {
    Tyinfo.iter (handle_tyinfo_members)
  }
}
  
} // end ns
