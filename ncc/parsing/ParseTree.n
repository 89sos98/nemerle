/*
 * Copyright (c) 2003-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Utility;

namespace Nemerle.Compiler.Parsetree
{
  [Record (Exclude = [_definedIn])]
  public variant TopDeclaration : DeclarationBase
  {
    | Class {
      mutable t_extends : list [PExpr];
      decls : list [ClassMember];
    }
    | Alias { ty : PExpr; }
    
    | Interface {
      mutable t_extends : list [PExpr];
      methods : list [ClassMember]; // only iface_member
    } 
    | Variant {
      mutable t_extends : list [PExpr];
      mutable decls : list [ClassMember];
    }
    | VariantOption { decls : list [ClassMember]; }

    | Macro {
      header : Fun_header;
      synt : list [PExpr];
      expr : PExpr;
    }
    | Delegate { header : Fun_header; }
    | Enum {
      t_extends : list [PExpr];
      decls : list[ClassMember];
    }

    public mutable typarms : Typarms;
    /// If this TopDeclaration nested in other TopDeclaration
    /// this property contain referens to it.  This property set to null 
    /// if it is top level declaration.
    [Accessor] internal mutable _definedIn : TopDeclaration;

    public this (tp : Typarms) {
      this ();
      typarms = tp;
    }
        
    public this () { base (Splicable.Name (Name ("")), Modifiers.Empty) }

    public override ToString() : string
    {
      def name = this.Name;
      match (this)
      {
        | Class                => $"class $name"
        | Alias(ty)            => $"type $name = $ty"
        | Interface            => $"interface $name"
        | Variant              => $"variant $name"
        | VariantOption        => $"| $name"
        | Macro (header, _, _) => $"macro $name($header)"
        | Delegate (header)    => $"delegate $name: $header"
        | Enum                 => $"enum $name"
      }
    }
  }

  [Record (Exclude = [_env, _tokens, _bodyLocation, _definedIn, _builder, _userData])]
  public variant ClassMember : DeclarationBase
  {
    | TypeDeclaration { td : TopDeclaration; }
    | Field {
        mutable ty : PExpr;
        public new Builder : FieldBuilder    { get { _builder :> FieldBuilder } }
      }
    | Function { 
        header : Fun_header;
        mutable implemented : list [PExpr];
        mutable body : FunBody;
        public new Builder : MethodBuilder   { get { _builder :> MethodBuilder } }
      }
    | Property {
        ty : PExpr;
        prop_ty : PExpr;
        dims : list [Fun_parm]; // parameters of indexer property
        get : option [ClassMember];
        set : option [ClassMember];
        public new Builder : PropertyBuilder { get { _builder :> PropertyBuilder } }
      }
    | Event {
        ty : PExpr;
        field : ClassMember.Field;
        add : ClassMember.Function;
        remove : ClassMember.Function;
        public new Builder : EventBuilder    { get { _builder :> EventBuilder } }
      }
    | EnumOption { value : option [PExpr]; }

    // It's prevent esers from fortuitous modification of Env property.
    public SetEnv(env : GlobalEnv) : void { _env = env; } 
    [Accessor] internal mutable _env          : GlobalEnv;
    [Accessor] internal mutable _tokens       : Token.BracesGroup;
    [Accessor] internal mutable _bodyLocation : Location;
    /// This property contain referens to TopDeclaration where defined this member.
    [Accessor] internal mutable _definedIn    : TopDeclaration;
    //  This field set to MemberBuilder where it will be created. (null for EnumOption & TypeDeclaration)
    [Accessor] internal mutable _builder      : MemberBuilder;
    [Accessor(flags = WantSetter)]
    mutable _userData : object;
    
    /** accessible only for ClassMember.Function, when its FunBody is not typed or compiled */
    public Body : PExpr
    {
      get {
        match (this) {
          | ClassMember.Function (body = bd) =>
            match (bd) {
              | FunBody.Parsed (expr) => expr
              | FunBody.Typed =>
                Message.Error ("Body of typed method is not accessible");
                null
              | FunBody.ILed =>
                Message.Error ("Body of compiled method is not accessible");
                null
              | FunBody.Abstract => <[ () ]>
            }
          | _ =>
            Message.Error ("Body is accessible only for ClassMember.Function variant option");
            null
        }
      }
      set {
        match (this) {
          | ClassMember.Function as fn =>
            fn.body = FunBody.Parsed (value);
          | _ =>
            Message.Error ("Body is accessible only for ClassMember.Function variant option")
        }
      }
    }

    public IsMutable () : bool { modifiers.mods %&& NemerleAttributes.Mutable }

    internal PrintBody (writer : LocatableTextWriter) : void
    {
      match (this) {
        | Function (body = bd) =>
          match (bd) {
              | FunBody.Parsed (expr) => 
                PrettyPrint.SprintExpr (None(), expr, "", writer);
              | _ => ()
          }
        | _ => ()
      }
    }
    
    public override ToString() : string
    {
      def attrs1 = Attributes.ToString().ToLower().Replace(",", "");
      def attrs = if (attrs1 == "") attrs1 else (attrs1 + " ");
      def ifMutable () { if (IsMutable ()) "mutable " else "" }
      def prefix() { $"$(attrs)$(ifMutable())" }
      def name = this.Name;

      match (this)
      {
        | TypeDeclaration(td)         => $"TopDeclaration: $(prefix())Name=$name ($td)"
        | Field(ty)                   => $"Field: $(prefix())$name : $ty;"
        | Function(header, _, _)      => $"Function: $(prefix())$header;"
        | Property(ty, _, dims, get, set) => 
          def getSet = match ((get, set))
          {
            | (Some, Some) => " { get; set; }"
            | (None, Some) => " { set; }"
            | (Some, None) => " { get; }"
            | (None, None) => ";"
          }
          
          $"Property: $(prefix())$name : $ty" + (if (dims.IsEmpty) "" else dims.ToString()) + getSet

        | Event(ty, _, _, _)          => $"Event: $(prefix())$name : $ty;"
        | EnumOption(value)           => $"$name" + match (value) { | Some(v) => $" = $v" | None => "" }
      }
    }
  }

  [Record]
  public class DeclarationBase : Located
  {
    public mutable name : Splicable;
    public mutable modifiers : Modifiers;

    public ParsedName : Name {
      get { name.GetName () }
    }
    
    public Name : string {
      get { name.GetName ().Id }
    }

    public Attributes : NemerleAttributes {
      get { modifiers.mods }
      set { modifiers.mods = value }
    }

    public GetCustomAttributes () : list [PExpr] {
      modifiers.custom_attrs
    }

    public AddCustomAttribute (e : PExpr) : void {
      modifiers.custom_attrs = e :: modifiers.custom_attrs
    }
  }

  [Record]
  public class Constraint
  {
    public tyvar : Splicable;
    public ty : PExpr;
  }

  [Record]
  public class Typarms
  {
    public tyvars : list [Splicable];
    public constraints : list [Constraint];

    public static Empty : Typarms = Typarms ([], []);

    public override ToString() : string
    {
      if (tyvars.IsEmpty) "" else ($"[..$tyvars]")
    }
    
    public virtual IsCopyOfExisting : bool { get { false } }
    public virtual Substitute (ty : MType) : TyVar { ty } 
    public virtual ExistingTyvars : list [StaticTyVar] { get { null } } 
  }
  
  public class SubstitutingTyparms : Typarms {
    subst : Subst;  
    
    public this (subst : Subst) {
      base ([], []);
      this.subst = subst;   
    }

    public override Substitute (ty : MType) : TyVar { subst.Apply (ty) }         
  }
  
  /** The specified list of typed type parameters will be used as template for new type parameters. 
      Compiler will also perform substitution of references to old parameters in type/method signature into references
      to fresh type parameters */
  public class CopyTypedTyparms : SubstitutingTyparms {
    fresh_vars : list [StaticTyVar];
       
    public this (template_tyvars : list [StaticTyVar]) {
      this (template_tyvars, null)
    }   
    
    public this (template_tyvars : list [StaticTyVar], subst : Subst) {
      def (fsubst, fresh_vars) = StaticTyVar.CopyList (template_tyvars);
      when (subst != null)
        fsubst.AddSubst (subst);
      base (fsubst);
      this.fresh_vars = fresh_vars;
    }    
    
    public override IsCopyOfExisting : bool { get { true } }
    public override ExistingTyvars : list [StaticTyVar] { get { fresh_vars } } 
  }

  /** class encapsulating name of variable for purpose of
      quotation and renaming
   */    
  public class Name : Located, System.IComparable [Name]
  {
    public idl : string;
    public color : int;
    public context : GlobalEnv;

    public this (id : string)
    {
      this.color = ManagerClass.Instance.MacroColors.Color;
      this.context = null; // no global context
      idl = id;
    }

    public this (id : string, loc : Location)
    {
      this(id);
      this.Location = loc;
    }

    public this (id : string, color : int, context : GlobalEnv)
    {
      this.color = color;
      this.context = context;
      idl = id;
    }

    public this (id : string, loc : Location, color : int, context : GlobalEnv)
    {
      this(id, color, context);
      this.Location = loc;
    }

    static public NameInCurrentColor (id : string, context : GlobalEnv) : Name
    {
      Name (id, context.Manager.MacroColors.Color, context)
    }

    static public NameInCurrentColor (id : string, loc : Location, context : GlobalEnv) : Name
    {
      Name (id, loc, context.Manager.MacroColors.Color, context)
    }

    static public Global (mgr : ManagerClass, id : string) : Name
    {
      Name (id, 1, mgr.CoreEnv)
    }

    public NewName (id : string) : Name {
      Name (id, color, context);
    }
    
    /** Returns plain identifier string of this name.
     */
    public Id : string
    {
      get { idl }
    }

    public override ToString () : string
    {
      Id
    }

    public override GetHashCode () : int 
    {
      unchecked (idl.GetHashCode () * (color + 1))
    }
    
    [Nemerle.OverrideObjectEquals]
    public Equals (other : Name) : bool
    {
      this.CompareTo (other) == 0
    }

    public CompareTo (other : Name) : int
    {
      if (color == other.color || color < 0 || other.color < 0)
        if (idl == other.idl) 0
        else string.CompareOrdinal (idl, other.idl)
      else
        color - other.color
    }

    public GetEnv (default : GlobalEnv) : GlobalEnv
    {
//      when (context == null) Message.Debug ("null: " + Id);
      if (context != null)
        context
      else
        default
    }
  }

  [Record (Exclude = [typed_object])]
  public variant PExpr : Located 
  {
    | Wildcard        // `_' used mainly in patterns, but also in `_ = ignored'
    | Void            // `void' used only in types
    | As              { pat : PExpr; name : Splicable; }
    | Is              { pat : PExpr; ty : PExpr; }
    | Where           { name : PExpr; fields : PExpr; }
    | Match           { expr : PExpr; cases : list [MatchCase]; mutable expr_loc : Location;
                        this(loc : Location, expr : PExpr, cases : list [MatchCase]) { this(loc, expr, cases, Location.Default); }
                        this(expr : PExpr, cases : list [MatchCase]) { this(expr, cases, Location.Default); }
                      }

    | Ref             { name : Name; }
    | Member          { obj : PExpr; member : Splicable; }
    | Call            { func : PExpr; parms : list [PExpr]; }
    | GenericSpecifier { func : PExpr; generic_parms : list [PExpr]; }
    | ListLiteral     { elements : list [PExpr]; }
    | Assign          { target : PExpr; source : PExpr; }
    | DefMutable      { name : PExpr; val : PExpr; }
    | Define          { pattern : PExpr; val : PExpr; }
    | DefFunctions    { funs : list [Function_decl]; }
    | Lambda          { decl : Function_decl; }
    | Throw           { exn : PExpr; }
    | Try             { body : PExpr; cases : list [TryCase]; }
    | TryFinally      { body : PExpr; handler : PExpr; }
    | Literal         { val : Nemerle.Compiler.Literal; }
    | This
    | Base
    | Typeof          { ty : PExpr; }
    | TypeConversion  { expr : PExpr; ty : PExpr; }  // (expr :> ty)
    | TypeEnforcement { expr : PExpr; ty : PExpr; } // (expr : ty)
    | Sequence        { body : list [PExpr]; }
    | Tuple           { args : list [PExpr]; }
    | Array           { rank : PExpr; args : PExpr; }
    | EmptyArray      { sizes : list [PExpr]; }
    | Indexer         { obj : PExpr; args : list [PExpr]; }
    | ParmByRef       { parm : PExpr; }
    | ParmOut         { parm : PExpr; }

    | Error // placeholder of missing tree (where some errors occured)

    // macros stuff    
    | MacroCall       { name : Name; ns : NamespaceTree.Node;
                        parms : list [SyntaxElement]; }
    | Quoted          { body : SyntaxElement; }
    | Spliced         { body : PExpr; }
    | ToComplete      { body : Name; }
    | Ellipsis        { body : PExpr; }
    | Typed           { body : Typedtree.TExpr; }
    | TypedPattern    { body : Typedtree.Pattern; }  
    | TypedType       { body : TyVar; }

    [Accessor] internal mutable typed_object : object;

    public override ToString () : string {
      PrettyPrint.SprintExpr (None (), this);
    }

    // transforms dot-separated identifier to the parse-tree expression 
    public static FromQualifiedIdentifier (manager : ManagerClass, qid : string) : PExpr 
    {
      if (string.IsNullOrEmpty (qid)) null
      else {
        def split = qid.Split ('.');
        mutable expr = <[ $(Name (split [0], manager.MacroColors.UseColor, manager.MacroColors.UseContext) : name) ]>;
        for (mutable i = 1; i < split.Length; i++)
          expr = <[ $expr . $(Name (split [i], manager.MacroColors.UseColor, manager.MacroColors.UseContext) : name) ]>;
        expr
      }
    }
  }

  [Record (Exclude = [typed_object])]
  public variant Splicable : Located 
  {
    | Name { body : Parsetree.Name; }
    | Expression { expr : PExpr; }
    | HalfId { prefix : Parsetree.Name; }

    [Accessor] internal mutable typed_object : IMember;

    public GetName () : Parsetree.Name {
      match (this) {
        | Splicable.Name (x) => x
        | _ => throw System.ArgumentException ("GetName () called for option " + this.ToString ())
      }
    }

    [Nemerle.OverrideObjectEquals]
    public Equals (other : Splicable) : bool {
      match ((this, other)) {
        | (HalfId (n1), HalfId (n2))
        | (Name (n1), Name (n2)) => n1.Equals (n2)
        | _ => false
      } 
    }

    public GetIdentifier () : string {
      match (this) {
        | Splicable.Name (x) => x.Id
        | _ => throw System.ArgumentException ("GetIdList () called for option " + this.ToString ())
      }
    }

    override public ToString() : string
    {
      match (this) {
        | Name(name)
        | HalfId(name)     => name.ToString()
        | Expression(expr) => expr.ToString()
      }
    }
  }

  public class Fun_parm : DeclarationBase
  {
    public mutable ty : PExpr;

    // when parse_header() sees a pattern as a function parameters,
    // it generates a dummy name and puts the pattern in this field
    internal mutable pattern_hack : PExpr;

    [Accessor] internal mutable typed_object : Typedtree.Fun_parm;

    public this (name : Splicable, ty : PExpr, modifiers : Modifiers) 
    {
      base (Location_stack.top (), name, modifiers);
      this.ty = ty;
    }
    public this (loc : Location, name : Splicable, ty : PExpr,
                 modifiers : Modifiers, pattern_hack : PExpr = null) 
    {
      base (loc, name, modifiers);
      this.ty = ty;
      this.pattern_hack = pattern_hack;
    }

    public this (from : PExpr) 
    {
      base (from.Location, null, Modifiers (NemerleAttributes.None, []));
      match (from) {
        | PExpr.Ref (n)     => name = Splicable.Name (n);       ty = PExpr.Wildcard (from.Location);
        | PExpr.Spliced (s) => name = Splicable.Expression (s); ty = PExpr.Wildcard (from.Location);
        | PExpr.TypeEnforcement (PExpr.Ref (n), t) =>
          name = Splicable.Name (n); ty = t;
          
        | PExpr.TypeEnforcement (PExpr.Spliced (s), t) =>
          name = Splicable.Expression (s); ty = t;

        | _ => throw System.ArgumentException ($"incorrect expression supplied for parameter creation: $from")
      }
    }

    public ReferencingExpr : PExpr {
      get { 
        match (name) {
          | HalfId (n)
          | Name (n) => PExpr.Ref (this.Location, n)
          | Expression (e) => e
        }
      }
    }

    public override ToString() : string
    {
      $"$(this.Name) : $ty"
    }
  }

  /// implemented by parse tree and typed tree function headers
  public interface IParametersProvider {
    ParametersDeclarations : list [Fun_parm] { get; }
    ParametersReferences : list [PExpr] { get; }
  }

  public class Fun_header : Located, IParametersProvider
  {
    public mutable typarms : Typarms;
    public mutable name : Splicable; // is changed when typing lambda
    public ret_type : PExpr;
    public parms : list [Fun_parm];

    [Accessor] internal mutable typed_object : Typedtree.Fun_header;

    public ParsedName : Name {
      get { name.GetName () }
    }
    
    public Parameters : list [Fun_parm] implements IParametersProvider.ParametersDeclarations
    {
      get { parms }   
    }

    public this (loc : Location, name : Splicable, ret_type : PExpr, 
                 parms : list [Fun_parm]) 
    {
      base (loc);
      this.typarms = Typarms.Empty;
      this.name = name;
      this.ret_type = ret_type;
      this.parms = parms;
    }

    public this (typarms : Typarms, name : Splicable, ret_type : PExpr,
                 parms : list [Fun_parm]) 
    {
      this (Location_stack.top (), typarms, name, ret_type, parms)
    }

    public this (loc : Location, typarms : Typarms, 
                 name : Splicable, ret_type : PExpr, parms : list [Fun_parm]) 
    {
      this (loc, name, ret_type, parms);
      this.typarms = typarms;
    }

    public ParametersReferences : list [PExpr] {
      get { parms.Map (_.ReferencingExpr) }
    }

    public override ToString() : string
    {
      $"$name$typarms(..$parms) : $ret_type"
    }
  }

  [Record]
  public class Function_decl
  {
    public header : Fun_header;
    public mutable body : PExpr;

    public Location : Location
    {
      get { header.Location.Combine(body.Location) }
    }
  }

  [Record]
  public class MatchCase
  {
    public this (patterns : list [PExpr], body : PExpr)
    {
      this (patterns, body, false)
    }

    public patterns : list [PExpr];
    public body : PExpr;
    public mutable disable_warnings : bool;

    public Location : Location
    {
      get
      {
        mutable loc = body.Location;

        patterns.Iter(p => loc = loc.Combine(p.Location));

        loc;
      }
    }

    public override ToString () : string
    {
      $"| $(patterns.ToString(\" | \")) => $body"
    }
  }

  [Record]
  public variant TryCase {
    | Catch    { exn : Splicable; exn_ty : PExpr; handler : PExpr; }
    | Filter   { exn : Splicable; exn_ty : PExpr; filter : PExpr; handler : PExpr; }
    | Ellipsis { body : PExpr; }

    public Location : Location {
      get {
        match (this) {
          | Catch   (exn, exn_ty, handler)         => exn.Location.Combine(exn_ty).Combine(handler)
          | Filter  (exn, exn_ty, filter, handler) => exn.Location.Combine(exn_ty).Combine(filter).Combine(handler)
          | Ellipsis(body)                         => body.Location
        }
      }
    }
  }

  public variant SyntaxElement {
    | Expression       { body : PExpr; }
    | MatchCase        { body : Parsetree.MatchCase; }
    | Function         { body : Function_decl; }
    | Parameter        { body : Fun_parm; }
    | TType            { body : PExpr; }

    | RawToken         { body : Token; }

    | ClassMember      { body : Parsetree.ClassMember; }
    | TypeBuilder      { body : Compiler.TypeBuilder; }
    | FieldBuilder     { body : Compiler.FieldBuilder; }
    | MethodBuilder    { body : Compiler.MethodBuilder; }
    | PropertyBuilder  { body : Compiler.PropertyBuilder; }
    | EventBuilder     { body : Compiler.EventBuilder; }
    | ParameterBuilder { body : Typedtree.Fun_parm; }

    public Location : Location {
      get {
        match (this) {
          | Expression (null)    | Parameter (null)        | TType (null)
          | ClassMember (null)   | ParameterBuilder (null) | FieldBuilder (null)
          | MethodBuilder (null) | PropertyBuilder  (null) | EventBuilder (null)
          | MatchCase (null)     | Function (null)         | RawToken (null)
          | TypeBuilder (null)                      => Location.Default;

          | Expression       (body : Located)
          | Parameter        (body : Located)
          | TType            (body : Located)
          | ClassMember      (body : Located)
          | ParameterBuilder (body : Located)       => body.Location;
          | FieldBuilder     (body : MemberBuilder)
          | MethodBuilder    (body : MemberBuilder)
          | PropertyBuilder  (body : MemberBuilder)
          | EventBuilder     (body : MemberBuilder) => body.Location;
          | MatchCase        (body)                 => body.Location;
          | Function         (body)                 => body.Location;
          | RawToken         (body)                 => body.Location;
          | TypeBuilder      (body)                 => body.Location;
        }
      }
    }

    public override ToString () : string {
      match (this) {
        | SyntaxElement.Expression (null) => ""
        | SyntaxElement.Expression (body) => body.ToString ()
        | SyntaxElement.TType (body)      => "ttype: " + body.ToString ()
        | SyntaxElement.RawToken (t)      => t.ToString ()
        | SyntaxElement.MatchCase         => "match case"
        | SyntaxElement.Function          => "function"
        | SyntaxElement.Parameter         => "parameter"

        | SyntaxElement.ClassMember       => "ClassMember"
        | SyntaxElement.TypeBuilder       => "TypeBuilder"
        | SyntaxElement.FieldBuilder      => "FieldBuilder"
        | SyntaxElement.MethodBuilder     => "MethodBuilder"
        | SyntaxElement.PropertyBuilder   => "PropertyBuilder"
        | SyntaxElement.EventBuilder      => "EventBuilder"
        | SyntaxElement.ParameterBuilder  => "ParameterBuilder"
      }
    }
  }
} // Nemerle.Compiler

