/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 */
public interface IMacro {
  GetName () : string;
  Run (ctx : CTX, args : list <PT.SyntaxElement>) : PT.Expr;
  CallTransform (_ : list <PT.Parm>) : list <PT.SyntaxElement>;
  SyntaxExtension () : string * list <Parser.GrammarElement> * list <int>;
} 

public module MacroRegistry {
  public mutable macros : Hashtable <string, IMacro>;

  this () {
    macros <- Hashtable ();
  }

  public register_macro (m : IMacro) : void {
    def name = m.GetName ();
    if (macros.Contains (name))
      Util.ice ("macro already registered: " + name)
    else {
      match (m.SyntaxExtension ()) {
        | ("", [], []) => ()
        | (key, rules, positions) =>
          def permute = Macros.CreatePermutingFunction (List.Rev (positions));
          Lexer.AddKeyword (key);
          List.Iter (rules, fun (x) { 
            | Parser.GE_keyword (k) => Lexer.AddKeyword (k); 
            | _ => () 
          });

          Parser.ctx.keywords.Set (key, Parser.KeywordCallback (key, 
            Parser.make_parsing_function (name, rules, permute)))
      };
      macros.Set (name, m)
    }
  }

  public expand_macro (ctx : CTX, expr : PT.Expr) : PT.Expr {
    match (expr) {
      | PT.E_call (PT.E_ref (name), args) =>
        match (macros.Get (name.id)) {
          | Some (x) =>
            TypingContext.PushNewColor (name.color, name.GetEnv (null));
            def expanded = x.Run (ctx, x.CallTransform (args));
            TypingContext.PopColor ();
            expand_macro (ctx, expanded);
          | None => expr
        }
      | PT.E_macrocall (name, parms) =>
        TypingContext.PushNewColor (name.color, name.GetEnv (null));
        def expanded = Option.UnSome (macros.Get (name.id)).Run (ctx, parms);
        TypingContext.PopColor ();        
        expand_macro (ctx, expanded)

      | _ => expr
    }
  }

}
} // end ns
