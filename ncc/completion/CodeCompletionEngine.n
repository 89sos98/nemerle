//
// CodeCompletionEngine.n
//
// Author:
//  Alejandro Serrano (trupill at yahoo dot es)
//

/*
 * Copyright (c) 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define DEBUG
 
using System;
using Nemerle.Assertions;
using Nemerle.Compiler;
using Nemerle.Utility;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using System.Diagnostics;

using Typed = Nemerle.Compiler.Typedtree;
using SR = System.Reflection;
using SCG = System.Collections.Generic;

namespace Nemerle.Compiler
{
  // Compiler messages
  public enum MessageKind
  {
    | Error
    | Warning
    | Hint
  }

  [Record]
  public class CompilerMessage
  {
    public mutable Message     : string;
    public mutable Location    : Location;
    public mutable MessageKind : MessageKind;

    public override ToString() : string
    {
      $"$(this.MessageKind): $Message ($(this.Location))"
    }
  }

  // Relocation

  public interface ISupportRelocation
  {
    RelocateImpl (info : RelocationInfo/*, ident : string*/) : void;
  }

  //[Record(Exclude = [VisitedObjects])]
  public class RelocationInfo
  {
    public this(fileIndex : int, line : int, ch : int, lineOffset : int, charOffset : int)
    {
      this.VisitedObjects = Hashtable();
      this.CharOffset     = charOffset;
      this.LineOffset     = lineOffset;
      this.Char           = ch;
      this.Line           = line;
      this.FileIndex      = fileIndex;
    }

    public VisitedObjects : Hashtable[object, byte];
    public FileIndex      : int;
    public Line           : int;
    public Char           : int;
    public LineOffset     : int;
    public CharOffset     : int;

    //public mutable VisitCount  : int;
    //public mutable NodeCount  : int;
    
    override public ToString() : string
    {
      $"FileIndex=$FileIndex Line=$Line Char=$(this.Char) LineOffset=$LineOffset CharOffset=$CharOffset"
    }
  }
  
  public module Completion
  {
    /// Shift Location.
    public Relocate (loc : Location, info : RelocationInfo) : Location
    {
      def relocatePoint (oldLn, oldCh, info, ch)
      {
        if (oldLn > info.Line)
          (oldLn + info.LineOffset, oldCh)
        else if (oldLn == info.Line && oldCh >= ch)
          (oldLn + info.LineOffset, oldCh + info.CharOffset)
        else
          (oldLn, oldCh) 
      }

      if (loc.FileIndex == info.FileIndex)
      {
        def (newLn, newCh)       = relocatePoint(loc.Line,    loc.Column,    info, info.Char + 1);
        def (newEndLn, newEndCh) = relocatePoint(loc.EndLine, loc.EndColumn, info, info.Char);

        Location (loc, newLn, newCh, newEndLn, newEndCh);
      }
      else
        loc
    }
    
    /// Shift Location.
    public RelocateFile (loc : Location, info : RelocationInfo) : Location
    {
      if (loc.FileIndex == info.FileIndex)
        Relocate (loc, info)
      else
        loc
    }

    /// Shift Location.
    public Relocate (loc : Location, line : int, ch : int, lineOffset : int, chOffset : int) : Location
    {
      def relocatePoint (oldLn, oldCh, ch)
      {
        if (oldLn > line)
          (oldLn + lineOffset, oldCh)
        else if (oldLn == line && oldCh >= ch)
          (oldLn + lineOffset, oldCh + chOffset)
        else
          (oldLn, oldCh) 
      }

      def (newLn, newCh)       = relocatePoint(loc.Line,    loc.Column,    ch + 1);
      def (newEndLn, newEndCh) = relocatePoint(loc.EndLine, loc.EndColumn, ch);

      Location (loc.FileIndex, newLn, newCh, newEndLn, newEndCh);
    }
    
    CmpOptins = System.StringComparison.InvariantCultureIgnoreCase;

    /// extract information about types/namespaces and add it to 'elems' list.
    public AddTypesAndNamespaces (
      [NotNull] elems : SCG.List[Elem],
      [NotNull] nss : list [NamespaceTree.Node],
      obj : PExpr, // nullable
      [NotNull] name : Parsetree.Name,
      noMacros : bool) : void
    {
      def prefix = name.Id;
      def isAll = string.IsNullOrEmpty(prefix); // don't use prefix
      // scan namespace tree node and add appropriate nodes into 'elems' list.
      def scanAndAdd (subNode : NamespaceTree.Node)
      {
        when (subNode.Children != null)
          foreach (elem when isAll || elem.Key.StartsWith(prefix, CmpOptins) in subNode.Children)
          {
            def name = elem.Key;
            def node = elem.Value;

            match (node.Value)
            {
              | No => ()
              | MacroCall(macr) => 
                when (!noMacros)
                  elems.Add(Elem.Node (
                    if (macr.Keywords.IsEmpty) node.PartName else macr.Keywords.Head,
                    node));
              
              | _ => elems.Add(Elem.Node (name, node));
            }
          }
        
        subNode.EnsureCached ();

        def scanStaticMembers (ti)
        {
          foreach (member in ti.GetMembers (BindingFlags.Public | BindingFlags.Static))
            when (isAll || member.GetName().StartsWith(prefix, CmpOptins))
              elems.Add(Elem.Member (member));
        }

        match (subNode.Value)
        {
          | Cached(ti)                 => scanStaticMembers (ti)
          | CachedAmbiguous(typeInfos) =>
            foreach (ti in typeInfos)
              scanStaticMembers (ti);

          | _                          => ()
        }

      }

      if (obj is null)
        foreach (subNode in nss)
          scanAndAdd (subNode)
      else match (Util.QidOfExpr (obj)) // extract list of name parts from expression
      {
        | Some ((nameParts, _)) => 
          match (NamespaceTree.Node.PassTo (nss, nameParts)) // open node
          {
            | null => ()
            | subNode => scanAndAdd (subNode)
          }
        | None => ()
      }
    }

    public GetName (this member : IMember) : string
    {
      match (member.MemberKind)
      {
        | Constructor => ReplaceSpecialName (member.DeclaringType.Name)
        | _ => member.Name
      }
    }

    /// Look for special names
    public ReplaceSpecialName(name : string) : string
    {
      | "Nemerle.Core.list" 
      | "Nemerle.Core.list+Cons" 
      | "Nemerle.Core.list+Nil"  => "list"
      | "System.Byte"            => "byte"
      | "System.SByte"           => "sbyte"
      | "System.Int16"           => "short"
      | "System.UInt16"          => "ushort"
      | "System.Int32"           => "int"
      | "System.UInt32"          => "uint"
      | "System.Int64"           => "long"
      | "System.UInt64"          => "ulong"
      | "System.Single"          => "float"
      | "System.Double"          => "double"
      | "System.Decimal"         => "decimal"
      | "System.String"          => "string"
      | "System.Object"          => "object"
      | "System.Boolean"         => "bool"
      | "System.Char"            => "char"
      | _                        => name
    }
  }
  
  public class CompletionMethodBuilder : MethodBuilder {
    public this (par : TypeBuilder, functionAst : ClassMember.Function)    {
      this (par, functionAst, false);
    }
    public this (par : TypeBuilder, functionAst : ClassMember.Function, is_property : bool) {
      base (par, functionAst, is_property);
      _bodyTokens = functionAst.Tokens;
    }
    
    public override EnsureCompiled() : void
    {
      unless (BodyLocation.FileIndex > 0 && this.Attributes %&& NemerleAttributes.Abstract)
        _ = BodyTyped;
    }
  
    mutable _bodyMessages : SCG.List[CompilerMessage];
    public override BodyMessages : SCG.List[CompilerMessage]
    {
      get
      {
        Trace.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        when (_bodyMessages == null)
          _bodyMessages = SCG.List();
  
        _bodyMessages
      }
    }
  
    public override ResetCodeCache () : void
    {
      when (_bodyMessages != null)
        _bodyMessages.Clear();
  
      _bodyTokens     = null;
      _bodyParsed     = null;
      _bodyTyped      = null;
      fun_header.body = null;
    }
  
    mutable _bodyTokens : Token.BracesGroup;
  
    //mutable _indent : string = "";
  
    /// The method body tokens. 
    /// Note: For call this method you must implement method 
    /// PreParseMethodBody in a subtype.
    public override BodyTokens : Token.BracesGroup
    {
      get
      {
        //Trace.WriteLine($"$_indent>>>> ##### BodyTokens ($Name)!");
        Trace.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        Trace.Assert(Manager.IsIntelliSenseMode);
        when (_bodyTokens == null)
        {
          //def indent = _indent; _indent += "  ";
          Manager.SetCompiletMessages (BodyMessages);
          _bodyTokens = Manager.PreParseMethodBody (this);
          //_indent = indent;
        }
  
        //Trace.WriteLine($"$_indent<<<< ##### BodyTokens ($Name)!");
        _bodyTokens
      }
  
      set { ResetCodeCache(); _bodyTokens = value; }
    }
  
    mutable _bodyParsed : PExpr;
  
    /// The method body parsed expressions. 
    public override BodyParsed : PExpr
    {
      get
      {
        //Trace.WriteLine($"$_indent>>>> ##### BodyParsed ($Name)!");
        Trace.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        Trace.Assert(Manager.IsIntelliSenseMode);
        when (_bodyParsed == null)
        {
          //def indent = _indent; _indent += "  ";
          Manager.SetCompiletMessages (BodyMessages);
          _bodyParsed = MainParser.ParseFunctionBody (Env, Ast.header, BodyTokens);
          fun_header.body = FunBody.Parsed (_bodyParsed);
          //_indent = indent;
        }
  
        //Trace.WriteLine($"$_indent<<<< ##### BodyParsed ($Name)!");
        _bodyParsed
      }
    }
  
    public override IsBodyCompilable : bool
    {
      get
      {
        def res = HasAbstractBody || BodyLocation.IsGenerated 
          || BodyLocation.FileIndex <= 0
          || Attributes %&& NemerleAttributes.SpecialName;
        !res
      }
    }
  
    mutable _bodyTyped : TExpr;
  
    /// The method body parsed expressions. 
    public override BodyTyped : TExpr
    {
      get
      {
        Manager.CheckSolver();
        //Trace.WriteLine($"$_indent>>>> ##### BodyTyped ($Name)!");
        Trace.Assert(!(Attributes %&& NemerleAttributes.Abstract || BodyLocation.FileIndex <= 0));
        Trace.Assert(Manager.IsIntelliSenseMode);
        when (_bodyTyped == null)
        {
          //def indent = _indent; _indent += "  ";
          Manager.SetCompiletMessages (BodyMessages);
          try
          {
            _ = BodyParsed; // Use side affect
            RunBodyTyper();
            _bodyTyped = (fun_header.body :> FunBody.Typed).expr;
          }
          finally { Manager.SetCompiletMessages (null); }
          //_indent = indent;
        }
  
        //Trace.WriteLine($"$_indent<<<< ##### BodyTyped ($Name)!");
        _bodyTyped
      }
    }
  }
}
