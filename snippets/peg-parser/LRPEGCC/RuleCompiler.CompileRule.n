using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace LRPEGCC
{
  partial internal class RuleCompiler
  {
    _typer    : Typer;
    _isDebug  : bool;

    public this(typer : Typer)
    {
      _typer    = typer;
      _isDebug  = _typer.Manager.Options.IsConstantDefined("DEBUG");
    }

    public CompileRule(ruleToCompile : Rule, grammar : Grammar) : PExpr
    {
      def prepandExprs(exprs : list[PExpr], mainExpr : PExpr.Sequence) : PExpr.Sequence
      {
        match (mainExpr)
        {
          | <[ { ..$nestedExprs } ]> => <[ { ..$(exprs + nestedExprs) } ]>
        }
      }

      def defVars(exprs : list[string], mainExpr : PExpr.Sequence) : PExpr.Sequence
      {
        def vars = exprs.Map(var => <[ mutable $(var : dyn); ]>);
        match (mainExpr)
        {
          | <[ { ..$nestedExprs } ]> => <[ { ..$(vars + nestedExprs) } ]>
        }
      }

      mutable varCount = 0;
      def newVar()
      {
        ++varCount;
        $"token_$(varCount)";
      }

      def makeVariables(subrule : Rule) : list[string]
      {
        match (subrule)
        {
          | Capture(Handler(_, _, ty), _)
          | Capture(Argument(ty), _)
            =>
            match (ty)
            {
              | Tuple(types) => types.Map(_ => newVar())
              | None         => []
              | _            => [newVar()]
            }
          | _ => []
        }
      }
      def makeSubruleCode(results         : list[string],
                          subrule         : Rule,
                          makeInitExpr    : PExpr               -> PExpr,
                          makeSetExpr     : PExpr * list[PExpr] -> PExpr,
                          makeSetNoneExpr : PExpr               -> PExpr)
        : list[PExpr] * PExpr * PExpr * PExpr
      {
        match (results)
        {
          | [] =>
            ([], <[ () ]>, <[ () ]>, compile(subrule, []))

          | [result] =>
            def result          = <[ $(result : dyn) ]>;
            def variables       = makeVariables(subrule);
            def ruleCode        = compile(subrule, variables);
            def initList        = makeInitExpr(result);
            def setExpr         = makeSetExpr(result, variables.Map(var => <[ $(var : dyn) ]>));
            def setNoneExpr     = makeSetNoneExpr(result);
            def initialising    = initList :: variables.Map(var => <[ mutable $(var : dyn); ]>);
            (initialising, setExpr, setNoneExpr, ruleCode)

          | _ => throw ArgumentException();
        }
      }
      and makeListCode(results      : list[string],
                       subrule      : Rule)
        : list[PExpr] * PExpr * PExpr
      {
        def (initialising, setExpr, _setNoneExpr, rule) =
          makeSubruleCode(results, subrule,
                        varRef                 => <[ $varRef = SCG.List(); ]>, 
                        (varRef, variableRefs) => <[ $varRef.Add(..$variableRefs); ]>,
                        _                      => <[ () ]>);
        (initialising, setExpr, rule)
      }
      and compile(currentRule : Rule, results : list[string]) : PExpr
      {
        def code = match (currentRule)
        {
          | And(rule)              =>
            <[
              {
                def newPos = $(compile(rule, []));
                if (newPos >= 0) pos else -1;
              }
            ]>

          | Not(Chars([RangeSet where (Ranges = [RangeSet.Range.Plain(char.MinValue, char.MaxValue)])])) => // !any
            <[
              {
                if (pos >= text.Length) pos else -1;
              }
            ]>

          | Not(rule)              =>
            <[
              {
                def newPos = $(compile(rule, []));
                if (newPos < 0) pos else -1;
              }
            ]>

          | Call(name)             =>
            match (grammar.GetRule(name))
            {
              | Capture(Handler, _) =>
                match (results)
                {
                  | [] =>
                    <[
                      {
                        mutable ignoreResult;
                        $(DecorateRuleName(name.Id) : dyn)(pos, ref ignoreResult, text);
                      }
                    ]>
                  | [result] =>
                    <[
                      {
                        $(DecorateRuleName(name.Id) : dyn)(pos, ref $(result : dyn), text);
                      }
                    ]>
                  | _ => throw ArgumentException();
                }
              | _ =>
                <[
                  {
                    $(DecorateRuleName(name.Id) : dyn)(pos, text);
                  }
                ]>
            }

          | Chars(chars)           =>
            def testChar(rset)
            {
              def nset = RangeSet().AddRange(char.MinValue, char.MaxValue).Sub(rset);

              def makeCond(rset)
              {
                def cmp(_ : RangeSet.Range)
                {
                  | RangeSet.Range.Plain as range =>
                    if (range.from == range.to)
                      (1, [<[ c == $(range.from : char) ]>])
                    else if (range.from == char.MinValue)
                      (1, [<[ c <= $(range.to : char) ]>])
                    else if (range.to == char.MaxValue)
                      (1, [<[ $(range.from : char) <= c ]>])
                    else if (range.from + 1 == range.to)
                      (2, [<[ c == $(range.from : char) ]>, <[ c == $(range.to : char) ]>])
                    else
                      (2, [<[ ($(range.from : char) <= c && c <= $(range.to : char)) ]>])
                  | RangeSet.Range.UnicodeClass as range =>
                    def cat = <[ System.Globalization.UnicodeCategory.$(range.category.ToString() : usesite) ]>;
                    if(range.inverted)
                      (2, [<[ char.GetUnicodeCategory(c) != $cat ]>])
                    else
                      (2, [<[ char.GetUnicodeCategory(c) == $cat ]>])
                }
                def rset = rset.Ranges.Map(cmp);

                def (rsetSize, rset) = rset.Fold((0, []), ((sz, r), (rsetSize, rset)) => (rsetSize + sz, r :: rset));

                def gen(ranges)
                {
                  | [range]         => range;
                  | range :: ranges => <[ $range || $(gen(ranges))]>
                  | []              => throw ArgumentException();
                }
                (rsetSize, gen(rset.Reverse().Flatten()))
              }
              def (rsetSize, rset) = makeCond(rset);
              def (nsetSize, nset) = makeCond(nset);
              if (rsetSize <= nsetSize)
                rset;
              else
                <[! $nset]>;
            }
            def generate(_)
            {
              | [ch] =>
                match (ch.Ranges)
                {
                  | [RangeSet.Range.Plain(char.MinValue, char.MaxValue)] =>
                    <[ pos + 1 ]>
                  | _ =>
                    <[
                      c = text[pos];
                      if ($(testChar(ch))) pos + 1 else -1;
                    ]>
                }
              | ch :: chars =>
                match (ch.Ranges)
                {
                  | [RangeSet.Range.Plain(char.MinValue, char.MaxValue)] =>
                    <[
                      def pos = pos + 1;
                      $(generate(chars));
                    ]>
                  | _ =>
                    <[
                      c = text[pos];
                      
                      if ($(testChar(ch)))
                      {
                        def pos = pos + 1;
                        $(generate(chars));
                      }
                      else
                        -1;
                    ]>
                }

              | [] => throw ArgumentException();
            }
            def len = chars.Length;
            def check = if (len > 1) <[pos + $((len - 1) : int)]> else <[pos]>;

            match (results)
            {
              | [] =>
                <[
                  if ($check < text.Length) $(generate(chars)) else -1
                ]>
              | [result] =>
                <[
                  def newPos = if ($check < text.Length) $(generate(chars)) else -1;
                  when (newPos >= 0)
                    $(result : dyn) = Nemerle.Peg.NToken(pos, newPos, text);
                  newPos
                ]>
              | _ => throw ArgumentException();
            }

          | Choice(rules)          =>
            def generate(_)
            {
              | [rule]        => rule;
              | rule :: rules =>
                <[
                  {
                    def newPos = $rule;
                    
                    if (newPos < 0) $(generate(rules)) else newPos;
                  }
                ]>

              | []            => throw ArgumentException();
            }

            generate(rules.Map(compile(_, results)));

          | RepeatMinMax(0, 1, subrule)    =>
            def (initialising, setExpr, setNoneExpr, ruleCode) =
              makeSubruleCode(results, subrule,
                              _                      => <[ () ]>,
                              (varRef, variableRefs) => <[ $varRef = Some(..$variableRefs); ]>,
                              varRef                 => <[ $varRef = None(); ]>);
            prepandExprs(initialising, <[
              {
                def newPos = $ruleCode;
                
                if (newPos >= 0)
                {
                  $setExpr;
                  newPos
                }
                else
                {
                  $setNoneExpr;
                  pos
                }
              }
            ]>)

          | RepeatMinMax(minCount, maxCount, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(results, subrule);
            prepandExprs(initialising, <[
              {
                def rep(count, pos)
                {
                  if (count == $(maxCount : int))
                    pos
                  else
                  {
                    def newPos = $ruleCode;

                    if (newPos >= 0)
                    {
                      $addTokensToList;
                      rep(count + 1, newPos)
                    }
                    else if (count >= $(minCount : int))
                      pos
                    else
                      -1
                   }
                }

                rep(0, pos);
              }
            ]>);

          | RepeatMin(0, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(results, subrule);

            prepandExprs(initialising, <[
              {
                def rep(pos : int)
                {
                  def newPos = $ruleCode;

                  if (newPos >= 0)
                  {
                    $addTokensToList;
                    rep(newPos)
                  }
                  else
                    pos
                }

                rep(pos)
              }
            ]>)

          | RepeatMin(minCount, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(results, subrule);

            prepandExprs(initialising, <[
              {
                def rep(count, pos)
                {
                  def newPos = $ruleCode;

                  if (newPos >= 0)
                  {
                    $addTokensToList;

                    rep(count + 1, newPos)
                  }
                  else if (count >= $(minCount : int))
                    pos
                  else
                    -1
                }

                rep(0, pos)
              }
            ]>)

          | Sequence(subrules)        =>
            def generate(rules : list[Rule], results : list[string]) : PExpr
            {
              match (rules)
              {
                | [rule]        => compile(rule, results);
                | rule :: rules =>
                  match (rule)
                  {
                    | Capture(Handler(_, _, ty), _) when !(ty is RuleType.None)
                    | Capture(Argument(ty), _)      when !(ty is RuleType.None)
                      =>
                      def (result :: results) = results;
                      def ruleCode = compile(rule, [result]);
                      <[
                        {
                          def pos = $ruleCode;
                          if (pos >= 0) $(generate(rules, results)) else -1
                        }
                      ]>

                    | _ =>
                      def ruleCode = compile(rule, []);
                      <[
                        {
                          def pos = $ruleCode;
                          if (pos >= 0) $(generate(rules, results)) else -1
                        }
                      ]>
                  }

                | []                =>  <[ { pos } ]>;
              }
            }

            generate(subrules, results);

          | Capture(Argument(Chars), subrule) =>
            def code = compile(subrule, []);
            match (results)
            {
              | []       => code;
              | [result] =>
                <[
                  def newPos = $code;
                  when (newPos >= 0)
                    $(result : dyn) = Nemerle.Peg.NToken(pos, newPos, text);
                  newPos;
                ]>
              | _ => throw ArgumentException();
            }

          | Capture(Argument, subrule) =>
            compile(subrule, results);

          | Capture(Handler(name, _, _), subrule) =>
            match (results)
            {
              | []       => compile(subrule, [])
              | [result] =>
                def varNames     = makeVariables(subrule);
                def subRuesCode  = compile(subrule, varNames);
                defVars(varNames, <[
                  {
                    def newPos = $subRuesCode;

                    if (newPos >= 0)
                      $(result : dyn) = Nemerle.Peg.VToken(pos, newPos, text, $(name.Id : dyn)(..$(varNames.Map(var => <[ $(var : dyn) ]>))));
                    else
                      SetMaxRollbackPos(pos);

                    newPos
                  }
                ]>)
              | _        => throw ArgumentException()
            }
          | ExtensionPoint         => throw NotImplementedException();
        }

        if (_isDebug)
        {
          def s = $"$currentRule";
          <[
            {
              _ = $(s : string);
              $code;
            }
          ]>
        }
        else
          code
      } // end of compile()

      match (ruleToCompile)
      {
        | Capture(Handler, _) =>
          compile(ruleToCompile, ["result"])

        | _ =>
          compile(ruleToCompile, []);
          //<[
          //  def newPos = $code;
          //  when (newPos >= 0)
          //    result = Nemerle.Peg.NToken(pos, newPos, text);
          //  newPos;
          //]>
      }
    }
  }
}
