(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open System;
open System.IO;
open System.Text;
open System.Collections;

namespace Nemerle.Compiler {

class Lexer extends yyParser.yyInput 
{
  file : FileStream;
  file_name : string;
  val : Value;
  line : int;
  col : int;
  
  last_line : int;
  last_col : int;
  mutable cur_tok : int;
  
  static keyword : Hashtable;
  
  public this (fn : string)
    {
      this.file_name <- fn;
      this.file <- FileStream (fn, FileMode.Open);
      this.line <- 1;
      this.col <- 1;
      this.putbac <- -1;
      this.cur_tok <- -1;
    }
    
  putback : int;
    
  do_read () : int
    {
      def ch = file.ReadByte();
      if (ch == '\n') {
	line <- line + 1;
	col <- 1;
      } 
      else
        col <- col + 1;
      ch
    }
	
  read () : int
    {
      if (putback == -1)
        do_read()
      else {
	def c = putback;
	putback <- -1;
	c
      }
    }

  peek() : int
    {
      if (putback == -1)
        putback <- do_read()
      else ();
      putback
    }

  is_id_beg(ch : int) : bool
    {
      (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_'
    }

  is_digit(ch : int) : bool
    {
      ch >= '0' && ch <= '9'
    }

  is_opchar(ch : int) : bool
    {
      match (ch) {
	| '=' => true
	| '<' => true
	| '>' => true
	| '@' => true
	| '^' => true
	| '|' => true
	| '&' => true
	| '+' => true
	| '-' => true
	| '*' => true
	| '/' => true
	| '$' => true
	| '%' => true
	| '!' => true
	| '?' => true
	| '~' => true
	| '.' => true
	| ':' => true
	| '#' => true
	| '[' => true
	| ']' => true
	| _ => false
      }
    }

  skip_comment () : void
    {
      mutable ch <- ' ';
      mutable seen_star <- false;
      
      def loop () : void
	{
	  ch <- read();
	  if (seen_star && ch == ')')
	    ()
	  else {
	    if (ch == '*')
	      seen_star <- true
	    else
	      seen_star <- false;
	    loop ()
	  }
	};
      loop ()
    }

  get_op(tok : int, first_ch : int) : int
    {
      def buf = StringBuilder();
      
      buf.Append ((first_ch : char));

      def eat_opchars () : void
	{
	  if (is_opchar (peek ())) {
	    buf.Append ((read () : char));
	    eat_opchars ()
	  }
	  else
	    ()
	};
	
      eat_opchars ();
      def s = buf.ToString();
	
      val <- s;

      match (s) {
	| "*" => s[0]
	| "=" => s[0]
	| "?" => s[0]
	| "|" => s[0]
	| "$" => s[0]
	| "]" => s[0]
	| "<-" => Token.LESS_MINUS
	| "->" => Token.MINUS_MORE
	| "=>" => Token.EQ_MORE
	| "<[" => Token.LESS_SQBRAC
	| "]>" => Token.SQBRAC_MORE
	| "&&" => Token.LAZY_AND
	| "||" => Token.LAZY_OR
	| _ => tok
      }
    }

  get_number (first_ch : int) : int
    {
      def buf = StringBuilder();
      
      buf.Append ((first_ch : char));

      def eat_digits () : void
	{
	  if (is_digit (peek ())) {
	    buf.Append ((read () : char));
	    eat_digits ()
	  }
	  else
	    ()
	};

      eat_digits ();  
      val <- Number (Int32.Parse (buf.ToString ()));

      Token.NUMBER_LITERAL
    }

  get_id (first_ch : int) : int
    {
      if (first_ch == '\'' && !is_id_beg (peek ())) {
	get_char()
      } 
      else {
	def buf = StringBuilder();
	
	buf.Append ((first_ch : char));
	
	def eat_alphanum () : void
	  {
	    if (is_id_beg (peek ()) || is_digit (peek ()) || peek() == '\'') {
	      buf.Append ((read () : char));
	      eat_alphanum ()
	    }
	    else
	      ()
	  };
	    
	eat_alphanum ();
	def str = buf.ToString ();
	
	if (first_ch == '\'' && str.Length == 2 && str[1] == '\'') {
	  val <- (((str[0] : int)) : Object);
	  Token.CHAR_LITERAL
	}
	else {
	  val <- (str : Object);
	  
	  if (first_ch == '\'')
	  Token.TYVAR
	  else {
	    init_keywords();
	    
	    if (keywords[str] != null)
	      (keywords[str] : int)
	    else
	      Token.ID
	  }
	}
      }
    }

  escape_value (ch : int) : int
    {
      match (ch) {
	| 'n' => '\n'
	| 't' => '\t'
	| 'r' => '\r'
	| 'b' => '\b'
	| '"' => '"'
	| '\'' => '\''
	| '\\' => '\\'
	| _ => -1
      }
    }
    
  error(msg : string) : int
    {
      Message.error (get_current_location (), msg);
      Token.ERROR
    }

  get_char () : int
    {
      def ret = get_string('\'');
      if (ret == Token.ERROR)
        ret
      else {
	def v = (val : string);
	if (v.Length == 0)
  	  error ("empty character literal")
	else {
	  if (v.Length != 1)
	    error("character literal too long")
	  else {
	    val <- Number ((v[0] : int));
	    Token.CHAR_LITERAL;
	  }
	}
      }
    }

  get_string(end_ch : char) : int
    {
      def buf = StringBuilder();
      mutable ch <- -1;
		
      def loop () : option (int)
	{
	  if (ch != end_ch) {
	    ch <- read();
	    match (ch) {
	      | '\\' =>
	        ch <- read();
	      	def esc = escape_value(ch);
		if (esc == -1)
		  Some (error("invalid escape in string literal"))
		else {
		  buf.Append ((esc : char));
		  ch <- ' ';
		  loop ()
		}

	      | '\n' =>
	        error ("newline in string literal")

              | n =>
                if (n == -1)
	          error ("EOF in string literal")
                else
  	          if (ch != end_ch) {
	            buf.Append((ch : char));
		    loop ()
	       	  }
	       	  else 
 	            None
	    }
	  }
          else
            None
       	};
       
      match (loop ()) {
       	| Some (err) => err
       	| None =>
	  val <- buf.ToString ();
     
          Token.STRING_LITERAL
      }
    }

  get_quoted_op () : int
    {
      get_op(Token.ID, read());
      if (peek() != '`') {
	read();
	error("invalid character in quoted op")
      }
      else {
	read();
	Token.ID
      }
    }

  get_double_quoted_id () : int
    {
      def buf = StringBuilder();
      mutable ch <- -1;

      def loop () : option (int)
        {
          if (ch != '`') {
            ch <- read();
            
            match (ch) {
              | '`' =>
                if (read() != '`')
                  Some (error("invalid character in double quoted id"))
                else {
              	  if (ch != '`') buf.Append ((ch : char))
                  else ();
                  loop ()
                }
              | '\n' =>
                Some (error("newline in double quoted id"))
              | _ =>
                Some (error("EOF in double quoted id"))
            }
          }
          else
            None
        };
        
      match (loop ()) {
        | Some(e) => e
        | _ =>
          val <- buf.ToString ();
          Token.ID
      }
    }
		
  get_quoted_id () : int
    {
      def buf = StringBuilder ();
      mutable ch <- -1;
		
      def loop () : option (int)
        {
          if (ch != '`') {
            ch <- read();

            match (ch) {
              | '`' =>
                if (ch != '`')
                  buf.Append ((ch : char))
                else ();
                loop ()
              | '\n' =>
                Some (error("newline in infix id"))
              | _ =>
                Some (error("EOF in infix id"))
            }
          }
          else
            None
        };

      match (loop ()) {
        | Some (e) => e
        | _ =>
          val <- buf.ToString ();
          Token.OP4
      }
    }

  get_token () : int
    {
      def last_line = line;
      def last_col = col;
      mutable ch <- read();
		
      match (ch) {
        | ' ' => get_token ()
        | '\t' => get_token ()
        | '\r' => get_token ()
        | '\n' => get_token()
        | '"' => get_string('"')

        | '`' =>
          if (peek () == '`') {
            read();
            get_double_quoted_id()
          }
          else if (is_opchar (peek ())) {
            get_quoted_op()
          } else get_quoted_id()

        | '\'' => get_id('\'')

        | '(' =>
          if (peek () == '*') {
            read();
            skip_comment();
            get_token()
          } else ch

        | ':' =>
          if (peek () == '>') {
            read();
            Token.COLON_MORE
          } else if (peek () == ':') {
            read();
            Token.COLON_COLON
          } else ch

        | '{' => ch
        | '}' => ch
        | '[' => ch
        | ',' => ch
        | ';' => ch
        | '.' => ch
        | ')' => ch
        | '#' => ch
        | '\\' => ch

        | '*' =>
          if (peek () == '*')
            get_op(Token.OP1, ch)
          else
            get_op(Token.OP2, ch)

        | '/' =>
          if (peek () == '/') {
            ch <- read ();

            def loop () : void {
              if (ch != '\n' && ch != -1) {
                ch <- read();
                loop ()
              }
              else
                ()
            };
            loop ();
            get_token()
          } else
            get_op(Token.OP2, ch)
				
        | '%' => get_op(Token.OP2, ch)
        | '+' => get_op(Token.OP3, ch)
        | '-' => get_op(Token.OP3, ch)
        | '@' => get_op(Token.OP4, ch)
        | '^' => get_op(Token.OP4, ch)
        | '$' => get_op(Token.OP4, ch)
        | '~' => get_op(Token.OP4, ch)
        | '?' => get_op(Token.OP4, ch)
        | '=' => get_op(Token.OP5, ch)
        | '<' => get_op(Token.OP5, ch)
        | '>' => get_op(Token.OP5, ch)
        | '!' => get_op(Token.OP5, ch)
        | ']' => get_op(Token.OP5, ch)
        | '&' => get_op(Token.OP6, ch)
	| '|' => get_op(Token.OP7, ch)

        | n =>
          if (n == -1) -1
          else
            if (is_digit (ch))
              get_number(ch)
            else
              if (is_id_beg (ch))
                get_id(ch)
              else
                error("invalid character")
      }      
    }

  public get_location () : Location
    {
      Location(file_name, last_line, last_col)
    }

  public get_current_location () : Location
    {
      Location(file_name, line, col)
    }

  // yyParser.yyInput
  public advance () : bool
    {
      cur_tok <- get_token();
      cur_tok != -1
    }
    
  public token () : int
    {
      if (cur_tok == -1)
        Util.ice ("attempt to read beyond end of file")
      else
       cur_tok
    }

  public value () : object
    {
      val
    }
	
  static init_keywords() : void
    {
      if (keywords != null)
        ()
      else {
        keywords <- Hashtable();
        keywords["_"] <- ('_' : int);
        keywords["abstract"] <- Token.KW_ABSTRACT;
        keywords["const"] <- Token.KW_CONST;
        keywords["extern"] <- Token.KW_EXTERN;
        keywords["internal"] <- Token.KW_INTERNAL;
        keywords["new"] <- Token.KW_NEW;
        keywords["private"] <- Token.KW_PRIVATE;
        keywords["protected"] <- Token.KW_PROTECTED;
        keywords["sealed"] <- Token.KW_SEALED;
        keywords["volatile"] <- Token.KW_VOLATILE;
        keywords["class"] <- Token.KW_CLASS;
        keywords["enum"] <- Token.KW_ENUM;
        keywords["extends"] <- Token.KW_EXTENDS;
        keywords["finally"] <- Token.KW_FINALLY;
        keywords["in"] <- Token.KW_IN;
        keywords["null"] <- Token.KW_NULL;
        keywords["out"] <- Token.KW_OUT;
        keywords["public"] <- Token.KW_PUBLIC;
        keywords["raise"] <- Token.KW_RAISE;
        keywords["ref"] <- Token.KW_REF;
        keywords["struct"] <- Token.KW_STRUCT;
        keywords["this"] <- Token.KW_THIS;
        keywords["variant"] <- Token.KW_VARIANT;
        keywords["interface"] <- Token.KW_INTERFACE;
        keywords["implements"] <- Token.KW_IMPLEMENTS;
        keywords["namespace"] <- Token.KW_NAMESPACE;
        keywords["where"] <- Token.KW_WHERE;
        keywords["type"] <- Token.KW_TYPE;
        keywords["let"] <- Token.KW_LET;
        keywords["fun"] <- Token.KW_FUN;
        keywords["and"] <- Token.KW_AND;
        keywords["tymatch"] <- Token.KW_TYMATCH;
        keywords["with"] <- Token.KW_WITH;
        keywords["try"] <- Token.KW_TRY;
        keywords["open"] <- Token.KW_OPEN;
        keywords["void"] <- Token.KW_VOID;
        keywords["base"] <- Token.KW_BASE;
        keywords["if"] <- Token.KW_IF;
        keywords["then"] <- Token.KW_THEN;
        keywords["else"] <- Token.KW_ELSE;
        keywords["as"] <- Token.KW_AS;
        keywords["match"] <- Token.KW_MATCH;
        keywords["static"] <- Token.KW_STATIC;
        keywords["mutable"] <- Token.KW_MUTABLE;
        keywords["def"] <- Token.KW_DEF;
        keywords["module"] <- Token.KW_MODULE;
        keywords["require"] <- Token.KW_REQUIRE;
        keywords["ensure"] <- Token.KW_ENSURE;
        keywords["array"] <- Token.KW_ARRAY;
        keywords["mkarray"] <- Token.KW_MKARRAY;
        keywords["macro"] <- Token.KW_MACRO;
//                keywords["pattern"] <- Token.KW_PATTERN;
      }
    }
} // end class Lexer
} // end ns
