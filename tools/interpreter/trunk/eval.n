using System;
using System.Text;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using Nemerle.Compiler;
using Nemerle.Collections.List;
using Nemerle.Utility;

public module Evaluator
{
 public static Eval (ret: Type, refr: list [string], 
                     ns: list [string], code: string): object {
  def cp = CompilerParameters (NArray.FromList (typeof (string), refr));
  cp.GenerateInMemory = true;
  def prog =
   FoldLeft (ns, "", fun (x: string, acc) { acc + "using " + x + ";\n" }) +
   "public module Exec {\n"
   " public static Foo(): " + ret.Name + " {\n"
   "  " + code + "\n"
   " }\n"
   "}\n";
  def cr = NemerleCodeProvider ().CreateCompiler ().
            CompileAssemblyFromSource (cp, prog);

  if (cr.Errors.HasErrors) {
   def error = StringBuilder ("AAAAAAAAAAAAAARGH!!!\n");
//   foreach (err: CompilerError in cr.Errors) { 
//    error.Append (err.ErrorText + "\n")
//   }
   for (mutable i=0; i<cr.Errors.Count; ++i) 
    error.Append (cr.Errors[i].ErrorText + "\n");

   throw Exception (error.ToString ());
  }
  else {
   def a = Assembly.LoadFrom (cp.OutputAssembly);
   def mi = a.GetTypes ()[0].GetMethod ("Foo");
   mi.Invoke (null, null);
  }
 }
}
