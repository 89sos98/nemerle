<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003, 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>The most interesting features we implemented using macros</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        This page is dedicated to the features of Nemerle and its library, which
        have been implemented using our <a ref="macros.html">meta-programming facilities</a>.
      </p>
      <p>
        Understanding how macros work is not necessary for using any of
        them. It would be useful only for knowing that those examples
        are just a tip of an iceberg called meta-programming and that you can easily
        implement even nicer things.
      </p>
    </body>
  </section>
  <section id="designbycontract">
    <title>Design by Contract</title>
      <body>
        <p>
          Languages like 
          <a ref="http://en.wikipedia.org/wiki/Eiffel_programming_language">Eiffel</a> 
          or 
          <a ref="http://research.microsoft.com/~leino/papers/krml136.pdf">Spec#</a> 
          incorporate a methodology called 
          <a ref="http://en.wikipedia.org/wiki/Design_by_contract">Design by Contract</a>
          to reason about programs, libraries, methods. It allows to write more
          secure and correct software and specify its behavior.
        </p>
        <p>
          The language following this design must support writing explicit requirements 
          about values on which a program operates. It contains:
        </p>
        <ul>
          <li>preconditions - some fact (boolean condition) that must be 
            satisfied in order to call a method; it mostly concerns passed
            parameters, but is necessary
          </li>
          <li>postconditions - a fact that must be satisfied after calling a method,
            for example about its return value
          </li>
          <li>invariants - a property of a program, which does not change in time (like
            a non-decreasing order of elements in list, etc.)
          </li>
          <li>other restrictions in behavior of some part of a program (like, for example,
            the fact that a method does not change the state of a class)
          </li>
        </ul>
        <p>
          We are currently on the way to add an ability to define most of those features
          to Nemerle. In the following subsections we present their current state, design
          and plans for the future.
        </p>
        <subsection id="requires">
          <title>Preconditions - Requires attribute</title>
            <body>
              <p>
                Preconditions of a method (conditions that need to be satisfied before the method is called) can be specified using the <tt>Requires</tt> attribute.
              </p>
<code>
<![CDATA[
class String {
  [Requires (startIdx >= 0 && startIdx <= this.Length)]
  public Substring (startIdx : int) : string 
  { ... }
}
]]></code>
              <p>
                Using this attribute we can add an arbitrary assertion, keeping the
                body of the method clean and verbose. The compiler automatically adds
                runtime checks at the beginning of the method. If the condition is
                violated, then an <tt>AssertionException</tt> is being thrown with 
                an appropriate message containing this expression.
              </p>
              <p>
                <tt>Requires</tt> and other attributes can occur many times before a single
                method. They can be also defined directly on parameters.
              </p>
<code>
ConnectTrees ([Requires (!tree1.Cyclic ())] tree1 : Graph,
              [Requires (!tree2.Cyclic ())] tree2 : Graph, 
              e : Edge) : Graph 
{ ... }
</code>
            </body>
        </subsection>
        <subsection id="ensures">
          <title>Postconditions - Ensures attribute</title>
            <body>
              <p>
                Following the same design, we can define postconditions which the
                method must satisfy. This is an assertion that must be true
                after the execution of the method. If the method returns a value, then a 
                symbol <tt>value</tt> is available inside the expression
                stating an assertion.
              </p>
<code>
class LinkedList {
  [Ensures (IsEmpty ())]
  public Clear () : void
  { ... }

  [Ensures (value >= 0)]
  public Length () : int
  { ... }
}
</code>
            </body>
        </subsection>
        <subsection id="invariants">
          <title>Class invariants - Invariant attribute</title>
            <body>
              <p>
                An even more powerful feature is to give a condition, which
                must be true all the time during the execution of a program.
                We can attach invariant to any class by writing <tt>Invariant</tt>
                attribute before its definition.
              </p>
<code>
<![CDATA[
[Invariant (position >= 0 && position <= arr.Length)]
class Vector <T> {
  private mutable position : int = 0;
  private arr : array <T> = array [];

  public push_back (x : T) : void 
  { ... }
]]></code>
              <p>
                This way we can control that our object is in some set of valid
                states.
				<!-- niejasne: we can check/verify if our object is in/belongs to a set of valid states? we can ensure that our object is in a set of valid states? -->

              </p>
              <p>
                This naturally brings the problem with changing variables,
                which are dependent on each other in invariant. Suppose we have 
                an assertion <tt>x == y + 5</tt> and we cannot change any of the variables.
                Thus, we need a mechanism for making transactions, within which
                invariants are temporarily ''turned off''.
              </p>
              <p>
                We follow the design of Spec# and add a special construct to expose 
                the object to changes.
              </p>
<code>
expose (this) {
  x += 3;
  y += 3;
}
</code>
              <p>
                <tt>expose</tt> takes reference to the object to be exposed and
                executes the given code.
              </p>
              <p>
                In the matter of fact, invariants are not checked all the time during
                execution. It would be too expensive to validate them at any assignment
                or call to external function. We again follow design of Spec# and 
                run assertions at the end of <tt>expose</tt> blocks and after execution
                of all public methods.
              </p>
            </body>
        </subsection>
        <subsection id="dsc-future">
          <title>Future work</title>
            <body>        
              <p>
                There are few more things which we want to implement in more or
                less distant future:
              </p>
              <ul>
                <li> 
                  a better syntax for those attributes 
<code>
class V { 
  invariant pos > 0; 

  Add (x : int) : void 
  requires x &lt; 0; 
  { ... } 
}
</code>
                </li>
                <li> 
                  Make these attributes inherited in classes deriving from those decorated
                  with assertions. For example, we define an interface with preconditions
                  and postconditions and we can be sure, that every class implementing this
                  interface will comply to them.
                </li>
                <li>
                  Plug a theorem prover designed for Spec# into Nemerle, so we can check
                  assertions not only in the runtime, but also statically at compile-time.
                </li>
                <li>
                  Invariant attribute needs much work to follow all functionality of
                  its Spec# counterpart.
                </li>
              </ul>
            </body>
        </subsection>
    </body>
  </section>
  <section id="checkedsql">
    <title>Compile-time validation of embedded SQL queries</title>
      <body>
        <p>
          As for now see 
          <a ref="http://nemerle.org/svn/nemerle/trunk/snippets/sql.n">this</a>.
	</p>
      </body>
  </section>
  <section id="aspects">
    <title>Aspects-Oriented programming</title>
      <body>
        <p>
          As for now see 
          <a ref="http://nemerle.org/svn/nemerle/trunk/ncc/testsuite/trace.n">this</a>.
	</p>
      </body>
  </section>
</document>
