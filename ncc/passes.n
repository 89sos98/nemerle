/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler 
{
  public module Passes 
  {
    public mutable cgil : CGIL;
    public mutable tyinfo_counter : int;
    
    mutable current_tyinfo_count : int;
    mutable current_pb_stage : int;
    
    mutable pb_killed : bool;

    public MarkTyinfoCompiled () : void
    {
      current_tyinfo_count <- current_tyinfo_count + 1;
      ProgressBar (10 + current_tyinfo_count * 90 / tyinfo_counter);
    }

    ProgressBar (stage : int) : void
    {
      when (Flags.progress_bar) {
        def max = 60;
        def act = stage * max / 100;
        def act = if (act > max) max else act;
        def diff = act - current_pb_stage;
        when ((pb_killed && diff > 10) || (!pb_killed && diff > 0)) {
          System.Console.Write ("\r" + System.String ('_', act) + 
                                       System.String ('.', max - act) + "\r");
          current_pb_stage <- act;
          pb_killed <- false;
        }
      }
    }

    public KillProgressBar () : void
    {
      when (Flags.progress_bar && !pb_killed) {
        System.Console.Write ("\n");
        pb_killed <- true;
      }
    }
    
    /** 
     * Run passes of the compiler.  This function is run after input files
     * are parsed.  [decls] contains list of declarations in list of
     * parsed modules. 
     */
    public run (decls : list <list <Top_decl>>) : void    
    {
      ProgressBar (5);
      cgil <- CGIL (!Flags.target_is_library, Flags.output_file_name);
      
      List.Iter (decls, Scan_globals.run);
      
      ProgressBar (8);

      if (Flags.just_dump_xml)
        XmlDump.run ()
      else {
        Tyinfo.Run ();
        Message.maybe_bailout();
        
        ProgressBar (10);

        cgil.EmitAuxDecls ();
        Message.maybe_bailout();

        cgil.EmitDecls ();
        Message.maybe_bailout();
        
        GlobalEnv.FinishMacroContextClass ();

        cgil.SaveAssembly ();
        Message.maybe_bailout();
        
        KillProgressBar ();
      }
    }      
  }
}
