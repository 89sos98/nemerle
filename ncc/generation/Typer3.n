/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  public class Typer3
  {
    current_fun : Fun_header;
    current_type : TypeBuilder;
    messenger : Messenger;

    public this (ty : TypeBuilder, fn : Fun_header)
    {
      current_fun = fn;
      current_type = ty;

      messenger = Passes.Solver.CurrentMessenger;
    }


    IsTopLevelFun : bool
    {
      get { current_fun.decl == null }
    }


    LocalRef (decl : LocalValue) : TExpr
    {
      LocalRef (decl, for_store = false)
    }


    LocalRef (decl : LocalValue, for_store : bool) : TExpr
    {
      def decl = decl.Redirect;
      def is_this = decl.ValKind is LocalValue.Kind.ClosurisedThisPointer;

      def res =
        if (decl.InClosure)
          if (!for_store && is_this && IsTopLevelFun)
            TExpr.This ()
          else {
            assert (decl.ClosureVal != null);
            assert (decl.ClosureField != null);
            def clo = TExpr.LocalRef (decl.ClosureVal.Type, decl.ClosureVal);
            TExpr.FieldMember (clo, decl.ClosureField)
          }
        else if (is_this)
          TExpr.This ()
        else
         TExpr.LocalRef (decl);

      res.ty = decl.Type;
      res
    }
    

    [Nemerle.NotImplemented]
    EmitStaticProxy (meth : IMethod) : TExpr
    {
    }
    

    [Nemerle.NotImplemented]
    HandleLocalFunction (fn : Fun_header) : void
    {
    }
    

    // expects reversed list
    BuildSequence (exprs : list [TExpr]) : TExpr
    {
      match (exprs) {
        | [] =>
          TExpr.Literal (InternalType.Void, Literal.Void ())
        | x :: xs =>
          def loop (acc, l) {
            match (l) {
              | [] => acc
              | TExpr.DefValIn (name, val, null) :: xs =>
                loop (TExpr.DefValIn (acc.Type, name, val, acc), xs)
              | x :: xs =>
                loop (TExpr.Sequence (acc.Type, x, acc), xs)
            }
          }
          loop (x, xs)
      }
    }


    PrepareClosure () : list [TExpr]
    {
      if (current_fun.closure_vars.IsEmpty) []
      else {
        def clo_type = current_type.DefineNestedType (<[ decl:
          private class $(Util.tmpname ("closure") : dyn)
          { }
        ]>);
        def closure_val =
          LocalValue (current_fun, "_N_closure", clo_type.GetMemType (), 
                      LocalValue.Kind.Plain (), is_mutable = false);
        foreach (decl in current_fun.closure_vars) {
          def ptdecl = <[ decl: 
            internal mutable 
              $(Util.tmpname (decl.Name) : dyn) : $(decl.Type : typed);
          ]>;
          decl.ClosureField = clo_type.DefineAndReturn (ptdecl) :> IField;
          decl.ClosureVal = closure_val;
        }
        def ctor = clo_type.DefineAndReturn (<[ decl: internal this () {} ]>);
        def ctor = Option.UnSome (ctor);
        def ctor_call = 
          TExpr.Call (clo_type.GetMemType (),
                      TExpr.StaticRef (ctor.GetMemType (), ctor), []);
        [TExpr.DefValIn (InternalType.Void, closure_val, ctor_call, null)]
      }
    }


    LoadParameters () : list [TExpr]
    {
      mutable initializers = [];
      
      foreach (fp in current_fun.parms) {
        def parm = fp.decl;

        if (parm.InClosure) {
          def a = TExpr.Assign (InternalType.Void,
                                LocalRef (parm, for_store = true), 
                                TExpr.LocalRef (parm.Type, parm));
          
          initializers = a :: initializers
        // this should be dead code with generics
        } else if (fp.ty.Fix ().IsSystemObject && ! parm.Type.Fix ().IsSystemObject) {
          def local = LocalValue (current_fun, parm.Name, parm.Type, 
                                  LocalValue.Kind.Plain (), is_mutable = parm.IsMutable);
          parm.Redirect = local;
          def val =
            TExpr.TypeConversion (parm.Type,
                                  TExpr.LocalRef (fp.ty, parm),
                                  parm.Type,
                                  ConversionKind.IL (true));
                                 
          def a = TExpr.DefValIn (InternalType.Void, local, val, null);
          initializers = a :: initializers
        } else {}
      }

      initializers
    }


    GetBaseCall () : option [TExpr]
    {
      // put base () / this () call before storing 'this' in closure inside constructor
      if (current_fun.name == ".ctor" && !current_type.IsValueType)
        match (current_fun.body) {
          | FunBody.Typed (TExpr.Sequence (TExpr.Call as basecall, rest)) =>
            current_fun.body = FunBody.Typed (rest);
            Some (Walk (basecall))

          | FunBody.Typed (TExpr.Call as basecall) =>
            current_fun.body = FunBody.Typed (BuildSequence ([]));
            Some (Walk (basecall))

          | FunBody.Typed (TExpr.TailCall as basecall) =>
            current_fun.body = FunBody.Typed (BuildSequence ([]));
            Some (Walk (basecall))
            
          | FunBody.Typed (body) =>
            Message.Warning (body.loc, body.ToString ());
            assert (false)

          | _ => assert (false)
        }
      else None ()
    }
    

    // the result is reversed!
    PrepareProlog () : list [TExpr]
    {
      // assigments of parameters and 'this' to closure fields
      // interleaved with base (..) call in constructor
      mutable initializers = [];

      // we build the initialization stuff of method:
      // 1. method's closure ctor()
      // 2. store parameters into closure
      // 3. base (..) / this (..) for constructors
      // 4. store 'this' in closure

      initializers = PrepareClosure ();

      initializers = LoadParameters () + initializers;

      match (GetBaseCall ()) {
        | Some (call) =>
          initializers = call :: initializers;
        | None => {}
      }

      // store 'this' into closure object
      foreach (d in current_fun.closure_vars) 
        when (d.InClosure && 
              d.ValKind is LocalValue.Kind.ClosurisedThisPointer) {
          def ini =
            TExpr.Assign (InternalType.Void,
                          LocalRef (d, for_store = true),
                          TExpr.This (current_type.GetMemType ()));
          initializers = ini :: initializers;
        }

      initializers
    }
    

    public Run () : void
    {
      Util.locate (current_fun.loc, {
        def initializers = PrepareProlog ();

        match (current_fun.body) {
          | FunBody.Typed (body) =>
            current_fun.body = FunBody.Typed (BuildSequence (Walk (body) :: initializers))
          | _ => assert (false)
        }
      })
    }


    Walk (expr : TExpr) : TExpr
    {
      expr.Walk (DoWalk)
    }


    [Nemerle.NotImplemented]
    EmitLoop (hd : Fun_header, parms : list [Parm]) : TExpr
    {
    }


    [Nemerle.NotImplemented]
    EmitDelegateCtor (meth : IMethod, parm : TExpr) : TExpr
    {
    }


    EmitCall (func : TExpr, parms : list [Parm], is_tail : bool) : TExpr
    {
      foreach (p in parms)
        p.expr = Walk (p.expr);

      def just_call (func) {
        if (is_tail)
          TExpr.TailCall (func, parms)
        else
          TExpr.Call (func, parms)
      }

      def plain_call () {
        def meth = InternalType.GetFunctionType (parms.Length).ApplyMethod;
        just_call (TExpr.MethodRef (func.ty, Walk (func), meth, false))
      }

      match (func) {
        // check if it's a base.Foo call
        | TExpr.MethodRef (
           TExpr.LocalRef (ty = ty, 
                           decl = LocalValue where (ValKind = 
                                      LocalValue.Kind.ClosurisedThisPointer) as decl) as obj, 
                         meth, _) when ! ty.Equals (decl.Type) =>
          just_call (TExpr.MethodRef (func.ty, Walk (obj), meth, true))
                           
        | TExpr.MethodRef (obj, meth, notvirt) =>
          just_call (TExpr.MethodRef (func.ty, Walk (obj), meth, notvirt))
          
        | TExpr.StaticRef (_ is IMethod)
        | TExpr.OpCode
        | TExpr.Base =>
          just_call (func)

        | TExpr.LocalRef (LocalValue where 
                          (ValKind = LocalValue.Kind.Function (hd, _)) as decl) =>
          match (hd.usage) {
            | FunctionUsage.UsedJustOnce =>
              EmitLoop (hd, parms)

            | _ =>
              _ = decl;
              // FIXME
              plain_call ()
          }

        | _ => plain_call ()
      }
    }


    DoWalk (expr : TExpr) : TExpr
    {
      // Message.Debug ($ "dowalk: $expr");
      match (expr) {
        | TExpr.LocalRef (decl) =>
          LocalRef (decl)
          
        | TExpr.StaticRef (_ is IField) =>
          null

        | TExpr.StaticRef (meth is IMethod) =>
          EmitStaticProxy (meth)

        // we do not support any other staticrefs here
        // everything should be handled by Typer2 already
        | TExpr.StaticRef => assert (false)
          
        | TExpr.DefFunctionsIn (funs, body) =>
          foreach (fn in funs)
            HandleLocalFunction (fn);
          Walk (body)

        // handled by Typer2.LambdaTransform
        | TExpr.MethodRef => assert (false)

        | TExpr.Call (TExpr.StaticRef (m is IMethod), [parm])
          when
            m.GetFunKind () is FunKind.Constructor && 
            m.DeclaringType.IsDelegate =>
          EmitDelegateCtor (m, parm.expr)

        | TExpr.TailCall (func, parms)
        | TExpr.Call (func, parms) =>
          EmitCall (func, parms, expr is TExpr.TailCall)

        | _ => null
      }
    }
  }
}
