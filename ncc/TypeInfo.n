/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

public type MemberTypes = System.Reflection.MemberTypes;
public type BindingFlags = System.Reflection.BindingFlags;
  
public variant MemberKind
{
  | Field { field : IField; }
  | Method { method : IMethod; }
  | Property { prop : IProperty; }
  | Type { tycon : TypeInfo; }
  | Event { body : IEvent; }
}

public variant TypeInfoKind
{
  | NemerleType { exact : TypeBuilder; }
  | ExternalNetType { exact : System.Type; }
  | ExternalNemerleType { exact : System.Type; }
}

public enum Accessibility
{
  | Public
  | Internal
  | ProtectedOrInternal
  | ProtectedAndInternal
  | Protected
  | Private
}

public interface IMember
{
  GetMemType () : TType;
  GetKind () : MemberKind;
  Location : Location { get; }
  GetId () : int;
  GetHandle () : System.Reflection.MemberInfo;
  CanAccess (source : TypeInfo) : bool;

  /* public properties */
  DeclaringType : TypeInfo {get;}
  Name : string {get;}
  MemberType : MemberTypes {get;}
  IsStatic : bool { get; } // types are always static
  HasBeenUsed : bool { get; set; } // for the 'unused' warnings
  
  Attributes : NemerleAttributes { get; }
  
  /* public methods */
  GetModifiers () : Modifiers;

  /* Return name that is unique for given member/overload, that is 
     name for fields, name/argument types for methods etc */
  OverloadName : string { get; }
}

public interface IField : IMember
{
  IsMutable : bool { get; }
  IsVolatile : bool { get; }
  IsLiteral : bool { get; }
  GetValue () : object;
  GetFieldInfo () : System.Reflection.FieldInfo;
}

public interface IEvent : IMember
{
  GetEventInfo () : System.Reflection.EventInfo;
  GetAdder () : IMethod;
  GetRemover () : IMethod;
}

public interface IMethod : IMember
{
  GetFreshType () : TType;
  GetHeader () : Fun_header;
  GetFunKind () : FunKind;
  GetMethodBase () : System.Reflection.MethodBase;
  GetMethodInfo () : System.Reflection.MethodInfo;
  GetConstructorInfo () : System.Reflection.ConstructorInfo;
  GetExternName () : option [string]; // None () if not extern
  IsVarArgs : bool { get; }
  IsFinal : bool { get; }  
}

public interface IProperty : IMember
{
  IsIndexer : bool { get; }
  IsMutable : bool { get; }
  GetPropertyInfo () : System.Reflection.PropertyInfo;
  GetGetter () : IMethod;
  GetSetter () : IMethod;
}

public abstract class TypeInfo : IMember
{
  protected mutable system_type : System.Type;
  id : int;
  protected mutable default_indexer : option [string];  

  public this () {
    id = Util.next_id ();
  }
  
  public GetHandle () : System.Reflection.MemberInfo
  { system_type }

  public GetId () : int
  { id }

  /** Compare types for equality. */
  public Equals (the_other : TypeInfo) : bool
  { id == the_other.id }

  [Nemerle.OverrideObjectEquals]
  public Equals (t : IMember) : bool
  {
    id == t.GetId ()
  }

  public override ToString () : string
  {
    FullName
  }

  public GetKind () : MemberKind
  {
    MemberKind.Type (this)
  }

  public abstract IsSealed : bool
  { get; }
  
  /** Types are always static */
  public IsStatic : bool
  {
    get { true }
  }

  /** Specifies if given type is an interface */
  public abstract IsInterface : bool
  {
    get;
  }
  
  /* Return name that is unique for given member/overload, that is 
     name for fields, name/argument types for methods etc */
  public OverloadName : string
  {
    get { Name }
  }

  public virtual GetLibraryReference () : LibraryReference { null }

  public DefaultIndexerName : option [string]
  {
    get {
      when (default_indexer == null)
        match (SuperClass ()) {
          | Some (tc) =>
            default_indexer = tc.DefaultIndexerName;

          | None => default_indexer = None ()
        };
      default_indexer        
    }
  }

  public GetSystemType () : System.Type
  {
    system_type
  }
  
  /** Return full qualified type name with namespaces.
   
      It probably should contain [+] instead of [.] for nested types.
   */
  public abstract FullName : string { get; } // FIXME: this could be with + or . ?

  /** Look for specified member. 

      Semantics of returning base class member is the same as for 
      [System.Type.GetMember] method.
   */
  public abstract LookupMember (name : string) : list [IMember];

  /** Return kind of this tycon. */
  public abstract GetTypeInfoKind () : TypeInfoKind;

  /** */
  public abstract GetTydecl () : TypeDeclaration;

  /** Construct substitution resulting from applying this type constructor
      to specified arguments.
      
      For example assuming our type parameters are are ('a, 'b), then
      [MakeSubst (t1, t2)] produces substitution { 'a := t1; 'b := t2 }.
   */
  public abstract MakeSubst (parms : list [TType]) : Subst;

  public abstract FreshSubst () : Subst;

  /** If this tycon subtypes [tycon], then return instantiation using
      which we subtype it.
   */
  public abstract SuperType (tycon : TypeInfo) : option [list [TType]];

  /** */
  public abstract SubtypingSubst (tycon : TypeInfo) : Subst;

  public abstract SuperClass () : option [TypeInfo];

  /** Return list of all members defined in this very type and its
      supertypes. */
  public abstract GetMembers () : list [IMember];

  /** Searches for the members defined for the current TypeInfo, using the
      specified binding constraints. */
  public abstract GetMembers (bindingAttr : BindingFlags) : list [IMember];

  /** Searches for the fields defined for the current TypeInfo, using the
      specified binding constraints. */
  public abstract GetFields (bindingAttr : BindingFlags) : list [IField];

  public abstract GetConstructors (bindingAttr : BindingFlags) : list [IMethod];
  
  /** */
  public abstract GetSuperTypes () : list [TType.Class];

  public abstract GetDirectSuperTypes () : list [TType.Class];

  /** If this is a constant variant option, this method returns static
      class member that shall be used instead of calling constructor.
      Otherwise [None ()] is returned. */
  public abstract GetConstantObject () : option [IField];

  public abstract IsDelegate : bool { get; }

  public abstract Accessibility : Accessibility { get; }

  /**
   * True if the type will be accessible from an external assembly.
   * This depends on this type's and parent types' accessibility.
   */
  public abstract IsExternallyAccessible : bool { get; }
  
  /** If this is constructor of value type (which is allocated on stack not on heap) */
  public abstract IsValueType : bool { get;}
  
  public abstract HasAttribute (attribute : TypeInfo) : bool;

  public abstract GetMemType () : TType;
  public abstract Location : Location { get; }
  public abstract CanAccess (source : TypeInfo) : bool;

  /* public methods */
  public abstract GetModifiers () : Modifiers;

  /* public properties */
  public abstract DeclaringType : TypeInfo {get;}
  public abstract Name : string {get;}
  public abstract MemberType : MemberTypes {get;}
  public abstract HasBeenUsed : bool { get; set; } // for the 'unused' warnings
  public abstract Attributes : NemerleAttributes { get; }
}

} // ns
