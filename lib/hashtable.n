/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections 
{
  /**
   * A functional type-safe wrapper for the System.Collections.Hashtable class.   
   */
  public class Hashtable ('a, 'b) 
    where 'a :> System.Object, 'b :> System.Object
    : IDictionary <'a,'b>
  {
    private mutable hashtable : System.Collections.Hashtable;


    /* -- PUBLIC CONSTRUCTORS ---------------------------------------------- */

    /**
     *
     */
    public this () {
      this.hashtable <- System.Collections.Hashtable ();
    }

    /**
     *
     */
    public this (capacity : int) {
      this.hashtable <- System.Collections.Hashtable (capacity);
    }

    /**
     *
     */
    public this (capacity : int, loadFactor : float) {
      this.hashtable <- System.Collections.Hashtable (capacity, loadFactor);
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */
        
    /**
     * 
     */
    public Get (key : ('a)) : option <'b> implements IDictionary.Item {
      def value = (this.hashtable [key] :> ('b));
      if (value != null) Some (value) else None ()
    }

    /**
     * This is different from add, which can fail if the key is
     * already in the underlying Framework hashtable...
     */
    public Set (key : ('a), val : ('b)) : void {
      this.hashtable [key] <- val
    }

    /**
     *
     */
    public Add (key : ('a), val : ('b)) : void {
      this.hashtable.Add (key, val);
    }

    /**
     *
     */
    public Clear () : void {
      this.hashtable.Clear ();
    }

    /**
     *
     */
    public Clone () : Hashtable <'a,'b> {
      (this.hashtable.Clone () :> Hashtable <'a,'b>)
    }

    /**
     *
     */
    public Contains (key : ('a)) : bool {
      this.hashtable.Contains (key)
    }

    /**
     *
     */
    public Count () : int {
      this.hashtable.Count
    }

    /**
     *
     */
    public ContainsValue (val : ('b)) : bool {
      this.hashtable.ContainsValue (val)
    }

    /**
     *
     */
    public Remove (key : ('a)) : void {
      this.hashtable.Remove (key)
    }

    /**
     *
     */
    public 'c Fold (f : ('a * 'b * 'c) -> 'c, s : 'c) : 'c 
    {
      def loop (x : ('c), enumerator : System.Collections.IDictionaryEnumerator) {
        if ((enumerator :> System.Collections.IEnumerator).MoveNext ())
          loop (f ((enumerator.Key :> ('a)), (enumerator.Value :> ('b)), x), enumerator)
        else x
      };

      loop (s, this.hashtable.GetEnumerator())
    }

    /**
     *
     */
    public Iter (f : ('a * 'b) -> void) : void {
      def loop (enumerator : System.Collections.IDictionaryEnumerator) : void {
        if ((enumerator :> System.Collections.IEnumerator).MoveNext ()) {
          f ((enumerator.Key :> ('a)), (enumerator.Value :> ('b)));
          loop (enumerator)   
        } else ()
      };

      loop (this.hashtable.GetEnumerator())
    }

    /**
     * Maps a given function defined of key-value pairs to the contents
     * of this hashtable. A new hashtable object is created, containing
     * the results of the application.
     */
    public 'c, 'd 
      where 'c :> System.Object, 'd :> System.Object
    Map (f : ('a * 'b) -> ('c * 'd)) : Hashtable <'c,'d>
    {
      mutable ht <- Hashtable ();

      def loop (enumerator : System.Collections.IDictionaryEnumerator) : void {
        if ((enumerator :> System.Collections.IEnumerator).MoveNext ()) {
          match (f ((enumerator.Key :> ('a)), (enumerator.Value :> ('b)))) {
            | (k, v) => ht.Add (k, v)
          };
      
          loop (enumerator)   
        } else ()
      };

      loop (this.hashtable.GetEnumerator ());
      ht
    }

    /** 
     * Creates enumerator
     */
    public GetEnumerator() : IDictionaryEnumerator<'a,'b>
    {
      HashtableEnumerator(this.hashtable)
    }
  } /* end of class Hashtable ('a,'b) */


  class HashtableEnumerator<'a,'b>
    : IDictionaryEnumerator<'a,'b>
  {
    private mutable enumerator : System.Collections.IDictionaryEnumerator;

    public this(hashtable : System.Collections.Hashtable)
    {
      this.enumerator <- hashtable.GetEnumerator()
    }

    public Key() : 'a
    {
      (this.enumerator.Key :> 'a)
    }

    public Value() : 'b
    { 
      (this.enumerator.Value :> 'b)
    }

    public Entry() : DictionaryEntry<'a,'b>
    {
      def de = this.enumerator.Entry;
      DictionaryEntry((de.Key :> 'a),(de.Value :> 'b))
    }

    public Current() : DictionaryEntry<'a,'b>
    { 
      Entry ()
    }

    public Reset () : void
    {
      (this.enumerator : System.Collections.IEnumerator).Reset()
    }

    public MoveNext () : bool
    {
      (this.enumerator : System.Collections.IEnumerator).MoveNext()
    }
  }

} /* end of namespace */

