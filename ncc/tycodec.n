/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {


module TyCodec 
{

  variant Term
  {
    | App { name : string; args : list [Term]; }
  }
  

  ParseTerm (s : string) : Term
  {
    def get_name (pos) {
      def idx = s.IndexOf ('(', pos);
      assert (idx != -1);
      (idx + 1, s.Substring (pos, idx - pos))
    };
    
    def maybe_get (pos) {
      if (s[pos] == ')') (pos + 1, None ())
      else {
        def (pos, name) = get_name (pos);
        def (pos, args) = get_list ([], pos);
        (pos, Some (Term.App (name, args)))
      }
    } 
    and get_list (acc, pos) {
      match (maybe_get (pos)) {
        | (pos, None) => (pos, List.Rev (acc))
        | (pos, Some (x)) => get_list (x :: acc, pos)
      }
    };
    
    match (maybe_get (0)) {
      | (pos, Some (ret)) =>
        assert (pos == s.Length);
        ret
      | (_, None) =>
        assert (false);
    }
  }
  

  FlattenTerm (t : Term) : string
  {
    def ret = System.Text.StringBuilder ();
    def walk (t) {
      | Term.App (name, args) =>
        ignore (ret.Append (name));
        ignore (ret.Append ('('));
        List.Iter (args, walk);
        ignore (ret.Append (')'));
    };
    walk (t);
    ret.ToString ()
  }


  encode (t : TType) : Term
  {
    match (t) {
      | TType.ByRef (t) => 
        Term.App (".r", [encode (t)])
      | TType.Out (t) =>
        Term.App (".o", [encode (t)])
      | TType.Array (t, rank) =>
        Term.App (".a", [Term.App (rank.ToString (), []), encode (t)])
      | TType.Variable (tv) =>
        Term.App (".v", [Term.App (tv.id.ToString (), [])])
      | TType.Void =>
        Term.App ("System.Void", [])
      | TType.Function (arg, rt) =>
        Term.App (".f", [encode (arg), encode (rt)])
      | TType.Product (args) =>
        Term.App (".p", List.Map (args, encode))
      | TType.Class (ti, args) =>
        Term.App (Tyutil.FrameworkTypeName (ti), List.Map (args, encode))
    }
  }
    
  /**
   * Used to emit Nemerle types in assembly metadata
   *
   * [remarks]
   *   The type tree is converted to prefix, term-like notation.
   * </remarks>
   */
  public EncodeType (t : TType) : string
  {
    FlattenTerm (encode (t))
  }

  decode (lib : LibraryReference, tenv : SystemMap [int, Tyvar.T], t : Term) : TType
  {
    def self (t) { decode (lib, tenv, t) };
    match (t) {
      | Term.App (name, args) when name[0] != '.' =>
        match (GlobalEnv.LookupExactType (Nemerle.Utility.NString.Split (name, array ['.', '+']))) {
          | Some (tc) =>
            if (tc.FullName == "System.Void") TType.Void ()
            else
              TType.Class (tc, List.Map (args, self))
          | None =>
            match (lib.LookupInternalType (name)) {
              | Some (tc) =>
                TType.Class (tc, List.Map (args, self))
              | None => Util.ice ("unbound encoded type " + name)
            }
        }
      | Term.App (".r", [t]) => TType.ByRef (decode (lib, tenv, t))
      | Term.App (".o", [t]) => TType.Out (decode (lib, tenv, t))
      | Term.App (".a", [Term.App (srank, []), t]) => TType.Array (decode (lib, tenv, t), System.Int32.Parse (srank))
      | Term.App (".f", [t1, t2]) => TType.Function (decode (lib, tenv, t1), decode (lib, tenv, t2))
      | Term.App (".v", [Term.App (no, [])]) =>
        match (tenv.Find (System.Int32.Parse (no))) {
          | Some (tv) => TType.Variable (tv)
          | None => Util.ice ("unboud type variable in encoded type " + no)
        }
      | Term.App (".p", types) => TType.Product (List.Map (types, self))
      | Term.App (name, _) => Util.ice ("invalid encoded type opcode " + name)
    }
  }


  /**
   * Used to decode Nemerle types extracted from assembly metadata
   */
  public DecodeType (lib : LibraryReference, tenv : SystemMap [int, Tyvar.T], tokens : string) : TType
  {
    decode (lib, tenv, ParseTerm (tokens))
  }
  

  encode_typarms (tyvars : list [Tyvar.T]) : Term
  {
    def encode_tyvar (tv : Tyvar.T) {
      Term.App ("", [Term.App (tv.id.ToString (), []),
                Term.App (tv.name, []),
                Term.App ("", List.Map (tv.constraints, encode))])
    };
    
    Term.App (".tp", List.Map (tyvars, encode_tyvar))
  }
  
   
  decode_typarms (lib : LibraryReference, 
                  tenv : SystemMap [int, Tyvar.T], 
                  t : Term) : list [Tyvar.T] * SystemMap [int, Tyvar.T]
  {
    mutable tyvars = [];
    def decode_tyvar (t, acc : SystemMap [int, Tyvar.T]) {
      match (t) {
        | Term.App (_, [Term.App (no, []), Term.App (name, []), _]) =>
          def tv = Tyvar.T (name);
          tyvars = tv :: tyvars;
          acc.Replace (System.Int32.Parse (no), tv)
        | _ => Util.ice ("evil encoded tyvar")
      }
    };

    def vars =
      match (t) {
        | Term.App (".tp", vars) => vars
        | Term.App (name, _) => Util.ice ("invalid typarms in encoded type " + name)
      };
      
    def tenv = List.FoldLeft (vars, tenv, decode_tyvar);
    
    def set_constraints (t, tv : Tyvar.T) {
      match (t) {
        | Term.App (_, [_, _, Term.App (_, constraints)]) =>
          def add_constraint (t) { tv.add_constraint (decode (lib, tenv, t)) };
          List.Iter (constraints, add_constraint);
        | _ => Util.ice ("evil encoded tyvar")
      }
    };

    tyvars = List.Rev (tyvars);
    List.Iter2 (vars, tyvars, set_constraints);
    
    (tyvars, tenv)
  }
  

  encode_tyinfo (ti : TypeBuilder) : Term
  {
    Term.App (".ti", [
      encode_typarms (ti.GetTyparms ()),
      Term.App ("", List.Map (ti.GetDirectSuperTypes (), encode)),
      Term.App ("", List.Map (ti.GetSuperTypes (), encode))
    ])
  }

  public DecodeTypeBuilder (lib : LibraryReference, 
                       tenv : SystemMap [int, Tyvar.T], 
                       s : string) 
    : list [Tyvar.T] * SystemMap [int, Tyvar.T] * list [TType] * list [TType]
  {
    match (ParseTerm (s)) {
      | Term.App (".ti", [tp, Term.App (_, dst), Term.App (_, st)]) =>
          def (tyvars, tenv) = decode_typarms (lib, tenv, tp);
          def decode_ty (t) { decode (lib, tenv, t) };
          (tyvars, tenv, List.Map (dst, decode_ty), List.Map (st, decode_ty))
      | _ => Util.ice ("evil encoded tyinfo " + s)
    }
  }


  public FixupFunctionHeader (lib : LibraryReference,
                              tenv : SystemMap [int, Tyvar.T], 
                              fh : Fun_header, 
                              tokens : string) : void
  {
    match (ParseTerm (tokens)) {
      | Term.App (".m", [tp, ty]) =>
        def (tyvars, tenv) = decode_typarms (lib, tenv, tp);
        fh.typarms = tyvars;
        match (decode (lib, tenv, ty)) {
          | TType.Function (arg, rt) =>
            fh.ret_type = rt;
            def arg_types = Tyutil.fun_args (arg);
            def set_type (p : Fun_parm, t) {
              p.ty = t;
            };
            List.Iter2 (fh.parms, arg_types, set_type);
          | _ => Util.ice ("encoded method type aint ->")
        }
      | _ => Util.ice ("evil encoded method header " + tokens)
    }
  }
  
  
  public EncodeMemberType (m : IMember) : string
  {
    match (m.GetKind ()) {
      | MemberKind.MK_field (m) => EncodeType (m.GetMemType ())
      | MemberKind.MK_method (m) =>
        def tp = encode_typarms (m.GetHeader ().typarms);
        def mt = encode (m.GetMemType ());
        FlattenTerm (Term.App (".m", [tp, mt]))
      | MemberKind.MK_property (m) =>
        EncodeType (m.GetMemType ())
      | MemberKind.MK_event (m) =>
        EncodeType (m.GetMemType ())
      | MemberKind.MK_type (t) =>
        match (t.GetTypeInfoKind ()) {
          | TypeInfoKind.TK_NemerleType (ti) =>
            FlattenTerm (encode_tyinfo (ti))
          | _ => assert (false)
        }
    }
  }
}

} // ns
