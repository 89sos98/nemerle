(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Collections;
open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

module Parser {

  class CTX {
    public lexer : ILexer;
    public mutable last_token : Token;
    public mutable push_back : option (Token);
  }

  'a where 'a :> Located 
  opt_locate (ctx : CTX, f : void -> option ('a)) : option ('a) {
    def loc = ctx.lexer.get_location ();
    def ret = Util.locate (loc, f);
    match (ret) {
      | Some (x) => x.loc <- loc
      | None => ()
    };
    ret
  }

  'a where 'a :> Located 
  locate (ctx : CTX, f : void -> option ('a)) : option ('a) {
    def loc = ctx.lexer.get_location ();
    def ret = Util.locate (loc, f);
    ret.loc <- loc;
    ret
  }

  get_token (ctx : CTX) : Token { 
    match (ctx.push_back) {
      | Some (x) =>
        ctx.push_back <- None ();
        x
      | None =>
        ctx.last_token <- ctx.lexer.get_token ();
        ctx.last_token
    }
  }

  peek_token (ctx : CTX) : Token {
    def tok = get_token (ctx);
    push_back (ctx);
    tok
  }
  
  push_back (ctx : CTX) : void {
    match (ctx.push_back) {
      | Some => Util.ice ()
      | None =>
        ctx.push_back <- Some (ctx.last_token)
    }
  }

  location (ctx : CTX) : Location {
    ctx.lexer.get_location ()
  }

  'a fatal_error (ctx : CTX, msg : string) : 'a {
    // FIXME: near...
    Message.fatal_error (location (ctx), "parse error: " + msg)
  }

  error (ctx : CTX, msg : string) : void {
    Message.error (location (ctx), "parse error: " + msg)
  }

  get_qid (ctx : CTX) : string {
    def loop (acc) {
      match (get_token (ctx)) {
        | Tok_operator (".", _) =>
          match (get_token (ctx)) {
            | Tok_identifier (x) => loop (acc + "." + x)
            | _ => fatal_error (ctx, "expecting identifier after dot in qualified ID")
          }
        | _ =>
          push_back (ctx);
          acc
      }
    };

    match (get_token (ctx)) {
      | Tok_identifier (x) =>
        loop (x)
      | _ =>
        fatal_error (ctx, "expecting qualified identifier")
    }
  }
  
  expect_operator (ctx : CTX, op : string) : void {
    match (get_token (ctx)) {
      | Tok_operator (o, _) when op == o => ()
      | _ =>
        fatal_error (ctx, "expecting '" + op + "'");
    }
  }


  parse_type_member (ctx : CTX) : option (Class_member) { null
  }

  parse_type (ctx : CTX) : Type { null }
  parse_type_list (ctx : CTX) : list (Type) { null }

  get_attrs (ctx : CTX) : list (Modifier) { [] }
  
  parse_tyvars (ctx : CTX) : list (string) { [] }

  parse_where_constraints (ctx : CTX, tyvars : list (string)) : Typarms { null }
  
  parse_type_decl (ctx : CTX) : Type_decl {
    def parse_header () {
      match (get_token (ctx)) {
        | Tok_identifier (name) =>
          def typarms =
            match (get_token (ctx)) {
              | Tok_operator ("(", _) =>
                def tyvars = parse_tyvars (ctx);
                expect_operator (ctx, ")");
                parse_where_constraints (ctx, tyvars);
              | _ => 
                push_back (ctx); 
                Typarms ([], [])
            };
            
          def t_extends =
            match (get_token (ctx)) {
              | Tok_keyword ("extends") =>
                Some (parse_type (ctx))
              | _ => 
                push_back (ctx); 
                None ()
            };
            
          def t_implements =
            match (get_token (ctx)) {
              | Tok_keyword ("implements") =>
                parse_type_list (ctx)
              | _ => 
                push_back (ctx); 
                []
            };
          
          (name, typarms, t_extends, t_implements)

        | _ => fatal_error (ctx, "expecting type name")
      }
    };
    
    def parse_variant_member (ctx) {
      locate (ctx, fun () {
        match (get_token (ctx)) {
          | Tok_operator ("|", _) =>
            def id = get_id (ctx);
            def members =
              match (peek_token (ctx)) {
                | Tok_operator ("{", _) =>
                  def parse_field (ctx) {
                    locate (ctx, fun () {
                      def attrs = get_attrs (ctx);
                      def is_ref =
                        match (get_token (ctx)) {
                          | Tok_keyword ("mutable") => true
                          | _ => push_back (ctx); false
                        };
                      def id = get_id (ctx);
                      expect_operator (ctx, ":");
                      def ty = parse_type (ctx);
                      expect_operator (ctx, ";");
                      def f = M_field (ty = ty, 
                                       is_ref = is_ref, 
                                       kind = Val_normal ());
                      f.name <- id;
                      f.modifiers <- attrs;
                      f
                    })
                  };
                  collect_braced_list (ctx, parse_field)
                | _ => []
              };
            
        }
      })
    };
    
    def parse_iface_member (_) { null };
    
    def parse_members () {
      collect_braced_list (ctx, parse_type_member)
    };
  
    def attrs = get_attrs (ctx);
    def tok = get_token (ctx);
    opt_locate (ctx, fun () {
      match (tok) {
        | Tok_keyword ("type")
        | Tok_keyword ("class")
        | Tok_keyword ("struct")
        | Tok_keyword ("module")
        | Tok_keyword ("interface")
        | Tok_keyword ("variant") =>
          def (name, typarms, t_extends, t_implements) = parse_header ();
          def (attrs, td) =
            match (tok) {
              | Tok_keyword ("class") =>
                (attrs, TD_class (parse_members ()))
              | Tok_keyword ("struct") =>
                (Mod_struct () :: attrs, TD_class (parse_members ()))
              | Tok_keyword ("module") =>
                (Mod_module () :: attrs, TD_class (parse_members ()))
              | Tok_keyword ("type") =>
                expect_operator (ctx, "=");
                match (get_token (ctx)) {
                  | Tok_keyword ("extern") =>
                    match (get_token (ctx)) {
                      | Tok_string_literal (s) => 
                        expect_operator (ctx, ";");
                        (attrs, TD_external (s))
                      | _ => 
                        fatal_error (ctx, "expecting quoted type name after `extern'")
                    }
                    
                  | _ =>
                    push_back (ctx);
                    def t = parse_type (ctx);
                    expect_operator (ctx, ";");
                    (attrs, TD_alias (t))
                }
                
              | Tok_keyword ("interface") =>
                def decls = collect_braced_list (ctx, parse_iface_member);
                (attrs, TD_interface (decls))
                
              | Tok_keyword ("variant") =>
                expect_operator (ctx, "{");
                def decls = collect_list (ctx, parse_variant_member);
                expect_operator (ctx, "}");
                (attrs, TD_variant (decls))
             
              | _ => Util.ice ()
            };
            
          td.modifiers <- attrs;
          
          td.name <- name;
          td.typarms <- typarms;
          td.t_extends <- t_extends;
          td.t_implements <- t_implements;

          Some (td)
          
        | Tok_keyword ("macro") => Util.ice () // FIXME
        
        | Tok_keyword ("}", _)
        | Tok_EOF =>
          push_back (ctx);
          None ()

        | _ => fatal_error ("expecting type declaration")
      }
    })
  }

  parse_topdecl (ctx : CTX) : Top_decl {
    def tok = get_token (ctx);
    locate (ctx, fun () {
      match (tok) {
        | Tok_keyword ("open") =>
          def id = get_qid (ctx);
          expect_operator (ctx, ";");
          TD_open (id)
          
        | Tok_keyword ("namespace") =>
          def id = get_qid (ctx);
          match (get_token (ctx)) {
            | Tok_operator ("=", _) =>
              when (id.IndexOf ('.') != -1) {
                Message.error ("namespace alias cannot contain dots")
              };
              def id' = get_qid (ctx);
              expect_operator (ctx, ";");
              TD_namespace_alias (id, id')
              
            | Tok_operator ("{", _) =>
              push_back (ctx);
              def decls = collect_braced_list (ctx, parse_topdecl);
              TD_namespace (id, decls)

            | _ =>
              fatal_error (ctx, "expecting '}' or '='")
          }

        | _ =>
          push_back (ctx);
          TD_type (parse_type_decl (ctx))
      }
    })
  }

  'a collect_braced_list (ctx : CTX, f : CTX -> 'a) : list ('a) {
    expect_operator (ctx, "{");
    def r = collect_list (ctx, f);
    expect_operator (ctx, "}");
    r
  }
  
  'a collect_list (ctx : CTX, f : CTX -> 'a) : list ('a) {
    def loop (acc) {
      match (peek_token (ctx)) {
        | Tok_operator ("}", _) | Tok_EOF => List.rev (acc)
        | _ =>
          loop (f (ctx) :: acc)
      }
    };
    loop ([])
  }

  public parse (lexer : ILexer) : list (Top_decl) {
    def ctx = CTX (lexer = lexer,
                   last_token = null, 
                   push_back = None ());
    def r = collect_list (ctx, parse_topdecl);
    match (peek_token (ctx)) {
      | Tok_EOF => r
      | _ => fatal_error ("expecting EOF")
    }
  }

} // end module
} // end namespace
