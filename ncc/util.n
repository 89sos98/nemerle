/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Util;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

  public class ICE : System.Exception
  {
    public msg : string;
    public this (m : string) { this.msg = m }
  }

  public class Recovery : System.Exception
  {
    public this () {}
  }

  public module Util 
  {
    mutable current_id : int;

    public Init () : void
    {
      current_id = 0;

    }

    public next_id () : int
    {
      current_id = current_id + 1;
      current_id
    }

    public ice<'a> (msg : string) : 'a { throw ICE (msg) }
    public ice<'a> () : 'a { throw ICE ("(see backtrace)") }

    public is_capitalized (s : string) : bool
    {
      def idx = s.LastIndexOf('.');
      s[idx + 1] >= 'A' && s[idx + 1] <= 'Z'
    }

    public tmpname (kind : string) : string
    {
      System.Text.StringBuilder ("_N_").Append (kind).
      Append (Util.next_id ().ToString ()).ToString ()
    }

    public qidl_of_expr (expr : Parsetree.Expr) 
           : option <list <string> * Parsetree.Name>
    {
      def loop (e, acc) {
        match (e) {
          | <[ $(x : name) ]> => Some ((List.Head (x.idl) :: acc, x))
          | <[ $obj . $(fld : dyn) ]> =>
            loop (obj, fld :: acc)
          | _ => None ()
        }
      };
      loop (expr, [])
    }

    public qid_of_list (l : list <string>) : string
    {
      Nemerle.Utility.NString.Concat (".", l)
    }

    public expr_of_qidl (parts : list <string>) : Parsetree.Expr
    {
      List.FoldLeft (parts, null, fun (name : string, expr) {
        if (expr == null)
          <[ $(name : dyn) ]>
        else
          <[ $expr . $(name : dyn) ]>
      })
    }
    
    public expr_of_qid (fullname : string) : Parsetree.Expr
    {
      expr_of_qidl (NString.Split (fullname, array ['.']))
    }
    
  }
  
  public module Message 
  {
    mutable error_cnt : int;
    mutable warning_cnt : int;
    mutable emitted_hints : Hashtable <string, int>;

    mutable output : System.IO.TextWriter;

/*
 FIXME: we can't use it because of bug in compiler
    public delegate ErrorEventHandler (loc : Location, msg : string) : void;
    public event ErrorOccured : ErrorEventHandler;
    public event WarningOccured : ErrorEventHandler;
  */
    public mutable ErrorOccured : Location * string -> void;
    public mutable WarningOccured : Location * string -> void;    
  
    public InitOutput (o : System.IO.TextWriter) : void
    {
      output = o;
      error_cnt = 0;
      warning_cnt = 0;
      unless (emitted_hints == null) emitted_hints.Clear ();
    }
    
    public location_to_string (l : Location) : string
    {
      if (l == Location.Default)
        "(no location)"
      else
        $"$(l.File):$(l.Line):$(l.Column)"
    }

    public report (l : Location, m : string) : void
    {
      def l' =
        if (l == Location.Default) Location_stack.top()
        else l;
      Passes.KillProgressBar ();
      if (l'.File != "" || l'.Line != 0 || l'.Column != 0)
        fprintf (output, "%s: %s\n", Message.location_to_string(l'), m)
      else
        fprintf (output, "%s\n", m)
    }

    public error (loc : Location, m : string) : void {
      when (ErrorOccured != null) ErrorOccured (loc, m);
        
      Message.error_cnt = Message.error_cnt + 1;
      if (Flags.color_messages)
        Message.report (loc, "\e[01;31merror\e[0m: " + m)
      else
        Message.report (loc, "error: " + m);        
    }

    public error (m : string) : void { Message.error (Location.Default, m) }

    public warning (loc : Location, m : string) : void {
      when (WarningOccured != null) WarningOccured (loc, m);
        
      Message.warning_cnt = Message.warning_cnt + 1;
      if (Flags.color_messages)
        Message.report (loc, "\e[01;33mwarning\e[0m: " + m)
      else
        Message.report (loc, "warning: " + m);
    }

    public warning (m : string) : void { Message.warning (Location.Default, m) }

    public hint (loc : Location, m : string) : void {
      if (Flags.color_messages)
        Message.report (loc, "\e[01;32mhint\e[0m: " + m)
      else
        Message.report (loc, "hint: " + m);
    }

    public hint (m : string) : void { Message.hint (Location.Default, m) }

    public hint_once (loc : Location, m : string) : void {
      when (emitted_hints == null)
        emitted_hints = Hashtable (20);
      unless (emitted_hints.Contains (m)) {
        if (Flags.color_messages)
          Message.report (loc, "\e[01;32mhint\e[0m: " + m)
        else
          Message.report (loc, "hint: " + m);
        emitted_hints.Add (m, 0)
      }
    }

    public hint_once (m : string) : void { Message.hint_once (Location.Default, m) }

    public debug (loc : Location, m : string) : void {
      Message.report (loc, "debug: " + m);
    }

    public debug (m : string) : void { Message.debug (Location.Default, m) }

    public fatal_error<'a> (loc : Location, m : string) : 'a {
      Message.error (loc, m);
      throw Recovery ()
    }

    public fatal_error<'a> (m : string) : 'a { Message.fatal_error (Location.Default, m) }

    public maybe_bailout (fscked_up : bool) : void {
      unless (Flags.ignore_confusion && fscked_up)
        when (seen_error ()) {
          when (fscked_up)
            printf ("confused by earlier errors bailing out\n");
          if (Flags.ignore_confusion)
            throw Recovery ()
          else
            System.Environment.Exit (1)
        }
    }

    public maybe_bailout () : void { Message.maybe_bailout (false) }

    public seen_error () : bool
    {
      error_cnt != 0
    }
  }

  public module Location_stack
  {
    mutable s : list <Location>;

    public push (l : Location) : void {
      Location_stack.s = l :: Location_stack.s
    }

    public pop () : void {
      match (Location_stack.s) {
        | _ :: t => Location_stack.s = t
        | [] => Util.ice()
      }
    }

    public top () : Location
    {
      match (Location_stack.s) {
        | h :: _ => h
        | [] => Location.Default
      }
    }

    this () { Location_stack.s = []; }
  }
}
