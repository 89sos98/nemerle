using System;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

namespace LRPEGCC
{
  partial internal class Optimizer
  {
    private static FindActiveRules(start : RuleRef, rules : Grammar) : Set[RuleRef]
    {
      def findActiveRules(rule, activeRulesNames : Set[RuleRef])
      {
        match (rule : Rule)
        {
        | Call(name)=>
          if (activeRulesNames.Contains(name))
            activeRulesNames;
          else
            findActiveRules(rules.GetRule(name), activeRulesNames.Add(name));
            
        | Choice(rules)            
        | Sequence(rules)          => rules.Fold(activeRulesNames, (rule, activeRulesNames) => findActiveRules(rule, activeRulesNames));
        
        | Capture(_, _, _, rule)   
        | CaptureNamedTerminalSymbol(_, rule)   
        | RepeatMin(_, rule)       
        | RepeatMinMax(_, _, rule) 
        | Not(rule)                
        | And(rule)                => findActiveRules(rule, activeRulesNames);
        
        | Chars                    
        | ExtensionPoint           => activeRulesNames;
        }
      }
      findActiveRules(rules.GetRule(start), Set().Add(start));
    }

    public static OptimizeGrammar(grammar : Grammar) : Grammar
    {
      def grammar = grammar.Names.Fold(Grammar(grammar.StartRuleName), (name, newGrammar) =>
      {
        newGrammar.Add(name, OptimizeRule(grammar.GetRule(name), grammar));
      });

      def activeRulesNames = FindActiveRules(grammar.StartRuleName, grammar);

      activeRulesNames.Fold(Grammar(grammar.StartRuleName), (name, newGrammar) =>
      {
        newGrammar.Add(name, grammar.GetRule(name));
      });
    }
  }
}
