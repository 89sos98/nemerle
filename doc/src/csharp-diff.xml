<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Quick summary of differences between Nemerle and C#</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document lists basic differences between Nemerle and C#
        in a terse form. If you know Java or C++ you also should be able
        to use it.
      </p>
    </body>
  </section>


  <section id="expr-changes">
    <title>Changes in expressions</title>
    <body>
      <comparison>
        <entry>
          <csharp>
            int x = 3;<br/>
            string y = "foo";<br/>
            FooBarQux fbq = make_fbq ();
          </csharp>
          <nemerle>
            def x = 3;<br/>
            def y = "foo";<br/>
            def fbq = make_fbq ();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> cannot be changed.
            <a ref="grokking.html#def-mutable">More info</a>.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
              int x = 3;<br/>
              string y = "foo";<br/>
              FooBarQux fbq = make_fbq();
          </csharp>
          <nemerle>
              mutable x = 3;<br/>
              mutable y = "foo";<br/>
              mutable fbq = make_fbq();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> can be changed.
            <a ref="grokking.html#def-mutable">More info</a>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta> = <meta>expr_3</meta>;
          </csharp>
          <nemerle>
            def tmp = <meta>expr_3</meta>;<br/>
            <meta>expr_1</meta> = tmp;<br/>
            <meta>expr_2</meta> = tmp;
          </nemerle>
          <remarks>
            The type of assignment operator is <tt>void</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> (<meta>parms</meta>)
          </csharp>
          <nemerle>
            <meta>Class</meta> (<meta>parms</meta>)
          </nemerle>
          <remarks> 
            The <tt>new</tt> keyword for creating an object is dropped.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            array (<meta>size</meta>)
          </nemerle>
          <remarks>
            If the type can be inferred (most of the time).
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            (array (<meta>size</meta>) : array &lt;<meta>Class</meta>&gt;)
          </nemerle>
          <remarks>
            If the type cannot be inferred.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Type</meta>[] { <meta>expr_1</meta>, <meta>expr_1</meta>, ..., 
              <meta>expr_n</meta> }
          </csharp>
          <nemerle>
            array [<meta>expr_1</meta>, 
                   <meta>expr_1</meta>, ..., 
                   <meta>expr_n</meta>]
          </nemerle>
          <remarks>
            The array constructor.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) return <meta>foo</meta>;<br/>
            <meta>do_something ()</meta>;<br/>
            return <meta>bar</meta>;
          </csharp>
          <nemerle>
            if (<meta>cond</meta>) <meta>foo</meta><br/>
            else {<br/>
            <meta>do_something ()</meta>;<br/>
            <meta>bar</meta><br/>
            }
          </nemerle>
          <remarks>
            There is no <tt>return</tt> statement that cuts control flow in Nemerle.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            when (<meta>cond</meta>) answer = 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without <tt>else</tt> is called <tt>when</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (!<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            unless (<meta>cond</meta>) answer = 42;<br/>
            // or: when (!<meta>cond</meta>) answer = 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without "then" is called
            <tt>unless</tt>. However nobody is forced to use it.
          </remarks>
        </entry>

        <entry>
          <csharp>
            try ... <br/>
            catch (FooException e) { ... }<br/>
            catch (BarException e) { ... }
          </csharp>
          <nemerle>
            try ... <br/>
            catch {<br/>
              | e : FooException => ...<br/>
              | e : BarException => ...<br/>
            }
          </nemerle>
          <remarks>
            Somewhat different syntax, consistent with <tt>match</tt> though.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> :> <meta>type</meta>)
          </nemerle>
          <remarks>
            Runtime type cast, allows for downcasts and upcasts.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> : <meta>type</meta>)
          </nemerle>
          <remarks>
            Static cast, allow only upcast.
          </remarks>
        </entry>

        <entry>
          <csharp>
            using System;<br/>
            using SWF = System.Windows.Forms;<br/>
            using System.Xml;<br/>
            ...<br/>
            Console.WriteLine ("foo");<br/>
            SWF.Form x = new SWF.Form ();<br/>
            XmlDocument doc = new XmlDocument ();
          </csharp>
          <nemerle>
            using System;<br/>
            using System.Console;<br/>
            using SWF = System.Windows.Forms;<br/>
            ...<br/>
            WriteLine ("foo");<br/>
            def x = SWF.Form ();<br/>
            def doc = Xml.XmlDocument ();
          </nemerle>
          <remarks>
            In Nemerle you can also apply <tt>using</tt> directive
            to classes. Opened namespaces allow to cut prefix of other namespaces
            like <tt>System</tt> in <tt>System.Xml</tt>.
            <a ref="grokking.html#using">More info</a>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            System.Windows.Forms.Button button = control as System.Windows.Forms.Button;<br/>
            if (button != null) ...<br/>
            else ...
          </csharp>
          <nemerle>
            match (control) {<br/>
              | button : System.Windows.Forms.Button => ...<br/>
              | listv : System.Windows.Forms.ListView => ...<br/>
              | _ => ...<br/>
            }
          </nemerle>
          <remarks>
            Expression returning <tt>null</tt> value if variable is of given
            type must be simulated with a little bit longer construct, but
            pattern <a ref="grokking.html#variants-and-matching">matching</a>
            is more general and powerful feature for most of the tasks where
            <tt>as</tt> would be used.
           </remarks>
        </entry>

        <entry>
          <csharp>
            x++;
          </csharp>
          <nemerle>
            ++x;
          </nemerle>
          <remarks>
            The <tt>++</tt> (and <tt>--</tt> for that matter) is only available in the prefix form right now.
          </remarks>
        </entry>

      </comparison>
    </body>
  </section>
  

  <section id="class-changes">
    <title>Changes in type definitions</title>
    <body>
      <comparison>

        <entry>
          <csharp>
              static int foo (int x, string y) { ... }
          </csharp>
          <nemerle>
              static foo (x : int, y : string) : int { ... }
          </nemerle>
          <remarks>
            Types are written after variables.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              public Foo (int x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              public this (x : int) { ... }<br/>
            }
          </nemerle>
          <remarks>
            Constructor name is always <tt>this</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo : Bar {<br/>
              public Foo (int x) : base (x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo : Bar {<br/>
              public this (x : int) { base (x); ... }<br/>
            }
          </nemerle>
          <remarks>
            Base constructor is called in function body.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              mutable x : int;<br/>
            }
          </nemerle>
          <remarks>
            Fields to be changed outside the constructor need to be marked 
            <tt>mutable</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              readonly int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              x : int;<br/>
            }
          </nemerle>
          <remarks>
            <tt>readonly</tt> is the default.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class C : I1, I2 {<br/>
              void I1.m () { ... }<br/>
              void I2.m () { ... }<br/>
            }
          </csharp>
          <nemerle>
            class C : I1, I2 {<br/>
              meth1 () : void implements I1.m { ... }<br/>
              meth2 () : void implements I2.m { ... }<br/>
            }
          </nemerle>
          <remarks>
            When two interfaces have the method with the same name.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class C {<br/>
              public object this [int i] { ... }<br/>
              [System.Runtime.CompilerServices.CSharp.IndexerName("MyItem")]<br/>
              public int this [string name] { ... }<br/>
            }
          </csharp>
          <nemerle>
            class C {<br/>
              public Item [i : int] : object { ... }<br/>
              public MyItem [name : string] : int { ... }<br/>
            }
          </nemerle>
          <remarks>
            Nemerle allows defining named indexers in an easier way, just like
            in VB.NET.
          </remarks>
        </entry>
      </comparison>
    </body>
  </section>

  <section id="generics">
    <title>As in Generic C#...</title>
    <body>
      <p>
        Syntax and semantics of parametric polymorphism in Nemerle
        is the same as what is called generics in C# 2.0. There is,
        however, a naming convention of  type variables with identifiers like
        <tt>'a</tt>. You do not need obey it though.
      </p>

      <comparison>

        <entry>
          <csharp>
            class A &lt;T> { readonly T x; }
          </csharp>
          <nemerle>
            class A &lt;'t> { x : 't; }
          </nemerle>
          <remarks>
          </remarks>
        </entry>

        <entry>
          <csharp>
            class A &lt;T> where T : IComparable &lt;T> { ... }
          </csharp>
          <nemerle>
            class A &lt;'t> where 't : IComparable &lt;'t> { ... }
          </nemerle>
          <remarks>
            Type parameters are written in parens <tt>&lt;></tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class A &lt;T> where T : IFoo, IBar { ... }
          </csharp>
          <nemerle>
            class A &lt;'t> where 't : IFoo, IBar { ... }
          </nemerle>
          <remarks>
          </remarks>
        </entry>

        <entry>
          <csharp>
            class A &lt;X,Y> where X : IFoo, IBar where Y : IBaz { ... }
          </csharp>
          <nemerle>
            class A &lt;'x,Y> where 'x : IFoo, IBar where Y : IBaz { ... }
          </nemerle>
          <remarks>
            Multiple type variables. ' is optional, but it is a common naming convention
            in functional programming.
          </remarks>
        </entry>

        <entry>
          <csharp>
            int meth&lt;A> (A x) { ... }
          </csharp>
          <nemerle>
            meth&lt;'a> (x : 'a) : int { ... }
          </nemerle>
          <remarks>
            Polymorphic method.
          </remarks>
        </entry>

        <entry>
          <csharp>
            int meth&lt;A> (A x) <br/>
            where A : IFoo { ... }
          </csharp>
          <nemerle>
            meth&lt;'a> (x : 'a) : int<br/>
            where 'a : IFoo { ... }
          </nemerle>
          <remarks>
            Polymorphic method with constraints.
          </remarks>
        </entry>

      </comparison>

    </body>
  </section>
 
  <section id="new-stuff">
    <title>New stuff</title>
    <body>
      <p>
        This section talks about the stuff more or less absent in C#.
      </p>
      
      <comparison>
        <entry>
          <csharp>
            void m(int _unused1, string _unused2) { ... }
          </csharp>
          <nemerle>
            m (_ : int, _ : string) : void { ... }
          </nemerle>
          <remarks>
            Upon each use the <tt>_</tt> keyword generates a new name.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class Foo { static readonly int x; static int m () { ... } }
          </csharp>
          <nemerle>
            module Foo { x : int; m () : int { ... } }
          </nemerle>
          <remarks>
            <tt>module</tt> is a class, that have all members <tt>static</tt>.
          </remarks>
        </entry>
      </comparison>

      <p>
        There are other things, that don't fit here very well (this document should 
        be a short list of differences), so we just give some links.
      </p>
      <ul>
        <li>
          <a ref="grokking.html#tuple">Tuples</a> -- nameless,
          heterogeneous data structure.
        </li>
        <li>
          <a ref="grokking.html#void-value">The void literal</a> -- strange
          thing.
        </li>
        <li>
          <a ref="grokking.html#named-parms">Named parameters</a> -- naming
          parameters in method calls.
        </li>
        <li>
          <a ref="grokking.html#local-functions">Local functions</a> --
          defining functions within other functions.
        </li>
        <li>
          <a ref="grokking.html#functional-values">Functional values</a>
          -- passing functions as parameters and returning them from
          other functions.
        </li>
        <li>
          <a ref="grokking.html#lambda-expr">Lambda expression</a> --
          defining nameless functions.
        </li>
        <li>
          <a ref="grokking.html#variants-and-matching">Variants and matching</a> --
          a big topic about special Nemerle data structure.
        </li>
        <li>
          <a ref="grokking.html#list-literals">List literals</a> --
          shortcut syntax for lists.
        </li>
        <li>
          <a ref="grokking.html#macros">Macros</a> -- powerful but safe
          code generating macros.
        </li>
      </ul>
    </body>
    
  </section>
  

  
  <section id="same">
    <title>The same</title>
    <body>
      <p>
        This section lists things that are written (mostly) the same way as
        they are in C#. It only includes cases when it could be doubtful.
      </p>
      <comparison>
        <entry>
          <csharp>
            // A comment.<br/>
            /* A possibly multiline<br/>
            comment. */<br/>
          </csharp>
          <nemerle>
            // A comment.<br/>
            /* A possibly multiline<br/>
            comment. */<br/>
          </nemerle>
          <remarks>
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            throw new System.ArgumentException ("foo");
          </csharp>
          <nemerle>
            throw System.ArgumentException ("foo")
          </nemerle>
          <remarks>
            <tt>throw</tt> is the same (but <tt>new</tt> is dropped).
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            @"foo\bar"
          </csharp>
          <nemerle>
            @"foo\bar"
          </nemerle>
          <remarks>
            Quoted string literals.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            using Foo;
          </csharp>
          <nemerle>
            using Foo;
          </nemerle>
          <remarks>
            In Nemerle one can be <tt>using</tt> classes in addition
            to namespaces.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            try { foo (); bar (); } <br/>
            catch (Exception e) { baz (); } <br/>
            finally { qux (); }
          </csharp>
          <nemerle>
            try { foo (); bar () } <br/>
            catch { e : Exception => baz () } <br/>
            finally { qux () }
          </nemerle>
          <remarks>
          </remarks>
        </entry>
      </comparison>
      
      <!-- TODO opertors?  -->
    </body>
  </section>

  
    <!-- 
      <comparison>
        <entry>
          <csharp>
          </csharp>
          <nemerle>
          </nemerle>
          <remarks>
          </remarks>
        </entry>
      </comparison>

    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
