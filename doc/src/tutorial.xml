<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Don't Panic! - Nemerle for C# Programmers</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This tutorial will describe basics of programming in Nemerle. We assume
        the reader is familiar with C#.
      </p>
    </body>
  </section>


  <section id="simple">
    <title>Simple examples</title>
    <body>
      <p>
        This section lists simple example, that look almost the same as
        in C#.
      </p>
    </body>
    <subsection id="hello">
      <title>The very-first example</title>
      <body>
<code>
class Hello
{
  static Main () : void
  {
    System.Console.WriteLine ("Hello world!");
  }
}
</code>
        <p>
          As you can see the only difference between Nemerle and C#
          version of this program is that we write method's return type
          at the right, after colon. There are some reason to do it this
          way, we will explain them in future.
        </p>
        <p>
          To run this example:
        </p>
        <ul>
          <li>
            write it with your favorite text editor and save it in 
            <file>hello.n</file>
          </li>
          <li>
            run the Nemerle compiler by typing <tt>ncc hello.n</tt>
          </li>
          <li>
            the output goes to <file>out.exe</file>
          </li>
          <li>
            run it by typing <tt>out</tt> or <tt>./out.exe</tt> depending
            on your OS
          </li>
        </ul>
        <p>
          For people unfamiliar with C#: the entry point of
          execution is the static <tt>Main</tt> method in some
          class. <tt>System.Console.WriteLine</tt> is call to function
          from the .NET framework.
        </p>
      </body>
    </subsection>
    <subsection id="adder">
      <title>The adder</title>
      <body>
        <p>
          We will now write a very simple program to read and add two numbers.
        </p>
<code>
/* Our second example.  This is a comment. */
// This is also a comment.

using System;

public class Adder      // As in C# we can mark class public.
{
  public static Main () : void          // And method too.
  {
    /* Read two lines, convert them to integers and return their
       sum.  */
    Console.WriteLine ("The sum is {0}", 
                       Int32.Parse (Console.ReadLine ()) + 
                       Int32.Parse (Console.ReadLine ()));
  }
}
</code>
        <p>
          The <tt>using</tt> declaration imports identifiers from
          specified namespace, so they can be used without prefix.
          Unlike in C# it can also import members from classes, not only
          from namespaces. For example:
        </p>
<code>
using System;
using System.Console;

public class Adder
{
  public static Main () : void
  {
    WriteLine ("The sum is {0}", 
               Int32.Parse (ReadLine ()) + 
               Int32.Parse (ReadLine ()));
  }
}
</code>
        <p>
          As you can see for both lines we first read them and then
          convert to integer. We can factor this into a method:
        </p>
<code>
using System;

public class Adder
{
  // It is private by default.
  static ReadInteger () : int
  {
    Int32.Parse (Console.ReadLine ())
  }
  
  public static Main () : void
  {
    def x = ReadInteger (); // Variable definition.
    def y = ReadInteger ();
    Console.WriteLine ("{0} + {1} = {2}", x, y, x + y);
  }
}
</code>
        <p>
          The method definition looks the way we would expect from
          <tt>Main</tt> example. However in <tt>Main</tt> itself we
          define two variables: <tt>x</tt> and <tt>y</tt>. This is done
          using the <tt>def</tt> keyword. As you can see we do not write
          type of variable at the place of definition. The compiler sees
          that <tt>ReadInteger</tt> returns <tt>int</tt> and therefore
          type of <tt>x</tt> has to also be <tt>int</tt>. This is called
          type inference.
        </p>
        <p>
          In this example we see no gain from using <tt>def</tt> instead
          of <tt>int</tt> as you would do in C# (both are 3 characters long :-).
          However in most cases type names are far longer:
        </p>
<code>
FooBarQuxxFactory fact = new FooBarQuxxFactory (); // C#
def fact = FooBarQuxxFactory (); // Nemerle
</code>
        <p>
          As you can see we also do not use the <tt>new</tt> keyword.
        </p>
      </body>
    </subsection>
    <subsection id="read-file">
      <title>Reading a file</title>
      <body>
<code>
<![CDATA[class Cat
{
  public static Main () : void
  {
    def sr = System.IO.StreamReader ("SomeFile.txt");   // (1)
    mutable line <- sr.ReadLine ();                     // (2)
    while (line != null) { // (3)
      System.Console.WriteLine (line);
      line <- sr.ReadLine ();   // (4)
    }; // (5)
    System.Console.WriteLine ("EOF");
  }
}]]>
</code>
        <p>
          There are few remarkable things about this example. First one
          is the very important difference between lines marked (1) and
          (2).
        </p>
        <p>
          In (1) we define immutable value <tt>sr</tt>. Immutable means
          it cannot be changed once it is defined. This may first seem
          odd, but it is quite often that variables are never changed,
          once created. The <tt>def</tt> statement is there to mark this 
          intent.
        </p>
        <p>
          In (2) we define mutable value. This is the same thing as
          variable in C#, It has to be initialized before use and can be
          changed later. The assignment operator in Nemerle is called
          <tt>&lt;-</tt>. It works much like <tt>=</tt> in C#. We see
          its use in (4).
        </p>
        <p>
          In (3) we see the <tt>while</tt> loop. It works much like
          in C#. We also have <tt>do ... while</tt> and <tt>repeat
          ... until</tt> loops in Nemerle. There is one slight difference
          between the <tt>while</tt> loop in Nemerle and C# -- as you
          see in (5) we need to put semicolon (<tt>;</tt>) after closing
          brace. This is general rule in Nemerle -- when expression is
          followed by some other expression in sequence, it need to be
          closed by semicolon.
        </p>
        <p>
          This is no mistake to call the <tt>while</tt> loop an
          expression. There is no such thing as statement in Nemerle,
          there are only expressions. It is perfectly valid to write:
        </p>
<code>
(if (foo) 1 else { while (qux) baz; 2 }) + 7
</code>
        <p>
          Each expression returns some value, although some expressions
          (like the <tt>while</tt> loop, <tt>def</tt> or <tt>mutable</tt>
          declarations, or an assignment operation) do not return
          any <b>useful</b> value. Such a value has type <tt>void</tt>,
          and you cannot do much with it.
        </p>
      </body>
    </subsection>
  </section>
   <!--
     Describe:
       - if
       - local functions + type inference
       - variants and matching
       - functions as first class citizens
       - namespace aliases
       - continuation monad
   -->
  

    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
