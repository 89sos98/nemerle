/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;

using System.Reflection;
using System.Reflection.Emit;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

class NemerleMember : IMember {
  loc : Location;
  protected mutable name : string;
  internal mutable modifiers : list <Modifier>;
  declaring_type : Tyinfo;
  id : int;
  protected mutable kind : MemberKind;
  internal mutable ty : Type;

  mutable is_protected : bool;
  mutable is_public : bool;
  mutable is_internal : bool;

  protected this (par : Tyinfo, d : PT.Class_member) {
    loc <- d.loc;
    modifiers <- d.modifiers;
    name <- d.name;
    declaring_type <- par;
    id <- Util.next_id ();

    def parse_mod (mod) {
      match (mod) {
        | Mod_public => is_public <- true
        | Mod_internal => is_internal <- true
        | Mod_protected => is_protected <- true
        | _ => ()
      }
    };
    List.Iter (parse_mod, d.modifiers);
  }

  public CanAccess (source : Tycon) : bool
  {
    def walk_declaring (tc : Tycon) {
      tc.SameAs (declaring_type) || 
        (tc.GetDeclaringTycon () != null && walk_declaring (tc.GetDeclaringTycon ()))
    };
    is_public || 
    declaring_type.SameAs (source) ||
    (is_internal && 
      match (source.GetTyconKind ()) { 
        | TK_NemerleType => true 
        | _ => false 
      }) || 
    (is_protected && Option.IsSome (source.SuperType (declaring_type))) ||
    walk_declaring (source)
  }

  public GetName () : string 
  { name }

  public GetMemType () : Type
  { ty }

  public GetKind () : MemberKind
  { kind }

  public GetDeclaringTycon () : Tycon
  { declaring_type }
  
  public GetLocation () : Location
  { loc }
  
  public GetModifiers () : list <Modifier>
  { modifiers }

  public IsStatic () : bool
  { List.Exists (fun (x) { match (x) { Mod_static => true | _ => false } }, GetModifiers ()) }

  public GetId () : int
  { id }

  public GetHandle () : System.Reflection.MemberInfo
  { null }
}

class NemerleField 
  : NemerleMember, IField
{
  is_mutable : bool;
  public mutable field_builder : FieldBuilder;
  
  public this (par : Tyinfo, f : PT.M_field) {
    base (par, f);
    is_mutable <- f.is_ref;
    ty <- par.BindType (f.ty);
    kind <- MK_field (this);
  }

  public IsMutable () : bool
  {
    is_mutable
  }

  public GetFieldInfo () : FieldInfo
  {
    field_builder
  }
}

class NemerleMethod
  : NemerleMember, IMethod
{
  // FIXME: make these private
  public mutable fun_kind : Fun_kind;
  public mutable fun_body : Fun_body;
  public mutable fun_header : Fun_header;
  
  public mutable method_builder : System.Reflection.Emit.MethodBuilder;
  public mutable ctor_builder : System.Reflection.Emit.ConstructorBuilder;

  public GetMethodBase () : MethodBase
  {
    if (method_builder == null)
      (ctor_builder : MethodBase)
    else
      method_builder
  }

  public GetConstructorBuilder () : ConstructorBuilder 
    implements IMethod.GetConstructorInfo
  {
    assert (ctor_builder != null);
    ctor_builder
  }
  
  public GetMethodBuilder () : MethodBuilder 
    implements IMethod.GetMethodInfo
  {
    assert (method_builder != null);
    method_builder
  }

  public GetExternName () : string
  {
    match (fun_body) {
      | FB_extern (name) => name
      | _ => null
    }
  }
  
  public this (par : Tyinfo, f : PT.M_function) {
    base (par, f);
    
    def par = par; // hack, so previouse par is not closurised

    def (tenv', typarms) = par.BindTyparms (f.header.typarms);
    def bind (t) { par.BindType (tenv', t) };
    def mkparm (p : PT.Fun_parm) : Fun_parm {
      Fun_parm (loc = p.loc, name = Macros.unsstring (p.name), ty = bind (p.ty), 
                decl = null)
    };
    def is_static = List.Exists (fun (m) { match (m) { Mod_static => true | _ => false } }, 
                                 GetModifiers ());
 
    fun_body <- f.body;
    
   /* We need to convert things like:
        foo (x : int * int) : int { bar }
            ===>
        foo (_1 : int, _2 : int) : int { def x = (_1, _2); bar }
      To be consistent. */

    def parms =
      match (f.header.parms) {
        | [parm] =>
          match (Tyutil.top_expand (bind (parm.ty))) {
            | T_prod (types) =>
              def mkdummyparm (t : Type) {
                Fun_parm (loc = parm.loc, 
                          name = Util.tmpname ("tupled"),
                          ty = t, 
                          decl = null)
              };
              def parms = List.Map (types, mkdummyparm);
              def refs = List.Map (fun (fp : Fun_parm) { PT.E_ref (fp.name) }, parms);
              match (fun_body) {
                | FB_parsed_expr (body) =>
                  def name = Macros.unsstring (parm.name);
                  fun_body <- FB_parsed_expr (<[ { def $(name : var) = ( .. $refs ); $body } ]>)
                | _ => Util.ice ()
              };
              parms
            | _ => List.Map (f.header.parms, mkparm)
          }
        | _ => List.Map (f.header.parms, mkparm)
      };

    fun_kind <-
      match (f.kind) {
        | FK_method ([]) when is_static =>
          FK_function ()
        | FK_method (_ :: _) when is_static =>
          Message.error ("static function cannot implement anything");
          FK_function ()
        | FK_ctor when is_static =>
          this.name <- ".cctor";
          FK_static_ctor ()
        | x => x
      };

    fun_header <- Fun_header (
      ret_type = bind (f.header.ret_type),
      typarms = typarms,
      name = this.name,
      parms = parms,
      id = Util.next_id (),
      closure_vars = [],
      all_locals = [],
      tenv = tenv',
      loc = f.header.loc,
      decl = null,
      cg_method = null);

    ty <- Tyutil.fun_type (fun_header);
    
    kind <- MK_method (this);
  }

  public SetHeader (h : Fun_header) : void {
    fun_header <- h;
    ty <- Tyutil.fun_type (fun_header);
  }

  public GetHeader () : Fun_header
  { fun_header }

  public GetFreshType () : Type
  { GetMemType () /- Tyvar.fresh_subst (fun_header.typarms) }

  public GetFunKind () : Fun_kind
  { fun_kind }
}

}
