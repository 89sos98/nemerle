(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(*
 * NOTE: this is bootstrap code that will be eventually removed
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Collections;
  open Nemerle.Compiler.Parsetree;
  open Nemerle.Compiler;

  (**
   * Allowed types of class members
   *)
  variant ExternalClassMemberDeclaration
  {
    | ECMD_constructor { param_list : list (Fun_parm); }
    | ECMD_static_method { name : string; return_type : Type; param_list : list (Fun_parm); }
    | ECMD_method { name : string; return_type : Type; param_list : list (Fun_parm); }
    | ECMD_property { name : string; property_type : Type; is_readable : bool; is_writeable : bool; }
  }


  (**
   * External declaration of a Framework class
   *)
  class ExternalClassDeclaration
  {
    public mutable members : list (ExternalClassMemberDeclaration);
    public mutable name : string;

    this (name : string, members : list (ExternalClassMemberDeclaration))
    {
      this.members <- members;
      this.name <- name;
    } 
  }


  (**
   * External declarations for Framework classes.
   *)
  class ExternalDeclarationsRegistry
  {
    (**
     * Holds the class declarations, indexed by full names
     *)
    public static mutable class_decls : String_map (ExternalClassDeclaration);   


    (**
     * The static constructor initializes the delarations store
     *)
    static this ()
    {
      class_decls <- Map.string_map ();
    }


    (**
     * Creates a public constructor declaration
     *)
    private static make_ctor (env : Env, location : Location, class_name : string, 
	  				                  param_list : list (Fun_parm)) : Class_member
    {
	    def header = Fun_header (location, ".ctor", Type.T_void (), param_list);
	    def member = Class_member.M_function (header, FK_ctor (), FB_extern (class_name + "..ctor"));
	    member.name <- ".ctor";
	    member.modifiers <- [Modifier.Mod_public ()];
	    member
    }
  

    (**
     * Creates a public static method declaration
     *)
    private static make_static_method (env : Env, location : Location, class_name : string, method_name : string, 
	              			  			         return_type : Type, param_list : list (Fun_parm)) : Class_member
    {
	    def location = Location("[MsCoreLib:" + class_name + "]", 0, 0);
	    def header = Fun_header (location, method_name, return_type, param_list);
	    def member = Class_member.M_function (header, FK_function (), FB_extern (class_name + "." + method_name));
	    member.name <- method_name;
	    member.modifiers <- [Modifier.Mod_public ()];
	    member  
    }

  
    (**
     * Creates a public method declaration
     *)
    private static make_method (env : Env, location : Location, class_name : string, method_name : string, 
					                      return_type : Type, param_list : list (Fun_parm)) : Class_member
    {
	    def header = Fun_header (location, method_name, return_type, param_list);
	    def member = Class_member.M_function (header, FK_method (Nil ()), FB_extern (class_name + "." + method_name));
	    member.name <- method_name;
	    member.modifiers <- [Modifier.Mod_public ()];
	    member  
    }


    (**
     * Creates a public property declaration
     *)
    private static make_property (env : Env, location : Location, class_name : string, property_name : string, 
					                        property_type : Type, is_readable : bool, is_writeable : bool) : Class_member
    {
      def reader = if (is_readable) Some (FB_extern (class_name + ".get_" + property_name)) else None ();
      def writer = if (is_writeable) Some (FB_extern (class_name + ".set_" + property_name)) else None ();      
	    def member = Class_member.M_property (property_type, reader, writer);
	    member.name <- property_name;
	    member.modifiers <- [Modifier.Mod_public ()];
	    member  
    }


    (**
     * Creates a public class member declaration
     *
     * TODO: - fix the locations in the param list
     *)
    private static make_class_member (env : Env, location : Location, class_name : string,
                                      member : ExternalClassMemberDeclaration) : Class_member
    {
      match (member) {
        | ECMD_constructor (param_list) => 
          make_ctor (env, location, class_name, param_list);
        | ECMD_static_method (name, return_type, param_list) => 
          make_static_method (env, location, class_name, name, return_type, param_list);
        | ECMD_method (name, return_type, param_list) => 
          make_method (env, location, class_name, name, return_type, param_list);
        | ECMD_property (name, property_type, is_readable, is_writeable) =>
          make_property (env, location, class_name, name, property_type, is_readable, is_writeable)
      }
    }

  
    (**
     * Processes a list of public class members
     *)  
    private static make_class_members (env : Env, location : Location, class_name : string, 
		                    		           class_members : list (ExternalClassMemberDeclaration)) : list (Class_member)
    {
      match (class_members) {
        | Nil => Nil ()
        | Cons (member, rest) =>
          Cons (make_class_member (env, location, class_name, member), 
			    make_class_members (env, location, class_name, rest))
      }
    }


    (**
     * Registers an external class declaration
     *)
    public static register_class (class_decl : ExternalClassDeclaration) : void
    {
	    def location = Location("[MsCoreLib:" + class_decl.name + "]", 0, 0);
	    def env = Env ();

	    def members = make_class_members (env, location, class_decl.name, class_decl.members);

	    def declaration = Type_decl.TD_class (members);
	    declaration.name <- class_decl.name;
	    declaration.loc <- location;
      declaration.typarms <- Typarms (Nil (), Nil ());
      declaration.t_extends <- None ();
      declaration.t_implements <- Nil (); 
      declaration.modifiers <- Cons (Modifier.Mod_public (), Nil ());

      def type_info = Tyinfo (None (), env, declaration);
      type_info.contained_types <- Nil ();
      type_info.make_tyenvs (Tyvar.TEnv ());
      type_info.bind_types ();

      def decl = Env.add_type (type_info);
      
      (* register the external class declaration *)
      ExternalDeclarationsRegistry.class_decls 
        <- ExternalDeclarationsRegistry.class_decls.add (class_decl.name, class_decl);

      ()
    }
    
    
    (* -- TEST AREA -------------------------------------------------------- *)
  
    private static make_param (param_name : string, param_type : Type) : Fun_parm
    {
	    def location = Location("[MsCoreLib]", 0, 0);

      Fun_parm (location, param_name, param_type);
    }

    private static make_type (type_name : string) : Type
    {
      Type.T_app (type_name, Nil ());
    }

    private static make_array_type (base_type_name : string) : Type
    {
      Type.T_array (make_type (base_type_name));
    }

    public static add_mscorelib_decls () : void
    {
      def core_void = Type.T_void ();
      def core_int = make_type ("Nemerle.Core.int");
      def core_bool = make_type ("Nemerle.Core.bool");
      def core_string = make_type ("Nemerle.Core.string");

      (* System.IO.StreamWriter *)    
      def system_io_streamwriter_ctor_string =
        ECMD_constructor ([make_param ("file_name", core_string)]);
      
      def system_io_streamwriter_writeline_string =
        ECMD_method ("WriteLine", core_void, [make_param ("format", core_string)]);
      
      def system_io_streamwriter_close =
        ECMD_method ("Close", core_void, Nil ());
      
      def system_io_streamwriter_flush =
        ECMD_method ("Flush", core_void, Nil ());
            
      def system_io_streamwriter =
        [system_io_streamwriter_ctor_string; system_io_streamwriter_writeline_string;
         system_io_streamwriter_close; system_io_streamwriter_flush];
      
      
      (* System.IO.File *)
      def system_io_file_exists =
        ECMD_static_method ("Exists", core_bool, [make_param ("path", core_string)]);
        
      def system_io_file = [system_io_file_exists];


      (* System.Console *)
      def system_console_writeline_1 =
        ECMD_static_method ("WriteLine", core_void, [make_param ("format", core_string)]);

      def system_console_writeline_2 =
        ECMD_static_method ("WriteLine", core_void, [make_param ("format", core_string);
                                                     make_param ("param0", core_string)]);

      def system_console_writeline_3 =
        ECMD_static_method ("WriteLine", core_void, [make_param ("format", core_string);
                                                     make_param ("param0", core_string);
                                                     make_param ("param0", core_string)]);

      def system_console_writeline_4 =
        ECMD_static_method ("WriteLine", core_void, [make_param ("format", core_string);
                                                     make_param ("param0", core_string);
                                                     make_param ("param0", core_string);
                                                     make_param ("param0", core_string)]);
        
      def system_console = [system_console_writeline_1; system_console_writeline_2;
                            system_console_writeline_3; system_console_writeline_4];

      
      (* System.Type *)
      def system_type_tostring =
        ECMD_method ("ToString", core_string, []);
         
      def system_type = [system_type_tostring];

      
      (* System.Reflection.Assembly *)
      def system_reflection_assembly_loadfrom =
        ECMD_static_method ("LoadFrom", make_type ("System.Reflection.Assembly"), 
                            [make_param ("assemblyFile", core_string)]);
      
      def system_reflection_assembly_gettypes =
        ECMD_method ("GetTypes", make_array_type ("System.Type"), []);
      
      def system_reflection_assembly = [system_reflection_assembly_loadfrom;
                                        system_reflection_assembly_gettypes];
      
      
      (* System.IO.FileNotFoundException *)
      def system_io_filenotfoundexception = [];
      
      (* System.Array *)
      def system_array_length =
        ECMD_property ("Length", core_int, true, false);
        
      def system_array = [system_array_length];
      
      register_class (ExternalClassDeclaration ("System.IO.StreamWriter", system_io_streamwriter));
      register_class (ExternalClassDeclaration ("System.IO.File", system_io_file));
      register_class (ExternalClassDeclaration ("System.Console", system_console));
      register_class (ExternalClassDeclaration ("System.Reflection.Assembly", system_reflection_assembly));
      register_class (ExternalClassDeclaration ("System.Type", system_type));
      register_class (ExternalClassDeclaration ("System.IO.FileNotFoundException", system_io_filenotfoundexception));
      register_class (ExternalClassDeclaration ("System.Array", system_array));
    }
  }
} (* namespace *)
