open Nemerle.Collections.Tree;
open Nemerle.Collections;

namespace Nemerle.Collections {

interface I_comparable_to ('a)
  {
    compare(_ : 'a) : int;
  }

interface I_comparator ('a)
  {
    compare(_ : 'a, _ : 'a) : int;
  }

class Impossible extends System.Exception
  {
    method this () {}
  }

variant node ('a) where 'a :> I_comparable_to('a) =
  [
    | R { l : node ('a); e : 'a; r : node ('a); }
    | B { l : node ('a); e : 'a; r : node ('a); }
    | T
  ]

class Tree
  {
    fun ('a) where 'a :> I_comparable_to('a) 
      balance (left : node('a), elem : 'a, right : node('a)) : node('a) =
      // this could be or pattern, but it's 10 times better then
      // it used to be anyway :-)
      match (left, elem, right) with [
        | (R (R (?a, ?x, ?b), ?y, ?c), ?z, ?d) =>
          R (B (a, x, b), y, B (c, z, d))
        | (R (R (?a, ?x, ?b), ?y, ?c), ?z, ?d) =>
          R (B (a, x, b), y, B (c, z, d))
        | (R (?a, ?x, R (?b, ?y, ?c)), ?z, ?d) =>
          R (B (a, x, b), y, B (c, z, d))
        | (?a, ?x, R (R (?b, ?y, ?c), ?z, ?d)) =>
          R (B (a, x, b), y, B (c, z, d))
        | (?a, ?x, R (?b, ?y, R (?c, ?z, ?d))) =>
          R (B (a, x, b), y, B (c, z, d))
        | _ => 
          R (left, elem, right)
      ];

    fun ('a) where 'a :> I_comparable_to('a) 
      insert (t : node('a), x : 'a) : node('a) =
      letfun ins (t : node ('a)) : node('a) =
        match t with [
          | T => R (T (), x, T ())
          | B ?y =>
            let res = y#e#compare (x) in
            if res > 0 then balance (ins (y#l), y#e, y#r)
            else if res < 0 then balance (y#l, y#e, ins (y#r))
            else B (y#l, x, y#r) // replace
          | R ?y =>
            let res = y#e#compare (x) in
            if res > 0 then R (ins (y#l), y#e, y#r)
            else if res < 0 then R (y#l, y#e, ins (y#r))
            else R (y#l, x, y#r)
        ] in 
          let t = ins (t) in
          match t with [
            | B => t
            | R ?x => B(x#l, x#e, x#r)
            | _ => raise Impossible()
          ];

    fun ('a) where 'a :> I_comparable_to('a) 
      find (t : node('a), x : 'a) : option('a) =
      letfun f (t : node('a)) : option('a) =
        match t with [
          | R ?y =>
            //let _ = print_string (".") in
            let res = y#e#compare (x) in
            if res > 0 then f (y#l)
            else if res < 0 then f (y#r)
            else option.Some(y#e)
          | B ?y =>
            //let _ = print_string ("+") in
            let res = y#e#compare (x) in
            if res > 0 then f (y#l)
            else if res < 0 then f (y#r)
            else option.Some(y#e)
          | T => option.None()
        ]
      in f(t);
  }

  class map_node ('a, 'b) implements I_comparable_to(map_node('a, 'b))
    {
      field key : 'a;
      field val : 'b;
      field cmp : I_comparator('a);
      
      method compare(x : map_node('a, 'b)) : int 
        implements I_comparable_to.compare
        = this#cmp#compare(this#key, x#key);

      method this (c : I_comparator('a), k : 'a, v : 'b) 
        { 
          this#cmp <- c;
          this#key <- k; 
          this#val <- v;
        }

      method this (c : I_comparator('a), k : 'a) 
        {
          this#cmp <- c;
          this#key <- k;
        }
    }

  class Int_comparator implements I_comparator(int)
    {
      method compare (x : int, y : int) : int 
        implements I_comparator.compare
        = x - y;
      method this () {}
    }

  class String_comparator implements I_comparator(string)
    {
      method compare (x : string, y : string) : int 
        implements I_comparator.compare
        = compare_strings(x, y);
      method this () {}
    }

  class Map ('a, 'b, 'c) where 'c :> I_comparator('a)
    {
      field root : node(map_node('a, 'b));
      field cmp : I_comparator('a);
      
      method this(c : I_comparator('a))
        {
          this#root <- T();
          this#cmp <- c;
        }

      private method this(c : I_comparator('a), r : node(map_node('a, 'b))) 
        {
          this#cmp <- c;
          this#root <- r;
        }
      
      method add (k : 'a, v : 'b) : Map('a, 'b, 'c) =
        Map(this#cmp, Tree.insert(this#root, map_node(this#cmp, k, v)));
        
      method find (k : 'a) : option('b) =
        match Tree.find(this#root, map_node(this#cmp, k)) with [
          | option.Some ?n => option.Some(n#val#val) 
          | option.None => option.None()
        ];

      method mem (k : 'a) : bool =
        match Tree.find(this#root, map_node(this#cmp, k)) with [
          | Some => true
          | None => false
        ];

      fun ('d) int_map () : Int_map('d)
        = Map(Int_comparator());
      fun ('d) string_map () : String_map('d)
        = Map(String_comparator());
    }

    type Int_map ('a) = Map(int, 'a, Int_comparator);
    type String_map ('a) = Map(string, 'a, String_comparator);

}
