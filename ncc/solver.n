/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.SolverMacros;

/*

There are two kinds of type variables:

  * free type variables with an associated upper and lower bounds on
    types that can be substituted for it
    
  * fixed type variables, that are already substituted some type
    constructor
    
The constraint solver maintains a graph of type variables (vertices)
and subtyping relations (edges).  The graph follows several invariants:

  1. There are only free type variables in it.

  2. There are no cycles in it. If a cycle emerge, all type variables
     involved in it are merged into one type variable. (The graph is
     therefore a DAG).

  3. The graph is transitively closed, that is if A :> B and B :> C, then
     A :> C, where X :> Y stands for an edge in the graph from X to Y.
     
  4. The upper and lower bounds are also transitively closed, that is
     if t :> A, A :> B, B :> t' then t :> t', where :> stands for a
     subtyping relation.

  5. If t :> A and A :> t', then t :> t' (that is upper bound has to be
     bigger then lower bound). If t = t', then the type t is substituted
     for the variable A (that is A gets fixed), since it is the only
     type to fulfill both upper and lower limits. To maintain 1., it's
     then removed from the graph.
     
It is sometimes crucial to save the graph in a certain state and then go
back to it. This is done with the PushState and PopState methods -- they
maintain stack of maps from type variable identifiers to type variables
themselves. Type variables in given state are looked up with the Find
method, while if there is a need to update a type variable, Copy should
be called.  Copy is a noop if there is already a copy in the current
state, while both Copy and Find are noops if the stack of states is empty.

The Find() methods also takes into account the equality constraints
on type variables (they result from subtyping tests or cycle merging).
It returns the selected representative of given merged variable class.
New equality constraints are added using the AddLink method.

*/

namespace Nemerle.Compiler 
{
  public class Subst
  {
    public Apply (t : MType) : MType
    {
    }
  }
  
  /** A constraint solver. */
  public class Solver
  {
    /** Store current constraint state.
        
        Called before some speculative type checking fragment, like
        overload resolution. */
    public PushState () : void
    {
    }


    /** Go one constraint state back.
        
        This function rollbacks all constraints made in current state,
        and also clear the error state if it was in */
    public PopState () : void
    {
    }


    /** Check if the solver has encountered an error in the current of
        parent state. */
    public InErrorState : bool
    {
      get { in_error_state }
    }
    

    public EnsureClearState () : void
    {
      when (in_error_state)
        throw RestartWithMessages ()
    }


    /** Make sure all TyVars created so far won't go anywhere.
        
        Called when the type checking process for a method is finished (or
        for a class, if we decide to go with inferred private types). */
    public FixateAll () : void
    {
    }


    /** Generate a new type variable. */
    public FreshTyVar () : TyVar
    {
      TyVar (this)
    }


    /** Increment current type variable rank.

        Called before typing of a local function. */
    public PushRank () : void
    {
    }

    
    /** Restore previous type variable rank.

        Called after typing of a local function. */
    public PopRank () : void
    {
    }

    /** Return the biggest type [t] such that [t <: t1] and [t <: t2]. 
        It doesn't work for separated types. */
    public Intersect (t1 : MType, t2 : MType) : MType
    {
      def intersect_classes (tc1 : TypeInfo, args1, tc2, args2) {
        match (tc1.SuperType (tc2)) {
          | None =>
            match (tc2.SuperType (tc1)) {
              | None =>
                match ((tc1.GetTydecl (), tc2.GetTydecl ())) {
                  | (TypeDeclaration.Interface, TypeDeclaration.Interface)
                  | (TypeDeclaration.Class, TypeDeclaration.Interface)
                  | (TypeDeclaration.Interface, TypeDeclaration.Class) =>
                    [t1, t2]
                  | _ =>
                    ReportError ($ "types $t1 and $t2 are not compatible "
                                   "[during intersection]")
                }
              | Some =>
                intersect_classes (tc2, args2, tc1, args1)
            }
          | Some (args) =>
            // tc1 : tc2(args)
            def subst = tc1.GetSubst (args1);
            List.Iter2 (args, args2,
                        fun (t : MType, tv : TyVar) { 
                             tv.Unify (subst.Apply (t)) 
                        });
            [t2]
        }
      }

      if (t1 == null) t2
      else if (t2 == null) t1
      else {
        def result =
          match ((t1, t2)) {
            | (MType.Class (tc, args), MType.Intersection (lst))
            | (MType.Intersection (lst), MType.Class (tc, args)) =>
              def loop (res, tc, args, lst) {
                | (MType.Class (tc', args')) as t :: tl =>
                  if (tc'.SuperType (tc) matches Some ||
                      tc.SuperType (tc') matches Some)
                    match (intersect_classes (tc, args, tc', args')) {
                      | [MType.Class (tc, args)] =>
                        loop (res, tc, args, tl)
                      | _ => assert (false)
                    }
                  else loop (t :: res, tc, args, tl)
                  
                | _ :: _ => assert (false)

                | [] => MType.Class (tc, args) :: res
              }
              loop (tc, args, lst)
              
              
            | (MType.Class (tc1, args1), MType.Class (tc2, args2) =>
              intersect_classes (tc1, args1, tc2, args2)
            | _ => 
              ReportError ($ "types $t1 and $t2 are not compatible "
                             "[during intersection]")
          }
        match (result) {
          | [x] => x
          | lst => MType.Intersection (lst)
        }
      }
    }
    

    public Sum (t1 : MType, t2 : MType) : MType
    {
    }
    

    public AddLink (t1 : TyVar, t2 : TyVar) : void
    {
    }
    

    public Find (id : int) : TyVar
    {
    }


    public Copy (t : TyVar) : TyVar
    {
    }

    
    /** Set the solver to be in the error state. */
    MarkError () : void
    {
      assert (!throw_on_error);
      in_error_state = true;
    }


    ThrowMessage (msg : string) : void
    {
      assert (throw_on_error);
      throw ErrorMessage (msg)
    }

    mutable throw_on_error : bool;
    mutable in_error_state : bool;
  }



  /** Represent top-level type constructor for a given type. */
  public variant MType
  {
    | Class {
        tycon : TypeInfo;
        args : list <TyVar>;
      }
    | TyVar {
        tyvar : StaticTyVar;
      }
    | Fun {
        from : TyVar;
        to : TyVar;
      }
    | Tuple {
        args : list <TyVar>;
      }
    | Array {
        t : TyVar;
        rank : int;
      }
    | Void

      /* Used when given value is required to have all the listed types.

         Invariant: the types listed cannot be in the subtyping relation
         pairwise.
         
         This type is not expressible in the .NET type system directly,
         it can be however expressed with type variable bounds in some
         cases. */
    | Intersection {
        types : list <MType>;
      }


    /** Check for type equality, taking intersection types
        into account. */
    [Nemerle.OverrideObjectEquals]
    public Equals (t : MType) : bool
    {
    }


    /** Enforce [this] to be subtype of [t]. */
    public Require (t : MType) : void
    {
    }

    
    /** Enforce [this] to be equal [t]. */
    public Unify (t : MType) : void
    {
    }

    
    public IsSeparated : bool
    {
      get {
        match (t) {
          | Class => false
          
          | TyVar
          | Fun
          | Tuple
          | Array
          | Void => true
          
          | Intersection (lst) =>
            mutable is = false;
            foreach (x in lst)
              if (x.IsSeparated)
                is = true;
            is
        }
      }
    }
    

  }



  /** Represents an explicitly bound type variable, like the one from
      polymorphic type or method definition. It is also used in
      generalizations of inferred types. */
  public class StaticTyVar
  {
  }


 
  /** Represents a node in constraint graph. Used during type
      inference. */
  public class TyVar
  {
    // PUBLIC interface

    /** Require [this] to be at least [t].
    
        To be called when we require some lower constraint on type
        variable. */
    public Require (t : TyVar) : void
    {
      AddRelation (t, this)
    }


    /** Require [this] to be at least [t].
    
        To be called when we require some lower constraint on type
        variable. */
    public Require (t : MType) : void
    {
      AddRelation (t, this, rev = false)
    }

    
    /** Provide type [t] as the maximal type for [this].
        
        To be called when value of type [t] is assigned to cell of type
        [this]. Dual to [Require]. */
    public Provide (t : TyVar) : void
    {
      AddRelation (this, t)
    }

    
    /** Provide type [t] as the maximal type for [this].
        
        To be called when value of type [t] is assigned to cell of type
        [this]. Dual to [Require]. */
    public Provide (t : MType) : void
    {
      AddRelation (t, this, rev = true)
    }


    /** Make sure [t] and [this] will from now on always represent the 
        same type. */
    public Unify (t : TyVar) : void
    {
      match (t.Self.state) {
        | State.Free =>
          Require (t);
          Provide (t);
        | State.MonoType (t) =>
          Unify (t)
      }
    }


    /** Make sure [t] and [this] will from now on always represent the 
        same type. */
    [ForwardThis (Self)]
    public Unify (t : MType) : void
    {
      match (state) {
        | State.MonoType (t') =>
          t'.Unify (t)

        | State.Free =>
          def self = solver.Copy (this);
          def f = Free (self);
          SetLowerBound (f, t);
          SetUpperBound (f, t);
          def lower = f.lower_tyvars;
          def upper = f.upper_tyvars;
          self.state = State.MonoType (t);
          lower.Iter (fun (tv) {
            def f = Free (solver.Copy (tv));
            assert (f.upper_tyvars [self]);
            f.upper_tyvars = f.upper_tyvars.Remove (self);
          })
          upper.Iter (fun (tv) {
            def f = Free (solver.Copy (tv));
            assert (f.lower_tyvars [self]);
            f.lower_tyvars = f.lower_tyvars.Remove (self);
          })
      }
    }


    public LowerBound : option <MType>
    {
      get {
        match (Self.state) {
          | State.MonoType (t) => Some (t)
          | (State.Free) as f =>
            if (f.lower_bound == null) None ()
            else Some (f.lower_bound)
        }
      }
    }


    public UpperBound : option <MType>
    {
      get {
        match (Self.state) {
          | State.MonoType (t) => Some (t)
          | (State.Free) as f =>
            if (f.upper_bound == null) None ()
            else Some (f.upper_bound)
        }
      }
    }
    

    public IsFixed : bool
    {
      get {
        Self.state matches State.MonoType
      }
    }


    public IsFree : bool
    {
      get {
        Self.state matches State.Free
      }
    }


    /** Fix the type to be [LowerBound], so it won't change anymore.
    
        Don't use this function unless absolutely necessary. */
    public Fixate () : void
    {
      match (Self.state) {
        | State.MonoType => ()
        | (State.Free) as f =>
          if (f.lower_bound == null)
            Provide (InternalType.Object)
          else
            Provide (f.lower_bound)
      }
    }


    // PRIVATE helper functions

    static AddRelation (low : TyVar, high : TyVar) : void
    {
      def low = low.Self;
      def high = high.Self;
      match ((low.state, high.state)) {
        | (State.MonoType (low), State.MonoType (high)) =>
          high.Require (low)
        | (State.MonoType (low), State.Free) =>
          AddRelation (low, high, rev = false)
        | (State.Free, State.MonoType (high)) =>
          AddRelation (high, low, rev = true)
        | _ =>
          AddTyVarRelation (low, high)
      }
    }


    static AddRelation (low : MType, high : TyVar, rev : bool) : void
    {
      if (low.IsSeparated)
        high.Unify (low)
      else {
        // TODO don't call it if not needed
        if (rev)
          SetUpperBound (Free (solver.Copy (high)), low)
        else
          SetLowerBound (Free (solver.Copy (high)), low);
        def f = Free (this);
        when (f.upper_bound.Equals (f.lower_bound))
          Unify (f.lower_bound)
      }
    }
    
      
    static Free (v : TyVar) : State.Free
    {
      v.Self.state :> State.Free
    }

    
    static MergeCycle (low : State.Free, high : State.Free) : void
    {
      def upper = low.upper_tyvars.Sum (high.upper_tyvars);
      def lower = low.lower_tyvars.Sum (high.lower_tyvars);
      def cycle = upper.Intersect (lower).ToList ();
      def cycle = List.Map (solver.Copy, cycle);
      def upper = Set.Sum (List.Map (cycle, fun (x) { Free (x).upper_tyvars }));
      def lower = Set.Sum (List.Map (cycle, fun (x) { Free (x).lower_tyvars }));
      match (cycle) {
        | x :: xs =>
          mutable lb = Free (x).lower_bound;
          mutable ub = Free (x).upper_bound;
          x.lower_tyvars = lower;
          x.upper_tyvars = upper;
          foreach (y in xs) {
            lb = solver.Intersect (lb, Free (y).lower_bound);
            ub = solver.Sum (ub, Free (y).upper_bound);
            solver.AddLink (x, y);
          }
          foreach (y in cycle) {
            def f = free (y);
            f.lower_bound = lb;
            f.upper_bound = ub;
            f.lower_tyvars = lower;
            f.upper_tyvars = upper;
          }
        | [] => assert (false)
      }
    }
    
    
    static AddTyVarRelation (low_tv : TyVar, high_tv : TyVar) : void
    {
      if (Free (low_tv).upper_tyvars.Contains (high_tv)) {
        assert (Free (high_tv).lower_tyvars.Contains (low_tv));
        ()
      } else {
        def low = Free (solver.Copy (low_tv));
        def high = Free (solver.Copy (low_tv));
        def upper = low.upper_tyvars.Sum (high.upper_tyvars).Replace (high);
        def lower = high.lower_tyvars.Sum (low.lower_tyvars).Replace (low);
        def have_cycle = upper [low];
        assert (have_cycle == lower [high]);
        if (have_cycle) {
          high.lower_tyvars = lower;
          low.upper_tyvars = upper;
          MergeCycle (low, high)
        } else {
          SetLowerBound (high, low.lower_bound);
          SetUpperBound (low, high.upper_bound);
          high.lower_tyvars = lower;
          low.upper_tyvars = upper;
        }
      }
    }


    static SetLowerBound (f : State.Free, t : MType) : void
    {
      f.lower_bound = solver.Intersect (f.lower_bound, t);
      f.upper_bound.Require (f.lower_bound);
      f.upper_tyvars.Iter (fun (tv : TyVar) { tv.Require (lb) })
    }
    
    
    static SetUpperBound (f : State.Free, t : MType, rec : bool) : void
    {
      f.upper_bound = solver.Sum (f.upper_bound, t);
      f.upper_bound.Require (f.lower_bound);
      f.lower_tyvars.Iter (fun (tv : TyVar) { tv.Provide (ub) })
    }


    variant State {
      | MonoType { ty : MType; }
      | Free {
          mutable lower_tyvars : Set <TyVar>;
          mutable upper_tyvars : Set <TyVar>;
          mutable lower_bound : MType;
          mutable upper_bound : MType;
        }
    }

    mutable state : State;
    id : int;
    solver : Solver;

    static current_id : int;

    Self : TyVar
    {
      get { solver.Find (id) }
    }

    internal this (s : Solver)
    {
      solver = s;
      state = State.Free (Set (), Set (), null, null);
      id = current_id;
      ++current_id;
    }

    internal this (other : TyVar)
    {
      id = other.id;
      solver = other.solver;
      match (other.Self.state) {
        | State.Free (a, b, c, d) =>
          state = State.Free (a, b, c, d);
        | State.MonoType =>
          assert (false)
      }
    }
  }
}
