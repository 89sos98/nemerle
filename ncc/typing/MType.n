/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler 
{
  /** Represent top-level type constructor for a given type. */
  public variant MType
  {
    | Class {
        tycon : TypeInfo;
        args : list <TyVar>;
      }
    | TyVar {
        tyvar : StaticTyVar;
      }
    | Fun {
        from : TyVar;
        to : TyVar;
      }
    | Tuple {
        args : list <TyVar>;
      }
    | Array {
        t : TyVar;
        rank : int;
      }
    | Void

      /* Used when given value is required to have all the listed types.

         Invariant 1: the types listed cannot be in the subtyping relation
         pairwise.

         Invariant 2: there can be only Class() objects inside.
         
         This type is not expressible in the .NET type system directly,
         it can be however expressed with type variable bounds in some
         cases. */
    | Intersection {
        types : list <MType>;
      }


    /** Check for type equality, taking intersection types
        into account. */
    [Nemerle.OverrideObjectEquals]
    [Nemerle.NotImplemented]
    public Equals (t : MType) : bool
    {
    }


    /** Check for type equality, taking intersection types
        into account. If it's possible that types are equal -- enforce 
        that.  Assume non-seperated types. */
    [Nemerle.OverrideObjectEquals]
    [Nemerle.NotImplemented]
    public TryUnify (solver : Solver, t : MType) : bool
    {
      assert (!this.IsSeparated);
      assert (!t.IsSeparated);
      
      solver.EnsureClearState ();
      
      match ((this, t)) {
        | (MType.Class (tc1, args1), MType.Class (tc2, args2))
          when tc1.Equals (tc2) =>
          List.Iter2 (args1, args2, fun (t1 : TyVar, t2 : TyVar) {
            t1.Unify (t2)
          });
          !solver.InErrorState
          
        | (MType.Intersection (l1), MType.Intersection (l2)) 
          when List.Length (l1) == List.Length (l2) =>
          def ht = Hashtable ();
          foreach ((MType.Class (tc, _)) as t in l1)
            ht [tc.GetId ()] = t;
          mutable cnt = 0;
          foreach ((MType.Class (tc, _)) as t in l2)
            when (ht.Contains (tc.GetId ()))
              ++cnt;
          if (cnt == List.Length (l1)) {
            foreach ((MType.Class (tc, _)) as t in l2)
              ht [tc.GetId ()].Unify (t);
            !solver.InErrorState
          } else false

        | _ => false
      }
    }


    /** Enforce [this] to be subtype of [t]. */
    public Require (s : Solver, t : MType) : void
    {
      match ((this, t)) {
        | (_, MType.Class (tc, _)) 
          when tc.Equals (InternalType.Object_tc) => ()
          
        | (MType.Class (tc1, args1), MType.Class (tc2, args2)) =>
          match (tc1.SuperType (tc2)) {
            | Some (args) =>
              def subst = tc1.GetSubst (args1);
              List.Iter2 (args, args2 
                           fun (t : MType, tv : TyVar) { 
                             tv.Unify (subst.Apply (t)) 
                           });
            | None =>
              ReportError (solver, $ "$tc1 is not a subtype of $tc2 "
                                     "[simple require]")
          }
          
        | (MType.Fun (f1, t1), MType.Fun (f2, t2)) =>
          f2.Require (f1);
          t1.Require (t2);
          
        | (MType.Tuple (l1), MType.Tuple (l2)) 
          when List.Length (l1) == List.Length (l2) =>
          List.Iter2 (l1, l2, fun (x : TyVar, y : TyVar) { x.Require (y) })
          
        | (MType.Array (t1, rank1), MType.Array (t2, rank2))
          when rank1 == rank2 =>
          // XXX we allow array covariance here! we may want to change it
          t1.Require (t2)
        
        | (MType.Void, MType.Class (tc, _)) when tc.Equals (InternalType.Void_tc)
        | (MType.Class (tc, _), MType.Void) when tc.Equals (InternalType.Void_tc)
        | (MType.Void, MType.Void) => ()

        | (MType.Array, MType.Class (tc, _)) 
          when tc.Equals (InternalType.Array_tc) => ()

        | (MType.TyVar (tv1), MType.TyVar (tv2))
          when tv1.Equals (tv2) => ()

        | (MType.TyVar (tv1), t2) =>
          tv1.LowerBound.Require (t2)

        | (MType.Intersection (lst), (MType.Class (tc, _)) as t2) =>
          def loop (_) {
            | (MType.Class (tc', _)) as t1 :: xs =>
              if (tc'.SuperType (tc) matches Some)
                t1.Require (t2)
              else
                loop (xs)
            | [] =>
              ReportError (solver, $ "$(this) is not a subtype of $t "
                                     "[simple require, intersection]")
            | _ => assert (false)
          }
          loop (lst)
        
        | (t1, MType.Intersection (lst)) =>
          foreach (t2 in lst)
            t1.Require (t2);

        | _ =>
          ReportError (solver, $ "$(this) is not a subtype of $t "
                                 "[simple require]")
      }
    }

    
    /** Enforce [this] to be equal [t]. */
    [Nemerle.NotImplemented]
    public Unify (s : Solver, t : MType) : void
    {
      match ((this, t)) {
        | (MType.Intersection, MType.Intersection) when TryUnify (s, t)
        | (MType.Class, MType.Class) when TryUnify (s, t) => ()
        
        | (MType.Fun (f1, t1), MType.Fun (f2, t2)) =>
          f1.Unify (f2);
          t1.Unify (t2);
          
        | (MType.Tuple (l1), MType.Tuple (l2)) 
          when List.Length (l1) == List.Length (l2) =>
          List.Iter2 (l1, l2, fun (x : TyVar, y : TyVar) { x.Unify (y) })
          
        | (MType.Array (t1, rank1), MType.Array (t2, rank2))
          when rank1 == rank2 =>
          t1.Unify (t2)
        
        | (MType.Void, MType.Class (tc, _)) when tc.Equals (InternalType.Void_tc)
        | (MType.Class (tc, _), MType.Void) when tc.Equals (InternalType.Void_tc)
        | (MType.Void, MType.Void) => ()

        | (MType.TyVar (tv1), MType.TyVar (tv2))
          when tv1.Equals (tv2) => ()

        | _ =>
          ReportError (solver, $ "the types $(this) and $t are not compatible "
                                 "[simple unify]")
      }
    }


    [Nemerle.NotImplemented]
    public override ToString () : string
    {
    }

    
    public IsSeparated : bool
    {
      get {
        match (t) {
          | Class => false
          
          | TyVar
          | Fun
          | Tuple
          | Array
          | Void => true
          
          | Intersection (lst) =>
            foreach (x in lst)
              assert (!x.IsSeparated);
            false
        }
      }
    }
  }
}
