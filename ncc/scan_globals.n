/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

namespace Nemerle.Compiler {

module Scan_globals {

  private handle_type (par : option <Tyinfo>, vop : option <Tyinfo>, 
                       env : GlobalEnv, t : Type_decl) : list <Tyinfo>
  {
    def env = env.Copy ();
    def name = env.GetCurrentNamespace () + t.name;
    env.AddOpenNamespace (name);
    def ti = Tyinfo (par, vop, env, t);
    GlobalEnv.AddType (name, ti);

    def env' = env.InPrefix (t.name);
    def recurse (acc : list <Tyinfo>, m : Class_member) : list <Tyinfo> {
      match (m) {
        | M_type (t) =>
          List.Append (handle_type (Some (ti), None (), env', t), acc)
        | _ => acc
      }
    };
    def (res, decls) =
      match (t) {
        | TD_class (d) => ([], d)
        | TD_interface (d) => ([], d)
        | TD_variant (ds) =>
          def handle_vo (d) {
            handle_type (par, Some (ti), env, d)
          };
          (List.Concat (List.Map (handle_vo, ds)), [])
        | TD_variant_option (d) => ([], d)
        | TD_alias => ([], [])
      };
    ti.SetContainedTypes (List.FoldLeft (recurse, [], decls));
    ti.SetVariantOptions (res);
    ti :: res
  }

  /** This function does the very first pass, after parsing.  It changes 
      open/namespace declaration into appropriate entries in [GlobalEnv] class.
      It also creates [Tyinfo] object for each type and registers it
      with global name environment.  */
  public run (decls : list <Top_decl>) : void
  {
    def loop (env : GlobalEnv, decl : Top_decl) : GlobalEnv {
      match (decl) {
        | TD_namespace (n, d) =>
          def env' = env.InPrefix (n);
          env'.AddOpenNamespace (n);
          def _ = List.FoldLeft (loop, env', d);
          env
          
        | TD_open (n) =>
          def env' = env.Copy ();
          env'.AddOpenNamespace (n);
          env'
          
        | TD_namespace_alias (s, l) =>
          def env' = env.Copy ();
          env'.AddNamespaceAlias (s, l);
          env'

        | TD_type (d) =>
          def _ = handle_type (None (), None (), env, d);
          env
      }
    };
    def env = GlobalEnv ();
    env.AddOpenNamespace ("Nemerle.Core");
    env.AddOpenNamespace ("Nemerle.Core.Aliases");
    def _ = List.FoldLeft (loop, env, decls);
    ()
  }
      
} // module Scan_globals

} // N.C
