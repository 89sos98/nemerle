using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

public class Evaluator
{
  public static mutable Locals : list [string * PExpr];
  public static mutable code : string;
  public static mutable previous : array [object];
  public static mutable ns : list [list [string]];
 
  public this () {
    Evaluator.Locals = [];
    Evaluator.previous = array [];
    Message.InitOutput (System.Console.Out);         

    Options.Sources = [""];
    Options.CompileToMemory = true;
    Options.ProgressBar = false;
    Options.IgnoreConfusion = true;
    WarningOptions.Disable (10005); // ignore computed value
    WarningOptions.Disable (168);   // unused variable

    Passes.LexingPipeline = fun (_) { null };
    Passes.ParsingPipeline = fun (_) { [null] };
    Passes.ScanningPipeline = DoTheStuff;
  }

  public Eval (refr: list [string], ns: list [string], code: string): object {
    Evaluator.code = code;
    Evaluator.ns = List.FoldLeft (ns, [], fun (x, acc) { 
      NString.Split (x, array ['.']) :: acc }
    );
    Options.ReferencedLibraries = refr;

    Passes.Run ();
    
    def ass = Passes.GeneratedAssembly;
    def meth = ass.GetTypes()[0].GetMethod("Run");
    def ret = meth.Invoke (null, array [Evaluator.previous : object]) :> array [object];
    def result = ret[0];
    def locals = ret[1] :> array [object];

    mutable tmp = array (Evaluator.previous.Length + locals.Length) : array [object];
    System.Array.Copy (Evaluator.previous, tmp, Evaluator.previous.Length);
    System.Array.Copy (locals, tmp, locals.Length);
    Evaluator.previous = tmp;

    def l = List.FromArray (locals);
    match ((Locals, l)) {
      | (_, []) | ([], _) => ()
      | _ =>
        List.Iter2 (l, Locals, fun (x: object, y: string * PExpr) { 
          def (y1, y2) = y;
          System.Console.WriteLine ($"$y1 = $x : $y2")
        });
    }

    result
  }

  static DoTheStuff (_tdecl : Parsetree.TopDeclaration) : void {
    MacroRegistry.register_macro (StagedMacro ());
    def n = ["Nemerle", "Core"] :: ["Nemerle", "Core", "option"] :: Evaluator.ns;
    def env = List.FoldLeft (n, GlobalEnv.Empty, fun (x, acc: GlobalEnv) { 
                acc.AddOpenNamespace (x, Location.Default)
              });

    MacroColorizer.PushNewColor (-1, env);

    def cname = Macros.NewSymbol ();
    def tb = GlobalEnv.DefineExact (<[ decl: public class $(cname : name) { } ]>);

    def body = MainParser.ParseExpr (env, Evaluator.code + " "); 
    
    def whole = inject (body);

    mutable i = -1;    
    def inits = List.FoldLeft (Evaluator.Locals, [], fun (x, acc) {
      match (x) {
        | (name, ty) =>
          ++i;          
          <[ def $(name : usesite) = _N_prevs [$(i : int)] :> $ty ]> :: acc;
      }
    });
    def whole = <[ {.. $(inits + [whole]) } ]>;

//    PrettyPrint.PrintExpr (None (), whole);
    
    tb.Define (<[ decl:
                 public static Run (_N_prevs : array [System.Object]) : array [System.Object]
                 { $whole }
               ]>);
    tb.Compile ();

    MacroColorizer.PopColor ();
  }

  static inject (body : PExpr) : PExpr {
    match (body) {
      | <[ {..$seq } ]> => 
        def (beg, last) = List.DivideLast (seq);
        def last = 
          match (last) {
            | <[ def $_ = $_ ]> | <[ mutable $_ = $_ ]> => 
              <[ $last; $("stagedmacro" : usesite) (()) ]>
            | _ => <[ $("stagedmacro" : usesite) ($last) ]>
          }
        <[ {..$ (beg + [last]) } ]>
      | _ => <[ $("stagedmacro" : usesite) ($body) ]>
    }
  }

  class StagedMacro : IMacro 
  {
    public Run (ctx : Typer, val : list [SyntaxElement]) : PExpr {
      match (val) {
        | [SyntaxElement.Expression (expr)] =>
          Evaluator.Locals = [];
          
          def locals = ctx.GetLocals ();
          def values = locals.Fold ([], fun (n : Name, loc : LocalValue, acc) {
            regexp match (n.ToString ()) {
              | @"_N_\w+" => acc
              | _ =>
                Evaluator.Locals = (loc.Name, PrettyPrint.TyVarToParseTree (loc.Type)) :: Evaluator.Locals;
                <[ ($(n : name) : System.Object) ]> :: acc
            }
          });
          <[ array [$expr : System.Object, array [..$values]] ]>
        | _ => Util.ice ()
      }
    }

    public CallTransform (l : list [PExpr]) : list [SyntaxElement]
    { List.Map (l, SyntaxElement.Expression); }
    public SyntaxExtension () : GrammarElement * (list [SyntaxElement] -> list [SyntaxElement])
    { (null, fun (_) { [] }) }
    public IsInherited : bool { get { false } }
    public IsTailRecursionTransparent : bool { get { false } }
    public GetName () : string { "stagedmacro" }
    public GetNamespace () : string { "" }
    public Keywords : list [string] { get { [] } }
    public Usage : Nemerle.MacroUsageAttribute { get { null } }
  }
}
