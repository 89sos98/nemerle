<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Quick summary of differences between Nemerle and C#</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document lists basic differences between Nemerle and C#
        in a terse form. If you know Java or C++ you also should be able
        to use it.
      </p>
    </body>
  </section>


  <section id="expr-changes">
    <title>Changes in expressions</title>
    <body>
      <comparison>
        <entry>
          <csharp>
            int x = 3;<br/>
            string y = "foo";<br/>
            FooBarQux fbq = make_fbq ();
          </csharp>
          <nemerle>
            def x = 3;<br/>
            def y = "foo";<br/>
            def fbq = make_fbq ();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> cannot be changed.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
              int x = 3;<br/>
              string y = "foo";<br/>
              FooBarQux fbq = make_fbq();
          </csharp>
          <nemerle>
              mutable x &lt;- 3;<br/>
              mutable y &lt;- "foo";<br/>
              mutable fbq &lt;- make_fbq();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> can be changed.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta>;
          </csharp>
          <nemerle>
            <meta>expr_1</meta> &lt;- <meta>expr_2</meta>;
          </nemerle>
          <remarks>
            The assignment operator.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta> = <meta>expr_3</meta>;
          </csharp>
          <nemerle>
            def tmp = <meta>expr_3</meta>;<br/>
            <meta>expr_1</meta> &lt;- tmp;<br/>
            <meta>expr_2</meta> &lt;- tmp;
          </nemerle>
          <remarks>
            The type of assignment operator is <tt>void</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> (<meta>parms</meta>)
          </csharp>
          <nemerle>
            <meta>Class</meta> (<meta>parms</meta>)
          </nemerle>
          <remarks> 
            The <tt>new</tt> keyword is dropped.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            array (<meta>size</meta>)
          </nemerle>
          <remarks>
            If the type can be inferred (most of the time).
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            (array (<meta>size</meta>) : array (<meta>Class</meta>))
          </nemerle>
          <remarks>
            If the type cannot be inferred.
          </remarks>
        </entry>

        <entry>
          <csharp>
            { <meta>expr_1</meta>, <meta>expr_1</meta>, ..., 
              <meta>expr_n</meta> }
          </csharp>
          <nemerle>
            array [<meta>expr_1</meta>, 
                   <meta>expr_1</meta>, ..., 
                   <meta>expr_n</meta>]
          </nemerle>
          <remarks>
            The array constructor.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) return <meta>foo</meta>;<br/>
            <meta>do_something ()</meta>;<br/>
            return <meta>bar</meta>;
          </csharp>
          <nemerle>
            if (<meta>cond</meta>) <meta>foo</meta><br/>
            else {<br/>
            <meta>do_something ()</meta>;<br/>
            <meta>bar</meta><br/>
            }
          </nemerle>
          <remarks>
            There is no <tt>return</tt> statement that cuts control flow in Nemerle.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            when (<meta>cond</meta>) answer &lt;- 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without <tt>else</tt> is called <tt>when</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (!<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            unless (<meta>cond</meta>) answer &lt;- 42;<br/>
            // or: when (!<meta>cond</meta>) answer &lt;- 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without "then" is called
            <tt>unless</tt>. However nobody is forced to use it.
          </remarks>
        </entry>

        <entry>
          <csharp>
            try ... <br/>
            catch (FooException e) { ... }<br/>
            catch (BarException e) { ... }
          </csharp>
          <nemerle>
            try ... <br/>
            catch {<br/>
              | e : FooException => ...<br/>
              | e : BarException => ...<br/>
            }
          </nemerle>
          <remarks>
            Somewhat different syntax, consistent with <tt>match</tt> though.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> :> <meta>type</meta>)
          </nemerle>
          <remarks>
            Runtime type cast, allows for downcasts and upcasts.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> : <meta>type</meta>)
          </nemerle>
          <remarks>
            Static cast, allow only upcast.
          </remarks>
        </entry>

        <entry>
          <csharp>
            using System;<br/>
            ...<br/>
            Console.WriteLine ("foo");
          </csharp>
          <nemerle>
            using System.Console;<br/>
            ...<br/>
            WriteLine ("foo");
          </nemerle>
          <remarks>
            In Nemerle you can also apply <tt>using</tt> directive
            to classes.
          </remarks>
        </entry>

        <entry>
          <csharp>
            while (x &lt; 7) {<br/>
              y += x;<br/>
              x++;<br/>
            }<br/>
            System.Console.WriteLine (y);
          </csharp>
          <nemerle>
            while (x &lt; 7) {<br/>
              y &lt;- y + x;<br/>
              x &lt;- x + 1;<br/>
            };<br/>
            System.Console.WriteLine (y);
          </nemerle>
          <remarks>
            Note semicolon after <tt>while {...}</tt>.
            [[FIXME: shouldn't we have ++ += etc?]]
          </remarks>
        </entry>

        <entry>
          <csharp>
            for (int x = 0; x &lt; 7; x++) {<br/>
              y += x;<br/>
            }<br/>
            System.Console.WriteLine (y);
          </csharp>
          <nemerle>
            for (mutable x &lt;- 0; x &lt; 7; y &lt;- y + x) {<br/>
              x &lt;- x + 1;<br/>
            };<br/>
            System.Console.WriteLine (y);
          </nemerle>
          <remarks>
            Note semicolon after <tt>for {...}</tt>.
          </remarks>
        </entry>

      </comparison>
      
    </body>
  </section>
  

  <section id="class-changes">
    <title>Changes in type definitions</title>
    <body>
      <comparison>

        <entry>
          <csharp>
              static int foo (int x, string y) { ... }
          </csharp>
          <nemerle>
              static foo (x : int, y : string) : int { ... }
          </nemerle>
          <remarks>
            Type are written after variables.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              public Foo (int x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              public this (x : int) { ... }<br/>
            }
          </nemerle>
          <remarks>
            Constructor name is always <tt>this</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo : Bar {<br/>
              public Foo (int x) : base (x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo : Bar {<br/>
              public this (x : int) { base (x); ... }<br/>
            }
          </nemerle>
          <remarks>
            Base constructor is called in function body.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              mutable x : int;<br/>
            }
          </nemerle>
          <remarks>
            Fields to be changed outside constructor need to be marked 
            <tt>mutable</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              readonly int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              x : int;<br/>
            }
          </nemerle>
          <remarks>
            <tt>readonly</tt> is the default.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class C : I1, I2 {<br/>
              void I1.m () { ... }<br/>
              void I2.m () { ... }<br/>
            }
          </csharp>
          <nemerle>
            class C : I1, I2 {<br/>
              meth1 () : void implements I1.m { ... }<br/>
              meth2 () : void implements I2.m { ... }<br/>
            }
          </nemerle>
          <remarks>
            When two interfaces have the method with the same name.
          </remarks>
        </entry>

      </comparison>
    </body>
  </section>

  <section id="generics">
    <title>As in Generic C#...</title>
    <body>
      <p>
        Syntax and semantics of polymorphism in Nemerle is the same as what
        is called generics in C# 2.0.
      </p>
    </body>
  </section>
 
  <section id="new-stuff">
    <title>New stuff</title>
    <body>
      <p>
        This section talks about stuff more or less absent in C#.
      </p>
      
      <comparison>
        <entry>
          <csharp>
            void m(int _unused1, string _unused2) { ... }
          </csharp>
          <nemerle>
            m (_ : int, _ : string) : void { ... }
          </nemerle>
          <remarks>
            Upon each use the <tt>_</tt> keyword generates new name.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class Foo { static readonly int x; static int m () { ... } }
          </csharp>
          <nemerle>
            module Foo { x : int; m () : int { ... } }
          </nemerle>
          <remarks>
            <tt>module</tt> is a class, that have all members <tt>static</tt>.
          </remarks>
        </entry>
      </comparison>
    </body>
    

    <subsection id="ns-alias">
      <title>Namespace aliases</title>
      <body>
        <p>
          Example:
        </p>
<code>
namespace SR = System.Reflection;
namespace SC = System.Console;
...
def name = SR.AssemblyName ();
SC.WriteLine (name.CodeBase);
</code>
        <p>
          This example probably wouldn't convince anybody this feature
          is needed :) However it comes in handy when one has two very
          similar namespaces (for two SQL providers) and want to use
          both without writing veeeery long names each time.
        </p>
      </body>
    </subsection>
    
    
    <subsection id="tuple">
      <title>Tuples</title>
      <body>
        <p>
          Tuples are form of nameless data structures. They are usable
          when you need to return two or three values from function.
        </p>
<code>
/** Parses time in HH:MM format. */
parse_time (time : string) : int * int
{
  def arr = time.Split (array [':']);
  (System.Int32.Parse (arr[0]), System.Int32.Parse (arr[1]))
}

seconds_since_midnight (time : string) : int
{
  def (hours, minutes) = parse_time (time);
  (hours * 60 + minutes) * 60
}

foo () : void
{
  def secs = seconds_since_midnight ("17:42");
  ...
}
</code>
        <p>
          Another example could be:
        </p>
<code>
// split (3.7) => (3, 0.7)
split (x : double) : int * double
{
  def floor = System.Math.Floor (x);
  (System.Convert.ToInt32 (floor), x - floor)
}
</code>
      </body>
    </subsection>
    
        
    <subsection id="void-value">
      <title>The void literal</title>
      <body>
        <p>
          The void literal is written: <tt>()</tt>.
        </p>
        <p>
          The void literal is quite tricky thing, since it represents
          the only value of type <tt>void</tt>, which judging from the
          name should be ergh... void. In fact in some other functional
          languages this type is called <tt>unit</tt>, but in Nemerle
          the name comes from <tt>System.Void</tt> for which the
          <tt>void</tt> type is alias for.
        </p>
        <p>
          In C# the <tt>void</tt> type is used as return type of
          functions. It doesn't make much sense to use it elsewhere.
          It could be needed however if for example you want to use
          <tt>Hashtable ('a, 'b)</tt> type as a set representation of
          let's say strings. You can use <tt>Hashtable (string, void)</tt>
          then. And this is the place to use the void value -- when you
          call set method, you need to pass something as value to set --
          and you pass the void value.
        </p>
        <p>
          You can also use void value to return it from function -- as you
          remember the return value of function is the last expression
          in its body. However in most cases the last expression will
          already have the right <tt>void</tt> type.
        </p>
      </body>
    </subsection>


    <subsection id="local-functions">
      <title>Local functions</title>
      <body>
        <p>
          Local functions are functions defined within other functions.
          For this reason they are also called <b>nested functions</b>.
        </p>
        <p>
          There are three reasons to defined local functions. First one
          is not to pollute class namespace. We have the <tt>private</tt>
          keyword for that, so this doesn't seem any good reason.
        </p>
        <p>
          The second one is that local functions can access variables
          defined in outer function. This allows for somewhat different
          (better?) code structuring then in C#. You can have several
          variables and local functions using them defined in a function.
        </p>
        <p>
          The most important reason for local function is however the
          fact that you can pass them to other functions so they can
          be run from there implementing for example iterators for
          data structures. This is explained in more detail
          <a ref="functional-values">later</a>.
        </p>
        <p>
          Local functions are defined just like other values with
          the <tt>def</tt> keyword.
        </p>
<code>
sum_cubes (v1 : int, v2 : int, v2 : int) : int
{
  def cube (x : int) : int {
    x * x * x
  };
  cube (v1) + cube (v2) + cube (v3)
}
</code>
        <p>
          In almost all cases you can omit return type specification for
          local functions.  In most cases you can also omit parameter
          specifications (however not in the example above).
        </p>
        <p>
          Using local functions is one of way of implementing loops in
          Nemerle.
        </p>
<code>
<![CDATA[class Sum {
  public Main () : void
  {
    def sum (x) {
      if (x <= 0) 
        0
      else
        x + sum (x - 1)
    };
    System.Console.WriteLine ("Sum of numbers from 20 to 0 is: {0}", 
                              sum (20));
  }
}]]>
</code>
      </body>
    </subsection>

    
    <subsection id="functional-values">
      <title>Functional values</title>
      <body>
        <p>
          In Nemerle one can pass functions as arguments of other
          functions, as well as return them as results. This way functions
          are not worse then any other data types (think about Equal
          Rights for Functions movement :-)
        </p>
        <p>
          In C# one have delegates. This concept is quite similar to
          functional values.  However functional values are far more
          efficient and their types need not be declared before use.
        </p>
        <p>
          As a first example consider:
        </p>
<code>
// C#
delegate int IntFun (int);

class M {
  static int f(int x)
  {
    return x * 2;
  }

  static int run_delegate_twice(IntFun f, int v)
  {
    return f(f(v));
  }
  
  static void Main ()
  {
    System.Console.WriteLine("{0}", 
                   run_delegate_twice(new IntFun (f), 3));
  }
}
</code>
<code>
// Nemerle
class M {
  static f (x : int) : int
  {
    x * 2
  }

  static run_delegate_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }
  
  static void Main ()
  {
    System.Console.WriteLine ("{0}", run_delegate_twice (f, 3))
  }
}
</code>
        <p>
          In this example delegates seem just like function pointers
          in C.  Functional values don't present any better, except
          maybe shorter syntax.  However real power of delegates comes
          from the fact that one can use methods as delegates (thus
          effectively embedding the <tt>this</tt> pointer in delegate).
          This is much like "functional objects" design pattern in C++.
          We won't show it here, please refer to C# manual for details.
        </p>
        <p>
          Still using methods as delegates doesn't show their full power.
          The funny part begins when we use nested functions as functional
          values.
        </p>
<code>
class M {
  static run_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }

  static run_adder (x : int) : void
  {
    def f (y : int) : int { x + y };
    System.Console.WriteLine ("{0}", run_twice (f, 1))
  }

  static Main () : void
  {
    run_adder (1);
    run_adder (2);
  }
}
</code>
        <p>
          This example prints 3 and 5. Note how <tt>x</tt> is captured in local
          function <tt>f</tt>.
        </p>
        <p>
          Types of functions taking more then one argument are represented
          as tuples. For example the following functions:
        </p>
<code>
some_function (arg_1 : int, arg_2 : string, arg_3 : Foo) : float
{
   // ...
}
</code>
        <p>
          has type <tt>int * string * Foo -> float</tt>. Functions that take no
          arguments pretend to take one argument of type <tt>void</tt>. That is
          function:
        </p>
<code>
other_function () : string { ... }
</code>
        <p>
          posses type <tt>void -> string</tt>.
        </p>
        <!-- TODO: mention iterators -->
      </body>
    </subsection>
    
      
    <subsection id="named-parms">
      <title>Named parameters</title>
      <body>
        <p>
          This feature (in this form) comes from <a
          ref="http://www.python.org/">python</a>.  When you call a
          function you can name some of its parameters (which allows
          putting them in different order then in definition).
        </p>
<code>
<![CDATA[frobnicate (foo : int, do_qux : bool, 
                                do_baz : bool, 
                                do_bar : bool)
{
  // The method body doesn't mean anything ;-)
  if (do_qux && !do_baz) foo * 2
  else if (do_bar) foo * 7
  else if (do_baz) foo * 13
  else 42
}

Main () : void {
  // Parameters' names can be omitted.
  def res1 = frobnicate (7, true, false, true);
  
  // This is the indented usage -- the first 
  // (main) parameter comes without a name
  // and the following flags with names
  def res2 = frobnicate (7, do_qux = true,
                            do_baz = false, 
                            do_bar = true);
                            
  // You can however name every parameter:
  def res3 = frobnicate (foo = 7, do_qux = true, 
                         do_baz = false, do_bar = true);
                         
  // And permute them:
  def res3 = frobnicate (do_qux = true, do_bar = true, 
                         do_baz = false, foo = 7);
                         
  // You can also omit names for any number of leading 
  // parameters and permute the trailing ones.
  def res2 = frobnicate (7, true,
                            do_bar = true,
                            do_baz = false);
  ()
}]]>
</code>
        <p>
          The rules behind named parameters are simple:
        </p>
        <ul>
          <li>
            named parameters must come after all unnamed (positional)
            parameters
          </li>
          <li>
            positional parameters are assigned first
          </li>
          <li>
            the remaining parameters are assigned based on their names
          </li>
        </ul>
        <p>
          Named parameters can be used only when names of parameters are
          known (which basically mean they do not work in conjunction
          with functional values).
        </p>
      </body>
    </subsection>
    
    
    <subsection id="lambda-expr">
      <title>Lambda expressions</title>
      <body>
        <p>
          Lambda expression are just syntactic sugar to defined unnamed
          local functions. Unnamed local functions are useful when you
          need to pass some function to iterator, so you use it just once.
        </p>
        <p>
          Lambda expression are defined using the <tt>fun</tt> keyword,
          followed by formal parameters, optional return type and
          function body.
        </p>
<code>
def x = List.Map (fun (x) { 2 * x }, [1, 2, 3]);
def y = List.FoldLeft (fun (acc, val : int) { acc + val }, x);
assert (y == 12);
</code>
        <p>
          In general:
        </p>
<code>
fun (<meta>parms</meta>) { <meta>exprs</meta> }
</code>
        <p>
          Is equivalent to:
        </p>
<code>
{ 
  def tmp (<meta>parms</meta>) { <meta>exprs</meta> };
  tmp
}
</code>
        <p>
          This feature is similar to anonymous delegates in C# 2.0.
        </p>
      </body>
    </subsection>
    

    <subsection id="list-literals">
      <title>List literals</title>
      <body>
        <p>
          List literals are special forms of writing lists. Lists are data
          structure that is very often used in Nemerle. Often enough to
          get own syntax. Lists in Nemerle are somewhat different then
          the <tt>ArrayList</tt> type in .NET.
        </p>
        <ul>
          <li>
            lists in Nemerle are immutable (cannot be changed once
            created)
          </li>
          <li>
            one can only append items at the begging (constructing
            new lists)
          </li>
        </ul>
        <p>
          Of course you are free to use .NET <tt>ArrayList</tt>.
        </p>
        <p>
          Anyway to construct list consisting of given head (first element)
          and tail (rest of elements, also a list), write:
        </p>
<code>
<meta>head</meta> :: <meta>tail</meta>
</code>
        <p>
          To construct list with specified elements write:
        </p>
<code>
[ <meta>element_1</meta>, <meta>element_2</meta>, ..., <meta>element_n</meta> ]
</code>
        <p>
          This way you can also construct empty list (<tt>[]</tt>).
        </p>
      </body>
    </subsection>
    
  </section>
  

  <section id="variants-and-matching">
    <title>Variants and matching</title>
    <body>
      <p>
        Variants (called datatypes or sum types in
        <a ref="http://www.smlnj.org/">SML</a> and <a
        ref="http://www.ocaml.org">OCaml</a>) are forms of expressing
        data that comes in several different kinds. Simplest example of
        variants are enum types known from C#.
      </p>
      <comparison>
        <entry>
          <csharp>
            enum Color {<br/>
            Red,<br/>
            Yellow,<br/>
            Green<br/>
            }
          </csharp>
          <nemerle>
            variant Color {<br/>
            | Red<br/>
            | Yellow<br/> 
            | Green<br/> 
            }
          </nemerle>
          <remarks>
          </remarks>
        </entry>
      </comparison>
      <p>
        However variant options can carry a value.
      </p>
<code>
variant Color {
  | Red
  | Yellow
  | Green
  | Different { 
      red : float; 
      green : float; 
      blue : float; 
    }
}
</code>
      <p>
        So if color isn't neither red, yellow nor green, it can be
        represented with RGB.
      </p>
      <p>
        You can think about variants as of union with selector in C. In
        OO world one can sometimes see modeling variants with sub classing:
      </p>
<code>
// C#
class Color { }
class Red : Color { }
class Green : Color { }
class Yellow : Color { }
class Different : Color {
  float red;
  float green;
  float blue;
}
</code>
     <p>
       Of course you need to write constructor, mark fields
       <tt>public</tt> and so on. When you're done, using this kind
       of stuff is quite hard -- you need to use lots of <tt>is</tt>
       expressions.
     </p>
     <p>
       On the other hand Nemerle provides easy and convenient method of
       dealing with variants -- pattern matching:
     </p>
<code>
string_of_color (color : Color) : string
{
  match (color) {
    | Red => "red"
    | Yellow => "yellow"
    | Green => "green"
    | Different (r, g, b) => 
      System.String.Format ("rgb({0},{1},{2})", r, g, b)
  }
}
</code>
      <p>
        The main idea behind patterns is that they match values that
        look like them. For example Nemerle compiler creates default
        constructor for the <tt>Different</tt> variant option. It has following
        body:
      </p>
<code>
<![CDATA[public this (red : float, green : float, blue : float)
{
  this.red <- red;
  this.green <- green;
  this.blue <- blue;
}]]>
</code>
      <p>
        Therefore constructor call <tt>Different (r, g, b)</tt> create new
        variant option instance with specified arguments. The pattern looks
        the same -- it binds actual values of <tt>red</tt>, <tt>green</tt>
        and <tt>blue</tt> fields to <tt>r</tt>, <tt>g</tt> and <tt>b</tt>
        respectively. You can also say it explicitly:
      </p>
<code>
  | Different { red = r; green = g; blue = b; } => 
    System.String.Format ("rgb({0},{1},{2})", r, g, b)
</code>
      <p>
        The example above, while simple, isn't best usage of
        variants. Variants are best at handling tree-like data structures.
      </p>
<code>
variant XmlNode {
  | Text { payload : string; }
  | Element { name : string; children : list (XmlNode); }
}

parse (n : XmlNode) : string
{
  match (n) {
    | Element ("foo", []) => construct_foo ()
    | Element ("bar", [Text (t)]) => construct_bar (t)
    | _ => throw InvalidArgumentException ("n")
  }
}
</code>
      <p>
        The <tt>[...]</tt> things are list patterns, that work much like
        list literals.
      </p>
    </body>
  </section>

  
  <section id="same">
    <title>The same</title>
    <body>
      <p>
        This section lists things that are written (mostly) the same way as
        they do in C#. It only includes cases when it could be doubtful.
      </p>
      <!-- 
        @"foo"
        /* */
        //
        using (+ opening classes)
        throw
        try..finally
        opertors?
      -->
    </body>
  </section>

  
    <!-- 
      <comparison>
        <entry>
          <csharp>
          </csharp>
          <nemerle>
          </nemerle>
          <remarks>
          </remarks>
        </entry>
      </comparison>

    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
