/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

using Nemerle.Collections;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core
{
  /** MACROS EXTENDING SYNTAX OF LANGUAGE */

  /**
   * The 'unchecked' macro
   */
  macro @unchecked (expr)
  syntax ("unchecked", expr)
  {
    <[ $(ty_expr (Nemerle.Macros.ImplicitCTX ().WithChecked (false), expr) : typed) ]>
  }

  /**
   * The 'checked' macro
   */
  macro @checked (expr)
  syntax ("checked", expr)
  {
    <[ $(ty_expr (Nemerle.Macros.ImplicitCTX ().WithChecked (true), expr) : typed) ]>
  }
  
  /** specialized macro for [if] condition with good warning messages,
      it performs typing of given expressions to check their type
      correctness
   */
  macro @if (cond, e1, e2)
  syntax ("if", "(", cond, ")", e1, Optional (";"), "else", e2) 
  {
    def tcond = ty_expr (Nemerle.Macros.ImplicitCTX (), cond);
    def bool_ty = <[ ttype: bool ]>;
    expect_type ("if condition", tcond, bool_ty);
    
    <[ 
      match ($(tcond : typed)) { 
        | true => $e1 
        | _ => $e2
      } 
    ]>
  }

  /** this macro provides convenient way to write a simple while loop,
      which performs execution of [body] parameter as long as
      [condition] is true
    */
  macro @while (cond, body)
  syntax ("while", "(", cond, ")", body) 
  {
    def loop = Nemerle.Macros.Symbol (Util.tmpname ("while_"));

    <[ 
      def $(loop : name) () : void {
        when ($cond) { $body; $(loop : name) () }
      }; 
      $(loop : name) (); 
    ]>
  }

  /** shortcut for [if (cond) body else ()] */
  macro @when (cond, body)
  syntax ("when", "(", cond, ")", body) 
  {
    <[ match ($cond) { | true => $body | _ => () } ]>
  }

  macro @for (init, cond, change, body)
  syntax ("for", "(", Optional (init), ";", Optional (cond), ";",
          Optional (change), ")", body) 
  {
    def init = if (init != null) init else <[ () ]>;
    def cond = if (cond != null) cond else <[ true ]>;
    def change = if (change != null) change else <[ () ]>;    

    def loop = Nemerle.Macros.Symbol (Util.tmpname ("for_"));
    
    <[ 
      $init;
      def $(loop : name) () : void {
        when ($cond) { $body; $change; $(loop : name) () }
      };
      $(loop : name) ();
    ]>
  }

  /** shortcut for [if (cond) () else body] */
  macro @unless (cond, body)
  syntax ("unless", "(", cond, ")", body) 
  {
    <[ match ($cond) { | false => $body | _ => () } ]>
  }

  /** macro providing C# 'using' functionality
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_8.asp  
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vclrfusingstatement.asp
   */
  macro @using (body, params args : array <expr>)
  syntax ("using", "(", args, ")", body) 
  {
    def maybe_valuetype_dispose (nm, typed_expr) {
      def tc = Tyutil.GetTypeTycon (Tyexpr.type_of (typed_expr));
      if (tc != null && tc.IsValueType)
        <[ ($(nm : name) :> System.IDisposable).Dispose () ]>
      else
        <[
          when ($(nm : name) != null)
            ($(nm : name) :> System.IDisposable).Dispose ()
        ]>
    };
    
    def len = args.Length;
    def store_exprs (i, preexprs, postexprs) {
      if (i < len) {
        def x = Macros.NewSymbol ();
        match (args[i]) {
          | <[ $(str : name) = $e ]> =>
            def ex = Tyexpr.ty_expr (Nemerle.Macros.ImplicitCTX (), e);            
           
            store_exprs (i + 1, <[ def $(str : name) = $(ex : typed) ]> :: preexprs, 
                         maybe_valuetype_dispose (str, ex) :: postexprs)
          | e =>
            def ex = Tyexpr.ty_expr (Nemerle.Macros.ImplicitCTX (), e);
            
            store_exprs (i + 1, <[ def $(x : name) = $(ex : typed) ]> :: preexprs,
                         maybe_valuetype_dispose (x, ex) :: postexprs)
        }
      }
      else
        (preexprs, postexprs)
    };

    def (preexps, postexps) = store_exprs (0, [], []);
    List.FoldLeft2 (preexps, postexps, <[ $body ]>, fun (pre, post, acc) {
      <[ $pre; try { $acc } finally { $post } ]>
    });
  }

  macro @lock (x, body)
  syntax ("lock", "(", x, ")", body)
  {
    <[ 
      System.Threading.Monitor.Enter ($x);
      try {
        $body
      } finally {
        System.Threading.Monitor.Exit ($x);
      }
    ]>
  }

  macro dowhile (cond, body) 
  syntax ("do", body, "while", "(", cond, ")") 
  {
    def loop = Nemerle.Macros.Symbol (Util.tmpname ("do_while_"));

    <[ 
      def $(loop : name) () {
        $body; 
        when ($cond) $(loop : name) ();
      };
      $(loop : name) ()
    ]>
  }

  /**
   * The 'foreach' macro introduces a construction equivalent
   * to C#'s 'foreach' keyword, iterating over a collection.
   */
  macro @foreach (iter : funparm, collection, body)
  syntax ("foreach", "(", iter, "in", collection, ")", body)
  {
    def tcollection = ty_expr (Nemerle.Macros.ImplicitCTX (), collection); 

    match (iter) {
      | <[ funparm: $(iname : name) : $ty ]> =>
        match (Tyutil.top_expand (tcollection.expr_ty)) {
          | T_app (tc, _) =>
            if (tc.SuperType (InternalType.Nemerle_list_tc) matches Some)
              <[
                def foreach_loop (_ : list < $ty >) {
                  | $(iname : name) :: xs => $body; foreach_loop (xs)
                  | _ => ()
                }
                foreach_loop ($(tcollection : typed))
              ]>
            else {
              def init_body =
                if (tc.SuperType (InternalType.IEnumerable_tc) matches Some)
                  <[ ($(tcollection : typed) : System.Collections.IEnumerable).GetEnumerator () ]>
                else
                  <[ $(tcollection : typed).GetEnumerator () ]>;

              def finally_body = <[
                match (enumerator) {
                  | x : System.IDisposable => x.Dispose ();
                  | _ => ()
                }
              ]>;
              /// hack, to disable warning about [enumerator] type if it is known at compile time
              match (finally_body) {
                | PT.E_match (_, mclauses) => 
                  List.Iter (mclauses, fun (x : PT.Match_case) { x.disable_warnings = true })
                | _ => Util.ice ("we constructed something else a while ago")
              }

              <[ 
                def enumerator = $init_body;
                def loop () {
                  when (enumerator.MoveNext ()) {
                    def $(iname : name) = (enumerator.Current :> $ty);
                    $body;
                    loop ();
                  }
                };
                try { loop () } 
                finally { $finally_body }
              ]>
            }

          | T_array (_ , rank) =>
            def indices  = array (rank);
            def lengths = array (rank);
            for (mutable i = 0; i < rank; ++i) {
              indices [i] = Macros.NewSymbol ();
              lengths [i] = Macros.NewSymbol ();
            }
            def indices_list = List.RevMap (List.FromArray (indices), fun (x) {
                <[ $(x : name) ]> 
            });
            def build_loops (depth)  {
              | 0 => <[ def $(iname : name) = cached_collection [..$indices_list]  : $ty; $body; ]>
              | n => 
                def idx = indices [n - 1];
                <[ for (mutable $(idx : name) = 0; 
                        $(idx : name) < $(lengths [n - 1] : name);
                        ++ $(idx : name) ) 
                     $(build_loops (n - 1)) 
                ]>
            }
            mutable sequence = [ <[ $(build_loops (rank)) ]> ];
            if (rank == 1) 
              sequence = <[ def $(lengths [0] : name) = cached_collection.Length ]> :: sequence;
            else
              for (mutable i = rank - 1; i >= 0; --i)
                sequence = <[ def $(lengths [i] : name) = cached_collection.GetLength ($(i : int)) ]>
                           :: sequence;

            sequence = <[ def cached_collection = $(tcollection : typed) ]> :: sequence;
            <[ { .. $sequence } ]>

          | _ =>
            Message.fatal_error ("collection in foreach must be an array or type implementing" +
                                 "enumerator pattern");
        }
      | _ =>
          Message.fatal_error ("iterator in foreach must be an identifier" +
                               "with optional type");
    }
  }

  macro ignore (e) 
  {
    <[ def _ = $e; () ]>
  }

  macro assert (cond, message = <[ "" ]>) 
  {
    match (cond) {
      | <[ false ]> =>
        // skip cond in this case so it gets 'a type
        <[ throw AssertionException ($(cond.loc.file : string), 
                                     $(cond.loc.line : int),
                                     "", $message) ]>
      | _ =>
        <[ unless ($cond) 
             throw AssertionException ($(cond.loc.file : string), 
                                       $(cond.loc.line : int),
                                       $(PrettyPrint.SprintExpr (None (), cond) : string),
                                       $message) ]>
    }
  }

  macro abort (message = <[ "" ]>) 
  {
    <[ throw AssertionException ($(message.loc.file : string), 
                                 $(message.loc.line : int), $message) ]>
  }

  /** MACROS EXTENDING TYPE SYSTEM OF LANGUAGE */

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro Record (par : TypeBuilder)
  {
    def instance_flags = BindingFlags.Instance %|
      BindingFlags.Public %| BindingFlags.NonPublic %|
      BindingFlags.DeclaredOnly;

    def make_ctor (is_value_type, base_ctor : IMember) {
      def base_ctor = (base_ctor :> IMethod);
      def (ctor_parms, base_call) =
        if (base_ctor == null)
          ([], if (is_value_type) <[ () ]> else <[ base () ]>)
        else {
          def pp = base_ctor.GetHeader ().parms;
          def callparms = List.Map (pp, fun (fp : Fun_parm) {
            <[ $(fp.name : usesite) ]>
          });
          (List.Map (pp, fun (fp : Fun_parm) {
             <[ funparm: $(fp.name : usesite) : $(fp.ty : typed) ]>
           }),
           <[ base (..$callparms) ]>)
        };

      def flds = par.GetFields (instance_flags);

      def collect (mem : IField, acc) {
        def n = Macros.UseSiteSymbol (mem.Name);
        def fp = <[ funparm: $(n : name) : $(mem.GetMemType () : typed) ]>;
        def ex = <[ this.$(n : name) = $(n : name) ]>;
        def (es, ps) = acc;
        (ex :: es, fp :: ps)
      };
      def (assigns, parms) = List.FoldLeft (flds, ([], []), collect);
      
      def body = <[ { ..$(base_call :: assigns) } ]>;
      body.loc = par.GetLocation ();
      
      def attrs = Modifiers (mods = 
        match (par.GetTydecl ()) {
          | TD_variant => NemerleAttributes.Protected
          | _ => NemerleAttributes.Public
        }, attrs = []);
        
      def parms = List.Append (ctor_parms, List.Rev (parms));
      def meth = <[ decl: ..$attrs this (..$parms) $body ]>;
      meth.loc = par.GetLocation ();

      /// we do not try to add empty constructor if it exists
      if (parms matches []) {
        def existing = par.GetConstructors (instance_flags);
        unless (List.Exists (existing, fun (x : IMethod) { 
          x.GetHeader ().parms matches [] 
        }))
          par.Define (meth);
      }
      else
        par.Define (meth);
    };
      
    match (par.SuperClass ()) {
      | Some (baseti) when baseti.FullName != "System.ValueType" =>
        def ctors = baseti.GetConstructors (instance_flags);
        match (ctors) {
          | [] => 
            match (baseti.GetTydecl ()) {
              | TD_variant => make_ctor (false, null)
              | _ =>
                Message.fatal_error ("type `" + baseti.FullName + "' (base of `" + 
                                     par.FullName +
                                     "') has no constructors, cannot "
                                     "generate default constructor")
            }
          | decls =>
            List.Iter (decls, fun (x) { make_ctor (false, x) })
        }

      | Some => make_ctor (true, null)
        
      | _ => make_ctor (false, null)
    }
  }

  
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Field,
                       Inherited = false, AllowMultiple = false)]
  macro StaticInitializer (t : TypeBuilder, f : FieldBuilder, val)
  {
    def is_static = f.Attributes %&& NemerleAttributes.Static;
    def static_attr =
      if (is_static) BindingFlags.Static
      else BindingFlags.Instance;
    def mems = t.GetConstructors (static_attr %| BindingFlags.Public %|
                                  BindingFlags.NonPublic %|
                                  BindingFlags.DeclaredOnly);
    def fieldName = Macros.UseSiteSymbol (f.Name);
    def typeName = Macros.UseSiteSymbol (t.Name);

    def (init, base_ctor) =
      if (is_static)
        (<[ $(typeName : name).$(fieldName : name) = $val ]>, <[ () ]>)
      else
        (<[ this.$(fieldName : name) = $val ]>, <[ base () ]>);

    // given existing constructor, insert call to base constructor
    // at its beginning 
    def inject (ctor : NemerleMethod) {
      def bd = ctor.Body;
      def nbody =
        match (bd) {
          | <[ {.. $(e :: rest) } ]> =>
            match (e) {
              | <[ base (..$_) ]> => <[ $e; $init; {.. $rest } ]>
              | <[ this (..$_) ]> => bd
              | _ => <[ $base_ctor; $init; $bd ]>
            }
          | _ => <[ $base_ctor; $init; $bd ]>
        };
      ctor.Body = nbody
    };
    match (mems) {
      | [] => 
        if (is_static) 
          t.Define (<[ decl: static public this () { $init } ]>)
        else
          t.Define (<[ decl: public this () { $base_ctor; $init } ]>)
      | _ =>
        List.Iter ((mems :> list <NemerleMethod>), inject)
    }
  }
  
  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Property,
                       Inherited = false, AllowMultiple = true)]
  macro PropertyEmbeddedField (t : TypeBuilder, p : PropertyBuilder, field_box)
  {
    match (field_box) { 
      | <[ fun (..$([val])) { ..$_ } ]> =>
        def fld_name = Macros.NameOfSString (val.name);
        def unique = Macros.UseSiteSymbol (Util.tmpname (fld_name.Id));
        def set = p.GetSetter () :> NemerleMethod;
        when (set != null)
          set.Body = Macros.RecursiveRename (t, set.Body, fld_name, unique);
        def get = p.GetGetter () :> NemerleMethod;
        when (get != null)
          get.Body = Macros.RecursiveRename (t, get.Body, fld_name, unique);

        if (p.Attributes %&& NemerleAttributes.Static) {
          val.modifiers.mods |= NemerleAttributes.Static;
          t.Define (<[ decl: ..$(val.modifiers) $(unique : name) : $(val.ty); ]>)
        }
        else
          t.Define (<[ decl: ..$(val.modifiers) $(unique : name) : $(val.ty); ]>)
      | _ =>
        Message.fatal_error (field_box.loc, "malformed PropertyEmbeddedField (ICE?)")
    }
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Event,
                       Inherited = false, AllowMultiple = true)]
  macro EventEmbeddedField (t : TypeBuilder, p : EventBuilder, field_box)
  {
    match (field_box) { 
      | <[ fun (..$([val])) { ..$_ } ]> =>
        def fld_name = Macros.NameOfSString (val.name);
        def unique = Macros.UseSiteSymbol (Util.tmpname (fld_name.Id));
        def set = p.GetRemover () :> NemerleMethod;
        when (set != null)
          set.Body = Macros.RecursiveRename (t, set.Body, fld_name, unique);
        def get = p.GetAdder () :> NemerleMethod;
        when (get != null)
          get.Body = Macros.RecursiveRename (t, get.Body, fld_name, unique);

        if (p.Attributes %&& NemerleAttributes.Static) {
          val.modifiers.mods |= NemerleAttributes.Static;
          t.Define (<[ decl: ..$(val.modifiers) $(val.name) : $(val.ty); ]>)
        }
        else
          t.Define (<[ decl: ..$(val.modifiers) $(val.name) : $(val.ty); ]>)
      | _ =>
        Message.fatal_error (field_box.loc, "malformed EventEmbeddedField (ICE?)")
    }
  }
}

namespace Nemerle.Compiler.Util {
  macro locate (l, body) {
    <[
      def pushpop = $l != null && ($l : object) != Located.default_loc;
      when (pushpop) Location_stack.push ($l);
      try { $body } finally { when (pushpop) Location_stack.pop () }
    ]>
  }
}

namespace Nemerle.Macros {


  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method,
                       Inherited = true, AllowMultiple = false)]
  macro Hygienic (_ : TypeBuilder, m : ParsedMethod) {
    m.Body = <[
      TypingContext.PushNewColor (TypingContext.MacroUseColor,
                                  TypingContext.MacroUseContext);
      def result = $(m.Body);
      TypingContext.PopColor ();
      result
    ]>;
  }


  macro DefineCTX (ctx) {
    <[ def $(Nemerle.Compiler.Macros.GetImplicitCTXName () : name) = $ctx ]>
  }

  macro ImplicitCTX () {
    <[ $(Nemerle.Compiler.Macros.GetImplicitCTXName () : name) ]>
  }  
  
  /** creates new symbol with given id and current global context */
  macro Symbol (id)
  {
    def nr = Nemerle.Macros.ImplicitCTX ().env.GetMacroContext ();
    <[ PT.Name.NameInCurrentColor (Nemerle.Utility.NString.Split ($id, array ['.']), 
                                   $("_N_MacroContexts" : dyn).Get ($(nr : int))) ]>
  }

  macro pretty_print_expr (exp, expand : bool)
  {
    def ctx = if (expand) Some (Nemerle.Macros.ImplicitCTX ()) else None ();
    PrettyPrint.PrintExpr (ctx, exp);
    <[ () ]>
  }
}

namespace Nemerle.Extensions {
  /**
   * The `lambda' macro
   */
  macro @lambda (parm : funparm, body)
  syntax ("lambda", parm, "->", body)
  {
    match (parm) {
      | <[ funparm: $(iname : name) : $ty ]> =>
        <[ fun ($(iname : name) : $ty) { $body } ]>
      | _ =>
        Message.fatal_error ("expected a single parameter for the lambda abstraction");
        
    }
  } 

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro TupleToString (t : TypeBuilder) {
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|          
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);
    def appends = 
      List.RevMap (flds, fun (x : IField) { 
        <[ ignore (str.Append ($(x.Name : usesite).ToString ())); ]>
      });
    def body_seq =
      List.FoldLeft (List.Tail (appends), List.Head (appends) ::
                     [<[ ignore (str.Append (")")); str.ToString () ]>], fun (x, acc) {
        x :: <[ ignore (str.Append (", ")) ]> :: acc
      });
    def body_seq = <[ def str = System.Text.StringBuilder ("(") ]> :: body_seq;
    t.Define (<[ decl:
      public override ToString () : string { ..$body_seq }
    ]>);
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro DisableImplicitConstructor (t : TypeBuilder) {
    t.DisableImplicitConstructor ();
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro StructuralEquality (t : TypeBuilder) {
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);
    def body = 
      List.FoldLeft (flds, <[ true ]>, fun (x : IField, acc) { 
        def nm = Macros.UseSiteSymbol (x.Name);
        <[ $acc && $(nm : name).Equals (tup.$(nm : name)) ]>
      });
    def tname = Macros.UseSiteSymbol (t.Name);
    def full = <[ if (o.GetType ().Equals (this.GetType ())){
                    def tup = (o :> $(tname : name));
                    $body
                  } else false ]>;
    t.Define (<[ decl:
      public override Equals (o : System.Object) : bool { $full }
    ]>);
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro LexicographicCompareTo (t : TypeBuilder) {
    def tname = Macros.UseSiteSymbol (t.Name);
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);
    def compareField (fld : IField)
    {
        def nm = Macros.UseSiteSymbol (fld.Name);
        def hasLess = match (fld.GetMemType ()) {
            | T_app (ti, _) =>
              def name = ti.FullName;
              match (name) {
                  | "Nemerle.Core.string"
                  | "System.String"
                  | "Nemerle.Core.int"
                  | "System.Int32"
                  | "System.UInt32"
                  | "Nemerle.Core.float"
                  | "System.Single"
                  | "Nemerle.Core.double"
                  | "System.Double"
                  | "Nemerle.Core.char"
                  | "System.Char" =>
                    true
                  | _ =>
                    false
              }
            | _ => 
              false
        }
        if (hasLess)
        {
            <[ 
              if (this.$(nm : name) < other.$(nm : name)) 
              {
                  -1
              }
              else if (this.$(nm : name) > other.$(nm : name)) 
              {
                  1
              }
              else
              {
                  0
              }
           ]>
       }
       else
       {
           <[ this.$(nm : name).CompareTo (other.$(nm : name)); ]>
       }
    }
    def body = 
      List.FoldRight (flds, <[ 0 ]>, fun (x : IField, acc) { 
        <[ 
           def cmp = $(compareField (x));
           if (cmp == 0) 
           {
               $(acc)
           }
           else
           {
               cmp
           }
        ]>
      });
    def full = if (t.IsValueType) 
    {
        body 
    }
    else
    {
        <[ 
           if (object.ReferenceEquals (this, other)) 
           {
               0
           }
           else if (object.ReferenceEquals (other, null))
           {
               1
           }
           else
           {
               $(body)
           }
        ]>
    }

    t.Define (<[ decl:
      public CompareTo (other : $(tname : name)) : int { $full }
    ]>);
    t.Define (<[ decl:
      public CompareTo (Oother : object) : int 
      { 
        try 
        {
          def other = Oother :> $(tname : name);
          this.CompareTo (other)
        } 
        catch 
        {
          | _ : System.InvalidCastException => throw System.ArgumentException ()
        }
      }
    ]>);
  }

  [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers,
                       Nemerle.MacroTargets.Class,
                       Inherited = false, AllowMultiple = false)]
  macro StructuralHashCode (t : TypeBuilder) {
    def flds = t.GetFields (BindingFlags.Public %| BindingFlags.NonPublic %|          
                            BindingFlags.Instance %| BindingFlags.DeclaredOnly);

    def body = 
      List.FoldLeft (flds, <[ 0 ]>, fun (x : IField, acc) {
        <[ $acc %^ $(x.Name : usesite).GetHashCode () ]>
      });
    t.Define (<[ decl:
      public override GetHashCode () : int {
        $body
      }
    ]>);
  }
  
  /** MACROS, WHICH WE CAN DO BETTER THAN HASKELL */

  macro SelectFromTuple (k : int, n : int, tupl)
  {
    def symb = Macros.NewSymbol ();
    mutable tup = [];
    for (mutable i = n; i > 0; --i)
      if (i == k)
        tup = <[ pattern: $(symb : name) ]> :: tup
      else
        tup = <[ pattern: _ ]> :: tup;

    <[ def (.. $tup) = $tupl; $(symb : name) ]>
  }

  macro TupleMap (f, tup)
  {
    match (tup) {
      | <[ (.. $elms) ]> =>
        def mapped = List.Map (elms, fun (e) { <[ $f ($e) ]> });
        <[ (.. $mapped) ]>
      | _ => 
        Message.fatal_error ("'TupleMap' macro expects function and tuple")
      }
  }

  macro PrintTuple (tup, size : int)
  {
    def symbols = array (size);
    mutable pvars = [];
    for (mutable i = size - 1; i >= 0; --i) {
      symbols[i] = Macros.NewSymbol ();
      pvars = <[ pattern: $(symbols[i] : name) ]> :: pvars;
    };
    mutable exps = [];
    for (mutable i = size - 1; i >= 0; --i)
      exps = <[ System.Console.WriteLine ($(symbols[i] : name)) ]> :: exps;

    exps = <[ def (.. $pvars) = $tup ]> :: exps;
    <[ {.. $exps } ]>
  }

  macro PrintTupleTyped (tup)
  {
    match (type_of (ty_expr (Nemerle.Macros.ImplicitCTX (), tup))) {
      | T_prod (args) =>
        def size = List.Length (args);
        def symbols = array (size);
        mutable pvars = [];
        for (mutable i = size - 1; i >= 0; --i) {
          symbols[i] = Macros.NewSymbol ();
          pvars = <[ pattern: $(symbols[i] : name) ]> :: pvars;
        };
        mutable exps = [];
        for (mutable i = size - 1; i >= 0; --i)
          exps = <[ System.Console.WriteLine ($(symbols[i] : name)) ]> :: exps;
          
        exps = <[ def (.. $pvars) = $tup ]> :: exps;
        <[ {.. $exps } ]>
      | _ => 
        Message.fatal_error ("expected tuple")
    }
  }
} // end ns

namespace Nemerle.Diagnostics {

  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method)]
  macro Trace (_ : TypeBuilder, m : ParsedMethod, tracecall) {
    def add (x) {
      | <[ {.. $seq } ]> =>
        def nseq = 
        List.Flatten (List.Map (seq, fun (e : Parsetree.Expr) { 
          [<[
             def $("line" : usesite) = $(e.loc.line : int);
             $tracecall;
           ]>, e]
        }));
        <[ { ..$nseq } ]>
      | _ => x
    };
    def bod = Macros.TraverseExpr (None (), m.Body, add, fun (x) { x });
    m.Body = <[ 
      def $("file" : usesite) = $(m.Body.loc.file : string);
      def $("method" : usesite) = $(m.Name : string);
      $bod;
    ]>
  }
}


namespace Nemerle {

  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method)]
  macro NotImplemented (t : TypeBuilder, m : ParsedMethod) {
    def ignores = List.Map (m.header.parms, fun (x : PT.Fun_parm) {
      <[ ignore ($(Macros.NameOfSString (x.name) : name)) ]>
    });
    def message = "Method `" + Macros.NameOfSString (m.name).Id + "' in type `" + 
                  t.FullName + "' is not implemented yet.";
    m.Body = <[ 
      { ..$ignores }; 
      throw System.NotImplementedException ($(message : string)) 
    ]>
  }
}
