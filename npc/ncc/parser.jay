%{
using System;

namespace Nemerle.Compiler {

class Parser {
  protected list result;

  class Located_ID {
    public string name;
    public Location loc;
  }

  class Fun_helper {
    public Fun_header header;
    public bool is_ctor;
    public list implements;
    public Fun_helper(Fun_header h, bool c, list i)
    {
    	header = h;
	is_ctor = c;
	implements = i;
    }
  }

  protected Lexer lex;

  string tmp_name()
  {
  	return "__N__" + (Util.next_id()).ToString();
  }

  list cons(object h, list t)
  {
  	return new list.Cons(h, t);
  }

  list nil()
  {
  	return new list.Nil();
  }

  option none()
  {
  	return new option.None();
  }

  option some(object x)
  {
  	return new option.Some(x);
  }

  void fixup_tydecl(object targ, list mods, Type_decl_base source)
  {
	Type_decl_base target = (Type_decl_base)targ;
			
        target.name = source.name;
        target.loc = source.loc;
        target.typarms = source.typarms;
        target.t_extends = source.t_extends;
        target.t_implements = source.t_implements;

	target.modifiers = mods;
  }
  
  void fixup_decl(object targ, list mods, Located_ID source)
  {
	Decl_base target = (Decl_base)targ;
			
        target.name = source.name;
        target.loc = source.loc;

	target.modifiers = mods;
  }

  Expr make_bin(Expr e1, string op, Expr e2)
  {
  	Expr rf = new Expr.E_ref(op);
	Expr cl = new Expr.E_call(rf, cons(e1, cons(e2, nil())));
  	locate(rf);
  	locate(cl);
	return cl;
  }
  
  Expr make_unary(string op, Expr e)
  {
  	Expr rf = new Expr.E_ref(op);
	Expr cl = new Expr.E_call(rf, cons(e, nil()));
  	locate(rf);
  	locate(cl);
	return cl;
  }
  
  void locate(object o, Location l)
  {
  	((Located)o).loc = l;
  }

  void locate(object o)
  {
  	locate(o, lex.get_location());
  }

  Located_ID make_located_id(string name)
  {
      Located_ID i = new Located_ID();
      i.name = name;
      i.loc = lex.get_location();
      return i;
  }

  public list parse(Lexer l)
  {
      lex = l;
      result = nil();
      yyparse(l);
      return result;
  }

%}

%token <int> NUMBER_LITERAL
%token <string> ID
%token <string> TYVAR
%token <string> STRING_LITERAL
%token <string> OP1
%token <string> OP2
%token <string> OP3
%token <string> OP4
%token <string> OP5
%token <string> OP6
%token <string> OP7

%token KW_ABSTRACT KW_CONST KW_EXTERN KW_INTERNAL KW_NEW KW_PRIVATE
%token KW_PROTECTED KW_SEALED KW_VOLATILE KW_NAMESPACE KW_BASE
%token KW_CLASS KW_ENUM KW_EXTENDS KW_FINALLY KW_IN KW_METHOD KW_NULL KW_OUT
%token KW_PUBLIC KW_RAISE KW_REF KW_STRUCT KW_THIS KW_VARIANT
%token KW_INTERFACE KW_IMPLEMENTS KW_WHERE KW_FIELD KW_VALUE KW_TYPE KW_LET
%token KW_IN KW_FUN KW_AND KW_TYMATCH KW_WITH KW_TRY KW_OPEN KW_VOID
%token KW_IF KW_THEN KW_ELSE KW_LETFUN KW_AS KW_RECORD KW_MATCH

%token COLON_MORE LESS_MINUS MINUS_MORE EQ_MORE

%token ERROR

%nonassoc KW_RAISE LESS_MINUS KW_LET
%left OP7
%left OP6
%left OP5
%left OP4
%left OP3
%left OP2 '*'
%right OP1
%nonassoc UNARY

%type <Located_ID> located_id located_qid located_id_or_dummy
%type <string> qid
%type <Type> ty prim_ty prod_ty
%type <bool> maybe_ref maybe_new
%type <Type_decl> type_decl
%type <Type_decl_base> type_header
%type <Typarms> typarms
%type <Expr> expr sequence prim_expr local_fun_body
%type <Fun_helper> fun_def_head
%type <Fun_body> fun_body
%type <Fun_header> lambda_head
%type <Class_member.M_function> fun_def
%type <Pattern> nl_pattern pattern maybe_pattern

%type <list> maybe_implements comma_sep_types interface_members variant_options tyvars
%type <list> maybe_where where_constraints type_members attrs maybe_record record
%type <list> record_members non_empty_fun_parms fun_parms maybe_method_implements
%type <list> implemented_methods prod_ty_x expr_list non_empty_parameters parameters
%type <list> fun_defs match_cases namespace_or_type_decls record_patterns 
%type <list> comma_sep_patterns comma_sep_exprs

%type <option> maybe_extends

%start program

%%

program:
        namespace_or_type_decls		{ result = $1; }

namespace_or_type_decl:
          KW_OPEN located_qid ';'
	  	{
			$$ = new Top_decl.TD_open ($2.name);
			locate($$, $2.loc);
		}
        | KW_NAMESPACE located_id '=' located_qid ';'
		{
			$$ = new Top_decl.TD_namespace_alias ($2.name, $4.name);
			locate($$, $2.loc);
		}
	| KW_NAMESPACE located_qid '{' namespace_or_type_decls '}'
		{
			$$ = new Top_decl.TD_namespace ($2.name, $4);
			locate($$, $2.loc);
		}
	| type_decl

located_id:
        ID      { $$ = make_located_id($1); }
	
located_id_or_dummy:
          located_id
        | '_'		{ $$ = make_located_id(tmp_name()); }

qid:
          ID            { $$ = $1; }
        | ID '.' qid    { $$ = $1 + "." + $3; }

located_qid:
        qid      { $$ = make_located_id($1); }

namespace_or_type_decls:
          namespace_or_type_decl namespace_or_type_decls
			{ $$ = cons($1, $2); }
        | /* */
			{ $$ = nil(); }

type_header:
          located_id typarms maybe_extends maybe_implements
	  	{
			Type_decl_base p = new Type_decl_base();
			
			p.name = $1.name;
			p.loc = $1.loc;
			p.typarms = $2;
			p.t_extends = $3;
			p.t_implements = $4;

			$$ = p;
	  	}

type_decl:
          attrs KW_TYPE type_header '=' ty ';'
	  	{
			$$ = new Type_decl.TD_alias($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_TYPE type_header '=' KW_EXTERN STRING_LITERAL ';'
		{
			$$ = new Type_decl.TD_external($6);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_INTERFACE type_header '{' interface_members '}'
		{
			$$ = new Type_decl.TD_interface($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_CLASS type_header '{' type_members '}'
		{
			$$ = new Type_decl.TD_class($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_STRUCT type_header '{' type_members '}'
		{
			$$ = new Type_decl.TD_class($5);
			// FIXME: set some attribute, that it's struct
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_RECORD type_header record
		{
			$$ = new Type_decl.TD_class($4);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_VARIANT type_header '=' '[' maybe_bar variant_options ']'
		{
			$$ = new Type_decl.TD_variant($7);
			fixup_tydecl($$, $1, $3);
		}

maybe_extends:
          /* */                 { $$ = none(); }
        | KW_EXTENDS ty         { $$ = some($2); }

maybe_implements:
          /* */                                 { $$ = nil(); }
        | KW_IMPLEMENTS comma_sep_types         { $$ = $2; }

comma_sep_types:
          ty                                    { $$ = cons($1, nil()); }
        | ty ',' comma_sep_types              { $$ = cons($1, $3); }

interface_members:
          /* */                                   { $$ = nil(); }
        | interface_member interface_members      { $$ = cons($1, $2); }

maybe_new:
          /* */   { $$ = false; }
        | KW_NEW  { $$ = true; }

interface_member:
        maybe_new maybe_method fun_def_head ';'
		{
			Class_member m = new Class_member.M_iface_method($1, $3.header);
			// FIXME: error message for this and implements
			m.name = $3.header.name;
			m.loc = $3.header.loc;
			m.modifiers = nil();
			$$ = m;
		}

maybe_method:
          /* */
        | KW_METHOD

variant_options:
          variant_option                    	{ $$ = cons($1, nil()); }
        | variant_option '|' variant_options    { $$ = cons($1, $3); }

variant_option:
        located_id maybe_record
		{
			Variant_option o = new Variant_option();
			o.decls = $2;
			o.loc = $1.loc;
			o.name = $1.name;
			$$ = o;
		}

typarms:
          /* */
	  	{
			$$ = new Typarms(nil(), nil());
		}
        | '(' tyvars ')' maybe_where
		{
			$$ = new Typarms($2, $4);
		}

tyvars:
          tyvar                       { $$ = cons($1, nil()); }
        | tyvar ',' tyvars            { $$ = cons($1, $3); }

maybe_where:
          /* */                         { $$ = nil(); }
        | KW_WHERE where_constraints    { $$ = $2; }

maybe_bar:
          /* */
        | '|'

where_constraints:
          where_constraint                              { $$ = cons($1, nil()); }
        | where_constraint ',' where_constraints        { $$ = cons($1, $3); }

where_constraint:
        TYVAR COLON_MORE ty
		{
			$$ = new Constraint($1, $3);
		}

tyvar:
        TYVAR

type_members:
          /* */                              { $$ = nil(); }
        | type_member type_members           { $$ = cons($1, $2); }

attrs:
          /* */                              { $$ = nil(); }
        | attr attrs                         { $$ = cons($1, $2); }

attr:
          KW_NEW          { $$ = new Modifier.Mod_new(); }
        | KW_PUBLIC       { $$ = new Modifier.Mod_public(); }
        | KW_PROTECTED    { $$ = new Modifier.Mod_protected(); }
        | KW_INTERNAL     { $$ = new Modifier.Mod_internal(); }
        | KW_PRIVATE      { $$ = new Modifier.Mod_private(); }
        | KW_ABSTRACT     { $$ = new Modifier.Mod_abstract(); }
        | KW_SEALED       { $$ = new Modifier.Mod_sealed(); }


maybe_record:
          /* */		{ $$ = nil(); }
        | record

record:
        '{' record_members '}'		{ $$ = $2; }

record_members:
          /* */                              { $$ = nil(); }
        | record_member record_members       { $$ = cons($1, $2); }

record_member:
        attrs maybe_ref located_id ':' ty ';'
	  	{
			$$ = new Class_member.M_field($5, $2);
			fixup_decl($$, $1, $3);
		}

type_member:
          attrs KW_FIELD maybe_ref located_id ':' ty ';'
	  	{
			$$ = new Class_member.M_field($6, $3);
			fixup_decl($$, $1, $4);
		}
        | attrs KW_VALUE maybe_ref located_id ':' ty ';'
	  	{
			$$ = new Class_member.M_value($6, $3);
			fixup_decl($$, $1, $4);
		}
        | attrs KW_METHOD fun_def
	  	{
			$$ = $3;
			$3.modifiers = $1;
		}
        | attrs KW_FUN fun_def
		{
			$3.modifiers = $1;
			if ($3.fun_kind is Fun_kind.FK_ctor)
				$3.fun_kind = new Fun_kind.FK_static_ctor();
			else if ($3.fun_kind is Fun_kind.FK_method) {
				if (!(((Fun_kind.FK_method)$3.fun_kind).f_implements is list.Nil))
					Message.error($3.loc, "functions cannot implement anything");
				$3.fun_kind = new Fun_kind.FK_function();
			}
			$$ = $3;
		}
        | type_decl
		{
			Type_decl td = $1;
			Class_member.M_type t = new Class_member.M_type(td);
			t.modifiers = td.modifiers;
			t.name = td.name;
			t.loc = td.loc;
			$$ = t;
		}

fun_def_head:
          typarms located_id '(' fun_parms ')' ':' ty maybe_method_implements
	  	{
			Fun_header h = new Fun_header();
			
			h.typarms = $1;
			h.loc = $2.loc;
			h.name = $2.name;
			h.parms = $4;
			h.ret_type = $7;

			$$ = new Fun_helper(h, false, $8);
		}
        | typarms KW_THIS '(' fun_parms ')'
		{
			Fun_header h = new Fun_header();
			
			h.typarms = $1;
			h.name = "this";
			h.parms = $4;
			h.ret_type = new Type.T_void();
			locate(h);

			$$ = new Fun_helper(h, true, nil());
		}

fun_body:
          '=' expr ';'				{ $$ = new Fun_body.FB_expr ($2); }
        | sequence				{ $$ = new Fun_body.FB_expr ($1); }
        | '=' KW_EXTERN STRING_LITERAL ';'	{ $$ = new Fun_body.FB_extern ($3); }

fun_def:
          fun_def_head fun_body
	  	{
			Fun_kind k = new Fun_kind.FK_method($1.implements);
			if ($1.is_ctor)
				k = new Fun_kind.FK_ctor();
			Class_member.M_function f = 
				new Class_member.M_function($1.header, k, $2);
			f.name = $1.header.name;
			f.loc = $1.header.loc;
			f.modifiers = nil();
			$$ = f;
		}

fun_parm:
        located_id_or_dummy ':' ty
		{
			Fun_parm p = new Fun_parm();
			
			p.name = $1.name;
			p.loc = $1.loc;
			p.ty = $3;

			$$ = p;
		}

non_empty_fun_parms:
          fun_parm                    { $$ = cons($1, nil()); }
        | fun_parm ',' fun_parms      { $$ = cons($1, $3); }

fun_parms:
          /* */                       { $$ = nil(); }
        | non_empty_fun_parms

maybe_method_implements:
          /* */           			{ $$ = nil(); }
        | KW_IMPLEMENTS implemented_methods 	{ $$ = $2; }

implemented_methods:
          qid                                   { $$ = cons($1, nil()); }
        | qid ',' implemented_methods          	{ $$ = cons($1, $3); }

maybe_ref:
          /* */         { $$ = false; }
        | KW_REF        { $$ = true; }

prim_ty:
          qid				{ $$ = new Type.T_app($1, nil(), 0); }
        | qid '(' comma_sep_types ')'	{ $$ = new Type.T_app($1, $3, 0); }
        | TYVAR				{ $$ = new Type.T_var($1); }
        | '(' ty ')'			{ $$ = $2; }
        | KW_VOID			{ $$ = new Type.T_void(); }
        | KW_REF prim_ty	{ $$ = new Type.T_ref($2); }
        | KW_OUT prim_ty	{ $$ = new Type.T_out($2); }

prod_ty_x:
          prim_ty                              { $$ = cons($1, nil()); }
        | prim_ty '*' prod_ty_x                { $$ = cons($1, $3); }

prod_ty:
        prod_ty_x	
		{
			list.Cons c = (list.Cons)$1;
			if (c.tl is list.Nil)
				$$ = c.hd;
			else
				$$ = new Type.T_prod(c);
		}

ty:
          prod_ty
        | prod_ty MINUS_MORE ty		{ $$ = new Type.T_fun($1, $3); }

prim_expr:
          raw_prim_expr			{ locate($1); $$ = $1; }
        | '(' expr ')' 			{ $$ = $2; }

expr:
          raw_expr			{ locate($1); $$ = $1; }
        | prim_expr

raw_prim_expr:
          qid			{ $$ = new Expr.E_ref($1); }
        | KW_THIS		{ $$ = new Expr.E_this(); }
        | KW_NULL		{ $$ = new Expr.E_literal(new Literal.L_null()); }
        | '(' ')'		{ $$ = new Expr.E_literal(new Literal.L_void()); }
        | STRING_LITERAL	{ $$ = new Expr.E_literal(new Literal.L_string($1)); }
        | NUMBER_LITERAL	{ $$ = new Expr.E_literal(new Literal.L_int($1)); }
        | '(' expr COLON_MORE ty ')'
		{ $$ = new Expr.E_type_conversion($2, $4); }
        | '(' expr ':' ty ')'
		{ $$ = new Expr.E_type_enforcement($2, $4); }
        | prim_expr '#' qid
		{ $$ = new Expr.E_member($1, $3); }
	| '(' comma_sep_exprs ')'
		{ $$ = new Expr.E_tuple($2); }

comma_sep_exprs:
	  expr ',' expr			{ $$ = cons($1, cons($3, nil())); }
	| expr ',' comma_sep_exprs	{ $$ = cons($1, $3); }

sequence:
          '{' '}'
	  	{ $$ = new Expr.E_sequence(nil()); locate($$); }
        | '{' expr_list maybe_semicolon '}'
		{ $$ = new Expr.E_sequence(List.rev($2)); locate($$); }

maybe_semicolon:
          /* */
        | ';'

expr_list:
          expr_list ';' expr      { $$ = cons($3, $1); }
        | expr                    { $$ = cons($1, nil()); }

raw_expr:
          prim_expr '(' parameters ')'
	  	{ $$ = new Expr.E_call($1, $3); }
        | prim_expr LESS_MINUS expr
		{ $$ = new Expr.E_assign($1, $3); }
        | KW_LET maybe_ref located_id_or_dummy '=' expr KW_IN expr %prec KW_LET
		{ $$ = new Expr.E_let($2, $3.name, $5, $7); }
        | KW_LETFUN fun_defs KW_IN expr %prec KW_LET
		{ $$ = new Expr.E_letfun($2, $4); }
        | KW_IF expr KW_THEN expr KW_ELSE expr %prec KW_LET
		{ $$ = new Expr.E_if($2, $4, $6); }
        | KW_MATCH expr KW_WITH '[' maybe_bar match_cases ']'
		{ $$ = new Expr.E_match($2, $6); }
        | KW_RAISE expr
		{ $$ = new Expr.E_raise($2); }
        | KW_TRY expr KW_WITH '(' '?' ID ':' ty ')' expr %prec KW_LET
		{ $$ = new Expr.E_try_with($2, $6, $8, $10); }
        | KW_TRY expr KW_FINALLY expr %prec KW_LET
		{ $$ = new Expr.E_try_finally($2, $4); }

        | expr OP1 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP2 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP3 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP4 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP5 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP6 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP7 expr	{ $$ = make_bin($1, $2, $3); }
        | expr '*' expr	{ $$ = make_bin($1, "*", $3); }

        | OP1 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP2 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP3 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP4 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP5 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP6 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP7 expr %prec UNARY	{ $$ = make_unary($1, $2); }

        | lambda
        | sequence

lambda_head:
          typarms KW_FUN '(' fun_parms ')' ':' ty
	  	{
			Fun_header h = new Fun_header();
			locate(h);
			h.name = tmp_name();
			h.parms = $4;
			h.ret_type = $7;
			h.typarms = $1;
			$$ = h;
		}

lambda:
          lambda_head local_fun_body %prec KW_LET
	  	{
			$$ = new Expr.E_lambda($1, $2);
		}

local_fun_body:
	  '=' expr 		%prec KW_LET
	  	{ $$ = $2; }
	| sequence		%prec KW_LET

local_fun_def:
          fun_def_head local_fun_body
	  	{ 
			if ($1.is_ctor || !($1.implements is list.Nil))
				yyerror("parse error");
			$$ = new Function_decl($1.header, $2); 
		}

non_empty_parameters:
          parameter                       { $$ = cons($1, nil()); }
        | parameter ',' parameters        { $$ = cons($1, $3); }

parameters:
          /* */                           { $$ = nil(); }
        | non_empty_parameters

parameter:
            maybe_ref expr
	    	{ $$ = new Parm($1, $2, ""); }
          | maybe_ref ID '=' expr
	    	{ $$ = new Parm($1, $4, $2); }

fun_defs:
          local_fun_def                        { $$ = cons($1, nil()); }
        | local_fun_def KW_AND fun_defs        { $$ = cons($1, $3); }

match_cases:
          match_case                        { $$ = cons($1, nil()); }
        | match_case '|' match_cases        { $$ = cons($1, $3); }

maybe_pattern:
          pattern { $$ = $1; }
        | /* */   { $$ = new Pattern.P_underscore(); locate($$); }

nl_pattern:
          qid maybe_pattern             
	  	{ $$ = new Pattern.P_cons ($1, $2); }
        | '?' '_'
		{ $$ = new Pattern.P_underscore(); }
        | '_'
		{ $$ = new Pattern.P_underscore(); }
        | '?' ID
                { $$ = new Pattern.P_variable ($2); }
        | '{' record_patterns maybe_semicolon '}'
                { $$ = new Pattern.P_record (List.rev ($2)); }
        | '(' comma_sep_patterns ')'
		{ $$ = new Pattern.P_tuple ($2); }
        | '(' pattern ')'
		{ $$ = $2; }

pattern: nl_pattern { locate($1); $$ = $1; }

comma_sep_patterns:
          pattern ',' pattern                 { $$ = cons($1, cons($3, nil())); }
        | pattern ',' comma_sep_patterns      { $$ = cons($1, $3); }

record_patterns:
          record_patterns ';' record_pattern        { $$ = cons($3, $1); }
        | record_pattern                            { $$ = cons($1, nil()); }

record_pattern:
          ID '=' pattern
             { $$ = new Tuple2($1, $3); }

match_case:
          pattern EQ_MORE expr
	  	{ $$ = new Match_case($1, $3); }

%%

}
