/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Data;
using System.Text.RegularExpressions;
using Nemerle.Collections;
using Npgsql;

using Nemerle.Compiler;

namespace Nemerle.Data {
module Npgsql {
  private connections : Hashtable <string, NpgsqlConnection>;

  public this () { connections <- Hashtable () }

  get_connection (name : string) : NpgsqlConnection
  {
    match (connections.Get (name)) {
      | Some (c) => c
      | None =>
        Message.fatal_error ("connection `" + name + "' was not found")
    }
  }
  
  type_representant (t : Typedtree.Type) : DbType * object
  {
    match (t) {
      | Typedtree.T_app (tc, []) =>
        match (tc.GetFullName ()) {
          | "System.String" | "Nemerle.Core.string" =>
            (DbType.String, ("string parameter" : object))
          | "System.Int32" =>
            (DbType.Int32, 234)
          | x =>
            Message.fatal_error (x + " type not supported")
        }
      | _ =>
        Message.fatal_error ("only basic types supported in sql query")
    }
  }

  /** Extracts parameters after $, type expressions containing variables with
      names of those parameters.

      Returns:
       - final SQL provider secific query
       - collection of name and typed expression containing variable with this
         name
   */
  extract_parameters (ctx : Tyexpr.CTX, query : string)
  : string * Hashtable <string, Typedtree.Expr>
  {
    // take names after $
    def namesreg = Regex (@"(([^\$]*)\$(\w+))|(.+)", RegexOptions.Singleline);
    mutable m <- namesreg.Match (query);
    def fquery = System.Text.StringBuilder (query);
    def pars = Hashtable ();

    // extract names and prefix them with Npgsql parameter delimiter `:'
    while (m.Success) {
      when (m.Groups[1].Success) {
        pars.Set (m.Groups[3].ToString (), null);
        fquery[m.Groups[3].Index - 1] <- ':';
      };
      m <- m.NextMatch ();
    };

    // initializers of sql command parameters
    def tpars = Hashtable ();    
    pars.Iter (fun (x, _) {
      def varname = Macros.UseSiteSymbol (x);
      def tvar = Tyexpr.ty_expr (ctx, <[ $(varname : var) ]>);
      tpars.Set (x, tvar);
    });
    (fquery.ToString (), tpars)
  }

  
  macro CreateCompileTimeConnection (con_str : string, name : string = "")
  {
    if (connections.Contains (name))
      Message.fatal_error ("Connection with name `" + name + "' is already defined")
    else {
      def connection = NpgsqlConnection (con_str);
      connection.Open ();
      connections.Add (name, connection)
    };
    <[ () ]>
  }

  macro ExecuteNonQuery (query : string, conn, con_name : string = "")
  {
    def (query, tpars) = extract_parameters (_N_ctx, query);
    mutable pars_init <- [];

    // create compile-time query to check syntax and types in query
    def mycmd = NpgsqlCommand ("BEGIN TRANSACTION; " + query + "; ROLLBACK;",
                               get_connection (con_name));
    
    tpars.Iter (fun (name, tvar : Typedtree.Expr) {
      def (dbtype, dbvalue) = type_representant (tvar.expr_ty);
      mycmd.Parameters.Add (name, dbtype).Value <- dbvalue;
      
      /// add parameter initializer
      pars_init <- <[ ignore (querycmd.Parameters.Add ($(name : string), 
                                                       $(tvar : typed))) ]> 
                   :: pars_init;
    });
    // try to execute query chcecking its syntax and typecorrectness
    try
      ignore (mycmd.ExecuteNonQuery ())
    catch {
      | e : NpgsqlException =>
        Message.fatal_error ("sql query error: " + e.Message)
    };
    
    <[
      def querycmd = NpgsqlCommand ($(query : string), $conn);
      { .. $pars_init };
      def result = querycmd.ExecuteNonQuery ();
      querycmd.Dispose ();
      result
    ]>
  }
  
  macro SqlLoop (query : string, conn, body)
  {
    def (query, tpars) = extract_parameters (_N_ctx, query);

    /// expressions initializing [querycmd.Parameters] with their values
    mutable pars_init <- [];

    // create compile-time query to check syntax and types in query
    def mycmd = NpgsqlCommand (query, get_connection (""));
    tpars.Iter (fun (name, tvar : Typedtree.Expr) {
      def (dbtype, dbvalue) = type_representant (tvar.expr_ty);
      mycmd.Parameters.Add (name, dbtype).Value <- dbvalue;

      /// add parameter initializer
      pars_init <- <[ ignore (querycmd.Parameters.Add ($(name : string), 
                                                       $(tvar : typed))) ]> 
                   :: pars_init;
    });

    // list of definitions of query results inside loop body
    mutable bodyseq <- [body];
    try {
      // try to execute query chcecking its syntax and aquiring names of columns
      def myreader = mycmd.ExecuteReader(CommandBehavior.SchemaOnly);
      def table = myreader.GetSchemaTable ();
      foreach(myRow : DataRow in table.Rows){
        def col = myRow["ColumnName"].ToString ();
        def col_type = Macros.UseSiteSymbol (myRow["DataType"].ToString ());
        def col_name = Macros.UseSiteSymbol (col);
        bodyseq <- <[ def $(col_name : var) = (reader[$(col : string)] 
                                              :> $(col_type : var)) ]> :: bodyseq;
      }
    }
    catch {
      | e : NpgsqlException =>
        Message.fatal_error ("sql query error: " + e.Message)
    };

    /// final code for entire sql loop
    <[
      def querycmd = NpgsqlCommand ($(query : string), $conn);
      { .. $pars_init };
      def reader = querycmd.ExecuteReader ();
      while (reader.Read ()) { ..$bodyseq };
      reader.Close ();
      querycmd.Dispose ();
    ]>
  }

}
}
