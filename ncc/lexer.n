(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

//open System;
//open System.IO;

open System.Text;
open Nemerle.Collections;

namespace Nemerle.Compiler {

variant Token {
  | Tok_identifier { name : string; }
  | Tok_keyword { name : string; }
  | Tok_tyvar { name : string; }
  | Tok_operator { name : string; priority : int; }

  | Tok_string_literal { value : string; }
  | Tok_number_literal { value : int; }
  | Tok_char_literal { value : int; }

  | Tok_EOF
}

interface ILexer {
  get_token () : Token;
  get_location () : Location;
}

class Lexer implements ILexer
{
  file : System.IO.FileStream;
  file_name : string;
  mutable line : int;
  mutable col : int;
  mutable putback : bool;
  mutable putbackVal : char;
  
  mutable last_line : int;
  mutable last_col : int;
  
  static mutable keywords : Hashtable (string, bool);

  class Error extends System.Exception {
    public name : string;
    public this (name : string) { this.name <- name; }
  }

  public this (fn : string)
    {
      this.file_name <- fn;
      this.file <- System.IO.FileStream (fn, System.IO.FileMode.Open);
      this.line <- 1;
      this.col <- 1;
      this.putback <- false;
    }

  do_read () : char
    {
      def inp = this.file.ReadByte ();
      if (inp >= 0) {
        def ch = System.Convert.ToChar (inp);
        if (ch == '\n') {
          this.line <- this.line + 1;
          this.col <- 1;
        } 
        else
          this.col <- this.col + 1;
        ch
      }
      else 
        raise Error ("unexpected end of file")
    }
        
  read () : char
    {
      if (!this.putback)
        this.do_read()
      else {
        def c = this.putbackVal;
        this.putback <- false;
        c
      }
    }

  peek() : char
    {
      if (!this.putback)
        this.putbackVal <- this.do_read()
      else ();
      this.putback <- true;
      this.putbackVal
    }

  is_id_beg(ch : char) : bool
    {
      System.Char.IsLetter (ch) || ch == '_'
    }

  is_opchar(ch : char) : bool
    {
      match (ch) {
        | '=' | '<' | '>' | '@' | '^' | '|' | '&' | '+'
        | '-' | '*' | '/' | '$' | '%' | '!' | '?' | '~'
        | '.' | ':' | '#' | '[' | ']' => true
        | _ => false
      }
    }

  skip_comment () : void
    {
      mutable ch <- ' ';
      mutable seen_star <- false;

      while ({ch <- this.read(); !seen_star || ch != ')'}) {
        if (ch == '*')
          seen_star <- true
        else
          seen_star <- false
      }
    }

  get_op (priority : int, first_ch : char) : Token
    {
      def buf = System.Text.StringBuilder();
      
      ignore (buf.Append (first_ch));

      while (this.is_opchar (this.peek ())) { 
        ignore (buf.Append (this.read ()))
      };

      def s = buf.ToString ();
      match (s) {
        | "<-" => 
          // force low priority
          Tok_operator ("<-", 9)

        | "|" | ":" | ":>" | "=>" =>
          // cannot use this as regular operator
          Tok_operator (s, 0)
          
        | _ => 
          Tok_operator (s, priority)
      }
    }

  get_number (first_ch : char) : Token
    {
      def buf = System.Text.StringBuilder();
      
      ignore (buf.Append (first_ch));

      while (System.Char.IsDigit (this.peek ())) {
        ignore (buf.Append (this.read ()))
      };

      Tok_number_literal (System.Int32.Parse (buf.ToString ()))
    }

  get_id (first_ch : char) : Token
    {
      if (first_ch == '\'' && !this.is_id_beg (this.peek ())) {
        this.get_char()
      } 
      else {
        def buf = System.Text.StringBuilder();
        when (first_ch != '\'') {
          ignore (buf.Append (first_ch))
        };

        while (this.is_id_beg (this.peek ()) || 
               System.Char.IsDigit (this.peek ()) || 
               this.peek() == '\'') {
          ignore (buf.Append (this.read ()))
        };
            
        def str = buf.ToString ();
        
        if (first_ch == '\'' && str.Length == 2 && str[1] == '\'')
          Tok_char_literal (System.Convert.ToInt32 (str[0]))
        else if (first_ch == '\'')
          Tok_tyvar (str)
        else if (keywords.Contains (str))
          Tok_keyword (str)
        else
          Tok_identifier (str)
      }
    }

  escape_value (ch : char) : char
    {
      match (ch) {
        | 'n' => '\n'
        | 't' => '\t'
        | 'r' => '\r'
        | 'b' => '\b'
        | '"' => '"'
        | '\'' => '\''
        | '\\' => '\\'
        | _ => raise Error ("bad escape character")
      }
    }
    
  get_char () : Token
    {
      match (this.get_string('\'')) {
        | Tok_string_literal (v) =>
          if (v.Length == 0)
            raise Error ("empty character literal")
          else {
            if (v.Length != 1)
              raise Error ("character literal too long")
            else
              Tok_char_literal (System.Convert.ToInt32 (v[0]))
          }
        | _ => Util.ice ("Value is not string in get_char")
      }
    }

  get_string(end_ch : char) : Token
    {
      def buf = StringBuilder();
      mutable ch <- ' ';
                
      while (ch != end_ch) {
        ch <- this.read();
        match (ch) {
          | '\\' =>
            ch <- this.read();
            def esc = this.escape_value(ch);
            ignore (buf.Append (esc));
            ch <- ' ';
          | '\n' =>
            raise Error ("newline before end of string")
          | n =>
            when (ch != end_ch) {
              ignore (buf.Append(ch))
            }
        }
      };
       
      Tok_string_literal (buf.ToString ())
    }

  get_quoted_op () : Token
    {
      match (this.get_op (0, this.read ())) {
        | Tok_operator (n, _) => 
          if (this.peek () != '`') {
            def _ = this.read();
            raise Error ("invalid character in quoted op")
          } else {
            def _ = this.read();
            Tok_identifier (n)
          }
        | _ => Util.ice ()
      }
    }

  get_double_quoted_id () : Token
    {
      mutable buf <- StringBuilder();
      mutable ch <- ' ';

      while (ch != '`') {
        ch <- this.read();
            
        match (ch) {
          | '`' =>
            if (this.read() != '`')
              raise Error ("invalid character in double quoted id")
            else {
              if (ch != '`') buf <- buf.Append (ch)
              else ();
            }
          | '\n' =>
            raise Error ("newline in double quoted id")
          | _ =>
            raise Error ("EOF in double quoted id")
        }
      };
        
      Tok_identifier (buf.ToString ())
    }
                
  get_quoted_id () : Token
    {
      mutable buf <- StringBuilder ();
      mutable ch <- ' ';
                
      while (ch != '`') {
        ch <- this.read();

        match (ch) {
          | '`' =>
            if (ch != '`')
              buf <- buf.Append ((ch : char))
            else ();
          | '\n' =>
            raise Error ("newline in infix id")
          | _ =>
            raise Error ("EOF in infix id")
        };
      };

      Tok_operator (buf.ToString (), 4)
    }

  do_get_token (ch : char) : Token {
    match (ch) {
      | ' ' | '\t' | '\r' | '\n' => this.get_token()
      
      | '"' => this.get_string('"')

      | '`' =>
        if (this.peek () == '`') {
          def _ = this.read();
          this.get_double_quoted_id()
        }
        else if (this.is_opchar (this.peek ())) {
          this.get_quoted_op()
        } else this.get_quoted_id()

      | '\'' => this.get_id('\'')

      | '(' =>
        if (this.peek () == '*') {
          def _ = this.read();
          this.skip_comment();
          this.get_token()
        } else Tok_operator ("(", 0)

      | '{' | '}' 
      | '[' | ']' 
      | ',' | ';' 
      | '.' | ')' => Tok_operator (System.String (ch, 1), 0)
      
      | '*' =>
        if (this.peek () == '*')
          this.get_op(1, ch)
        else
          this.get_op(2, ch)

      | '/' =>
        if (this.peek () == '/') {
          def skip () { if (this.read () == '\n') () else skip () };
          skip ();
          this.get_token()
        } else
          this.get_op(2, ch)
                              
      | '%' | '\\'
        => this.get_op(2, ch)
      
      | '+' | '-' 
        => this.get_op(3, ch)
      
      | '@' | '^' | '$' | '~' | '?' | '#'
        => this.get_op(4, ch)
        
      | '=' | '<' | '>' | '!' 
        => this.get_op(5, ch)
        
      | '&' => this.get_op(6, ch)
      | '|' => this.get_op(7, ch)
      | ':' => this.get_op(8, ch)

      | n =>
        if (System.Char.IsDigit (ch))
          this.get_number (ch)
        else
          if (this.is_id_beg (ch))
            this.get_id (ch)
          else
            raise Error ("invalid character")
    }      
  }

  get_token () : Token
    implements ILexer.get_token
    {
      this.last_line <- this.line;
      this.last_col <- this.col;
      
      def ch = try Some (this.read()) with x : Error => None ();
     
      def ret =
        match (ch) {
          | Some (c) => this.do_get_token (c)
          | None => Tok_EOF ()
        };

      //Message.debug (Parser.token_name (ret));

      ret
    }

  get_location () : Location
    implements ILexer.get_location
    {
      Location(this.file_name, this.last_line, this.last_col)
    }

  get_current_location () : Location
    {
      Location(this.file_name, this.line, this.col)
    }

  public static this () {
    def tab = mkarray [
        "_"; "abstract"; "and"; "array"; "as"; "base"; "class"; "const";
        "def"; "else"; "enum"; "extends"; "extern"; "finally"; "for";
        "fun"; "if"; "implements"; "in"; "interface"; "internal"; "let";
        "macro"; "match"; "mkarray"; "module"; "mutable"; "namespace";
        "new"; "null"; "open"; "out"; "private"; "protected"; "public";
        "raise"; "ref"; "sealed"; "static"; "struct"; "then"; "this";
        "try"; "tymatch"; "type"; "typeof"; "unless"; "using"; "variant"; 
        "void"; "volatile"; "when"; "where"; "while"; "with";
    ];
    keywords <- Hashtable ();
    for (mutable i <- 0; i < (tab : System.Array).Length; i <- i + 1) {
      keywords.Add (tab[i], true)
    }
  }

} // end class Lexer
} // end ns
