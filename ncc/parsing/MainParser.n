/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  enum OpContext {
    | Prefix
    | Postfix
  }

  [System.Flags]
  enum TokenStoppers {
    | None   = 0x0000
    | Pipe   = 0x0001 // |
    | Equal  = 0x0002 // =
    | Braces = 0x0004 // {}
    | Arrow  = 0x0008 // =>
    | Colon  = 0x0010 // :
    | Dollar = 0x0020 // $
    | All = Pipe %| Equal %| Braces %| Arrow
  }
  
  public variant GrammarElement {
    | Operator { name : string; }
    | Keyword { name : string; }
    | Expression
    | Parameter
    | ExpressionList
    | Optional { body : GrammarElement; }
  }
  
  [Record]
  public class SyntaxDefinition {
    public Start : string;
    public Keywords : list [string];
    public MacroNamespace : GlobalEnv.NamespaceND;
    public Rules : list [GrammarElement];
    public Permute : list [SyntaxElement] -> list [SyntaxElement];
  }
  
  public class MainParser
  {
    /// Reverse Polish Notation token. It is used on the stack created during translation
    /// of infix operator expression into RPN on the way to create appropriate PExpr.
    [Record]
    class OperatorInfo {
      public Name : string;
      public LeftPriority : int;
      public RightPriority : int;

      public static RoundInfo : OperatorInfo = OperatorInfo ("(", 290,291);
      public static SquareInfo : OperatorInfo = OperatorInfo ("[", 290, 291);
      public static ProductInfo : OperatorInfo = OperatorInfo ("*", 260, 261);    

      public static PrefixInfos : Hashtable [string, OperatorInfo];    
      public static Infos : Hashtable [string, OperatorInfo];

      static this () {
        PrefixInfos = Hashtable ();
        PrefixInfos.Add ("-", UnaryOperatorInfo ("-", 281, 280));
        PrefixInfos.Add ("+", UnaryOperatorInfo ("+", 281, 280));      
        PrefixInfos.Add ("++", UnaryOperatorInfo ("++", 281, 280));
        PrefixInfos.Add ("--", UnaryOperatorInfo ("--", 281, 280));
        PrefixInfos.Add ("!", UnaryOperatorInfo ("!", 281, 280));
        PrefixInfos.Add ("~", UnaryOperatorInfo ("~", 281, 280));      

        Infos = Hashtable ();
        Infos.Add (".", BinaryOperatorInfo (".", 285, 301));
        Infos.Add ("++", UnaryOperatorInfo ("++", 283, 284));
        Infos.Add ("--", UnaryOperatorInfo ("--", 283, 284));            
        Infos.Add ("/", BinaryOperatorInfo ("/", 260, 261));
        Infos.Add ("%", BinaryOperatorInfo ("%", 260, 261));
        Infos.Add ("->", BinaryOperatorInfo ("->", 250, 251));      
        Infos.Add (":", BinaryOperatorInfo (":", 245, 246));
        Infos.Add (":>", BinaryOperatorInfo (":>", 245, 246));
        Infos.Add ("+", BinaryOperatorInfo ("+", 240, 241));
        Infos.Add ("-", BinaryOperatorInfo ("-", 240, 241));
        Infos.Add ("<<", BinaryOperatorInfo ("<<", 230, 231));
        Infos.Add (">>", BinaryOperatorInfo (">>", 230, 231));
        Infos.Add ("::", BinaryOperatorInfo ("::", 221, 220));
        Infos.Add ("as", BinaryOperatorInfo ("as", 215, 301));            
        Infos.Add ("<", BinaryOperatorInfo ("<", 210, 211));
        Infos.Add (">", BinaryOperatorInfo (">", 210, 211));
        Infos.Add ("<=", BinaryOperatorInfo ("<=", 210, 211));
        Infos.Add (">=", BinaryOperatorInfo (">=", 210, 211));
        Infos.Add ("is", BinaryOperatorInfo ("is", 210, 211));
        Infos.Add ("matches", BinaryOperatorInfo ("matches", 210, 211));
        // FIXME: confront to C sharp
        Infos.Add ("&", BinaryOperatorInfo ("&", 190, 191));
        Infos.Add ("%&", BinaryOperatorInfo ("%&", 190, 191));
        Infos.Add ("%&&", BinaryOperatorInfo ("%&&", 190, 191));
        Infos.Add ("^", BinaryOperatorInfo ("^", 180, 181));
        Infos.Add ("%^", BinaryOperatorInfo ("%^", 180, 181));
        Infos.Add ("|", BinaryOperatorInfo ("|", 170, 171));
        Infos.Add ("%|", BinaryOperatorInfo ("%|", 170, 171));
        Infos.Add ("==", BinaryOperatorInfo ("==", 165, 166));
        Infos.Add ("!=", BinaryOperatorInfo ("!=", 165, 166));
        Infos.Add ("&&", BinaryOperatorInfo ("&&", 160, 161));
        Infos.Add ("||", BinaryOperatorInfo ("||", 150, 151));
        Infos.Add ("=", BinaryOperatorInfo ("=", 141, 140));
        Infos.Add ("*=", BinaryOperatorInfo ("*=", 141, 140));
        Infos.Add ("/=", BinaryOperatorInfo ("/=", 141, 140));
        Infos.Add ("%=", BinaryOperatorInfo ("%=", 141, 140));
        Infos.Add ("+=", BinaryOperatorInfo ("+=", 141, 140));      
        Infos.Add ("-=", BinaryOperatorInfo ("-=", 141, 140));
        Infos.Add ("<<=", BinaryOperatorInfo ("<<=", 141, 140));
        Infos.Add (">>=", BinaryOperatorInfo (">>=", 141, 140));
        Infos.Add ("&=", BinaryOperatorInfo ("&=", 141, 140));
        Infos.Add ("^=", BinaryOperatorInfo ("^=", 141, 140));
        Infos.Add ("|=", BinaryOperatorInfo ("|=", 141, 140));      
        Infos.Add ("when", BinaryOperatorInfo ("when", 130, 131));
      }

      public static GetOrCreate (op : string) : OperatorInfo {
        match (Infos.Get (op)) {
          | Some (x) => x
          | None =>
            def newinfo = BinaryOperatorInfo (op, 200, 201);
            Infos.Add (op, newinfo);
            newinfo
        }
      }
    }

    class UnaryOperatorInfo : OperatorInfo {
      public this (name : string, left : int, right : int) {
        base (name, left, right);
      }
    }

    class BinaryOperatorInfo : OperatorInfo {
      public this (name : string, left : int, right : int) {
        base (name, left, right);
      }
    }

    class NaryOperatorInfo : OperatorInfo {
      public this (copy : OperatorInfo) {
        base (copy.Name, copy.LeftPriority, copy.RightPriority);
      }

      public mutable ExprsBegin : list [PExpr];
    }

    
    mutable env : GlobalEnv;
    mutable stream : Token;
    mutable last_tok : Token;
    mutable syntax_keywords : SystemMap [string, SyntaxDefinition];

    mutable streams_stack : array [Token] = array (200);
    mutable stack_pos : int = 0;

    public this (env : GlobalEnv) {
      this.env = env;
      syntax_keywords = SystemMap ();
      def core_extensions = MacroRegistry.GetSyntaxExtensions (["Nemerle", "Core"]);
      syntax_keywords = load_syntax (core_extensions);
    }

    public static ParseExpr (env : GlobalEnv, expr : string) : PExpr
    {
      def lexer = LexerString (expr, Location_stack.top ());
      def preparser = PreParser (lexer);
      def tokens = preparser.PreParse ();      
      def parser = MainParser (env);
      parser.push_stream (tokens);
      parser.parse_embedded_expr (TokenStoppers.None);
    }

    public static Parse (lex : LexerBase) : list [TopDeclaration]
    {
      def preparser = PreParser (lex);
      def parser = MainParser (GlobalEnv.Core);
      
      mutable result = [];
      foreach (tok : Token in preparser.ParseTopLevel ()) 
        result = parser.ParseTopLevel (tok, result);
        
      List.Rev (result);
    }
    
    #region Utility functions operating on current token stream
    push_stream (newstream : Token) : void {
      streams_stack [stack_pos] = stream;
      ++stack_pos;
      stream = newstream;
    }

    pop_stream () : void {
      --stack_pos;
      if (stack_pos > 0)
        // previous stack was stored before incrementing pointer
        stream = streams_stack [stack_pos];
      else
        stream = null;
    }

    pop_stream (finish_entity : string) : void {
      expect_empty (finish_entity);
      pop_stream ();
    }

    get_token () : Token {
      if (stream != null) {
        last_tok = stream;
        stream = stream.Next;
        last_tok
      }
      else {
        Error (last_tok, "unexpected end of token sequence");
        Token.EndOfGroup (last_tok.Location)
      }
    } 

    peek_token () : Token {
      if (stream != null) stream
      else Token.EndOfGroup (last_tok.Location)
    }

    peek_second_token () : Token {
      if (stream != null)
        if (stream.Next != null) stream.Next
        else Token.EndOfGroup (stream.Location)
      else Token.EndOfGroup (last_tok.Location)
    }

    peek_sibling_token () : Token {
      if (stream != null) stream
      else {
        def next_group = streams_stack [stack_pos - 1].Next;
        if (next_group != null)
          (next_group :> Token.LooseGroup).Child
        else
          Token.EndOfGroup (last_tok.Location)
      }
    }

    jump_to_sibling () : void {
      if (stream == null) {
        streams_stack [stack_pos - 1] = streams_stack [stack_pos - 1].Next;
        def parent = streams_stack [stack_pos - 1] :> Token.LooseGroup;
        if (parent == null)
          Error (last_tok, "unexpected end of token sequence")
        else
          stream = parent.Child;
      }
      else
        Util.ice ("cannot jump to sibling, some tokens are still here")
    }
    
    shift_sibling () : void {
      if (stream == null) {
        jump_to_sibling ();
        shift ()
      }
      else
        shift ();
    }

    new_group_beginning () : void {
      when (stream != null) {
        def newgroup = Token.LooseGroup (stream);
        newgroup.Next = streams_stack [stack_pos - 1];
        streams_stack [stack_pos - 1] = newgroup;
        stream = null;
      }
    }
    
    push_back () : void {
      stream = last_tok;
      last_tok = null;
    }
    
    shift () : void {
      if (stream != null) {
        last_tok = stream;
        stream = stream.Next;
      }
      else Error (last_tok, "unexpected end of token sequence");
    }
    
    expect_empty (msg : string) : void {
      when (stream != null)
        Message.error (stream.Location, "unexpected tokens after " + msg)
    }

    expect_operator (op : string) : void {
      match (get_token ()) {
        | Token.Operator (o, _) when op == o => ()
        | Token.Operator (o, _) =>
          match (peek_token ()) {
            | Token.Operator (o', _) when op == o + o' => shift (); ()
            | x => Error (x, "expecting operator `" + op + "'");
          }
        | x => Error (x, "expecting operator `" + op + "'");
      }
    }

    expect_keyword (op : string) : void {
      match (get_token ()) {
        | Token.Keyword (o) when op == o => ()
        | x =>
          Error (x, "expecting keyword `" + op + "'");
      }
    }
    
    flag_keyword (kw : string) : bool {
      match (peek_token ()) {
        | Token.Keyword (n) when n == kw => shift (); true
        | _ => false
      }
    }

    flag_sibling_keyword (kw : string) : bool {
      match (peek_sibling_token ()) {
        | Token.Keyword (k) when kw == k => shift_sibling (); true
        | _ => false
      }
    }

    should_stop (stop : TokenStoppers) : bool {
      if (stream == null) true
      else {
        match (stream) {
          | Token.LooseGroup (Token.Operator (str, _))
          | Token.Operator (str, _) =>
            match (str) {
              | "|" when stop %&& TokenStoppers.Pipe 
              | "=" when stop %&& TokenStoppers.Equal 
              | "=>" when stop %&& TokenStoppers.Arrow
              | "$" when stop %&& TokenStoppers.Dollar
              | ":" when stop %&& TokenStoppers.Colon => true
              | _ => false
            }
          | _ => false
        }
      }
    }

    comma_separated_list ['a] (f : void -> 'a) : list ['a] {
      def loop (acc) {
        match (peek_token ()) {
          | Token.Comma => shift (); loop (f () :: acc)
          | _ => List.Rev (acc)
        }
      };
      loop ([f ()])
    }

    process_groups ['a] (first : Token, name : string, f : void -> 'a) : list ['a] {
      push_stream (first);
      mutable members = [];
      while (stream != null) {
        def child = f ();
        when (child != null) members = child :: members;
      }
      pop_stream (name);
      List.Rev (members)
    }
    #endregion Utility functions operating on current token stream

    Error (tok : Token, msg : string) : void {
      Message.error (tok.Location, "parse error near " + tok.ToString (true) + ": " + msg)
    }
    
    TokenMap ['a] (tokens : Token, f : void -> 'a) : list ['a] {
      mutable result = [];
      foreach (tok : Token.LooseGroup in tokens) {
        push_stream (tok.Child);
        result = f () :: result;
        pop_stream ("group of tokens");
      }
      List.Rev (result);
    }
    
    get_splicable_id () : Splicable {
      assert (env != null);
      def tok = get_token ();
      def loc = tok.Location;
      match (tok) {
        | Token.Identifier (n) => Splicable.Name (loc, Name.NameInCurrentColor (n, env))
          
        | Token.Operator ("$", _) =>
          def second = get_token ();
          match (second) {
            | Token.Identifier (id)  =>
              Splicable.Expression (loc + second.Location,
                                    PExpr.Ref (second.Location, Name.NameInCurrentColor (id, env)))

            | Token.RoundGroup (group) =>
              def loc = loc + second.Location;
              // FIXME: use stopper
              push_stream (group);
              def expr =
                match (parse_expr_sequence (TokenStoppers.Colon)) {
                  | [x] => x
                  | _ =>
                    Message.error (loc, "only single element in `$(...)' is allowed");
                    <[ () ]>
                }
              def result = 
              match (peek_token ()) {
                | Token.LooseGroup (Token.Operator (":", _) as colon) =>
                  shift ();
                  push_stream (colon.Next);
                  def tok = get_token ();
                  pop_stream ("spliced expression");
                  match (tok) {
                    | Token.Identifier (ty) =>
                      Splicable.Expression (PExpr.Spliced (loc,
                        PExpr.TypeEnforcement (loc, expr, PExpr.Ref (loc, Name (ty)))))
                        
                    | x => Error (x, "expecting identifier specifying splicing type");
                      Splicable.Expression (<[ () ]>)
                  }

                | Token.EndOfGroup => Splicable.Expression (loc, expr)
                | x => Error (x, "expecting end of spliced expression"); Splicable.Expression (<[ () ]>)
              }
              pop_stream ("spliced expression");
              result

            | Token.Keyword ("_") =>
              Splicable.Expression (loc + second.Location, PExpr.Wildcard (second.Location))

            | _ =>
              Error (second, "expecting expression after `$' operator");
              Splicable.Name (Name (["error"]))
          }
              
        | Token.Keyword ("_") =>
          Splicable.Name (loc, Name.NameInCurrentColor (Util.tmpname ("u"), env))
          
        | _ =>
          Error (tok, "expecting identifier");
          Splicable.Name (Name (["error"]))
      }
    }


    load_syntax (extensions : list [SyntaxDefinition]) : SystemMap [string, SyntaxDefinition]
    {
      mutable keywords = syntax_keywords;
      foreach (definition in extensions)
        keywords = keywords.Replace (definition.Start, definition);
      keywords
    }
    
   
    /** This function parses top level group updating global environment
        when entering into new namespace, using directive, class, etc.
     */
    ParseTopLevel (tok : Token, mutable acc : list [TopDeclaration]) : list [TopDeclaration]
    {
      match (tok) {
        | Token.LooseGroup (tokens) =>
          match (tokens) {
            | Token.Namespace (name, extensions, _) =>
              def begin_syntax = syntax_keywords;
              def begin_env = env;

              // update current environment
              env = env.EnterIntoNamespace (name);
              syntax_keywords = load_syntax (extensions);

              // parse elements of namespace with new environment enabled
              foreach (child : Token in tokens)
                acc = ParseTopLevel (child, acc);

              // bring env from outside of namespace
              env = begin_env;
              syntax_keywords = begin_syntax;
              acc

            | Token.Using (name, extensions) =>
              syntax_keywords = load_syntax (extensions);          
              env = env.AddOpenNamespace (name, tok.Location);
              acc

            | Token.UsingAlias (name, fullname) =>
              match (name) {
                | [name] => env = env.AddNamespaceAlias (name, fullname, tok.Location);
                | _ => Error (tok, "using alias must be simple name without dots")
              }
              acc

            | Token.SquareGroup (null) => Error (tok, "empty custom attribute"); acc

            // assembly attribute
            | Token.SquareGroup (inner) as square =>
              match (inner) {
                | Token.LooseGroup (Token.Identifier ("assembly")) =>
                  mutable assembly_custom = [square];
                  def customs = take_attributes_out (ref assembly_custom,
                                                     System.AttributeTargets.Assembly, true);

                  foreach (cust in customs)
                    AttributeCompiler.AddAssemblyAttribute (env, cust);

                  // executed only in case of [assembly: .. ] [ .. ]
                  if (square.Next != null)
                    ParseTopLevel (Token.LooseGroup (square.Next.Location, square.Next), acc)
                  else
                    acc

                | _ => ParseTypeDeclaration (tokens) :: acc
              }
            | _ => ParseTypeDeclaration (tokens) :: acc
          }

        | x => Error (x, "expecting group of tokens"); acc
      }
    }

    /** Parses toplevel type (like class, interface, etc.).
        Expects [toks] to be first token in type declaration.
     */
    ParseTypeDeclaration (toks : Token) : TopDeclaration
    {
      push_stream (toks);
      mutable customs_token = get_customs ();
      def customs = take_attributes_out (ref customs_token, System.AttributeTargets.Class, true);      
      def mods = Modifiers (get_modifiers (), customs);
      def result = ParseTypeDeclaration (mods);
      pop_stream ("type declaration");

      result;
    }

    /** Parses toplevel type (like class, interface, etc.).
        We are inside stream with modifiers and custom attributes already read.
     */
    ParseTypeDeclaration (mods : Modifiers) : TopDeclaration
    {
      def tok = get_token ();
      def res =
        match (tok) {
          | Token.Keyword (key) =>
            match (key) {
              | "type" | "class" | "struct" | "module" | "interface" | "enum"
              | "variant" =>
                /// first get name of this declartion
                def name = get_splicable_id ();
                // now generic type parameters
                def tyvars = parse_tyvars ();                  
                def t_extends =
                  match (peek_token ()) {
                    | Token.Operator (":", _) =>
                      shift ();
                      match (maybe_parse_ellipsis ()) {
                        | Some (e) => [e]
                        | _ =>
                          // parse , separated sequence as one expression
                          comma_separated_list (fun () { parse_expr (TokenStoppers.All) });
                      }
                    | _ => []
                  };
                // where constraints for specified generic type parameters
                def typarms = parse_where_constraints (tyvars);

                mutable members = null;
                unless (key == "type")
                  match (get_token ()) {
                    | Token.BracesGroup (children) =>
                      members = process_groups (children, "type member", ParseClassMember)
                        
                    | x => Error (x, "expecting type body");
                  }

                def td =
                  match (key) {
                    | "class" => TopDeclaration.Class (typarms, t_extends, members)
                    | "struct" =>
                      mods.mods |= NemerleAttributes.Struct;
                      TopDeclaration.Class (typarms, t_extends, members)

                    | "module" =>
                      mods.mods |= NemerleAttributes.Static;
                      TopDeclaration.Class (typarms, t_extends, members)

                    | "type" =>
                      expect_operator ("=");
                      def t = parse_expr ();
                      expect_empty ("type alias declaration");
                      TopDeclaration.Alias (typarms, t)

                    | "interface" => TopDeclaration.Interface (typarms, t_extends, members)
                    | "variant" => TopDeclaration.Variant (typarms, t_extends, members)
                    | "enum" => TopDeclaration.Enum (t_extends, members)

                    | _ => Util.ice ()
                  };
                td.name = name;
                td.loc = tok.Location + name.Location;                
                td

              | "delegate" =>
                def h = parse_fun_header (null);
                def td = TopDeclaration.Delegate (h);
                expect_empty ("delegate declaraion");
                td.loc = tok.Location + h.Location;
                td.name = h.name;                
                td

              | "macro" => 
                def header = parse_fun_header (null);
                def synt = 
                  match (peek_token ()) {
                    | Token.Keyword ("syntax") =>
                      shift ();
                      match (get_token ()) {
                        | Token.RoundGroup (groups) => parse_expr_sequence (groups)
                        | t => Error (t, "expecting comma sperated list of syntax specifiers in `()'"); []
                      }
                    | _ => []
                  }
                def expr = parse_block ([]);
                def res = TopDeclaration.Macro (header, synt, expr);
                res.name = header.name;
                res.loc = tok.Location + header.Location;
                res

              | _ => Error (tok, "expecting type declaration"); TopDeclaration.Delegate (null);
            }
          | x => Error (x, "expecting type declaration"); TopDeclaration.Delegate (null);
        };
      res.modifiers = mods;
      res
    }

    
    ParseClassMember () : ClassMember
    {
      match (get_token ()) {
        | Token.LooseGroup (toks) =>
          push_stream (toks);
          mutable customs = get_customs ();
          def mods = get_modifiers ();

          def tok = peek_token ();
          def result = 
            match (tok) {
              | Token.Operator ("$", _) | Token.Identifier =>
                def id = get_splicable_id ();
                mutable is_property = false;
                def (tyvars, parms) =
                  match ((peek_token (), peek_second_token ())) {
                    | (Token.SquareGroup, Token.SquareGroup) =>
                      is_property = true;
                      (parse_tyvars (), parse_parameters ());

                    | (Token.SquareGroup, Token.RoundGroup) =>
                      (parse_tyvars (), parse_parameters ());            

                    | (Token.SquareGroup, _) =>
                      is_property = true;                      
                      ((null, null), parse_parameters ());                        

                    | (Token.RoundGroup, _) =>
                      ((null, null), parse_parameters ());

                    | _ =>
                      is_property = true; // most probably it is a field or property
                      ((null, null), [])
                  }

                def ret_type = parse_return_type (false);
                def typarms = parse_where_constraints (tyvars);

                if (is_property)
                  parse_property (mods, customs, id, ret_type, parms, typarms)
                else {
                  def header = Fun_header (tok.Location + ret_type.Location,
                                           name = id,
                                           ret_type = ret_type, 
                                           parms = parms, 
                                           typarms = typarms);
                  def mcustoms = take_attributes_out (ref customs, System.AttributeTargets.Method, true);
                  parse_method (header, Modifiers (mods, mcustoms));
                }


              | Token.Keyword ("this") =>
                shift ();
                def parms = parse_parameters ();                
                def header = Fun_header (tok.Location,
                                         name = Splicable.Name (Name ([".ctor"])),
                                         ret_type = PExpr.Void (),
                                         parms = parms,
                                         typarms = Typarms.Empty);
                def mcustoms = take_attributes_out (ref customs, System.AttributeTargets.Method, true);
                parse_method (header, Modifiers (mods, mcustoms));

              | Token.Keyword ("event") =>
                shift ();
                parse_event (tok.Location, mods, customs)

              | Token.Operator ("|", _) =>
                shift ();
                unless (customs matches []) Error (tok, "custom attributes not allowed on options");
                unless (mods == NemerleAttributes.None) Error (tok, "modifiers not allowed on options");              
                parse_option ()

              | _ =>
                def tcustoms = take_attributes_out (ref customs, System.AttributeTargets.Class, true);                
                def td = ParseTypeDeclaration (Modifiers (mods, tcustoms));
                ClassMember.TypeDeclaration (loc = td.loc, 
                                             name = td.name, 
                                             modifiers = td.modifiers, 
                                             td = td)
            }
          pop_stream ("class member");
          result
            
        | _ => null
      }
    }

    parse_property (mods : NemerleAttributes, mutable customs : list [Token.SquareGroup],
                    id : Splicable, ret_type : PExpr, parms : list [Fun_parm],
                    typarms : Typarms) : ClassMember
    {
      def loc = id.Location + ret_type.Location;      
     // FIXME:       | Token.Keyword ("implements") => null      
      match (peek_token ()) {
        | Token.BracesGroup as group =>
          shift ();
          mutable pcustoms = take_attributes_out (ref customs, System.AttributeTargets.Property, true);
          mutable setter = None ();
          mutable getter = None ();

          def plain_name = match (id) { | Splicable.Name (n) => n.Id | _ => "" };
          
          def prop_ty =
            match (parms) {
              | [parm] => PExpr.Call (loc, PExpr.Ref (loc, Name (["->"])), [parm.ty, ret_type])
              | [] => ret_type
              | x :: xs =>
                def parms_prod_type =
                  List.FoldLeft (xs, x.ty, fun (fp : Fun_parm, acc) { 
                    PExpr.Call (loc, PExpr.Ref (loc, Name (["*"])), [acc, fp.ty])
                  });
                PExpr.Call (loc, PExpr.Ref (loc, Name (["->"])), [parms_prod_type, ret_type])
            }
          
          def parse_bd (p) {
            match (peek_token ()) {
              | Token.EndOfGroup => (FunKind.Method ([]), FunBody.Abstract ())
              | _ =>
                def bl = parse_block (p);
                (FunKind.Method ([]), FunBody.Parsed (bl))
            };
          };

          foreach (Token.LooseGroup (toks) in group) {
            push_stream (toks);
            mutable mycustoms = get_customs ();
            def mymods = get_modifiers ();

            match (get_token ()) {
              | Token.Identifier (i) as nametok =>
                def loc = nametok.Location;
                match (i) {
                  | "get" =>
                    unless (getter matches None)
                      Message.error (loc, "property cannot have multiple getters");

                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, true);
                    def method_atts = Modifiers (mymods, method_atts);

                    def (kind, bd) = parse_bd ([]);
                    def name = Splicable.Name (loc, Name ("get_" + plain_name));
                    def fh = Fun_header (loc, name, ret_type, parms);
                    getter = Some (ClassMember.Function (loc, fh.name, method_atts, fh, kind, bd));

                  | "set" =>
                    unless (setter matches None)
                      Message.error (loc, "property cannot have multiple setters");

                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, false);
                    def method_atts = Modifiers (mymods, method_atts);                    

                    def par_atts = Modifiers (NemerleAttributes.None,
                      take_attributes_out (ref mycustoms, System.AttributeTargets.Parameter, true));
                    def val_n = Splicable.Name (loc, Name.NameInCurrentColor ("value", env));
                    def setter_parms = parms + [Fun_parm (val_n, ret_type, par_atts)];
                    
                    def (kind, bd) = parse_bd (setter_parms);
                    def name = Splicable.Name (loc, Name ("set_" + plain_name));
                    def fh = Fun_header (loc, typarms, name, PExpr.Void (), setter_parms);
                    setter = Some (ClassMember.Function (loc, fh.name, method_atts, fh, kind, bd));

                  | _ =>
                    def nm = Splicable.Name (loc, Name.NameInCurrentColor (i, env));
                    def t = parse_return_type (false);
                    def attrs = Modifiers (mymods, take_attributes_out
                                  (ref mycustoms, System.AttributeTargets.Field, true));
                    def embed = PExpr.Quoted (loc, SyntaxElement.ClassMember (
                                  ClassMember.Field (loc + t.Location, nm, attrs, t)));
                    pcustoms = <[ $(Name ("PropertyEmbeddedField") : name) ($embed) ]> :: pcustoms;
                }

              | x => Error (x, "expecting property accessor"); 
            }
            pop_stream ("property member");
          }
          ClassMember.Property (loc, id, Modifiers (mods, pcustoms), ret_type,
                                prop_ty, parms, getter, setter)


        | Token.Operator ("=", _) =>
          shift ();
          def val = parse_expr ();
          def initializer = <[ $(Name (["StaticInitializer"]) : name) ]>;
          def fcustoms = <[ $initializer ($val) ]> ::
                         take_attributes_out (ref customs, System.AttributeTargets.Field, true);
          ClassMember.Field (loc, id, Modifiers (mods, fcustoms), ret_type)
          
        | Token.EndOfGroup =>
          def fcustoms = take_attributes_out (ref customs, System.AttributeTargets.Field, true);
          ClassMember.Field (loc, id, Modifiers (mods, fcustoms), ret_type)
          
        | t => Error (t, "expecting `;' or `{ }' in field / property declaration"); null
      }
    }

    parse_method (h : Fun_header, modifiers : Modifiers) : ClassMember
    {
      def parse_extern () {
        expect_keyword ("extern");
        match (get_token ()) {
          | Token.StringLiteral (s) => 
            expect_empty ("extern function name");
            s
          | x => Error (x, "expecting string after `extern'"); ""
        }
      };
      def impl =
        match (peek_token ()) {
          | Token.Keyword ("implements") =>
            shift ();
            match (maybe_parse_ellipsis ()) {
              | Some (e) => [Splicable.Expression (e)]
              | _        => comma_separated_list (fun () {
                // FIXME
                  def expr = parse_expr (TokenStoppers.All);
                  match (Util.qidl_of_expr (expr)) {
                    | Some ((qid, _)) => Splicable.Name (Name.NameInCurrentColor (qid, env))
                    | None =>
                      Message.error (expr.Location, "expected name of implemented interface method");
                      Splicable.Name (Name ([]))
                  }
                });
            }
          | _ => []
        };
      def body =
        match (peek_token ()) {
          | Token.Operator ("=", _) =>
            shift (); FunBody.Extern (parse_extern ())
            
          | Token.BracesGroup       => FunBody.Parsed (parse_block (h.parms))
          | Token.EndOfGroup         => FunBody.Abstract ()
          | Token.Operator ("$", _) =>
            def result = FunBody.Parsed (parse_spliced_expr ());
            new_group_beginning ();
            result

          | x => Error (x, "expecting method body"); FunBody.Abstract ();
        };

      ClassMember.Function (header = h, name = h.name, modifiers = modifiers, 
                            loc = h.loc, body = body, kind = FunKind.Method (impl))
    }

    parse_option () : ClassMember
    {
      def id = get_splicable_id ();
      match (peek_token ()) {
        | Token.BracesGroup (children) =>
          shift ();
          def members = process_groups (children, "elements of variant option",
                                       ParseClassMember);
          def td = TopDeclaration.VariantOption (name = id, loc = id.loc,
                                                 modifiers = Modifiers (NemerleAttributes.None, []),
                                                 decls = members);

          ClassMember.TypeDeclaration (loc = id.loc, name = null, modifiers = null, td = td)

        | Token.EndOfGroup =>
          ClassMember.EnumOption (id.Location, id, Modifiers (NemerleAttributes.None, []), None ());
                                       
        | Token.Operator ("=", _) =>
          shift ();
          def val = Some (parse_expr (TokenStoppers.Pipe));
          new_group_beginning ();
          ClassMember.EnumOption (id.Location, id, Modifiers (NemerleAttributes.None, []), val);

        | _ =>
          new_group_beginning ();
          ClassMember.EnumOption (id.Location, id, Modifiers (NemerleAttributes.None, []), None ());
      }
    }

    parse_event (mutable loc : Location, mods : NemerleAttributes,
                 mutable customs : list [Token.SquareGroup]) : ClassMember
    {
      def id = get_splicable_id ();
      def ret_type = parse_return_type (false);
      loc += ret_type.Location;
      def plain_name = match (id) { | Splicable.Name (n) => n.Id | _ => "" };      
      def val_n = Splicable.Name (loc, Name.NameInCurrentColor ("value", env));
      mutable remove = null;
      mutable add = null;
      
      match (peek_token ()) {
        | Token.BracesGroup as group =>
          shift ();
          mutable ecustoms = take_attributes_out (ref customs, System.AttributeTargets.Event, true);

          def parse_bd (p) {
            match (peek_token ()) {
              | Token.EndOfGroup => (FunKind.Method ([]), FunBody.Abstract ())
              | _ =>
                def bl = parse_block (p);
                (FunKind.Method ([]), FunBody.Parsed (bl))
            };
          };

          foreach (Token.LooseGroup (toks) in group) {
            push_stream (toks);
            mutable mycustoms = get_customs ();
            def mymods = get_modifiers ();

            match (get_token ()) {
              | Token.Identifier (i) as nametok =>
                def mloc = nametok.Location;
                match (i) {
                  | "remove" | "add" =>
                    if (i == "remove")
                      unless (remove == null)
                        Message.error (mloc, "event cannot have multiple remove methods");
                    else
                      unless (add == null)
                        Message.error (mloc, "event cannot have multiple add methods");

                    def method_atts = take_attributes_out (ref mycustoms, System.AttributeTargets.Method, false);
                    def method_atts = Modifiers (mymods, method_atts);                    

                    def par_atts = Modifiers (NemerleAttributes.None,
                      take_attributes_out (ref mycustoms, System.AttributeTargets.Parameter, true));
                    def method_parms = [Fun_parm (val_n, ret_type, par_atts)];
                    
                    def (kind, bd) = parse_bd (method_parms);
                    def name = Splicable.Name (mloc, Name.NameInCurrentColor (i + "_" + plain_name, env));
                    def fh = Fun_header (mloc, name, PExpr.Void (mloc), method_parms);
                    def method = ClassMember.Function (loc, name, method_atts, fh, kind, bd) :>
                                 ClassMember.Function;
                    if (i == "remove")
                      remove = method;
                    else
                      add = method;

                  | _ =>
                    def nm = Splicable.Name (loc, Name.NameInCurrentColor (i, env));
                    def t = parse_return_type (false);
                    def attrs = Modifiers (mymods, take_attributes_out
                                  (ref mycustoms, System.AttributeTargets.Field, true));
                    def f = ClassMember.Field (mloc + t.Location, nm, attrs, t);
                    def embed = PExpr.Quoted (mloc, SyntaxElement.ClassMember (f));
                    ecustoms = <[ $(Name ("EventEmbeddedField") : name) ($embed) ]> :: ecustoms;
                }

              | x => Error (x, "expecting event accessor"); 
            }
            pop_stream ("property member");
          }
          when (add == null || remove == null)
            Message.error (loc, "both of event accessors `add' and 'remove' must be specified");
          
          ClassMember.Event (loc, id, Modifiers (mods, ecustoms), ret_type, null, add, remove)
          
        | Token.EndOfGroup =>
          // first take out event attributes (those without target also get here)
          def ecustoms = take_attributes_out (ref customs, System.AttributeTargets.Event, false);
          
          /// auto-generated field
          def fmods = NemerleAttributes.Private %| NemerleAttributes.Mutable;
          def field_name = Name.NameInCurrentColor (Util.tmpname (plain_name), null);
          def field_attrs = take_attributes_out (ref customs, System.AttributeTargets.Field, false);
          def field = ClassMember.Field (loc, Splicable.Name (field_name),
                                         Modifiers (fmods, field_attrs), ret_type) :> ClassMember.Field;

          def method_atts = take_attributes_out (ref customs, System.AttributeTargets.Method, true);
          def method_atts = Modifiers (mods, method_atts);
          def method_parms = [Fun_parm (val_n, ret_type, Modifiers.Empty)];

          def name = Splicable.Name (loc, Name.NameInCurrentColor ("add_" + plain_name, env));
          def fh = Fun_header (loc, name, PExpr.Void (loc), method_parms);
          add = ClassMember.Function (loc, name, method_atts, fh, FunKind.Method ([]), null) :>
                ClassMember.Function;
          def name = Splicable.Name (loc, Name.NameInCurrentColor ("remove_" + plain_name, env));
          def fh = Fun_header (loc, name, PExpr.Void (loc), method_parms);
          remove = ClassMember.Function (loc, name, method_atts, fh, FunKind.Method ([]), null) :>
                   ClassMember.Function;

          ClassMember.Event (loc, id, Modifiers (mods, ecustoms), ret_type, field, add, remove)
          
        | t => Error (t, "expecting `;' or `{ }' in event declaration"); null
      }
    }
    
    maybe_parse_ellipsis () : option [PExpr]
    {
      match (peek_token ()) {
        | Token.LooseGroup (Token.Operator (".", _) as tok) =>
          shift ();
          push_stream (tok);
          expect_operator ("..");
          def spliced = parse_spliced_expr ();
          pop_stream ("ellipsis splicing");
          Some (PExpr.Ellipsis (tok.Location + spliced.Location, spliced))
          
        | Token.Operator (".", _) as tok =>
          expect_operator ("..");
          def spliced = parse_spliced_expr ();
          Some (PExpr.Ellipsis (tok.Location + spliced.Location, spliced))
          
        | _ => None ()
      }
    } 
    
    get_customs () : list [Token.SquareGroup] {
      def loop (acc) {
        match (peek_token ()) {
          | Token.SquareGroup (ch) as gr =>
            shift ();
            if (ch != null)
              loop (gr :: acc)
            else {
              Error (gr, "custom attributes brackets cannot be empty");
              loop (acc)
            }

          | _ => List.Rev (acc)
        }
      }
      match (peek_token ()) {
        | Token.Operator (".", _) as begin =>
          mutable end = null;
          repeat (4) end = get_token ();
          end.Next = null;
          [Token.SquareGroup (begin.Location, Token.LooseGroup (begin.Location, begin)) :> Token.SquareGroup]

        | _ => loop ([])
      }
    }

    /** allowed targets are:
          assembly: assembly 
          module:  module   (not supprted currently)
          class, struct, interface, enum: type 
          delegate: type, return
          method: method, return
          parameter: param 
          field: field 
          property indexer: property 
          property get accessor: method, return
          property set accessor: method, param, return
          event field: event, field, method
          event property: event, property (what is this?)
          event add: method, param
          event remove: method, param
    */
    take_attributes_out (from : ref list [Token.SquareGroup], 
                         what : System.AttributeTargets,
                         comply_on_other : bool) : list [PExpr]
    {
      mutable result = [];
      from = List.RevFilter (from, fun (x : Token.SquareGroup) {
        mutable leave = true;
        match (x.Child) {
          | Token.LooseGroup (first) =>
            push_stream (first);
            def target = 
              match (first) {
                | Token.Identifier ("assembly") => System.AttributeTargets.Assembly
                | Token.Identifier ("field") => System.AttributeTargets.Field
                | Token.Keyword ("event") => System.AttributeTargets.Event
                | Token.Identifier ("method") => System.AttributeTargets.Method
                | Token.Keyword ("module") => System.AttributeTargets.Module
                | Token.Identifier ("param") => System.AttributeTargets.Parameter
                | Token.Identifier ("property") => System.AttributeTargets.Property
                | Token.Identifier ("return") => System.AttributeTargets.ReturnValue
                | Token.Keyword ("type") => System.AttributeTargets.Class
                | _ => System.AttributeTargets.All
              }
            when (target != System.AttributeTargets.All) {
              shift (); // ignore target token
              expect_operator (":");
            }
            if (target %&& what || target == System.AttributeTargets.All) {
              leave = false;
              // parse body of first element in this [ , , ]
              result = parse_expr () :: result;

              // parse all remaining in current bracket group [ , , , ]
              when (x.Child.Next != null) {
                x.Child = x.Child.Next;
                result = parse_expr_sequence (x.Child, result);
              }
              pop_stream ("custom attribute")
            }
            else {
              when (comply_on_other)
                Error (first, $"unexpected attribute target `$(first)'");
              // there are still some unpased tokens here, ignore them
              pop_stream ();                
            }

          | _ => Util.ice ("broken brackets in attribute")
        }
        leave
      });
      List.Rev (result);
    }
    
    get_modifiers () : NemerleAttributes
    {
      def loop (acc) {
        def tok = peek_token ();
        match (tok) {
          | Token.Keyword (key) =>
            def add_and_loop (attr : NemerleAttributes) {
              shift ();              
              when (attr %&& acc)
                Error (tok, "attribute '" + key + "' specified more than once");
              loop (attr %| acc)
            }
            match (key) {
              | "mutable" => add_and_loop (NemerleAttributes.Mutable)
              | "public" => add_and_loop (NemerleAttributes.Public)
              | "private" => add_and_loop (NemerleAttributes.Private)
              | "static" => add_and_loop (NemerleAttributes.Static)
              | "new" => add_and_loop (NemerleAttributes.New)
              | "protected" => add_and_loop (NemerleAttributes.Protected)
              | "internal" => add_and_loop (NemerleAttributes.Internal)
              | "abstract" => add_and_loop (NemerleAttributes.Abstract)
              | "sealed" => add_and_loop (NemerleAttributes.Sealed)
              | "override" => add_and_loop (NemerleAttributes.Override)
              | "virtual" => add_and_loop (NemerleAttributes.Virtual)
              | "volatile" => add_and_loop (NemerleAttributes.Volatile)
              | "partial" => add_and_loop (NemerleAttributes.Partial)
              | _ => acc
            }
          | _ =>
            // perform some sanity checks on the declared attributes
            when ((acc %&& NemerleAttributes.Virtual)
                  && (acc %&& NemerleAttributes.Override))
              Message.warning (tok.Location, "the `virtual' attribute is "
                               "redundant, `override' implies `virtual'");
            acc
        }
      }
      loop (NemerleAttributes.None)
    }


    get_tyvar () : string * int {
      match (peek_token ()) {
        | Token.Identifier (tv) =>
          shift ();
          (tv, TypingContext.MacroColor)
        | t => Error (t, "expecting type variable"); ("error", 0)
      }
    }
    
    /** `splicing_type' is for noting, that there are spliced tyvars
     * if yes, it's PType.Spliced with expression describing their list
     * else it's PType.Void ()
     */
    parse_tyvars () : list [string * int] * PExpr
    {
      match (peek_token ()) {
        | Token.SquareGroup (null) as t =>
          shift ();
          Error (t, "expecting type variables"); (null, null)
          
        | Token.SquareGroup (children) as group =>
          push_stream ((children :> Token.LooseGroup).Child);          
          match (maybe_parse_ellipsis ()) {
            | Some (e) =>
              pop_stream ("type variables");
              shift ();              
              ([], e)

            | _ =>
              pop_stream ();
              shift (); // now we are after whole '[..]' group
              (TokenMap (group, get_tyvar), PExpr.Void ())
          }
        | _ => (null, null)
      };
    }

    parse_where_constraints (tyvars : list [string * int], splicing_type : PExpr) 
    : Typarms 
    {
      def loop (acc) {
        if (flag_keyword ("where"))
          match (maybe_parse_ellipsis ()) {
            | Some (e) => (List.Rev (acc), e)
            | _ =>
              def tv = get_tyvar ();
              expect_operator (":");
              def types = comma_separated_list (fun () { parse_expr (TokenStoppers.Braces) });
              def acc = List.FoldLeft (types, acc, fun (t, acc) { 
                Constraint (tv, t) :: acc 
              });
              loop (acc)
          }
        else (List.Rev (acc), PExpr.Void ())
      };
      if (tyvars != null) {
        def (where_cts, where_spl_t) = loop ([]);
        match ((splicing_type, where_spl_t)) {
          | (PExpr.Void, PExpr.Void) => Typarms (tyvars, where_cts)
          | _ =>
            // we have spliced type variables
            Typarms (tyvars, Constraint (("", 0), <[ ($splicing_type, $where_spl_t) ]>) 
                     :: where_cts)
        }
      }
      else Typarms.Empty
    }

    /**
     *  Parse plain functional header (with optional '[..]' generic parameters
     *                                 and '(..)' fun parameters)
     */
    parse_fun_header (mutable name : Splicable) : Fun_header
    {
      when (name == null) name = get_splicable_id ();
      def tyvars = parse_tyvars ();      
      def parms = parse_parameters ();
      def ret_type = parse_return_type (true);
      def typarms = parse_where_constraints (tyvars);

      Fun_header (name.Location + ret_type.Location,
                  name = name,
                  ret_type = ret_type, 
                  parms = parms, 
                  typarms = typarms)
    }
   

    /** Parse function parameter definition from given LooseGroup */
    parse_parameter () : Fun_parm {
      mutable customs_token = get_customs ();
      def customs = take_attributes_out (ref customs_token, System.AttributeTargets.Parameter, true);      
      def mods = Modifiers (get_modifiers (), customs);

      match (peek_token ()) {
        | Token.Keyword ("params") =>
          shift ();
          mods.custom_attrs = <[ System.ParamArrayAttribute ]> :: mods.custom_attrs;
        | _ => ()
      };
      def id = get_splicable_id ();
      def t =
        match (peek_token ()) {
          | Token.Operator (":", _) => shift (); parse_expr (TokenStoppers.Equal)
          | _ => PExpr.Wildcard (id.Location)
        };
      match (peek_token ()) {
        | Token.Operator ("=", _) => 
          shift ();
          def e = parse_expr ();
          mods.custom_attrs = <[ System.ComponentModel.DefaultValueAttribute ($e)
                              ]> :: mods.custom_attrs;
        | _ => ()
      };
      Fun_parm (loc = id.loc, name = id, ty = t, modifiers = mods)
    }

    parse_parameters () : list [Fun_parm] {
      def group = get_token ();
      match (group) {
        | Token.RoundGroup (null) | Token.SquareGroup (null) => []
        | Token.RoundGroup (child)          
        | Token.SquareGroup (child) =>
          push_stream (child);
          match (maybe_parse_ellipsis ()) {
            | Some (e) =>
              pop_stream ("ellipsis spliced expression");
              [Fun_parm (e.loc, Splicable.Name (Name ([])), PExpr.Void (), 
                         Modifiers (NemerleAttributes.None, [e]))]
                         
            | _ => pop_stream (); TokenMap (group, parse_parameter);
          }
        | _ => Error (group, "expecting function parameters"); []
      }
    }

    parse_return_type (allow_inference : bool) : PExpr {
      match (peek_token ()) {
        | Token.Operator (":", _) =>
          shift ();
          parse_expr (TokenStoppers.Braces %| TokenStoppers.Dollar %| TokenStoppers.Equal)
          
        | _ when allow_inference => PExpr.Wildcard (last_tok.Location)
        | t => Error (t, "expecting `:' and type specifier for class member");
          PExpr.Wildcard (last_tok.Location)
      };
    }
       
    parse_block (parms : list [Fun_parm]) : PExpr
    {
      def tok = get_token ();
      def loc = tok.Location;
      match (tok) {
        // entire function body may be spliced
        | Token.Operator ("$", _) =>
          push_back (); parse_spliced_expr ()

        // empty { }
        | Token.BracesGroup (x) when x == null => PExpr.Sequence (loc, [])

        // function body with embedded matching { | pat => bd | ... }
        | Token.BracesGroup (Token.LooseGroup (Token.Operator ("|", _)) as group) =>
          // convert function's parameters to tuple to be matched
          def parms_to_tupl (prs : list [Fun_parm], acc) {
            match (prs) {
              | [] => PExpr.Tuple (group.Location, List.Rev (acc))
              | ({name = Splicable.Name (x); loc = l}) :: xs => 
                parms_to_tupl (xs, PExpr.Ref (l, x) :: acc)
              | x :: _  => Message.error (x.Location, "illegal spliced parameter?"); <[ () ]>
            }
          };
          def cases = process_groups (group, "function body", parse_match_case);
          match (parms) {
            | [{name = Splicable.Name (x)}] => PExpr.Match (loc, PExpr.Ref (loc, x), cases)
            | _::_::_ => 
              def tup = parms_to_tupl (parms, []);
              tup.loc = loc;
              PExpr.Match (loc, tup, cases)
              
            | [] =>             
              Message.error (loc, "functions with direct matching must have parameters"); <[ () ]>
              
            | x :: _ => Message.error (x.Location, "illegal spliced parameter?"); <[ () ]>
          }
          
        // standard body enclosed by { ... }
        | Token.BracesGroup (groups) =>
          PExpr.Sequence (loc, parse_expr_sequence (groups));

        | x =>
          Error (x, "expected `{' at the beginning of function body"); <[ () ]>
      }
    }

    make_operator_call (name : string, e1 : PExpr, e2 : PExpr) : PExpr
    {
      def loc = e1.Location + e2.Location;
      def make_splicable (e) {
        | PExpr.Ref (n) => Splicable.Name (e.Location, n);
        | PExpr.Spliced (PExpr.TypeEnforcement) => Splicable.Expression (e);
        | PExpr.Spliced (s) => Splicable.Expression (s);
        | _ =>
          Message.error (e2.Location, "expecting identifier after");
          null
      }
      match (name) {
        | "." => PExpr.Member (loc, e1, make_splicable (e2))
        | "=" => PExpr.Assign (loc, e1, e2)
        | ":" => PExpr.TypeEnforcement (loc, e1, e2)
        | ":>" => PExpr.TypeConversion (loc, e1, e2)
        | "::" => PExpr.Call (loc, PExpr.Ref (loc, Name.NameInCurrentColor ("Cons", env)), [e1, e2])
        | "as" => PExpr.As (loc, e1, make_splicable (e2))
        | "is" =>
          Util.locate (loc, <[ match ($e1) { | _ : $e2 => true | _ => false } ]>)

        | "matches" =>
          Util.locate (loc, <[ match ($e1) { | $e2 => true | _ => false } ]>)
          
        | _ => PExpr.Call (loc, PExpr.Ref (loc, Name.NameInCurrentColor (name, env)), [e1, e2])
      }
    }

    make_operator_call (name : string, e : PExpr) : PExpr
    {
      PExpr.Call (e.Location, PExpr.Ref (e.Location, Name.NameInCurrentColor (name, env)), [e])
    }
    
    make_operator_call (name : string, parms : list [PExpr]) : PExpr
    {
      def head = List.Head (parms);
      def loc = head.Location;
      match (name) {
        | "(" => PExpr.Call (loc, head, List.Tail (parms))
        | "[" => PExpr.Indexer (loc, head, List.Tail (parms))
        | _ => PExpr.Call (loc, PExpr.Ref (loc, Name (name)), parms)
      }
    }
    
    roll_exprs (exprs : ref list [PExpr], begin : list [PExpr]) : list [PExpr]
    {
      mutable result = [];
      while ((exprs : object) != begin) {
        match (exprs) {
          | x :: xs =>
            result = x :: result;
            exprs = xs;
          | _ => Util.ice ("invalidated expressions stack")
        }
      }
      result
    } 
    
    roll_operators (exprs : ref list [PExpr], ops : ref list [OperatorInfo], priority : int) : void
    {
      def loop () {
        match (ops) {
          | [] => ()
          | x :: xs =>
            // a * b + c --- *'s right is higher, than +'s left, so a*b rolls
            // when + occurs
            when (x.RightPriority >= priority) {
              // we take all expressions, which appeared after this operator
              // appeared on stack (and sometimes the one from top at that time)
              def expr = 
                match (x) {
                  | nary : NaryOperatorInfo =>
                    def parms = roll_exprs (ref exprs, nary.ExprsBegin);
                    make_operator_call (x.Name, parms)
                    
                  | _ : BinaryOperatorInfo =>
                    match (exprs) {
                      | e1 :: e2 :: rest =>
                        exprs = rest;
                        make_operator_call (x.Name, e2, e1)
                      | _ => Util.ice ("not enough parms for binary")
                    }
                  | _ =>
                    def e = List.Head (exprs);
                    exprs = List.Tail (exprs);
                    make_operator_call (x.Name, e);
                }
              
              // put new expression on the stack
              exprs = expr :: exprs;
              ops = xs;
              loop ();
            }
        }
      }
      loop ();
    }

    parse_expr () : PExpr { parse_expr (TokenStoppers.None); }
    
    /** Parse expression from current stream of tokens.
        Reading is terminated before every token from [stop]. */
    parse_expr (stop : TokenStoppers) : PExpr
    {
      mutable _expr_stack = [];
      mutable rpn_op_stack = [];
      mutable _op_context = OpContext.Prefix;

      def loop () {
        if (_op_context == OpContext.Prefix)
          match (peek_token ()) {
            | Token.Operator (".", _) =>
              expect_operator ("..");
              def expr = parse_spliced_expr ();
              _expr_stack = PExpr.Ellipsis (expr.Location, expr) :: _expr_stack;
              expect_empty ("ellipsis expression");
              _op_context = OpContext.Postfix;
              loop ()

            | Token.Operator (str, _) when str != "$" =>
              def info = OperatorInfo.PrefixInfos [str];
              if (info == null) {
                Error (stream, "invalid operator in prefix position");
                <[ () ]>
              }
              else {
                shift ();
                rpn_op_stack = info :: rpn_op_stack;
                // we leave prefix context here (for things like `!!expr'
                loop ();
              }

            | _ =>
              def expr = parse_embedded_expr (stop);
              _expr_stack = expr :: _expr_stack;
              // after raw expression we are in postfix context
              _op_context = OpContext.Postfix;
              loop ()
          }
        else {
          mutable group = null : Token;
          def info = 
            match (peek_token ()) {
              | Token.Operator ("*", _) =>
                NaryOperatorInfo (OperatorInfo.ProductInfo);

              | Token.Operator (str, _) =>
                if (should_stop (stop))
                  null
                else
                  OperatorInfo.GetOrCreate (str)
                  
              | Token.Keyword (k) => OperatorInfo.Infos [k]
              | Token.SquareGroup (g)  =>
                group = g;                
                NaryOperatorInfo (OperatorInfo.SquareInfo);

              | Token.RoundGroup (g) =>
                group = g;
                NaryOperatorInfo (OperatorInfo.RoundInfo);

              | _ => null
            }
          if (info == null) {
            // this is the end of parsing, roll all operators
            roll_operators (ref _expr_stack, ref rpn_op_stack, 0);
            // there should be only one expr on the stack, return it
            match (_expr_stack) {
              | [x] => x
              | _ => Util.ice ("something different than one expression after rolling")
            }
          }
          else {
            shift ();
            roll_operators (ref _expr_stack, ref rpn_op_stack, info.LeftPriority);

            match (info) {
              | x : NaryOperatorInfo => x.ExprsBegin = List.Tail (_expr_stack);
              | _ => ()
            }
            
            // special case for x * y * z
            if (info.Name == "*") {
              _op_context = OpContext.Prefix;
              match (rpn_op_stack) {
                | x :: _ when x.Name == "*" => ()
                | _ => rpn_op_stack = info :: rpn_op_stack;
              }
            }
            else
              rpn_op_stack = info :: rpn_op_stack;

            // parse inner elements of bracket-like operators: `( ... )'
            _expr_stack = parse_expr_sequence (group, _expr_stack);

            when (info is BinaryOperatorInfo)
              _op_context = OpContext.Prefix;
            
            loop ();
          }
        }
      }
      loop ();
    }
    
    parse_literal () : PExpr
    {
      def tok = peek_token ();
      def lit = 
        match (tok) {
          | Token.Keyword ("null") => Literal.Null ()
          | Token.Keyword ("true") => Literal.Bool (true)
          | Token.Keyword ("false") => Literal.Bool (false)
          | Token.RoundGroup (null) => Literal.Void ()
          | Token.StringLiteral (s) => assert (s != null); Literal.String (s)
          | Token.ByteLiteral (n) => Literal.Byte (n)
          | Token.SByteLiteral (n) => Literal.SByte (n)
          | Token.ShortLiteral (n) => Literal.Short (n)
          | Token.UShortLiteral (n) => Literal.UShort (n)
          | Token.IntLiteral (n) => Literal.Int (n)
          | Token.UIntLiteral (n) => Literal.UInt (n)
          | Token.LongLiteral (n) => Literal.Long (n)
          | Token.ULongLiteral (n) => Literal.ULong (n)
          | Token.FloatLiteral (n) => Literal.Float (n)
          | Token.DoubleLiteral (n) => Literal.Double (n)
          | Token.DecimalLiteral (n) => Literal.Decimal (n)
          | Token.CharLiteral (c) => Literal.Char (c)
          | _ => null
        }
      if (lit != null) {
        shift ();
        PExpr.Literal (tok.Location, lit)
      }
      else null
    }

    parse_spliced_expr () : PExpr {
      def id = get_splicable_id ();
      match (id) {
        | Splicable.Expression (e) =>
          match (e) {
            | PExpr.Spliced (PExpr.TypeEnforcement) => e
            | _ => PExpr.Spliced (id.Location, e)
          }
        | Splicable.Name | Splicable.Int =>
          Message.error (id.Location, "expected spliced expression"); <[ () ]>
      }
    }

    parse_case_guard () : PExpr * option [PExpr] {
      match (parse_expr (TokenStoppers.Pipe %| TokenStoppers.Arrow)) {
        | <[ @when ($pat, $guard) ]> => (pat, Some (guard))
        | pat                        => (pat, None ())
      }
    }
   
    parse_match_case () : MatchCase {
      def loop2 (acc) {
        def res = parse_case_guard ();
        match (get_token ()) {
          | Token.Operator ("=>", _) => List.Rev (res :: acc)
          | Token.Operator ("|", _) => loop2 (res :: acc)
          | x => Error (x, "found junk after pattern"); List.Rev (res :: acc)
        }
      };
      def case_group = (stream :> Token.LooseGroup);
      push_stream (case_group.Child);
      
      // eat pattern part and '=>'
      def pats = 
        match (peek_token ()) {
          | Token.Operator ("|", _) =>
            shift ();
            match (maybe_parse_ellipsis ()) {
              | Some (e) =>
                expect_operator ("=>");
                [(e, None ())]
                
              | None => loop2 ([])
            }
          | _ => loop2 ([])
        };
      // modify beginning of current group to point at match case body  
      case_group.Child = stream; 
      pop_stream ();

      def expr =
        match (parse_expr_sequence (TokenStoppers.Pipe)) {
          | [x] => x
          | l => PExpr.Sequence (case_group.Child.Location, l)
        };

      MatchCase (pats, expr)
    }

    parse_embedded_expr (stop : TokenStoppers) : PExpr
    {
      def lit = parse_literal ();
      if (lit != null) lit
      else {
        def tok = get_token ();
        def loc = tok.Location;

        match (tok) {
          | Token.Keyword ("void") => PExpr.Void (loc)
          | Token.Keyword ("this") => PExpr.This (loc)
          | Token.Keyword ("base") => PExpr.Base (loc)
          | Token.Keyword ("_") => PExpr.Wildcard (loc)
          | Token.Keyword ("typeof") =>
            match (get_token ()) {
              | Token.RoundGroup (child) =>
                match (parse_expr_sequence (child, [])) {
                  | [x] => PExpr.Typeof (loc, x)
                  | _ => Message.error (child.Location, "expecting single type in `typeof (...)'"); <[ () ]>
                }
              | x => Error (x, "expecting `(..)' after `typeof'"); <[ () ]>
            }

          | Token.Keyword ("array") =>
            def rank =
              match (peek_token ()) {            
                | Token.Operator (".", _) =>
                  shift ();
                  match (get_token ()) {
                    | Token.SquareGroup (child) =>
                      match (parse_expr_sequence (child, [])) {
                        | [x] => x
                        | _ => Error (child, "expecting `[rank]' after `array.'"); <[ 1 ]>
                      }
                    | x => Error (x, "expecting `[rank]' after `array.'"); <[ 1 ]>
                  }
                | _ => <[ 1 ]>
              }

            def body = peek_token ();              
            match (body) {
              | Token.SquareGroup | Token.Operator ("$", _) =>
                PExpr.Array (loc, rank, parse_embedded_expr (TokenStoppers.All))

              | Token.RoundGroup (groups) =>
                shift ();
                def exprs = parse_expr_sequence (groups);
                PExpr.EmptyArray (loc + body.Location, exprs)

              | x =>
                Error (x, "expected [ ..elements of array.. ], ( .."
                       "sizes of empty array.. )  or `array .[rank] [..]' in array creation");
                <[ () ]>
            }
            
          // tuples
          | Token.RoundGroup (groups) =>
            match (parse_expr_sequence (groups)) {
              | [PExpr.Ellipsis] as exprs => PExpr.Tuple (loc, exprs)
              | [e] => e
              | exprs => PExpr.Tuple (loc, exprs)
            }

          | Token.SquareGroup (groups) =>
            def exprs = parse_expr_sequence (groups);
            def nil = PExpr.Call (loc, PExpr.Ref (loc, Name.NameInCurrentColor ("Nil", env)), []);
            List.FoldRight (exprs, nil, fun (x : PExpr, acc) {
              PExpr.Call (x.Location, PExpr.Ref (x.Location, Name.NameInCurrentColor ("Cons", env)), [x, acc])
            });

          | Token.BracesGroup (groups) when !(stop %&& TokenStoppers.Braces) =>
            PExpr.Sequence (loc, parse_expr_sequence (groups));

          | Token.QuoteGroup (group) =>
            push_stream (group);
            def expr = parse_quotation ();
            pop_stream ("code quotation");
            expr
            
          | Token.Keyword ("ref") =>
            def refexpr = parse_expr (TokenStoppers.All);
            PExpr.ParmByRef (loc + refexpr.loc, refexpr)

          | Token.Keyword ("out") =>
            def outexpr = parse_expr (TokenStoppers.All);
            PExpr.ParmOut (loc + outexpr.loc, outexpr)

          | Token.Keyword ("throw") =>
            def exn = parse_expr (stop);
            PExpr.Throw (loc + exn.loc, exn)
            
          | Token.Keyword ("mutable") =>
            def id = get_splicable_id ();
            match (get_token ()) {
              | Token.Operator ("=", _) =>
                def val = parse_expr (stop);
                PExpr.Define (loc + val.loc, true, id, val)
              | x =>
                Error (x, "expected assignment operator ="); <[ () ]>
            };

          | Token.Keyword ("fun") =>
            def tyvars = parse_tyvars ();      
            def parms = parse_parameters ();
            def ret_type = parse_return_type (true);
            def typarms = parse_where_constraints (tyvars);

            def h = Fun_header (loc + ret_type.Location,
                                name = Splicable.Name (Name ([])),
                                ret_type = ret_type, 
                                parms = parms, 
                                typarms = typarms);
            
            def expr = parse_block (parms);
            PExpr.Lambda (h.loc, Function_decl (h, expr))

          | Token.Operator ("$", _) =>
            match (peek_token ()) {
              | Token.StringLiteral (str) =>
                shift ();
                <[ Nemerle.IO.sprint ($(str : string)) ]>
              | _ =>
                push_back ();
                parse_spliced_expr ();
            }
            
          | Token.Keyword ("match") =>
            def expr = 
              match (get_token ()) {
                | Token.RoundGroup (group) =>
                  match (parse_expr_sequence (group, [])) {
                    | [x] => x
                    | _ => Message.error (group.Location, "expecting single expression in `match (..)'"); <[ () ]>
                  }
                | x => Error (x, "expecting `(..)' after `match'"); <[ () ]>
              }
            match (get_token ()) {
              | Token.BracesGroup (Token.LooseGroup (Token.Operator (".", _)) as group) =>
                push_stream (group);
                match (maybe_parse_ellipsis ()) {
                  | Some (e) =>
                    pop_stream ("match body");
                    PExpr.Match (loc, expr, [MatchCase ([], e)]);
                  | _        => Util.ice ()
                }
              | Token.BracesGroup (group) =>
                PExpr.Match (loc, expr, process_groups (group, "match body", parse_match_case))
                
              | x => Error (x, "expecting '{' after 'match (e)'"); <[ () ]>
            }

          | Token.Keyword ("try") =>
            def try_body = parse_block ([]);
            mutable body = try_body; // resulting expression

            // exception handlers
            when (flag_sibling_keyword ("catch")) {
              def mktry (h : MatchCase, body) {
                match (h.patterns) {
                  | [(PExpr.TypeEnforcement (PExpr.Wildcard, t), _)] =>
                    PExpr.TryWith (loc, body, Splicable.Name (Name ([Util.tmpname ("u")])), t, h.body)
                  
                  | [(PExpr.TypeEnforcement (PExpr.Ref (id), t), _)] =>
                    PExpr.TryWith (loc, body, Splicable.Name (id), t, h.body)

                  | [(PExpr.TypeEnforcement (PExpr.Spliced (id), t), _)] =>
                    PExpr.TryWith (loc, body, Splicable.Expression (id), t, h.body)

                  | _ =>
                    Message.error (h.body.Location, "exception catch pattern must"
                                   " be in form of `| e : ExceptionType => handler'"); body
                }
              };
              match (get_token ()) {
                | Token.BracesGroup (group) =>
                  body = List.FoldLeft (process_groups (group, "exception handlers", parse_match_case),
                                        try_body, mktry);

                | x => Error (x, "expecting handlers of exceptions")
              }
            }
            
            if (flag_sibling_keyword ("finally")) {
              def handler = parse_block ([]);
              PExpr.TryFinally (loc, body, handler)
            }
            else {
              if (body == (try_body : object)) {
                Message.error (loc, "expecting `catch' or `finally'");
                try_body
              }
              else body
            }

          | Token.Keyword ("def") =>
            def parse_val (id) {
              expect_operator ("=");
              def val = parse_expr (stop);
              PExpr.Define (loc + val.loc, false, id, val)
            };
            def parse_pat () {
              def pat = parse_expr (stop %| TokenStoppers.Equal);
              expect_operator ("=");
              def expr = parse_expr (stop);
              PExpr.DefPattern (loc + expr.loc, pat, expr)
            };
            def parse_funs (acc, idopt) {
              def h = parse_fun_header (idopt);
              def fd = Function_decl (h, parse_block (h.parms));
              if (flag_sibling_keyword ("and")) {
                def id = get_splicable_id ();
                parse_funs (fd :: acc, id)
              }
              else    
                PExpr.DefFunctions (loc + h.loc, List.Rev (fd :: acc))
            };

            match (maybe_parse_ellipsis ()) {
              | Some (e) => PExpr.DefFunctions (loc, [Function_decl (null, e)])
              | _ =>
                match (peek_token ()) {
                  | Token.Keyword ("_")
                  | Token.Operator ("$", _) 
                  | Token.Identifier =>
                    def id = get_splicable_id ();
                    match (peek_token ()) {
                      | Token.SquareGroup 
                      | Token.RoundGroup => parse_funs ([], id)
                      | Token.Operator ("=", _) => parse_val (id)
                      | x => Error (x, "expecting `def x = expr' or `def f () { .. }'"); <[ () ]>
                    }
                  | _ => parse_pat ()                    
                }
            }

          | Token.Identifier (i) => PExpr.Ref (loc, Name.NameInCurrentColor (i, env))
            
          | Token.Keyword (k) =>
            match (syntax_keywords.Find (k)) {
              | None => Error (tok, "unexpected keyword in expression context"); <[ () ]>
              | Some (syntax_definition) =>
                parse_syntax_definition (syntax_definition, stop)                
            }

          | _ => Error (tok, "expecting expression"); <[ () ]>
        }
      }
    }

    parse_quotation () : PExpr {
      match (peek_token ()) {
        | Token.LooseGroup (Token.Identifier (first) as tok) as group
          when tok.Next != null && (tok.Next matches Token.Operator (":", _)) =>

          group.Child = tok.Next.Next;

          def push ['a] (describe, f : void -> 'a) {
            push_stream (group.Child);
            def entity = f ();
            pop_stream (describe);
            shift ();
            entity
          }
          
          def element =
            match (first) {
              | "ttype" =>
                match (parse_expr_sequence (TokenStoppers.None)) {
                  | [x] => SyntaxElement.TType (x)
                  | _ => Error (group, "expecting single type in quotated code"); SyntaxElement.TType (null)
                }
              | "case"  => SyntaxElement.MatchCase (parse_match_case ())
              | "caseguard" =>
                SyntaxElement.MatchCaseGuard (push ("quoted pattern", parse_case_guard))

              | "fundecl" =>
                def decl = push ("quoted function", fun () {
                  def h = parse_fun_header (null);
                  Function_decl (h, parse_block (h.parms));
                });
                SyntaxElement.Function (decl)

              | "parameter" | "funparm" =>
                SyntaxElement.Parameter (push ("quoted parameter", parse_parameter))

              | "decl" => SyntaxElement.ClassMember (ParseClassMember ())
              | _ => Error (tok, "bad quotation type"); SyntaxElement.Expression (<[ () ]>)
            }
          PExpr.Quoted (tok.Location, element)

        | x =>
          def expr =
            match (parse_expr_sequence (TokenStoppers.None)) {
              | [x] => x
              | l => PExpr.Sequence (x.Location, l)
            };
          PExpr.Quoted (expr.Location, SyntaxElement.Expression (expr))
      }
    }
    

    parse_expr_sequence (stop : TokenStoppers) : list [PExpr]
    {
      List.Rev (parse_expr_sequence (stop, []))
    }
    
    parse_expr_sequence (group : Token) : list [PExpr]
    {
      List.Rev (parse_expr_sequence (group, []))
    }
    
    /** special function to parse sequence in a way allowing other functions
        switching to sibling LooseGroup of tokens. Like:
          LooseGroup (..a b c..); LooseGroup (d..)
     */
    parse_expr_sequence (stop : TokenStoppers, mutable result : list [PExpr]) : list [PExpr]
    {
      def loop () {
        unless (should_stop (stop)) {
          def group_token = stream :> Token.LooseGroup;
          push_stream (group_token.Child);
          result = parse_expr (stop) :: result;
          
          if (stream == null || !should_stop (stop)) {
            pop_stream ("expression in sequence");
            shift (); // shift group in which we reached the end
            loop ();
          }
          else {
            def next = stream;
            pop_stream ();
            (stream :> Token.LooseGroup).Child = next;
          }
        }
      }
      loop ();
      result
    }
    
    parse_expr_sequence (group : Token, acc : list [PExpr]) : list [PExpr]
    {
      push_stream (group);
      def result = parse_expr_sequence (TokenStoppers.None, acc);
      pop_stream ("group of expressions");
      result
    }
    
    //------------- PARSING OF MACRO SYNTAX EXTENSIONS ---------------------

    parse_syntax_definition (definition : SyntaxDefinition, stop : TokenStoppers) : PExpr
    {
      def loc = last_tok.Location;
      def parms = parse_grammar_rule (definition.Rules, stop);
      PExpr.MacroCall (loc, Name ([]), definition.MacroNamespace, definition.Permute (parms))
    }
    
    parse_grammar_rule (rule : list [GrammarElement], stop : TokenStoppers)
      : list [SyntaxElement]
    {
      def find_closing (li) {
        def loop (ac, l) {
          match (l) {
            | [] => Message.fatal_error ("syntax definition do not have `)' after '(");
            | GrammarElement.Operator (")") :: xs =>
              (List.Rev (ac), xs)
            | x :: xs => loop (x :: ac, xs)
          }
        }
        loop ([], li)
      }

      def expect_semicolon () {
        if (stream == null)
          jump_to_sibling ();
        else if (stream matches Token.Semicolon)
          shift ()
        else
          Error (stream, "expected `;'");
      }
      
      def loop (acc, lst) {
        match (lst) {
          | GrammarElement.Operator ("(") :: xs =>
            def (g_elements, rest) = find_closing (xs);
            
            match (get_token ()) {
              | Token.RoundGroup (Token.LooseGroup (first) as loose) =>
                match (g_elements) {
                  | [GrammarElement.ExpressionList] =>
                    def exprs = parse_expr_sequence (loose);
                    loop (List.RevMap (exprs, fun (x) { SyntaxElement.Expression (x)}) + acc, rest)

                  | _ =>
                    push_stream (loose);
                    push_stream (first);
                    def res = parse_grammar_rule (g_elements, TokenStoppers.None);
                    pop_stream ("inside `()'");
                    shift (); // shift the loose group, which just ended
                    pop_stream ("end of `()'");
                    loop (List.Rev (res) + acc, rest)
                }

              | Token.RoundGroup as x => Error (x, "it cannot be empty"); loop (acc, rest)
              | x => Error (x, "expecting `(..)'"); loop (acc, rest);
            }

          | GrammarElement.Operator (";") :: xs =>
            expect_semicolon ();
            loop (acc, xs)
            
          | GrammarElement.Operator (n) :: xs =>
            expect_operator (n);
            loop (acc, xs)

          | GrammarElement.Keyword (n) :: xs =>
            unless (flag_sibling_keyword (n)) 
              Error (peek_token (), $"expected `$(n)' keyword");
            loop (acc, xs)

          | GrammarElement.Expression :: xs =>
            def expr = parse_expr (stop);
            loop (SyntaxElement.Expression (expr) :: acc, xs)

          | GrammarElement.ExpressionList :: _ => Util.ice ("expr list?")

          | GrammarElement.Parameter :: xs =>
            def p = parse_parameter ();
            loop (SyntaxElement.Parameter (p) :: acc, xs)

          | GrammarElement.Optional (GrammarElement.Operator (";")) :: xs =>
            if (stream == null)
              jump_to_sibling ()
            else when (stream matches Token.Semicolon)
              shift ();
            loop (acc, xs)
            
          | GrammarElement.Optional (GrammarElement.Operator (n)) :: xs =>
            match (peek_token ()) {
              | Token.Operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
                expect_operator (n)
              | _ => ()
            };
            loop (acc, xs)

          | GrammarElement.Optional (GrammarElement.Keyword (n)) :: xs =>
            ignore (flag_keyword (n));
            loop (acc, xs)

          | GrammarElement.Optional (GrammarElement.Expression) :: GrammarElement.Keyword (n) :: xs =>
            match (peek_token ()) {
              | Token.Keyword (o) when o == n =>
                shift ();
                loop (SyntaxElement.Expression (null) :: acc, xs)
              | _ =>
                def expr = parse_expr (stop);
                expect_keyword (n);
                loop (SyntaxElement.Expression (expr) :: acc, xs)
            };

          | GrammarElement.Optional (GrammarElement.Expression) :: GrammarElement.Operator (";") :: xs =>
            if (stream == null) {
              jump_to_sibling ();
              loop (SyntaxElement.Expression (null) :: acc, xs)
            }
            else if (stream matches Token.Semicolon) {
              shift ();
              loop (SyntaxElement.Expression (null) :: acc, xs)
            } 
            else {
              def expr = parse_expr (stop);
              expect_semicolon ();
              loop (SyntaxElement.Expression (expr) :: acc, xs)
            }

          | [GrammarElement.Optional (GrammarElement.Expression)] =>
            if (stream == null)
              List.Rev (acc)
            else
              List.Rev (SyntaxElement.Expression (parse_expr ()) :: acc)
            
          | GrammarElement.Optional (GrammarElement.Expression) :: GrammarElement.Operator (n) :: xs =>
            match (peek_token ()) {
              | Token.Operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
                shift ();
                loop (SyntaxElement.Expression (null) :: acc, xs)
              | _ =>
                def expr = parse_expr (stop);
                expect_operator (n);
                loop (SyntaxElement.Expression (expr) :: acc, xs)
            };

          | x :: _ =>
            Message.fatal_error (last_tok.Location, "syntax definition of macro is ambiguous: " + x.ToString ())

          | [] => List.Rev (acc)
        }
      };

      loop ([], rule)
    }
  } // end MainParser
} // end namespace
