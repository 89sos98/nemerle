/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 */
public interface IMacro {
  GetName () : string;
  GetNamespace () : string;  
  Run (ctx : CTX, args : list <PT.SyntaxElement>) : PT.Expr;
  CallTransform (_ : list <PT.Parm>) : list <PT.SyntaxElement>;
  SyntaxExtension () : string * list <Parser.GrammarElement> * list <int>;
} 

public module MacroRegistry {
  public macros : Hashtable <string, IMacro>;
  extensions : Hashtable <string, list <string * list<string> * Parser.KeywordCallback>>;

  this () {
    macros <- Hashtable (100);
    extensions <- Hashtable (50);
  }

  internal LoadSyntaxExtensions (from_namespace : string) : void
  {
    def load (key, keywords, callback) {
      Parser.ctx.keywords.Set (key, callback);
      List.Iter (keywords, fun (x) { Lexer.AddKeyword (x) })
    };
    match (extensions.Get (from_namespace)) {
      | Some (l) => List.Iter (l, load)
      | _ => ()
    }
  }

  internal RemoveSyntaxExtensions () : void
  {
    extensions.Iter (fun (ns, val) {
      when (ns != "Nemerle.Core") {
        List.Iter (val, fun (tup) {
          def (key, keywords, _) = tup;
          List.Iter (keywords, fun (x) { Lexer.RemoveKeyword (x) });
          Parser.ctx.keywords.Remove (key)
        })
      }
    })
  }
  
  public register_macro (m : IMacro) : void {
    def ns = m.GetNamespace ();
    // full qualified name of macro call
    def fullname = ns + m.GetName ();
    // crop last symbol (`.') of namespace
    def ns = ns.Substring (0, ns.Length - 1);    
    def name = m.GetName ();

    if (macros.Contains (fullname))
      Message.fatal_error ("Macro name `" + fullname + "' is ambiguous.")
    else {
      match (m.SyntaxExtension ()) {
        | ("", [], []) => ()
        | (key, rules, positions) =>
          def permute = Macros.CreatePermutingFunction (List.Rev (positions));
          Lexer.AddKeyword (key);
          mutable keywords <- [];
          List.Iter (rules, fun (x) { 
            | Parser.GE_keyword (k) =>
              Lexer.AddKeyword (k);
              keywords <- k :: keywords;
            | _ => () 
          });

          def callback =
            Parser.KeywordCallback (key, Parser.make_parsing_function
                                           (name, rules, permute));
                                                                  
          Parser.ctx.keywords.Set (key, callback);

          // store extensions for this namespace
          match (extensions.Get (ns)) {
            | Some (l) =>
              extensions.Set (ns, (key, keywords, callback) :: l)
            | None =>
              extensions.Set (ns, [(key, keywords, callback)])
          }
      };
      macros.Set (name, m)
    }
  }

  public expand_macro (ctx : CTX, expr : PT.Expr) : PT.Expr {
    match (expr) {
      | PT.E_call (PT.E_ref (name), args) =>
        match (macros.Get (name.id)) {
          | Some (x) =>
            TypingContext.PushNewColor (name.color, name.GetEnv (null));
            def expanded = x.Run (ctx, x.CallTransform (args));
            TypingContext.PopColor ();
            expand_macro (ctx, expanded);
          | None => expr
        }
      | PT.E_macrocall (name, parms) =>
        TypingContext.PushNewColor (name.color, name.GetEnv (null));
        def expanded = Option.UnSome (macros.Get (name.id)).Run (ctx, parms);
        TypingContext.PopColor ();        
        expand_macro (ctx, expanded)

      | _ => expr
    }
  }

}
} // end ns
