open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Bind_types;

namespace Nemerle.Compiler {
(*
pass 2:
  Given a list of Type_decls resolve all Type_decl and Type variable
  references within it.
*)
  class Bind_types
    {
      type CTX = String_map(int);

      fun add_tyvars(ctx : CTX, tp : Typarms) : CTX =
        letfun add (ctx : CTX * CTX, name : string) : CTX * CTX =
          let id = Tyvars.add(name) in
          let (?local, ?global) = ctx in
          (local#add(name, id), global#add(name, id))
        in 
        let (?local, ?global) = 
          List.fold_left(add, (Map.string_map(), ctx), tp#tyvars) 
        in
        letfun addc (c : Constraint) : void =
          match local#find(c#tyvar) with [
            | Some (?id) =>
              Tyvars.add_constraint(id, c#ty)
            | None =>
              Message.error("unbound type variable " + c#tyvar + " in constraint")
          ]
        in {
          List.iter(addc, tp#constraints);
          global
        };
        
      fun run(decls : list (Type_decl)) : void =
        letfun do_tydecl(ctx : CTX, decl : Type_decl) : CTX =
          let ctx' = add_tyvars(ctx, decl#typarms) in
          ctx'
        and do_decl(ctx : CTX, decl : Class_member) : void = ()
        in 
        Treeutil.decl_walk(do_tydecl, do_decl, Map.string_map(), decls);
    }
  
} // end ns
