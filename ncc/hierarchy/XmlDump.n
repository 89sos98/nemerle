/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Utility;

using System.Xml;
using System.Text;

namespace Nemerle.Compiler 
{
  class XmlDoc {
    document : XmlDocument;
    docNode : XmlNode;
    mutable last_loc : Location;

    public this (comments : Map [Location, string], output : string) {
      this.Comments = comments;
      this.OutputFileName = output;
      
      document = XmlDocument ();
      _ = document.AppendChild (document.CreateXmlDeclaration ("1.0", null, null));
      def d = document.AppendChild (document.CreateElement ("doc"));
      def name = d.AppendChild (document.CreateElement ("assembly")).
        AppendChild (document.CreateElement ("name"));
      _ = name.AppendChild (document.CreateTextNode (this.OutputFileName));
      docNode = d.AppendChild (d.AppendChild (document.CreateElement ("members")));
    }
    
    OutputFileName : string;
    Comments : Map [Location, string];
    
    public Save () : void {
      document.Save (OutputFileName);
    }

    CreateMember (name : string) : XmlNode {
      def mem = document.CreateElement ("member");
      def attr = document.CreateAttribute("name");
      attr.Value = name;
      _ = mem.SetAttributeNode(attr);
      mem
    }

    DumpMember (m : IMember) : void {
      def full_name = m.DeclaringType.FullName + "." + m.Name;
      def (prefix, suffix) = 
        match (m.GetKind ()) {
          | MemberKind.Field => ("F:", "")
          | MemberKind.Method (method) =>
            def parms = List.Map (method.GetParameters (),
                                  fun (p : Typedtree.Fun_parm) {
                                    p.ty.SystemType.FullName
                                  });
            if (!(parms is []))                                  
              ("M:", "(" + Nemerle.Utility.NString.Concat (",", parms) + ")")
            else 
              ("M:", "")

          | MemberKind.Property => ("P:", "")
          | MemberKind.Type (tycon) => DumpType (tycon); ("", "")
          | MemberKind.Event => ("E:", "")
        }
      unless (prefix == "" && suffix == "") {
        def member = docNode.AppendChild (CreateMember (prefix + full_name + suffix));
        add_comments (member, m);
      }
    }

    variant XToken
    {
      | EmptyLine
      | EOF
      | Text { t : string; }
      | XmlStart { n : string; v : string; }
      | XmlEnd { n : string; }
      | WhiteSpace { w : string }
    }

    static tokenize (comment : string) : array [XToken]
    {
      def lines = comment.Split (array ['\n']);
      mutable all_stars = true;
      def white_space = array [' ', '\t', '\r', '\n'];
      def res = System.Collections.Generic.List ();

      for (mutable i = 0; i < lines.Length; ++i) {
        lines[i] = lines[i].TrimEnd (white_space);
        when (i > 0 && 
              lines[i].Trim (white_space) != "" && 
              !lines [i].TrimStart (white_space).StartsWith ("*"))
          all_stars = false;
      }

      when (all_stars)
        for (mutable i = 1; i < lines.Length; ++i)
          when (lines [i].Trim (white_space) != "")
            lines [i] = lines [i].TrimStart (white_space).Substring (1);

      def buf = string.Join ("\n", lines) + "\n";
      
      mutable i = 0; 
      while (i < buf.Length)
      {
        def start = i;

        def space_tab (ch) { ch == ' ' || ch == '\t' }
        def scan (pred) {
          while (i < buf.Length && pred (buf [i])) i++;
          buf.Substring (start, i - start)
        }

        if (space_tab (buf [i]))
          res.Add (XToken.WhiteSpace (scan (space_tab)));
        else if (buf [i] == '\n')
          match (scan (_ == '\n')) {
            | "\n" =>
              res.Add (XToken.WhiteSpace ("\n"));
            | s =>
              res.Add (XToken.WhiteSpace (s));
              res.Add (XToken.EmptyLine ());
          }
        else if (buf [i] == '<') {
          def v = scan (_ != '>');
          if (i == buf.Length)
            // location?
            Message.Warning ("unfinished XML tag");
          else i++;
          def v = v.Substring (1).Trim (white_space);
          if (v.StartsWith ("/"))
            res.Add (XToken.XmlEnd (v.Substring (1)));
          else {
            def idx = v.IndexOfAny (array [' ', '\t']);
            if (idx == -1)
              if (v.EndsWith ("/")) {
                def v = v.Substring (0, v.Length - 1);
                res.Add (XToken.XmlStart (v, ""));
                res.Add (XToken.XmlEnd (v));
              }
              else
                res.Add (XToken.XmlStart (v, ""));
            else {
              def name = v.Substring (0, idx);
              def args = v.Substring (idx);
              if (args.EndsWith ("/")) {
                def args = args.Substring (0, args.Length - 1);
                res.Add (XToken.XmlStart (name, args));
                res.Add (XToken.XmlEnd (name));
              } else
                res.Add (XToken.XmlStart (name, args));
            }
          }
        } else
          res.Add (XToken.Text (scan (c => c != '<' && c != '\n')));
      }

      res.Add (XToken.EOF ());
      res.ToArray ();
    }

    /*
     Top-level tags:
       <remarks>, <summary>, <example>, <exception>, <param>, <permission>,
       <returns>, <seealso>, <include>, <value>
     Other tags:
       <c>, <code>, <list>, <listheader>, <item>, <term>, <description>,
       <para>, <paramref>, <see>
    */
    
    parse_comment (comment : string) : XmlNode
    {
      def is_top_tag (_) {
        | "summary" | "remarks" | "example" | "exception" | "param"
        | "permission" | "returns" | "seealso" | "include" | "value" => true
        | _ => false
      }

      def is_text_holding (_) {
        | "para" | "code" | "list" => true
        | _ => false
      }

      def tokens = tokenize (comment).ToList ().GetEnumerator ();
      // stack of currently active tags, along with information if
      // they were user-supplied
      mutable tags = [];
      def sb = StringBuilder ("");

      def skip_ws () {
        match (tokens.Current) {
          | WhiteSpace | EmptyLine =>
            _ = tokens.MoveNext (); skip_ws ()
          | _ => {}
        }
      }

      def output (_ : XToken) {
        | EmptyLine 
        | EOF => {}
        | WhiteSpace (t)
        | Text (t) => _ = sb.Append (t)
        | XmlStart (n, v) => _ = sb.Append ("<" + n + v + ">");
        | XmlEnd (n) => _ = sb.Append ("</" + n + ">");
      }

      def output_and_move ()
      {
        output (tokens.Current);
        _ = tokens.MoveNext ();
      }

      def possibly_close (pred)
      {
        match (tags) {
          | (name, false) :: xs when pred (name) =>
            tags = xs;
            output (XToken.XmlEnd (name));
          | _ => {}
        }
      }

      def open_fake (name)
      {
        tags ::= (name, false);
        output (XToken.XmlStart (name, ""));
      }

      _ = tokens.MoveNext ();
      skip_ws ();

      match (tokens.Current) {
        | XmlStart (n, _) when is_top_tag (n) =>
          output_and_move ();
          skip_ws ();
          tags ::= (n, true);
        | _ =>
          open_fake ("summary")
      }

      while (! (tokens.Current is XToken.EOF))
      {
        def t = tokens.Current;
        match (t) {
          | EOF => {}

          | EmptyLine =>
            possibly_close (_ == "para");
            possibly_close (_ == "summary");

          | Text =>
            // TODO: for <code> we should strip some common prefix
            when (!tags.Exists ((n, _) => is_top_tag (n)))
              open_fake ("remarks");
            when (!tags.Exists ((n, _) => is_text_holding (n)))
              open_fake ("para");
            output (t);
            
          | XmlStart (n, _) =>
            when (is_text_holding (n) || is_top_tag (n))
              possibly_close (_ == "para");
            when (is_top_tag (n))
              // any auto summary/remarks
              possibly_close (is_top_tag);
            tags ::= (n, true);
            output (t);

          | XmlEnd (n) =>
            // close any auto tags at the top
            while (tags is (_, false) :: _)
              possibly_close (_ => true);
            match (tags) {
              | (n', true) :: xs when n' == n || n == "" =>
                tags = xs;
                output (XToken.XmlEnd (n'));
              | _ =>
                Message.Warning ($"trying to close XML tag <$n> that is not open")
            }

          | WhiteSpace =>
            output (t)
        }
        _ = tokens.MoveNext ();
      }

      while (tags is (_, false) :: _)
        possibly_close (_ => true);

      foreach ((n, true) in tags)
        Message.Warning ($"unclosed XML tag <$n>");

      def frag = document.CreateDocumentFragment ();
      //Message.Debug ($"comment: $sb");
      frag.InnerXml = sb.ToString ();
      frag
    }

    add_comments (x : XmlNode, mem : IMember) : void
    {
      def curr = mem.Location;

      def choose (loc : Location, com, acc) {
        if (loc.File == curr.File && 
            loc.CompareTo (curr) <= 0 && (curr.CompareTo (last_loc) < 0 || loc.CompareTo (last_loc) > 0))
          com;
        else
          acc
      }

      Util.locate (curr, {
        def comment = Comments.Fold (null, choose);
        when (comment != null && comment != "") {
          try {
            _ = x.AppendChild (parse_comment (comment));
          }
          catch {
            | e is XmlException =>
              Message.Warning ("Cannot parse XML in comment: " + e.Message);       
          }
        }
      });

      last_loc = curr;
    }

    public DumpType (t : TypeInfo) : void {
      def node = docNode.AppendChild (CreateMember ("T:" + t.FullName));
      add_comments (node, t);
      def mems = t.GetMembers (BindingFlags.Static %| BindingFlags.Instance %|
                               BindingFlags.Public %| BindingFlags.NonPublic %| 
                               BindingFlags.DeclaredOnly);
      List.Iter (mems, DumpMember);
    }
  }
} // end ns
