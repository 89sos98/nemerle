/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler 
{
  /** Represent top-level type constructor for a given type. */
  public variant MType
  {
    | Class {
        tycon : TypeInfo;
        args : list <TyVar>;
      }
    | TyVar {
        tyvar : StaticTyVar;
      }
    | Fun {
        from : TyVar;
        to : TyVar;
      }
    | Tuple {
        args : list <TyVar>;
      }
    | Array {
        t : TyVar;
        rank : int;
      }
    | Void

      /* Used when given value is required to have all the listed types.

         Invariant 1: the types listed cannot be in the subtyping relation
         pairwise.

         Invariant 2: there can be only Class() objects inside.
         
         This type is not expressible in the .NET type system directly,
         it can be however expressed with type variable bounds in some
         cases. */
    | Intersection {
        types : list <MType>;
      }


    /** Check for type equality, taking intersection types
        into account. 
        
        XXX it is not clear if it will be needed. */
    [Nemerle.OverrideObjectEquals]
    [Nemerle.NotImplemented]
    public Equals (t : MType) : bool
    {
    }


    /** Check for type equality, taking intersection types
        into account. If it's possible that types are equal -- enforce 
        that.  Assume non-seperated types. */
    public TryUnify (solver : Solver, t : MType) : bool
    {
      assert (!this.IsSeparated);
      assert (!t.IsSeparated);
      
      solver.EnsureClearState ();
      
      match ((this, t)) {
        | (Class (tc1, args1), Class (tc2, args2))
          when tc1.Equals (tc2) =>
          List.Iter2 (args1, args2, fun (t1 : TyVar, t2 : TyVar) {
            t1.Unify (t2)
          });
          !solver.InErrorState
          
        | (Intersection (l1), Intersection (l2)) 
          when List.Length (l1) == List.Length (l2) =>
          def ht = Hashtable ();
          foreach ((Class (tc, _)) as t in l1)
            ht [tc.GetId ()] = t;
          mutable cnt = 0;
          foreach ((Class (tc, _)) as t in l2)
            when (ht.Contains (tc.GetId ()))
              ++cnt;
          if (cnt == List.Length (l1)) {
            foreach ((Class (tc, _)) as t in l2)
              ht [tc.GetId ()].Unify (t);
            !solver.InErrorState
          } else false

        | _ => false
      }
    }


    /** Enforce [this] to be subtype of [t]. */
    public Require (s : Solver, t : MType) : void
    {
      match ((this, t)) {
        | (_, Class (tc, _)) 
          when tc.Equals (InternalType.Object_tc) => ()
          
        | (Class (tc1, args1), Class (tc2, args2)) =>
          match (tc1.SuperType (tc2)) {
            | Some (args) =>
              def subst = tc1.GetSubst (args1);
              List.Iter2 (args, args2 
                           fun (t : MType, tv : TyVar) { 
                             tv.Unify (subst.Apply (t)) 
                           });
            | None =>
              ReportError (solver, $ "$tc1 is not a subtype of $tc2 "
                                     "[simple require]")
          }
          
        | (Fun (f1, t1), Fun (f2, t2)) =>
          f2.Require (f1);
          t1.Require (t2);
          
        | (Tuple (l1), Tuple (l2)) 
          when List.Length (l1) == List.Length (l2) =>
          List.Iter2 (l1, l2, fun (x : TyVar, y : TyVar) { x.Require (y) })
          
        | (Array (t1, rank1), Array (t2, rank2))
          when rank1 == rank2 =>
          // XXX we allow array covariance here! we may want to change it
          t1.Require (t2)
        
        | (Void, Class (tc, _)) when tc.Equals (InternalType.Void_tc)
        | (Class (tc, _), Void) when tc.Equals (InternalType.Void_tc)
        | (Void, Void) => ()

        | (Array, Class (tc, _)) 
          when tc.Equals (InternalType.Array_tc) => ()

        | (TyVar (tv1), TyVar (tv2))
          when tv1.Equals (tv2) => ()

        | (TyVar (tv1), t2) =>
          tv1.LowerBound.Require (t2)

        | (Intersection (lst), (Class (tc, _)) as t2) =>
          def loop (_) {
            | (Class (tc', _)) as t1 :: xs =>
              if (tc'.SuperType (tc) matches Some)
                t1.Require (t2)
              else
                loop (xs)
            | [] =>
              ReportError (solver, $ "$(this) is not a subtype of $t "
                                     "[simple require, intersection]")
            | _ => assert (false)
          }
          loop (lst)
        
        | (t1, Intersection (lst)) =>
          foreach (t2 in lst)
            t1.Require (t2);

        | _ =>
          ReportError (solver, $ "$(this) is not a subtype of $t "
                                 "[simple require]")
      }
    }

    
    /** Enforce [this] to be equal [t]. */
    public Unify (s : Solver, t : MType) : void
    {
      match ((this, t)) {
        | (Intersection, Intersection) when TryUnify (s, t)
        | (Class, Class) when TryUnify (s, t) => ()
        
        | (Fun (f1, t1), Fun (f2, t2)) =>
          f1.Unify (f2);
          t1.Unify (t2);
          
        | (Tuple (l1), Tuple (l2)) 
          when List.Length (l1) == List.Length (l2) =>
          List.Iter2 (l1, l2, fun (x : TyVar, y : TyVar) { x.Unify (y) })
          
        | (Array (t1, rank1), Array (t2, rank2))
          when rank1 == rank2 =>
          t1.Unify (t2)
        
        | (Void, Class (tc, _)) when tc.Equals (InternalType.Void_tc)
        | (Class (tc, _), Void) when tc.Equals (InternalType.Void_tc)
        | (Void, Void) => ()

        | (TyVar (tv1), TyVar (tv2))
          when tv1.Equals (tv2) => ()

        | _ =>
          ReportError (solver, $ "the types $(this) and $t are not compatible "
                                 "[simple unify]")
      }
    }


    public override ToString () : string
    {
      match (this) {
        | Class (tc, []) =>
          match (tc.FullName) {
            | "Nemerle.Core.string"
            | "System.String" => "string"
            | "Nemerle.Core.int"
            | "System.Int32" => "int"
            | "Nemerle.Core.float"
            | "System.Single" => "float"
            | "Nemerle.Core.char"
            | "System.Char" => "char"
            | "Nemerle.Core.bool"
            | "System.Boolean" => "bool"
            | "System.Void" => "void"
            | name => name
          }

        | Class (tc, args) =>
          def args = List.Map (args, fun (x : TyVar) { x.ToString () });
          def args = NString.Concat (", ", args);
          $ "$tc<$args>"
          
        | TyVar (s) => s.ToString ()
        
        | Fun (t1, t2) =>
          $ "$t1 -> $t2"
          
        | Tuple (lst) =>
          def args = List.Map (lst, fun (x : TyVar) { x.ToString () });
          "(" + NString.Concat (" * ", args) + ")"

        | Array (t, 1) =>
          $ "array <$t>"
          
        | Array (t, n) =>
          $ "array.$n <$t>"
          
        | Void => "void"
        
        | Intersection (lst) =>
          def args = List.Map (lst, fun (x : TyVar) { x.ToString () });
          "[" + NString.Concat (" AND ", args) + "]"
      }
    }

   
    /** Check if given type cannot be supertyped by a plain type
        constructor. */
    public IsSeparated : bool
    {
      get {
        match (t) {
          | Class => false
          
          | TyVar
          | Fun
          | Tuple
          | Array
          | Void => true
          
          | Intersection (lst) =>
            foreach (x in lst)
              assert (!x.IsSeparated);
            false
        }
      }
    }

    internal Validate () : void
    {
      match (this) {
        | Intersection ([]) => assert (false)
        | Intersection ([_]) => assert (false)
        | Intersection (lst) =>
          def supers =
            List.FoldLeft (lst, Set (), fun (e, s : Set<TypeInfo>) {
              match (e) {
                | Class (tc, _) =>
                  def lst = List.Map (tc.GetSuperTypes (), 
                                      fun (_) { 
                                        | Class (tc, _) => tc
                                        | _ => assert (false)
                                      });
                  s.ReplaceList (lst)
                | _ => assert (false)
              }
            });
          assert (Set.FromList (lst).Intersect (supers).IsEmpty);

       | _ => ()
      }
    }

  }
}
