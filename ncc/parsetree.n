/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler.Parsetree {


public variant SyntaxElement {
  | SyntaxExpr { body : Expr; }
  | SyntaxType { body : Type; }
  | SyntaxCase { body : MatchCase; }
  | SyntaxCaseGuard { body : Expr; guard : option <Expr>; }
  | SyntaxFunDecl { body : Function_decl; }
  | SyntaxFunParm { body : Fun_parm; }
  | SyntaxTType { body : Type; }

  | SyntaxDeclaration { body : Class_member; }    
  | SyntaxTTypeBuilder { body : TypeBuilder; }
  | SyntaxTField { body : NemerleField; }
  | SyntaxTMethod { body : NemerleMethod; }
  | SyntaxTProperty { body : NemerleProperty; }
  | SyntaxTEvent { body : NemerleEvent; }
  | SyntaxTFunParm { body : Typedtree.Fun_parm; }
}

[Record]
public class DeclarationBase : Located
{
  public mutable name : Splicable_string;
  public mutable modifiers : Modifiers;

  public Name : string {
    get { Macros.NameOfSString (name).Id }
  }

  public Attributes : NemerleAttributes {
    get { modifiers.mods }
    set { modifiers.mods = value }
  }
}

[Record]
public class Constraint
{
  public tyvar : string * int;
  public ty : Type;
}

[Record]
public class Typarms
{
  public tyvars : list <string * int>;
  public constraints : list <Constraint>;
  
  public static Empty : Typarms = Typarms ([], []);
}

[Record]
public variant TopDeclaration : DeclarationBase
{
  | TD_namespace { decls : list <TopDeclaration>; }
  | TD_open 
  | TD_namespace_alias { alias : string; }
  | TD_attribute { body : Expr; }

  | TD_class {
    typarms : Typarms;
    mutable t_extends : list <Type>;
    decls : list <Class_member>;
  }
  | TD_alias {
    typarms : Typarms;
    ty : Type;
  }
  | TD_interface {
    typarms : Typarms;
    mutable t_extends : list <Type>;
    methods : list <Class_member>; // only iface_member
  } 
  | TD_variant {
    typarms : Typarms;
    mutable t_extends : list <Type>;
    mutable decls : list <Class_member>;
  }
  | TD_variant_option { decls : list <Class_member>; }
    
  | TD_macro {
    header : Fun_header;
    synt : list <Expr>;
    expr : Expr;
  }
  | TD_delegate { header : Fun_header; }
  | TD_enum {
    t_extends : list <Type>;
    decls : list<Class_member>;
  }

  public this () { base (Splicable_string.SS_string (Name ([])), Modifiers.Empty) }
}

[Record]
public variant Class_member : DeclarationBase
{
  | M_type { td : TopDeclaration; }
  | M_field { ty : Type; }
  | M_function { 
      header : Fun_header;
      mutable kind : Fun_kind;
      mutable body : Fun_body;
    }
  | M_property {
      ty : Type;
      prop_ty : Type;
      dims : list <Fun_parm>; // parameters of indexer property
      mutable get : option <Class_member>;
      mutable set : option <Class_member>;
    }
  | M_event {
      ty : Type;
      mutable add : option <Class_member>;
      mutable remove : option <Class_member>;
    }
  | M_enum { value : option <Expr>; }

  /** accessible only for Class_member.M_function, when its Fun_body is not typed or compiled */
  public Body : Expr {
    get {
      match (this) {
        | Class_member.M_function { body = bd } =>
          match (bd) {
            | Fun_body.FB_parsed_expr (expr) => expr
            | Fun_body.FB_typed_expr =>
              Message.error ("Body of typed method is not accessible");
              null
            | Fun_body.FB_compiled_expr =>
              Message.error ("Body of compiled method is not accessible");
              null
            | Fun_body.FB_extern 
            | Fun_body.FB_abstract => <[ () ]>
          }
        | _ =>
          Message.error ("Body is accessible only for Class_member.M_function variant option");
          null
      }
    }
    set {
      match (this) {
        | (Class_member.M_function) as fn =>
          fn.body = Fun_body.FB_parsed_expr (value);
        | _ =>
          Message.error ("Body is accessible only for Class_member.M_function variant option")
      }
    }
  }
}

/** class encapsulating name of variable for purpose of
    quotation and renaming
 */    
public class Name : Nemerle.IComparable <Name>
{
  public idl : list <string>;  
  public color : int;
  public context : GlobalEnv;

  public this (idl : list<string>)
  {
    this.idl = idl;
    this.color = TypingContext.MacroColor;
    this.context = null; // no global context
  }
  
  public this (id : string)
  {
    this.color = TypingContext.MacroColor;
    this.context = null; // no global context
    idl = [id]
  }

  public this (id : list <string>, color : int, context : GlobalEnv)
  {
    this.color = color;
    this.context = context;
    idl = id;
  }

  static public NameInCurrentColor (id : list <string>, context : GlobalEnv) : Name
  {
    Name (id, TypingContext.MacroColor, context)
  }


  /** returns the first part of the name (in most cases it is entime name)
   */
  public Id : string
  {
    get { Nemerle.Collections.List.Head (idl) }
  }

  /** return fully qualified name stored in this instance (in most cases it doesnt
                                                           differ from Id)
   */                                                           
  public FullId : string
  {
    get { Nemerle.Utility.NString.Concat (".", idl) }
  }

  public Equals (other : Name) : bool
  {
    color == other.color && lexicographic_compare (idl, other.idl) == 0
  }
  
  public CompareTo (other : Name) : int
  {
    if (color == other.color || color < 0 || other.color < 0)
      lexicographic_compare (idl, other.idl)
    else
      color - other.color
  }

  lexicographic_compare (my : list <string>, oth : list <string>) : int {
    | (x :: xs, y :: ys) =>
      if (x == y) lexicographic_compare (xs, ys)
      else string.CompareOrdinal (x, y)
    | ([], []) => 0
    | (_, []) => 1
    | ([], _) => -1
  }
  
  public GetEnv (default : GlobalEnv) : GlobalEnv
  {
    if (context != null)
      context
    else
      default
  }
}

[Record]
public variant Splicable_string : Located 
{
  | SS_string { body : Name; }
//  | Splicable_string.SS_int { body : int; }    
  | SS_spliced_expr { expr : Expr; }
}

[Record]
public variant Splicable_int : Located
{
  | SI_int { body : int; }
  | SI_spliced_expr { expr : Expr; }
}

public variant Type
{
  | T_app {
      tycon : Splicable_string;
      args : list <Type>;
    }
  | T_ref { t : Type; }
  | T_out { t : Type; }
  | T_fun { from : Type; to : Type; }
  | T_void
  | T_prod { args : list <Type>; }
  | T_array { t : Type; rank : Splicable_int; }
  | T_infer

  | T_spliced { expr : Expr; }
  | T_type_list { body: Type; }
  
  | T_typed { body : Typedtree.Type; }
}

public class Fun_parm : DeclarationBase
{
  public ty : Type;
  public this (name : Splicable_string, ty : Type, modifiers : Modifiers) 
  {
    base (Location.Default, name, modifiers);
    this.ty = ty;
  }
  public this (loc : Location, name : Splicable_string, ty : Type,
               modifiers : Modifiers) 
  {
    base (loc, name, modifiers);      
    this.ty = ty;
  }
}
  
public class Fun_header : Located
{
  public typarms : Typarms;
  public mutable name : Splicable_string;
  public ret_type : Type;
  public parms : list <Fun_parm>;

  public this () {}
  public this (loc : Location, name : Splicable_string, ret_type : Type, 
               parms : list <Fun_parm>) 
  {
    base (loc);
    this.typarms = Typarms.Empty;
    this.name = name;
    this.ret_type = ret_type;
    this.parms = parms;
  }
  
  public this (typarms : Typarms, 
               name : Splicable_string, 
               ret_type : Type, 
               parms : list <Fun_parm>) 
  {
    this.typarms = typarms;
    this.name = name;
    this.ret_type = ret_type;
    this.parms = parms;
  }

  public this (loc : Location,
               typarms : Typarms, 
               name : Splicable_string, 
               ret_type : Type, 
               parms : list <Fun_parm>) 
  {
    base (loc);
    this.typarms = typarms;
    this.name = name;
    this.ret_type = ret_type;
    this.parms = parms;
  }
}

[Record]
public class Function_decl
{
  public header : Fun_header;
  public mutable body : Expr;
}

[Record]
public class MatchCase
{
  public this (patterns : list <Expr * option <Expr>>, body : Expr)
  {
    this (patterns, body, false)
  }
    
  public patterns : list <Expr * option <Expr>>;
  public body : Expr;
  public disable_warnings : bool;
}

[Record]
public variant Expr : Located 
{
  | E_Underscore
  | E_As { pat : Expr; name : Splicable_string; }
  | E_DefPattern { pattern : Expr; val : Expr; }
  | E_Match { expr : Expr; cases : list <MatchCase>; }
  | E_Application { func : Expr; arg : Expr; }    
 
  | E_ref { name : Name; }
  | E_member { obj : Expr; member : Splicable_string; }
  | E_call { func : Expr; parms : list <Expr>; }
  | E_assign { target : Expr; source : Expr; }
  | E_let { is_ref : bool; name : Splicable_string; val : Expr; }
  | E_letfun { funs : list <Function_decl>; }
  | E_lambda { decl : Function_decl; }
  | E_raise { exn : Expr; }
  | E_try_with { body : Expr; exn : Splicable_string; exn_ty : Type; 
            handler : Expr; }
  | E_try_finally { body : Expr; handler : Expr; }
  | E_literal { val : Literal; }
  | E_this
  | E_base
  | E_typeof { ty : Type; }
  | E_type_conversion { expr : Expr; ty : Type; }  // (expr :> ty)
  | E_type_enforcement { expr : Expr; ty : Type; } // (expr : ty)
  | E_sequence { body : list <Expr>; }
  | E_tuple { args : list <Expr>; }
  | E_mkarray { rank : Expr; args : Expr; }
  | E_empty_array { sizes : list <Expr>; }
  | E_indexer { obj : Expr; args : list <Expr>; }

  | E_parm_by_ref { parm : Expr; }
  | E_parm_out { parm : Expr; }

  // macros stuff    
  | E_macrocall { name : Name; ns : GlobalEnv.NamespaceND;
             parms : list <SyntaxElement>; }
  | E_quoted { body : SyntaxElement; }
  | E_spliced { body : Expr; }
  | E_expr_list { body : Expr; }
  | E_typed_expr { body : Typedtree.Expr; }
  | E_typed_pattern { body : Typedtree.Pattern; }  
}
} // Nemerle.Compiler

