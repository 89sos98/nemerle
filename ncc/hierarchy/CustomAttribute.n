/*
 * Copyright (c) 2004-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
using System.IO;

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public abstract class AttributeCompilerClass : ICompilerContextBoundObject
  {
    public Manager : ManagerClass { get; }
    protected InternalType : InternalTypeClass { get { Manager.InternalType } }

    protected this (man : ManagerClass)
    {
      Manager = man;
    }

    public abstract ResolveAttribute (env : GlobalEnv, expr : PExpr, expect_exact : TypeInfo = null)
    : option [TypeInfo * list [PExpr]];
  }

  public abstract partial class TypesManager
  {
    public AddAssemblyAttribute (env : GlobalEnv, attr : Parsetree.PExpr) : void {
      def add (phase) {
        def suff = AttributeMacroExpansion.Suffix (MacroTargets.Assembly, phase);
        match (MacroRegistry.lookup_macro (env, attr, suff)) {
          | None => false
          | Some =>
            def expansion = AssemblyAttributeMacroExpansion (MacroTargets.Assembly, phase,
                                                             attr, [], null, null, env);
            AddMacroExpansion (expansion);
            true
        }
      }
      def b1 = add (MacroPhase.BeforeInheritance);
      def b2 = add (MacroPhase.BeforeTypedMembers);
      def b3 = add (MacroPhase.WithTypedMembers);
      if (b1 || b2 || b3)
        ()
      else
        assembly_attributes.Add (env, attr);
    }
  }

  public partial class Modifiers
  {
    public IsCustomAttributeDefined(attributeFullName : string, env : GlobalEnv) : bool
    {
      FindAttribute(env.Manager.LookupTypeInfo(attributeFullName), env).IsSome
    }

    /// Finds first attribute of specified type
    public FindAttribute (lookingFor : TypeInfo, env : GlobalEnv) : option [PExpr]
    {
      def compiler = env.Manager.AttributeCompiler;
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr, lookingFor) is Some(_))
          Nemerle.Imperative.Return(Some(expr));
      None()
    }

    /// Finds attribute of specified type
    public FindAttributeWithArgs(lookingFor : TypeInfo, env : GlobalEnv) : option[PExpr * list [PExpr]]
    {
      def compiler = env.Manager.AttributeCompiler;
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr, lookingFor) is Some((_, args)))
          Nemerle.Imperative.Return(Some(expr, args));
      None()
    }

    /// Finds all attributes of specified type
    public FindAttributesWithArgs(lookingFor : TypeInfo, env : GlobalEnv) : list[PExpr * list [PExpr]]
    {
      def compiler = env.Manager.AttributeCompiler;
      mutable result = [];
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr, lookingFor) is Some((_, args)))
          result ::= (expr, args);
      result
    }

    public AttributeTypes(env : GlobalEnv) : list[TypeInfo]
    {
      def compiler = env.Manager.AttributeCompiler;
      mutable result = [];
      foreach(expr in custom_attrs)
        when(compiler.ResolveAttribute(env, expr) is Some((ti, _)))
          result ::= ti;
      result
    }
  }
}


