/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler 
{
  module ConstantFolder
  {
    is_known_operator (name : string) : bool
    {
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "%^"
      | "%|"
      | "%&"
      | "&&"
      | "||"
      | "!"
      | "~" => true
      | _ => false
    }

    is_flag_enum (t : System.Type) : bool
    {
      t.GetCustomAttributes (typeof (System.FlagsAttribute), false).Length > 0
    }

    underlaying_enum_type (t : System.Type) : System.Type
    {
      def res =
        NArray.Fold (t.GetFields (), null, fun (elt : System.Reflection.FieldInfo, acc) {
          if (elt.IsStatic) {
            assert (acc == null);
            elt.FieldType
          } else
            acc
        });
      assert (res != null);
      res
    }

    enum_field_value (env : GlobalEnv, expr : Expr) : Expr
    {
      match (Util.qid_of_expr (expr, env)) {
        | Some ((name, env)) =>
          def val = 
            List.FoldLeft (env.ExpandName (name), None (),
              fun (fullname, acc) {
                match (GlobalEnv.LookupExactType (Util.get_ns (fullname))) {
                  | Some (t) =>
                    def is_enum_field (m : IMember) {
                      m.IsStatic () && match (m.GetKind ()) {
                        | MK_field => true
                        | _ => false
                      }
                    };
                    def members = t.LookupMember (Util.strip_ns (fullname));
                    match (List.Filter (members, is_enum_field)) {
                      | [] => acc
                      | [x] =>
                        match (acc) {
                          | Some (y) when (y : IMember).GetId () != x.GetId () =>
                            Message.error ("the field name `" + name + "' is ambigious");
                            Some (x)
                          | _ => Some (x)
                        }
                      | _ =>
                        Message.error ("the field name `" + name + 
                                       "' is ambigious in its own type");
                        acc
                    }
                  | None => acc
                }
              });
          match (val) {
            | Some (field) =>
              def field = (field :> IField);
              def enum_ty = field.GetDeclaringTycon ().GetSystemType ();
              def under_ty = underlaying_enum_type (enum_ty);
              def obj = field.GetFieldInfo ().GetValue (null);
              def r (l) { E_literal (L_enum (l, enum_ty)) };
              if (under_ty.Equals (typeof (int)))
                r (L_int ((obj :> int)))
              else if (under_ty.Equals (typeof (long)))
                r (L_long ((obj :> long)))
              else
                expr
            | None => expr
          }
        | None => expr
      }
    }

    fold_binary_operator (env : GlobalEnv, name : string, 
                          e1 : Expr, e2 : Expr, expr : Expr) : Expr
    {
      def e1 = FoldConstants (env, e1);
      def e2 = FoldConstants (env, e2);
      match ((e1, e2)) {
        | (E_literal (L_int (n1)), E_literal (L_int (n2))) =>
          def r (n) { E_literal (L_int (n)) };
          match (name) {
            | "+" => r (n1 + n2)
            | "-" => r (n1 - n2)
            | "*" => r (n1 * n2)
            | "/" => r (n1 / n2)
            | "%" => r (n1 % n2)
            | "%|" => r (n1 %| n2)
            | "%&" => r (n1 %& n2)
            | "%^" => r (n1 %^ n2)
            | _ => expr
          }
          
        | (E_literal (L_long (n1)), E_literal (L_long (n2))) =>
          def r (n) { E_literal (L_long (n)) };
          match (name) {
            | "+" => r (n1 + n2)
            | "-" => r (n1 - n2)
            | "*" => r (n1 * n2)
            | "/" => r (n1 / n2)
            | "%" => r (n1 % n2)
            | "%|" => r (n1 %| n2)
            | "%&" => r (n1 %& n2)
            | "%^" => r (n1 %^ n2)
            | _ => expr
          }
        
        | (E_literal (L_enum (L_int (n1), t1)), 
           E_literal (L_enum (L_int (n2), t2))) 
             when t1.Equals (t2) && is_flag_enum (t1) =>
          def r (n) { E_literal (L_enum (L_int (n), t1)) };
          match (name) {
            | "%|" => r (n1 %| n2)
            | "%&" => r (n1 %& n2)
            | "%^" => r (n1 %^ n2)
            | _ => expr
          }

        | _ => expr
      }
    }
    
    internal FoldConstants (env : GlobalEnv, expr : Expr) : Expr
    {
      match (expr) {
        | <[ $(name : dyn) ($e1, $e2) ]> when is_known_operator (name) =>
          fold_binary_operator (env, name, e1, e2, expr)
  //      | <[ $(name : dyn) ($e1) ]> when is_known_operator (name) =>
  
        | <[ $_o . $_f ]>
        | <[ $(_ : var) ]> => 
          enum_field_value (env, expr)

        | _ => expr
      }
    }
  }
}
