(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;

namespace Nemerle.Compiler {

// it is to be extended when we'll have generics
public variant CG_type
  {
    | CT_ref { name : string; }
    | CT_void
    | CT_object
    | CT_bool
    | CT_unreached
    | CT_tuple { arity : int; }
    | CT_fun { arity : int; }
    | CT_array { t : CG_type; }
  }

public class CG_member_base
  {
    public mutable loc : Location;
    public mutable name : string;
    public mutable extern_name : string;
    public mutable attrs : list (string);
    public this () 
      {
        this.loc <- Location_stack.top ();
        this.name <- "";
        this.extern_name <- "";
        this.attrs <- Nil ();
      }
  }

public variant CM_kind
  {
    | CK_interface
    | CK_class
    | CK_struct
  }
  
public variant CG_member extends CG_member_base
  {
    | CM_class
        { 
          mutable ns : string;
          mutable kind : CM_kind;
          mutable inheritance : list (CG_type);
          mutable decls : list (CG_member);
        }

    | CM_method
        { 
          parms : list (CG_val);
          mutable ret_type : CG_type;
          mutable body : CG_expr;
        }

    | CM_field
        {
          ty : CG_type;
        }

    | CM_property
        {
          ty : CG_type;
        }
  }
  
public class CE_base
  {
    public mutable loc : Location;
    public this () {}
  }

public class CG_val
  {
    public loc : Location;
    public name : string;
    public mutable ty : CG_type;
    public val : CG_expr;
  }
  
public variant CG_expr extends CE_base 
  { 
    | CE_ref { decl : CG_val; }
    | CE_global_ref { decl : CG_member; } // not class
    | CE_ctor_ref { klass : CM_class; }
    | CE_field_ref { obj : CG_expr; fld : CM_field; }
    | CE_property_ref { obj : CG_expr; fld : CM_property; }
    | CE_method_ref { obj : CG_expr; meth : CM_method; }
    | CE_tuple_ref { obj : CG_expr; pos : int; }
    | CE_call { func : CG_expr; parms : list (CG_expr); }
    | CE_assign { target : CG_expr; source : CG_expr; }
    | CE_let { name : CG_val; body : CG_expr; }
    | CE_has_type { expr : CG_expr; ty : CG_type; }
    | CE_raise { exn : CG_expr; }
    | CE_if { ty : CG_type; cond : CG_expr; e_then : CG_expr; e_else : CG_expr; }
    | CE_true
    | CE_false
    | CE_try_with { body : CG_expr; exn : CG_val; handler : CG_expr; }
    | CE_try_finally { body : CG_expr; handler : CG_expr; }
    | CE_literal { val : Literal; }
    | CE_this
    | CE_skip
    | CE_cast { expr : CG_expr; ty : CG_type; }
    | CE_sequence { body : list (CG_expr); }
    | CE_tuple_ctor { exprs : list (CG_expr); }
    | CE_array { initializers : list (CG_expr); }
    | CE_indexer { obj : CG_expr; args : list (CG_expr); }

    | CE_none
  }
 
}
