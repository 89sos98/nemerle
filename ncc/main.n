/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is the main compiler file. But all it does it running parser
 * (parser.n) and transferring control to Passes.run function (from
 * passes.n).
 *
 * Main file also catches some exceptions.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

namespace Nemerle.Compiler 
{
  module MainClass
  {
    public Main () : void
    {
      try
        do_main ()
      catch {
        | e : System.IO.FileNotFoundException =>
          Message.error (e.Message)
        | e : Recovery =>
          bomb (e, "got Recovery exception")
        | e : System.ArgumentException =>
          bomb (e, "got ArgumentException (" + e.Message + ")")
        | e : MatchFailureException =>
          bomb (e, "got MatchFailureException exception")
        | e : ICE =>
          bomb (e, e.msg)
        | e : AssertionException =>
          bomb (e, e.Message)
        | e : AssemblyFindException =>
          Message.error (e.Message);
          System.Environment.Exit (3);
        | e : System.Exception =>
          bomb (e, "got some unknown exception " + e.ToString ())
      };

      Message.maybe_bailout();
    }
    
    bomb (e : System.Exception, msg : string) : void
    {
      Passes.KillProgressBar ();
      Message.maybe_bailout (true);
      Message.error (sprintf ("internal compiler error: %s\n%s\n", msg, e.StackTrace));
      System.Environment.Exit (2);
    }

    do_main () : void {
      mutable files = [];
      mutable no_macros = false;
      mutable no_stdlib = false;

      def print_version () {
        System.Console.Error.Write ("Nemerle Compiler (ncc) version 0.1.3.99 (SVN)\n"
                                    "(c) 2003, 2004 University of Wroclaw,"
                                    " All rights reserved.\n");
        System.Environment.Exit (0);
      };

      def split_opt (s) {
        if (s == null)
          []
        else {
          def split = NString.Split (s, array [' ', '\t', '\n', '\r']);
          def split = List.Map (split, fun (x : string) { x.Trim () });
          List.Filter (split, fun (x) { x != "" })
        }
      };
      
      def execute_pkgconfig (opt : string) {
        def pkg = System.Diagnostics.Process ();
        pkg.StartInfo.FileName = "pkg-config"; 
        pkg.StartInfo.Arguments = ("--libs " + opt);
        pkg.StartInfo.RedirectStandardOutput = true;
        pkg.StartInfo.RedirectStandardError = true;        
        pkg.StartInfo.UseShellExecute = false;
        mutable result = "";
        try 
        {
          ignore (pkg.Start ());
          result = pkg.StandardOutput.ReadLine ();
          pkg.WaitForExit ();
        }
        catch { 
          | _ : System.Exception =>
            Message.warning ("pkg-config execution failed")
        };
        match (split_opt (result)) {
          | [] => ["-r", opt]
          | x => x
        }
      };
      def execute_fromfile (s : string) {
        try {
          // Create an instance of StreamReader to read from a file.
          // The using statement also closes the StreamReader.
          mutable result = "";
          using (sr = System.IO.StreamReader(s))
            result = sr.ReadToEnd ();
          split_opt (result)
        }
        catch {
          | _ : System.Exception =>
            Message.error ("cannot read response file `" + s + "'");
            []
        }  
      };
      
      def opts = [
        Getopt.Flag (name = "-xml", 
                     aliases = ["-x"], 
                     help = "Output XML representation of AST (for documentation)",
                     handler = fun () { 
                       Flags.just_dump_xml = true;
                       LexerFile.store_comments = true;
                     }),
        Getopt.Flag (name = "-target-exe", 
                     aliases = ["-texe"],
                     help = "Build an executable file",
                     handler = fun () { Flags.target_is_library = false; }),
        Getopt.Flag (name = "-target-library", 
                     aliases = ["-tdll"], 
                     help = "Build a library",
                     handler = fun () { Flags.target_is_library = true; }),
        Getopt.String (name = "-out",
                       aliases = ["-o"],
                       help = "Output file name",
                       handler = fun (s) { Flags.output_file_name = s }),
        Getopt.String (name = "-reference",
                       aliases = ["-r", "-ref"],
                       help = "Link specified assembly",
                       handler = fun (s) { Flags.referenced_libraries = 
                         s :: Flags.referenced_libraries
                       }),
        Getopt.String (name = "-library-path",
                       aliases = ["-lib", "-L"],
                       help = "Add specified directory to library search path",
                       handler = LibraryReferenceManager.AddSearchDirectory),

        Getopt.String (name = "-define",
                       aliases = ["-def", "-D"],
                       help = "Define preprocessor symbol for conditional compilation",
                       handler = fun (x) { LexerFile.command_defines.Set (x, true) }),
                       
        Getopt.SubstitutionString (name = "-pkg-config",
                       aliases = ["-pkg", "-p"],
                       help = "Link to assemblies listed by pkg-config run on"
                              " given string",
                       substitute = execute_pkgconfig),

        Getopt.SubstitutionString (name = "-from-file",
                       aliases = ["@"],
                       help = "Read command line options from given file", 
                       substitute = execute_fromfile),
                       
        Getopt.Flag (name = "-no-stdmacros",
                     help = "Do not load standard macros",
                     handler = fun () { no_macros = true }),
        Getopt.Flag (name = "-no-stdlib",
                     help = "Do not load Nemerle.dll",
                     handler = fun () { no_stdlib = true }),
        Getopt.Flag (name = "-use-loaded-corlib",
                     help = "Use already loaded mscorlib.dll and System.dll",
                     handler = fun () { Flags.use_loaded_corlib = true }),
                          
        Getopt.Flag (name = "-ignore-confusion",
                     help = "Output stack trace even when seen errors",
                     handler = fun () { Flags.ignore_confusion = true }),
        Getopt.Flag (name = "-general-tail-call-opt",
                     aliases = ["-Ot"],
                     help = "Enable general tail call optimization",
                     handler = fun () { Flags.general_tail_call_opt = true }),

        Getopt.Flag (name = "-boolean-constant-matching-opt",
                     aliases = ["-Obcm"],
                     help = "Enable boolean constant matching optimization",
                     handler = fun () {
                       Flags.constant_boolean_matching_opt = true
                     }),
        Getopt.Flag (name = "-ordinal-constant-matching-opt",
                     aliases = ["-Oocm"],
                     help = "Enable ordinal constant matching optimization",
                     handler = fun () {
                       Flags.constant_ordinal_matching_opt = true
                     }),
        Getopt.Flag (name = "-string-constant-matching-opt",
                     aliases = ["-Oscm"],
                     help = "Enable string constant matching optimization",
                     handler = fun () {
                       Flags.constant_string_matching_opt = true
                     }),
      
        Getopt.Flag (name = "-no-color",
                     help = "Disable ANSI coloring of error/warning/hint messages",
                     handler = fun () { Flags.color_messages = false }),
        Getopt.Flag (name = "-pedantic-lexer",
                     help = "Enable some pedantic checks for illegal characters"
                     " in input stream",
                     handler = fun () { Flags.pedantic_lexer = true }),
        Getopt.Flag (name = "-version",
                     aliases = ["-V"],
                     help = "Output version information and exit",
                     handler = print_version),
        Getopt.Flag (name = "-no-progress-bar",
                     aliases = ["-q"],
                     help = "Disable progress bar",
                     handler = fun () { Flags.progress_bar = false; }),
        Getopt.NonOption (name = "",
                          help = "Specify file to compile",
                          handler = fun (s) { files = s :: files })
      ];

      Getopt.Parse (opts);

      match (files) {
        | [] =>
          Getopt.Error ("need at least one file to compile\n" + Getopt.Usage (opts))
        | _ =>
          unless (no_macros)
            LibraryReferenceManager.LoadMacrosFrom ("Nemerle.Macros");

          unless (no_stdlib) {
            LibraryReferenceManager.AddLibrary ("mscorlib");
            LibraryReferenceManager.AddLibrary ("System");
            LibraryReferenceManager.AddLibrary ("Nemerle");
          };

          List.Iter (List.Rev (Flags.referenced_libraries), 
                     LibraryReferenceManager.AddLibrary);

          MacroRegistry.LoadSyntaxExtensions ("Nemerle.Core");
                     
          def trees = List.Map (List.Rev (files), fun (f) {
            Parser.parse (LexerFile (f))
          });

          Passes.run (trees)
      }
    }
  }
}
