/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public class TypingContext
{
  public this_ptr_decl : option <LocalValue>;
  public in_ctor : bool;
  public env : GlobalEnv;
  public tenv : Tyvar.TEnv;
  public current_fun : Fun_header;
  locals : NemerleMap <PT.Name, LocalValue>;
  public parent_type : Tyinfo;
  public in_tail_position : bool;

  public static mutable MacroColor : int;
  public static mutable MacroUseColor : int;
  public static mutable MacroUseContext : GlobalEnv;
  static mutable max_macro_color : int;
  static mutable colors_stack : list<int * int * GlobalEnv>;

  public static this () 
  { 
    MacroColor <- 1;
    MacroUseColor <- 1;
    MacroUseContext <- null;
    max_macro_color <- 1;
  }
                         
  public this (this_ptr_decl : option <LocalValue>,
               in_ctor : bool, env : GlobalEnv, tenv : Tyvar.TEnv,
               current_fun : Fun_header,
               locals : NemerleMap <PT.Name, LocalValue>,
               parent_type : Tyinfo,
               in_tail_position : bool)
  {
    this.this_ptr_decl <- this_ptr_decl;
    this.in_ctor <- in_ctor;
    this.env <- env;
    this.tenv <- tenv;
    this.current_fun <- current_fun;
    this.locals <- locals;
    this.parent_type <- parent_type;
    this.in_tail_position <- in_tail_position;

  }

  register_local (val : LocalValue) : void
  {
    val.parent_fun.all_locals <- val :: val.parent_fun.all_locals
  }

  public static NewColor () : int
  {
    max_macro_color <- max_macro_color + 1;
    max_macro_color
  }
  
  /** creates new color for execution of macro expansion, stores
      this color as top of the stack, together with [macro_use]
      as context color of currently executed macro
   */   
  public static PushNewColor (use_color : int, use_context : GlobalEnv) : void
  {
    colors_stack <- (MacroColor, MacroUseColor, MacroUseContext) :: colors_stack;
    max_macro_color <- max_macro_color + 1;
    MacroColor <- max_macro_color;
    MacroUseColor <- use_color;
    MacroUseContext <- use_context;
  }

  /** bring color context of previous execution of macro
      (occurs when macro expansion execution finishes

      <remarks>
      Assumes that [PushNewColor] was called before
      </remarks>
   */    
  public static PopColor () : void
  {
    match (colors_stack) {
      | (col, use_col, use_ctx) :: rest =>
        colors_stack <- rest;
        MacroColor <- col;
        MacroUseColor <- use_col;
        MacroUseContext <- use_ctx;
      | [] =>
        Util.ice ("pop from empty stack of macro colors...")
    }
  }
  
  public WithTEnv (e : Tyvar.TEnv) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, e, current_fun, locals, 
                   parent_type, in_tail_position)
  }
  
  public WithCurrentFunction (h : Fun_header) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, h, locals, 
                   parent_type, in_tail_position)
  }

  public WithLocal (val : LocalValue) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, 
                   locals.Replace (PT.Name ([val.name], val.color, null), val), parent_type, 
                   in_tail_position)
  }
  
  public WithLocals (vals : list <LocalValue>) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, 
                   List.FoldLeft (vals, locals, fun (v : LocalValue, m : NemerleMap <PT.Name, LocalValue>) 
                                { m.Replace (PT.Name ([v.name], v.color, null), v) }), 
                   parent_type, in_tail_position)
  }
  
  public WithInTailPosition (itp : bool) : TypingContext
  {
    if (itp == in_tail_position) this
    else
      TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, locals,
                     parent_type, itp)
  }
  
  public Closurise (val : LocalValue) : void
  {
    def head = val.parent_fun;
    when (head.id != current_fun.id && !val.used_in.Member (current_fun.id))
      val.used_in <- val.used_in.Add (current_fun.id, current_fun)
  }
  
  public DefineLocal (n : string, c : int, k : LocalValueKind, ty : Type) : LocalValue
  { 
    def val = LocalValue (n, c, k, ty, current_fun);
    register_local (val);
    val
  }

  public DefineLocal (n : PT.Name, k : LocalValueKind, ty : Type) : LocalValue
  { 
    DefineLocal (n.id, n.color, k, ty)
  }

  public LookupLocal (n : PT.Name) : option <LocalValue>
  {
    locals.Find (n)
  }

}

}
