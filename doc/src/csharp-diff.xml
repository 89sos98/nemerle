<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Quick summary of differences between Nemerle and C#</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document lists basic differences between Nemerle and C#
        in a terse form. If you know Java or C++ you also should be able
        to use it.
      </p>
    </body>
  </section>


  <section id="syntax-changes">
    <title>Syntax changes</title>
    <body>
      <table>
        <row>
          <cell header="yes">C#</cell>
          <cell header="yes">Nemerle</cell>
          <cell header="yes">Remarks</cell>
        </row>

        <!-- TODO: sort it. -->
        
        <row>
          <cell><tt>((<meta>type</meta>) <meta>expr</meta>)</tt></cell>
          <cell><tt>(<meta>expr</meta> :> <meta>type</meta>)</tt></cell>
          <cell>Runtime type cast, allows for downcasts and upcasts.</cell>
        </row>
        
        <row>
          <cell><tt>((<meta>type</meta>) <meta>expr</meta>)</tt></cell>
          <cell><tt>(<meta>expr</meta> : <meta>type</meta>)</tt></cell>
          <cell>Static cast, allow only upcast.</cell>
        </row>
        
        <row>
          <cell><tt>new <meta>Class</meta> (<meta>parms</meta>)</tt></cell>
          <cell><tt><meta>Class</meta> (<meta>parms</meta>)</tt></cell>
          <cell></cell>
        </row>
        
        <row>
          <cell><tt>new <meta>Class</meta> [<meta>size</meta>]</tt></cell>
          <cell><tt>array (<meta>size</meta>)</tt></cell>
          <cell>If the type can be inferred (most of the time).</cell>
        </row>
        
        <row>
          <cell><tt>new <meta>Class</meta> [<meta>size</meta>]</tt></cell>
          <cell>
            <tt>(array (<meta>size</meta>) : array (<meta>Class</meta>))</tt>
          </cell>
          <cell>If the type cannot be inferred.</cell>
        </row>
        
        <row>
          <cell>
            <tt>
              { <meta>expr_1</meta>, <meta>expr_1</meta>, ..., 
                <meta>expr_n</meta> }
            </tt>
          </cell>
          <cell>
            <tt>
              array [<meta>expr_1</meta>, 
                     <meta>expr_1</meta>, ..., 
                     <meta>expr_n</meta>]
            </tt>
          </cell>
          <cell>The array constructor.</cell>
        </row>
        
        <row>
          <cell>
            <tt>
              <meta>expr_1</meta> = <meta>expr_2</meta>;
            </tt>
          </cell>
          <cell>
            <tt>
              <meta>expr_1</meta> &lt;- <meta>expr_2</meta>;
            </tt>
          </cell>
          <cell>The assignment operator.</cell>
        </row>
        
        <row>
          <cell>
            <tt>
              <meta>expr_1</meta> = <meta>expr_2</meta> = <meta>expr_3</meta>;
            </tt>
          </cell>
          <cell>
            <tt>
              def tmp = <meta>expr_3</meta>;<br/>
              <meta>expr_1</meta> &lt;- tmp;<br/>
              <meta>expr_2</meta> &lt;- tmp;
            </tt>
          </cell>
          <cell>The type of assignment operator is <tt>void</tt>.</cell>
        </row>
        
        <row>
          <cell>
            <tt>
              static int foo (int x, string y) { ... }
            </tt>
          </cell>
          <cell>
            <tt>
              static foo (x : int, y : string) : int { ... }
            </tt>
          </cell>
          <cell></cell>
        </row>
        
        <row>
          <cell>
            <tt>
              if (<meta>cond</meta>) return <meta>foo</meta>;<br/>
              <meta>do_something ()</meta>;<br/>
              return <meta>bar</meta>;
            </tt>
          </cell>
          <cell>
            <tt>
              if (<meta>cond</meta>) <meta>foo</meta><br/>
              else {<br/>
              <meta>do_something ()</meta>;<br/>
              <meta>bar</meta><br/>
              }
            </tt>
          </cell>
          <cell>There is no <tt>return</tt> statement that cuts control flow in Nemerle.</cell>
        </row>
        
        <row>
          <cell>
            <tt>
              int x = 3;<br/>
              string y = "foo";<br/>
              FooBarQux fbq = make_fbq ();
            </tt>
          </cell>
          <cell>
            <tt>
              def x = 3;<br/>
              def y = "foo";<br/>
              def fbq = make_fbq ();
            </tt>
          </cell>
          <cell>The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> cannot be changed.
          </cell>
        </row>
        
        <row>
          <cell>
            <tt>
              int x = 3;<br/>
              string y = "foo";<br/>
              FooBarQux fbq = make_fbq ();
            </tt>
          </cell>
          <cell>
            <tt>
              mutable x &lt;- 3;<br/>
              mutable y &lt;- "foo";<br/>
              mutable fbq &lt;- make_fbq ();
            </tt>
          </cell>
          <cell>The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> can be changed.
          </cell>
        </row>
        
        <row>
          <cell>
            <tt>
              class Foo {<br/>
                int x;<br/>
              }
            </tt>
          </cell>
          <cell>
            <tt>
              class Foo {<br/>
                mutable x : int;<br/>
              }
            </tt>
          </cell>
          <cell></cell>
        </row>
        
        <row>
          <cell>
            <tt>
              class Foo {<br/>
                readonly int x;<br/>
              }
            </tt>
          </cell>
          <cell>
            <tt>
              class Foo {<br/>
                x : int;<br/>
              }
            </tt>
          </cell>
          <cell></cell>
        </row>
        
      </table>
      
  <!-- TODO:
    extends, implements
    ctor == this
    try..catch
    when,unless,if..then
    -->

    </body>
  </section>
  

  <section id="generics">
    <title>As in Generic C#...</title>
    <body>
      <p>
        This section describes stuff that is similar to what is called
        generics in C# 2.0.
      </p>
  <!-- TODO:
    'a
    where constraints
     -->
    </body>
  </section>

  
  <section id="new-stuff">
    <title>New stuff</title>
    <body>
      <p>
        This section talks about stuff absent in C#.
      </p>
      <!-- TODO:
        namespace aliases
        _ as identifier
        module
        function and tuple types
        named parameters
        local functions
        void literal
        lambda
        [],::
       -->
    </body>
  </section>
  

  <section id="variants-and-matching">
    <title>Variants and matching</title>
    <body>
      <!-- TODO -->
    </body>
  </section>

  
  <section id="same">
    <title>The same</title>
    <body>
      <p>
        This section lists things that are written (mostly) the same way as
        they do in C#. It only includes cases when it could be doubtful.
      </p>
      <!-- 
        @"foo"
        /* */
        //
        using (+ opening classes)
        throw
        try..finally
        opertors?
      -->
    </body>
  </section>

  
    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
