using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace LRPEGCC
{
  internal variant RuleType
  {
    | List   { ty : RuleType; }
    | Option { ty : RuleType; }
    | Tuple  { types : list[RuleType]; }
    | NType  { ty : PExpr; }
    | Range
  }

  [Record] 
  internal class RuleRef : Located, IComparable[RuleRef]
  {
    [Accessor] id : string;

    public override ToString() : string
    {
      id
    }

    public override GetHashCode() : int
    {
      id?.GetHashCode()
    }

    public CompareTo(other : RuleRef) : int
    {
      StringComparer.Ordinal.Compare(this.id, other?.id)
    }

    [Nemerle.OverrideObjectEquals]
    public Equals(_ : RuleRef) : bool
    {
      | null => false
      | other => other.id == this.id
    }
  }

  internal variant Rule
  {
    | Choice                        { rules : list[Rule]; }
    | Sequence                      { rules : list[Rule]; }
    | Call                          { name : RuleRef; }
    | RepeatMin                     { minCount : int; rule : Rule; }
    | RepeatMinMax                  { minCount : int; maxCount : int; rule : Rule; }
    | Chars                         { chars : list[RangeSet]; }
    | Not                           { rule : Rule; }
    | And                           { rule : Rule; }
    | Capture                       { name : RuleRef; retType : RuleType; rule : Rule; }
    | ExtensionPoint                { name : RuleRef; }
    
    public Walk(func : Rule -> Rule) : Rule
    {
      def loop(rule : Rule) : Rule
      {
        def rule2 = func(rule);
        
        def rule3 = 
          match (rule2)
          {
            | Choice(rules)                             => Choice(rules.Map(loop))
            | Sequence(rules)                           => Sequence(rules.Map(loop))
            | RepeatMin(x, rule)                        => RepeatMin(x, loop(rule))
            | RepeatMinMax(min, max, rule)              => RepeatMinMax(min, max, loop(rule))
            | Not(rule)                                 => Not(loop(rule))
            | And(rule)                                 => And(loop(rule))
            | Capture(name, retType, rule)              => Capture(name, retType, loop(rule))
            | Call | Chars | ExtensionPoint             => rule2
          };
          
        rule3.Index = rule.Index;
        rule3
      }

      loop(this)
    }
    
    public Index : int { get; private set; }
    
    internal UpdateIndecis() : void
    {
      //assert2(!this.ToString().Contains("inputError"));
      
      def loop(rule : Rule, index : int) : void
      {
        rule.Index = index;
        
        match (rule)
        {
          | Choice(rules)                           =>
            foreach (r in rules)
              loop(r, index)
              
          | Sequence(rules)                         => 
            mutable i = 0;
            foreach (r in rules)
            {
              | Not | And => loop(r, -1);
              | _ =>
                loop(r, i);
                i++;
            }
          
          | Not(r) | And(r) 
          | RepeatMinMax(0, 1, r)                   => loop(r, 0)
          | RepeatMin(_, r) | RepeatMinMax(_, _, r) => loop(r, 0)
          | Capture(_, _, r)                        => loop(r, 0)
          | Call| Chars | ExtensionPoint            => ()
        }
      }
      
      loop(this, 0);
    }
    
    public Priority : int
    {
      get
      {
        match (this)
        {
          | Chars                       => 5
          | Capture                     => 5
          | ExtensionPoint              => 5
          | Call                        => 5
          | RepeatMin                   => 4
          | RepeatMinMax                => 4
          | Not                         => 3
          | And                         => 3
          | Sequence                    => 2
          | Choice                      => 1
        }
      }
    }

    public override ToString() : string
    {
      def p(rule : Rule)
      {
        if (rule.Priority <= this.Priority) 
          $"($rule)"
        else                                
          rule.ToString()
      }
      
      match (this)
      {
        | Choice(rules)                             => $<#..$(rules; " / "; p)#>
        | Sequence(rules)                           => $<#..$(rules; " "; p)#>
        | Call(name)                                => name.Id
        | RepeatMin(0, rule)                        => $"$(p(rule))*"
        | RepeatMin(1, rule)                        => $"$(p(rule))+"
        | RepeatMin(x, rule)                        => $"$RepeatMin($x, $rule)"
        | RepeatMinMax(0, 1, rule)                  => $"$(p(rule))?"
        | RepeatMinMax(min, max, rule)              => $"$RepeatMin($min, $max, $rule)"
        | Chars([chars])                            => $"[$chars]"
        | Chars(chars)                              => $<#(..$(chars; " "; ch => $"[$ch]"))#>
        | Not(rule)                                 => $"!$(p(rule))"
        | And(rule)                                 => $"&$(p(rule))"
        | Capture(name, _, rule)                    => $"Capture[$name]($rule)"
        | ExtensionPoint(name)                      => $"ExtensionPoint($name)"
      }
    }
  }
}
