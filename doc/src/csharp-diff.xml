<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Quick summary of differences between Nemerle and C#</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document lists basic differences between Nemerle and C#
        in a terse form. If you know Java or C++ you also should be able
        to use it.
      </p>
    </body>
  </section>


  <section id="expr-changes">
    <title>Changes in expressions</title>
    <body>
      <comparison>
        <entry>
          <csharp>
            int x = 3;<br/>
            string y = "foo";<br/>
            FooBarQux fbq = make_fbq ();
          </csharp>
          <nemerle>
            def x = 3;<br/>
            def y = "foo";<br/>
            def fbq = make_fbq ();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> cannot be changed.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
              int x = 3;<br/>
              string y = "foo";<br/>
              FooBarQux fbq = make_fbq();
          </csharp>
          <nemerle>
              mutable x &lt;- 3;<br/>
              mutable y &lt;- "foo";<br/>
              mutable fbq &lt;- make_fbq();
          </nemerle>
          <remarks>
            The values of <tt>x</tt>, <tt>y</tt> and <tt>fbq</tt> can be changed.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta>;
          </csharp>
          <nemerle>
            <meta>expr_1</meta> &lt;- <meta>expr_2</meta>;
          </nemerle>
          <remarks>
            The assignment operator.
          </remarks>
        </entry>

        <entry>
          <csharp>
            <meta>expr_1</meta> = <meta>expr_2</meta> = <meta>expr_3</meta>;
          </csharp>
          <nemerle>
            def tmp = <meta>expr_3</meta>;<br/>
            <meta>expr_1</meta> &lt;- tmp;<br/>
            <meta>expr_2</meta> &lt;- tmp;
          </nemerle>
          <remarks>
            The type of assignment operator is <tt>void</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> (<meta>parms</meta>)
          </csharp>
          <nemerle>
            <meta>Class</meta> (<meta>parms</meta>)
          </nemerle>
          <remarks> 
            The <tt>new</tt> keyword is dropped.
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            array (<meta>size</meta>)
          </nemerle>
          <remarks>
            If the type can be inferred (most of the time).
          </remarks>
        </entry>

        <entry>
          <csharp>
            new <meta>Class</meta> [<meta>size</meta>]
          </csharp>
          <nemerle>
            (array (<meta>size</meta>) : array (<meta>Class</meta>))
          </nemerle>
          <remarks>
            If the type cannot be inferred.
          </remarks>
        </entry>

        <entry>
          <csharp>
            { <meta>expr_1</meta>, <meta>expr_1</meta>, ..., 
              <meta>expr_n</meta> }
          </csharp>
          <nemerle>
            array [<meta>expr_1</meta>, 
                   <meta>expr_1</meta>, ..., 
                   <meta>expr_n</meta>]
          </nemerle>
          <remarks>
            The array constructor.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) return <meta>foo</meta>;<br/>
            <meta>do_something ()</meta>;<br/>
            return <meta>bar</meta>;
          </csharp>
          <nemerle>
            if (<meta>cond</meta>) <meta>foo</meta><br/>
            else {<br/>
            <meta>do_something ()</meta>;<br/>
            <meta>bar</meta><br/>
            }
          </nemerle>
          <remarks>
            There is no <tt>return</tt> statement that cuts control flow in Nemerle.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            when (<meta>cond</meta>) answer &lt;- 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without <tt>else</tt> is called <tt>when</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            if (!<meta>cond</meta>) answer = 42;<br/>
            ...
          </csharp>
          <nemerle>
            unless (<meta>cond</meta>) answer &lt;- 42;<br/>
            // or: when (!<meta>cond</meta>) answer &lt;- 42;<br/>
            ...
          </nemerle>
          <remarks>
            The <tt>if</tt> without "then" is called
            <tt>unless</tt>. However nobody is forced to use it.
          </remarks>
        </entry>

        <entry>
          <csharp>
            try ... <br/>
            catch (FooException e) { ... }<br/>
            catch (BarException e) { ... }
          </csharp>
          <nemerle>
            try ... <br/>
            catch {<br/>
              | e : FooException => ...<br/>
              | e : BarException => ...<br/>
            }
          </nemerle>
          <remarks>
            Somewhat different syntax, consistent with <tt>match</tt> though.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> :> <meta>type</meta>)
          </nemerle>
          <remarks>
            Runtime type cast, allows for downcasts and upcasts.
          </remarks>
        </entry>

        <entry>
          <csharp>
            ((<meta>type</meta>) <meta>expr</meta>)
          </csharp>
          <nemerle>
            (<meta>expr</meta> : <meta>type</meta>)
          </nemerle>
          <remarks>
            Static cast, allow only upcast.
          </remarks>
        </entry>

      </comparison>
      
    </body>
  </section>
  

  <section id="class-changes">
    <title>Changes in type definitions</title>
    <body>
      <comparison>

        <entry>
          <csharp>
            class Foo : Bar, IComparable, IEnumerable { ... }
          </csharp>
          <nemerle>
            class Foo extends Bar implements IComparable, IEnumerable { ... }
          </nemerle>
          <remarks>
            This seems more readable.
          </remarks>
        </entry>

        <entry>
          <csharp>
              static int foo (int x, string y) { ... }
          </csharp>
          <nemerle>
              static foo (x : int, y : string) : int { ... }
          </nemerle>
          <remarks>
            Type are written after variables.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              public Foo (int x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              public this (x : int) { ... }<br/>
            }
          </nemerle>
          <remarks>
            Constructor name is always <tt>this</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo : Bar {<br/>
              public Foo (int x) : base (x) { ... }<br/>
            }
          </csharp>
          <nemerle>
            class Foo extends Bar {<br/>
              public this (x : int) { base (x); ... }<br/>
            }
          </nemerle>
          <remarks>
            Base constructor is called in function body.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              mutable x : int;<br/>
            }
          </nemerle>
          <remarks>
            Fields to be changed outside constructor need to be marked <tt>mutable</tt>.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class Foo {<br/>
              readonly int x;<br/>
            }
          </csharp>
          <nemerle>
            class Foo {<br/>
              x : int;<br/>
            }
          </nemerle>
          <remarks>
            <tt>readonly</tt> is the default.
          </remarks>
        </entry>

        <entry>
          <csharp>
            interface I { void m(); }<br/>
            class C : I {<br/>
              public void m () { ... }<br/>
            }
          </csharp>
          <nemerle>
            interface I { m () : void; }<br/>
            class C implements I {<br/>
              public m () : void { ... }<br/>
            }
          </nemerle>
          <remarks>
            Implementing methods from interfaces.
          </remarks>
        </entry>

        <entry>
          <csharp>
            class C : I1, I2 {<br/>
              void I1.m () { ... }<br/>
              void I2.m () { ... }<br/>
            }
          </csharp>
          <nemerle>
            class C implements I1, I2 {<br/>
              meth1 () : void implements I1.m { ... }<br/>
              meth2 () : void implements I2.m { ... }<br/>
            }
          </nemerle>
          <remarks>
            When two interfaces have the method with the same name.
          </remarks>
        </entry>

      </comparison>
    </body>
  </section>
 
 <!--
      <comparison>
        <entry>
          <csharp>
          </csharp>
          <nemerle>
          </nemerle>
          <remarks>
          </remarks>
        </entry>
      </comparison>
   -->


  <section id="generics">
    <title>As in Generic C#...</title>
    <body>
      <p>
        This section describes stuff that is similar to what is called
        generics in C# 2.0.
      </p>
      
      <comparison>
      
        <entry>
          <csharp>
            class A &lt;T> { readonly T x; }
          </csharp>
          <nemerle>
            class A ('t) { x : 't; }
          </nemerle>
          <remarks>
            Type parameters (or type variables) have special syntax even at
            the lexical level.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class A &lt;T> where T : IComparable &lt;T> { ... }
          </csharp>
          <nemerle>
            class A ('t) where 't :> IComparable ('t) { ... }
          </nemerle>
          <remarks>
            Type parameters are written in parens <tt>()</tt>.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            class A &lt;T> where T : IFoo, IBar { ... }
          </csharp>
          <nemerle>
            class A ('t) where 't :> IFoo, 't :> IBar { ... }
          </nemerle>
          <remarks>
            Multiple constraints.
          </remarks>
        </entry>
        
        <entry>
          <csharp>
            int meth&lt;A> (A x) { ... }
          </csharp>
          <nemerle>
            'a meth (x : 'a) : int { ... }
          </nemerle>
          <remarks>
            Polymorphic method.
          </remarks>
        </entry>
        
      </comparison>
      
    </body>
  </section>

  
  <section id="new-stuff">
    <title>New stuff</title>
    <body>
      <p>
        This section talks about stuff absent in C#.
      </p>
      <!-- TODO:
        namespace aliases
        _ as identifier
        module
        function and tuple types
        named parameters
        local functions
        void literal
        lambda
        [],::
       -->
    </body>
  </section>
  

  <section id="variants-and-matching">
    <title>Variants and matching</title>
    <body>
      <!-- TODO -->
    </body>
  </section>

  
  <section id="same">
    <title>The same</title>
    <body>
      <p>
        This section lists things that are written (mostly) the same way as
        they do in C#. It only includes cases when it could be doubtful.
      </p>
      <!-- 
        @"foo"
        /* */
        //
        using (+ opening classes)
        throw
        try..finally
        opertors?
      -->
    </body>
  </section>

  
    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
