/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

namespace Nemerle.Compiler {

module Scan_globals {

  private handle_type (par : option <TypeBuilder>, vop : option <TypeBuilder>, 
                       env : GlobalEnv, t : TopDeclaration) : void
  {
    match (t) {
      | TD_macro (header, synt, expr) =>
        Macros.GenerateMacroClass (env, par, t.modifiers, header,
                                   synt, expr)

      | TD_delegate (header) =>
        Delegates.GenerateDelegateClass (env, par, t.modifiers, header)
                                   
      | _ =>
        def ns = env.GetCurrentNamespaceND ().Path (Macros.UnSString (t.name));
        def env' = env.AddOpenNamespace (ns, t.loc);
        def ti = TypeBuilder (par, vop, env', t);
        GlobalEnv.AddType (ns, ti);

        def env' = env.EnterIntoNamespace (Macros.UnSString (t.name));

        match (t) {
          | TD_variant_option (ds)
          | TD_interface { methods = ds }
          | TD_class { decls = ds } =>
            foreach (cm in ds) {
              match (cm) {
                | M_type (t) =>
                  handle_type (Some (ti), None (), env', t)
                | _ =>
                  ()
              }
            };
            
          | TD_variant { decls = ds } =>
            foreach (x in ds) {
              match (x) {
                | M_type (d) =>
                  match (d) {
                    | TD_variant_option =>
                      handle_type (par, Some (ti), env, d)
                    | _ => ()
                  }
                | M_enum (None) =>
                  def d = TD_variant_option (name = x.name, modifiers = x.modifiers,
                                             decls = []);
                  d.loc = x.loc;
                  handle_type (par, Some (ti), env, d)
                | M_enum =>
                  Message.error ("variant options cannot have value, they are not enums")
                | _ => ()
              }
            }
            
          | TD_enum => ()
          | TD_alias => ()
          | TD_macro => assert (false)
          | TD_delegate => assert (false)
          | TD_namespace => Message.fatal_error ("namespace nesting inside type is not allowed")
          | TD_open => Message.fatal_error ("namespace import inside type is not allowed") 
          | TD_namespace_alias => Message.fatal_error ("namespace alias inside type is not allowed") 
          | TD_attribute => Message.fatal_error ("assembly attribute inside type is not allowed") 
        };
        ti.ReverseChildren ();
    }
  }

  /** This function does the very first pass, after parsing.  It changes 
      open/namespace declaration into appropriate entries in [GlobalEnv] class.
      It also creates [TypeBuilder] object for each type and registers it
      with global name environment.  */
  public run (decls : list <TopDeclaration>) : void
  {
    def loop (decl, env : GlobalEnv) : GlobalEnv {
      match (decl) {
        | TD_namespace (d) =>
          def env' = env.EnterIntoNamespace (Macros.UnSString (decl.name));
          ignore (List.FoldLeft (d, env', loop));
          env
          
        | TD_open => env.AddOpenNamespace (Macros.UnSString (decl.name), decl.loc);
          
        | TD_namespace_alias (s) => env.AddNamespaceAlias (s, Macros.UnSString (decl.name), decl.loc);

        | TD_attribute (body) =>
          AttributeCompiler.AddAssemblyAttribute (env, body);
          env
          
        | d =>
          handle_type (None (), None (), env, d);
          env
      }
    };
    def _ = List.FoldLeft (decls, GlobalEnv.Core, loop);
    ()
  }
      
} // module Scan_globals

} // N.C
