using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility.NString;
using SC = System.Console;
using System.Text;
using System.Text.RegularExpressions.Regex;

module MainClass
{
  Main () : void {
    def print_welcome () : void {
      SC.WriteLine ("Welcome to Nemerle interpreter.\n");
      SC.WriteLine ("Please enter expressions appended with \";;\".");
      SC.WriteLine ("To add open namespaces, reference libraries or set "
                    "various preferences, use");
      SC.WriteLine ("properties from the Interp module. Their list is "
                    "available via \"Interp.Help;;\"\n");
    }
   
    print_welcome ();

    def e = Evaluator ();
#if READLINE
    def rl = Mono.ReadLine.GnuReadLine ();
#endif
    def readinput (code : string) : void {
#if READLINE
      def line = rl.ReadLine (Interp.Prompt);
#else
      SC.Write (Interp.Prompt);
      def line = SC.ReadLine ();
#endif
      match (line) {
        | null => ()
        | _ => 
#if READLINE
          rl.AddHistory(line);
#endif
          regexp match (line) {
            | @"^\s*$" => readinput (code)
            | _ =>  { 
              def l = line.TrimEnd ();
              if (l.EndsWith (";;")) {
                try { 
                  def (nmnvts) = e.Eval (Interp.RefParsed, Interp.UsingParsed,
                                         code + 
                                         l.TrimEnd (array [';',' ','\t']));
		  Iter (nmnvts, fun (x) {
                    def (newvar, mut, name, val, ty) = x;
		    when (newvar) 
                      match ((mut, val, ty)) {
			| (false, null, _) =>
			  SC.WriteLine ($"def $name : $ty")
			| (_, null, _) =>
			  SC.WriteLine ($"mutable $name : $ty")
			| (_, _, <[ $_ -> $_ ]>) =>
			  SC.WriteLine ($"def $name : $ty")
                        | (false, _, _) => 
			  SC.WriteLine ($"def $name = $val : $ty")
                        | _ => 
			  SC.WriteLine ($"mutable $name = $val : $ty")
		    }
		  })
                } 
                catch {
                  | e is System.Exception =>
                    unless (Nemerle.Compiler.Message.SeenError) {
                      SC.WriteLine (e.Message + e.StackTrace);
                      SC.WriteLine (e.ToString ())
                    }
                } 
                Interp.Prompt = Interp.PS1;
                readinput ("") 
              }
              else { 
                Interp.Prompt = Interp.PS2;
                readinput (code + line + " ") 
              }
            }
          }
      }
    }

    //FIXME: this is a temporary workaround, to be removed later
    Interp.Ref = "";

    readinput ("")
  }
}

