/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree; 

namespace Nemerle.Compiler {

module Tyops {
  public @/- (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
  public @>:> (x : Type, y : Type) : bool = extern "Nemerle.Compiler.Tyutil.subtypes";
}
  
public variant TvValue
{
  | TV_unspecified
  | TV_free
  | TV_free_from_null
  | TV_at_most { t : Type; }
  | TV_exactly { t : Type; }
}

public type Subst = SystemMap <int, TvValue>;

public module Tyutil {

  public GetTypeTycon (t : Type) : Tycon
  {
    match (top_expand (t)) {
      | T_app (tc, _) => tc
      | _ => null
    }
  }
  
  public subst (t : Type, s : Subst) : Type
  {
    //Message.debug ("subst " + t.as_string ());
    if (s.IsEmpty ())
      t
    else {
      def self (t : Type) : Type { subst (t, s) };
      match (t) {
        | T_ref (t) => T_ref (subst (t, s))
        | T_out (t) => T_out (subst (t, s))
        | T_array (t, rank) => T_array (subst (t, s), rank)
        | T_fun (tl, t) => T_fun (subst (tl, s), subst (t, s))
        | T_void => t
        | T_prod (tl) => T_prod (List.Map (tl, self))
        | T_app (ti, args) =>
          T_app (ti, List.Map (args, self))
        | T_var (tv) =>
          def self (_) {
            | T_var (tv2) when tv.id == tv2.id => assert (false)
            | t' => subst (t', s)
          };
          match (s.Find (tv.id)) {
            | Some (TV_at_most (t'))
            | Some (TV_exactly (t')) => t'
            | _ =>
              match (tv.value) {
                | TV_at_most (t') =>
                  //Message.debug ("killed at most " + t'.as_string ());
                  tv.value = TV_exactly (t');
                  self (t')
                | TV_exactly (t') =>
                  self (t')
                | _ => t
              }
          }
      }
    }
  }
  
  tv_value (s : Subst, tv : Tyvar.T) : TvValue
  {
    match (s.Find (tv.id)) {
      | Some (r) => r
      | None => tv.value
    }
  }

  public top_expand (t : Type) : Type 
  {
    def (s, t) = top_expand (SystemMap (), t, false);
    Tyvar.global_store (s);
    t
  }

  join_substs (s1 : Subst, s2 : Subst) : Subst
  {
    s1.Fold (fun (i, v, s : Subst) { s.Add (i, v) }, s2)
  }
  
  top_expand (s : Subst, t : Type, stop : bool) : Subst * Type
  {
    match (t) {
      | T_app (ti, args) =>
        match (ti.GetTydecl ()) {
          | TD_alias (t) =>
            top_expand (s, t /- ti.MakeSubst (args), stop)
          | _ => (s, t)
        }
        
      | T_var (tv) =>
        match (tv_value (s, tv)) {
          | TV_exactly (t) => top_expand (s, t, stop)
          | TV_at_most (t) when !stop =>
            top_expand (s.Replace (tv.id, TV_exactly (t)), t, stop)
          | _ => (s, t)
        }
        
      | _ => (s, t)
    }
  }

  common_supertypes (ti1 : Tycon, a1 : list <Type>, ti2 : Tycon,
                     a2 : list <Type>) : list <Type>
  {
    def ht = Hashtable ();

    def s1 = ti1.MakeSubst (a1);
    def s2 = ti1.MakeSubst (a2);

    List.Iter (ti1.GetSuperTypes (), fun (t) {
      match (top_expand (t)) {
        | (T_app (ti, _)) as t =>
          when (ti.FullName != "System.Object")
            ht.Add (ti.GetId (), t /- s1)
        | _ => assert (false)
      }
    });

    List.FoldLeft (ti2.GetSuperTypes (), [], fun (t, acc) {
      match (top_expand (t)) {
        | (T_app (ti, _)) as t =>
          match (ht.Get (ti.GetId ())) {
            | Some (t') =>
              match (unify (s2, t, t', false)) {
                | Some (s) => (t /- s) :: acc
                | None => acc
              }
            | None => acc
          }
        | _ => assert (false)
      }
    })
  }

  
  maximal_types (types : list <Type>) : list <Type>
  {
    List.FoldLeft (types, [], fun (t, max) {
      def is_bigger_then_t (t') {
        Option.IsSome (unify (t', t, true))
      };
      
      if (List.Exists (max, is_bigger_then_t))
        max
      else
        t :: max
    })
  }

  internal maximal_common_supertypes (s : Subst, t1 : Type, t2 : Type) : list <Type>
  {
    //Message.debug ("mcs unify");
    match (unify (s, t1, t2, true)) {
      | Some => [t2]
      | None =>
        match (unify (s, t2, t1, true)) {
         | Some => [t1]
         | None =>
            match ((top_expand (t1 /- s), top_expand (t2 /- s))) {
              | (T_app (ti1, a1), T_app (ti2, a2)) =>
                maximal_types (common_supertypes (ti1, a1, ti2, a2))
              | _ => []
            }
        }
    }
  }

  is_value_type (t : Type) : bool
  {
    | T_app (tc, _) =>
      match (tc.GetTyconKind ()) {
        | TK_ExternalNemerleType (st)
        | TK_ExternalNetType (st) =>
          st.IsValueType || st.FullName == "System.Void"
        | TK_NemerleType => false
      }
    | T_void => true
    | _ => false
  }

  try_subst (s : Subst, tv : Tyvar.T, t2 : Type, is_at_most : bool) : option <Subst>
  {
    //Message.debug ("ccs");
    def check_constraint (c : Type, s : option <Subst>) {
      match (s) {
        | None => None ()
        | Some (s) =>
          //Message.debug ("check_constraint unify");
          unify (s, t2, c, true)
      }
    };

    def occur_check (_) {
      | T_ref (t)
      | T_out (t)
      | T_array (t, _) => 
        occur_check (t)
      | T_fun (t1, t2) => 
        occur_check (t1) || occur_check (t2)
      | T_void => false
      | T_prod (tl)
      | T_app (_, tl) => List.Exists (tl, occur_check)
      | T_var (tv') when tv.id == tv'.id => true
      | T_var (tv) =>
        match (tv_value (s, tv)) {
          | TV_at_most (t)
          | TV_exactly (t) => occur_check (t)
          | _ => false
        };
    };

    match (tv_value (s, tv)) {
      | TV_free_from_null when is_value_type (t2) => None ()
      | TV_free_from_null
      | TV_free 
      | TV_at_most =>
        if (occur_check (t2))
          None ()
        else {
          def repl =
            if (is_at_most) TV_at_most (t2) 
            else TV_exactly (t2);
          List.FoldLeft (Tyvar.constraints (tv),
                         Some (s.Replace (tv.id, repl)),
                         check_constraint)
        }
      | TV_exactly => assert (false)
      | TV_unspecified => assert (false)
    }
  }

  unify_tyvars (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option <Subst>
  {
    def check_at_most_intro () {
      match ((t1, t2)) {
        | (t, T_var (tv)) when allow_subtyping =>
          match (tv_value (s, tv)) {
            | TV_free
            | TV_free_from_null =>
              try_subst (s, tv, t, true)
              
            | TV_at_most (t') =>
              match (maximal_common_supertypes (s, t, t')) {
                | [] => None ()
                | [max] =>
                  //Message.debug ("max = " + max.as_string ());
                  def s = Option.UnSome (unify (s, t, max, true));
                  def s = Option.UnSome (unify (s, t', max, true));
                  match (tv_value (s, tv)) {
                    | TV_exactly => None ()
                    | TV_at_most =>
                      try_subst (s, tv, max, true)
                    | _ => assert (false)
                  }
                | _ => None ()
              }
              
            | TV_exactly => assert (false)
            
            | TV_unspecified => None ()
          }

        | _ => None ()
      }
    };

    def check_simple_unification (t1, t2) {
      match (t1) {
        | T_var (tv) =>
          match (tv_value (s, tv)) {
            | TV_free
            | TV_free_from_null =>
              try_subst (s, tv, t2, false)
            | _ => None ()
          }
        | _ => None ()
      }
    };

    def check_at_most_kill (t1, t2) {
      match (t1) {
        | T_var (tv) =>
          match (tv_value (s, tv)) {
            | TV_at_most (t) =>
              //Message.debug ("kill_at_most " + t.as_string () + " vs " + (t2:Type).as_string ());
              match (try_subst (s, tv, t, false)) {
                | Some (s) =>
                  unify (s, t, t2, true)
                | None => None ()
              }
            | _ => None ()
          }
        | _ => None ()
      }
    };

    def check_list (_) : option <Subst> {
      | f :: fs =>
        //Message.debug (sprintf("method %d", List.Length (fs)));
        match ((f : void -> option <Subst>) ()) {
          | (Some) as r => r
          | None => check_list (fs)
        }
      | [] => None ()
    };

    //Message.debug ("unify tv");
    
    check_list ([check_at_most_intro, 
                 fun () { check_simple_unification (t1, t2) },
                 fun () { check_simple_unification (t2, t1) },
                 fun () { check_at_most_kill (t1, t2) },
                 fun () { check_at_most_kill (t2, t1) }
                ])
  }


  // t1 :> t2 (or t1 =? t2)
  public unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option <Subst>
  {
    def unify_lists (s, t1, t2, allow_subtyping) {
      match ((t1, t2)) {
        | (t1 :: ts1, t2 :: ts2) =>
          match (unify (s, t1, t2, allow_subtyping)) {
            | Some (s') => unify_lists (s', ts1, ts2, allow_subtyping)
            | None => None ()
          }
        | ([], []) => Some (s)
        | _ => None ()
      }
    };

    def alterable (tv) {
      match (tv_value (s, tv)) {
        | TV_free
        | TV_free_from_null
        | TV_at_most => true
        | _ => false
      }
    };
    

    //def sign = if (allow_subtyping) " :> " else " =? ";
    //Message.debug ("(((unify " + string_of_type (t1) + sign + string_of_type (t2));
    def (s, t1) = top_expand (s, t1, true);
    def (s, t2) = top_expand (s, t2, true);
    //Message.debug ("  --> " + string_of_type (t1) + sign + string_of_type (t2));

    def res =

    match ((t1, t2)) {
      | (T_array (t1, rank1), T_array (t2, rank2)) when rank1 == rank2 =>
        unify (s, t1, t2, false) // no array covariance
      | (T_array (_, _), T_app (ti2, [])) when allow_subtyping && 
                                            ti2.FullName == "System.Array" => 
        Some (s)
        
      | (T_prod (l1), T_prod (l2)) => 
        unify_lists (s, l1, l2, allow_subtyping)

      | (T_void, T_void) => Some (s)
                              
      | (T_fun (a1, r1), T_fun (a2, r2)) =>
        match (unify (s, r1, r2, allow_subtyping)) {
          | Some (s) => unify (s, a2, a1, allow_subtyping)
          | None => None ()
        }

      | (_, T_app (ti2, [])) when allow_subtyping && 
                                  ti2.FullName == "System.Object" =>
        Some (s)

      | (T_app (ti1, a1), T_app (ti2, a2)) when ti1.SameAs (ti2) =>
        unify_lists (s, a1, a2, false)

      | (T_app (ti1, a1), T_app (ti2, _)) when allow_subtyping =>
        match (ti1.SuperType (ti2)) {
          | Some (args) => 
            //Message.debug ("unify <: " + ti1.FullName + " " + ti2.FullName);
            unify (s, ti2.GetMemType () 
                        /- ti2.MakeSubst (args) 
                        /- ti1.MakeSubst (a1), t2, true)
          | None => None ()
        }

      | (T_var (tv1), T_var (tv2)) when tv1.id == tv2.id => Some (s)
      
      // don't let this case down, we don't want tv1's constraints to
      // mess with tv2
      | (_, T_var (tv2)) when alterable (tv2) =>
        unify_tyvars (s, t1, t2, allow_subtyping)
        
      | (T_var (tv), _) when allow_subtyping =>
        // check to see if any of our constraints is enough
        def check_constraints (cs) {
          match (cs) {
            | [] => unify_tyvars (s, t1, t2, allow_subtyping)
            | c :: cs =>
              //Message.debug ("solved-by-constraint unify");
              match (unify (s, c, t2, true)) {
                | Some (r) => 
                  //Message.debug ("hit scu");
                  Some (r)
                | None => check_constraints (cs)
              }
          }
        };
        check_constraints (Tyvar.constraints (tv))
      
      | _ => 
        unify_tyvars (s, t1, t2, allow_subtyping)
    };
   
   /*
    match (res) {
      | Some (s) =>
        Message.debug ("res = " + (t1 /- s).as_string () + 
                " " + (t2 /- s).as_string () + ")))");
      | None =>
        Message.debug ("failed )))");
    };
    */

    res
  }

  public unify (t1 : Type, t2 : Type, allow_subtyping : bool) : option <Subst> 
  {
    unify (SystemMap (), t1, t2, allow_subtyping)
  }
  
  public unify (t1 : Type, t2 : Type) : option <Subst>
  {
    unify (SystemMap (), t1, t2, false) 
  }
 
  // FIXME: this might be broken (if there are free variables in types to
  // begin with)
  public types_eq (a : Type, b : Type) : bool
  {
    match (unify (a, b)) {
      | Some => true
      | None => false
    }
  }

  // check if a :> b and if so, incorporate substitution into
  // global context
  public subtypes (a : Type, b : Type) : bool 
  {
    match (unify (a, b, true)) {
      | Some (s) => { Tyvar.global_store (s); true }
      | None => false
    }
  }

  public string_of_type (t : Type) : string
  {
    def f (lev, t) {
      match (t) {
        | _ when lev > 20 => "..."
        | T_app (ti, args) =>
          def name = ti.FullName;
          match (name) {
            | "Nemerle.Core.string"
            | "System.String" => "string"
            | "Nemerle.Core.int"
            | "System.Int32" => "int"
            | "Nemerle.Core.float"
            | "System.Single" => "float"
            | "Nemerle.Core.char"
            | "System.Char" => "char"
            | "Nemerle.Core.bool"
            | "System.Boolean" => "bool"
            | _ => 
              match (args) {
                | [] => name
                | _ => name + " <" + map (lev + 1, ", ", args) + ">"
              }
          }
        | T_var (tv) =>
          match (tv.value) {
            | TV_unspecified =>
              sprintf ("%s_%d", tv.name, tv.id)
            | TV_free
            | TV_free_from_null =>
              sprintf ("%s_%d*", tv.name, tv.id)
            | TV_at_most (t) =>
              f (lev + 1, t) + "+"
            | TV_exactly (t) =>
              f (lev + 1, t) + "@"
          }
        | T_ref (t) => "ref " + f (lev + 1, t)
        | T_out (t) => "out " + f (lev + 1, t)
        | T_void => "void"
        | T_prod (args) => 
          "(" + map (lev + 1, " * ", args) + ")"
        | T_fun (from, to) =>
          f (lev + 1, from) + " -> " + f (lev + 1, to)
        | T_array (t, 1) => "array <" + f (lev + 1, t) + ">"
        | T_array (t, rank) => "array * "+ sprintf ("%d", rank) + " <" + f (lev + 1, t) + ">"
      };
    }
    and map (lev, sep, args) {
      NString.Concat (sep, List.Map (args, fun (x) { f (lev, x) }))
    };

    f (0, t);
  }


  // Given function declaration, construct its type.
  public fun_type (h : Fun_header) : Type
  {
    match (List.Map (h.parms, fun (p : Fun_parm) : Type { p.ty })) {
      | [x] => T_fun (x, h.ret_type)
      | [] => T_fun (T_void (), h.ret_type)
      | l => T_fun (T_prod (l), h.ret_type)
    }
  }

  public fun_args (from : Type) : list <Type>
  {
    match (top_expand (from)) {
      | T_prod (a) => a
      | T_void => []
      | t => [t]
    }
  }

  /**
   * Return set of maximal types (with respect to the [:>] ordering).
   * Types can have any additional information attached.
   */
  public maximal_types<'a> (types : list <Type * 'a>) : list <Type * 'a>
  {
    def is_worse (t1 : Type, t2 : Type) : bool {
      match ((unify (t1, t2, true), unify (t2, t1, true))) {
        | (Some, None) => false
        | _ => true
      }
    };

    def loop (did : bool, acc : list <Type * 'a>, lst : list <Type * 'a>) : list <Type * 'a> {
      match (lst) {
        | (ty, data) :: xs =>
          def f = fun (t : Type, _ : 'a) : bool { is_worse (ty, t) };
          def acc' = List.Filter (acc, f);
          def did = did || List.Length (acc') != List.Length (acc);
          loop (did, (ty, data) :: acc, List.Filter (xs, f))
        | [] =>
          // fixpoint iteration
          if (did) loop (false, [], acc)
          else acc
      }
    };

    loop (false, [], types)
  }

  /**
   * Compute common type of two branches of some expression.
   *
   * If [t = unify_branches (t1, t2)] then [t1 :> t && t2 :> t].
   *
   * In case of [!(t1 :> t2) && !(t2 :> t1)] we unify only options of
   * the same variant.
   */
  public unify_branches (t1 : Type, t2 : Type) : option <Type>
  {
    match (unify (t1, t2, true)) {
      | Some (s) => Tyvar.global_store (s); Some (t2)
      | None =>
        match (unify (t2, t1, true)) {
         | Some (s) => Tyvar.global_store (s); Some (t1)
         | None =>
            match ((top_expand (t1), top_expand (t2))) {
              | (T_app (ti1, a1), T_app (ti2, a2)) =>
                match ((ti1.GetTydecl (), ti2.GetTydecl ())) {
                  | (TD_variant_option, TD_variant_option) when 
                    Option.UnSome (ti1.SuperClass ()).SameAs (Option.UnSome (ti2.SuperClass ())) =>
                    match (unify (T_prod (a1), T_prod (a2))) {
                      | Some (s) =>
                        Tyvar.global_store (s);
                        Some (T_app (Option.UnSome (ti1.SuperClass ()), a1))
                      | None => None ()
                    }
                  | _ => None ()
                }
              | _ => None ()
            }
        }
    }
  }

  public TypeOfMemberIn (mem : IMember, tc : Tycon) : Type
  {
    mem.GetMemType () /- tc.SubtypingSubst (mem.DeclaringType)
  }
  
  public TypeOfMethodIn (mem : IMethod, tc : Tycon) : Type 
  {
    mem.GetFreshType () /- tc.SubtypingSubst (mem.DeclaringType)
  }
  
  public FrameworkTypeName (tc : Tycon) : string
  {
    def par = tc.DeclaringType;
    if (par == null)
      tc.FullName
    else
      FrameworkTypeName (par) + "+" + tc.Name
  }

  /// Check if [access] doesn't grant more access then any of tycons in [t].
  public CheckAccessibility (access : Accessibility, t : Type) : void
  {
    def check (access_t) {
      match ((access_t, access)) {
        | (A_public, _) 
        | (_, A_private)
        | (A_internal, A_internal)
        | (A_protected, A_protected)
        | (A_protected_or_internal, A_internal)
        | (A_protected_or_internal, A_protected_or_internal)
        | (A_protected_or_internal, A_protected) 
        
        | (A_protected, A_protected_and_internal)
        | (A_protected_and_internal, A_protected_and_internal)
        | (A_internal, A_protected_and_internal) => false
        | _ => true
      }
    };
    
    match (t) {
      | T_app (tc, parms) =>
        if (check (tc.GetAccessibility ()))
          Message.error ("entity is more accessible then `" + tc.FullName + "'")
        else
          List.Iter (parms, fun (t) { CheckAccessibility (access, t) })
      | T_var | T_void => ()
      | T_ref (t) | T_out (t) | T_array (t, _) =>
        CheckAccessibility (access, t)
      | T_fun (t1, t2) =>
        CheckAccessibility (access, t1);
        CheckAccessibility (access, t2)
      | T_prod (parms) =>
        List.Iter (parms, fun (t) { CheckAccessibility (access, t) })
    }
  }


  public IsDelegate (ty : Type) : bool
  {
    match (Tyutil.top_expand (ty)) {
      | T_app (tc, _) =>
        Option.IsSome (tc.SuperType (InternalType.Delegate_tc))
      | _ => false
    }
  }

}

} // ns
