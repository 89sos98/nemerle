/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;

/*
   From now on usage of Util.locate() in this file is prohibited. We
   have location_here() always at the top of the stack, which assigns
   mostly proper location to things. We fix is here and there, in most
   cases it is redundant now, and should be fixed.
 */

namespace Nemerle.Compiler {

public module Parser 
{
  [Record]
  public class ParenCallback {
    public opening_paren : string;
    public closing_paren : string;
    public parsing_function : void -> PExpr;
  }

  [Record]
  public class CTX {
    public mutable lexer : LexerBase;
    public mutable last_token1 : Token; // most recent token
    public mutable last_token2 : Token; // one token before
    public mutable last_token3 : Token; // two tokens before
    public mutable push_back : int; // position in last_token{1,2} or 0
    public parens : Hashtable [string, ParenCallback];
    public closing_parens : Hashtable [string, int];
    public keywords : Hashtable [string, void -> PExpr];
  }

  public mutable ctx : CTX;
  private mutable pending_comment : string;
  private tok_semicolon : Token;

  this () 
  {
    ctx = CTX (lexer = null,
                last_token1 = null, 
                last_token2 = null, 
                last_token3 = null,
                push_back = 0,
                keywords = Hashtable (),
                parens = Hashtable (),
                closing_parens = Hashtable ());
    init_parens ();
    tok_semicolon = Token.Operator (";", 0);
  }

  public Init () : void {
    if (Options.XmlDoc)
      doc_comments = NemerleMap ();
    else
      doc_comments = null;
  }

  public AddParsingFunction (keyword : string, func : void -> PExpr) : void {
    ctx.keywords.Set (keyword, func);
  }
  
  last_token () : Token
  {
    match (ctx.push_back) {
      | 0 => ctx.last_token1
      | 1 => ctx.last_token2
      | 2 => ctx.last_token3
      | _ => assert (false)
    }
  }

  get_token () : Token
  {
    match (ctx.push_back) {
      | 1 =>
        ctx.push_back = 0;
        ctx.last_token1
      | 2 =>
        ctx.push_back = 1;
        ctx.last_token2
      | _ =>
        def get_token () {
          def tok = 
            try {
              ctx.lexer.GetToken ()
            } catch { e : LexerBase.Error =>
              Message.error (ctx.lexer.Location, "lexing problem: " + e.name);
              get_token ()
            };
          if (LexerFile.store_comments)  
            match (tok) {
              | Token.Comment (c) => pending_comment = c; get_token ()
              | Token.Operator ("}", _) | Token.Operator (")", _)
              | Token.Operator ("]", _)  
                => 
                doc_comments = doc_comments.Replace (ctx.lexer.Location, "");
                pending_comment = null;
                tok
                              
              | _ => tok
            }
          else
            tok
        };
        ctx.last_token3 = ctx.last_token2;
        ctx.last_token2 = ctx.last_token1;
        ctx.last_token1 = get_token ();
        ctx.last_token1
    }
  }

  peek_token () : Token {
    def tok = get_token ();
    push_back ();
    tok
  }
  
  push_back () : void {
    match (ctx.push_back) {
      | 1 => ctx.push_back = 2
      | 2 => Util.ice ()
      | _ => ctx.push_back = 1
    }
  }

  push_back (tok : Token) : void {
    match (ctx.push_back) {
      | 1 => ctx.push_back = 2; ctx.last_token2 = tok
      | 2 => Util.ice ()
      | _ => ctx.push_back = 1; ctx.last_token1 = tok
    }
  }
  
  shift () : void {
    ignore (get_token ()) 
  }

  shift_loc () : Location {
    def tok = get_token ();
    tok.Location 
  }


  public mutable doc_comments : NemerleMap [Location, string];

  location_here () : Location {
    def t = peek_token ();
    def loc = t.Location;
    when (doc_comments != null && pending_comment != null) {
      doc_comments = doc_comments.Add (loc, pending_comment);
      pending_comment = null;
    }
    loc
  }

  location () : Location {
    ctx.lexer.Location
  }

  describe () : string {
    when (ctx.push_back != 2) {
      push_back ()
    };
    def name = peek_token ().ToString (true);
    "parse error near " + name + ": "
  }

  fatal_error['a] (msg : string) : 'a {
    Message.fatal_error (location (), describe () + msg)
  }

  error (msg : string) : void {
    Message.error (location (), describe () + msg)
  }

  get_qid (first : list [string]) : list [string] {
    def loop (acc) {
      match (get_token ()) {
        | Token.Operator (".", _) =>
          match (get_token ()) {
            | Token.Identifier (x) => loop (x :: acc)
            | _ => fatal_error ("expecting identifier after dot in qualified ID")
          }
        | _ =>
          push_back ();
          List.Rev (acc)
      }
    };

    match (get_token ()) {
      | Token.Identifier (x) =>
        // reversed accumulator
        loop (x :: first)
      | _ => fatal_error ("expecting qualified identifier")
    }
  }

  get_splicable_qid () : Splicable {
    match (peek_token ()) {
      | Token.Identifier => Splicable.Name (Name (get_qid ([])))
        
      | Token.Operator ("$", _) => get_splicable_id ()
        
      | _ => fatal_error ("expecting qualified identifier")
    }
  }
    
  get_splicable_id () : Splicable {
    def tok = get_token ();
    def loc = tok.Location;
    match (tok) {
      | Token.Identifier (n) => Splicable.Name (loc, Name ([n]))
      | Token.Operator ("$", _) =>
        def bodytok = get_token ();
        match (bodytok) {
          | Token.Identifier (id) =>
            def idloc = bodytok.Location;
            Splicable.Expression (loc + idloc, PExpr.Ref (idloc, Name ([id])))
              
          | Token.Operator ("(", _) =>
            def expr = parse_expr ();
            expect_operator (")");
            match (expr) {
              | PExpr.TypeEnforcement =>
                Splicable.Expression (loc, PExpr.Spliced (expr))

              | x => Splicable.Expression (loc, x); 
            }

          | Token.Keyword ("_") =>
            def locend = bodytok.Location;
              Splicable.Expression (loc + locend, PExpr.Wildcard (locend))
              
          | _ => fatal_error ("expecting identifier or '(' after '$'")
        }
      | Token.Keyword ("_") => 
        Splicable.Name (loc, Name ([Util.tmpname ("u")]))
      | _ => Message.fatal_error (loc, "expecting identifier")
    }
  }

  get_tyvar () : string * int {
    match (get_token ()) {
      | Token.Identifier (tv) => (tv, TypingContext.MacroColor)
      | t => Message.fatal_error (t.Location, "expecting type variable")
    }
  }

  expect_operator (op : string) : void {
    match (get_token ()) {
      | Token.Operator (o, _) when op == o => ()
      | Token.Operator (o, _) when o.StartsWith (op) =>
        push_back (Token.Operator (o.Substring (op.Length), 0))
      | Token.Operator (o, _) =>
        match (peek_token ()) {
          | Token.Operator (o', _) when op == o + o' => shift (); ()
          | _ => fatal_error ("expecting operator `" + op + "'");
        }
      | _ =>
        fatal_error ("expecting operator `" + op + "'");
    }
  }

  expect_operator_loc (op : string) : Location {
    def tok = get_token ();
    match (tok) {
      | Token.Operator (o, _) when op == o => tok.Location
      | Token.Operator (o, _) when o.StartsWith (op) =>
        push_back (Token.Operator (o.Substring (op.Length), 0));
        tok.Location
      | Token.Operator (o, _) =>
        match (peek_token ()) {
          | Token.Operator (o', _) when op == o + o' => tok.Location + shift_loc ();
          | _ => Message.fatal_error (tok.Location, "expecting operator `" + op + "'");
        }
      | _ =>
        Message.fatal_error (tok.Location, "expecting operator `" + op + "'");
    }
  }


  expect_keyword (op : string) : void {
    match (get_token ()) {
      | Token.Keyword (o) when op == o => ()
      | _ =>
        fatal_error ("expecting keyword `" + op + "'");
    }
  }

  flag_keyword (kw : string) : bool {
    match (get_token ()) {
      | Token.Keyword (n) when n == kw => true
      | _ => push_back (); false
    }
  }

  parse_funparm (allow_inference : bool) : Fun_parm {
    def (atts, _) = get_attrs (System.AttributeTargets.Parameter, System.AttributeTargets.Parameter);
    match (peek_token ()) {
      | Token.Keyword ("params") =>
        shift ();
        atts.custom_attrs = <[ System.ParamArrayAttribute ]> :: atts.custom_attrs;
      | _ => ()
    };
    def id = get_splicable_id ();
    def t =
      match (get_token ()) {
        | Token.Operator (":", _) => parse_toplevel_expr ()
        | _ when allow_inference => push_back (); PExpr.Wildcard ()
        | _ => fatal_error ("expecting typing constraint after parameter name")
      };
    match (peek_token ()) {
      | Token.Operator ("=", _) => 
        shift ();
        def e = parse_expr ();
        atts.custom_attrs = <[ System.ComponentModel.DefaultValueAttribute ($e)
                            ]> :: atts.custom_attrs;
      | _ => ()
    };
    Fun_parm (loc = id.loc, name = id, ty = t, modifiers = atts)
  }

  // `splicing_type' is for noting, that there are spliced tyvars
  // if yes, it's PType.Spliced with expression describing their list
  // else it's PType.Void ()
  parse_tyvars () : list [Fun_parm]
  {
    match (get_token ()) {
      | Token.Operator ("<", _) as _tok =>
        Message.warning (_tok.Location, "this syntax is obsolete, use foo ['a, ..]");
        match (peek_token ()) {
          | Token.Operator (".", _) =>
            def loc = expect_operator_loc ("..");
            match (get_splicable_id ()) {
              | Splicable.Name | Splicable.Int =>
                fatal_error ("expected spliced expression")
              | Splicable.Expression (e) =>
                expect_operator (">");                    
                [Fun_parm (loc, null, PExpr.Spliced (e), Modifiers.Empty)]
            }
          | _ =>
            def tyvars = operator_separated_list (",", fun () { parse_funparm (true) } );
            expect_operator (">");
            tyvars
        }
      | Token.Operator ("[", _) =>
        match (peek_token ()) {
          | Token.Operator (".", _) =>
            def loc = expect_operator_loc ("..");
            match (get_splicable_id ()) {
              | Splicable.Name | Splicable.Int =>
                fatal_error ("expected spliced expression")
              | Splicable.Expression (e) =>
                expect_operator ("]");
                [Fun_parm (loc, null, PExpr.Spliced (e), Modifiers.Empty)]
            }
          | _ =>
            def tyvars = operator_separated_list (",", fun () { parse_funparm (true) });
            expect_operator ("]");
            tyvars
        }
      | _ => push_back (); []
    };
  }
  
  /** eats exactly header with [name], [(parameters)] and inferencable [: type] */
  parse_fun_header (allow_inference : bool, 
                    allow_ctor : bool,
                    is_lambda : bool, 
                    knownname : option [Splicable]) : Fun_header * bool
  {
    mutable is_ctor = false;
    mutable loc = Location.Default;
    mutable is_indexer = false;
    
    def name = 
      match (knownname) {
        | None =>
          match (peek_token ()) {
            | Token.Keyword ("this") when allow_ctor =>
              loc = shift_loc ();
              is_ctor = true; Splicable.Name (Name ([".ctor"]))
            | Token.Keyword ("fun") when is_lambda =>
              loc = shift_loc (); Splicable.Name (Name ([]))
            | _ when is_lambda => fatal_error ("expecting `fun'")
            | Token.Identifier  
            | Token.Operator ("$", _) => get_splicable_id ()
            | t => Message.fatal_error (t.Location, "expecting function name")
          }
        | Some (n) => n
      };
    def tyvars = parse_tyvars ();
    def parse_parm () { parse_funparm (allow_inference) };
    def parms =
      match (peek_token ()) {
        | Token.Operator ("(", _) =>
          shift ();
          def pars =
            match (peek_token ()) {
              | Token.Operator (")", _) => []
              | Token.Operator (".", _) =>
                expect_operator ("..");
                match (get_splicable_id ()) {
                  | Splicable.Expression (e) =>
                      [Fun_parm (e.loc, Splicable.Name (Name ([])), PExpr.Void (), 
                                 Modifiers (NemerleAttributes.None, [PExpr.Spliced (e)]))]
                  | Splicable.Name | Splicable.Int =>
                    fatal_error ("expected spliced expression")
                  }
              | _ => operator_separated_list (",", parse_parm)
            };
          expect_operator (")");
          pars
          
        | Token.Operator ("[", _) =>
          shift ();
          def pars = 
            match (peek_token ()) {
              | Token.Operator ("]", _) => []
              | Token.Operator (".", _) =>
                expect_operator ("..");
                match (get_splicable_id ()) {
                  | Splicable.Expression (e) =>
                      [Fun_parm (e.loc, Splicable.Name (Name ([])), PExpr.Void (), 
                                 Modifiers (NemerleAttributes.None, [PExpr.Spliced (e)]))]
                  | Splicable.Name | Splicable.Int =>
                    fatal_error ("expected spliced expression")
                  }
              | _ => operator_separated_list (",", parse_parm)
            };
          expect_operator ("]");
          is_indexer = true;
          pars
          
        | _ =>
          is_indexer = true;
          tyvars
      }
    def tyvars = if ((tyvars : object) == parms) [] else tyvars;
    def tok = get_token ();
    loc += tok.Location;
    def ret_type =
      match (tok) {
        | _ when is_ctor => push_back (); PExpr.Void ()
        | Token.Operator (":", _) => parse_toplevel_expr ()
        | _ when allow_inference => push_back (); PExpr.Wildcard ()
        | _ => fatal_error ("expecting typing constraint on function return value")
      };

    def typarms = parse_where_constraints (tyvars);

    (Fun_header (loc,
                name = name,
                ret_type = ret_type, 
                parms = parms, 
                typarms = typarms), is_indexer)
  }

  parse_literal () : option [Literal]
  {
    match (get_token ()) {
      | Token.Keyword ("null") => Some (Literal.Null ())
      | Token.Keyword ("true") => Some (Literal.Bool (true))        
      | Token.Keyword ("false") => Some (Literal.Bool (false))
      | Token.Operator ("(", _) =>
        match (get_token ()) {
          | Token.Operator (")", _) => Some (Literal.Void ())
          | _ => push_back (); push_back (); None ()
        }
      | Token.StringLiteral (s) => Some (Literal.String (s))
      | Token.ByteLiteral (n) => Some (Literal.Byte (n))
      | Token.SByteLiteral (n) => Some (Literal.SByte (n))
      | Token.ShortLiteral (n) => Some (Literal.Short (n))
      | Token.UShortLiteral (n) => Some (Literal.UShort (n))
      | Token.IntLiteral (n) => Some (Literal.Int (n))
      | Token.UIntLiteral (n) => Some (Literal.UInt (n))
      | Token.LongLiteral (n) => Some (Literal.Long (n))
      | Token.ULongLiteral (n) => Some (Literal.ULong (n))
      | Token.FloatLiteral (n) => Some (Literal.Float (n))
      | Token.DoubleLiteral (n) => Some (Literal.Double (n))
      | Token.DecimalLiteral (n) => Some (Literal.Decimal (n))                
      | Token.CharLiteral (c) => Some (Literal.Char (c))
      | _ => push_back (); None ()
    }
  }

  // builds an PExpr.Match expression for the 'is' keyword
  build_match_for_is (expr : PExpr, ty : PExpr) : PExpr
  {
    def id = Splicable.Name (Name ("_N_is"));
    def pat = PExpr.As (expr.loc, PExpr.TypeEnforcement (expr.loc, 
                                                         PExpr.Wildcard (expr.loc), ty), id);
    
    build_match_for_isp (expr, pat)
  }
  
  // builds an PExpr.Match expression for the 'isp' keyword
  build_match_for_isp (expr : PExpr, pat : PExpr) : PExpr
  {
    PExpr.Match (expr.loc + pat.loc, expr,
             [MatchCase ([(pat, None ())], PExpr.Literal (expr.loc, Literal.Bool (true))),
              MatchCase ([(PExpr.Wildcard (expr.loc), None ())], PExpr.Literal (expr.loc, Literal.Bool (false)))])
  }
  
  parse_closed_prim_expr () : PExpr {
    def loc = location_here ();
    match (parse_literal ()) {
      | Some (l) => PExpr.Literal (loc, l)
      | None =>
        def problem () {
          Message.fatal_error (loc, describe () + "expecting primary expression")
        };
        
        match (get_token ()) {
          | Token.Keyword ("void") => PExpr.Void (loc)
          | Token.Keyword ("this") => PExpr.This (loc)
          | Token.Keyword ("base") => PExpr.Base (loc)
          | Token.Keyword ("_") => PExpr.Wildcard (loc)
          | Token.Keyword ("typeof") => 
            expect_operator ("(");
            def type_expr = parse_expr ();
            expect_operator (")");
            PExpr.Typeof (loc, type_expr)

          | Token.Keyword ("array") =>
            match (peek_token ()) {
              | Token.Operator ("[", _) | Token.Operator ("$", _) =>
                PExpr.Array (loc, <[ 1 ]>, parse_toplevel_expr ())

              | Token.Operator (".", _) =>
                expect_operator (".");
                expect_operator ("[");
                def rank = match (get_token ()) {
                             | Token.IntLiteral (i) when i > 0 => <[ $(i : int) ]>
                             | Token.IntLiteral =>
                               fatal_error ("array rank must be positive");
                             | Token.Operator ("$", _) =>
                               push_back ();
                               parse_spliced_expr ();
                             | _ => fatal_error ("expected integer array rank");
                }
                expect_operator ("]");
                match (peek_token ()) {
                  | Token.Operator ("[", _) | Token.Operator ("$", _) =>
                     PExpr.Array (loc, rank, parse_expr ());
                  | _ =>
                    fatal_error ("expected [ ... elements of array ] after `array.[rank]'")
                }

              | Token.Operator (o, _) when o.StartsWith ("<") =>
                Message.warning ("this syntax is obsolete, use `type[args]'");
                expect_operator ("<");
                def rank = match (get_token ()) {
                             | Token.IntLiteral (i) when i > 0 => <[ $(i : int) ]>
                             | Token.IntLiteral =>
                               fatal_error ("array rank must be positive");
                             | Token.Operator ("$", _) =>
                               push_back ();
                               parse_spliced_expr ();
                             | _ => fatal_error ("expected integer array rank");
                }
                expect_operator (">");
                match (peek_token ()) {
                  | Token.Operator ("[", _) | Token.Operator ("$", _) =>
                     PExpr.Array (loc, rank, parse_expr ());
                  | _ =>
                    fatal_error ("expected [ ... elements of array ] after `array [rank]'")
                }

              | Token.Operator ("(", _) =>
                shift ();
                def exprs = operator_separated_list (",", parse_expr);
                expect_operator (")");
                PExpr.EmptyArray (loc, exprs)

              | _ => fatal_error ("expected [ ... elements of array ], ( ... "
                                  "sizes of empty array )  or [rank] after `array'")
            }
            
          | Token.Identifier (n) => PExpr.Ref (loc, Name ([n]))

          // tuples
          | Token.Operator ("(", _) =>
            def expr = parse_expr ();
            match (get_token ()) {
              | Token.Operator (",", _) =>
                def exprs = expr :: operator_separated_list (",", parse_expr);
                expect_operator (")");
                PExpr.Tuple (loc, exprs)
                
              | Token.Operator (")", _) => 
                match (expr) {
                  | PExpr.Ellipsis => PExpr.Tuple (loc, [expr])
                  | _ => expr
                }              

              | _ => Message.fatal_error (loc, describe () + "unbalanced `('")
            }

          | Token.Operator ("$", _) =>
            match (peek_token ()) {
              | Token.StringLiteral (str) =>
                shift ();
                <[ Nemerle.IO.sprint ($(str : string)) ]>
              | _ =>
                push_back ();
                parse_spliced_expr ();
            }

          | Token.Operator (o, _) as tok =>
            def parse_paren (p : ParenCallback) {
              def expr = p.parsing_function ();
              def loc = expect_operator_loc (p.closing_paren);
              expr.loc = tok.Location + loc;
              expr
            };

            def loop (i, o : string) {
              if (i > 0)
                match (ctx.parens.Get (o.Substring (0, i))) {
                  | Some (x)  => (i, Some (x))
                  | _ => loop (i - 1, o)
                }
              else
                (0, None ())
            };
            
            match (ctx.parens.Get (o)) {
              | Some (p) => parse_paren (p)
              | None =>
                match (loop (o.Length - 1, o)) {
                  | (i, Some (p)) =>
                    push_back (Token.Operator (o.Substring (i), 0));
                    parse_paren (p)
                  | (_, None) =>
                    match (get_token ()) {
                      | Token.Operator (o', _) =>
                        match (ctx.parens.Get (o + o')) {
                          | Some (p) => parse_paren (p)
                          | None => push_back (); problem ()
                        }
                      | _ => push_back (); problem ()
                    }
                }
            }
            
          | _ => problem ()
        }
    }
  }

  parse_spliced_expr () : PExpr {
    match (get_splicable_id ()) {
      | Splicable.Expression (e) =>
        match (e) {
          | PExpr.Spliced (PExpr.TypeEnforcement) => e
          | _ => PExpr.Spliced (e)
        }
      | Splicable.Name | Splicable.Int => Util.ice ("expected spliced expression")
    }
  }

  parse_prim_expr (expr : PExpr) : PExpr {
    match (get_token ()) {
      | Token.Operator ("[", _) =>
        def exprs = operator_separated_list (",", parse_expr);
        def loc = expect_operator_loc ("]");
        parse_prim_expr (PExpr.Indexer (expr.loc + loc, expr, exprs))
          
      | Token.Operator (".", _) => 
        def id = get_splicable_id ();
        parse_prim_expr (PExpr.Member (expr.loc + id.loc, expr, id))
          
      | Token.Operator ("(", _) =>
        def (loc, parms) =
          match (peek_token ()) {
            | Token.Operator (")", _) => (shift_loc (), [])
            | _ => 
              def parms = operator_separated_list (",", parse_expr);
              (expect_operator_loc (")"), parms)
          };
        //Message.debug (loc.Column.ToString () + " " + loc.EndColumn.ToString ());   
        parse_prim_expr (PExpr.Call (expr.loc + loc, expr, parms))

      | Token.Keyword ("_") =>
        PExpr.Application (expr.loc, expr, PExpr.Wildcard ())

      | _ => push_back (); expr
    }
  }

  parse_unary_expr () : PExpr {
    match (peek_token ()) {
      | Token.Operator ("(", _)
      | Token.Operator ("$", _) => parse_prim_expr (parse_closed_prim_expr ())

      | Token.Operator (".", _) =>
        expect_operator ("..");
        match (get_splicable_id ()) {
          | Splicable.Expression (e) =>
            PExpr.Ellipsis (e.loc, PExpr.Spliced (e))                
          | Splicable.Name | Splicable.Int =>
            fatal_error ("expected spliced expression")
        }

      | Token.Operator (o, pri) =>
        def unary () {
          def loc = shift_loc ();
          when (pri == 0)
            Message.fatal_error (loc, $"operator `$(o)' cannot be used in unary context");
          def subexpr = parse_unary_expr ();
          PExpr.Call (loc + subexpr.loc, PExpr.Ref (loc, Name ([o])), [subexpr])
        };
        
        if (ctx.parens.Contains (o))
          parse_prim_expr (parse_closed_prim_expr ())
        else {
          shift ();
          def tok = peek_token ();
          push_back ();
          match (tok) {
            | Token.Operator (o', _) =>
              if (ctx.parens.Contains (o + o'))
                parse_prim_expr (parse_closed_prim_expr ())
              else unary ()
            | _ => unary ()
          }
        }
      | _ => parse_prim_expr (parse_closed_prim_expr ())
    }
  }

  parse_case_guard () : PExpr * option [PExpr] {
    def pat = parse_expr ();
    if (flag_keyword ("when"))
      (pat, Some (parse_expr ()))
    else (pat, None ());
  }


  parse_match_case () : MatchCase {
    def loop2 (acc) {
      def res = parse_case_guard ();
      match (get_token ()) {
        | Token.Operator ("=>", _) => List.Rev (res :: acc)
        | Token.Operator ("|", _) => loop2 (res :: acc)
        | _ => fatal_error ("found junk after pattern")
      }
    };
    
    // eat pattern part and '=>'
    def pats = 
      match (peek_token ()) {
        | Token.Operator ("|", _) => 
          shift ();
          match (peek_token ()) {
            | Token.Operator (".", _) =>
              expect_operator ("..");
              match (get_splicable_id ()) {
                | Splicable.Expression (e) =>
                  expect_operator ("=>");
                  [(PExpr.Ellipsis (e.loc, PExpr.Spliced (e)), None ())]                  
                | Splicable.Name | Splicable.Int =>
                  fatal_error ("expected spliced expression")
              }
            | _ => loop2 ([])
          }
        | _ => loop2 ([])
      };

    def loc' = location_here ();
    def expr =
      match (parse_expr_sequence ()) {
        | [x] => x
        | l => PExpr.Sequence (loc', l)
      };

    MatchCase (pats, expr)
  }

  parse_toplevel_expr () : PExpr
  {
    def tok = get_token ();
    def loc = tok.Location;    
    //Message.debug ("pse " + token_name (tok));
    match (tok) {
      | Token.Operator ("{", _) =>
        def res = parse_maybe_null_expr_sequence ();
        def endloc = expect_operator_loc ("}");
        PExpr.Sequence (loc + endloc, res);

      | Token.Keyword ("ref") =>
        def refexpr = parse_expr ();
        PExpr.ParmByRef (loc + refexpr.loc, refexpr)
        
      | Token.Keyword ("out") =>
        def outexpr = parse_expr ();
        PExpr.ParmOut (loc + outexpr.loc, outexpr)
        
      | Token.Keyword ("match") =>
        expect_operator ("(");
        def expr = parse_expr ();
        expect_operator (")");
        match (get_token ()) {
          | Token.Operator ("{", _) =>
            match (peek_token ()) {
              | Token.Operator (".", _) =>
                expect_operator ("..");
                match (get_splicable_id ()) {
                  | Splicable.Expression (e) =>
                    expect_operator ("}");                  
                    PExpr.Match (loc, expr, 
                             [MatchCase ([], PExpr.Ellipsis (e.loc, PExpr.Spliced (e)))]);
                  | Splicable.Name | Splicable.Int =>
                    fatal_error ("expected spliced expression")
                }
              | _ =>
                push_back ();
                def cases = collect_braced_list (parse_match_case);
                PExpr.Match (loc, expr, cases)
            }
          | _ =>
            fatal_error ("expecting '{' after 'match (e)'")
        }
        
      | Token.Keyword ("throw") =>
        def exn = parse_expr ();
        PExpr.Throw (loc + exn.loc, exn)

      | Token.Keyword ("try") =>
        def body = parse_block ([]);
        match (get_token ()) {
          | Token.Keyword ("catch") =>
            def parse_with () {
              match (peek_token ()) {
                | Token.Operator ("|", _) => shift ()
                | _ => ()
              };
              def id = get_splicable_id ();
              expect_operator (":");
              def t = parse_expr ();
              expect_operator ("=>");
              match (parse_expr_sequence ()) {
                | [x] => (id, t, x)
                | l => (id, t, PExpr.Sequence (loc, l))
              }
            };

            def mktry (h, body) {
              def (id, t, handler) = h;
              PExpr.TryWith (loc, body, id, t, handler)
            };
            
            def res = List.FoldLeft (collect_braced_list (parse_with), 
                                     body, mktry);

            match (get_token ()) {
              | Token.Keyword ("finally") =>
                def handler = parse_block ([]);
                PExpr.TryFinally (loc, res, handler)
                
              | _ => push_back (); res
            }
            
          | Token.Keyword ("finally") =>
            def handler = parse_block ([]);
            PExpr.TryFinally (loc, body, handler)

          | _ => fatal_error ("expecting `catch' or `finally'")
        }

      | Token.Keyword ("fun") =>
        push_back ();
        def (h, _) = parse_fun_header (allow_ctor = false,
                                  allow_inference = true, 
                                  is_lambda = true, 
                                  knownname = None ());
        def expr = parse_block (h.parms);
        PExpr.Lambda (loc + expr.loc, Function_decl (h, expr))

      | Token.Keyword ("mutable") =>
        def id = get_splicable_id ();
        match (get_token ()) {
          | Token.Operator ("<-", _) =>
            Message.warning ("<- assignment operator is obsolete, use `var = expr'");
            PExpr.Define (loc, true, id, parse_expr ())
          | Token.Operator ("=", _) =>
            def val = parse_expr ();
            PExpr.Define (loc + val.loc, true, id, val)
          | _ =>
            fatal_error ("expected assignment operator =")
        };

      | Token.Keyword ("def") =>
        def parse_val (id) {
          expect_operator ("=");
          def val = parse_expr ();
          PExpr.Define (loc + val.loc, false, id, val)
        };
        def parse_pat (idopt) {
          def pat =
            match (idopt) {
              | None => parse_closed_prim_expr ()
              | Some (Splicable.Name (id)) => parse_prim_expr (PExpr.Ref (loc, id))
              | Some (Splicable.Expression (e)) => parse_prim_expr (PExpr.Spliced (e.loc, e))
              | Some (Splicable.Int) => Util.ice ("unexpected splicable int")
            };
          expect_operator ("=");
          def expr = parse_expr ();
          PExpr.DefPattern (loc + expr.loc, pat, expr)
        };
        def parse_funs (acc, idopt) {
          def (h, _) = parse_fun_header (allow_ctor = false, 
                                    allow_inference = true, 
                                    is_lambda = false, knownname = idopt);
          def fd = Function_decl (h, parse_block (h.parms));
          match (peek_token ()) {
            | Token.Keyword ("and") =>
              shift ();
              parse_funs (fd :: acc, None ())
            | _ => PExpr.DefFunctions (loc + h.loc, List.Rev (fd :: acc))
          }
        };
        
        match (peek_token ()) {
          | Token.Keyword ("_")
          | Token.Operator ("$", _) 
          | Token.Identifier =>
            def id = get_splicable_id ();
            match (peek_token ()) {
              | Token.Operator ("[", _) 
              | Token.Operator ("(", _) 
              | Token.Operator ("<", _) => 
                parse_funs ([], Some (id))
                
              | Token.Operator ("=", _) =>
                parse_val (id)
              
              | _ => parse_pat (Some (id))
            }

          | Token.Operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | Splicable.Expression (e) =>
                PExpr.DefFunctions (loc, [Function_decl (null, 
                                               PExpr.Ellipsis (PExpr.Spliced (e)))])

              | _ => fatal_error ("expected spliced expression")
            }
          | _ => parse_pat (None ())
        }

      | Token.Keyword (k) =>
        match (ctx.keywords.Get (k)) {
          | Some (parsing_function) => parsing_function ()
          | None => push_back (); parse_operator_expr ()
        }
       
      | _ => push_back (); parse_operator_expr ()
    }
  }

  parse_operator_expr () : PExpr
  {
    def is_paren (s) {
      ctx.parens.Contains (s) || ctx.closing_parens.Contains (s) || s == "$"
    };

    def make_bin (op, e1 : PExpr, e2 : PExpr) {
      def loc = e1.loc + e2.loc;
      match (op) {
        | "=" =>  PExpr.Assign (loc, e1, e2)
        | "<-" =>
          Message.warning ("<- assignment operator is obsolete, use `var = expr'");
          PExpr.Assign (loc, e1, e2)

        | ":" => PExpr.TypeEnforcement (loc, e1, e2)
        | ":>" => PExpr.TypeConversion (loc, e1, e2)
        | "::" => PExpr.Call (loc, PExpr.Ref (loc, Name (["Cons"])), [e1, e2])
        | _ =>
          PExpr.Call (loc, PExpr.Ref (loc, Name ([op])), [e1, e2])
      }
    };
    
    def parse_pri (pri) : PExpr {
      def loop_left (expr) {
        match (get_token ()) {
          | Token.Keyword ("is") when pri == 9 =>
            def ty = parse_expr ();
            loop_left (build_match_for_is (expr, ty))
            
          | Token.Keyword ("matches") when pri == 9 =>
            def pat = parse_expr ();
            loop_left (build_match_for_isp (expr, pat))

          | Token.Keyword ("as") when pri == 9 =>
            def id = get_splicable_id ();
            loop_left (PExpr.As (expr.loc + id.loc, expr, id))

          | Token.Operator (s, p) when p == pri && !is_paren (s) =>
            def expr' = parse_pri (pri - 1);
            loop_left (make_bin (s, expr, expr'))
          | _ => 
            push_back (); 
            expr
        }
      };

      def loop_right () {
        def expr = parse_pri (pri - 1);
        match (get_token ()) {
          | Token.Operator (s, p) when p == pri && !is_paren (s) =>
            make_bin (s, expr, loop_right ())
          | _ => push_back (); expr
        }
      };
     
      match (pri) {
        | 0 => parse_unary_expr ()
        | 1 | 8 => loop_right ()
        | _ => loop_left (parse_pri (pri - 1))
      }
    };

    parse_pri (9)
  }

  parse_expr () : PExpr
  {
    def expr = parse_toplevel_expr ();
    match (get_token ()) {
      | Token.Operator ("<-", _) =>
        Message.warning ("<- assignment operator is obsolete, use `var = expr'");
        def expr' = parse_toplevel_expr ();
        PExpr.Assign (expr.loc + expr'.loc, expr, expr')
                
      | Token.Operator ("=", _) =>
        def expr' = parse_toplevel_expr ();
        PExpr.Assign (expr.loc + expr'.loc, expr, expr')

      | Token.Operator ("{", _) =>
        push_back ();
        def seq = parse_expr ();
        PExpr.Application (expr.loc + seq.loc, expr, seq)

      | _ => push_back (); expr
    }
  }

  parse_expr_sequence () : list [PExpr] {
    def loop (acc) {
      def last = last_token ();
      match (get_token ()) {
        | Token.Operator (";", _) =>
          match (peek_token ()) {
            | Token.Operator ("}", _) 
            | Token.Operator ("|", _) 
            | Token.Operator ("]", _) 
              => List.Rev (acc)
            | _ => loop (parse_expr () :: acc)
          }
        | Token.Operator ("}", _) 
        | Token.Operator ("|", _) 
        | Token.Operator ("]", _) => push_back (); List.Rev (acc)
        | _ =>
          match (last) {
            | Token.Operator ("}", _) =>
              push_back ();
              loop (parse_expr () :: acc)
            | _ =>
              fatal_error ("expecting the `;' separator after an expression in a sequence")
          }
      }
    };

    loop ([parse_expr ()])
  }

  parse_maybe_null_expr_sequence () : list [PExpr] {
    match (peek_token ()) {
      | Token.Operator ("}", _) 
      | Token.Operator ("]", _) => []
      | _ => parse_expr_sequence ()
    }
  }

  parse_block (parms : list [Fun_parm]) : PExpr 
  {
    def tok = peek_token ();
    def loc = tok.Location;
    match (tok) {
      // entire function body may be spliced
      | Token.Operator ("$", _) =>
        parse_expr ()

      // standard body enclosed by { ... }
      | Token.Operator ("{", _) =>
        shift ();
        match (peek_token ()) {
          | Token.Operator ("}", _) => 
            def loc1 = shift_loc (); 
            PExpr.Sequence (loc + loc1, [])
            
          | Token.Operator ("|", _) =>
            // convert function's parameters to tuple to be matched
            def parms_to_tupl (prs : list [Fun_parm], acc) {
              match (prs) {
                | [] => PExpr.Tuple (List.Rev (acc))
                | ({name = Splicable.Name (x); loc = l}) :: xs => 
                  parms_to_tupl (xs, PExpr.Ref (l, x) :: acc)
                | _ => fatal_error ("illegal spliced parameter?")
              }
            };
            push_back ();
            def cases = collect_braced_list (parse_match_case);
            match (parms) {
              | [{name = Splicable.Name (x)}] => 
                PExpr.Match (loc, PExpr.Ref (loc, x), cases)
              | _::_::_ => 
                def tup = parms_to_tupl (parms, []);
                tup.loc = loc;
                PExpr.Match (loc, tup, cases)
              | [] =>             
                fatal_error ("functions with direct matching must have parameters")
              | _ => fatal_error ("illegal spliced parameter?")
            }
          | _ => 
            def seq = parse_expr_sequence ();
            def loc1 = expect_operator_loc ("}");
            PExpr.Sequence (loc + loc1, seq);
        }
      | _ =>
        fatal_error ("expected `{' at the beginning of function body")
    }
  }
  

  /** allowed targets are:
        assembly: assembly 
        module:  module   (not supprted currently)
        class, struct, interface, enum: type 
        delegate: type, return
        method: method, return
        parameter: param 
        field: field 
        property indexer: property 
        property get accessor: method, return
        property set accessor: method, param, return
        event field: event, field, method
        event property: event, property (what is this?)
        event add: method, param
        event remove: method, param
  */
  get_attrs (main_target : System.AttributeTargets, allowed_targets : System.AttributeTargets) 
  : Modifiers * Hashtable [System.AttributeTargets, list [PExpr]]
  {
    mutable other_atts = null;
    def distribute_attributes (current_target, exps : list [PExpr]) {
      if (current_target == System.AttributeTargets.All ||
          current_target == main_target)
        exps
      else {
        unless (current_target %&& allowed_targets)
          match (current_target) {
            | System.AttributeTargets.Assembly => 
              error ("[assembly: ...] custom attribute not allowed here");
            | System.AttributeTargets.Module  => 
              error ("[module: ...] custom attribute not allowed here");
            | System.AttributeTargets.Class =>
              error ("`type' target is here forbidden")     
            | System.AttributeTargets.Method  => 
              error ("`method' target is here forbidden")     
            | System.AttributeTargets.Property => 
              error ("`property' target is here forbidden")     
            | System.AttributeTargets.Field => 
              error ("`field' target is here forbidden")     
            | System.AttributeTargets.Event => 
              error ("`event' target is here forbidden")     
            | System.AttributeTargets.Parameter => 
              error ("`param' target is here forbidden")     
            | System.AttributeTargets.ReturnValue  => 
//              error ("`return' target is here forbidden") 
              Message.warning ("`return' target is not supported because of SRE limitations") 
            | x => Util.ice ("who set complex attribute? (" + x.ToString () + ")")
          }

        when (other_atts == null) other_atts = Hashtable ();
        match (other_atts.Get (current_target)) {
          | Some (l) => other_atts.Set (current_target, l + exps)
          | None => other_atts.Add (current_target, exps)
        };
        []
      }
    }

    def loop (acc, attrs) {
      def add_and_loop (attr : NemerleAttributes, attr_name : string) {
        when (attr %&& acc)
          Message.error ("attribute '" + attr_name + "' specified more than once");

        loop (attr %| acc, attrs)
      }
                        
      match (get_token ()) {
        | Token.Keyword ("mutable") => add_and_loop (NemerleAttributes.Mutable, "mutable")
        | Token.Keyword ("public") => add_and_loop (NemerleAttributes.Public, "public")
        | Token.Keyword ("private") => add_and_loop (NemerleAttributes.Private, "private")
        | Token.Keyword ("static") => add_and_loop (NemerleAttributes.Static, "static")
        | Token.Keyword ("new") => add_and_loop (NemerleAttributes.New, "new")
        | Token.Keyword ("protected") => add_and_loop (NemerleAttributes.Protected, "protected")
        | Token.Keyword ("internal") => add_and_loop (NemerleAttributes.Internal, "internal")
        | Token.Keyword ("abstract") => add_and_loop (NemerleAttributes.Abstract, "abstract")
        | Token.Keyword ("sealed") => add_and_loop (NemerleAttributes.Sealed, "sealed")
        | Token.Keyword ("override") => add_and_loop (NemerleAttributes.Override, "override")
        | Token.Keyword ("virtual") => add_and_loop (NemerleAttributes.Virtual, "virtual")
        | Token.Keyword ("volatile") => add_and_loop (NemerleAttributes.Volatile, "volatile")
        | Token.Keyword ("partial") => add_and_loop (NemerleAttributes.Partial, "partial")
        | Token.Operator ("[", _) =>
          def target = 
            match (get_token ()) {
              | Token.Identifier ("assembly") => System.AttributeTargets.Assembly
              | Token.Identifier ("field") => System.AttributeTargets.Field
              | Token.Keyword ("event") => System.AttributeTargets.Event
              | Token.Identifier ("method") => System.AttributeTargets.Method
              | Token.Keyword ("module") => System.AttributeTargets.Module
              | Token.Identifier ("param") => System.AttributeTargets.Parameter
              | Token.Identifier ("property") => System.AttributeTargets.Property
              | Token.Identifier ("return") => System.AttributeTargets.ReturnValue
              | Token.Keyword ("type") => System.AttributeTargets.Class
              | _ => 
                push_back ();
                System.AttributeTargets.All
            };
          when (target != System.AttributeTargets.All)
            expect_operator (":");

          def exps = operator_separated_list (",", parse_expr);
          expect_operator ("]");
          def main_attrs = distribute_attributes (target, exps);
          loop (acc, attrs + main_attrs)
        | _ =>
          push_back ();
          Modifiers (acc, attrs)
      }
    };

    def mods =
      match (peek_token ()) {
        | Token.Operator (".", _) =>
          expect_operator ("..");
          match (get_splicable_id ()) {
            | Splicable.Expression (e) =>
              Modifiers (NemerleAttributes.None, [PExpr.Ellipsis (PExpr.Spliced (e))])

            | _  => fatal_error ("expected spliced expression")
          }
        | _ =>
          loop (NemerleAttributes.None, [])
      }

    // perform some sanity checks on the declared attributes
    when (mods.mods %&& NemerleAttributes.Virtual &&
          mods.mods %&& NemerleAttributes.Override)
      Message.warning ("the `virtual' attribute is redundant, `override' implies `virtual'");

    (mods, other_atts)
  }

  take_attributes_out (from : Hashtable [System.AttributeTargets, list [PExpr]], 
                       what : System.AttributeTargets,
                       comply_on_other : bool) : list [PExpr]
  { 
    if (from != null) {
      def result = 
        match (from.Get (what)) {
          | Some (l) =>
            from.Remove (what);
            l
          | None => []
        };
      when (comply_on_other && from.Count > 0) {
        from.Iter (fun (x, y : list [PExpr]) { 
          match (y) { 
            | expr :: _ =>  Message.error (expr.loc, "unexpected attribute target: " + x.ToString ());
            | _ => Util.ice ("targetted attribute without attribute")
          }
        });
      }
      result
    }
    else []
  }
  
  operator_separated_list['a] (op : string, f : void -> 'a) : list ['a] {
    def loop (acc) {
      match (get_token ()) {
        | Token.Operator (o, _) when o == op => loop (f () :: acc)
        | _ => push_back (); List.Rev (acc)
      }
    };

    loop ([f ()])
  }

  decompose_tyvars (parms : list [Fun_parm]) : list [string * int]
  {
    List.Map (parms, fun (x : Fun_parm) {
      unless (x.ty is PExpr.Wildcard)
        Message.error (x.loc, "type variables must be single identifiers");
        unless (x.modifiers.mods == NemerleAttributes.None)
          Message.error (x.loc, "type variables must be single identifiers");
      match (x.name) {
        | Splicable.Name (n) =>
          (n.Id, n.color)
        | _ =>
          Message.fatal_error (x.loc, "type variables must be single identifiers");
      }
    })
  }
  
  parse_where_constraints (tyvars : list [Fun_parm]) : Typarms 
  {
    def loop (acc) {
      if (flag_keyword ("where")) {
        match (peek_token ()) {
          | Token.Operator (".", _) =>
            expect_operator ("..");
            match (get_splicable_id ()) {
              | Splicable.Expression (e) => (List.Rev (acc), PExpr.Spliced (e))
              | _ => fatal_error ("expected spliced expression")
            }
          | _ =>
            def tv = get_tyvar ();
            expect_operator (":");
            def types = operator_separated_list (",", parse_toplevel_expr);
            def acc = List.FoldLeft (types, acc, fun (t, acc) { 
              Constraint (tv, t) :: acc 
            });
            loop (acc)
        }
      } else (List.Rev (acc), PExpr.Void ())
    };
    def (where_cts, where_spl_t) = loop ([]);
    match (where_spl_t) {
      | PExpr.Void => Typarms (decompose_tyvars (tyvars), where_cts);
      | _ =>
        match (tyvars) {
          | [p] =>
            Typarms ([], Constraint (("", 0), PExpr.Tuple ([p.ty, where_spl_t])) 
                     :: where_cts)
          | _ =>
            fatal_error ("cannot use spliced where constraints when type variables are not spliced")
        }
    }
  }

  parse_property (name : Splicable, ret_ty : PExpr, prop_ty : PExpr,
                  attrs : Modifiers, dims : list[Fun_parm]) : ClassMember
  {
    def parse_bd (p) {
      match (peek_token ()) {
        | Token.Operator (";", _) =>
          shift ();
          (FunKind.Method ([]), FunBody.Abstract ())
        | _ =>
          def bl = parse_block (p);
          (FunKind.Method ([]), FunBody.Parsed (bl))
      };
    };

    mutable valid_targets = System.AttributeTargets.Method %| System.AttributeTargets.Field %|
      System.AttributeTargets.Parameter %| System.AttributeTargets.ReturnValue;
    mutable default_attrs = null;
    mutable other_attrs = null;

    def collect_attrs (main) {
      def (x, y) = get_attrs (main, valid_targets);
      default_attrs = x;
      other_attrs = y;
    }

    def plain_name = match (name) { | Splicable.Name (n) => n.Id | _ => "" };
    
    mutable set = None (); mutable get = None ();
    def loc = location_here ();
    
    // parse embedded fields and add PropertyEmbeddedField macros to attributes
    collect_attrs (0 :> System.AttributeTargets);
    while (match (peek_token ()) { 
      | Token.Identifier (i) when i != "set" && i != "get" => true 
      | _ => false }) 
    {
      def nm = get_splicable_id ();
      match (parse_field (loc, nm, (default_attrs, other_attrs), false)) {
        | ClassMember.Field { loc = loc; ty = t} =>
          def funparm = [Fun_parm (loc, nm, t, default_attrs)];
          attrs.custom_attrs = <[ $(Name (["PropertyEmbeddedField"]) : name) (fun (..$funparm) {}) ]> 
            :: attrs.custom_attrs;
        | _ =>
          fatal_error ("only plain fields can be embedded into the property")
      }
      collect_attrs (0 :> System.AttributeTargets);
    }

    valid_targets &= ~System.AttributeTargets.Field;
    
    def take_get () {
      def loc = location_here ();
      def (kind, bd) = parse_bd (dims);
      def name = Splicable.Name (Name ("get_" + plain_name));
      def fh = Fun_header (loc, name, ret_ty, dims);
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      get = Some (ClassMember.Function (loc, fh.name, default_attrs, fh, kind, bd));
    }
    def take_set () {
      def loc = location_here ();
      def par_atts = Modifiers (NemerleAttributes.None, 
        take_attributes_out (other_attrs, System.AttributeTargets.Parameter, false));
      def setter_parms = dims + [Fun_parm (Splicable.Name (Name (["value"])), ret_ty, par_atts)];
      def (kind, bd) = parse_bd (setter_parms);
      def name = Splicable.Name (Name ("set_" + plain_name));
      def fh = Fun_header (loc, name, PExpr.Void (), setter_parms);
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      set = Some (ClassMember.Function (loc, fh.name, default_attrs, fh, kind, bd));
      valid_targets &= ~System.AttributeTargets.Parameter;
    }

    match (get_token ()) {
      | Token.Identifier ("get") =>
        take_get ();
        collect_attrs (System.AttributeTargets.Method);

        match (get_token ()) {
          | Token.Identifier ("set") =>
            take_set ();
            expect_operator ("}");

          | Token.Operator ("}", _) => ()
          | _ => fatal_error ("expecting `set' section of property or `}'")
        }

      | Token.Identifier ("set") =>
        take_set ();
        collect_attrs (System.AttributeTargets.Method);   
        match (get_token ()) {
          | Token.Identifier ("get") =>
            take_get ();
            expect_operator ("}");

          | Token.Operator ("}", _) => ()
          | _ => fatal_error ("expecting `get' section of property or `}'")
        }
      | _ => fatal_error ("expecting `set' of `get' section of property")
    };

    ClassMember.Property (loc = loc, name = name, modifiers = attrs, ty = ret_ty,
                prop_ty = prop_ty, set = set, get = get, dims = dims)
  }

  parse_event (name : Splicable, t : PExpr,
               attrs : Modifiers) : ClassMember
  {
    def parse_bd (p) {
      match (peek_token ()) {
        | Token.Operator (";", _) =>
          shift ();
          (FunKind.Method ([]), FunBody.Abstract ())
        | _ =>
          def bl = parse_block (p);
          (FunKind.Method ([]), FunBody.Parsed (bl))
      };
    };

    mutable valid_targets = System.AttributeTargets.Method %| System.AttributeTargets.Field %|
      System.AttributeTargets.Parameter %| System.AttributeTargets.ReturnValue;
    mutable default_attrs = null;
    mutable other_attrs = null;

    def collect_attrs (main) {
      def (x, y) = get_attrs (main, valid_targets);
      default_attrs = x;
      other_attrs = y;
    }

    def plain_name = match (name) { | Splicable.Name (n) => n.Id | _ => "" };
    mutable add = None (); mutable remove = None ();
    def loc = location_here ();

    // parse embedded fields and add EventEmbeddedField macros to attributes
    collect_attrs (0 :> System.AttributeTargets);
    while (match (peek_token ()) { 
      | Token.Identifier (i) when i != "remove" && i != "add" => true 
      | _ => false }) 
    {
      def nm = get_splicable_id ();
      match (parse_field (loc, nm, (default_attrs, other_attrs), false)) {
        | ClassMember.Field { loc = loc; ty = t} =>
          def funparm = [Fun_parm (loc, nm, t, default_attrs)];
          attrs.custom_attrs = <[ EventEmbeddedField (fun (..$funparm) {}) ]> 
            :: attrs.custom_attrs;
        | _ =>
          fatal_error ("only plain fields can be embedded into the event")
      }
      collect_attrs (0 :> System.AttributeTargets);
    }

    valid_targets &= ~System.AttributeTargets.Field;
    def value_parm = Fun_parm (Splicable.Name (Name (["value"])), t, Modifiers.Empty);

    def take_remove () {
      def (kind, bd) = parse_bd ([value_parm]);
      def name = Splicable.Name (Name ("remove_" + plain_name));
      def fh = Fun_header (loc, name, PExpr.Void (), [value_parm]);
      value_parm.modifiers = Modifiers (NemerleAttributes.None, 
        take_attributes_out (other_attrs, System.AttributeTargets.Parameter, false));
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      remove = Some (ClassMember.Function (loc, name, default_attrs, fh, kind, bd) :>
                     ClassMember.Function);
    }
    def take_add () {
      def (kind, bd) = parse_bd ([value_parm]);
      def name = Splicable.Name (Name ("add_" + plain_name));
      def fh = Fun_header (loc, name, PExpr.Void (), [value_parm]);
      value_parm.modifiers = Modifiers (NemerleAttributes.None, 
        take_attributes_out (other_attrs, System.AttributeTargets.Parameter, false));
      def targeted = take_attributes_out (other_attrs, System.AttributeTargets.Method, true);
      default_attrs.custom_attrs = targeted + default_attrs.custom_attrs;
      add = Some (ClassMember.Function (loc, name, default_attrs, fh, kind, bd) :>
                  ClassMember.Function);
    }
    
    match (get_token ()) {
      | Token.Identifier ("remove") =>
        take_remove ();
        collect_attrs (System.AttributeTargets.Method);

        match (get_token ()) {
          | Token.Identifier ("add") =>
            take_add ();
            expect_operator ("}");
                                                
          | Token.Operator ("}", _) => ()
          | _ => fatal_error ("expecting `add' section of event or `}'")
        }

      | Token.Identifier ("add") =>
        take_add ();
        collect_attrs (System.AttributeTargets.Method);

        match (get_token ()) {
          | Token.Identifier ("remove") =>
            take_remove ();
            expect_operator ("}");

          | Token.Operator ("}", _) => ()
          | _ => fatal_error ("expecting `remove' section of event or `}'")
        }
      | _ => fatal_error ("expecting `add' or `remove' section of event")
    };
    ClassMember.Event (loc = loc, name = name, modifiers = attrs, ty = t,
             add = add, remove = remove)
  }
  
  parse_field (loc : Location, name : Splicable, 
               rich_mods : Modifiers * Hashtable [System.AttributeTargets, list [PExpr]],
               is_event : bool) : ClassMember
  {      
    def (attrs, other_attrs) = rich_mods;
    expect_operator (":");
    def t = parse_toplevel_expr ();

    match (get_token ()) {
      | Token.Operator (";", _) =>
        if (is_event) {
          // FIXME: hack for embedded field and method targeted attributes in events
          def hacking_insert_field (x) {
            <[ ("field", $x) ]>
          }
          def hacking_insert_method (x) {
            <[ ("method", $x) ]>
          }
          attrs.custom_attrs += List.Map (take_attributes_out (other_attrs, System.AttributeTargets.Field, false),
                                          hacking_insert_field);
          attrs.custom_attrs += List.Map (take_attributes_out (other_attrs, System.AttributeTargets.Method, true),
                                          hacking_insert_method);

          ClassMember.Event (loc = loc, name = name, modifiers = attrs, ty = t,
                   add = None (), remove = None ())
        }
        else {
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Field, true);
          ClassMember.Field (loc = loc, name = name, modifiers = attrs, ty = t)
        }

      | Token.Operator ("{", _) =>
        if (is_event) {
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Event, false);
          parse_event (name, t, attrs)
        }
        else
        {
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Property, true);
          parse_property (name, t, t, attrs, [])
        }

      | Token.Operator ("=", _) =>
        def val = parse_expr ();
        expect_operator (";");
        def initializer = <[ $(Name (["StaticInitializer"]) : name) ]>;
        attrs.custom_attrs = <[ $initializer ($val) ]> :: attrs.custom_attrs;
        if (is_event)
          ClassMember.Event (loc = loc, name = name, modifiers = attrs, ty = t,
                   add = None (), remove = None ())
        else
          ClassMember.Field (loc = loc, name = name, modifiers = attrs, ty = t)

      | _ =>
        if (is_event)
          fatal_error ("expecting `;' finishing event declaration or `{'"
                       " for its body")
        else
          fatal_error ("expecting `;' finishing field declaration or `{'"
                       " for property declaration")
    }
  }

  parse_method (loc : Location, id : option [Splicable],
                attrs : Modifiers, other_attrs : Hashtable [System.AttributeTargets, list [PExpr]])
                : ClassMember
  {
    def parse_extern () {
      expect_keyword ("extern");
      match (get_token ()) {
        | Token.StringLiteral (s) => 
          expect_operator (";");
          s
        | _ => fatal_error ("found some junk after extern (expecting string)")
      }
    };
    
    def ctr = 
      match (peek_token ()) {
        | Token.Keyword ("this") => true
        | _ => false
      };
    def (h, is_indexer) = parse_fun_header (allow_ctor = ctr, 
                                            allow_inference = false,
                                            is_lambda = false,
                                            knownname = id);
      
    if (is_indexer) {
      expect_operator ("{");
      attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Property, true);      
      def (prop_ty, indexer_parms) =
        match (h.parms) {
          | [parm] =>
            (PExpr.Call (PExpr.Ref (Name (["->"])), [parm.ty, h.ret_type]), [parm])

          | [] => (h.ret_type, [])
            
          | (x :: xs) as parms =>
            def parms_prod_type =
              List.FoldLeft (xs, x.ty, fun (fp : Fun_parm, acc) { 
                PExpr.Call (PExpr.Ref (Name (["*"])), [acc, fp.ty])
              });
            (PExpr.Call (PExpr.Ref (Name (["->"])), [parms_prod_type, h.ret_type]), parms)
        }
      parse_property (h.name, h.ret_type, prop_ty, attrs, indexer_parms)
    }
    else {
      attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Method, true);            
      def impl =
        match (get_token ()) {
          | Token.Keyword ("implements") =>
            match (peek_token ()) {
              | Token.Operator (".", _) =>
                expect_operator ("..");
                match (get_splicable_id ()) {
                  | Splicable.Expression (e) =>
                    [Splicable.Expression (PExpr.Ellipsis (PExpr.Spliced (e)))]
                  | _ =>
                    fatal_error ("expected spliced expression after `..'")
                }
              | _ =>
                operator_separated_list (",", get_splicable_qid)
            }
          | _ => push_back (); []
        };
      def body =
        match (peek_token ()) {
          | Token.Operator ("=", _) =>
            shift ();
            FunBody.Extern (parse_extern ())
          | Token.Operator ("{", _) =>
            FunBody.Parsed (parse_block (h.parms))
          | Token.Operator (";", _) =>
            shift ();
            FunBody.Abstract ()
          | Token.Operator ("$", _) =>
            match (get_splicable_id ()) {
              | Splicable.Expression (e) =>
                FunBody.Parsed (PExpr.Spliced (e))
              | _ => Util.ice ("get_splicable_id returned impossible value")
            }
          | _ => fatal_error ("expecting method body")
        };

      ClassMember.Function (header = h, 
                  name = h.name, 
                  modifiers = attrs, 
                  loc = loc, 
                  body = body, 
                  kind = FunKind.Method (impl))
    }
  }

  parse_option (loc : Location, attrs : Modifiers) : ClassMember {
    def id = get_splicable_id ();
    match (peek_token ()) {
      | Token.Operator ("{", _) =>
        def parse_field () {
          ignore (peek_token ());
          def loc = location_here ();
          def (attrs, _) = get_attrs (System.AttributeTargets.Field, System.AttributeTargets.Field);
          def id = get_splicable_id ();
          expect_operator (":");
          def ty = parse_toplevel_expr ();
          expect_operator (";");
          ClassMember.Field (loc, name = id, modifiers = attrs, ty = ty)
        };
        def members = collect_braced_list (parse_field);
        def td =
          TopDeclaration.VariantOption (name = id, modifiers = attrs, decls = members);
        td.loc = loc;
        ClassMember.TypeDeclaration (loc = loc,
                name = td.name, 
                modifiers = td.modifiers, 
                td = td)

      | Token.Operator ("=", _) =>
        shift ();
        
        ClassMember.EnumOption (loc = loc, name = id, modifiers = attrs, value = Some (parse_expr ()))

      | _ =>
        ClassMember.EnumOption (loc = loc, name = id, modifiers = attrs, value = None ())
    };
  }
  
  parse_type_member () : ClassMember {
    def (attrs, other_atts) = get_attrs (0 :> System.AttributeTargets, System.AttributeTargets.Method %|
      System.AttributeTargets.Field %| System.AttributeTargets.Property %| System.AttributeTargets.Event %|
      System.AttributeTargets.Class);

    def tok = peek_token ();
    def loc = tok.Location;
    match (tok) {
      | Token.Operator ("$", _) | Token.Identifier =>
        def id = get_splicable_id ();
        match (peek_token ()) {
          | Token.Operator ("(", _)
          | Token.Operator ("<", _) => 
            parse_method (loc, Some (id), attrs, other_atts)
          | Token.Operator ("[", _) =>
            parse_method (loc, Some (id), attrs, other_atts)            
          | _ =>
            parse_field (loc, id, (attrs, other_atts), false)
        }
        
      | Token.Keyword ("this") =>
        parse_method (loc, None (), attrs, other_atts)

      | Token.Keyword ("event") =>
        shift ();
        attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Event, false);
        def id = get_splicable_id ();
        parse_field (loc, id, (attrs, other_atts), true)

      | Token.Operator ("|", _) =>
        shift ();
        when (other_atts != null) error ("custom attributes not allowed on options");
        parse_option (loc, attrs)
        
      | _ =>
        def td = parse_type_decl ();
        attrs.custom_attrs += take_attributes_out (other_atts, System.AttributeTargets.Class, true);
        td.Attributes |= attrs.mods;
        td.modifiers.custom_attrs += attrs.custom_attrs;
        ClassMember.TypeDeclaration (loc = loc + td.loc, 
                                     name = td.name, 
                                     modifiers = td.modifiers, 
                                     td = td)
    }
  }

  parse_type_decl () : TopDeclaration {
    def parse_header () {
      match (peek_token ()) {
        | Token.Identifier
        | Token.Operator ("$", _) =>
          def name = get_splicable_id ();
          def tyvars = parse_tyvars ();
            
          def t_extends =
            match (get_token ()) {
              | Token.Operator (":", _) =>
                match (peek_token ()) {
                  | Token.Operator (".", _) =>
                    expect_operator ("..");
                    match (get_splicable_id ()) {
                      | Splicable.Expression (e) =>
                        [PExpr.Ellipsis (PExpr.Spliced (e))]

                      | _ => fatal_error ("expected spliced expression")
                    };
                  | _ =>
                    operator_separated_list (",", parse_toplevel_expr)
                }
              | _ => 
                push_back ();
                []
            };

          def typarms = parse_where_constraints (tyvars);
            
          (name, typarms, t_extends)
          
        | _ => fatal_error ("expecting type name")
      }
    };

    def parse_members () { collect_braced_list (parse_type_member) };

    def (attrs, other_attrs) = get_attrs (System.AttributeTargets.Class, 
                                          System.AttributeTargets.Class);
    def tok = get_token ();
    def loc = tok.Location;
    
    def res =
      match (tok) {
        | Token.Keyword ("type")
        | Token.Keyword ("class")
        | Token.Keyword ("struct")
        | Token.Keyword ("module")
        | Token.Keyword ("interface")
        | Token.Keyword ("enum")
        | Token.Keyword ("variant") =>
          def (name, typarms, t_extends) = parse_header ();
          def td =
            match (tok) {
              | Token.Keyword ("class") =>
                TopDeclaration.Class (typarms, t_extends, parse_members ())
                
              | Token.Keyword ("struct") =>
                attrs.mods |= NemerleAttributes.Struct;
                TopDeclaration.Class (typarms, t_extends, parse_members ())
                
              | Token.Keyword ("module") =>
                attrs.mods |= NemerleAttributes.Static;
                TopDeclaration.Class (typarms, t_extends, parse_members ())
                
              | Token.Keyword ("type") =>
                expect_operator ("=");
                def t = parse_expr ();
                expect_operator (";");
                TopDeclaration.Alias (typarms, t)
                
              | Token.Keyword ("interface") =>
                TopDeclaration.Interface (typarms, t_extends, parse_members ())
                
              | Token.Keyword ("variant") =>
                TopDeclaration.Variant (typarms, t_extends, parse_members ())

              | Token.Keyword ("enum") =>
                TopDeclaration.Enum (t_extends, parse_members ())
                
              | _ => Util.ice ()
            };
            
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Class, true);
          td.modifiers = attrs;
          
          td.name = name;
          td

        | Token.Keyword ("delegate") =>
          attrs.custom_attrs += take_attributes_out (other_attrs, System.AttributeTargets.Class, true);
          def (h, _) = parse_fun_header (false, false, false, None ());
          def td = TopDeclaration.Delegate (h);
          expect_operator (";");
          td.modifiers = attrs;
          td

        | Token.Keyword ("macro") => 
          def (header, _) = parse_fun_header (true, false, false, None ());
          def synt = 
            match (peek_token ()) {
              | Token.Keyword ("syntax") =>
                shift ();
                expect_operator ("(");
                def parse_elems (acc) {
                  match (peek_token ()) {
                    | Token.Operator (")", _) =>
                      shift ();
                      List.Rev (acc)
                    | Token.Operator (",", _) =>
                      shift ();
                      parse_elems (parse_prim_expr (parse_closed_prim_expr ()) :: acc)
                    | _ =>
                      fatal_error ("expected comma separated expressions in "
                                   + "syntax description")
                  }
                };
                parse_elems ([parse_closed_prim_expr ()])
              | _ => []
            };
          def expr = parse_block ([]);
          def res = TopDeclaration.Macro (header, synt, expr);
          res.modifiers = attrs;
          res
       
        | _ => fatal_error ("expecting type declaration")
      };

    res.loc = loc + res.loc;
    res
  }
  
  parse_topdecl () : TopDeclaration {
    def tok = get_token ();
    def loc = tok.Location;
    match (tok) {
      | Token.Keyword ("using") =>
        def id = get_splicable_qid ();
        match (get_token ()) {
          | Token.Operator ("=", _) =>
            def id = 
              match (id) {
                | Splicable.Name ({ idl = [x] }) => x
                | Splicable.Name ({ idl = x :: _ }) =>
                  Message.error ("namespace alias cannot contain dots");
                  x
                | Splicable.Expression =>
                  Message.fatal_error ("namespace alias cannot contain spliced expr");
                | _ => Util.ice ("empty list")
              };
            def id' = get_splicable_qid ();
            def loc' = expect_operator_loc (";");
            TopDeclaration.UsingAlias (loc + loc', id', Modifiers.Empty, id)

          | Token.Operator (";", _) =>
            /// FIXME: pass list
            MacroRegistry.LoadSyntaxExtensions (id.GetFullId ());
            TopDeclaration.Using (loc + id.loc, id, Modifiers.Empty)

          | _ => fatal_error ("expecting `;' or `='")
        }

      | Token.Keyword ("namespace") =>
        def id = get_splicable_qid ();
        match (get_token ()) {
          | Token.Operator ("=", _) =>
            Message.warning ("`namespace ID = QID;' construct is obsolete, use `using ID = QID'");
            def id = 
              match (id) {
                | Splicable.Name ({ idl = [x] }) => x
                | Splicable.Name ({ idl = x :: _ }) =>
                  Message.error ("namespace alias cannot contain dots");
                  x
                | Splicable.Expression =>
                  Message.fatal_error ("namespace alias cannot contain spliced expr");
                | _ => Util.ice ("empty list")
              };
            def id' = get_splicable_qid ();
            def loc' = expect_operator_loc (";");
            TopDeclaration.UsingAlias (loc + loc', id', Modifiers.Empty, id)

          | Token.Operator ("{", _) =>
            // FIXME: pass list
            MacroRegistry.LoadSyntaxExtensions (id.GetFullId ());
            push_back ();
            def decls = collect_braced_list (parse_topdecl);
            TopDeclaration.Namespace (loc + id.loc, id, Modifiers.Empty, decls)

          | _ => fatal_error ("expecting '}'")
        }

      | Token.Operator ("[", _) =>
        match (peek_token ()) {
          | Token.Identifier ("assembly") =>
            shift ();
            expect_operator (":");
            def body = parse_expr ();
            def loc' = expect_operator_loc ("]");
            TopDeclaration.Attribute (loc + loc', null, Modifiers.Empty, body)
          | _ =>
            push_back ();
            parse_type_decl ()
        }

      | _ =>
        push_back ();
        parse_type_decl ()
    };
  }

  parse_quotation () : PExpr {
    def tok = get_token ();
    def loc = tok.Location;
    
    PExpr.Quoted (loc,
      match (get_token ()) {
        | Token.Operator (":", _) =>
          match (tok) {
            | Token.Keyword ("type") =>
              Message.fatal_error ("`type' quotation was removed, use just plain quotation");

            | Token.Identifier ("ttype") =>
              SyntaxElement.TType (parse_expr ())
            
            | Token.Identifier ("case") =>
              SyntaxElement.MatchCase (parse_match_case ())

            | Token.Identifier ("caseguard") =>
              SyntaxElement.MatchCaseGuard (parse_case_guard ())

            | Token.Identifier ("fundecl") =>
              def (h, _) = parse_fun_header (allow_ctor = false, 
                                        allow_inference = true, 
                                        is_lambda = false, knownname = None ());
              SyntaxElement.Function (Function_decl (h, parse_block (h.parms)))

            | Token.Identifier ("funparm") =>
              SyntaxElement.Parameter (parse_funparm (allow_inference = true))

            | Token.Identifier ("decl") =>
              SyntaxElement.ClassMember (parse_type_member ())
              
            | _ =>
              fatal_error ("bad quotation type")
          }
        | _ =>
          push_back (); 
          push_back ();
          def expr =
            match (parse_expr_sequence ()) {
              | [x] => x
              | l => PExpr.Sequence (loc, l)
            };
          SyntaxElement.Expression (expr)
      }
    )
  }
  
  collect_braced_list['a] (f : void -> 'a) : list ['a] {
    expect_operator ("{");
    def r = collect_list (f);
    expect_operator ("}");
    r
  }
  
  collect_list['a] (f : void -> 'a) : list ['a] {
    def loop (acc) {
      match (peek_token ()) {
        | Token.Operator ("}", _) | Token.EndOfFile => List.Rev (acc)
        | _ =>
          loop (f () :: acc)
      }
    };
    loop ([])
  }

  public variant GrammarElement {
    | GE_operator { name : string; }
    | GE_keyword { name : string; }
    | GE_expression
    | GE_funparm
    | GE_expression_list { separator : string; }
    | GE_optional { body : GrammarElement; }
  }

  parse_wrt_rule (rule : list [GrammarElement]) : list [SyntaxElement] {
    def loop (acc, lst) {
      match (lst) {
        | GrammarElement.GE_operator (n) :: xs =>
          expect_operator (n);
          loop (acc, xs)

        | GrammarElement.GE_keyword (n) :: xs =>
          expect_keyword (n);
          loop (acc, xs)

        | GrammarElement.GE_expression :: xs =>
          def expr = parse_expr ();
          loop (SyntaxElement.Expression (expr) :: acc, xs)

        | GrammarElement.GE_expression_list (sep) :: xs =>
          def exprs = operator_separated_list (sep, parse_expr);
          loop (List.RevAppend (List.Map (exprs, fun (e) { SyntaxElement.Expression (e) }), 
                                 acc), xs)

        | GrammarElement.GE_funparm :: xs =>
          def p = parse_funparm (allow_inference = true);
          loop (SyntaxElement.Parameter (p) :: acc, xs)

        | GrammarElement.GE_optional (GrammarElement.GE_operator (n)) :: xs =>
          match (peek_token ()) {
            | Token.Operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
              expect_operator (n)
            | _ => ()
          };
          loop (acc, xs)

        | GrammarElement.GE_optional (GrammarElement.GE_keyword (n)) :: xs =>
          match (peek_token ()) {
            | Token.Keyword (o) when o == n => shift ();
            | _ => ()
          };
          loop (acc, xs)

        | GrammarElement.GE_optional (GrammarElement.GE_expression) :: GrammarElement.GE_keyword (n) :: xs =>
          match (peek_token ()) {
            | Token.Keyword (o) when o == n =>
              shift ();
              loop (SyntaxElement.Expression (null) :: acc, xs)
            | _ =>
              def expr = parse_expr ();
              expect_keyword (n);
              loop (SyntaxElement.Expression (expr) :: acc, xs)
          };
          
        | GrammarElement.GE_optional (GrammarElement.GE_expression) :: GrammarElement.GE_operator (n) :: xs =>
          match (peek_token ()) {
            | Token.Operator (o, _) when n.StartsWith (o) || o.StartsWith (n) =>
              shift ();
              loop (SyntaxElement.Expression (null) :: acc, xs)
            | _ =>
              def expr = parse_expr ();
              expect_operator (n);
              loop (SyntaxElement.Expression (expr) :: acc, xs)
          };

        | _ :: _ => Message.fatal_error ("syntax definition of macro is ambiguous")
          
        | [] => List.Rev (acc)
      }
    };

    loop ([], rule)
  }

  internal make_parsing_function (macro_ns : GlobalEnv.NamespaceND,
                                  rule : list [GrammarElement], 
                                  perm : list [SyntaxElement] -> list [SyntaxElement]) 
                                  : void -> PExpr 
  {
    fun () {
      def loc = peek_token ().Location;
      def parms = parse_wrt_rule (rule);
      PExpr.MacroCall (loc, Name ([]), macro_ns, perm (parms))
    }
  }

  parse_list () : list [PExpr]
  {
    def parse_list () {
      match (peek_token ()) {
        | Token.Operator ("]", _) => []
        | Token.Operator (",", _) =>
          shift ();
          parse_expr () :: parse_list ()
        | _ =>
          fatal_error ("expecting expression in list literal")
      }
    };
    match (peek_token ()) {
      | Token.Operator ("]", _) => []
      | _ =>
        def expr = parse_expr ();
        expr :: parse_list ()
    }
  }

  init_parens () : void {
    def add (o, c, f) {
      ctx.parens.Add (o, ParenCallback (o, c, f));
      ctx.closing_parens.Add (c, 0);
    };
    add ("<[", "]>", parse_quotation);
    
    add ("[", "]", fun () {
      def make_list (exps : list [PExpr]) : PExpr {
        | [] => PExpr.Call (PExpr.Ref (Name (["Nil"])), [])
        | x :: xs => 
          def sub = make_list (xs);
          def newloc = x.loc + sub.loc;         
          PExpr.Call (newloc, PExpr.Ref (newloc, Name (["Cons"])), 
                      [x, sub])
      };
      make_list (parse_list ())
    });
  }

  public Parse (lexer : LexerBase) : list [TopDeclaration]
  {
    ctx.lexer = lexer;
    ctx.last_token1 = null;
    ctx.last_token2 = null;
    ctx.push_back = 0;
    MacroRegistry.RemoveSyntaxExtensions ();
    Location_stack.push_fn (location_here);
    def r = collect_list (parse_topdecl);
    Location_stack.pop ();
    match (peek_token ()) {
      | Token.EndOfFile => r
      | _ => fatal_error ("expecting EOF")
    }
  }

  public ParseExpr (expr : string) : PExpr
  {
    ctx.lexer = LexerString (expr, Location_stack.top ());
    ctx.last_token1 = null;
    ctx.last_token2 = null;
    ctx.push_back = 0;
    MacroRegistry.RemoveSyntaxExtensions ();
    def r = parse_expr ();
    match (peek_token ()) {
      | Token.EndOfFile => r
      | _ => fatal_error ("expecting EOF")
    }
  }
  
} // end module
} // end namespace
