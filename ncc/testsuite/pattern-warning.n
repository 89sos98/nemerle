variant X  {
  | A
  | B
  | C
}

module M {
  f1 (x : X * X) : void {
    match (x) { // W: this matching is not exhaustive
      | (_, A) => () // OK
      | (B, _) => () // OK
      | (A, B) => () // OK
      | (A, A) => () // W: this match clause is unused
      | (A, C) => () // OK
      | (C, C) => () // OK
    } 
  }
  
  f2 (x : X * X) : void {
    match (x) {
      | (_, A) => () // OK
      | (B, _) => () // OK
      | (A, B) => () // OK
      | (A, A) => () // W: this match clause is unused
      | (A, C) => () // OK
      | (C, C) => () // OK
      | (C, B) => () // OK
    } // OK
  }
  
  f3 (x : X * X) : void {
    match (x) {
      | _ => () // OK
      | (A, A) => () // W: this match clause is unused
    } // OK
  }
  
  Main () : void { }
}

(*
BEGIN-OUTPUT
END-OUTPUT
*)
