/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Collections 
{ 
    /**
     * Exception throws by queue service function where queue is empty.
     */
    class EmptyQueue : System.Exception 
    {
        public this () {}
    }


    /**
     * Class representing first-in-first-out queue.
     */
    public class Queue <'a> : ICollection<'a>
    {
        /** first part of the queue */
        mutable first : list <'a>;

        /** second part of the queue */
        mutable last  : list <'a>;


        /** Create a new empty queue. */
        public this ()
        {
            this.first = [];
            this.last  = [];
        }


        /**
         * Ensure that if there are any elements in the queue, then
         * the first list is not empty.
         */
        private move_cond () : void
        {
            match (this.first) {
                | [] =>
                  this.first = List.Rev (this.last);
                  this.last  = [];
                | _  => ()
            }
        }


        /**
         * Unconditionally move all the elements of the second list
         * to the end of the first list.
         */
        private move () : void
        {
            this.first = this.first + List.Rev (this.last);
        }


        /**
         * Append element to the end of the queue.
         */
        public Add (x : 'a) : void 
        {
            this.last = x :: this.last;
        }
     

        /**
         * Alias for Add.
         */
        public Push (x : 'a) : void
        {
            this.Add (x)
        }

     
        /**
         * Return the first element of the queue and remove it.  Throw
         * EmptyQueue exception if the queue is empty.
         */
        public Take () : 'a
        {
            this.move_cond ();

            match (this.first) {
                | x :: xs => 
                  this.first = xs;
                  x
                | [] => throw EmptyQueue ()
            }
        }


        /**
         * Alias for Take.
         */
        public Pop () : 'a
        {
            this.Take ()
        }


        /**
         * Return the first element of the queue.
         * Throw EmptyQueue exception if the queue is empty.
         */
        public Peek () : 'a
        {
            this.move_cond ();

            match (this.first) {
                | x :: _ => x
                | [] => throw EmptyCollection ("Nemerle.Collections.Queue")
            }
        }


        /**
         * Alias for Peek.
         */
        public Top () : 'a
        {
            this.Peek ()
        }


        /** 
         * Return some element from the queue, implements ICollection.First.
         */
        public First () : option<'a>
        {
            this.move_cond ();

            match (this.first) {
                | x :: _ => Some (x)
                | []     => None ()
            }
        }


        /**
         * Empty the queue.
         */
        public Clear () : void
        {
            this.first = [];
            this.last  = [];
        }


        /**
         * Create a copy of the queue.
         */
        public Copy () : Queue <'a>
        {
            def q   = Queue();
            q.first = List.Copy (this.first);
            q.last  = List.Copy (this.last);
            q
        }


        /**
         * Return true iff the queue is not empty, and false otherwise.
         */
        public IsEmpty () : bool
        {
            this.move_cond ();

            match (this.first) {
                | [] => true
                | _  => false
            }
        }


        /**
         * Return the number of elements in the queue.
         */
        public Length () : int
        {
            List.Length (this.first) + List.Length (this.last)
        }


        /**
         * Alias for Length.
         */
        public Size () : int
        { 
            Length () 
        }

      
        /**
         * Call supplied function for every element of the queue.
         */
        public Iter (f : 'a -> void) : void
        {
            this.move ();
            List.Iter (this.first, f);
        }
        

        /**
         * Fold elements of the queue with supplied function and initial
         * value.
         */
        public Fold<'b> (f : 'a * 'b -> 'b, x : 'b) : 'b
        {
            this.move ();
            List.FoldLeft (this.first, x, f)
        }


        /**
         * Transfer all elements of the queue q to the end of this queue.
         */
        public Transfer (q : Queue<'a>) : void
        {
            this.move ();
            
            this.last = q.last + List.Rev (q.first);
            q.first   = [];
            q.last    = [];
        }


        /**
         * Return true iff an element x is a member of the queue.
         */
         public Member (x : 'a) : bool
         {
             List.Member (this.first, x) || List.Member (this.last, x)
         }


         /**
          * Remove element x from the queue.
          */
         public Remove (x : 'a) : void
         {
             this.first = List.Remove (this.first, x);
             this.last  = List.Remove (this.last, x);
         }


         /**
          * Return true iff every element of the queue satisfy predicate f.
          */
          public ForAll (f : 'a -> bool) : bool
          {
              List.ForAll (this.first, f) && List.ForAll (this.last, f)
          }

          
          /**
           * Return true iff the queue contains an element that
           * satisfies predicate f.
           */
          public Exists (f : 'a -> bool) : bool
          {
              List.Exists (this.first, f) || List.Exists (this.last, f)
          }


          /**
           * Remove from queue every element that does not satisfy
           * predicate f.
           */
          public Filter (f : 'a -> bool) : void
          {
              this.first = List.Filter (this.first, f);
              this.last  = List.Filter (this.last, f);
          }


          /**
           * Map queue to a new queue using mapping f.
           */
          public Map <'b> (f : 'a -> 'b) : Queue <'b>
          {
              def q   = Queue ();
              q.first = List.Map (this.first, f);
              q.last  = List.Map (this.last, f);
              q
          }


          /**
           * Partition the queue into two queues: first with elements
           * that satisfy predicate f, second with the rest.
           */
          public Partition (f : 'a -> bool): Queue<'a> * Queue<'a>
          {
              def sat      = Queue ();
              def nonsat   = Queue ();

              def (s,n)    = List.Partition (this.first, f);
              sat.first    = s; 
              nonsat.first = n;

              def (s,n)    = List.Partition (this.last, f);
              sat.last     = s;
              nonsat.last  = n;

              (sat,nonsat)
          }

          /**
           * Return enumerator for elements of the queue.
           */
           public GetEnumerator() : IEnumerator<'a>
           {
               this.move ();

               ListEnumerator (this.first)
           }

  } /* end of class Queue */
} /* end of namespace */

