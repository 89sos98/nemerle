(*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Compiler;
  open Nemerle.Compiler.Tyops;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Collections;
  
  open System.Reflection;
  open System.Reflection.Emit;


  (**
   *
   *)
  variant CGIL_tree {
    | CGIL_class { type_builder : TypeBuilder; subtree : list (CGIL_tree); }
    | CGIL_field { field : CM_field; field_builder : FieldBuilder; }
    | CGIL_constructor { constructor : CM_method; constructor_builder : ConstructorBuilder; }
    | CGIL_method { method : CM_method; method_builder : MethodBuilder; }
  }


  (**
   * An IL code generator
   *)
  public class CGIL
  {
    (* -- PUBLIC CONSTRUCTORS ---------------------------------------------- *)
    
    (** 
     * Outputs objects from cgtree.n as IL code. 
     *)
    public this (decls : list (CM_class))
    {
      (* create the type builder queue *)
      this._type_builder_queue <- Queue ();
      
      (* create a weak assembly name and define a dynamic assembly *)
      this._assembly_name <- System.Reflection.AssemblyName ();
      this._assembly_name.Version <- System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name <- "CGILTest"; // FIXME

      this._assembly_builder <- 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      (* create a dynamic module *)
      this._module_builder <- 
        this._assembly_builder.DefineDynamicModule ("CGILTest", "cgil-test.dll"); // FIXME

      (* create the assembly skeleton *)
      def add_classes (decl) { this.make_class (decl, null) };
      def classes_tree = List.map (add_classes, decls);
            
      (* fill in the member declarations *)
      def add_declarations (tree) { this.add_declarations (tree, null) }; // FIXME: aargh
      def declarations_tree = List.map (add_declarations, classes_tree);
            
      (* add the method implementations *)
      def add_implementations (tree) { this.add_implementations (tree) }; // FIXME: aargh
      def implementations_tree = List.map (add_implementations, declarations_tree);
            
      (* execute the type builder queue *)
      def create_type (tb : TypeBuilder) : void {
        def _ = tb.CreateType ();
        ()
      };      
      this._type_builder_queue.iter (create_type);
            
      (* save the assembly *)
      this._assembly_builder.Save ("cgil-test.dll"); // FIXME
    }



    (* -- PRIVATE METHODS -------------------------------------------------- *)
    
    (**
     * Builds a Nemerle type attribute
     *)
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = typeof (Nemerle.TypeAttribute);
      def constructor_param_types = mkarray [typeof (System.String)];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     * Builds a Nemerle variant attribute
     *)
    private make_nemerle_variant_attribute () : CustomAttributeBuilder
    {
      def attr_type = typeof (Nemerle.VariantAttribute);
      def constructor_info = attr_type.GetConstructor (mkarray []);
      def attr_builder = CustomAttributeBuilder (constructor_info, (mkarray [] :> array (System.Object)));
      attr_builder
    }
    

    (**
     * Builds a Nemerle variant option attribute
     *)
    private make_nemerle_variant_option_attribute (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = typeof (Nemerle.VariantOptionAttribute);
      def constructor_param_types = mkarray [typeof (System.String)];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     *
     *)
    private nemerle_to_framework_type (ty : CG_type) : System.Type
    {
      match (ty) {
        | CT_array (t) =>
          def internal_type = this.nemerle_to_framework_type (t);
          
          def array_type = this._module_builder.GetType (internal_type.FullName + "[]");
          if (array_type != null) array_type 
          else {
            def array_type = System.Type.GetType (internal_type.FullName + "[]");
            if (array_type != null) array_type else typeof (System.Array)
          }

        | CT_ref (name) =>
          def ref_type = this._module_builder.GetType (name);
          if (ref_type != null) ref_type 
          else {
            def ref_type = System.Type.GetType (name);
            if (ref_type != null) ref_type else typeof (System.Object)
          }

        | CT_tuple (arity) =>
          def tuple_type = this._module_builder.GetType ("Nemerle.Tuple" + string_of_int (arity)); // FIXME
          if (tuple_type != null) tuple_type else typeof (System.Object)
          
        | CT_fun (arity) =>
          def fun_type = this._module_builder.GetType ("Nemerle.Func" + string_of_int (arity)); // FIXME
          if (fun_type != null) fun_type else typeof (System.Object)
          
        | CT_void => typeof(System.Void)
        | CT_object => typeof(System.Object)
        | CT_bool => typeof(System.Bool)
        
        | CT_unreached => Util.ice ("nemerle_to_framework_type:CT_unreached")
      }          
    }
    
    
    (**
     *
     *)
    private nemerle_field_modifiers_to_framework_attrs (attrs : list (Modifier)) : FieldAttributes
    {
      def process_modifier (modifier : Modifier) : FieldAttributes {
        match (modifier) {
          | Mod_public => FieldAttributes.Public
          | Mod_private => FieldAttributes.Private
          | Mod_new => Util.ice ("Mod_new is not supported for fields")
          | Mod_protected => FieldAttributes.Family
          | Mod_internal => FieldAttributes.FamORAssem
          | Mod_abstract => Util.ice ("Mod_abstract is not supported for fields")
          | Mod_virtual => Util.ice ("Mod_virtual is not supported for fields")
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for fields")
          | Mod_static => FieldAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for fields")
          | Mod_module => Util.ice ("Mod_module is not supported for fields")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) + this.nemerle_field_modifiers_to_framework_attrs (rest)
        | [] =>
          FieldAttributes.PrivateScope
      }
    }


    (**
     *
     *)
    private make_method_attributes (attrs : list (Modifier)) : MethodAttributes
    {
      def process_modifier (modifier : Modifier) : MethodAttributes {
        match (modifier) {
          | Mod_public => MethodAttributes.Public
          | Mod_private => MethodAttributes.Private
          | Mod_new => MethodAttributes.NewSlot
          | Mod_protected => MethodAttributes.Family
          | Mod_internal => MethodAttributes.FamORAssem
          | Mod_abstract => MethodAttributes.Abstract
          | Mod_virtual => MethodAttributes.Virtual
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for methods")
          | Mod_static => MethodAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for methods")
          | Mod_module => Util.ice ("Mod_module is not supported for methods")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) + this.make_method_attributes (rest)
        | [] =>
          MethodAttributes.PrivateScope
      }
    }


    (**
     *
     *)  
    private type_list_to_type_array (x : list (System.Type)) : array (System.Type) {

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), List.length (x)) :> array (System.Type));
      
      def loop (index : int, x : list (System.Type)) : void {        
        match (x) {
          | head :: tail =>
            result [index] <- (head :> System.Type);
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }


    (**
     *
     *)
    private determine_inheritance (m : CM_class) : (System.Type * array (System.Type))
    {
(*            
          def inh =
            match (m.inheritance) {
              | [] => ST_leaf ("")
              | _ => " : " ++ st_concat (", ", List.map (flat_ty, m.inheritance))
            };
*)

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), 0) :> array (System.Type));
        
      (typeof (System.Object), result) // FIXME
    }
  

    (**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     *)
    private make_class (m : CM_class, type_builder : TypeBuilder) : CGIL_tree
    {       
      (* create optional custom attributes for this type *)
      def custom_attribute =
        match (m.kind) {          
          | CK_variant => 
            this.make_nemerle_variant_attribute ()
          | CK_variant_option (encoded_type) =>
            this.make_nemerle_variant_option_attribute (encoded_type)
          | _ => null
        };

      (* decide the new type attributes *)
      def type_kind_attrs = 
        match (m.kind) { 
          | CK_class => TypeAttributes.Class
          | CK_struct => Util.ice ("CK_struct")
          | CK_interface => TypeAttributes.Interface + TypeAttributes.Abstract
          | CK_variant => TypeAttributes.Class
          | CK_variant_option (_) => TypeAttributes.Class
        };
        
      def attrs = type_kind_attrs + TypeAttributes.Public;

      (* determine the inheritance relation for this type *)
      def (extends_class, implements_interfaces) = this.determine_inheritance (m);

      (* create the type builder for a top-level or nested class declaration *)
      def new_type_builder = 
        if (type_builder == null)
          this._module_builder.DefineType (m.ns + m.name, attrs)
        else
          type_builder.DefineNestedType (m.name, TypeAttributes.NestedPublic + attrs);

      when (custom_attribute != null) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      this._type_builder_queue.add (new_type_builder);

      (* create the type builder's CGIL subtree *)
      def walk_members (decls : list (CG_member)) : list (CGIL_tree) {
        match (decls) {
          | decl :: rest => 
            this.make_subtree (decl, new_type_builder) :: walk_members (rest)
          | [] => []
        }
      };
      
      CGIL_class (new_type_builder, walk_members (m.decls))    
    }



    (**
     * This method walks the declarations tree, creating partial types
     * and building the CGIL tree of the compilation unit.
     *)
    make_subtree (m : CG_member, type_builder : TypeBuilder) : CGIL_tree
    {
      assert (type_builder != null);
      
      match (m) {
        | (CM_class) as m =>
          this.make_class (m, type_builder)

        | (CM_field) as f =>
          CGIL_field (f, null)
                               
        | (CM_property) as p =>
          Message.fatal_error ("emitting properties is not supported yet")
                            
        | (CM_method) as m =>
          CGopt.tail_call_optimize (m);

          match (m.ret_type) {
            | CT_unreached => CGIL_constructor (m, null)
            | _ => CGIL_method (m, null)
          }
      }          
    }


    (**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     *)
    add_declarations (m : CGIL_tree, type_builder : TypeBuilder) : CGIL_tree
    {
      match (m) {
        | CGIL_class (class_type_builder, members) =>
          def walk_members (decls : list (CGIL_tree)) : list (CGIL_tree) {
            match (decls) {
              | decl :: rest => 
                this.add_declarations (decl, class_type_builder) :: walk_members (rest)
              | [] => []
            }
          };          
          CGIL_class (type_builder, walk_members (members))    

        | CGIL_field (field, _) =>
          assert (type_builder != null);
          
          def field_builder = 
            type_builder.DefineField (field.name, 
                                      this.nemerle_to_framework_type (field.ty), 
                                      this.nemerle_field_modifiers_to_framework_attrs (field.modifiers));
          field_builder.SetCustomAttribute (this.make_nemerle_type_attr (field.encoded_type));

          CGIL_field (field, field_builder)
                            
        | CGIL_constructor (constructor, _) =>
          assert (type_builder != null);

          this.make_constructor_skeleton (constructor, type_builder)

        | CGIL_method (method, _) =>
          assert (type_builder != null);

          this.make_method_skeleton (method, type_builder)
      }          
    }


    (**
     * This method adds implementations to methods, where applicable...
     *)
    private add_implementations (tree : CGIL_tree) : CGIL_tree
    {
      match (tree) {
        | CGIL_class (type_builder, subtree) => 
          def walk_branches (branch) { this.add_implementations (branch) }; // FIXME: aargh
          CGIL_class (type_builder, List.map (walk_branches, subtree))
          
        | (CGIL_constructor (constructor, constructor_builder)) as member =>
          this.add_constructor_body (constructor, constructor_builder);
          member
        
        | (CGIL_method (method, method_builder)) as member =>
          this.add_method_body (method, method_builder);
          member
        
        | member => member
      }
    }



    private make_constructor_skeleton (m : CM_method, type_builder : TypeBuilder) : CGIL_tree
    {
      (* build the parameter types array *)      
      def mkparm (v : CG_val) : System.Type {
        this.nemerle_to_framework_type (v.ty)
      };
                    
      def parameter_types = this.type_list_to_type_array (List.map (mkparm, m.parms));

      (* create the constructor builder *)
      def constructor_builder = 
        type_builder.DefineConstructor (this.make_method_attributes (m.modifiers),
                                        CallingConventions.Standard, parameter_types);

      CGIL_constructor (m, constructor_builder)
    }

    

    (**
     *
     *)    
    private add_constructor_body (constructor : CM_method, constructor_builder : ConstructorBuilder) : void
    {
      def il_generator = constructor_builder.GetILGenerator ();

      il_generator.Emit (OpCodes.Ret);
    }



    (**
     *
     *)
    private make_method_skeleton (m : CM_method, type_builder : TypeBuilder) : CGIL_tree
    {
      (* build the return type and parameter types *)      
      def mkparm (v : CG_val) : System.Type {
        this.nemerle_to_framework_type (v.ty)
      };
      
      def return_type = this.nemerle_to_framework_type (m.ret_type);
              
      def parameter_types = this.type_list_to_type_array (List.map (mkparm, m.parms));

      (* add the method to the type builder *)
      def method_builder = 
        type_builder.DefineMethod (m.name, this.make_method_attributes (m.modifiers),
                                   return_type, parameter_types);

      CGIL_method (m, method_builder)
    }


    (**
     *
     *)    
    private add_method_body (method : CM_method, method_builder : MethodBuilder) : void
    {
      def il_generator = method_builder.GetILGenerator ();

      il_generator.Emit (OpCodes.Ldstr, "Hello world!");

      def system_console = typeof(System.Console);

      def method_info =
        system_console.GetMethod ("WriteLine", (mkarray [typeof(string)] :> array (System.Type)));

      il_generator.Emit (OpCodes.Call, method_info);
      il_generator.Emit (OpCodes.Ret);

    (*
      def (pref, r) = make_complex (flat (m.body));
      def ret =
        if (is_dummy_type (m.ret_type))
          side_effect_run (r)
        else
          if (is_dummy_type (type_of (m.body)))
            side_effect_run (r) ++ "return null;\n"
          else
            "return " ++ r ++ ";\n";

      print_st ("\n{\n" ++ pref ++ ret ++ "} // end of fun " ++ m.name ++ "\n")
    *)

    }


    (* -- PRIVATE FIELDS --------------------------------------------------- *)

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _type_builder_queue : Queue (TypeBuilder);
    
  } (* end of the module *)
  
} (* end of the namespace *)
