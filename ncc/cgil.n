/*
 * Copyright (c) 2003, 2004 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler
{
  using Nemerle.Compiler;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Collections;
  using Nemerle.Utility;

  using System.Reflection;
  using System.Reflection.Emit;
  using System.IO;

  using NC = Nemerle.Compiler;
  using SR = System.Reflection;

  /**
   * An IL code generator
   */
  public class CGIL
  {
    /* -- PUBLIC CONSTRUCTORS ---------------------------------------------- */

    public this (target_exe : bool, output_file_name : string, assem_name : AssemblyName)
    {
      _output_file_name = output_file_name;
      _assembly_name = assem_name;

      /* define a dynamic assembly */
      _assembly_name.Name = Path.GetFileNameWithoutExtension (output_file_name);

      this._assembly_builder =
        System.AppDomain.CurrentDomain.DefineDynamicAssembly
          (this._assembly_name,
           AssemblyBuilderAccess.RunAndSave,
           Path.GetDirectoryName(Path.GetFullPath (_output_file_name)));

      /* we can embed resources only on mono */
      if (SystemType.AssemblyBuilder_EmbedResourceFile != null)
        foreach ((file, name : string) in _embedded_resources)
          try {
            def margs = array [name : object, file : object];
            if (File.Exists (file))
                ignore (SystemType.AssemblyBuilder_EmbedResourceFile
                        .Invoke (_assembly_builder, margs));
            else
              Message.error ("Could not find resource " + file);
          }
          catch {
            | e : System.Exception =>
              Message.error ("Could not embed resource: " + e.Message);
          }
      else
        when (_embedded_resources matches _ :: _)
          Message.error ("Cannot embed resource on this runtime... use mono");

      foreach ((file, name) in _linked_resources)
        try {
          _assembly_builder.AddResourceFile (name, file);
        }
        catch {
          | _ : FileNotFoundException =>
            Message.error ("Could not find resource " + file);
          | e : System.ArgumentException =>
            Message.error ("Could not link resource: " + e.Message);
        }

      def attr = make_string_attribute (SystemType.Reflection_AssemblyConfigurationAttribute,
                                        "ContainsNemerleTypes");
      this._assembly_builder.SetCustomAttribute (attr);

      /* create a dynamic module */
      this._module_builder =
        this._assembly_builder.DefineDynamicModule ("Module_" + _assembly_name.Name,
                                                    Path.GetFileName (output_file_name),
                                                    true); // FIXME

      when (target_exe) {
        _need_entry_point = true;
        _entry_point = None ();
      };

      _aux_types = [];
    }


    /**
     *
     */
    public EmitAuxDecls () : void
    {
      compile_all_tyinfos (true)
    }


    /**
     *
     */
    public EmitDecls () : void
    {
      foreach (x in AttributeCompiler.GetCompiledAssemblyAttributes ())
        _assembly_builder.SetCustomAttribute (x);

      compile_all_tyinfos (false)
    }

    /**
     * Adds new resource to list of resources to be embedded into output
     * assembly
     */
    public static AddResource (x : string) : void
    {
      def cp = x.IndexOf (',');

      def element =
        if (cp != -1)
          (x.Substring (0, cp), x.Substring (cp + 1))
        else
          // change name from /foo/bar/file to foo.bar.file namespace  
          (x, x.Replace ('/','.').Replace ('\\', '.'));

      _embedded_resources = element :: _embedded_resources;
    }

    /**
     * Adds new resource to list of resources to be linked in output
     * assembly
     */
    public static AddLinkedResource (x : string) : void
    {
      def cp = x.IndexOf (',');
      def element =
        if (cp != -1)
          // change name from /foo/bar/file to foo.bar.file namespace          
          (x.Substring (0, cp), x.Substring (cp + 1))
        else
          (x, x);

      _linked_resources = element :: _linked_resources;
    }

    /**
     * Saves the constructed assembly to a file
     */
    public SaveAssembly () : void
    {
      // set the entry point
      match ((_need_entry_point, _entry_point)) {
        | (true, Some (entry_point_method_info)) =>
          _assembly_builder.SetEntryPoint (entry_point_method_info,
                                           PEFileKinds.ConsoleApplication)
        | (true, None) =>
          Message.error ("no suitable entry point (Main function) found")
        | _ => ()
      };

      // save the assembly
      try {
        _assembly_builder.Save (Path.GetFileName (_output_file_name));
      }
      catch {
        | e : IOException =>
          Message.error ($"could not write to output file `$(this._output_file_name)'"
                         " -- `$(e.Message)'")  
      }
    }

    /**
     * Tell IL generator that we have created type instance elsewhere, and
     * it needs to get finalized before saving an assembly.
     */
    public RegisterAuxType (tb : Emit.TypeBuilder) : void
    {
      _aux_types = tb :: _aux_types;
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    /**
     *
     */
    emit_implementation (ti : NC.TypeBuilder) : void
    {
      ti.is_finalized = true;

      mutable skip_types = false;
      def emit_member (m : IMember) {
        def mods = m.GetModifiers ();
        unless (mods.IsEmpty) {
          def handle = m.GetHandle ();
          //Message.debug (handle.ToString () + ": " + handle.GetType ().ToString ());
          mutable context = m.DeclaringType;
          def adder =
            match (m.GetKind ()) {
              | MK_method (m) =>
                // FIXME: we should allow [return:] here, but lame S.R.E. doesn't allow
                // this, mono has an extension though
// bug in MS Framework?      if ((handle :> MethodBase).IsConstructor)
                if (m.GetFunKind () is FK_ctor)
                  fun (target, attribute) {
                    if (target != System.AttributeTargets.Method &&
                        target != System.AttributeTargets.All)
                      Message.error ("only [method:] target allowed on constructor")
                    else {
                      def x = (handle :> ConstructorBuilder).SetCustomAttribute (attribute) ;
                      x
                     }
                    }
                else
                  fun (target, a) {
                    if (target == System.AttributeTargets.ReturnValue)
                      Message.error ("[return:] attribute target not supported yet")
                    else if (target != System.AttributeTargets.Method &&
                             target != System.AttributeTargets.All)
                      Message.error ("only [method:] and [return:] targets allowed on methods")
                    else
                     (handle :> MethodBuilder).SetCustomAttribute (a)
                  }
              | MK_property =>
                fun (target, a) {
                  if (target != System.AttributeTargets.Property &&
                           target != System.AttributeTargets.All)
                    Message.error ("only [property:] targets allowed on properties")
                  else
                   (handle :> PropertyBuilder).SetCustomAttribute (a)
                }
              | MK_event =>
                fun (target, a) {
                  if (target != System.AttributeTargets.Event &&
                      target != System.AttributeTargets.All)
                    Message.error ("only [event:] target allowed on events")
                  else
                   (m :> NemerleEvent).event_builder.SetCustomAttribute (a)
                }
              | MK_field  =>
                fun (target, a) {
                  if (target != System.AttributeTargets.Field &&
                      target != System.AttributeTargets.All)
                    Message.error ("only [field:] target allowed on fields")
                  else
                   (handle :> FieldBuilder).SetCustomAttribute (a)
                }
              | MK_type (tc) =>
                if (skip_types)
                  null
                else {
                  context = tc;
                  fun (target, a) {
                    if (target != System.AttributeTargets.Class &&
                        target != System.AttributeTargets.All)
                      Message.error ("only [type:] target allowed on types")
                    else
                     (handle :> SR.Emit.TypeBuilder).SetCustomAttribute (a)
                  }
                }
            };

          when (adder != null)
            mods.SaveCustomAttributes ((context :> NC.TypeBuilder), adder)
        }

        match (m.GetKind ()) {
          | MK_field =>
            when ((m :> NemerleField).IsVolatile)
            {
              def volatile_attr =
                make_void_attribute (SystemType.VolatileModifier);

              (m.GetHandle () :> FieldBuilder).SetCustomAttribute (volatile_attr)
            }
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod))
          | MK_property (p) =>
            compile_property (p)
          | MK_event (p) =>
            compile_event (p)
          | _ => ()
        }
      };

      emit_member (ti);
      skip_types = true;
      List.Iter (ti.GetDirectMembers (), emit_member);
      //Message.debug ("finalizing " + ti.FullName);
      unless (Message.seen_error ())
        ti.FinalizeType ();
      //Message.debug ("finalized " + ti.FullName);
    }


    compile_property (prop : IProperty) : void
    {
      def builder = (prop.GetPropertyInfo () :> PropertyBuilder);
      when (prop.GetGetter () != null)
        builder.SetGetMethod ((prop.GetGetter ().GetMethodInfo () :> MethodBuilder));
      when (prop.GetSetter () != null)
        builder.SetSetMethod ((prop.GetSetter ().GetMethodInfo () :> MethodBuilder));
    }


    compile_event (prop : IEvent) : void
    {
      def builder = (prop :> NemerleEvent).event_builder;
      builder.SetAddOnMethod ((prop.GetAdder ().GetMethodInfo () :> MethodBuilder));
      builder.SetRemoveOnMethod ((prop.GetRemover ().GetMethodInfo () :> MethodBuilder));
    }


    finalize_aux_types () : void
    {
      unless (Message.seen_error ())
        foreach (x : Emit.TypeBuilder in _aux_types)
          ignore (x.CreateType ());
      _aux_types = [];
    }


    /**
     *
     */
    compile_all_tyinfos (aux_phase : bool) : void
    {
      def allow_it (ti : NC.TypeBuilder) {
        !ti.is_finalized &&
        is_aux_decl (ti) == aux_phase
      };
      def set_type_builder (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("make type builder for " + ti.FullName);
          ti.ConstructTypeBuilder ();
          when (ti.Attributes %&& NemerleAttributes.Macro) {
            def attr = make_string_attribute (SystemType.ContainsMacroAttribute,
                                              ti.GetTypeBuilder ().FullName);
            _assembly_builder.SetCustomAttribute (attr);
          }
        }
      };
      def emit_decls (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("generating declarations " + ti.FullName);
          add_declarations (ti)
        }
      };
      def emit_impl_iface (ti : NC.TypeBuilder) {
        when ((ti.GetTydecl () matches TD_interface) && allow_it (ti)) {
          //Message.debug ("generating code for interface type " + ti.FullName);
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };
      def emit_impl_vt (ti : NC.TypeBuilder) {
        when (ti.IsValueType && allow_it (ti)) {
          //Message.debug ("generating code for value type " + ti.FullName);
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };
      def emit_impl (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("generating code for " + ti.FullName);
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };

      this._emit_nemerle_attributes = !aux_phase;

      when (!aux_phase) _cgil_phase = 1;
      NC.TypeBuilder.Iter (set_type_builder);

      when (!aux_phase) _cgil_phase = 2;
      NC.TypeBuilder.Iter (emit_decls);

      //FIXME: need a better ordering of emissions here (bug 158)
      when (!aux_phase) _cgil_phase = 3;
      NC.TypeBuilder.Iter (emit_impl_iface);
      NC.TypeBuilder.Iter (emit_impl_vt);
      NC.TypeBuilder.Iter (emit_impl);

      Message.maybe_bailout ();

      when (!aux_phase) _cgil_phase = 4;
      finalize_aux_types ();
    }


    internal MemberAdded (ti : NC.TypeBuilder, mem : IMember) : void
    {
      when (_cgil_phase >= 1)
        ti.ConstructTypeBuilder ();

      when (_cgil_phase >= 2)
        add_declaration (ti, mem);

      when (_cgil_phase >= 3)
        match (mem.GetKind ()) {
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod));
          | _ => ()
        };

      when (_cgil_phase >= 4)
        finalize_aux_types ();
    }


    /**
     * Check if declaration is auxiliary, used internally etc.
     */
    private is_aux_decl (ti : NC.TypeBuilder) : bool
    {
      def tn = ti.FullName;

      tn.StartsWith ("Nemerle.Internal.") ||
      tn == "Nemerle.Core.NullMatchException"
    }


    private make_string_attribute (attr_type : System.Type, value : string) : CustomAttributeBuilder
    {
      def constructor_param_types = array [SystemType.String];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      assert (constructor_info != null);
      def constructor_params = array [(value : object)];
      CustomAttributeBuilder (constructor_info, constructor_params)
    }


    private make_void_attribute (attr_type : System.Type) : CustomAttributeBuilder
    {
      def constructor_info = attr_type.GetConstructor (System.Type.EmptyTypes);
      CustomAttributeBuilder (constructor_info, array [])
    }


    /**
     * Builds a Nemerle type attribute
     */
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      make_string_attribute (SystemType.TypeAttribute, encoded_type)
    }


    /**
     * Builds a Nemerle variant attribute
     */
    private make_nemerle_variant_attribute (decls : list <Tycon>) : CustomAttributeBuilder
    {
      def names = List.Map (decls, Tyutil.FrameworkTypeName);
      make_string_attribute (SystemType.VariantAttribute,
                             NString.Concat (",", names))
    }


    /**
     * Builds a Nemerle type alias
     */
    private make_nemerle_type_alias_attribute (t : Type) : CustomAttributeBuilder
    {
      make_string_attribute (SystemType.TypeAliasAttribute, TyCodec.EncodeType (t))
    }


    /**
     * Builds a Nemerle variant option attribute
     */
    private make_nemerle_variant_option_attribute (is_const : bool) : CustomAttributeBuilder
    {
      make_void_attribute (if (is_const)
                             SystemType.ConstantVariantOptionAttribute
                           else
                             SystemType.VariantOptionAttribute)
    }


    /**
     * Converts Nemerle property modifiers to the CLI property attributes.
     */
    private make_property_attributes (attrs : NemerleAttributes) : PropertyAttributes
    {
      mutable result = PropertyAttributes.None;

      when (attrs %&& NemerleAttributes.SpecialName) result |= PropertyAttributes.SpecialName;

      when (attrs %&& (NemerleAttributes.Mutable %|
                       NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro))
        Util.ice ("given modifier is not supported for properties");

      result
    }


    /**
     * Converts Nemerle field modifiers to the CLI field attributes.
     */
    private make_field_attributes (attrs : NemerleAttributes) : FieldAttributes
    {
      mutable result = FieldAttributes.PrivateScope;

      when (attrs %&& NemerleAttributes.Public) result |= FieldAttributes.Public;
      when (attrs %&& NemerleAttributes.Private) result |= FieldAttributes.Private;
      when (attrs %&& NemerleAttributes.Protected) result |= FieldAttributes.Family;
      when (attrs %&& NemerleAttributes.Internal) result |= FieldAttributes.FamORAssem;
      when (attrs %&& NemerleAttributes.Static) result |= FieldAttributes.Static;
      when (attrs %&& NemerleAttributes.SpecialName) result |= FieldAttributes.SpecialName;

      when (attrs %&& (NemerleAttributes.Abstract %|
                       NemerleAttributes.Virtual %|
                       NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro %|
                       NemerleAttributes.Override))
        Util.ice ("given attribute is not supported for fields");
      result
    }


    /**
     * Converts Nemerle method modifiers to the CLI method attributes.
     */
    private make_method_attributes (attrs : NemerleAttributes) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;

      when (attrs %&& NemerleAttributes.Public) result |= MethodAttributes.Public;
      when (attrs %&& NemerleAttributes.Private) result |= MethodAttributes.Private;
      when (attrs %&& NemerleAttributes.Protected) result |= MethodAttributes.Family;
      when (attrs %&& NemerleAttributes.Internal) result |= MethodAttributes.FamORAssem;
      when (attrs %&& NemerleAttributes.Static) result |= MethodAttributes.Static;
      when (attrs %&& NemerleAttributes.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;
      when (attrs %&& NemerleAttributes.New)
        result |= MethodAttributes.NewSlot %| MethodAttributes.Virtual;
      when (attrs %&& NemerleAttributes.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;
      when (attrs %&& NemerleAttributes.Virtual) result |= MethodAttributes.Virtual;
      when (attrs %&& NemerleAttributes.Sealed)
        result |= MethodAttributes.Final %| MethodAttributes.Virtual;
      when (attrs %&& NemerleAttributes.SpecialName) result |= MethodAttributes.SpecialName;

      when (attrs %&& (NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro))
        Util.ice ("given attribute is not supported for methods");

      result
    }


    /**
     * Converts Nemerle method modifiers to the Framework type attributes.
     */
    private make_type_attributes (attrs : NemerleAttributes, is_nested : bool) : TypeAttributes
    {
      mutable result = TypeAttributes.AutoLayout;
      when (attrs %&& NemerleAttributes.Public)
        if (is_nested) result |= TypeAttributes.NestedPublic
        else result |= TypeAttributes.Public;
      when (attrs %&& NemerleAttributes.Private)
        if (is_nested) result |= TypeAttributes.NestedPrivate
        else Message.error ("Private is not allowed for top level types");
      when (attrs %&& NemerleAttributes.Protected)
        if (is_nested) result |= TypeAttributes.NestedFamily
        else Message.error ("Protected is not allowed for top level types");
      when (attrs %&& NemerleAttributes.Internal && is_nested)
        result |= TypeAttributes.NestedFamORAssem;
      when (attrs %&& NemerleAttributes.Abstract) result |= TypeAttributes.Abstract;
      when (attrs %&& NemerleAttributes.Sealed) result |= TypeAttributes.Sealed;
      when (attrs %&& NemerleAttributes.SpecialName) result |= TypeAttributes.SpecialName;
      when (attrs %&& (NemerleAttributes.New %|
                       NemerleAttributes.Virtual %|
                       NemerleAttributes.Mutable %|
                       NemerleAttributes.Override))
        Util.ice ("given attribute is not supported for types");
      result
    }


    /**
     * Converts a System.Type list to a System.Type array.
     * FIXME: array <x> won't work here as the list's length is not know.
     */
    internal type_list_to_type_array (x : list <System.Type>) : array <System.Type>
    {
      Nemerle.Utility.NArray.FromList (typeof (System.Type), x)
    }


    /**
     * Reads the inheritance list of a class and retrieves the base
     * type and builds the array of interfaces implemented by the class.
     */
    private determine_inheritance (ti : NC.TypeBuilder) : (System.Type * array <System.Type>)
    {
      def is_interface (t : Tycon) {
        match (t.GetTydecl ()) {
          | TD_interface | TD_alias => true
          | _ => false
        }
      };

      match (ti.GetTydecl ()) {
        | TD_enum => (SystemType.Enum, array [])
        | _ =>
          def base_class_type =
            match (ti.GetDirectSuperTypes ()) {
              | T_app (base_class, _) :: _ when !is_interface (base_class) =>
                base_class.GetSystemType ()
              | _ when is_interface (ti) => null
              | _ => SystemType.Object
            };

          def ifaces_types = List.Map (ti.InterfacesToImplement (),
                                       fun (tc : Tycon) { tc.GetSystemType () });

          (base_class_type, type_list_to_type_array (ifaces_types))
      }
    }


    /**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     */
    public ConstructTypeBuilder (tyinfo : NC.TypeBuilder) : Emit.TypeBuilder
    {
      /* create optional custom attributes for this type */
      def custom_attribute =
        match (tyinfo.GetTydecl ()) {
          | TD_variant (decls) =>
            make_nemerle_variant_attribute (decls)
          | TD_variant_option =>
            def has_co_ctor = Option.IsSome (tyinfo.GetConstantObject ());
            make_nemerle_variant_option_attribute (has_co_ctor)
          | TD_alias (t) =>
            make_nemerle_type_alias_attribute (t)
          | _ => null
        };

      /* decide the new type attributes */
      def is_nested = tyinfo.DeclaringType != null;
      mutable is_interface = false;

      def type_kind_attrs =
        match (tyinfo.GetTydecl ()) {
          | TD_class => TypeAttributes.Class
          | TD_alias // we pretend type alias is an interface
          | TD_interface =>
            is_interface = true;
            TypeAttributes.Interface %| TypeAttributes.Abstract
          | TD_variant => TypeAttributes.Class
          | TD_variant_option => TypeAttributes.Class
          | TD_enum =>
            TypeAttributes.Sealed %| TypeAttributes.Class
        };

      def attrs = make_type_attributes (tyinfo.Attributes, is_nested) %| type_kind_attrs;

      /* determine the inheritance relation for this type */
      def (extends_class, implements_interfaces) = determine_inheritance (tyinfo);

      /* create the type builder for a top-level or nested class declaration */
      def new_type_builder =
        if (!is_nested)
          this._module_builder.DefineType (tyinfo.FullName, attrs,
                                           extends_class, implements_interfaces)
        else {
          def type_builder = (tyinfo.DeclaringType :> NC.TypeBuilder).GetTypeBuilder ();
          type_builder.DefineNestedType (tyinfo.Name, attrs, extends_class,
                                         implements_interfaces)
        };

      when (custom_attribute != null && _emit_nemerle_attributes) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      new_type_builder
    }


    /**
     * Adds a an implicit parameterless constructor to a type builder
     */     
    internal AddImplicitCtor (tb : Emit.TypeBuilder) : ConstructorBuilder
    {
      def constructor_builder =
        tb.DefineDefaultConstructor (MethodAttributes.FamORAssem);

      constructor_builder
    }


    /**
     * Adds a constructor builder to a type builder
     */
    internal AddConstructorBuilder (cgm : CG_method, tb : Emit.TypeBuilder,
                                    is_delegate_ctor : bool) : void
    {
      // Message.debug ("-- AddConstructorBuilder: " + tb.FullName + "." + cgm.name);

      /* build the parameter types array */
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.Map (cgm.parms, mkparm);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      mutable skip_it_altogether = false;

      when (is_delegate_ctor) {
        if (cgm.modifiers %&& NemerleAttributes.Public)
          skip_it_altogether = true;
        else
          cgm.modifiers = NemerleAttributes.Public;
      }

      unless (skip_it_altogether) {
        /* create the constructor builder */
        def constructor_builder =
          tb.DefineConstructor (make_method_attributes (cgm.modifiers) %|
                                MethodAttributes.RTSpecialName %|
                                MethodAttributes.SpecialName,
                                CallingConventions.Standard, parm_types_array);

        /* add the runtime modifiers for delegate constructors */
        when (is_delegate_ctor) {
          constructor_builder.SetImplementationFlags (
            MethodImplAttributes.Runtime %| MethodImplAttributes.Managed
          )
        }

        def name_parms (pos, parms) {
          match (parms) {
            | [] => ()
            | (p : CG_val) :: ps =>
              assert (p.parm_info != null, "parm " + p.name);
              p.parm_info.builder =
                 constructor_builder.DefineParameter
                       (pos, parameter_attributes (p.parm_info), p.name);
              name_parms (pos + 1, ps)
          }
        };
        name_parms (1, cgm.parms);

        cgm.constructor_builder = constructor_builder;
      }
    }


    /**
     * Emits a constructor's body
     */
    internal EmitConstructor (context : NC.TypeBuilder, cgm : CG_method) : void
    {
      unless (context.IsDelegate) {
        def cb = cgm.constructor_builder;
        assign_parameter_indexes (cb.IsStatic, cgm);

        emit_parameter_attributes (context, cgm);

        CGpost.Postprocess (cgm);
        CGopt.Optimize (cgm);

        /* emit the constructor's body */
        def _ = CodeGenerator (cb, _module_builder, cgm);

        ()
      }
    }

    parameter_attributes (pi : CG_parm_info) : ParameterAttributes
    {
      if (pi.parm_kind == ParmKind.Ref)
        ParameterAttributes.None
      else if (pi.parm_kind == ParmKind.Out)
        ParameterAttributes.Out
      else
        ParameterAttributes.None
    }


    /**
     * Adds a method builder to a type builder
     */
    internal AddMethodBuilder (cgm : CG_method, tb : Emit.TypeBuilder, is_delegate_method : bool) : void
    {
      // Message.debug ("-- AddMethodBuilder: " + tb.FullName + "." + cgm.name);

      /* build the parameter types array */
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.Map (cgm.parms, mkparm);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      /* update the modifiers list */
      def modifiers =
        if (cgm.implemented_methods == null) cgm.modifiers
        else
          match (cgm.implemented_methods) {
            | [] => cgm.modifiers
            | _ => NemerleAttributes.Virtual %| cgm.modifiers
          };

      def attrs = make_method_attributes (modifiers);
      def attrs =
        if (cgm.name == ".cctor")
          attrs %| MethodAttributes.RTSpecialName %| MethodAttributes.SpecialName
        else
          attrs;

      /* add the method to the type builder */
      def method_builder =
        tb.DefineMethod (cgm.name, attrs,
                         cgm.ret_type, parm_types_array);

      /* add the runtime modifiers for delegate methods */
      when (is_delegate_method) {
        method_builder.SetImplementationFlags (
          MethodImplAttributes.Runtime %| MethodImplAttributes.Managed
        )
      }

      def name_parms (pos, parms) {
        match (parms) {
          | [] => ()
          | (p : CG_val) :: ps =>
            p.parm_info.builder =
               method_builder.DefineParameter
                     (pos, parameter_attributes (p.parm_info), (p : CG_val).name);
            name_parms (pos + 1, ps)
        }
      };
      name_parms (1, cgm.parms);

      cgm.method_builder = method_builder;
    }


    emit_parameter_attributes (context : NC.TypeBuilder, cgm : CG_method) : void
    {
      foreach (v : CG_val in cgm.parms) {
        v.parm_info.modifiers.SaveCustomAttributes (context, fun (target, attr) {
          if (target != System.AttributeTargets.Parameter &&
              target != System.AttributeTargets.All)
            Message.error ("only [param:] custom attribute target is allowed here")
          else
            v.parm_info.builder.SetCustomAttribute (attr)
        })
      }
    }


    /**
     * Emits a method's body
     */
    internal EmitMethod (context : NC.TypeBuilder, cgm : CG_method) : void
    {
      unless (context.IsDelegate) {
        def mb = cgm.method_builder;
        assign_parameter_indexes (mb.IsStatic, cgm);

        emit_parameter_attributes (context, cgm);

        CGpost.Postprocess (cgm);
        CGopt.Optimize (cgm);

        /* update the entry point settings, if necessary */
        when (_need_entry_point && cgm.name == "Main" && mb.IsStatic) {
          match (_entry_point) {
            | Some =>
              Message.error ($ "more then one entry point (Main function) "
                               "found in $(mb.DeclaringType)")
            | None =>
              _entry_point = Some ((mb : MethodInfo))
          }
        };

        /* update the overriding relationships */
        def type_builder = (mb.DeclaringType :> Emit.TypeBuilder);
        def method_info = (mb :> MethodInfo);

        foreach (overridden : IMethod in cgm.implemented_methods) {
          def overridden_info = overridden.GetMethodInfo ();

          //Message.debug ("override " + method_info.Name + " " + overridden_info.Name + " in " +
          //                type_builder.FullName);
          type_builder.DefineMethodOverride (method_info, overridden_info)
        };

        /* emit the method body */
        def _ = CodeGenerator (mb, _module_builder, cgm);

        ()
      }
    }


    /**
     * Adds a method and immediately emits it's body
     */
    internal AddMethod (ctx : NC.TypeBuilder, cgm : CG_method, tb : Emit.TypeBuilder) : void
    {
      AddMethodBuilder (cgm, tb, is_delegate_method = ctx.IsDelegate);
      EmitMethod (ctx, cgm);
    }


    /**
     * Adds a field builder
     */
    internal AddFieldBuilder (field : IField, tb : Emit.TypeBuilder) : FieldBuilder
    {
      def attrs = make_field_attributes (field.Attributes);
      def nemerle_field = (field :> NemerleField);
      def attrs =
        if (nemerle_field.enum_value != null)
          attrs %| FieldAttributes.Literal
        else if (field.Name == "value__" &&
                 (field.DeclaringType.GetTydecl () matches TD_enum))
          attrs %| FieldAttributes.RTSpecialName
                %| FieldAttributes.SpecialName
        else
          attrs;
      def field_builder =
        tb.DefineField (field.Name,
                        CGexpr.cg_type (tb, field.GetMemType ()),
                        attrs);

      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (field));
        field_builder.SetCustomAttribute (attr);
      };

      when (nemerle_field.enum_value != null) {
        //Message.debug ("setting value to " + nemerle_field.enum_value.ToString ());
        field_builder.SetConstant (nemerle_field.enum_value);
      };

      nemerle_field.field_builder = field_builder;
      field_builder
    }

    /**
     * Adds a property builder
     */
    internal AddPropertyBuilder (prop : IProperty, tb : Emit.TypeBuilder) : PropertyBuilder
    {
      def prop = (prop :> NemerleProperty);
      def parms = List.Map (prop.parms, fun (t) { CGexpr.cg_type (tb, t) });
      def parms = type_list_to_type_array (parms);
      def attrs = make_property_attributes (prop.Attributes);
      def ty = CGexpr.cg_type (tb, prop.GetMemType ());

      def prop_builder = tb.DefineProperty (prop.Name, attrs, ty, parms);

      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (prop));
        prop_builder.SetCustomAttribute (attr);
      };

      prop.property_builder = prop_builder;
      prop_builder
    }

    /**
     * Adds an event builder
     */
    internal AddEventBuilder (the_event : IEvent, tb : Emit.TypeBuilder) : EventBuilder
    {
      def ty = CGexpr.cg_type (tb, the_event.GetMemType ());
      def event_builder =
        tb.DefineEvent (the_event.Name, EventAttributes.None, ty);

      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (the_event));
        event_builder.SetCustomAttribute (attr);
      };

      (the_event :> NemerleEvent).event_builder = event_builder;
      event_builder
    }

    add_declaration (ti : NC.TypeBuilder, m : IMember) : void
    {
      def type_builder = ti.GetTypeBuilder ();
      match (m.GetKind ()) {
        | MK_field (field) =>
          ignore (AddFieldBuilder (field, type_builder))

        | MK_event (ev) =>
          ignore (AddEventBuilder (ev, type_builder))

        | MK_property (p) =>
          ignore (AddPropertyBuilder (p, type_builder))

        | MK_method (m) when Option.IsSome (m.GetExternName ()) => () // skip extern methods

        | MK_method (m) =>
          def attr =
            if (_emit_nemerle_attributes)
              make_nemerle_type_attr (TyCodec.EncodeMemberType (m))
            else
              null;
          match (m.GetFunKind ()) {
            | FK_ctor =>
              def cgm = CGexpr.GetCgMethod (m);
              AddConstructorBuilder (cgm, type_builder, ti.IsDelegate);
              def builder = cgm.constructor_builder;
              // we don't need our atributes on delegate ctors
              when (!ti.IsDelegate && _emit_nemerle_attributes)
                builder.SetCustomAttribute (attr);
              (m :> NemerleMethod).ctor_builder = builder
            | _ =>
              def cgm = CGexpr.GetCgMethod (m);
              AddMethodBuilder (cgm, type_builder, ti.IsDelegate);
              def builder = cgm.method_builder;
              when (_emit_nemerle_attributes)
                builder.SetCustomAttribute (attr);
              (m :> NemerleMethod).method_builder = builder
          }

        | MK_type => () // skip
      }
    }


    /**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     */
    add_declarations (ti : NC.TypeBuilder) : void
    {
      def type_builder = ti.GetTypeBuilder ();

      when (_emit_nemerle_attributes) {
        def tyattr = make_nemerle_type_attr (TyCodec.EncodeMemberType (ti));
        type_builder.SetCustomAttribute (tyattr);
      };

      foreach (m in ti.GetDirectMembers ())
        add_declaration (ti, m);

      when (ti.IsDelegate) {
        // a lil' fixup
        match (ti.LookupMember (".ctor")) {
          | [c1 : NemerleMethod, c2 : NemerleMethod] =>
            if (c1.ctor_builder == null)
              c1.ctor_builder = c2.ctor_builder
            else
              c2.ctor_builder = c1.ctor_builder
          | _ => assert (false)
        }
      }
    }


    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    private assign_parameter_indexes (is_static : bool, cgm : CG_method) : void
    {
      def walk_parms (index : int, parms : list <CG_val>) : void {
        match (parms) {
          | parm :: rest =>
            parm.parm_index = Some (index);
            walk_parms (index + 1, rest)
          | [] => ()
        }
      };

      walk_parms (if (is_static) 0 else 1, cgm.parms)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private _assembly_name : System.Reflection.AssemblyName;
    private _assembly_builder : AssemblyBuilder;
    private _module_builder : ModuleBuilder;
    private mutable _emit_nemerle_attributes : bool;
    private _need_entry_point : bool;

    /** updated when method with static Main signature is met */
    private mutable _entry_point : option <MethodInfo>;
    private _output_file_name : string;
    private mutable _aux_types : list <Emit.TypeBuilder>;
    private mutable _cgil_phase : int;
    private static mutable _embedded_resources : list <string * string> = [];
    private static mutable _linked_resources : list <string * string> = [];
  }



  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  internal class CodeGenerator
  {
    private _module_builder : ModuleBuilder;
    private _ilg : ILGenerator;    

    private _this_is_value_type : bool;
    private _type_of_this : System.Type;

    private  _method_name : string;
    private _method_is_static : bool;
    private _cg_method : CG_method;
    private _method_start_label : Label;

    /**
     * Creates and executes a code generator for a method
     */
    internal this (method_builder : MethodBuilder, module_builder : ModuleBuilder, cg_method : CG_method)
    {
      _cg_method = cg_method;

      _ilg = method_builder.GetILGenerator ();
      _module_builder = module_builder;

      _method_name = method_builder.DeclaringType.FullName + "::" + method_builder.Name;
      _method_is_static = method_builder.IsStatic;
      _this_is_value_type = method_builder.DeclaringType.IsValueType;
      _type_of_this = method_builder.DeclaringType;

      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      emit (cg_method.body);
      unless (throws (cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }


    /**
     * Creates and executes a code generator for a method
     */
    internal this (constructor_builder : ConstructorBuilder,
                   module_builder : ModuleBuilder, cg_method : CG_method)
    {
      _cg_method = cg_method;

      _ilg = constructor_builder.GetILGenerator ();
      _module_builder = module_builder;

      _method_name = constructor_builder.DeclaringType.FullName + "::"
                      + constructor_builder.Name;
      _method_is_static = constructor_builder.IsStatic;
      _this_is_value_type = constructor_builder.DeclaringType.IsValueType;
      _type_of_this = constructor_builder.DeclaringType;

      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      emit (cg_method.body);
      unless (throws (cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }

    private is_always_true (expr : CG_expr) : bool
    {
      | CE_literal (L_bool (true)) => true

      | CE_if (cond_expr, then_expr, else_expr) =>
        def cond_always_true = is_always_true (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_true = is_always_true (then_expr);
        def else_always_true = is_always_true (else_expr);
        
        cond_always_true && then_always_true ||
        cond_always_false && else_always_true ||
        then_always_true && else_always_true

      | _ => false
    }


    private is_always_false (expr : CG_expr) : bool
    {
      | CE_literal (L_bool (false)) => true

      | CE_if (cond_expr, then_expr, else_expr) =>
        def cond_always_true = is_always_true (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_false = is_always_false (then_expr);
        def else_always_false = is_always_false (else_expr);

        cond_always_true && then_always_false ||
        cond_always_false && else_always_false ||
        then_always_false && else_always_false
        
      | _ => false
    }

    private throws (expr : CG_expr) : bool
    {
      expr.flags %&& CgExprFlags.Throws
    }

    private wish_address (expr : CG_expr) : bool
    {
      expr.flags %&& CgExprFlags.WishAddress || 
      expr.flags %&& CgExprFlags.NeedAddress
    }

    /** Emit volatile prefix if needed. */
    private maybe_volatile (expr : CG_expr) : void
    {
      match (expr) {
       | CE_volatile_global_ref
       | CE_volatile_field_ref =>
         _ilg.Emit (OpCodes.Volatile)
       | _ => ()
      }
    }

    /**
     * Emits an expression.
     */
    private emit (expr : CG_expr) : void
    {
      // Message.debug (expr.loc, "emit: " + pretty_print (expr));

      match (expr) {

        /* -- SEQUENCING --------------------------------------------------- */

        /* emits a sequence of expressions */
        | CE_sequence (expr_seq) => foreach (e in expr_seq) emit (e);

        /* emits a local value definition */
        | CE_let (let_val, let_in) =>
          match (let_val.val) {
            | CE_none =>
              unless (SystemType.Void.Equals (let_val.ty)) {
                def _ = declare_val_local_slot (let_val); ()
              };
              emit (let_in)

            | CE_init_obj (t) =>
              def slot = declare_val_local_slot (let_val);
              _ilg.Emit (OpCodes.Ldloca, slot);
              _ilg.Emit (OpCodes.Initobj, t);

              emit (let_in)

            | _ =>
              emit (let_val.val);
              unless (SystemType.Void.Equals (let_val.ty)) {
                def local_slot = declare_val_local_slot (let_val);
                _ilg.Emit (OpCodes.Stloc, local_slot)
              };

              emit (let_in)
          };


        /* ignores the results of a computation */
        | CE_ignore (expr) =>
          emit (expr);
          unless (SystemType.Void.Equals (type_of (expr)))
            _ilg.Emit (OpCodes.Pop);


        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction, special case for constants */
        | CE_if (cond_expr, then_expr, _) when is_always_true (cond_expr) =>
          emit (then_expr)

        /* emits the if/then/else construction, special case for constants */
        | CE_if (cond_expr, _, else_expr) when is_always_false (cond_expr) =>
          emit (else_expr)

        /* emits the if/then/else construction */
        | CE_if (cond_expr, then_expr, else_expr) =>
          def emit_branch (expr, else_label : Label) {
            match (expr) {
              | CE_call (CE_opcode (opcode), parms) =>
                List.Iter (parms, emit);

                /* NOTE: the opcodes are swapped so that the 'then' expression
                         can be emitted before the 'else' expression */
                def opcode =
                  match (opcode) {
                    | "==" => OpCodes.Bne_Un
                    | "!=" => OpCodes.Beq
                    | "<.s" | "<.f" => OpCodes.Bge
                    | "<.u" => OpCodes.Bge_Un
                    | ">.s" | ">.f" => OpCodes.Ble
                    | ">.u" => OpCodes.Ble_Un
                    | "<=.s" | "<=.f" => OpCodes.Bgt
                    | "<=.u" => OpCodes.Bgt_Un
                    | ">=.s" | ">=.f" => OpCodes.Blt
                    | ">=.u" => OpCodes.Blt_Un
                    | "bool.!" => OpCodes.Brtrue_S                    
                    | _ => Util.ice ("invalid opcode '" + opcode +
                                     "' in optimized CE_if pattern")
                  };
                _ilg.Emit (opcode, else_label);

              | CE_has_type (expr, ty) =>
                emit (expr);
                _ilg.Emit (OpCodes.Isinst, ty);
                _ilg.Emit (OpCodes.Brfalse, else_label);

              | CE_if (new_cond, new_then, new_else) =>
                def my_label_else = _ilg.DefineLabel ();
                def my_label_fi = _ilg.DefineLabel ();
                emit_branch (new_cond, my_label_else);
                emit_branch (new_then, else_label);
                unless (throws (new_then))
                  _ilg.Emit (OpCodes.Br, my_label_fi);
                _ilg.MarkLabel (my_label_else);                  
                emit_branch (new_else, else_label);              
                _ilg.MarkLabel (my_label_fi);                                                 

              | e when is_always_true (e) => ()
              | e when is_always_false (e) =>
                _ilg.Emit (OpCodes.Br, else_label);                

              | e =>
                //Message.debug (e.loc, pretty_print (e));
                // most of other expressions here are CE_ref
                emit (e);
                _ilg.Emit (OpCodes.Brfalse, else_label);                
            }
          }

          def label_condition_else = _ilg.DefineLabel ();
          def label_condition_fi = _ilg.DefineLabel ();
          emit_branch (cond_expr, label_condition_else);

          emit (then_expr);
          unless (throws (then_expr))
            _ilg.Emit (OpCodes.Br, label_condition_fi);

          _ilg.MarkLabel (label_condition_else);
          emit (else_expr);

          _ilg.MarkLabel (label_condition_fi);
        
        /* emit a type check construction */
        | CE_has_type (expr, ty) =>
          emit (expr);
          def label_condition_not_null = _ilg.DefineLabel ();
          def label_condition_has_type = _ilg.DefineLabel ();
          def label_condition_continue = _ilg.DefineLabel ();

          _ilg.Emit (OpCodes.Dup);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);

          _ilg.ThrowException (SystemType.NullMatchException);

          _ilg.MarkLabel (label_condition_not_null);

          _ilg.Emit (OpCodes.Isinst, ty);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_0);
          _ilg.Emit (OpCodes.Br_S, label_condition_continue);
          _ilg.MarkLabel (label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_1);
          _ilg.MarkLabel (label_condition_continue);


        /* emit a nullness check construction */
        | CE_not_null (expr) =>
          emit (expr);
          def label_condition_not_null = _ilg.DefineLabel ();

          _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);

          _ilg.ThrowException (SystemType.NullMatchException);

          _ilg.MarkLabel (label_condition_not_null);


        /* load runtime representation of given type */
        | CE_typeof (t) =>
          _ilg.Emit (OpCodes.Ldtoken, t);
          _ilg.Emit (OpCodes.Call, SystemType.Type_GetTypeFromHandle);


        /* emits the CE_switch instruction */
        | CE_switch (indexing_expr, default_expr, cases) =>
          match (cases) {
            | [] =>
              Message.warning ("empty CE_switch instruction");
            | _ =>
              emit (indexing_expr);
              emit_switch (default_expr, cases)
          }


        /* insert label so CE_continue_loop can work */
        | (CE_loop (expr, _)) as loop =>
          def label = _ilg.DefineLabel ();
          loop.label = Some (label);
          _ilg.MarkLabel (label);
          emit (expr)


        /* branch to loop beginning. */
        | CE_continue_loop (which) =>
          _ilg.Emit (OpCodes.Br, Option.UnSome (which.label));


        /* -- TYPE CONVERSIONS --------------------------------------------- */

        /* do not perform casts between same types */
        | CE_cast (expr, cast_to_type, _) when type_of (expr).Equals (cast_to_type) =>
          emit (expr)


        /* special case casts from void */
        | CE_cast (expr, cast_to_type, _) when SystemType.Void.Equals (type_of (expr)) &&
                                               !cast_to_type.IsValueType =>
          emit (expr);
          _ilg.Emit (OpCodes.Ldnull);


        /* box value types casted to non value types */
        | CE_cast (expr, cast_to_type, _) when type_of (expr).IsValueType
          && ! cast_to_type.IsValueType =>
          emit (expr);
          _ilg.Emit (OpCodes.Box, type_of (expr));


        /* unbox value types or perform value type conversion */
        | CE_cast (expr, cast_to_type, is_checked) when cast_to_type.IsValueType =>
          emit (expr);
          def type_of_expr = type_of (expr);

          if (type_of_expr.IsValueType) {
            /* perform conversion of value types */
            emit_value_type_conversion (type_of_expr, cast_to_type, is_checked)
          }
          else if (SystemType.Object.Equals (type_of_expr) || type_of_expr.IsInterface) {
            /* unboxing returns a pointer to a value */
            _ilg.Emit (OpCodes.Unbox, cast_to_type);

            maybe_volatile (expr);

            emit_ldind_for_value_type (cast_to_type)
          }
          else {
            Util.ice (_method_name + ": failed to convert non-value type "
                      + type_of_expr.FullName + " to a value type "
                      + cast_to_type.FullName)
          };


        /* upcast / downcast non-value types */
        | CE_cast (expr, cast_to_type, _) =>
          emit (expr);
          /* upcasting / downcasting */
          _ilg.Emit (OpCodes.Castclass, cast_to_type);



        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | CE_ref (decl) =>
          emit_ce_ref (decl, 
                       get_address_for_value_types = wish_address (expr))

        /* load the value of a field */
        | CE_field_ref (base_object, field) 
        | CE_volatile_field_ref (base_object, field) =>
          emit (base_object);
          maybe_volatile (expr);
          if (wish_address (expr))
            _ilg.Emit (OpCodes.Ldflda, field);
          else
            _ilg.Emit (OpCodes.Ldfld, field);

        /* load the value of a static field */
        | CE_volatile_global_ref (mi) when member_is_field (mi)
        | CE_global_ref (mi) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");

          when (field_info.IsLiteral)
            // should not happen
            Message.warning ("loading literal as field `" + field_info.ToString () + "'");

          maybe_volatile (expr);
          if (wish_address (expr))
            _ilg.Emit (OpCodes.Ldsflda, field_info);
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);

        /* load an array element */
        | CE_array_indexer (array_obj, [index]) =>
          emit (array_obj);
          emit (index);
          def element_type = type_of (array_obj).GetElementType ();
          assert (element_type != null, "non-array in CE_array_indexer");

          if (wish_address (expr))
            _ilg.Emit (OpCodes.Ldelema, element_type)
          else
            emit_array_load_opcode (element_type);
          

        | CE_array_indexer (array_obj, indexes) =>
          emit (array_obj);
          List.Iter (indexes, emit);
          def method =
            if (wish_address (expr)) array_addr_method (array_obj)
            else array_get_method (array_obj);
          emit_method_call (expr, true, method);


        /* -- ASSIGNMENTS -------------------------------------------------- */

        // FIXME? move it a bit down and see no redundant warning?
        /* special case these assignments for performance */
        | CE_assign (CE_ref (decl), CE_init_obj (t)) =>
          emit_ce_ref (decl, get_address_for_value_types = true);
          _ilg.Emit (OpCodes.Initobj, t);
        
        /* assignment to a local variable */
        | CE_assign (CE_ref (local_var), val) =>
          emit (val);          
          match (local_var.local_slot) {
            | Some (local_slot) =>
              _ilg.Emit (OpCodes.Stloc, local_slot);
            | _ when SystemType.Void.Equals (type_of (val)) =>
              // simply skip assignment here
              ()
            | _ =>
              store_argument (local_var.parm_index)
          };

        /* assignment to ref/out parameter */
        | CE_assign (CE_indirect (CE_ref ({ parm_index = Some (parm_index) })), val) =>
          emit_ldarg (parm_index);
          emit (val);
          def ty = type_of (val);
          if (ty.IsValueType)
            _ilg.Emit (OpCodes.Stobj, ty)
          else
            _ilg.Emit (OpCodes.Stind_Ref);


        /* assignment to a field */
        | CE_assign (CE_volatile_field_ref (base_object, field), val)
        | CE_assign (CE_field_ref (base_object, field), val) =>
          emit (base_object);
          emit (val);
          maybe_volatile ((expr :> CE_assign).target);
          _ilg.Emit (OpCodes.Stfld, field);


        /* assignment to a static field */
        | CE_assign (CE_volatile_global_ref (mi), val) when member_is_field (mi)
        | CE_assign (CE_global_ref (mi), val) when member_is_field (mi) =>
          emit (val);
          maybe_volatile ((expr :> CE_assign).target);
          _ilg.Emit (OpCodes.Stsfld, (mi :> FieldInfo));


        /* assignment to an array element */
        | CE_assign (CE_array_indexer (array_obj, [index]), val) =>
          def type_of_val = type_of (val);

          emit (array_obj);
          emit (index);
          when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
            _ilg.Emit (OpCodes.Ldelema, type_of_val);

          emit (val);
          emit_array_store_opcode (type_of_val);

        | CE_assign (CE_array_indexer (array_obj, indexes), val) =>
          emit (array_obj);
          List.Iter (indexes, emit);
          emit (val);
          def method = array_set_method (array_obj);
          emit_method_call (expr, true, method);

        | CE_multiple_assign (assigns) =>
          def emit_store (local_var : CG_val, _) {
            match (local_var.local_slot) {
              | Some (local_slot) =>
                _ilg.Emit (OpCodes.Stloc, local_slot);
              | _ =>
                Util.ice (_method_name + ": null local slot in CE_multiple_assign")
            }
          };
          foreach ((_, e) in assigns) emit (e);
          List.Iter (List.Rev (assigns), emit_store);



        /* -- CALLS -------------------------------------------------------- */

        /* call the base constructor */
        | CE_tail_call (CE_base_ctor_ref (base_ctor), ctor_params)
        | CE_call (CE_base_ctor_ref (base_ctor), ctor_params) =>
          _ilg.Emit (OpCodes.Ldarg_0);
          List.Iter (ctor_params, emit);
          _ilg.Emit (OpCodes.Call, base_ctor);


        /* create a new object */
        | CE_tail_call (CE_ctor_ref (ctor), ctor_params)
        | CE_call (CE_ctor_ref (ctor), ctor_params) =>
          List.Iter (ctor_params, emit);
          _ilg.Emit (OpCodes.Newobj, ctor);


        /* emit a call to an instance method, basing on the 'this' pointer for value types */
        | CE_tail_call (CE_method_ref (CE_this, method, _), method_params)
                                                      when _this_is_value_type
        | CE_call (CE_method_ref (CE_this, method, _), method_params)
                                                      when _this_is_value_type =>
          _ilg.Emit (OpCodes.Ldarg_0);
          _ilg.Emit (OpCodes.Ldobj, _type_of_this);
          _ilg.Emit (OpCodes.Box, _type_of_this);

          List.Iter (method_params, emit);
          emit_method_call (expr, true, method)


        /* emit a call to an instance method, basing on an instance field's contents */
        | CE_tail_call (CE_method_ref (CE_field_ref (base_object, field),
                                       method, notvirtual), method_params)
        | CE_call (CE_method_ref (CE_field_ref (base_object, field), method, notvirtual),
                   method_params) =>
          emit (base_object);
          def base_is_value_type = field.FieldType.IsValueType;

          if (base_is_value_type)
            _ilg.Emit (OpCodes.Ldflda, field)
          else
            _ilg.Emit (OpCodes.Ldfld, field);

          List.Iter (method_params, emit);
          emit_method_call (expr, base_is_value_type || notvirtual, method)


        /* emit a call to an instance method, basing on a static field's contents */
        | CE_tail_call (CE_method_ref (CE_global_ref (mi), method, notvirt),
                        method_params) when member_is_field (mi)
        | CE_call (CE_method_ref (CE_global_ref (mi), method, notvirt),
                   method_params) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");

          def base_is_value_type = field_info.FieldType.IsValueType;

          if (base_is_value_type)
            _ilg.Emit (OpCodes.Ldsflda, field_info)
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);

          List.Iter (method_params, emit);
          emit_method_call (expr, base_is_value_type || notvirt, method);



        /* emit a call to an instance method, basing on a local variable */
        | CE_tail_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method, notvirt), method_params)
        | CE_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method, notvirt), method_params) =>
          def base_is_value_type = decl.ty.IsValueType;

          if (base_is_value_type) {
            match (decl.local_slot) {
              | Some (local_slot) => _ilg.Emit (OpCodes.Ldloca, local_slot)
              | _ =>
                match (decl.parm_index) {
                  | Some (parm_index) => emit_ldarga (parm_index)
                  | _ => Util.ice (_method_name +
                                   ": null local slot or no parameter index " +
                                   "in CE_call (CE_method_ref (CE_ref + " +
                                   decl.name + "))")
                }
            }
          }
          else {
            def _ = emit (decl_ref); ()
          };

          List.Iter (method_params, emit);
          emit_method_call (expr, base_is_value_type || notvirt, method)


        /* emit a call to an instance method */
        | CE_tail_call (CE_method_ref (base_object, method, notvirt), method_params)
        | CE_call (CE_method_ref (base_object, method, notvirt), method_params) =>
          emit (base_object);
          def is_value_type = type_of (base_object).IsValueType;
          when (is_value_type) {
            def local_slot = _ilg.DeclareLocal (type_of (base_object));
            _ilg.Emit (OpCodes.Stloc, local_slot);
            _ilg.Emit (OpCodes.Ldloca, local_slot);
          };
          List.Iter (method_params, emit);
          emit_method_call (expr, is_value_type || notvirt, method)


        /* emit a call to a static method */
        | CE_tail_call (CE_global_ref (mi), method_parms) when member_is_method (mi)
        | CE_call (CE_global_ref (mi), method_parms) when member_is_method (mi) =>
          def method_info = (mi :> MethodInfo);

          assert (method_info.IsStatic, "CE_call CE_global_ref to a non-static field");

          List.Iter (method_parms, emit);
          emit_method_call (expr, true, method_info)


        /* emit an operator */
        | CE_tail_call (CE_opcode (opcode), parms)
        | CE_call (CE_opcode (opcode), parms) =>
          // FIXME: seperate out
          List.Iter (parms, emit);
          match (opcode) {
            | "+.s" =>  _ilg.Emit (OpCodes.Add_Ovf)
            | "+.u" => _ilg.Emit (OpCodes.Add_Ovf_Un)
            | "+.f" =>  _ilg.Emit (OpCodes.Add)

            | "<<.s" | "<<.f" | "<<.u" =>  _ilg.Emit (OpCodes.Shl)
            | ">>.s" | ">>.f" =>  _ilg.Emit (OpCodes.Shr)
            | ">>.u" =>  _ilg.Emit (OpCodes.Shr_Un)

            | "unary.+.s" | "unary.+.u" | "unary.+.f" => ()

            | "-.s" =>  _ilg.Emit (OpCodes.Sub_Ovf)
            | "-.u" => _ilg.Emit (OpCodes.Sub_Ovf_Un)
            | "-.f" =>  _ilg.Emit (OpCodes.Sub)

            | "unary.-.s" =>
              _ilg.Emit (OpCodes.Ldc_I4_M1);
              emit_value_type_conversion (SystemType.Int32,
                                          type_of (List.Hd (parms)), true);
              _ilg.Emit (OpCodes.Mul_Ovf)
            | "unary.-.f" =>
              _ilg.Emit (OpCodes.Neg)

            | "unary.~.u"
            | "unary.~.s" =>
              _ilg.Emit (OpCodes.Not);

            | "unary.~.f" =>
              def type_of_parm = type_of (List.Head (parms));
              when (type_of_parm.FullName == "System.Single" ||
                    type_of_parm.FullName == "System.Double" ||
                    type_of_parm.FullName == "System.Decimal")
                Util.ice ("float, double or decimal as an argument for binary negation in CGIL");
              _ilg.Emit (OpCodes.Not);

            | "*.s" =>  _ilg.Emit (OpCodes.Mul_Ovf)
            | "*.u" => _ilg.Emit (OpCodes.Mul_Ovf_Un)
            | "*.f" =>  _ilg.Emit (OpCodes.Mul)

            | "/.s" | "/.f" =>  _ilg.Emit (OpCodes.Div)
            | "/.u" => _ilg.Emit (OpCodes.Div_Un)
            | "%.s" | "%.f" =>  _ilg.Emit (OpCodes.Rem)
            | "%.u" => _ilg.Emit (OpCodes.Rem_Un)

            | "|.s" | "|.u" | "|.f" => _ilg.Emit (OpCodes.Or);
            | "&.s" | "&.u" | "&.f" => _ilg.Emit (OpCodes.And);
            | "^.s" | "^.u" | "^.f" => _ilg.Emit (OpCodes.Xor);
            | "bool.!" =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Ceq)
            | "==" =>
              _ilg.Emit (OpCodes.Ceq);
            | "!=" =>
              _ilg.Emit (OpCodes.Ceq);
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Ceq);
            | "<.s" | "<.f" => emit_compare (OpCodes.Blt_S)
            | "<.u" => emit_compare (OpCodes.Blt_Un_S)
            | ">.s" | ">.f" => emit_compare (OpCodes.Bgt_S)
            | ">.u" => emit_compare (OpCodes.Bgt_Un_S)
            | "<=.s" | "<=.f" => emit_compare (OpCodes.Ble_S)
            | "<=.u" => emit_compare (OpCodes.Ble_Un_S)
            | ">=.s" | ">=.f" => emit_compare (OpCodes.Bge_S)
            | ">=.u" => emit_compare (OpCodes.Bge_Un_S)
            | _ =>
              Util.ice (_method_name + ": unmatched CE_opcode (" + opcode + ")")
          };

        /* emit self tail call -- that is jump to method start */
        | CE_self_tail_call (method_params) =>
          List.Iter (method_params, emit);
          foreach (cgv : CG_val in List.Rev (_cg_method.parms))
            store_argument (cgv.parm_index);
          _ilg.Emit (OpCodes.Br, _method_start_label);


        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | CE_raise (exc) =>
          emit (exc);
          _ilg.Emit (OpCodes.Throw);


        /* emit the try/with construction */
        | CE_try_with (try_expr, catch_val, catch_expr) =>
          def type_of_try_expr = type_of (expr);

          def ignore_try_with_result = SystemType.Void.Equals (type_of_try_expr);
          mutable try_result = null;

          unless (ignore_try_with_result)
            try_result = _ilg.DeclareLocal (type_of_try_expr);

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          unless (throws (try_expr) || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);

          _ilg.BeginCatchBlock (catch_val.ty);

          def catch_val_local_slot = declare_val_local_slot (catch_val);
          _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);

          emit (catch_expr);

          unless (throws (catch_expr) || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);

          _ilg.EndExceptionBlock ();

          unless ((throws (catch_expr) && throws (try_expr)) || ignore_try_with_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        // FIXME: how does finally work? what about storing it's result in
        //        try_result as in CE_try_with?
        | CE_try_finally (try_expr, finally_expr) =>
          def type_of_try_expr = type_of (try_expr);

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          def ignore_try_result = throws (try_expr) || SystemType.Void.Equals (type_of_try_expr);
          mutable try_result = null;

          unless (ignore_try_result) {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          emit (finally_expr);

          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | CE_this =>
          assert (!_method_is_static, "CE_this is a static method");

          _ilg.Emit (OpCodes.Ldarg_0);


        /* loads a literal on the evaluation stack */
        | CE_literal (l) =>
          emit_literal (l);


        /* loads address of given method */
        | CE_method_addr (meth) =>
          _ilg.Emit (OpCodes.Ldftn, meth);


        /* creates object of value type using implicit ctor */
        | CE_init_obj (t) =>
          def local_slot = _ilg.DeclareLocal (t);
          _ilg.Emit (OpCodes.Ldloca, local_slot);
          _ilg.Emit (OpCodes.Initobj, t);
          _ilg.Emit (OpCodes.Ldloc, local_slot);


        /* creates a new array, given a list of initializers */
        | CE_mkarray (element_type, initializers, [CE_literal (L_int (size))]) =>
          _ilg.Emit (OpCodes.Ldc_I4, size);
          _ilg.Emit (OpCodes.Newarr, element_type);

          def load_elements (index : int, elements : list <CG_expr>) {
            match (elements) {
              | [] => ()
              | element :: rest =>
                _ilg.Emit (OpCodes.Dup);
                _ilg.Emit (OpCodes.Ldc_I4, index);

                when (element_type.IsValueType && !element_type.IsPrimitive)
                  _ilg.Emit (OpCodes.Ldelema, element_type);

                emit (element);
                emit_array_store_opcode (element_type);
                load_elements (index + 1, rest)
            }
          };
          load_elements (0, initializers);

        | CE_mkarray (_, initializers, dimensions) =>
          mutable size = 0;
          foreach (element in dimensions) {
            ++size;
            emit (element);
          }

          def arg_types = array (size);
          for (mutable i = 0; i < size; ++i) arg_types [i] = SystemType.Int32;
          def method = _module_builder.GetArrayMethod (expr.ty, ".ctor", CallingConventions.HasThis,
                                                       null, arg_types);
          _ilg.Emit (OpCodes.Newobj, method);

          unless (initializers matches []) {
            def method = array_set_method (type_of (expr));

            def dimensions_array = array (size);
            mutable i = 0;
            foreach (CE_literal (L_int (it)) in dimensions) {
              dimensions_array [i] = it;
              ++i;
            };
            assert (i == size, "dimensions must be literals when initializes are supplied");

            def load_elements (index : array <int>, elements : list <CG_expr>) {
              match (elements) {
                | [] => ()
                | element :: rest =>
                  _ilg.Emit (OpCodes.Dup);                  
                  for (mutable j = 0; j < index.Length; ++j)
                    emit_literal (L_int (index [j]));
                  emit (element);
                  def next (index : array <int>)
                  {
                    ++index [index.Length - 1];
                    for (mutable j = index.Length - 1; index [j] == dimensions_array [j] && j > 0; --j)
                    {
                      index [j] = 0;
                      ++index [j - 1];
                    }
                    index
                  }
                  emit_method_call (expr, true, method);
                  load_elements (next (index), rest)
              }
            }
            load_elements (array (dimensions_array.Length), initializers);
          }

          
        /* takes address of a value */
        | CE_addr (CE_indirect (expr)) =>
          emit (expr)

        | CE_addr (expr) =>
          assert (wish_address (expr));
          match (expr) {
            | CE_ref
            | CE_field_ref
            | CE_volatile_field_ref
            | CE_volatile_global_ref
            | CE_global_ref
            | CE_array_indexer => ()
            | _ => 
              // should not happen
              Message.error (expr.loc, 
                             "failed to take address of this expression: " + 
                             pretty_print (expr))
          }
          // if wish_address(expr), then emit should handle this
          emit (expr)

        | CE_indirect (CE_addr (expr)) =>
          emit (expr)

        /* load value by pointer */
        | CE_indirect (expr) =>
          emit (expr);
          def ty = type_of (expr);
          def el_ty = ty.GetElementType ();
          assert (ty.IsByRef && el_ty != null);

          maybe_volatile (expr);

          if (el_ty.IsValueType)
            emit_ldind_for_value_type (el_ty)
          else
            _ilg.Emit (OpCodes.Ldind_Ref);


        /* an interrupting NOP instruction */
        | CE_none => ()

        | _ =>
          Message.warning ("FIXME: unmatched: " + pretty_print (expr));
      }
    }

    private array_set_method (t : System.Type) : MethodInfo
    {
        def rank = t.GetArrayRank ();

        def args = array (rank + 1);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }
        args [rank] = t.GetElementType ();

        _module_builder.GetArrayMethod (t, "Set",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        typeof (void), args);
    }


    /*
     * Emits a local reference instruction
     */
    private emit_ce_ref (decl : CG_val, get_address_for_value_types : bool) : void
    {
      match (decl.local_slot) {
        | Some (local_slot) =>
          // local values
          if (get_address_for_value_types)
            _ilg.Emit (OpCodes.Ldloca, local_slot)
          else
            _ilg.Emit (OpCodes.Ldloc, local_slot)

        | _ =>
          // method parameters
          match (decl.parm_index) {
            | Some (parm_index) =>
              if (get_address_for_value_types)
                emit_ldarga (parm_index)
              else
                emit_ldarg (parm_index)
            | _ when SystemType.Void.Equals (decl.ty) => ()
            | _ =>
              Util.ice (_method_name + ": parameter index / variable local"
                        " slot undefined in CE_ref " + decl.name)
          }
      }
    }


    private array_set_method (arr : CG_expr) : MethodInfo
    {
        array_set_method (type_of (arr));
    }

    private array_get_method (arr : CG_expr) : MethodInfo
    {
        def t = type_of (arr);
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }

        _module_builder.GetArrayMethod (t, "Get",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        t.GetElementType (), args);
    }

    private array_addr_method (arr : CG_expr) : MethodInfo
    {
        def t = type_of (arr);
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }

        _module_builder.GetArrayMethod (t, "Address",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        t.GetElementType (), args);
    }

    /**
     * Emits the CE_switch instruction
     *
     * Asserts that the smallest of the case indices is positive. Quietly
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never
     * generate too long switch instructions -- assuring this should belong
     * to a higher level logic.
     */
    private emit_switch (default_expr : option <CG_expr>,
                         cases : list <int * CG_expr>) : void
    {
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr) {
          | Some => label_default
          | None => label_next_instruction
        };

      // step one: sort the cases increasingly
      def compare_cases (l : int * CG_expr, r : int * CG_expr) : int {
        def (l, _) = l; def (r, _) = r; l - r
      };

      def cases = List.Sort (cases, compare_cases);
      def (first_index, _) = List.Head (cases);

      // step two: rescale, so that the first label has value zero
      when (first_index != 0) {
        // NOTE: see the assumptions in the method description
        emit_literal (L_int (first_index));
        _ilg.Emit (OpCodes.Sub_Ovf)
      };

      // step three: generate the jump labels for the switch cases
      mutable reversed_labels = [];

      def make_labels (index : int, cases : list <int * CG_expr>)
                                        : list <Label * CG_expr> {
        match (cases) {
          | (case_index, case_expr) :: rest =>
            assert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;

              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)
            }
          | [] => []
        }
      };

      def labeled_cases = make_labels (first_index, cases);
      def labels = List.Rev (reversed_labels);

      def labels_array = label_list_to_array (labels);

      // step four: emit the switch instruction and the default expression
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr) {
        | Some (default_expr) =>
          emit (default_expr);
          unless (throws (default_expr))
            _ilg.Emit (OpCodes.Br, label_next_instruction);
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
      };

      // step five: emit the switch cases
      def walk_cases (cases : list <Label * CG_expr>) : void {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          emit (expr);
          unless (throws (expr))
            _ilg.Emit (OpCodes.Br, label_next_instruction);
          walk_cases (rest)
        | [] => ()
      };

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      _ilg.MarkLabel (label_next_instruction);
    }


    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (index : int) : void
    {
      | 0 => _ilg.Emit (OpCodes.Ldarg_0)
      | 1 => _ilg.Emit (OpCodes.Ldarg_1)
      | 2 => _ilg.Emit (OpCodes.Ldarg_2)
      | 3 => _ilg.Emit (OpCodes.Ldarg_3)
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarg, index)
    }


    private store_argument (parm_index : option <int>) : void {
      | Some (index) =>
        if (index < 256)
          _ilg.Emit (OpCodes.Starg_S, index :> byte)
        else
          _ilg.Emit (OpCodes.Starg, index);
      | None => Util.ice ("no param_index found")
    }

    
    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (index : int) : void
    {
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarga, index)
    }


    /**
     * Performs value type conversion form l to r
     */
    private emit_value_type_conversion (l : System.Type, r : System.Type,
                                        is_checked : bool) : void
    {
      def is_unsigned (t : System.Type) {
        match (t.Name [0]) {
          // UInt32, UInt64, UInt16
          | 'U'
          // Byte
          | 'B'
          // Char
          | 'C'   => true
          | _ => false
        }
      };
      def fail () {
        Message.warning ("failed to emit value type conversion from " +
                         l.FullName + " to " + r.FullName)
      };

      match (()) {
        | _ when r.Equals (l) => ()
        | _ when l.IsPrimitive || l.IsEnum =>
          if (r.IsPrimitive || r.IsEnum) {
            def rname =
              // FIXME: use true underalying type
              if (r.IsEnum) "Int32" else r.Name;
            def opcode =
              if (is_checked) {
                match (rname) {
                  | "Int64" when is_unsigned (l) => OpCodes.Conv_Ovf_I8_Un
                  | "Int64" => OpCodes.Conv_I8 // Conv_Ovf_I8 is broken in mono
                  | "Int32" when is_unsigned (l) => OpCodes.Conv_Ovf_I4_Un
                  | "Int32" => OpCodes.Conv_Ovf_I4
                  | "Int16" when is_unsigned (l) => OpCodes.Conv_Ovf_I2_Un
                  | "Int16" => OpCodes.Conv_Ovf_I2
                  | "SByte" when is_unsigned (l) => OpCodes.Conv_Ovf_I1_Un
                  | "SByte" => OpCodes.Conv_Ovf_I1
                  | "UInt64" when is_unsigned (l) => OpCodes.Conv_Ovf_U8_Un
                  | "UInt64" => OpCodes.Conv_Ovf_U8
                  | "UInt32" when is_unsigned (l) => OpCodes.Conv_Ovf_U4_Un
                  | "UInt32" => OpCodes.Conv_Ovf_U4
                  | "UInt16" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
                  | "UInt16" => OpCodes.Conv_Ovf_U2
                  | "Boolean" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
                  | "Boolean" => OpCodes.Conv_Ovf_U1
                  | "Byte" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
                  | "Byte" => OpCodes.Conv_Ovf_U1
                  | "Char" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
                  | "Char" => OpCodes.Conv_Ovf_U2

                  | "Single" when is_unsigned (l) => OpCodes.Conv_R_Un
                  | "Single" => OpCodes.Conv_R4
                  // there is no OpCodes.Conv_R8_Un
                  | "Double" when !is_unsigned (l) => OpCodes.Conv_R8

                  | _ => fail (); OpCodes.Nop
                }
              }
              else {
                match (rname) {
                  | "Int64" => OpCodes.Conv_I8
                  | "Int32" => OpCodes.Conv_I4
                  | "Int16" => OpCodes.Conv_I2
                  | "SByte" => OpCodes.Conv_I1
                  | "UInt64" => OpCodes.Conv_U8
                  | "UInt32" => OpCodes.Conv_U4
                  | "UInt16" => OpCodes.Conv_U2
                  | "Byte" => OpCodes.Conv_U1
                  | "Boolean" => OpCodes.Conv_U1
                  | "Char" => OpCodes.Conv_U2

                  | "Single" when is_unsigned (l) => OpCodes.Conv_R_Un
                  | "Single" => OpCodes.Conv_R4
                  | "Double" => OpCodes.Conv_R8

                  | _ => fail (); OpCodes.Nop
                }
              }
            _ilg.Emit (opcode)
          }
          else if (r.Equals (SystemType.Decimal)) {
            // FIXME: use true underalying type
            def lname = if (l.IsEnum) "Int32" else l.Name;
            match (lname) {
              | "Int32" | "UInt32" | "Single" | "Int64" | "UInt64"
              | "Double" =>
                _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemType.Decimal_ctors.Get (lname)))
              | _ => fail ()
            }
          }
          else fail ()

        | _ => fail ()
      }
    }

    /**
     * Checks if a given member info describes a field
     */
    private member_is_field (mi : MemberInfo) : bool
    {
      mi.MemberType == System.Reflection.MemberTypes.Field
    }


    /**
     * Checks if a given member info describes a method
     */
    private member_is_method (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Method
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier.
     */
    private emit_method_call (expr : CG_expr,
                              base_is_value_type_or_static : bool,
                              method : MethodInfo) : void
    {
      def is_tail =
        match (expr) {
          | CE_tail_call when Flags.general_tail_call_opt =>
            _ilg.Emit (OpCodes.Tailcall);
            true
          | _ => false
        };

      if (base_is_value_type_or_static)
        _ilg.Emit (OpCodes.Call, method)
      else
        _ilg.Emit (OpCodes.Callvirt, method);

      when (is_tail)
        _ilg.Emit (OpCodes.Ret);
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : CG_val) : LocalBuilder
    {
      def local_slot = _ilg.DeclareLocal (val.ty);
      local_slot.SetLocalSymInfo (val.name);
      val.local_slot = Some (local_slot);
      local_slot
    }

    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     */
    private emit_array_store_opcode (ty : System.Type) : void
    {
      assert (!SystemType.Void.Equals (ty), "tried to store a System.Void in an array");

      if (ty.IsPrimitive) {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"
            | "Byte"                     => OpCodes.Stelem_I1
            | "Char" | "Int16"
            | "UInt16"                   => OpCodes.Stelem_I2
            | "Int32" | "UInt32"         => OpCodes.Stelem_I4
            | "Int64" | "UInt64"         => OpCodes.Stelem_I8
            | "Single"                   => OpCodes.Stelem_R4
            | "Double"                   => OpCodes.Stelem_R8
            | _ => Util.ice ("System.Type IsPrimitive has lied")
          }
          _ilg.Emit (opcode);
        }
        else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
        else _ilg.Emit (OpCodes.Stelem_Ref);
    }


    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : System.Type) : void
    {
      assert (!SystemType.Void.Equals (ty), "tried to load a System.Void from an array");

      if (ty.IsValueType && !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldelema, ty);
        _ilg.Emit (OpCodes.Ldobj, ty);
      } else {
        def opcode =
          if (ty.IsPrimitive)
            match (ty.Name) {
              | "SByte" | "Boolean" => OpCodes.Ldelem_I1
              | "Byte"              => OpCodes.Ldelem_U1
              | "Char" | "Int16"    => OpCodes.Ldelem_I2
              | "UInt16"            => OpCodes.Ldelem_U2
              | "Int32"             => OpCodes.Ldelem_I4
              | "UInt32"            => OpCodes.Ldelem_U4
              | "Int64" | "UInt64"  => OpCodes.Ldelem_I8
              | "Single"            => OpCodes.Ldelem_R4
              | "Double"            => OpCodes.Ldelem_R8
              | _ => Util.ice ("System.Type.IsPrimitive has lied")
            }
          else
            OpCodes.Ldelem_Ref;

        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : System.Type) : void
    {
      if (ty.IsEnum || !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldobj, ty)
      }
      else {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"     => OpCodes.Ldind_I1
            | "Byte"                  => OpCodes.Ldind_U1
            | "Char" | "Int16"        => OpCodes.Ldind_I2
            | "UInt16"                => OpCodes.Ldind_U2
            | "Int32"                 => OpCodes.Ldind_I4
            | "UInt32"                => OpCodes.Ldind_U4
            | "Int64"                 => OpCodes.Ldind_I8
            | "UInt64"                => OpCodes.Ldind_I8
            | "Single"                => OpCodes.Ldind_R4
            | "Double"                => OpCodes.Ldind_R8
            | _ =>
              Util.ice (_method_name + ": not a recognized value type: " + ty.FullName);
          }

        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a literal
     */
     
    private emit_literal (l : Literal) : void
    {
      def emit_i4 (x) {
        | -1 => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | 0  => _ilg.Emit (OpCodes.Ldc_I4_0)
        | 1  => _ilg.Emit (OpCodes.Ldc_I4_1)
        | 2  => _ilg.Emit (OpCodes.Ldc_I4_2)
        | 3  => _ilg.Emit (OpCodes.Ldc_I4_3)
        | 4  => _ilg.Emit (OpCodes.Ldc_I4_4)
        | 5  => _ilg.Emit (OpCodes.Ldc_I4_5)
        | 6  => _ilg.Emit (OpCodes.Ldc_I4_6)
        | 7  => _ilg.Emit (OpCodes.Ldc_I4_7)
        | 8  => _ilg.Emit (OpCodes.Ldc_I4_8)
        | k when (k >= -128 && k <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, k :> sbyte)
        | k => _ilg.Emit (OpCodes.Ldc_I4, k)
      }

      match (l) {
        | L_void => ()
        | L_null =>
          _ilg.Emit (OpCodes.Ldnull)
        | L_bool (true) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)
          
        | L_int (k) => emit_i4 (k)
        | L_uint (k) =>
          unchecked (emit_i4 (k :> int));
          _ilg.Emit (OpCodes.Conv_U4)

        | L_byte (k) => emit_i4 (k :> int)
        | L_char (k) => emit_i4 (k :> int)
        | L_short (k) => emit_i4 (k :> int)          
        | L_ushort (k) => emit_i4 (k :> int)
        | L_sbyte (k) => emit_i4 (k :> int)

        | L_long (k) => _ilg.Emit (OpCodes.Ldc_I8, k)
        | L_ulong (k) =>
          unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
          _ilg.Emit (OpCodes.Conv_U8)

        | L_string (s) => _ilg.Emit (OpCodes.Ldstr, s)
        | L_float (f) => _ilg.Emit (OpCodes.Ldc_R4, f)
        | L_double (f) => _ilg.Emit (OpCodes.Ldc_R8, f)
        | L_decimal (m) =>
          def decimal_bits = System.Decimal.GetBits (m);

          _ilg.Emit (OpCodes.Ldc_I4_4);

          _ilg.Emit (OpCodes.Newarr, SystemType.Int32);

          when (decimal_bits [0] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [1] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [2] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [3] != 0)
            _ilg.Emit (OpCodes.Dup);

          when (decimal_bits [0] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [0]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [1] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [1]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [2] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_2);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [2]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [3] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_3);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [3]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }

          _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemType.Decimal_ctors.Get ("Int32[]")))

        | L_enum (l, _) => emit_literal (l)
      }
    }


    /**
     * Emits a comparison operation
     */
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }


    /**
     * Computes the type of an expression
     */
    type_of (ex : CG_expr) : System.Type
    {
      CGexpr.type_of (ex)
    }


    /**
     * Pretty prints a list of expressions
     */
    static pretty_print_list (exs : list <CG_expr>, acc : string) : string
    {
      match (exs) {
        | [] => acc
        | ex :: rest => pretty_print_list (rest, acc + pretty_print (ex))
      }
    }


    /**
     * Pretty prints an expression
     */
    public static pretty_print (ex : CG_expr) : string
    {
      match (ex) {
        | CE_ref (decl) =>
          "CE_ref (" + decl.name + "); "
        | CE_global_ref (mi) =>
          "CE_global_ref (" + pretty_print_member_info (mi) + "); "
        | CE_volatile_global_ref (mi) =>
          "CE_volatile_global_ref (" + pretty_print_member_info (mi) + "); "
        | CE_base_ctor_ref (mi) =>
          "CE_base_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_ctor_ref (mi) =>
          "CE_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_field_ref (_, fld) =>
          "CE_field_ref (" + pretty_print_member_info (fld) +"); "
        | CE_volatile_field_ref (_, fld) =>
          "CE_volatile_field_ref (" + pretty_print_member_info (fld) +"); "
        | CE_method_ref (_, meth, _) =>
          "CE_method_ref (" + pretty_print_member_info (meth) + "); "
        | CE_method_addr (meth) =>
          "CE_method_addr (" + pretty_print_member_info (meth) + "); "
        | CE_ignore (expr) =>
          "CE_ignore (" + pretty_print (expr) + "); "
        | CE_opcode (name) =>
          "CE_opcode (" + name + "); "
        | CE_self_tail_call (parms) =>
          "CE_self_tail_call (" + pretty_print_list (parms, "") + "); "
        | CE_call (func, parms) =>
          "CE_call " + pretty_print (func) + " (" + pretty_print_list (parms, "") + "); "
        | CE_tail_call (func, parms) =>
          "CE_tail_call " + pretty_print (func) + " (" +
          pretty_print_list (parms, "") + "); "
        | CE_assign (target, source) =>
          pretty_print (target) + " = " + pretty_print (source) + "; "
        | CE_addr (expr) =>
          "CE_addr (" + pretty_print (expr) + "); "
        | CE_indirect (expr) =>
          "CE_indirect (" + pretty_print (expr) + "); "
        | CE_multiple_assign =>
          "CE_multiple_assign; "
        | CE_loop (expr, _) =>
          "CE_loop (" + pretty_print (expr) + "); "
        | CE_continue_loop =>
          "CE_continue_loop; "
        | CE_let (name, body) =>
          "let " + name.name + " = " + pretty_print (name.val) + " in "
          + pretty_print (body) + "; "
        | CE_has_type (_, ty) => "CE_has_type (" + pretty_print_type (ty) + "); "
        | CE_not_null => "CE_not_null; "
        | CE_typeof (ty) => "CE_typeof (" + pretty_print_type (ty) + "); "
        | CE_raise (exn) => "CE_raise (" + pretty_print (exn) + "); "
        | CE_if (cond, e_then, e_else) =>
          "if (" + pretty_print (cond) + ") " + pretty_print (e_then)
          + " else " + pretty_print (e_else) + "; "
        | CE_try_with => "CE_try_with; "
        | CE_try_finally => "CE_try_finally; "
        | CE_literal => "CE_literal; "
        | CE_this => "CE_this; "
        | CE_cast (expr, ty, _) =>
          "CE_cast < " + pretty_print (expr)
          + " to " + pretty_print_type (ty) + "> "
        | CE_init_obj (ty) =>
          "CE_init_obj (" + pretty_print_type (ty) + ") "
        | CE_sequence (body) => "{ " + pretty_print_list (body, "") + " }; "
        | CE_none => "CE_none"
        | CE_mkarray (_, initializers, dimensions) =>
          "CE_mkarray { " + pretty_print_list (initializers, "") + " } {"+ List.FoldLeft (dimensions, "", fun (i, acc) { acc + i.ToString () + "; " }) +"}; "
        | CE_array_indexer (obj, args) =>
          "CE_mindexer " + pretty_print (obj) + "[" +
          pretty_print_list (args, "") + "]" + "; "
        | CE_switch (indexer, _, _) =>
          "CE_switch ( " + pretty_print (indexer) + " ); "
      }
    }


    /**
     * Pretty prints a type
     */
    private static pretty_print_type (ty : System.Type) : string
    {
      ty.FullName
    }


    /**
     * Pretty prints a member info name
     */
    private static pretty_print_member_info (mi : MemberInfo) : string
    {
      mi.DeclaringType.FullName + "::" + mi.Name
    }

    /**
     * Converts a list <Label> into a array <Label>
     * FIXME: this should work now?
     */
    private label_list_to_array (x : list <Label>) : array <Label>
    {
      def result = array (List.Length (x));

      def loop (index : int, x : list <Label>) : void {
        match (x) {
          | head :: tail =>
            result [index] = head;
            loop (index + 1, tail)
          | [] => ()
        }
      };

      loop (0, x);

      result
    }

  } /* end of the class */

} /* end of the namespace */
