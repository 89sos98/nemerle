/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Util;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

  public class ICE : System.Exception
    {
      public msg : string;
      public this (m : string) { this.msg <- m }
    }

  public class Recovery : System.Exception
    {
      public this () {}
    }

  public module Util 
    {
      mutable current_id : int;
      public next_id () : int {
        current_id <- current_id + 1;
        current_id
      }

      public ice<'a> (msg : string) : 'a { throw ICE (msg) }
      public ice<'a> () : 'a { throw ICE ("(see backtrace)") }

      public locate<'a> (l : Location, f : void -> 'a) : 'a
        {
          if (l == null || l == Located.default_loc) f ()
          else {
            Location_stack.push (l);
            try f () finally Location_stack.pop ()
          }
        }

      /** Concatenates strings from the list, inserting given separator
          between them
       */
      public ConcatStrings (sep : string, l : list <string>) : string {
        def loop (l : list<string>, acc : System.Text.StringBuilder) {
          match (l) {
            | [x] => acc.Append (x)
            | x :: xs => loop (xs, acc.Append (x + sep))
            | [] => acc
          }
        };
        loop (l, System.Text.StringBuilder ("")).ToString ()
      }
      
      public is_new (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_new => true | _ => false };
        List.Exists (mem.GetModifiers (), is_mod);
      }
        
      public is_abstract (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_abstract => true | _ => false };
        List.Exists (mem.GetModifiers (), is_mod);
      }
        
      public is_static (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_static => true | _ => false };
        List.Exists (mem.GetModifiers (), is_mod);
      }
        
      public is_override (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_override => true | _ => false };
        List.Exists (mem.GetModifiers (), is_mod);
      }
        
      public is_mutable (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_mutable => true | _ => false };
        List.Exists (mem.GetModifiers (), is_mod);
      }
        
      public get_ns (s : string) : string {
        def idx = s.LastIndexOf('.');
        if (idx == -1) ""
        else
          s.Substring(0, idx);
      }
      
      public is_capitalized (s : string) : bool {
        def idx = s.LastIndexOf('.');
        s[idx + 1] >= 'A' && s[idx + 1] <= 'Z'
      }

      public tmpname (kind : string) : string {
        "_N_" + kind + Util.next_id ().ToString ()
      }
    }
  
  public module Message 
    {
      mutable error_cnt : int;
      mutable warning_cnt : int;
      mutable emitted_hints : Hashtable <string, int>;

      public location_to_string (l : Location) : string
      {
        if (l == null)
          "(no location)"
        else
          l.file + ":" + l.line.ToString () + ":" + l.column.ToString ()
      }

      public report (l : Location, m : string) : void
      {
        def l' =
          if (l == null) Location_stack.top()
          else l;
        Passes.KillProgressBar ();
        printf ("%s: %s\n", Message.location_to_string(l'), m);
      }

      public error (l : Location, m : string) : void {
        Message.error_cnt <- Message.error_cnt + 1;
        if (Flags.color_messages)
          Message.report (l, "\e[01;31merror\e[0m: " + m)
        else
          Message.report (l, "error: " + m);        
      }
        
      public error (m : string) : void { Message.error (null, m) }

      public warning (l : Location, m : string) : void {
        Message.warning_cnt <- Message.warning_cnt + 1;
        if (Flags.color_messages)
          Message.report (l, "\e[01;33mwarning\e[0m: " + m)
        else
          Message.report (l, "warning: " + m);
      }
        
      public warning (m : string) : void { Message.warning (null, m) }

      public hint (l : Location, m : string) : void {
        if (Flags.color_messages)
          Message.report (l, "\e[01;32mhint\e[0m: " + m)
        else
          Message.report (l, "hint: " + m);
      }
      
      public hint (m : string) : void { Message.hint (null, m) }
      
      public hint_once (l : Location, m : string) : void {
        when (emitted_hints == null)
          emitted_hints <- Hashtable (20);
        unless (emitted_hints.Contains (m)) {
          if (Flags.color_messages)
            Message.report (l, "\e[01;32mhint\e[0m: " + m)
          else
            Message.report (l, "hint: " + m);
          emitted_hints.Add (m, 0)
        }
      }
        
      public hint_once (m : string) : void { Message.hint_once (null, m) }

      public debug (l : Location, m : string) : void {
        Message.report (l, "debug: " + m);
      }
        
      public debug (m : string) : void { Message.debug (null, m) }

      public fatal_error<'a> (l : Location, m : string) : 'a {
        Message.error (l, m);
        throw Recovery ()
      }
      
      public fatal_error<'a> (m : string) : 'a { Message.fatal_error (null, m) }

      public exit<'a> (ret : int) : 'a {      
        System.Environment.Exit (ret);
        throw Recovery () // FIXME: this code is unreachable but it seems to be the only trick to do the magic here
      }

      public maybe_bailout (fscked_up : bool) : void {
        if (Flags.ignore_confusion && fscked_up)
          ()
        else if (seen_error ()) {
          if (fscked_up)
            printf ("confused by earlier errors bailing out\n")
          else ();
          System.Environment.Exit (1)
        } else ()
      }
        
      public maybe_bailout () : void { Message.maybe_bailout (false) }

      public seen_error () : bool
      {
        error_cnt != 0
      }
    }

    public module Location_stack
      {
        mutable s : list <Location>;
        
        public push (l : Location) : void {
          if (l == null) ice() else
          Location_stack.s <- l :: Location_stack.s
        }

        public pop () : void {
          match (Location_stack.s) {
            | [] => Util.ice()
            | _ :: t => Location_stack.s <- t
          }
        }

        public top () : Location {
          match (Location_stack.s) {
            | [] => Location("", 0, 0)
            | h :: _ => h
          }
        }

        this () { Location_stack.s <- []; }
      }
  
}
