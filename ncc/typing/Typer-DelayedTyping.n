/*
 * Copyright (c) 2005-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public partial class Typer
  {
    public abstract class DelayedAction
    {
      public abstract Resolve (fail_loudly : bool) : option [TExpr];

      public override ToString () : string
      {
        "delayed macro"
      }
    }

    public class DelayedLambdaAction : DelayedAction
    {
      desc : string;
      fn : bool -> option [TExpr];

      public override ToString () : string
      { 
        desc
      }

      public override Resolve (fail_loudly : bool) : option [TExpr]
      {
        fn (fail_loudly)
      }

      public this (fn : bool -> option [TExpr], desc = "delayed typing action")
      {
        this.fn = fn;
        this.desc = desc;
      }
    }

    
    // TODO: object model seems to fit better here, upgrade most kinds to use DelayedAction
    [ManagerAccess (typer.Manager)]
    public class DelayedTyping : Located, System.IComparable [DelayedTyping]
    {
      id : int;
      typer : Typer;
      local_context : LocalContext;
      expected : TyVar;
      mutable pexpr : PT.PExpr;
      mutable generic_specifier : list [TyVar];

      [Record]
      public variant Kind
      {
        | MemberAccess { expr : TExpr; name : PT.Name; }
        | Overloaded { overloads : list [OverloadPossibility]; }
        | OverloadedOperator { overloads : list [OverloadPossibility]; 
                               t1 : TyVar; t2 : TyVar; name : string; env : GlobalEnv; 
                               seen : list [OverloadPossibility];
                             }
        | Operator { t1 : TyVar; t2 : TyVar; name : string; env : GlobalEnv; }
        | Resolved { expr : TExpr; }
        | Macro { action : DelayedAction }
        | Error

        public mutable filtering_expression : TExpr.Call;
        public mutable need_ref : bool;
        public mutable need_write : bool;

        public this () {}

        public override ToString () : string
        {
          match (this) 
          {
            | Resolved (a) => "resolved expression " + a.ToString ()
            | Error => "an error"
            | Overloaded (overloads) =>
              "ambiguity between overloads:\n  " + overloads.ToString ("\n  ")
            | MemberAccess (expr, name) =>
              $ "accessing member: ($expr : $(expr.Type)).$name"
            | Operator (t1, t2, name, _) =>
              "operator: "
              + if (t2 == null) $"$t1 $name\n"
                else            $"$t1 $name $t2\n"

            | OverloadedOperator (lst, t1, t2, name, _, _) => 
              "overloaded operator: "
              + if (t2 == null) $"$t1 $name\n"
                else            $"$t1 $name $t2\n"
              + $<# [..$(lst; "\n")]#>

            | Macro (action) => action.ToString ()
          }
        }
      }


      public CompareTo (o : DelayedTyping) : int
      {
        id - o.id
      }


      public DtKind : Kind
      {
        get {
          typer.solver.dt_store.Get (this)
        }
      }


      public ApplyGenericSpecifier (tyvars : list [TyVar]) : void
      {
        assert (generic_specifier == null);
        generic_specifier = tyvars;
        // apply it (possibly)
        SetKind (DtKind);
      }


      SetKind (k : Kind) : void
      {
        match (k) 
        {
          | Kind.Resolved (expr) => _ = typer.Expect (expected, expr.Type, "resolved overload");
          | _ => {}
        }

        def k =
          match (k) 
          {
            | Kind.Resolved ((TExpr.StaticRef (_, meth is IMethod, _)) as expr) =>
              match (meth.BuiltinKind) 
              {
                | BuiltinMethodKind.OpCode (ch, unch) =>
                  def opcode = if (local_context.IsChecked) ch else unch;
                  Kind.Resolved (TExpr.OpCode (expr.Location, expr.ty, opcode))

                | _ => k
              }

            | Kind.Overloaded (lst) =>
              when (expected.Hint.IsNone && List.ForAll (lst, x => x.Type is MType.Fun))
                _ = expected.Unify (MType.Fun (typer.FreshTyVar (), typer.FreshTyVar ()));
              Kind.Overloaded (OverloadPossibility.Unique (lst))

            | Kind.OverloadedOperator (lst, t1, t2, n, e, s) =>
              Kind.OverloadedOperator (OverloadPossibility.Unique (lst), t1, t2, n, e, s)

            | _ => k
          }

        when (generic_specifier != null)
          match (k) 
          {
            | Kind.OverloadedOperator (lst, _, _, _, _, _) 
            | Kind.Overloaded (lst) =>
              foreach (o in lst)
                o.SetGenericSpecifier (generic_specifier);
              generic_specifier = null;
              
            | Kind.Resolved (expr) =>
              typer.ApplyGenericSpecifier (expr, generic_specifier);
              generic_specifier = null;
              
            | _ => {}
          }
          
        def solver = Manager.Solver;

        match (solver.dt_store.Find (this)) 
        {
          | Some (k1) =>
            when (k.filtering_expression == null)
              k.filtering_expression = k1.filtering_expression;
            k.need_ref = k1.need_ref;
            k.need_write = k1.need_write;
          | None => {}
        }

        solver.dt_store = solver.dt_store.Replace (this, k);

        match (k) 
        {
          | Kind.Resolved (expr) =>
            when (PExpr != null)
              PExpr.typed_object = expr;
            when (k.need_write)
              typer.CheckLValue (expr, k.need_ref, 
                 if (k.need_ref) "ref/out parameter"
                 else "assignment target");
          | _ => {}
        }
      }


      public this (t : Typer, k : Kind, e : TyVar)
      {
        typer = t;
        local_context = t.local_context;
        Manager.Typer_DT_Id++;
        id = Manager.Typer_DT_Id;
        expected = e;
        SetKind (k)
      }


      public IsMutableIndexer : bool
      { 
        get {
          match (DtKind) {
            | Kind.OverloadedOperator (lst, _, _, _, _, _) 
            | Kind.Overloaded (lst) =>
              List.ForAll (lst, fun (op : OverloadPossibility) {
                match (op.Member) {
                  | p is IProperty => p.IsMutable && p.IsIndexer
                  | _ => false
                }
              })

            | Kind.Resolved (TExpr.PropertyMember (_, p))
            | Kind.Resolved (TExpr.StaticPropertyRef (_, p)) =>
              p.IsIndexer && p.IsMutable

            | _ => false
          }
        }
      }

      public IsFunctional : bool
      {
        get {
          match (DtKind) {
            | Kind.OverloadedOperator (lst, _, _, _, _, _) 
            | Kind.Overloaded (lst) =>
              lst.ForAll (fun (op) { op.Member is IMethod })

            | Kind.Resolved (TExpr.StaticRef (_, _ is IMethod, _)) => true

            | _ => false
          }
        }
      }

      public ExpectLValue (need_ref : bool) : bool
      {
        def kind = DtKind;
        kind.need_write = true;
        when (need_ref)
          kind.need_ref = true;

        match (kind) {
          | Kind.Overloaded (lst) =>
            !need_ref &&
            match (List.RevFilter (lst, fun (o : OverloadPossibility) {
              match (o.Member) {
                | p is IProperty => p.IsMutable && !need_ref
                | f is IField    => f.IsMutable 
                  || typer.is_instance_ctor && f.DeclaringType.Equals(typer.current_type)
                  
                | _              => false
              }
            })) {
              | [] => false
              | newlst =>
                SetKind (Kind.Overloaded (newlst));
                true
            }
 
          | Kind.Resolved (r) => typer.IsLValue (r, need_ref)

          | Kind.MemberAccess
          | Kind.Macro
          | Kind.Error => true

          | Kind.OverloadedOperator 
          | Kind.Operator => false
        }
      }

      public ExpectMember (name : string) : void
      {
        def can_have (_ : MType) {
          | Class (tc, _) => ! (tc.LookupMember (name) is [])
          | Array (_, n) => ! (InternalType.GetArrayType (n).LookupMember (name) is [])
          | TyVarRef (tv) => tv.Constraints.Exists (can_have)
          | Intersection (lst) => lst.Exists (can_have)
          | Tuple | Fun | Void | Ref | Out => false
        }

        match (DtKind) {
          | Kind.OverloadedOperator (lst, t1, t2, n, e, s) => 
            when (InternalType.Object_tc.LookupMember (name) is []) {
              // otherwise it's pointless
              def newlst = List.RevFilter (lst, fun (o : OverloadPossibility) {
                match (o.Type.Hint) {
                  | Some (mt) => can_have (mt)
                  | None => true // we don't yet know
                }
              });

              if (newlst is []) {}
              else SetKind (Kind.OverloadedOperator (newlst, t1, t2, n, e, s));
            }

          | Kind.Overloaded (lst) =>
            when (InternalType.Object_tc.LookupMember (name) is []) {
              // otherwise it's pointless
              def newlst = List.RevFilter (lst, fun (o : OverloadPossibility) {
                match (o.Type.Hint) {
                  | Some (mt) => can_have (mt)
                  | None => true // we don't yet know
                }
              });

              if (newlst is []) {}
              else SetKind (Kind.Overloaded (newlst));
            }

          | _ => {}
        }
      }

      public IsResolved : bool
      {
        get {
          match (typer.solver.dt_store.Find (this)) { //DtKind
            | Some (Kind.Resolved)
            | Some (Kind.Error) => true
            | _ => false
          }
        }
      }


      public ResolutionResult : TExpr
      {
        get {
          match (DtKind) {
            | Kind.Resolved (e) => e
            | Kind.Error => TExpr.Error ()
            | _ => assert (false)
          }
        }
      }


      public override ToString () : string { $"$DtKind" }

      public GetDescriptionForError () : list [Location * string]
      {
        def loc = this.Location;
        def used(o) { o.UsedLastTime }
        def makeOverloads(overloads, msg)
        {
          def makeLoc(x) 
          {
            def memLoc  = x.Member.Location;
            if (memLoc.Line == 0 || !System.IO.File.Exists(memLoc.File)) loc
            else memLoc
          }
          def overloads1 = if (overloads.Exists(used)) overloads.Filter(used) 
                           else                        overloads;
          (loc, msg) :: overloads1.Map(x => (makeLoc(x), $"Posible overload: $x"))
        }
        
        match (DtKind) 
        {
          | OverloadedOperator ([], t1, t2, name, _env, _seen) =>
            def msg = $"finding the operator $name($t1" + (if (t2 != null) $", $t2" else "") + ")";
            (loc, msg) :: []

          | OverloadedOperator (overloads, t1, t2, name, _env, _seen) =>
            def msg = $"ambiguity between operator $name($t1" 
                       + (if (t2 != null) $", $t2" else "") + ")" + " overloads:";
            makeOverloads(overloads, msg)
            
          | Overloaded (overloads) => makeOverloads(overloads, "ambiguity between overloads:")
          | Macro (action) =>
            // the Resolve function should dump the error message
            Util.locate (Location, {
              def res = action.Resolve (true);
              when (res.IsSome)
                Message.Error ($ "the macro resolution function unexpectedly succeeded "
                                 "when run for the second time, the result is "
                                 "$(Option.UnSome (res))");
            });
            [(loc, ToString())]
            
          | _  => [(loc,ToString ())]
        }
      }


      public IsOverloaded : bool
      {
        get { DtKind is Kind.Overloaded || DtKind is Kind.OverloadedOperator }
      }


      public Context : LocalContext
      {
        get { local_context }
      }


      public PExpr : PT.PExpr
      {
        get { pexpr }
        set { pexpr = value }
      }


      public CanSetCallExpr : bool
      {
        get {
          match (DtKind) {
            | MemberAccess
            | Overloaded
            | OverloadedOperator
            | Error
            | Operator => true
            | Resolved
            | Macro => false
          }
        }
      }


      public SetCallExpr (e : TExpr.Call) : void
      {
        def kind = DtKind;
        Util.cassert (CanSetCallExpr);
        if (kind.filtering_expression == null)
          kind.filtering_expression = e;
        else
          Util.cassert (kind.filtering_expression : object == e : object)
      }


      ResolveOverload (overloads : list [OverloadPossibility], 
                       parms : list [Parm], expected : TyVar)
                       : list [OverloadPossibility]
      {
        def solver = typer.solver;
        def messenger = solver.CurrentMessenger;

        foreach (overload in overloads)
          overload.UsedLastTime = false;

        def has_untyped_parm = parms.Exists (p => p.expr.Type.Hint.IsNone);

        def try_type (overload : OverloadPossibility, final) 
        {
          def parms = parms;
          def parms2 = if (overload.ExtensionMethodObject == null) parms
            else Parm (overload.ExtensionMethodObject) :: parms;
          def ct = CallTyper (typer, overload.Compile (), parms2, expected, r8169logic = true);
          ct.overload_possibility = overload;
          ct.is_final = final;
          ct.is_var_args = overload.VarArgs;
          overload.ResetOverloadSelectionStuff ();
          ct.Run ();
          if (ct.result == null || (overload.VarArgs && !ct.used_var_args))
            TExpr.Error ()
          else {
            unless (ct.result is TExpr.Error) {
              overload.PermutationArray = ct.GetPermutationArray ();
              overload.UsedDefaultParms = ct.used_default_parms;
            }
            ct.result
          }
        }

        def print_error_message (overload : OverloadPossibility) 
        {
          when (messenger.NeedMessage)
          {
              solver.PushState ();
              messenger.NeedMessage = true;
              _ = try_type (overload, final = false);
              solver.PopState ();
          }
        }

        match (OverloadPossibility.OnlyPossible(overloads, null, typer)) 
        {
          | [] => []
          | overloads =>
            mutable ok = [];

            // Message.Debug ($ "try type: $overloads");
            foreach (overload in overloads)
            {
              solver.PushState();
#if DEBUG
              _speculativeOverloadStack ::= overload;
              when (DtKind is Kind.OverloadedOperator(_overloads, _t1, _t2, name, _env, _seen))
                when (name == "op_Multiply")
                  if (Speculative)
                    assert(true);
                  else
                    assert(true);
#endif //DEBUG
              try
              { 
                unless (IsError (try_type (overload, final = false)))
                {
                  ok ::= overload;
                  if (Speculative)
                    assert(true);
                  else
                    assert(true);
                }
              } 
              finally 
              { 
                solver.PopState (); 
#if DEBUG
                _speculativeOverloadStack = _speculativeOverloadStack.Tail;
                if (Speculative)
                  assert(true);
                else
                  assert(true);
#endif //DEBUG
              }
            }
            // Message.Debug ($ "res: $ok");
            
            def makeArgsTypes() { parms.Map(p => 
              p.expr.Type) 
            }
            
            match (if (ok.Length > 1) typer.GetBestOverloads(ok, makeArgsTypes()) else ok)
            {
              | [] =>
                if (messenger.NeedMessage) 
                  match (overloads) 
                  {
                    | [o] => print_error_message(o);
                    | _ =>
                      ReportError (messenger, "each overload has an error during call:");
                      mutable cnt = 1;
                      foreach (o in overloads) 
                      {
                        ReportError (messenger, $ "overload #$cnt, $o");
                        print_error_message (o);
                        ++cnt;
                      }
                  }
                else
                  messenger.MarkError();
                []

              /*
                In general we do not commit to a single, best overload when we still
                have some parameters that have no Hint (which means they are of a totally
                unknown type), except:
                  - when it is the only possible overload, 
                  - we're in a special second pass of delayed typings or 
                  - it is == or !=. 

                The last part is a hack, it might be a good idea to
                commit to a single overload also in some other cases
                but the comparison operators seem to be crucial.

                Bug #770.
              */

              | [one] as result when ok is [_]
                                      || !has_untyped_parm 
                                      || typer.BadnessAllowed > 0 
                                      || one.Member.Name == "op_Equality" 
                                      || one.Member.Name == "op_Inequality" 
                =>
                // if this typing is speculative, then we should not do final typeng.
                // It prevent change some types.
                if (this.Speculative)
                  result
                else match (try_type (one, final = true)) 
                {
                  | TExpr.Call (_func, _parms, _) as _tCall =>
                    def call = this.DtKind.filtering_expression;
                    // VladD2: This is a hack! 
                    // Copy original TExpr.Call. We should safe it for next speculative typing 
                    // processes (delayed typing).
                    def copy = TExpr.Call(call.func, call.parms, call.is_tail);
                    copy.ty = call.ty;
                    // Set copy to filter
                    this.DtKind.filtering_expression = copy;
                    // This change source TExpr.Call wich been made while parsing.
                    // TODO: This is a dirty hack. We mast remove it.
                    call.parms = _parms;

                    one.UsedLastTime = true;
                    result

                  | e => 
                    _ = e;
                    //assert2(false);
                    overloads
                }

              // This is important -- we only drop the clearly evil
              // solutions. We leave the less general ones (dropped by 
              // GetBestOverloads), as it is possible we will need them 
              // later.
              //
              // However we still mark only the best overloads in case we want
              // an error message later.
              | lst => 
                foreach (o in lst)
                  o.UsedLastTime = true;
                ok 
            }
        }
      }


      LookupOperatorIn (bound : MType, name : string) : list [OverloadPossibility]
      {
        mutable res = [];
        
        def loop (ti : TypeInfo) {
          foreach (meth is IMethod in ti.LookupMember (name))
            when (meth.IsStatic)
              res = typer.ConstructMethodOverload (ti, meth) + res;
          match (ti.GetTydecl ()) {
            | TypeDeclaration.Interface =>
              loop (InternalType.Object_tc)
            | _ =>
              Option.Iter (ti.SuperClass (), loop)
          }
        }

        match (bound) {
          | MType.Class (ti, _) =>
            loop (ti);
            res
          | _ => assert (false)
        }
      }


      LookupOperator (t : TyVar, name : string) : option [list [OverloadPossibility]]
      {
        assert (name != null);
        if (t == null)
          None ()
        else {
          match (t.AnyHint) {
            // This is kind of ugly special case, we sometimes claim, the
            // lower bound is System.Object in cases we don't really 
            // think this will be the final type. 
            // Therefore, for operators, that cannot be found in System.Object,
            // don't even try. The ugly part, is that it won't work for ==/!=
            | Some (Class (tc, []))
              when tc.Equals (InternalType.Object_tc) && 
                   name != "op_Equality" && name != "op_Inequality" => 
              None ()

            | Some (MType.Class as bound) =>
              Some (LookupOperatorIn (bound, name))

            | Some (MType.Array) =>
              Some (LookupOperatorIn (InternalType.Array, name))

            | Some (MType.TyVarRef (a)) =>
              LookupOperator (a.LowerBound, name)

            | Some (MType.Intersection (lst)) =>
              mutable res = [];
              foreach (MType.Class as t in lst) {
                res = LookupOperatorIn (t, name) + res
              }
              Some (res)

            | Some (MType.Fun (from, to)) =>
              // Ugly thing, class representing function depends on parameters voidness
              match (from.AnyHint) {
                | None when typer.BadnessAllowed > 2 with args = [MType.Void ()] //seem to work somehow
                | Some (MType.Tuple (args))
                | Some (MType.Void) with args = []
                | Some (x) with args = [x] =>
                  def inst = InternalType.GetFunctionType (args.Length);
                  Some (
                    LookupOperatorIn (
                      match (to.AnyHint) {
                        | Some (MType.Void) =>
                          MType.Class (inst.VoidTyCon, args)
                        | None when typer.BadnessAllowed > 2 //seem to work somehow
                        | Some => 
                          MType.Class (inst.TyCon, (args + [to]))
                        | None => 
                          InternalType.Object
                      },
                      name
                    )
                  )
                | _ => Some (LookupOperatorIn (InternalType.Object, name))
              }

            | _ => None ()
          }
        }
      }

      DoResolve () : void
      {
        def solver = typer.solver;
        def messenger = solver.CurrentMessenger;
        match (DtKind) {
          | Kind.MemberAccess (e, name) =>
            // We should not check "expected" in this time.
            // Instead we should try to add implicit type conversion 
            // in the end of delayed overload resolution process.
            // see [End of overload resoluton process] in this file.
            match (typer.TypeMember (e, name, typer.FreshTyVar())) {
              | Some ([]) =>
                ReportError (messenger,
                             $ "there is no member named `$(name)' "
                               "in $(typer.TypeOf (e)) with type $expected");
                SetKind (Kind.Error ())

              | Some (lst) =>
                SetKind (Kind.Overloaded (lst));
                when (DtKind.need_write && !ExpectLValue (false))
                  ReportError (messenger, $"needed writable value, got $lst");

                // restart with more information
                Resolve ()

              | None => {}
            }

          | Kind.Overloaded (overloads) =>
            def expr = DtKind.filtering_expression;
            def o1 =
              if (expr == null) 
              {
                def res1 = OverloadPossibility.OnlyPossible (overloads, expected, typer);
                def isAllOverloadsHaveSameArgCnt (overloads)
                {
                  assert (overloads.Length > 1);

                  def cntArgsForEachOverload = overloads.Map(arg =>
                    match (arg.Type.Hint)
                    {
                      | Some(MType.Fun(MType.Tuple(lst), _)) => lst.Length
                      | Some(MType.Fun(MType.Void, _))       => 0
                      | Some(MType.Fun)                      => 1
                      | _ => 0
                    });

                  def argsCnt = cntArgsForEachOverload.Tail.Fold (
                    cntArgsForEachOverload.Head, (arg, prev) => if (arg == prev) arg else -1);

                  argsCnt >= 0
                }

                def res2 = if (res1.Length > 1 && isAllOverloadsHaveSameArgCnt(res1))
                    typer.GetBestOverloads (res1);
                  else if (res1.Length > 1) RemoveExtensionMethods (res1)
                  else res1;

                res2
              }
              else if (typer.Expect (expected, expr.func.Type, "overloaded function call"))
                ResolveOverload (overloads, expr.parms, expr.Type)
              else [];

            when (o1.Length != overloads.Length || o1.Length == 1)
              match (o1) 
              {
                | [] => SetKind (Kind.Error ())
                | [one] => 
                  // [End of overload resoluton process]
                  // Add implicit cast if needed.
                  def expr1 = one.Compile();
                  def expr2 = typer.TryAddCastTo(expr1, expected);
                  SetKind(Kind.Resolved(expr2 ?? expr1))

                | lst => SetKind (Kind.Overloaded (lst))
              }

          | Kind.OverloadedOperator (overloads, t1, t2, name, env, seen) =>
            def not_seen (l) { 
              | None with l = []
              | Some (l) =>
                l.Filter ( fun (x) { !seen.Contains (x) } );
            }
            def new_operators = not_seen (LookupOperator (t1, name)) + not_seen (LookupOperator (t2, name));
            def seen = new_operators + seen;
            def added = 
              match (new_operators) {
                | lst when lst != [] =>
                  def lst = OverloadPossibility.Unique (overloads + lst);
                  if (lst == overloads)
                    false
                  else
                  {
                    SetKind (Kind.OverloadedOperator (lst, t1, t2, name, env, seen));
                    Resolve ();
                    true
                  }
                | _ => false
              }
            unless (added)
            {
                def args = if (t2 == null) 1 else 2;
                def hints = (if (t1.Hint.IsSome) 1 else 0) + (if (t2 != null && t2.Hint.IsSome) 1 else 0);

                def expr = DtKind.filtering_expression;
                def o1 =
                  if (expr == null) {
                    RemoveExtensionMethods (OverloadPossibility.OnlyPossible (overloads, expected, typer))
                  } else {
                    if (typer.Expect (expected, expr.func.Type, 
                                        "overloaded function call"))
                      match (overloads) {
                        | [one] when hints == 0 && typer.BadnessAllowed < 1 =>
                          [one] //don't call ResolveOverload early, as it can add wrong hints
                        | _ => ResolveOverload (overloads, expr.parms, expr.Type)
                      }
                    else
                      []
                  }

                when (o1.Length != overloads.Length || o1.Length == 1)
                  match (o1) {
                    | [one] when hints == args
                              || hints > 0 && typer.BadnessAllowed > 0
                              || typer.BadnessAllowed > 1 =>
                      when (expr != null) //ResolveOverload maybe wasn't called, but it should be to set stuff in expr
                        _ = ResolveOverload (overloads, expr.parms, expr.Type);
                      SetKind (Kind.Resolved (one.Compile ()))

                    | lst =>
                      SetKind (Kind.OverloadedOperator (lst, t1, t2, name, env, seen));
                  }
              }

          | Kind.Operator (t1, t2, name, env) =>
            def operators = {
              def globals = env.LookupSymbolExt ([name], typer.current_type);
              mutable res = [];
              foreach ((ti, meth) in globals)
                when (meth.IsStatic)
                  res = typer.ConstructMethodOverload (ti, meth :> IMethod) + res;
              when (LookupOperator (t1, name) is Some (lst))
                res = lst + res;
              when (LookupOperator (t2, name) is Some (lst))
                res = lst + res;
              res = OverloadPossibility.Unique (res);
              res
            }
            SetKind (Kind.OverloadedOperator (operators, t1, t2, name, env, operators));
            Resolve ()
            
          | Kind.Resolved (expr) =>
            unless (typer.Expect (expected, expr.Type, "already resolved overload"))
              SetKind (Kind.Error ())

          | Kind.Macro (action) =>
            Util.locate (Location,
              match (action.Resolve (false)) {
                | Some (expr) =>
                  if (typer.Expect (expected, expr.Type, $ "result of $action execution"))
                    SetKind (Kind.Resolved (expr))
                  else
                    SetKind (Kind.Error ())

                | None => {}
              })

          | Kind.Error => {}
        }
      }

#if DEBUG
      static mutable _speculativeOverloadStack : list[OverloadPossibility] = [];
#endif //DEBUG
      [Accessor] mutable _speculative : bool;

      public Resolve (speculative = false) : void
      {
        Util.locate (Location, 
        {
          def old_speculative = _speculative;
          _speculative = _speculative || speculative;
          def tmp = typer.local_context;
          try 
          {
            typer.local_context = local_context;
            DoResolve ();
          } 
          finally 
          {
            typer.local_context = tmp;
            _speculative = old_speculative;
          }
        })
      }
    }
  }
}
