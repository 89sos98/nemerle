using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;
using Nemerle.Imperative;

using LRPEGCC.GrammarCreator;

namespace LRPEGCC
{
  macro Grammar (_rules : Token)
  syntax ("grammar", _rules)
  {
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
      | e is GrammarException =>
        def loc = if(e.Location != Location.Default) e.Location else tb.Location;
        Message.Error(loc,  e.Message);
      | e is Exception =>
        //assert2(false, e.ToString());
        Message.Error(tb.Location,  $"Exception $e");
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      def (parsedGrammar, grammar) = CreateGrammar(typer, tb, startRule, rules);
        
      def compiler = RuleCompiler(typer);

      def tyParam = 
        match (grammar.GetRule(grammar.StartRuleName))
        {
          | Rule.Capture(Handler(retType = RuleType.NType(ty)), _) => ty
          | _ => 
            Message.Error(tb.Location,  "Start rule must be a capture rule");
            <[ object ]>
        };
        
      
      foreach (name in parsedGrammar.Names)
        MakeGotoInfos(name, parsedGrammar, tb, typer);

      foreach (name in grammar.Names)
      {
        def rule = grammar.GetRule(name);

        CheckRuleMethodHandler(name, grammar, tb, typer);

        def body          = if (typer.Manager.IsIntelliSenseMode) <[ _ = pos; _ = text ]>
                            else compiler.CompileRule(rule, grammar);

        def method =
          match (rule)
          {
            | Rule.Capture(Handler(retType = RuleType.NType(ty)), _) =>
              <[decl:
                private $(compiler.DecorateRuleName(name.Id) : dyn)(pos : int, result : ref Nemerle.Peg.VToken[$ty], text : string) : int
                {
                  mutable c : char;
                  _ = c; // eliminate wornint "a local value c was never used"
                  $body;
                }
              ]>

            | Rule.Capture as c => 
              Message.Error($"PEG implementation error. Wrong Capture '$(c)'");
              <[decl:private $(compiler.DecorateRuleName(name.Id) : dyn)() : void {}]>

            | _ =>
              <[decl:
                private $(compiler.DecorateRuleName(name.Id) : dyn)(pos : int, text : string) : int
                {
                  mutable c : char;
                  _ = c; // eliminate wornint "a local value c was never used"
                  $body;
                }
              ]>
          };

        _ = tb.DefineWithSource(method);

        //create parse method for single capture rule
        unless (name.Equals(grammar.StartRuleName))
        {
          match (rule)
          {
            | Rule.Capture(Handler(name, _, NType(retType)), _) => CreateSimpleParseMethod(name, retType, compiler, tb);
            | Rule.Capture => assert2(false);
            | _ => ();
          }
        }
      }

      CreateStartParseMethods(grammar.StartRuleName.Id, tyParam, compiler, tb);

      tb.Define(<[decl:
        private mutable _maxRollbackPos : int;
      ]>);

      tb.Define(<[decl:
        public MaxRollbackPos : int
        {
          get { _maxRollbackPos }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        private SetMaxRollbackPos(pos : int) : void
        {
          when (pos > _maxRollbackPos)
          {
            _maxRollbackPos = pos;
          }
        }
      ]>);
    }

    private CreateStartParseMethods(startRuleName : string, tyParam : PExpr, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      tb.Define(<[decl: mutable _parsingSource : Nemerle.Peg.SourceSnapshot; ]>);
      tb.Define(<[decl:
        public ParsingSource : Nemerle.Peg.SourceSnapshot
        {
          get { _parsingSource }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse(text : string) : int * $tyParam
        {
          TryParse(Nemerle.Peg.SourceSnapshot(text))
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse([Nemerle.Assertions.NotNull] source : Nemerle.Peg.SourceSnapshot) : int * $tyParam
        {
          _parsingSource = source;

          mutable result : Nemerle.Peg.VToken[$tyParam];
          def pos = $(compiler.DecorateRuleName(startRuleName) : dyn)(0, ref result, _parsingSource.Text);

          (pos, result.Value)
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public Parse(text : string) : option[$tyParam]
        {
          def (pos, res) = TryParse(text);
          
          if (pos < 0) None() else Some(res)
        }
      ]>);
      _ = tb.DefineWithSource(<[decl:
        public Parse(source : Nemerle.Peg.SourceSnapshot) : option[$tyParam]
        {
          def (pos, res) = TryParse(source);
          
          if (pos < 0) None() else Some(res)
        }
      ]>);
    }

    private static GetGotoMap(tb : TypeBuilder) : Hashtable[Location, Location]
    {
      mutable gotoMap = tb.UserData["GoToInfoMap"] :> Hashtable[Location, Location];
      
      when (gotoMap == null)
      {
        gotoMap = Hashtable();
        tb.UserData["GoToInfoMap"] = gotoMap;
      }
      gotoMap
    }

    private MakeGotoInfos(ruleName : RuleRef, grammar : Grammar, tb : TypeBuilder, typer : Typer) : void
    {
      def rule = grammar.GetRule(ruleName);
      def gotoMap = GetGotoMap(tb);
      def getRuleLocation(ruleRef : RuleRef) : Location
      {
        match (grammar.GetRule(ruleRef))
        {
          | Rule.Capture   (Handler(name = name), _)
          | ExtensionPoint (name = name) => name.Location
          | _                            => Location.Default
        }
      }
      def makeGotoRuleDef(r : Rule) : void
      {
        | Choice(rules)                       => foreach (r in rules) makeGotoRuleDef(r)
        | Sequence(rules)                     => foreach (r in rules) makeGotoRuleDef(r)
        | Call(name)                          => gotoMap[name.Location] = getRuleLocation(name)
        | RepeatMin(_, rule)                  => makeGotoRuleDef(rule)
        | RepeatMinMax(_, _, rule)            => makeGotoRuleDef(rule)
        | Chars                               => ()
        | Not(rule)                           => makeGotoRuleDef(rule)
        | And(rule)                           => makeGotoRuleDef(rule)
        | Capture(Handler(name, _, _), rule)  => gotoMap[name.Location] = getRuleLocation(name); makeGotoRuleDef(rule)
        | Capture(_, rule)                    => makeGotoRuleDef(rule)
        | ExtensionPoint                      => ()
      }

      when (typer.Manager.IsIntelliSenseMode)
        match (rule)
        { // skip top capture...
          | Capture(_, rule) => makeGotoRuleDef(rule);
          | _                => makeGotoRuleDef(rule);
        }
    }

    private CheckRuleMethodHandler(ruleName : RuleRef, grammar : Grammar, tb : TypeBuilder, typer : Typer) : void
    {
      def gotoMap = GetGotoMap(tb);
      def rule = grammar.GetRule(ruleName);
      def mems = tb.GetParsedMembers(true).Filter(m => m.Name == ruleName.Id);

      def ruleTypeToNType(_ : RuleType)
      {
        | Chars        => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Peg.NToken", 0), []);
        | NType(ty)    => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Peg.VToken", 1), [typer.BindFixedType(ty)])
        | List(ty)     => FixedType.Class(typer.Manager.LookupTypeInfo("System.Collections.Generic.List", 1), [ruleTypeToNType(ty)])
        | Option(ty)   => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Core.option", 1), [ruleTypeToNType(ty)])
        | Tuple(types) => FixedType.Tuple(types.Map(ruleTypeToNType))
        | None         => throw ArgumentException();
      }
      match (rule)
      {   // Capture with defined type. User must define handler for it!
        | Rule.Capture(Handler(name, argType, NType(ty)), _) =>
          def tTy     = typer.BindFixedType(ty);
          def methods = mems.MapFiltered(_ is ClassMember.Function, _ :> ClassMember.Function);
          def types   = match (argType)
          {
            | Tuple(types) => types.Map(ruleTypeToNType);
            | ty           => [ruleTypeToNType(ty)];
          }

          def errorMsg(ruleName, types, tTy)
          {
            //assert2(false);
            $<#You need define method-handler for "$ruleName" rule with signature: $ruleName(_ : ..$(types; ", _ : ")) : $tTy#>
          }
          match (methods)
          {
            | [m] => 
              when (typer.Manager.IsIntelliSenseMode)
              {
                gotoMap[name.Location]  = m.NameLocation;
                gotoMap[m.NameLocation] = name.Location;
              }

              def parms = m.header.Parameters;
              if (parms.Length == types.Length)
              {
                foreach ((need, p) in types.ZipLazy(parms))
                {
                  def real = typer.BindFixedType(p.Type);

                  unless (need.TryUnify(real))
                  {
                    //assert2(false);
                    Message.Error(p.Location, $<#The parameter "$(p.Name)" has wrong type $real (need type $need).#>);
                    Message.Error(p.Location, errorMsg(ruleName, types, tTy));
                    break;
                  }
                }
              }
              else
                Message.Error(m.Location, $<#The method-handler of rule "$ruleName" must have $(types.Length) parameters. $(errorMsg(ruleName, types, tTy))#>)

            | m :: _ => Message.Error(m.Location, "Overloading not supported for rule method-handler");
            | []     => Message.Error(ty.Location, errorMsg(ruleName, types, tTy));
          }
          
        | _ => ()
      }
    }

    private CreateSimpleParseMethod(ruleName : RuleRef, ty : PExpr, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      def methodName = "ParseRule_" + ruleName.Id;

      def parseMethod1 = <[decl:
        public $(methodName : dyn)(startPos : int, text : string) : option[$ty]
        {
          mutable result : Nemerle.Peg.VToken[$ty];

          def pos = $(compiler.DecorateRuleName(ruleName.Id) : dyn)(startPos, ref result, text);

          if (pos < 0) 
            None() 
          else 
            Some(result.Value)
        }
      ]>;

      def parseMethod2 = <[decl:
        public $(methodName : dyn)(text : string) : option[$ty]
        {
          $(methodName : dyn)(0, text)
        }
      ]>;

      _ = tb.DefineWithSource(parseMethod1);
      _ = tb.DefineWithSource(parseMethod2);
    }
  }
}
