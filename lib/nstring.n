/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
 
namespace Nemerle.Utility
{
  public module NString {

    public Split (sep : array <char>, str : string) : list <string> {
      mutable res <- [];
      mutable seppos <- sep.Length - 1;
      mutable last <- str.Length;
      for (mutable i <- str.Length - 1; i >= 0; --i) {
        if (str[i] == sep[seppos]) {
          --seppos;
          when (seppos < 0) {
            seppos <- sep.Length - 1;
            res <- str.Substring (i + sep.Length, last - i - sep.Length) :: res;
            last <- i;
          }
        }
        else
          seppos <- sep.Length - 1;
      };
      str.Substring (0, last) :: res
    }
    
    
    /** Concatenates strings from the list, inserting given separator
        between them
    */
    public Concat (sep : string, l : list <string>) : string {
      def loop (l : list<string>, acc : System.Text.StringBuilder) {
        match (l) {
          | [x] => acc.Append (x)
          | x :: xs => loop (xs, acc.Append (x + sep))
          | [] => acc
        }
      };
      loop (l, System.Text.StringBuilder ("")).ToString ()
    }

    /** Calls given function on elements of given list, appending given
        separator to string builder between those calls
    */
    public SeparatedCalls<'a> (sep : string, l : list <'a>, f : 'a -> void,
                       acc : System.Text.StringBuilder) : void {
      def loop (l) {
        | [x] => f (x)
        | x :: xs => f (x); ignore (acc.Append (sep)); loop (xs)
        | [] => ()
      };
      loop (l)
    }
  }
}
