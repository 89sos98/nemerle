<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Don't Panic! - Nemerle Basics Explained</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This tutorial will describe basics of programming in Nemerle.
        We assume the reader is familiar with C#, Java or C++.
      </p>
    </body>
  </section>


  <section id="simple">
    <title>Simple examples</title>
    <body>
      <p>
        This section lists simple example that look almost the same as
        in C# (or Java, or C++).
      </p>
    </body>
    <subsection id="hello">
      <title>The very-first example</title>
      <body>
        <external-code src="tutorial.n" part="HELLO" />
        <p>
          As you can see the only difference between Nemerle and C#
          version of this program is that we write method's return type
          at the right, after colon. There are some reasons to do it this
          way, we will explain them later.
        </p>
        <p>
          To run this example:
        </p>
        <ul>
          <li>
            write it with your favorite text editor and save it in 
            <file>hello.n</file>
          </li>
          <li>
            run the Nemerle compiler by typing <tt>ncc hello.n</tt>
          </li>
          <li>
            the output goes to <file>out.exe</file>
          </li>
          <li>
            run it by typing <tt>out</tt> or <tt>./out.exe</tt> depending
            on your OS
          </li>
        </ul>
        <p class="not-csharp">
          For people unfamiliar with C#: the entry point of execution 
          is the static <tt>Main</tt> method in some class. 
          <tt>System.Console.WriteLine</tt> is a call to a function
          from the .NET framework.
        </p>
      </body>
    </subsection>
    <subsection id="adder">
      <title>The adder</title>
      <body>
        <p>
          We will now write a very simple program to read and add two numbers.
        </p>
        <external-code src="tutorial.n" part="ADDER1" />
        <p>
          The <tt>using</tt> declaration imports identifiers from
          specified namespace, so they can be used without prefix.
          Unlike in C# it can also import members from classes, not only
          from namespaces. For example:
        </p>
        <external-code src="tutorial.n" part="ADDER2" />
        <p>
          As you can see for both lines we first read them and then
          convert to integers. We can factor this into a method:
        </p>
        <external-code src="tutorial.n" part="ADDER3" />        
        <p>
          The method definition looks the way we would expect from
          <tt>Main</tt> example. However in <tt>Main</tt> itself we
          <b>define two values</b>: <tt>x</tt> and <tt>y</tt>. This is done
          using the <tt>def</tt> keyword. As you can see we do not write
          type of variable at the place of definition. The compiler sees
          that <tt>ReadInteger</tt> returns <tt>int</tt> and therefore
          type of <tt>x</tt> has to also be <tt>int</tt>. This is called
          <b>type inference</b>.
        </p>
        <p>
          In this example we see no gain from using <tt>def</tt> instead
          of <tt>int</tt> as you would do in C# (both are 3 characters long :-).
          However in most cases type names are far longer:
        </p>
<code>
FooBarQuxxFactory fact = new FooBarQuxxFactory (); // C#
def fact = FooBarQuxxFactory (); // Nemerle
</code>
        <p>
          As you can see we also do not use the <tt>new</tt> keyword.
        </p>
      </body>
    </subsection>
    <subsection id="read-file">
      <title>Counting lines in file</title>
      <body>
        <external-code src="tutorial.n" part="LINECOUNTER1" />              
        <p>
          There are few remarkable things about this example. First one
          is the very important difference between lines marked (1) and
          (2).
        </p>
        <p>
          In (1) we define <b>immutable value</b> <tt>sr</tt>. Immutable means
          it cannot be changed once it is defined. This may first seem
          odd, but it is quite often that variables are never changed,
          once created. The <tt>def</tt> statement is there to mark this 
          intent.
        </p>
        <p>
          In (2) we define <b>mutable value</b>. This is the same thing as
          variable in C#, It has to be initialized before use and can be
          changed later. The assignment operator in Nemerle is called
          <tt>=</tt>, it works much like in C#. We see its use in (4).
        </p>
        <p>
          In (3) we see the <b><tt>while</tt> loop</b>. It works
          much like in C#. We also have <tt>do ... while</tt> loops
          in Nemerle.
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="functional-style">
    <title>Functional examples</title>
    <body>
      <p>
        This section will introduce some more functional features
        of Nemerle.
      </p>
      <p>
        <b>Functional programming (FP)</b> is style in which you do not
        modify state of the machine with instructions, but rather evaluate
        functions yielding new and new values. That is entire program is
        just one big expression. In purely functional language (Haskell
        being main example) you cannot modify any objects once they are
        created (there is no assignment operator, like <tt>=</tt>
        in Nemerle). There are no loops, just recursive functions.
      </p>
      <p>
        Nemerle does not force you to use FP. However you can use it
	whenever you find it necessary. Some algorithms have very natural
        representation when written in functional style -- for example
        functional languages are very good at manipulation of tree-like
        data structures (like XML, in fact XSLT can be thought of as a
        functional language).
      </p>
      <p>
        However at the beginning we will use functional style to write
        simple programs, that could be written in imperative style
        without much problems.
      </p>
      <p>
        We will be using terms <b>method</b> and <b>function</b>
        interchangeably.
      </p>
    </body>
    
    <subsection id="read-file-half-func">
      <title>Rewriting line counter without the loop</title>
      <body>
        <p>
          We will now rewrite our <a ref="#read-file">previous example</a>
          not to use loops, just a recursive function. It will get longer,
          but we will fix that soon.
        </p>
        <external-code src="tutorial.n" part="LINECOUNTER2" />                      
        <p>
          In (1) we define <b>nested method</b> called <tt>read_lines</tt>
          inside the <tt>Main</tt> method. The method is there to
          simulate the <tt>while</tt> loop from our previous example.
          It takes no parameters and returns void value.
        </p>
        <p>
          (2) If line wasn't <tt>null</tt> (i.e. it was not the last
          line), (3) we write the line we just read, (4) increase the
          line number, and finally (5) call ourself to read rest of the
          lines. The <tt>when</tt> expression is explained below.
        </p>
        <p>
          Next (6) we call <tt>read_lines</tt> for the first time,
          and finally (7) print the line count.
        </p>
        <p>
          The <tt>read_lines</tt> will get called as many times as there
          are lines in the file. As you can see this is the same as the
          <tt>while</tt> loop, just expressed in a slightly different way.
          It is very important to grok this concept of writing loops
          as recursion, in order to program functionally in Nemerle.
        </p>
        <p>
          If you are concerned about performance of this form of writing
          loops -- fear you not. When function body ends with call
          to another function -- no new stack frame is created. It is
          called <b>tail call</b>.  Thanks to it the example above is as
          efficient as the <tt>while</tt> loop we seen before.
        </p>
        <p>
          In Nemerle the <tt>if</tt> expression always need to have the
          <tt>else</tt> clause. It's done this way to avoid stupid bugs
          with dangling-else:
        </p>
<code>
// C#, misleading indentation hides real code meaning
if (foo)
   if (bar)
     m1 ();
else
   m2 ();
</code>
        <p>
          If you do not want the <tt>else</tt> clause, use
          <tt>when</tt> expression, as seen in the example. There is
          also <tt>unless</tt> expression, equivalent to <tt>when</tt>
          with condition negated.
        </p>
      </body>
    </subsection>

    <subsection id="read-file-func">
      <title>Rewriting line counter without mutable values</title>
      <body>
        <p>
          Our <a ref="#read-file-half-func">previous aim</a> of rewriting 
          line counter removed the loop and one mutable value. However
          one mutable value has left, so we cannot say the example is written
          functionally. We will now kill it.
        </p>
        <external-code src="tutorial.n" part="LINECOUNTER3" />        
        <p>
          In (1) we again define nested method called <tt>read_lines</tt>.
          However this time it takes one integer parameter -- the current
          line number.  It returns number of lines in entire file.
        </p>
        <p>
          (2) If line we just read is <tt>null</tt> (that was last line),
          we (3) return the current line number as number of lines in
          entire file. As you can see there is <b>no <tt>return</tt>
          statement</b>. The return value of method is its last
          expression.
        </p>
        <p>
          (4) Otherwise (it was not last line) we write the line we just
          read. Next (5) we call ourself to read the next line. We need
          to increase line number, since it is next line what we will
          be reading. Note that as a return value from this invocation
          of <tt>read_lines</tt> we return what the next invocation of
          <tt>read_lines</tt> returned. It in turn returns what the next
          invocation returned and so on, until, at the end of file, we reach
          (3), and final line count is returned through each invocation
          of <tt>read_lines</tt>.
        </p>
        <p>
          In (6) we call the <tt>read_lines</tt> nested method, with
          initial line number of 0 to read the file and print
          out line count.
        </p>
      </body>
    </subsection>
    
    <subsection id="type-inference">
      <title>Type inference</title>
      <body>
        <p>
          We have already seen type inference used to guess types of
          values defined with <tt>def</tt> or <tt>mutable</tt>. It can be
          also used to guess type of function parameters and return type.
          Try removing the <tt>: int</tt> constraints from line marked (1)
          in our <a ref="#read-file-func">previous example</a>.
        </p>
        <p>
          Type inference only works for nested functions. Type annotations
          are required in top-level methods (that is methods defined
          in classes, not in other methods). This is design decision,
          that is here not to change external interfaces by accident.
        </p>
        <p>
          It is sometimes quote hard to tell the type of parameter, from just 
          looking how it is used. For example consider:
        </p>
        <external-code src="tutorial.n" part="INFERENCE" />                
        <p>
          When compiling the <tt>f</tt> method we cannot tell if
          <tt>x</tt> is a string or array or something else. Nevertheless, 
          we can tell it later (looking at <tt>f</tt> invocation) and Nemerle
          type inference engine does it. 
        </p>              
        <p>
          If function with incomplete type information was not used or 
          its type waw ambiguous, compiler would refuse to compile it. 
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="more">
    <title>More info</title>
    <body>
      <p>
        Now, once you read through all this, please move to
        <a ref="grokking.html">Grokking Nemerle</a> tutorial,
        that is much more complete. You can also have a look
        at <a ref="reference.html">The Reference Manual</a>
        if you are tough.
      </p>
    </body>
  </section>
   <!--
     Describe:
       - variants and matching
       - functions as first class citizens
       - namespace aliases
       - continuation monad
   -->
  

    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
