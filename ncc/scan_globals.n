(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Collections;


namespace Nemerle.Compiler {

(*
pass 1:
  Walk through Top_decls, set env field for all global symbols, register
  all global symbols. Set environments for global values. Return list of 
  Type_decls.
*)

class Scan_globals
  {
    fun run (decls : list (Top_decl)) : list (Type_decl) =
      letfun in_prefix (env : Env, n : string) : Env =
        let env' = env#copy() in {
          env'#current_namespace <- env#current_namespace + n + ".";
          env'
        }
      in
      letfun make_member(d : Type_decl) : Class_member =
        let mem = M_type(d) in {
          mem#name <- d#name;
          mem#loc <- d#loc;
          mem#modifiers <- d#modifiers;
          mem#env <- d#env;
          mem#id <- d#id;
          mem
        }
      in
      letfun do_type(env : Env, t : Type_decl) : Env {
        t#env <- env;
        Env.add_global(env#current_namespace, make_member(t));
        in_prefix(env, t#name)
      } and do_decl(env : Env, d : Class_member) : void {
        if env == null then Util.ice() else
        d#env <- env;
        match d with [
          | M_type => ()
          | _ => Env.add_global(env#current_namespace, d)
        ]
      } in
      letfun loop (state : Env * list (Type_decl), decl : Top_decl) : Env * list (Type_decl) =
        let (?env, ?acc) = state in
        match decl with [
          | TD_namespace (?n, ?d) =>
            let env' = in_prefix(env, n) in
            let (_, ?acc) = List.fold_left (loop, (env', acc), d) in
            (env, acc)
          | TD_open (?n) =>
            let env' = env#copy() in {
              env'#add_open(n);
              (env', acc)
            }
          | TD_namespace_alias (?s, ?l) =>
            let env' = env#copy() in {
              env'#add_namespace_alias(s, l);
              (env', acc)
            }
          | TD_type (?d) =>
            {
// Message.error("decl walk");
              Treeutil.decl_walk(do_type, do_decl, env, List.cons(d));
              (env, Cons(d, acc))
            }
        ]
      in 
      let env = Env() in {
        env#add_open("Nemerle.Core");
        let (_, ?r) = List.fold_left (loop, (env, Nil()), decls) 
        in List.rev(r)
      };
  }



} // N.C
