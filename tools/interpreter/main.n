using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility.NString;
using SC = System.Console;
using System.Text;
using System.Text.RegularExpressions.Regex;

module MainClass
{
  Main () : void {
    def print_help () : void  {
      SC.WriteLine ("help\t-\tprint this help");
      SC.WriteLine ("ref\t-\tlink specified assembly\n"
                    "\t\t(ex. ref Nemerle.dll, Nemerle.Compiler.dll)");
      SC.WriteLine ("using\t-\tuse specified namespaces and/or aliases\n"
                    "\t\t(ex. using System, SC=System.Console)");
    }

    def print_welcome () : void {
      SC.WriteLine ("Welcome to Nemerle interpreter.\n");
      SC.WriteLine ("Please enter expressions appended with \";;\".");
      SC.WriteLine ("Built-in commands must be entered on a separate line,");
      SC.WriteLine ("their list is available via \"help;;\"\n");
    }
   
    print_welcome ();

    def e = Evaluator ();

    def readinput (refr : list [string], ns : list [option [string] * string],
                   code : string, prompt : string) : void {
      SC.Write (prompt);
      def line = SC.ReadLine ();
      match (line) {
        | null => ()
        | _ => 
          regexp match (line) {
            | @"^\s*$" => readinput (refr, ns, code, prompt)
            | @"^\s*help\s*(\(\))*[;\s]*;;\s*$" => 
              print_help ();
              readinput (refr, ns, code, "- ")
            | @"^\s*using\s+(?<n>(\w+\s*=\s*){0,1}\w+(\.\w+)*(\s*,\s*(\w+\s*=\s*){0,1}\w+(\.\w+)*)*)[;\s]*;;\s*$" =>
              def tmpns = Split (Replace (n, @"\s", ""), array [',']);
	      def newns = FoldLeft (tmpns, [], fun (x, acc) {
		match (Split (x, array ['='])) {
                  | [h] => (None (), h) :: acc
		  | [h, t] => (Some (h), t) :: acc
		  | _ => assert (false)
		}
	      });
              SC.WriteLine ("Now using " + n);
              readinput (refr, newns + ns, code, "- ")
            | @"^\s*ref\s+(?<r>\w+(\.\w+)*(\s*,\s*(\w+(\.\w+)*))*)[;\s]*;;\s*$" =>
              SC.WriteLine ("Added " + r + " for linking.");
              readinput (Split (Replace (r, @"\s", ""), array [',']) +
                         refr, ns, code, "- ")
            | _ =>  { 
              def l = line.TrimEnd ();
              if (l.EndsWith (";;")) {
                try { 
                  def (nmnvts) = e.Eval (refr, ns, code + 
		                         l.TrimEnd (array [';',' ','\t']));
		  Iter (nmnvts, fun (x) {
                    def (newvar, mut, name, val, ty) = x;
		    when (newvar) 
                      match ((mut, val, ty)) {
			| (false, null, _) =>
			  SC.WriteLine ($"def $name : $ty")
			| (_, null, _) =>
			  SC.WriteLine ($"mutable $name : $ty")
			| (_, _, <[ $_ -> $_ ]>) =>
			  SC.WriteLine ($"def $name : $ty")
                        | (false, _, _) => 
			  SC.WriteLine ($"def $name = $val : $ty")
                        | _ => 
			  SC.WriteLine ($"mutable $name = $val : $ty")
		    }
		  })
                } 
                catch {
                  | e is System.Exception =>
                    unless (Nemerle.Compiler.Message.SeenError) {
                      SC.WriteLine (e.Message + e.StackTrace);
                      SC.WriteLine (e.ToString ())
                    }
                } 
                readinput (refr, ns, "", "- ") 
              }
              else { 
                readinput (refr, ns, code + line + " ", "= ") 
              }
            }
          }
      }
    }

    readinput ([System.Reflection.Assembly.
                GetAssembly (e.GetType ()).CodeBase], [], "", "- ")
  }
}

