using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

public class Evaluator
{
  public static mutable locals : list [bool * string * PExpr];
  public static mutable code : string;
  public static mutable prevvals : list [object];
  public static mutable ns : list [option [string] * list [string]];
 
  public this () {
    Evaluator.locals = [];
    Evaluator.prevvals = [];
    Message.InitOutput (System.Console.Out);         

    Options.Sources = [""];
    Options.CompileToMemory = true;
    Options.ProgressBar = false;
    Options.IgnoreConfusion = true;
    WarningOptions.Disable (10005); // ignore computed value
    WarningOptions.Disable (168);   // unused variable

    Passes.LexingPipeline = fun (_) { null };
    Passes.ParsingPipeline = fun (_) { [null] };
    Passes.ScanningPipeline = DoTheStuff;
  }

  public Eval (refr: list [string], ns: list [option [string] * string],
               code: string) : list [bool * bool * string * object * PExpr] {
    Evaluator.code = code;
    Evaluator.ns = List.FoldLeft (ns, [], fun (x, acc) { 
      def (x1, x2) = x;
      (x1, NString.Split (x2, array ['.'])) :: acc 
    });
    
    Options.ReferencedLibraries = System.Reflection.Assembly.
                                  GetAssembly(Evaluator.GetType()).
				  CodeBase :: refr;
    
    def prevlocals = Evaluator.locals;

    Passes.Run ();
    
    def ass = Passes.GeneratedAssembly;
    def meth = ass.GetTypes()[0].GetMethod ("Run");
    def vals = meth.Invoke (null, null) :> list [object];

    Evaluator.prevvals = List.Rev (vals);
    
    // FIXME: add checks for changing values
    def loop (l1, l2, l3, acc) {
      match ((l1, l2, l3)) {
        | ([], [], []) => acc
	| ((mut, name, ty) :: t1, [], h3 :: t3) => 
	  loop (t1, [], t3, (true, mut, name, h3, ty) :: acc)
	| ((mut, name, ty) :: t1, (prevmut, prevname, prevty) :: t2, 
	  h3 :: t3) => 
	  if (name == prevname)
	    if (name == "it" || (ty.ToString () : string) != 
               (prevty.ToString () : string) || mut != prevmut)
              loop (t1, t2, t3, (true, mut, name, h3, ty) :: acc)
	    else
              loop (t1, t2, t3, (false, mut, name, h3, ty) :: acc)
	  else
	    loop (t1, (prevmut, prevname, prevty) :: t2, t3, 
	         (true, mut, name, h3, ty) :: acc)
        | _ => assert (false, "Error: internal error, please report a bug.")
      }
    }

    loop (Evaluator.locals, prevlocals, vals, [])
  }

  static DoTheStuff (_tdecl : Parsetree.TopDeclaration) : void {
    MacroRegistry.register_macro (StagedMacro ());
    def n = (None (), ["Nemerle", "Core"]) :: 
            (None (), ["Nemerle", "Core", "option"]) :: Evaluator.ns;
    def env = List.FoldLeft (n, GlobalEnv.Empty, fun (x, acc : GlobalEnv) { 
                def (x1, x2) = x;
		match (x1) {
		  | None => acc.AddOpenNamespace (x2, Location.Default)
		  | Some (sname) => acc.AddNamespaceAlias (sname, x2, 
		                                           Location.Default)
		}
              });

    MacroColorizer.PushNewColor (-1, env);

    def cname = Macros.NewSymbol ();
    def tb = GlobalEnv.DefineExact (<[ decl: public class $(cname : name) {
                                             } ]>);
    def body = MainParser.ParseExpr (env, Evaluator.code); 
    
    def whole = inject (body);

    def inits = List.FoldLeft (Evaluator.locals, [], fun (x, acc) {
      def (mut, name, ty) = x;
      match (mut) {
        | false => 
	  <[ def $(name : usesite)  = 
	  Nemerle.Collections.List.Hd (Evaluator.prevvals) :> $ty ]> :: 
          <[ Evaluator.prevvals = 
	  Nemerle.Collections.List.Tl (Evaluator.prevvals) ]> :: acc;
        | _ => 
	  <[ mutable $(name : usesite) = 
	  Nemerle.Collections.List.Hd (Evaluator.prevvals) :> $ty ]> ::
          <[ Evaluator.prevvals = 
	  Nemerle.Collections.List.Tl (Evaluator.prevvals) ]> :: acc; 
      }
    });
    def whole = <[ {.. $(inits + [whole]) } ]>;

//    PrettyPrint.PrintExpr (None (), whole);
    
    tb.Define (<[ decl: public static Run () : list [System.Object] {
                        $whole } ]>);
    tb.Compile ();

    MacroColorizer.PopColor ();
  }

  static inject (body : PExpr) : PExpr {
    match (body) {
      | <[ {..$seq } ]> => 
        def (beg, last) = List.DivideLast (seq);
        def last = 
          match (last) {
            | <[ def $_ = $_ ]> | <[ mutable $_ = $_ ]> 
            | <[ def .. $_ ]> =>
              <[ $last; $("stagedmacro" : usesite) (()) ]>
            | _ => <[ $("stagedmacro" : usesite) ($last) ]>
          }
        <[ {..$ (beg + [last]) } ]>
      | _ => <[ $("stagedmacro" : usesite) ($body) ]>
    }
  }

  class StagedMacro : IMacro 
  {
    public Run (ctx : Typer, val : list [SyntaxElement]) : PExpr {
      match (val) {
        | [SyntaxElement.Expression (expr)] =>
          Evaluator.locals = [];
          
          def l = ctx.GetLocals ();
          def values = <[ $expr : System.Object ]> :: 
                          l.Fold ([], fun (n : Name, loc : LocalValue, acc) {
            regexp match (n.ToString ()) {
              | @"^it$" => acc
              | _ => 
	        Evaluator.locals = (loc.IsMutable, loc.Name, 
                                    PrettyPrint.TyVarToParseTree (loc.Type)) ::
				    Evaluator.locals;
                <[ ($(n : name) : System.Object) ]> :: acc
            }
          });
	  Evaluator.locals = (false, "it", PrettyPrint.TyVarToParseTree 
	                     (ctx.TypeExpr (expr).Type)) :: Evaluator.locals;
          <[ [..$values] ]>
        | _ => Util.ice ()
      }
    }

    public CallTransform (l : list [PExpr]) : list [SyntaxElement]
    { List.Map (l, SyntaxElement.Expression); }
    public SyntaxExtension () : GrammarElement * (list [SyntaxElement] -> 
                                                  list [SyntaxElement])
    { (null, fun (_) { [] }) }
    public IsInherited : bool { get { false } }
    public IsTailRecursionTransparent : bool { get { false } }
    public GetName () : string { "stagedmacro" }
    public GetNamespace () : string { "" }
    public Keywords : list [string] { get { [] } }
    public Usage : Nemerle.MacroUsageAttribute { get { null } }
  }
}
