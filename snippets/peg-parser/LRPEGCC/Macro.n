using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;
using Nemerle.Imperative;

namespace LRPEGCC
{
  macro Grammar (_rules : Token)
  syntax ("grammar", _rules)
  {
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
      | e is GrammarException =>
        def loc = if(e.Location != Location.Default) e.Location else tb.Location;
        Message.Error(loc,  e.Message);
      | e is Exception =>
        //assert2(false, e.ToString());
        Message.Error(tb.Location,  $"Exception $e");
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      def compiler = RuleCompiler(typer, tb);
      def parsedGrammar = Parsing.ParseRules(typer, RuleRef(startRule.Location, startRule.ToString()), rules);
      def typedGrammar  = GrammarTyper.AddArgumentCaptures(parsedGrammar);

      if (typer.Manager.IsIntelliSenseMode)
        IntelliSenseSupport.AddIntelliSenseSupport(parsedGrammar, typer, tb);
      else
        compiler.CompileGrammar(typedGrammar);

      foreach (name in typedGrammar.Names)
        CheckRuleMethodHandler(name, typedGrammar, tb, typer);

      CreateStartParseMethods(parsedGrammar, compiler, typer, tb);
    }

    private CreateStartParseMethods(parsedGrammar : Grammar, compiler : RuleCompiler, typer : Typer, tb : TypeBuilder) : void
    {
      def tyParam =
        match (parsedGrammar.GetRule(parsedGrammar.StartRuleName))
        {
          | Rule.Capture(Handler(retType = RuleType.NType(ty)), _) => ty
          | _ => 
            Message.Error(tb.Location,  "Start rule must be a capture rule");
            <[ object ]>
        };

      tb.Define(<[decl: mutable _parsingSource : Nemerle.Peg.SourceSnapshot; ]>);
      tb.Define(<[decl:
        public ParsingSource : Nemerle.Peg.SourceSnapshot
        {
          get { _parsingSource }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse(text : string) : int * $tyParam
        {
          TryParse(Nemerle.Peg.SourceSnapshot(text))
        }
      ]>);

      if (typer.Manager.IsIntelliSenseMode)
      {
        _ = tb.DefineWithSource(<[decl:
          public TryParse([Nemerle.Assertions.NotNull] source : Nemerle.Peg.SourceSnapshot) : int * $tyParam
          {
            _parsingSource = source;
            mutable res;
            res;
          }
        ]>);
      }
      else
      {
        _ = tb.DefineWithSource(<[decl:
          public TryParse([Nemerle.Assertions.NotNull] source : Nemerle.Peg.SourceSnapshot) : int * $tyParam
          {
            _parsingSource = source;

            mutable result;
            def pos = $(compiler.DecorateRuleName(parsedGrammar.StartRuleName.Id) : dyn)(0, ref result, _parsingSource.Text);

            (pos, result)
          }
        ]>);
      }

      _ = tb.DefineWithSource(<[decl:
        public Parse(text : string) : option[$tyParam]
        {
          def (pos, res) = TryParse(text);

          if (pos < 0) None() else Some(res)
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public Parse(source : Nemerle.Peg.SourceSnapshot) : option[$tyParam]
        {
          def (pos, res) = TryParse(source);

          if (pos < 0) None() else Some(res)
        }
      ]>);

      tb.Define(<[decl:
        private mutable _maxRollbackPos : int;
      ]>);

      tb.Define(<[decl:
        public MaxRollbackPos : int
        {
          get { _maxRollbackPos }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        private SetMaxRollbackPos(pos : int) : void
        {
          when (pos > _maxRollbackPos)
          {
            _maxRollbackPos = pos;
          }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        protected GetText(tok : Nemerle.Peg.NToken) : string
        {
          _parsingSource.Text.Substring(tok.StartPos, tok.EndPos - tok.StartPos)
        }
      ]>);
    }

    private CheckRuleMethodHandler(ruleName : RuleRef, grammar : Grammar, tb : TypeBuilder, typer : Typer) : void
    {
      def gotoMap = IntelliSenseSupport.GetGotoMap(tb);
      def rule = grammar.GetRule(ruleName);
      def mems = tb.GetParsedMembers(true).Filter(m => m.Name == ruleName.Id);

      def ruleTypeToNType(_ : RuleType)
      {
        | Chars        => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Peg.NToken", 0), [])
        | NType(ty)    => typer.BindFixedType(ty)
        | List(ty)     => FixedType.Class(typer.Manager.LookupTypeInfo("System.Collections.Generic.List", 1), [ruleTypeToNType(ty)])
        | Option(ty)   => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Core.option", 1), [ruleTypeToNType(ty)])
        | Tuple(types) => FixedType.Tuple(types.Map(ruleTypeToNType))
        | None         => throw ArgumentException();
      }
      match (rule)
      {   // Capture with defined type. User must define handler for it!
        | Rule.Capture(Handler(name, argType, NType(ty)), _) =>
          def tTy     = typer.BindFixedType(ty);
          def methods = mems.MapFiltered(_ is ClassMember.Function, _ :> ClassMember.Function);
          def types   = match (argType)
          {
            | Tuple(types) => types.Map(ruleTypeToNType);
            | ty           => [ruleTypeToNType(ty)];
          }

          def errorMsg(ruleName, types, tTy)
          {
            //assert2(false);
            $<#You need define method-handler for "$ruleName" rule with signature: $ruleName(_ : ..$(types; ", _ : ")) : $tTy#>
          }
          match (methods)
          {
            | [m] => 
              when (typer.Manager.IsIntelliSenseMode)
              {
                gotoMap[name.Location]  = m.NameLocation;
                gotoMap[m.NameLocation] = name.Location;
              }

              def parms = m.header.Parameters;
              if (parms.Length == types.Length)
              {
                foreach ((need, p) in types.ZipLazy(parms))
                {
                  def real = typer.BindFixedType(p.Type);

                  unless (need.TryUnify(real))
                  {
                    //assert2(false);
                    Message.Error(p.Location, $<#The parameter "$(p.Name)" has wrong type $real (need type $need).#>);
                    Message.Error(p.Location, errorMsg(ruleName, types, tTy));
                    break;
                  }
                }
              }
              else
                Message.Error(m.Location, $<#The method-handler of rule "$ruleName" must have $(types.Length) parameters. $(errorMsg(ruleName, types, tTy))#>)

            | m :: _ => Message.Error(m.Location, "Overloading not supported for rule method-handler");
            | []     => Message.Error(ty.Location, errorMsg(ruleName, types, tTy));
          }
          
        | _ => ()
      }
    }

  }
}

/*
    private CreateSimpleParseMethod(ruleName : RuleRef, ty : PExpr, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      def methodName = "ParseRule_" + ruleName.Id;

      def parseMethod1 = <[decl:
        public $(methodName : dyn)(startPos : int, text : string) : option[$ty]
        {
          mutable result : Nemerle.Peg.VToken[$ty];

          def pos = $(compiler.DecorateRuleName(ruleName.Id) : dyn)(startPos, ref result, text);

          if (pos < 0)
            None()
          else 
            Some(result.Value)
        }
      ]>;

      def parseMethod2 = <[decl:
        public $(methodName : dyn)(text : string) : option[$ty]
        {
          $(methodName : dyn)(0, text)
        }
      ]>;

      _ = tb.DefineWithSource(parseMethod1);
      _ = tb.DefineWithSource(parseMethod2);
    }
*/