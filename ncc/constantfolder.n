/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler.Parsetree;

namespace TT = Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler 
{
  module ConstantFolder
  {
    is_known_operator (name : string) : bool
    {
      | "+"
      | "-"
      | "*"
      | "/"
      | "%"
      | "%^"
      | "%|"
      | "%&"
      | "&&"
      | "||"
      | "!"
      | "~" => true
      | _ => false
    }

    is_flag_enum (t : Tycon) : bool
    {
      t.HasAttribute (InternalType.FlagsAttribute_tc)
    }

    underlaying_enum_type (t : Tycon) : Tycon
    {
      def flds = t.GetFields (BindingFlags.Public %|
                              BindingFlags.NonPublic %|
                              BindingFlags.Instance);
      def res =
        List.FoldLeft (flds, null, fun (elt : IField, acc) {
          assert (acc == null);
          match (elt.GetMemType ()) {
            | TT.T_app (tc, []) => tc
            | _ => assert (false)
          }
        });
      assert (res != null);
      res
    }

    internal FieldValueAsLiteral (field : IField) : option <Literal>
    {
      def decl_type = field.DeclaringType;
      def (enum_ty, field_type) =
        match (decl_type.GetTydecl ()) {
          | TT.TD_enum =>
            (Some (decl_type), underlaying_enum_type (decl_type))
          | _ => 
            match (field.GetMemType ()) {
              | TT.T_app (tc, []) => (None (), tc)
              | _ => assert (false) // shouldn't be literal
            }
        };
      match (NumericType.ByName (field_type.GetFullName ())) {
        | Some (num_ty) =>
          def lit = num_ty.ToLiteral (field.GetValue ());
          match (enum_ty) {
            | Some (tc) =>
              Some (L_enum (lit, tc))
            | None =>
              Some (lit)
          }
        | None =>
          // ice?
          Message.warning ("literal field of unknown type `" + 
                           field_type.GetFullName () + "'");
          None ()
      }
    }

    literal_field_value (env : GlobalEnv, expr : Expr) : Expr
    {
      match (Util.qidl_of_expr (expr)) {
        | Some ((id, name)) =>
          match (name.GetEnv (env).LookupSymbol (id)) {
            | [Sym_type_member (m)] =>
              match (m.GetKind ()) {
                | MK_field (fld) when fld.IsLiteral =>
                  match (FieldValueAsLiteral (fld)) {
                    | Some (lit) => E_literal (expr.loc, lit)
                    | None => expr
                  }
                | _ => expr
              }
            | [] => 
              expr
            | _ => 
            expr
          }
        | None => expr
      }
    }

    literal_of_expr (e : Expr) : option <Literal>
    {
       | E_literal (l) => Some (l)
       | E_typed_expr (TT.E_literal (l)) => Some (l)
       | _ => None ()
    }
    
    fold_unary_operator (name : string, 
                         e1 : Expr, expr : Expr) : Expr
    {
      match (literal_of_expr (e1)) {
        | Some (L_enum (lit, enum_ty)) 
          when name == "~" && is_flag_enum (enum_ty) =>
          def t = Option.UnSome (NumericType.ByLiteral (lit));
          def res = t.Unary (name, t.FromLiteral (lit));
          assert (res != null);
          E_literal (expr.loc, L_enum (t.ToLiteral (res), enum_ty))

        | Some (lit) =>
          match (NumericType.ByLiteral (lit)) {
            | Some (t) =>
              def res = t.Unary (name, t.FromLiteral (lit));
              if (res == null)
                expr
              else
                E_literal (expr.loc, t.ToLiteral (res))
            | None => expr
          }
        | None => expr
      }
    }

    fold_binary_operator (name : string, e1 : Expr, e2 : Expr, 
                          expr : Expr) : Expr
    {
      match ((literal_of_expr (e1), literal_of_expr (e2))) {
        | (Some (l1), Some (l2)) =>
          def (l1, l2, enum_ty) =
            match ((l1, l2)) {
              | (L_enum (l1, t1), L_enum (l2, t2)) 
                when t1.SameAs (t2) && is_flag_enum (t1) =>
                (l1, l2, Some (t1))
              | _ => (l1, l2, None ())
            };
          match ((NumericType.ByLiteral (l1), NumericType.ByLiteral (l2))) {
            | (Some (t1), Some (t2)) when t1 == t2 =>
              def res = t1.Binary (name, t1.FromLiteral (l1), 
                                   t1.FromLiteral (l2));
              def lit = t1.ToLiteral (res);
              if (res != null)
                match ((enum_ty, name)) {
                  | (None, _) => 
                    E_literal (expr.loc, lit)
                  | (Some (t), "%|")
                  | (Some (t), "%&")
                  | (Some (t), "%^") => 
                    E_literal (expr.loc, L_enum (lit, t))
                  | (Some, _) =>
                    // other operators not allowed on enums
                    expr
                }
              else
                expr
            | _ => expr
          }
        | _ => expr
      }
    }
    
    fold_constants (env : GlobalEnv, expr : Expr, recurse : bool) : Expr
    {
      match (expr) {
        | <[ $(name : dyn) ($e1, $e2) ]> when is_known_operator (name) =>
          if (recurse)
            fold_binary_operator (name, 
                                  fold_constants (env, e1, true), 
                                  fold_constants (env, e2, true), 
                                  expr)
          else
            fold_binary_operator (name, e1, e2, expr)

        | <[ $(name : dyn) ($e1) ]> when is_known_operator (name) =>
          if (recurse)
            fold_unary_operator (name, fold_constants (env, e1, true), expr)
          else
            fold_unary_operator (name, e1, expr)
  
        | <[ $_o . $_f ]>
        | <[ $(_ : name) ]> => 
          literal_field_value (env, expr)

        | _ => expr
      }
    }

    internal FoldConstants (env : GlobalEnv, expr : Expr) : Expr
    {
      fold_constants (env, expr, true)
    }
    
    internal FoldTopConstants (env : GlobalEnv, expr : Expr) : Expr
    {
      fold_constants (env, expr, false)
    }

  }
}
