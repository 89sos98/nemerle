/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;
using Nemerle.Compiler.Tyexpr;

using Nemerle.Text;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 */
public interface IMacro
{
  GetName () : string;
  GetNamespace () : string;  
  Run (ctx : CTX, args : list <PT.SyntaxElement>) : PT.PExpr;
  CallTransform (_ : list <PT.PExpr>) : list <PT.SyntaxElement>;
  SyntaxExtension () : string * list <Parser.GrammarElement> * list <int>;
  IsTailRecursionTransparent : bool { get; }
} 

public module MacroRegistry {

  extensions : Hashtable <string, list <string * list<string>
               * Parser.KeywordCallback>>;
  mutable loaded : list<string>;

  this () {
    extensions = Hashtable (50);
    loaded = [];
  }

  public LoadSyntaxExtensions (from_namespace : string) : void
  {
    def load (key, keywords, callback) {
      Parser.ctx.keywords.Set (key, callback);
      List.Iter (keywords, fun (x) { LexerBase.AddKeyword (x) })
    };
    match (extensions.Get (from_namespace)) {
      | Some (l) =>
        List.Iter (l, load);
        loaded = from_namespace :: loaded;
      | _ => ()
    }
  }

  internal RemoveSyntaxExtensions () : void
  {
    loaded = List.Filter (loaded, fun (ns) {
      if (ns != "Nemerle.Core")
        match (extensions.Get (ns)) {
          | Some (val) =>
            List.Iter (val, fun (tup) {
              def (key, keywords, _) = tup;
              List.Iter (keywords, fun (x) { LexerBase.RemoveKeyword (x) });
              Parser.ctx.keywords.Remove (key)
            });
            false
          | None =>
            Util.ice ("cannot find loaded namespace in extensions")
        }
      else
        true
    })
  }
  
  internal register_macro (m : IMacro) : void {
    def ns = m.GetNamespace ();

    // full qualified name of macro call
    def fullname = ns + m.GetName ();
    // crop last symbol (`.') of namespace
    
    def ns =
      if (ns == "") 
        "Nemerle.Core" 
      else 
        ns.Substring (0, ns.Length - 1);
        
    def nslist = NString.Split (fullname, array ['.']);

    match (GlobalEnv.LookupExactMacro (nslist)) {
      | Some =>
        Message.error ("macro `" + fullname + "' already defined")
      | None =>
        // store syntax extension in MacroRegistry
        match (m.SyntaxExtension ()) {
          | ("", [], []) => ()
          | (key, rules, positions) =>
            mutable keywords = [key];
            List.Iter (rules, fun (x) { 
              | Parser.GrammarElement.GE_keyword (k) => keywords = k :: keywords;
              | _ => () 
            });

            def permute = Macros.CreatePermutingFunction (List.Rev (positions));
            def callback =
              Parser.KeywordCallback (key, Parser.make_parsing_function
                 (GlobalEnv.ExactPath (nslist), rules, permute));

            // store extensions for this namespace
            match (extensions.Get (ns)) {
              | Some (l) =>
                extensions.Set (ns, (key, keywords, callback) :: l)
              | None =>
                extensions.Set (ns, [(key, keywords, callback)])
            }
        };
        GlobalEnv.AddMacro (nslist, m);
    }
  }

  internal expand_macro (orig_ctx : CTX, ctx : CTX, expr : PT.PExpr) : PT.PExpr {
    match (expr) {
      | PT.PExpr.E_call (name, args) =>
        match (Util.qidl_of_expr (name)) {
          | Some ((namepath, name)) =>
            match (name.GetEnv (ctx.env).LookupMacro (namepath)) {
              | Some (x) =>
                def used_ctx = if (x.IsTailRecursionTransparent) orig_ctx else ctx;
                TypingContext.PushNewColor (name.color, name.GetEnv (ctx.env));
                def expanded = x.Run (used_ctx, x.CallTransform (args));
                TypingContext.PopColor ();
                expand_macro (orig_ctx, ctx, expanded);
              | None => expr
            }
          | None => expr
        }
        
      | PT.PExpr.E_macrocall (name, namespc, parms) =>
        match (namespc.Value) {
          | GlobalEnv.TypeInfoCache.MacroCall (m) =>
            def used_ctx = if (m.IsTailRecursionTransparent) orig_ctx else ctx;            
            TypingContext.PushNewColor (name.color, name.GetEnv (ctx.env));
            def expanded = m.Run (used_ctx, parms);
            TypingContext.PopColor ();        
            expand_macro (orig_ctx, ctx, expanded)
          | _ =>
            Util.ice ("failed to resolve macro name `" +
                      NString.Concat (".", namespc.Name) + "'")
        }

      | _ => expr
    }
  }

  internal lookup_macro (env : GlobalEnv, expr : PT.PExpr, suff : string)
  : option <PT.Name * IMacro * list <PT.PExpr>>
  {
    match (expr) {
      | <[ $(_ : name) ]>
      | <[ $_ . $_ ]> =>
        lookup_macro (env, <[ $expr () ]>, suff)
      | <[ $name ( .. $parms ) ]> =>
          match (Util.qidl_of_expr (name)) {
            | Some ((id, name)) =>
              def ctx = name.GetEnv (env);
              def id =
                match (List.Rev (id)) {
                  | x :: xs => List.Rev (x + suff :: xs)
                  | [] => assert (false)
                };
              match (ctx.LookupMacro (id)) {
                | Some (m) => Some ((name, m, parms))
                | None => None ()
              };
            | None => None ()
          }
      | _ => None ()
    }
  }
  
}
} // end ns
