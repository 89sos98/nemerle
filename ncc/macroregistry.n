(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

(** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 *)
public interface IMacro {
  GetName () : string;
  Run (ctx : CTX, args : list (PT.SyntaxElement)) : PT.Expr;
  CallTransform (_ : list (PT.Parm)) : list (PT.SyntaxElement);
  SyntaxExtension () : string * list (Parser.GrammarElement) * list (int);
} 

public module MacroRegistry {
  public mutable macros : Hashtable (string, IMacro);

  this () {
    macros <- Hashtable ();
  }

  public register_macro (m : IMacro) : void {
    def name = m.GetName ();
    if (macros.Contains (name))
      Util.ice ("macro already registered: " + name)
    else {
      match (m.SyntaxExtension ()) {
        | ("", [], []) => ()
        | (key, rules, positions) =>
          def positions = List.rev (positions);
          def len = List.length (positions);
          def permute (li) {
            def take_first (n, l, acc) {
              match ((n, l)) {
                | (0, _) => (List.rev (acc), l)
                | (_, []) => Util.ice ("too few parameters")
                | (n, x :: xs) =>
                  take_first (n - 1, xs, x :: acc)
              }
            };
            def pararr = (System.Array.CreateInstance (typeof (PT.SyntaxElement), 
                                                       len) 
                          :> array (PT.SyntaxElement));
            mutable m <- 0;
            def loop (l, ps) {
              match ((l, ps)) {
                | (x :: xs, [p]) =>
                  pararr[p] <- x;
                  loop (xs, [])
                | (x :: xs, p :: pp) =>
                  if (p == len - 1) {
                    def (rtail, rfront) = take_first (len - m - 1, 
                                                      List.rev (xs), []);
                    pararr[p] <- x;
                    loop (List.append (List.rev (rtail), List.rev (rfront)), pp)
                  }
                  else {
                    pararr[p] <- x;
                    m <- m + 1;
                    loop (xs, pp)
                  }
                | (xs, []) => List.append (List.from_array (pararr), xs)
                | ([], _) => Util.ice ("too few parameters")
              }
            };
            loop (li, positions)
          };
          Lexer.AddKeyword (key);
          List.iter (fun (x) { | Parser.GE_keyword (k) => 
                                 Lexer.AddKeyword (k); | _ => () }, rules);

          Parser.ctx.keywords.Set (key, Parser.KeywordCallback (key, 
            Parser.make_parsing_function (name, rules, permute)))
      };
      macros.Set (name, m)
    }
  }

  public expand_macro (ctx : CTX, expr : PT.Expr) : PT.Expr {
    match (expr) {
      | PT.E_call (PT.E_ref (n), args) =>
        match (macros.Get (n)) {
          | Some (x) => 
            expand_macro (ctx, x.Run (ctx, x.CallTransform (args)));
          | None => expr
        }
      | _ => expr
    }
  }

}
} // end ns
