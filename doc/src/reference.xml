<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle Language Reference</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document presents in semi-formal way syntax and semantics
        of the Nemerle language. It is not meant to be a tutorial.
      </p>
      <p>
        We often refer to <tt>.NET</tt> terminology [FIXME: reference it].
      </p>
    </body>
  </section>


  <section id="lexical">
    <title>Lexical Conventions</title>
    <body>
      <p>
        Programs are written using the Unicode character set. Every
        Nemerle source file is reduced to a sequence of lexical units
        (tokens) separated by sequences of white characters (blanks).
      </p>
    </body>
    <subsection id="tokens">
      <title>Tokens</title>
      <body>
        <p>
	  There are five classes of lexical tokens: 
        </p>
        <ul>
          <li>identifiers</li>
          <li>type variables</li>
          <li>keywords</li>
          <li>literals</li>
          <li>blanks</li>
        </ul>
<code>
/* A comment. */
// Also a comment

foo               // identifier
foo_bar foo' foo3 // other identifiers
'a                // type variable 
42                // integer literal
0x2a              // hexadecimal integer literal
0o52              // octal integer literal
0b101010          // binary integer literal
'a'               // character literal
'\n'              // also a character literal
"foo\nbar"        // string literal
@"x\n"            // same as "x\\n"
@if               // keyword used as identifier
</code>
      </body>
    </subsection>
    <subsection id="blanks">
      <title>Blanks</title>
      <body>
        <p>
	  Spaces, vertical, and horizontal tabulation characters,
	  new-page, and new-line characters, and comments (called blanks
	  altogether) are discarded, but can separate other lexical tokens.
	</p>
        <p>
	  A traditional comment begin with <tt>/*</tt>, and end with
	  <tt>*/</tt>.  A end-of-line comment begin with <tt>//</tt>,
	  and end with line terminator (ASCII LF character).
	</p>
      </body>
    </subsection>
    <subsection id="type-variables">
      <title>Type variables</title>
      <body>
        <p>
          Type variables start with apostrophe (<tt>'</tt>) followed
	  by not empty string of characters allowed in identifiers,
	  excluding apostrophe.
	</p>
      </body>
    </subsection>
    <subsection id="identifiers">
      <title>Identifiers</title>
      <body>
        <p>
	  Ordinary identifiers consist of letters, digits, underscores
	  and apostrophe, but cannot begin with a digit nor an apostrophe.
	  Identifiers may be quoted with the <tt>@</tt> character, which
	  is stripped. It removes any lexical and syntactic meaning from
	  the following string of characters until blank, thus enabling
	  programmer to use keywords as identifiers.
	</p>
	<p>
	  There is an important difference between identifiers starting
	  with underscore character <tt>_</tt> and the other ones.
	  [FIXME: explain the difference]
	</p>
	<p>
	  Symbolic identifiers consist of following characters: 
          <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>@</tt>,
          <tt>^</tt>, <tt>|</tt>, <tt>&amp;</tt>, <tt>+</tt>, <tt>-</tt>,
          <tt>*</tt>, <tt>/</tt>, <tt>$</tt>, <tt>%</tt>, <tt>!</tt>,
          <tt>?</tt>, <tt>~</tt>, <tt>.</tt>, <tt>:</tt>, <tt>#</tt>.
          Symbolic identifiers may be used, wherever ordinary
	  identifiers may, but have additional property of being used
	  as infix operators.
	</p>
      </body>
    </subsection>
    <subsection id="keywords">
      <title>Keywords</title>
      <body>
        <p>
	  Following identifiers are used as keywords, and may not be
	  used in any other context unquoted:
          <tt>_</tt>, <tt>abstract</tt>, <tt>and</tt>, <tt>array</tt>,
          <tt>as</tt>, <tt>base</tt>, <tt>class</tt>, <tt>const</tt>,
          <tt>def</tt>, <tt>else</tt>, <tt>ensure</tt>, <tt>enum</tt>,
          <tt>extends</tt>, <tt>extern</tt>, <tt>finally</tt>,
          <tt>fun</tt>, <tt>if</tt>, <tt>implements</tt>,
          <tt>in</tt>, <tt>interface</tt>, <tt>internal</tt>,
          <tt>let</tt>, <tt>macro</tt>, <tt>match</tt>,
          <tt>module</tt>, <tt>mutable</tt>, <tt>namespace</tt>,
          <tt>new</tt>, <tt>null</tt>, <tt>using</tt>, <tt>out</tt>,
          <tt>private</tt>, <tt>protected</tt>, <tt>public</tt>,
          <tt>raise</tt>, <tt>ref</tt>, <tt>require</tt>, <tt>sealed</tt>,
          <tt>static</tt>, <tt>struct</tt>, <tt>then</tt>, <tt>this</tt>,
          <tt>try</tt>, <tt>tymatch</tt>, <tt>type</tt>, <tt>variant</tt>,
          <tt>void</tt>, <tt>volatile</tt>, <tt>where</tt>, <tt>with</tt>.
        </p>
        <p>
          Following infix identifiers are keywords:
          <tt>=</tt>, <tt>$</tt>, <tt>?</tt>, <tt>|</tt>, <tt>&lt;-</tt>,
          <tt>-&gt;</tt>, <tt>=&gt;</tt>, <tt>&lt;[</tt>, <tt>]></tt>,
          <tt>&amp;&amp;</tt>, <tt>||</tt>.
	</p>
      </body>
    </subsection>
    <subsection id="literals">
      <title>Literals</title>
      <body>
        <p>
          There are few kinds of literals:
	</p>
        <ul>
          <li>
            String literals, enclosed in <tt>""</tt>. Compiler processes
            backslash escapes much like in C#.
          </li>
          <li>
            Raw string literals, written like ordinary string literals,
            but prefixed with <tt>@</tt>. Escapes are not processed.
          </li>
          <li>
            Character literals, enclosed in <tt>'</tt>. Escapes are
            processed.
          </li>
          <li>
            Integer literals, possibly prefixed with <tt>0x</tt>,
            <tt>0o</tt> or <tt>0b</tt> to donate hexadecimal, octal or
            binary encoding respectively.
          </li>
	  <li>
	    Floating point literals, defined this way:
	    <rule name="floating_point_literal">
	    	<non-terminal name="digits"/>
		<terminal name="."/>
		<optional>
		   <non-terminal name="digits"/>
		</optional>
		<optional>
		   <non-terminal name="exponential_marker"/>
		   <optional>
		      <non-terminal name="sign"/>
		   </optional>
		   <non-terminal name="digits"/>
		</optional>
	    </rule>
	    <rule name="digits">
	      <nonterminal name="digit"/>
	      <repeat>
	        <nonterminal name="digit"/>
	      </repeat>
	    </rule>
	    <rule name="exponential_marker">
	      <terminal name="e"/>
	    </rule>
	    <rule name="exponential_marker">
	      <terminal name="E"/>
	    </rule>
	    <rule name="sign">
	      <terminal name="+"/>
	    </rule>
	    <rule name="sign">
	      <terminal name="-"/>
	    </rule>
	  </li>
        </ul>
      </body>
    </subsection>
  </section>


  <section id="compilation-units">
    <title>Compilation units</title>
    <body>
      <rule name="compilation_unit">
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
      </rule>
      <p>
        Nemerle program consists of one or more compilation
        units. Compilation units are files with <tt>.n</tt> suffix.
        Compilation unit consists of namespace-related declarations and
        types within them.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="using"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Add specified namespace (which can be type or namespace name,
        unlike in C#) to symbol search path. Every symbol till end of
        current compilation unit will be searched also in location
        specified by this path.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <special-terminal name="IDENTIFIER"/>
        <terminal name="="/>
        <non-terminal name="qualified_identifier"/>
        <terminal name=";"/>
      </rule>
      <p>
        Define alias for namespace. After <tt>namespace Foo =
         Bar.Baz;</tt> any reference to <tt>Foo.bar</tt> will be expanded
        to <tt>Bar.Baz.bar</tt>.
      </p>
      <rule name="toplevel_declaration">
        <terminal name="namespace"/>
        <non-terminal name="qualified_identifier"/>
        <terminal name="{"/>
        <repeat>
          <non-terminal name="toplevel_declaration"/>
        </repeat>
        <terminal name="}"/>
      </rule>
      <p>
        Put declarations within specified namespace. Namespaces can
        be nested, creating tree of namespaces. 
      </p>
      <rule name="toplevel_declaration">
        <non-terminal name="type_declaration"/>
      </rule>
      <p>
        Define new type. Definition of new type can occur at top level
        of compilation unit.
      </p>
    </body>
  </section>


  <section id="misc">
    <title>Stuff that doesn't fit anywhere else</title>
    <body>
      <p>
        This section lists grammar rules common to most of other sections.
      </p>
    </body>
    <subsection id="id-or-dummy">
      <title>Identifier or dummy</title>
      <body>
        <rule name="identifier_or_dummy">
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <rule name="identifier_or_dummy">
          <terminal name="_"/>
        </rule>
        <p>
          In several places it is possible to use keyword <tt>_</tt> to donate intent
          to ignore parameter. Semantics of <tt>_</tt> in such places is to generate
          new temporary name.
        </p>
      </body>
    </subsection>
    <subsection id="qid">
      <title>Qualified identifier</title>
      <body>
        <rule name="qualified_identifier">
          <special-terminal name="IDENTIFIER"/>
          <repeat>
            <terminal name="."/>
            <special-terminal name="IDENTIFIER"/>
          </repeat>
        </rule>
        <p>
          Identifiers can be often qualified with namespaces.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-declarations">
    <title>Type declarations</title>
    <body>
      <p>
        Types are defined at the top level, within namespaces or within
        other types. Defining type within namespace affects its name --
        it's prefixed with namespace name. Defining type with other type
        additionally affects accessibility of type. The rules here are
        the same as in .NET.
      </p>
    </body>
    <subsection id="ty-header">
      <title>Type header</title>
      <body>
        <rule name="type_header">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <non-terminal name="type_parameters"/>
          </optional>
          <optional>
            <terminal name="extends"/>
            <non-terminal name="type"/>
          </optional>
          <optional>
            <terminal name="implements"/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
          </optional>
        </rule>
        <p>
          Type header is similar to .NET. Main difference are
          optional <tt>type_parameters</tt>, defined below.
        </p>
      </body>
    </subsection>
    <subsection id="ty-parms">
      <title>Type parameters</title>
      <body>
        <rule name="type_parameters">
          <terminal name="("/>
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <terminal name=")"/>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
        </rule>
        <rule name="where_constraints">
          <terminal name="where"/>
          <special-terminal name="TYPE_VARIABLE"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
            <terminal name=":&gt;"/>
            <non-terminal name="type"/>
          </repeat>
        </rule>
        <p>
          When defining polymorphic type one has to specify list
          of type variables in declaration. It can have following form:
        </p>
<code>
('a, 'b) where a :> Nemerle.Collections.IEnumerable, b :> Nemerle.Collections.IDictionary
</code>
        <p>
          Optional parameter <tt>where</tt> can be used to set constraints
          to type variables (type coercion).
        </p>
      </body>
    </subsection>
    <subsection id="type-alias">
      <title>Type alias</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
          This type declaration creates alias to another type.
        </p>
      </body>
    </subsection>
    <subsection id="extern-type">
      <title>External type declaration</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="type"/>
          <non-terminal name="type_header"/>
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <p>
          [FIXME - is not implemented or _will_ not be implemented]
        </p>
      </body>
    </subsection>
    <subsection id="interface-def">
      <title>Interface definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="interface"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="interface_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Nemerle interfaces are similar to .NET.
        </p>
      </body>
    </subsection>
    <subsection id="class-def">
      <title>Class definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="class"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Class definition is similar to .NET.
        </p>
      </body>
    </subsection>
    <subsection id="module-def">
      <title>Module definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="module"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <non-terminal name="type_member"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Module is much like class, but all module members are
          static. There is no need to place <tt>static</tt> attributes
          on module members. It is also not possible to create instances
          of module types.
        </p>
      </body>
    </subsection>
    <subsection id="variant-def">
      <title>Variant definition</title>
      <body>
        <rule name="type_declaration">
          <non-terminal name="attributes"/>
          <terminal name="variant"/>
          <non-terminal name="type_header"/>
          <terminal name="{"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="variant_option"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
          Variant declaration consist of type name, and list of
          bar-separated constructors enclosed in brackets.
        </p>
        <rule name="variant_option">
          <special-terminal name="IDENTIFIER"/>
          <optional>
            <terminal name="{"/>
            <repeat>
              <non-terminal name="field_definition"/>
            </repeat>
            <terminal name="}"/>
          </optional>
        </rule>
        <p>
          The constructor declaration describe the constructor
          associated to this variant type.  A constructor may take an
          argument.
	  [FIXME: Must constructor name be capitalized?]  
        </p>
      </body>
    </subsection>
  </section>


  <section id="attributes">
    <title>Attributes</title>
    <body>
      <p>
        The semantics of attributes is the same as in C#.
      </p>
      <rule name="attributes">
        <repeat>
          <non-terminal name="attribute"/>
        </repeat>
      </rule>
      <rule name="attribute">
        <terminal name="new"/>
      </rule>
      <rule name="attribute">
        <terminal name="public"/>
      </rule>
      <rule name="attribute">
        <terminal name="protected"/>
      </rule>
      <rule name="attribute">
        <terminal name="internal"/>
      </rule>
      <rule name="attribute">
        <terminal name="private"/>
      </rule>
      <rule name="attribute">
        <terminal name="abstract"/>
      </rule>
      <rule name="attribute">
        <terminal name="sealed"/>
      </rule>
      <rule name="attribute">
        <terminal name="override"/>
      </rule>
      <rule name="attribute">
        <terminal name="static"/>
      </rule>
    </body>
  </section>


  <section id="type-members">
    <title>Declarations within types</title>
    <body>
      <p>
        Following fields are allowed in <a ref="#class-def">class</a> 
        or <a ref="#module-def">module</a> body:
      </p>
      <rule name="type_member">
        <non-terminal name="field_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="method_definition"/>
      </rule>
      <rule name="type_member">
        <non-terminal name="type_declaration"/>
      </rule>
    </body>
    <subsection id="field-def">
      <title>Field definition</title>
      <body>
        <rule name="field_definition">
          <non-terminal name="attributes"/>
          <optional>
            <terminal name="mutable"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=";"/>
        </rule>
        <p>
          If optional keyword <tt>mutable</tt> is not used, field can be
          modified only inside the constructor.
        </p>
      </body>
    </subsection>
    <subsection id="interface-mem-def">
      <title>Interface member</title>
      <body>
        <rule name="interface_member">
          <optional>
            <terminal name="new"/>
          </optional>
          <non-terminal name="method_header"/>
          <terminal name=";"/>
        </rule>
        <p>
          Keyword <tt>new</tt> is necessary when declared method hides
          inherited one from another interface.
        </p>
      </body>
    </subsection>
    <subsection id="method-def">
      <title>Method definition</title>
      <body>
        <rule name="method_definition">
          <non-terminal name="attributes"/>
          <non-terminal name="method_header"/>
          <non-terminal name="method_body"/>
        </rule>
        <p>
          This is definition of method within class or module.
          Program entry point is method <tt>Main</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="method-head">
      <title>Method header</title>
      <body>
        <rule name="method_type_parameters">
          <special-terminal name="TYPE_VARIABLE"/>
          <repeat>
            <terminal name=","/>
            <special-terminal name="TYPE_VARIABLE"/>
          </repeat>
          <optional>
            <non-terminal name="where_constraints"/>
          </optional>
        </rule>
        <p>
          Declaration of polymorphic method needs its type
          variables listed at the beginning of declaration.
        </p>
        <rule name="method_header">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <non-terminal name="method_implements"/>
        </rule>
        <p>
          This is declaration of method. Unlike C# type is specified after
          parameters list.
        </p>
        <rule name="method_header">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="this"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
        </rule>
        <p>
        	Special method named <tt>this</tt> specifies constructor.
          This declaration cannot contain method type and method has
          to have type <tt>unit</tt>.
        </p>
        <rule name="method_implements">
          <optional>
            <terminal name="implements"/>
            <non-terminal name="qualified_identifier"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="qualified_identifier"/>
            </repeat>
          </optional>
        </rule>
      </body>
    </subsection>
    <subsection id="method-parms">
      <title>Method parameters</title>
      <body>
        <rule name="method_parameter">
          <non-terminal name="identifier_or_dummy"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
        </rule>
        <p>
          Method parameter is a pair consisting of <tt>identifier</tt>
          or <tt>_</tt> and it's type specification. [FIXME - type is not optional?]
        </p>
        <rule name="method_parameters">
          <optional>
            <non-terminal name="method_parameters"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="method_parameter"/>
            </repeat>
          </optional>
        </rule>
        <p>
          Method parameter is comma-separated list of parameter specification.
        </p>
      </body>
    </subsection>
    <subsection id="method-body">
      <title>Method body</title>
      <body>
        <rule name="method_body">
          <terminal name="="/>
          <terminal name="extern"/>
          <special-terminal name="STRING_LITERAL"/>
          <terminal name=";"/>
        </rule>
        <p>
          Method body can be linked to external function, example:
        </p>
<code>
  static ps(s : string) : void = extern "System.Console.Write";
</code>
        <rule name="method_body">
          <terminal name=";"/>
        </rule>
        <p>
          Empty method body (a <tt>;</tt>) is a method declaration.
        </p>
        <rule name="method_body">
          <non-terminal name="block"/>
        </rule>
        <p>
          This is classical method definition.
        </p>
      </body>
    </subsection>
  </section>


  <section id="type-expressions">
    <title>Type expressions</title>
    <body>
      <p>
        Type expression relate to <a ref="#type-declarations">type
        declarations</a> much like function calls relate to function
        and value definitions. Type declarations define ways the types
        can be constructed and type expressions define actual types.
      </p>
      <p>
        Types are both static and dynamic characterization of values.
        Static type of expression depends on its building blocks and
        is defined in paragraph describing given expression. Dynamic
        (runtime) type is bound to the value at the moment it is created,
        and remains there until the value is garbage collected.
      </p>
      <p>
        The type system is modeled after .NET Generics design, except
        for tuple and function types, which are new, but can be easily
        simulated using generics.
      </p>
    </body>
    <subsection id="type-app">
      <title>Type constructor application</title>
      <body>
        <rule name="primary_type">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <terminal name="("/>
            <non-terminal name="type"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="type"/>
            </repeat>
            <terminal name=")"/>
          </optional>
        </rule>
        <p>
          Type constructor (defined with <a ref="#type-definitions">type
          declaration</a>) can be applied to zero or more arguments
          forming type expression. Number of type arguments in type
          application must match number of <a ref="#ty-parms">type
          arguments</a> in definition.  Moreover actual type arguments
          must solve <a ref="#ty-parms"><tt>where</tt> constraints</a>
          imposed on formal type arguments.
        </p>
      </body>
    </subsection>
    <subsection id="tyvar">
      <title>Type variable reference</title>
      <body>
        <rule name="primary_type">
          <special-terminal name="TYPE_VARIABLE"/>
        </rule>
        <p>
          Refer to type substituted to given type variable. The type
          variable has to be defined (bound, quantified) before it is used.
          Type variable can be defined in <a ref="#ty-parms">type
          arguments</a> or <a ref="#method-head">method header</a>
          (of global or local function).
        </p>
      </body>
    </subsection>
    <subsection id="group-ty">
      <title>Grouping types</title>
      <body>
        <rule name="primary_type">
          <terminal name="("/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          This construct has no semantic meaning -- it exists only to
          enforce particular syntax decomposition.
        </p>
      </body>
    </subsection>
    <subsection id="void-ty">
      <title>Void type</title>
      <body>
        <rule name="primary_type">
          <terminal name="void"/>
        </rule>
        <p>
          This is mostly an alias for <tt>System.Void</tt> -- a type with
          exactly one inhibiting value it is however first class value
          -- can be passed as function parameter as well as returned
          from functions.
        </p>
        <p>
          The name comes from <tt>System.Void</tt>, but should be in
          fact <tt>unit</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="ref-out-ty">
      <title>Ref and Out types</title>
      <body>
        <rule name="primary_type">
          <terminal name="ref"/>
          <non-terminal name="primary_type"/>
        </rule>
        <rule name="primary_type">
          <terminal name="out"/>
          <non-terminal name="primary_type"/>
        </rule>
        <p>
          These are for parameters passed by reference. This is not
          implemented yet, but will have semantics similar as in C#.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ty">
      <title>Tuple type</title>
      <body>
        <rule name="type">
          <non-terminal name="primary_type"/>
          <repeat>
            <terminal name="*"/>
            <non-terminal name="primary_type"/>
          </repeat>
        </rule>
        <p>
          Construct product (tuple) type. This operator is not associative, which
          means that each two of following types are different:
        </p>
<code>
int * int * int
(int * int) * int
int * (int * int)
</code>
      </body>
    </subsection>
    <subsection id="function-ty">
      <title>Function type</title>
      <body>
        <rule name="type">
          <non-terminal name="type"/>
          <terminal name="->"/>
          <non-terminal name="type"/>
        </rule>
        <p>
          Construct function type with specified argument and return
          types respectively. The <tt>-></tt> operator is right
          associative, which means that the following type are equivalent:
        </p>
<code>
int -> int -> int
int -> (int -> int)
</code>
        <p>
          Multi-argument function types are written using tuple notation,
          for example after local declaration:
        </p>
<code>
def some_function (a : int, b : string) : float { ... }
</code>
        <p>
          the expression <tt>some_function</tt> has type <tt>int *
          string -> float</tt>.
        </p>
      </body>
    </subsection>
  </section>

  <section id="literal-exprs">
    <title>Literal expressions</title>
    <body>
      <p>
        These are used in expressions and patterns.
      </p>
    </body>
    <subsection id="boolean-lit">
      <title>Boolean</title>
      <body>
        <rule name="literal">
          <terminal name="true"/>
        </rule>
        <rule name="literal">
          <terminal name="false"/>
        </rule>
        <p>
          These literals have type <tt>bool</tt> and represent respectively
          true (false) boolean value 
        </p>
      </body>
    </subsection>
    <subsection id="null-lit">
      <title>Null</title>
      <body>
        <rule name="literal">
          <terminal name="null"/>
        </rule>
        <p>
          Represents null reference, one that does not refer to any object.
          It has type <tt>'a</tt>. 
        </p>
      </body>
    </subsection>
    <subsection id="void-lit">
      <title>Void</title>
      <body>
        <rule name="literal">
          <terminal name="("/>
          <terminal name=")"/>
        </rule>
        <p>
          Indicates returning no value. It is the only possible value of type <tt>void</tt>.
          See also <a ref="void-ty">void type</a>.
        </p>
      </body>
    </subsection>
    <subsection id="string-lit">
      <title>String</title>
      <body>
        <rule name="literal">
          <special-terminal name="STRING_LITERAL"/>
        </rule>
        <p>
          Represents <tt>string</tt> constants. Nemerle supports two forms of string:
        </p>
        <ul>
         <li> regular string literals </li>
         <li> verbatim string literals </li>
        </ul>
        
        <p>
          A regular string literal consists of zero or more characters enclosed in double
          quotes and may include both simple escape sequences (such as \n for the newline
          character) and hexadecimal and Unicode escape sequences (See 
          <a ref="character">character literals</a> for details).
        </p>
        <p>
          A verbatim string literal consists of an @ character followed by a double-quote 
          character, zero or more characters, and a closing double-quote character. 
          In a verbatim string literal, the characters between the double-quotes are recognized
          verbatim, the only exception is a sequence <tt>""</tt> (used to indicate <tt>'"'</tt>
          character) (Note that simple escape sequences and hexadecimal and Unicode escape sequences
          are not recognized in verbatim string literals). A verbatim string literal may span
          multiple lines. 
        </p>
        <p>
          Examples:
        </p>
<code>
def s1 = "Nemerle string !";            // Nemerle string !
def s2 = @"Nemerle string !";           // Nemerle string !
def s3 = "Nemerle\tstring !";           // Nemerle    string !
def s4 = @"Nemerle\tstring !";          // Nemerle\tstring !
def s5 = "I heard \"zonk !\"";          // I heard "zonk !"
def s6 = @"I heard ""zonk !""";         // I heard "zonk !"
def s7 = "\\\\trunk\\ncc\\ncc.exe";     // \\trunk\ncc\ncc.exe
def s8 = @"\\trunk\ncc\ncc.exe";        // \\trunk\ncc\ncc.exe
def s9 = "\"Nemerle\"\nstring\n!";      // "Nemerle"
                                        // string
                                        // !
def s10 = @"""Nemerle""                 // same as s9
rocks
!";
</code>
        <p>
          String s10 is a verbatim string literal that spans 3 lines.
        </p>
      </body>
    </subsection>
    <subsection id="number">
      <title>Number</title>
      <body>
        <rule name="literal">
          <special-terminal name="NUMBER_LITERAL"/>
        </rule>
        <p>
          Represents one of numeric types. See <a ref="literals"> literals </a> for details
          of representing particular numerical types.  
        </p>
      </body>
    </subsection>
    <subsection id="character">
      <title>Character</title>
      <body>
        <rule name="literal">
          <special-terminal name="CHARACTER_LITERAL"/>
        </rule>
        <p>
          Character literal consist of one character enclosed in single-quotes (' ')
          or escape character of form '\X' where X can be one of following:
          [FIXME : characters with (N) are not implemented yet (will they ?)]
        </p>
        <ul>
          <li> \, ', " - this allows representation of (respectively) backslash, single-quote
            double-quote </li> 
          <li> 0X - where X is an octal ASCII code (up to three digits) of character we want to represent (N)</li>
          <li> xX - where X is an hexadecimal ASCII code (exactly two digits) of character we want to represent (N) </li>
          <li> uX - where X is an hexadecimal UNICODE code (exactly four digits) of character we want to represent (N)</li>
          <li> a - matches a bell (alarm) (N)</li>
          <li> b - matches a backspace \u0008 </li>
          <li> r - matches carriage return \u000D </li> 
          <li> v - matches vertical tab \u000B (N)</li>
          <li> f - matches form feed \u000C (N)</li>
          <li> n - matches a new line \u000A </li>
          <li> e - matches an escape \u001B (N)</li>
          <li> cX - matches an ASCII control character; for example \cC represents control-C (N) </li>
        </ul>
        <p>
          It has type <tt>char</tt>.
        </p>
      </body>
    </subsection>
  </section>


  <section id="prim-expressions">
    <title>Primary expressions</title>
    <body>
      <p>
        Primary expressions is grammar category referring to expressions
        that have closed structure and are otherwise simple. Primary
        expressions and plain expressions do not differ at the semantic
        level.
      </p>
    </body>
    <subsection id="literal-ref">
      <title>Literal expression</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="literal"/>
        </rule>
        <p>
          [FIXME : ?? May literal be a primary expression ?]
        </p>
      </body>
    </subsection>
    <subsection id="variable-ref">
      <title>Variable reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="qualified_identifier"/>
        </rule>
        <p>
          This expression result is a variable itself (not its value).
          Type of this expression is <tt>ref 'a</tt> where <tt>'a</tt> is
          a type of variable being referenced.
        </p>
      </body>
    </subsection>
    <subsection id="this-ref">
      <title>this pointer reference</title>
      <body>
        <rule name="primary_expr">
          <terminal name="this"/>
        </rule>
        <p>
          This expression can only be used within non-static methods and indicates
          a reference to the current instance of the class (which posses this method).
          Note: "this" may be omitted when using it only to refer to another method
          or field of the class unless it generates an identifier ambiguity with some
          variable being in this lexical scope. 
        </p>
      </body>
    </subsection>
    <subsection id="grouping">
      <title>Grouping expression</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
        </rule>
        <p>
          Grouping expression allow to enforce particular syntax decomposition of expression.
        </p>
      </body>
    </subsection>
    <subsection id="type-cast">
      <title>Type cast</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":&gt;"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          This expression allows dynamic type coercion. It is done during runtime and if it cannot be
          realised then System.InvalidCastException is thrown. If it succeeds the type of this expression
          is equal to the type of <non-terminal name="type"/>.
        </p>
      </body>
    </subsection>
    <subsection id="type-enf">
      <title>Type enforcement</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name=")"/>
        </rule>
        <p>
          [FIXME : Am I right ?]
          This expression allows static type enforcement. It is checked during compile-time and
          error is reported if <non-terminal name="expr"/> type is not a subtype of <non-terminal name="type"/>.
          It allows only type widening. If it succeeds the type of this expression is equal to the type of
          <non-terminal name="type"/>.
          
          Note: Compiler always assumes that all previous cast (also dynamic) have been realised.
        </p>
      </body>
    </subsection>
    <subsection id="member-ref">
      <title>Member reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="primary_expr"/>
          <terminal name="."/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          This expression allows referring to the field or method that object represented by
          <non-terminal name="primary_expr"/> contains.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-ctor">
      <title>Tuple constructor</title>
      <body>
        <rule name="primary_expr">
          <terminal name="("/>
          <non-terminal name="expr"/>
          <repeat-plus>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat-plus>
          <terminal name=")"/>
        </rule>
        <p>
          This expression allows creating a tuple of <non-terminal name="expr"/> whose types may differ.
          The type of that tuple is <tt> type1 </tt> <repeat-plus> <terminal name="*"/> <tt> type_n </tt></repeat-plus>
          where type1 and following are types of corresponding expressions.
        </p>
      </body>
    </subsection>
    <subsection id="indexer-ref">
      <title>Indexer reference</title>
      <body>
        <rule name="primary_expr">
          <non-terminal name="expr"/>
          <terminal name="["/>
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="expr"/>
          </repeat>
          <terminal name="]"/>
        </rule>
        <p>
          This expression allows to refer to indexed (even by multiple indexes) fields of
          objects represented by leftmost <non-terminal name="expr"/> where second (and further)
          <non-terminal name="expr"/> are indexes values of field we want to refer to.
          <non-terminal name="expr"/> must refer to indexing object. 
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="core-expressions">
    <title>Core Expressions</title>
    <body>
       <p>
       </p>
    </body>
    <subsection id="prim-expr-ref">
      <title>Primary expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="call">
      <title>Function call</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="("/>
          <optional>
            <non-terminal name="parameter"/>
            <repeat>
              <terminal name=","/>
              <non-terminal name="parameter"/>
            </repeat>
          </optional>
          <terminal name=")"/>
        </rule>
        <p>
          Call a function with given parameters. The type of the function call
	  expression is the same as the type of the function return value;
	  that is, if function's type is <tt>'a->'b</tt>, then the type of
	  the function call expression is <tt>'b</tt>. The value of the whole
	  expression is the return value of the function.
        </p>
      </body>
    </subsection>
    <subsection id="assign">
      <title>Assignment</title>
      <body>
        <rule name="expr">
          <non-terminal name="primary_expr"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
	  Assign a value to a variable. Left side of the assignment expression
	  must evaluate to a mutable variable. The type of the assignment is
	  always <tt>void</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="match-expr">
      <title>Match expression</title>
      <body>
        <rule name="expr">
          <terminal name="match"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="match_case"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="match_case"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
	  <tt>expr</tt> is matched sequentially to the patterns in given
	  match cases. If one of the patterns is consistent with the value of
	  <tt>expr</tt> then the corresponding computation branch of the
	  match case is evaluated. Patterns in all the match cases must be of
	  the same type. Expressions being computation branches in all the
	  match cases must be of the same type, as well. The type of the match
	  expression is the same as the type of the computation branch in
	  all the match cases.
        </p>
      </body>
    </subsection>
    <subsection id="raise-expr">
      <title>Raise expression</title>
      <body>
        <rule name="expr">
          <terminal name="raise"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
	  Throws given exception. The expression given must be of type
	  <tt>System.Exception</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="try-with">
      <title>Try..with expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="with"/>
          <terminal name="{"/>
          <optional>
            <terminal name="|"/>
          </optional>
          <non-terminal name="try_with_handler"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="try_with_handler"/>
          </repeat>
          <terminal name="}"/>
        </rule>
        <p>
	  If the evaluation of <tt>expr</tt> does not raise any exception,
	  then the result is that of the evaluation of <tt>expr</tt>.
	  Otherwise, the value of the exception which was raised is
	  pattern-matched; the value of the expression corresponding to the
	  first matching pattern is returned. If none of the patterns
	  corresponds to the value of the exception then the latter is
	  propagated up. The value (and thus the type) of the whole expression
	  is the value of <tt>expr</tt>. Consult <tt>.NET</tt>
	  specification if you want to know more about exceptions.
        </p>
      </body>
    </subsection>
    <subsection id="try-finally">
      <title>Try..finally expression</title>
      <body>
        <rule name="expr">
          <terminal name="try"/>
          <non-terminal name="expr"/>
          <terminal name="finally"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
	  Evaluates the first expression and - regardless of whether the
	  evaluation has finished correctly or some exception has been thrown
	  during the evaluation - the second expression is evaluated. The
	  value (and thus the type) of the whole expression is the value of
	  the first expression.
        </p>
      </body>
    </subsection>
    <subsection id="unary-op">
      <title>Unary operator application</title>
      <body>
        <rule name="expr">
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="binary-op">
      <title>Binary operator application</title>
      <body>
        <rule name="expr">
          <non-terminal name="expr"/>
          <special-terminal name="OPERATOR"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="block-ref">
      <title>Block expression</title>
      <body>
        <rule name="expr">
          <non-terminal name="block"/>
        </rule>
        <p>
	  The value (and thus the type) of the whole expression is the value of
	  the last expression in the block.
        </p>
      </body>
    </subsection>
    <subsection id="array-ctor">
      <title>Array constructor</title>
      <body>
        <rule name="expr">
          <terminal name="mkarray"/>
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="expr"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
	  Create an array consisting of given elements. All elements must be
	  of the same type. If the elements are of the type <tt>'a</tt> then
	  the whole expression is of the type <tt>array 'a</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="value-def">
      <title>Value definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="pattern"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
	  Defines the binding between the variables in the pattern and the
	  value of the expression <tt>expr</tt> which will be known to all
	  subsequent expressions in the current block.
        </p>
      </body>
    </subsection>
    <subsection id="local-fun-def">
      <title>Local function definition</title>
      <body>
        <rule name="expr">
          <terminal name="def"/>
          <non-terminal name="method_header"/>
          <non-terminal name="block"/>
          <repeat>
            <terminal name="and"/>
            <non-terminal name="method_header"/>
            <non-terminal name="block"/>
          </repeat>
        </rule>
        <p>
	  Defines the functions which will be known to all subsequent
	  expressions in the current block. Names of all defined functions are
	  put into the symbol space before their bodies are parsed.
        </p>
      </body>
    </subsection>
    <subsection id="mutable-def">
      <title>Mutable value definition</title>
      <body>
        <rule name="expr">
          <terminal name="mutable"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="&lt;-"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
	  Defines new variable, value of which can be changed at any time
	  using the assignment expression.
        </p>
      </body>
    </subsection>
  </section>
  

  <section id="macro-expressions">
    <title>Secondary Expressions</title>
    <body>
      <p>
        This section describes expressions that are in fact just syntactic sugar
        over Core Expressions. We just present translation of Secondary Expressions
        into Core Expressions.
      </p>
    </body>
    <subsection id="if-expr">
      <title>Conditional expression</title>
      <body>
        <rule name="expr">
          <terminal name="if"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
          <terminal name="else"/>
          <non-terminal name="expr"/>
        </rule>
          <p>	
	    Standard branch, which executes and returns value of first expression 
	    if condition evaluates to true or second elsewhere.
          </p>
          <p>
            Internally it is translated into
          </p>
<code>
match (cond) {
  | true => expr1
  | false => expr2
}
</code>             
      </body>
    </subsection>
    <subsection id="while-expr">
      <title>While loop</title>
      <body>
        <rule name="expr">
          <terminal name="while"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Loop for executing body expression as long as condition is true.
          Its value is always checked before execution of body and if it
          evaluates to false, then loop ends. Body must be of type 
          <tt>void</tt>.
        </p>
        <p>
          While loop is translated internally into following code
        </p>
<code>
def loop () {
  if (cond) 
    body; loop ()
  else
    ()
};
loop ()
</code>
      </body>
    </subsection>
    <subsection id="when-expr">
      <title>When expression</title>
      <body>
        <rule name="expr">
          <terminal name="when"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Version of <tt>if</tt> condition, but having only one branch - 
          execution of body only when condition is satisfied. If its value
          if <tt>false</tt>, then nothing is done (i. e. <tt>()</tt> is 
          returned).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) body else ()
</code>
      </body>
    </subsection>
    <subsection id="unless-expr">
      <title>Unless expression</title>
      <body>
        <rule name="expr">
          <terminal name="unless"/>
          <terminal name="("/>
          <non-terminal name="expr"/>
          <terminal name=")"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
          Opposite version of <tt>when</tt>. It executes and returns value
          of body only if conditions if not satisfied (i. e. evaluates to 
          <tt>false</tt>).
        </p>
        <p>
          Its semantics is the same as
        </p>
<code>
if (cond) () else body
</code>
      </body>
    </subsection>
    <subsection id="lambda-expr">
      <title>Lambda expression</title>
      <body>
        <rule name="expr">
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <terminal name="fun"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
	  Lambda expressions can be thought as of anonymous local functions.
	  This construct defines such a function and returns it as the
	  functional value. This value can be used just like the name of 
	  regular local function.
        </p>
        <p>
          Example:
        </p>
<code>
List.iter (fun (x) { printf ("%d\n", x) }, intList)
</code>
        <p>
          is equivalent to
        </p>
<code>
def tmpfunc (x) { printf ("%d\n", x) };
List.iter (tmpfunc, intList)
</code>
        <p>
          Lambda expression is indeed translated internally to
        </p>
        <rule name="expr">
          <terminal name="def"/>
          <optional>
            <non-terminal name="method_type_parameters"/>
          </optional>
          <special-terminal name="temporary_name"/>
          <terminal name="("/>
          <non-terminal name="method_parameters"/>
          <terminal name=")"/>
          <optional>
            <terminal name=":"/>
            <non-terminal name="type"/>
          </optional>
          <non-terminal name="block"/>
        </rule>
        <p>
          where <tt>temporary_name</tt> is automatically created by compiler.
        </p>
      </body>
    </subsection>
    <subsection id="list-expr">
      <title>List constructor</title>
      <body>
        <rule name="expr">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="expr"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="expr"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          <tt>[1;2;3]</tt> is translated to <tt>Cons (1, Cons (2, Cons
          (3, Nil ())))</tt>.
        </p>
      </body>
    </subsection>
  </section>

  <section id="expression-helpers">
    <title>Expression helpers</title>
    <body>
      <p>
        This section describes some constructs used in Expressions
        section.
      </p>
    </body>
    <subsection id="sequence">
      <title>Sequence</title>
      <body>
        <rule name="sequence">
          <non-terminal name="expr"/>
          <repeat>
            <terminal name=";"/>
            <non-terminal name="expr"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
        </rule>
        <p>
	  Expressions in the sequence are evaluated sequentially, and the
	  value (and thus the type) of the sequence is the value of the last
	  expression in the sequence.
        </p>
      </body>
    </subsection>
    <subsection id="block">
      <title>Block</title>
      <body>
        <rule name="block">
          <terminal name="{"/>
          <non-terminal name="sequence"/>
          <terminal name="}"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="try-with-handler">
      <title>Try..with handler</title>
      <body>
        <rule name="try_with_handler">
          <non-terminal name="identifier_or_dummy"/>
          <terminal name=":"/>
          <non-terminal name="type"/>
          <terminal name="=&gt;"/>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
      </body>
    </subsection>
    <subsection id="fun-parm">
      <title>Function parameter</title>
      <body>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <non-terminal name="expr"/>
        </rule>
        <p>
        </p>
        <rule name="parameter">
          <optional>
            <terminal name="ref"/>
          </optional>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="expr"/>
        </rule>
        <p>
	  <tt>ref</tt> is used to denote parameter passes by reference. This is
	  not implemented yet, but will have semantics similar as in C#.
        </p>
      </body>
    </subsection>
    <subsection id="match-case">
      <title>Match case</title>
      <body>
        <rule name="guarded_pattern">
          <non-terminal name="pattern"/>
          <optional>
            <terminal name="when"/>
            <non-terminal name="expr"/>
          </optional>
        </rule>
        <p>
	  Guarded pattern requires expression <tt>expr</tt> to be of type
	  <tt>bool</tt>. Given some expression <tt>e</tt> this expression
	  satisfies the guarder pattern only if it is pattern-matched with
	  <tt>pattern</tt> and expression <tt>expr</tt> is evaluated to
	  <tt>true</tt>.
        </p>
        <rule name="match_case">
          <non-terminal name="guarded_pattern"/>
          <repeat>
            <terminal name="|"/>
            <non-terminal name="guarded_pattern"/>
          </repeat>
          <terminal name="=&gt;"/>
          <non-terminal name="sequence"/>
        </rule>
        <p>
	  Given some expression <tt>e</tt> this expression satisfies
	  this match case if and only if it satisfies one of the guarded
	  patterns in this match case.
        </p>
      </body>
    </subsection>
  </section>


  <section id="patterns">
    <title>Patterns</title>
    <body>
      <p>
        Patterns are form of accessing data structures, especially trees.
        Patterns can <i>match</i> values. Definition of the term <i>to
        match</i> is given with each pattern construct. However the
        main idea behind patterns is that they match values that look
        like them.
      </p>
      <p>
        Pattern are used in <a ref="#match-expr">match expression</a>
        and <a ref="#value-def">value definitions</a>.
      </p>
    </body>
    <subsection id="cons-pat">
      <title>Constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="qualified_identifier"/>
          <optional>
            <non-terminal name="pattern"/>
          </optional>
        </rule>
        <p>
          The identifier should refer to name of variant option. This
          pattern matches value iff it is specified variant option,
          and sub-pattern matches variant option payload.
        </p>
      </body>
    </subsection>
    <subsection id="dummy-pat">
      <title>Throw-away pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="_"/>
        </rule>
        <p>
          This pattern matches any value.
        </p>
      </body>
    </subsection>
    <subsection id="record-pat">
      <title>Record pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="{"/>
          <special-terminal name="IDENTIFIER"/>
          <terminal name="="/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=";"/>
            <special-terminal name="IDENTIFIER"/>
            <terminal name="="/>
            <non-terminal name="pattern"/>
          </repeat>
          <optional>
            <terminal name=";"/>
          </optional>
          <terminal name="}"/>
        </rule>
        <p>
          This pattern matches value of class, that has all specified
          fields (this is checked statically), and value of each field
          matches respective pattern.
        </p>
      </body>
    </subsection>
    <subsection id="as-pat">
      <title>As binding</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <terminal name=")"/>
          <terminal name="as"/>
          <special-terminal name="IDENTIFIER"/>
        </rule>
        <p>
          This pattern matches the same value as enclosed pattern
          does. However in addition value matched by enclosed pattern
          is bound to specified variable, which can be used in <tt>when</tt>
          guard or <tt>match</tt> body.
        </p>
      </body>
    </subsection>
    <subsection id="tuple-pat">
      <title>Tuple pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="("/>
          <non-terminal name="pattern"/>
          <repeat>
            <terminal name=","/>
            <non-terminal name="pattern"/>
          </repeat>
          <terminal name=")"/>
        </rule>
        <p>
          This pattern matches a tuple with specified contents (each
          tuple member is matched be respective pattern).
        </p>
        <p>
          In addition, when tuple pattern is seen, where record pattern
          would be otherwise expected -- tuple pattern is transformed
          to record pattern by adding field identifiers in order they
          appear in definition of given class. Tuple pattern transformed
          to record pattern cannot match fields inherited from the
          base class.
        </p>
      </body>
    </subsection>
    <subsection id="list-pat">
      <title>List constructor pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="pattern"/>
          <terminal name="::"/>
          <non-terminal name="pattern"/>
        </rule>
        <p>
          The following two lines are equivalent:
        </p>
<code>
<meta>pattern1</meta> :: <meta>pattern2</meta>
Cons (<meta>pattern1</meta>, <meta>pattern2</meta>)
</code>
      </body>
    </subsection>
    <subsection id="list-lit-pat">
      <title>List literal pattern</title>
      <body>
        <rule name="pattern">
          <terminal name="["/>
          <optional>
            <repeat>
              <non-terminal name="pattern"/>
              <terminal name=";"/>
            </repeat>
            <non-terminal name="pattern"/>
            <optional>
              <terminal name=";"/>
            </optional>
          </optional>
          <terminal name="]"/>
        </rule>
        <p>
          The following are equivalent:
        </p>
<code>
[ <meta>pattern1</meta> ; <meta>pattern2</meta> ; ... ; <meta>patternN</meta> ]
Cons (<meta>pattern1</meta>, Cons (<meta>pattern2</meta>, ... Cons (<meta>pattern2</meta>, Nil) ... ))
</code>
      </body>
    </subsection>
    <subsection id="lit-pattern">
      <title>Literal pattern</title>
      <body>
        <rule name="pattern">
          <non-terminal name="literal"/>
        </rule>
        <p>
          This pattern matches specified constant value.
        </p>
      </body>
    </subsection>
  </section>


  <section id="macros">
    <title>Macros</title>
    <body>
      <p>
        Please refer to <link>macros.html</link> for now.
      </p>
    </body>
  </section>


    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
