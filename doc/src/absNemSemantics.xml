<?xml version='1.0' encoding='UTF-8' ?>
<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Semantics of Abstract-Nem</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document describes semantics of Abstract-Nem language. While
        reasonably precise this document is not formal definition,
        please refer to operational semantics <ps-link ref="absNemOperationalSem" />
        for formal definitions.
      </p>
    </body>
    <subsection id="syntax">
      <title>Syntax</title>
      <body>
        <p>
          Abstract-Nem is rather theoretical vehicle for dynamic
          semantics, to be used in textual descriptions and as datatype
          inside compiler. We here use some written form of it, but
          (opposite to semantics) syntax of Abstract-Nem is not very
          important, as it is not used anywhere (maybe except debugging
          compiler output).
        </p>
      </body>
    </subsection>
  </section>
  <section id="struct">
    <title>Program structure</title>
    <body>
      <p>
        Program in Abstract-Nem is expression. It's evaluated and program
        result is result of this expression.
      </p>
      <p>
        There is no concept of types in Abstract-Nem.
      </p>
    </body>
  </section>
  <section id="expr">
    <title>Expressions</title>
    <body>
      <p>
        It remains to be explained what are possible expressions and
        what they evaluate to.
      </p>
    </body>
    <subsection id="let">
      <title>Name binding using <tt>let</tt></title>
      <body>
        <p> 
          <tt>let</tt> construct provides way of nesting expressions
          and performing computations in some specified order. It is
          basic building block of Abstract-Nem programs.
        </p>
<code>
let <meta>X</meta> = <meta>expression</meta> in <meta>expression</meta>
</code>
        <p>
          Evaluate first expression, bind its value to <meta>X</meta> in
          scope of second expression.  Value of <tt>let</tt> expression
          is value of it's second expression.
        </p>
        <p>
          Example:
        </p>
<code>
let f = "foo" in
let ff = f(f) in
let dummy = g() in
ff
</code>
      </body>
    </subsection>
    <subsection id="string">
      <title>String object construction</title>
      <body>
        <p>
          We need strings in language itself (opposite to let's say integers
          which are orthogonal to the language), since we use them in <tt>.*</tt>
          expression. Strings are written as in:
        </p>
<code>
"foo"
</code>
        <p>
          Value of string is string itself.
        </p>
        <p>
          Strings we're talking about here cannot be manipulated freely
          by the program: it can only construct strings (fixed at compile
          time), copy and pass them around.
        </p>
      </body>
    </subsection>
    <subsection id="unit">
      <title>Unit value</title>
      <body>
        <p>
          Special do-nothing value written: <tt>()</tt>. It is only
          inhabitant of type <tt>void</tt> in C# or <tt>unit</tt> in ML.
          Assignment evaluates to this value. You cannot do much with it.
        </p>
      </body>
    </subsection>
    <subsection id="val-ref">
      <title>Value reference</title>
      <body>
        <p>
          Value is referenced by simply mentioning its name in expression
          context. For example:
        </p>
<code>
let x = "foo" in   (* Here we define x. *)
let y = x in       (* And here we reference it... *)
x                  (* ...and again. *)
</code>
        <p>
          Values that can be referenced are:
        </p>
        <ul>
          <li>Local value bound with <tt>let</tt></li>
          <li>Functional value defined with <tt>fun</tt></li>
          <li>Formal function parameter (inside <tt>fun</tt>)</li>
          <li>Exception value bound in <tt>catch</tt></li>
        </ul>
        <p>
          Value reference evaluates to referenced value. Referenced values
          needs to be defined first (except in <a ref="#fun"><tt>fun</tt> 
          construct</a>).
        </p>
      </body>
    </subsection>
    <subsection id="obj">
      <title>Object construction</title>
      <body>
        <p>
          Complex objects are constructed by listing pairs of
          <tt><meta>field-name</meta> = <meta>expression</meta></tt>
          pairs in curly braces. <meta>expression</meta> to be used
          there is limited to value reference. Example:
        </p>
<code>
let f = "foo" in
let b = "bar" in
let o = { name = f; ref val = b; } in
...
</code>
        <p>
          As seen above it is also possible to mark that specified fields
          of object can be later changed using <tt>ref</tt>.
        </p>
        <p>
          Value of object constructor is constructed object. Each time
          object constructor is evaluated -- fresh object is created.
        </p>
      </body>
    </subsection>
    <subsection id="field-access">
      <title>Object field access</title>
      <body>
        <p>
          Once object is constructed we can access it's fields using dot operator.
          For example (continue example from <a ref="#obj">above</a>):
        </p>
<code>
...
let n = o . name in  (* n now holds value "foo" *)
...
</code>
        <p>
          It is runtime error to refer to undefined field.
        </p>
      </body>
    </subsection>
    <subsection id="indirect-field-access">
      <title>Indirect object field access</title>
      <body>
        <p>
          The <tt>.*</tt> operator allows accessing field, name
          of which is stored (as string) in some other location.
          It is used for <tt>tymatch</tt> translation.
        </p>
<code>
...
let field_name = "val" in
let v = o .* field_name in      (* v holds "bar" *)
...
</code>
        <p>
          It is runtime error to refer to undefined field.
        </p>
      </body>
    </subsection>
    <subsection id="func-call">
      <title>Function call</title>
      <body>
        <p>
          Function call applies functional value to actual parameters,
          which causes evaluation of function code with formal parameters
          replaced by actual ones.
        </p>
        <p>
          Functional values are created using <a ref="#fun"><tt>fun</tt>
          construct</a>.
        </p>
        <p>
          Both function value and actual parameters are restricted to
          value references.
        </p>
        <p>
          Function call is done using parentheses:
        </p>
<code>
f(x, y, z)
</code>
      </body>
    </subsection>
    <subsection id="fun">
      <title>Function definitions using <tt>fun</tt></title>
      <body>
        <p>
          <tt>fun</tt> defines functional values. Several values
          can be defined at once to allow mutual recursion. All function
          names bound in given <tt>fun</tt> are available in
          all it's defining expressions.
        </p>
        <p>
          It looks like this:
        </p>
<code>
(* Loop forever: *)
let f(x) = g(x)
and g(x) = f(x)
in g("foo")

let fst(x, y) = x in
let snd(x, y) = y in
...
</code>
      </body>
    </subsection>
    <subsection id="assignment">
      <title>Assignment</title>
      <body>
        <p>
          There are two kinds of assignment:
        </p>
        <ul>
          <li>Assignment to object member: <tt>obj.fld &lt;- val</tt></li>
          <li>Indirect assignment to object member: <tt>obj.*fld &lt;- val</tt></li>
        </ul>
        <p>
          Assignment is only allowed for field marked with <tt>ref</tt>
          upon object construction.  Value of assignment is <tt>()</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="match">
      <title>Checking string value using <tt>match</tt></title>
      <body>
        <p>
          Match can check which one of specified set of constant strings
          specified value holds. It looks like:
        </p>
<code>
match x with [
  | "string1" -> expr1
  | "string2" -> expr2
  | "string3" -> expr3
  ...
  | _ -> expr-for-default
]
</code>
      </body>
    </subsection>
    <subsection id="exns">
      <title>Exception handling with <tt>try</tt> and <tt>raise</tt></title>
      <body>
        <p>
          <tt>raise <meta>X</meta></tt> causes control to be transfered
          to <tt>catch</tt> part of nearest enclosing <tt>try</tt>
          expression.
        </p>
<code>
try <meta>expression</meta> catch (?<meta>Y</meta>) <meta>expression</meta>
</code>
        <p>
          In normal circumstances value of <tt>try</tt> block is first
          expression. However is <tt>raise <meta>X</meta></tt> is met
          during evaluation of first expression, value of <meta>X</meta>
          is bound to name <meta>Y</meta> in scope of second expression,
          which is evaluated and returned.
        </p>
      </body>
    </subsection>
  </section>
</document>

    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->

<!-- vim: expandtab sw=2
  -->
