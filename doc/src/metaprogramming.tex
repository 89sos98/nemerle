% Meta-programming in Nemerle
%
\documentclass{llncs}
%
\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\netf}[0]{{\tt .NET} framework}
\newcommand{\nem}[0]{Nemerle}
\newcommand{\cs}[0]{C\#}
\newcommand{\oo}[0]{object-oriented}
\newcommand{\kw}[1]{{\tt \bf #1}}
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%
\title{Meta-programming in New Functional \net\ Language Nemerle}
%
\titlerunning{Meta-programming in Nemerle}  
%
\author{Kamil Skalski \and Micha³ Moskal \and Pawe³ Olszta}
%
\authorrunning{Kamil Skalski et al.} 
%
%
\institute{University of Wroc³aw, Poland \\
           \texttt{http://www.nemerle.org}}
%
\maketitle              % typeset the title of the contribution
%
\begin{abstract}
We present design of meta-programming system embedded in new functional
language \nem incorporated into \net\ platform. It gives wide set of
operations performed on code at compile time, including program generation,
transformation and automated analysis. It provides good support for Aspects 
Oriented Programming, extending code with various features parametrized by
external data, while still strong typing it during compilation.
%
\nem\ and its macros are intended to easily introduce functional methods
and power of meta-programming to programmers with \cs-like background. 
Our focus is set on creating simple syntax, while not loosing power of
its expressiveness.
\end{abstract}
%
\section{Introduction}
Idea of compile-time meta-programming has been studied for quite a long time.
It was incorporated into several languages, like Common-Lisp macros 
\cite{CommonLisp}, C preprocessor-based macros, C++ template system and finally 
Haskell Template Meta-programming \cite{MetaHaskell}. 
They vary on their power and ease of use, but generally involves computations 
made during compile-time and generating code from some definitions.

Programs are becoming \emph{object programs}, which are data for meta-programs.
They can be arbitrarily transformed or analyzed and final result is then compiled
as regular program. This process may be repeated or take place in stages.

\emph{Meta language} is the language for programming those operations. It 
commonly has its own syntax for describing various constructs of object language.
For example \verb,<[ 1 + 1 ]>,
is our annotation for syntax tree of expression \verb,1+1,. This idea is called 
\emph{quasi-quotation}. 

\subsection{Our contribution}
We add some new ideas about syntax of meta language and usage of new technologies 
to connect great abilities of meta-programming with top industrial standards in
computer technology:
\begin{itemize}
  \item We develop uniform and simple quasi-quotation system, which doesn't require
    learning of any keywords to write quite complicated macros. It also contains easy
    way to write variable argument constructs (like tuples, functions with arbitrary
    amount of parameters)
  \item Using macros is transparent from user's point of view - it is not possible
    to distinguish between calling meta-program and common function, so user
    can use other's work without even knowing idea of meta-programming
  \item Syntax extensions allow even greater embedding of macros into language,
    which provides method to easily customize it to one's needs, without interfering
    with compiler internals
  \item Our system can be used to transform or generate practically any fragment
    of program, which composed with \net\ \oo\ structure gives powerful tools for
    software engineering methodologies
  \item We allow macros to type fragments of code, which they operate on, during
    their execution. It can be very useful to make them more independent of 
    the shape of data they are transforming
\end{itemize}

\subsection{Characteristics of \nem 's meta-system} 
Our meta-system has both \emph{program generation} and \emph{analysis}
capabilities \cite{Accomplishments:Meta}.
It can easily walk through abstract syntax tree of program and gather informations
about it as good as changing it (often using gathered data).

System is mainly designed for operating on object programs at compile-time,
but using features of \net\ and its dynamic code loading abilities, it is also
possible to execute macros during run-time. Taking this idea to the extreme, we
can use generated code as generator of another code, leading us to 
\emph{multi-stage system}. It never requires to run macros separately from 
compiling target program (in contrast to so-called \emph{static} code generators 
like Yacc).

Meta-language is \emph{homogeneous}, which means that it's the same as object 
language. We can use common \nem\ functions within macros and the syntax 
of generated programs is no different than one used to write macros.

Quasi-quotation provides clear separation of object program from meta-language.
It's semantically clear which part of code is generated and which generates.
This manual annotation gives us way to separate stages of execution in well
understood fashion. Although we allow only two level quotation, to do not confuse
programmer by multi layered code, it's easy to recurse through structure of
program.

\section{First examples}
Let's suppose we want to add some new syntax to our language, like
\kw{for} loop. We could embedd it into compiler, but it is rather hard,
inelegant way. This addition it quite short and shouldn't
involve much effort to complete. And here is the place, where we can
use macro.

\begin{verbatim}
macro for (init, cond, change, body) {
  <[ { $init;
       def forloop () {
         if ($cond) { $body; $change; forloop() } 
         else () 
       }; 
       forloop ()
     }
  ]>
}
\end{verbatim}

This code creates special meta-function, which, for every place where it's
called, is executed during compile-time. After that, its result is 
inserted into program. Always when we write something like
\begin{verbatim}
for (i <- 0; i < n; i <- i + 2, a[i] <- i)
\end{verbatim}
appropriate code is created according to the \kw{for} macro, 
which replaces orginal call.

We can also instruct compiler to extend its syntax, to allow usual (C-like)
usage of \kw{for} loop. Writing
\begin{verbatim}
macro for (init, cond, change, body) 
syntax ("for", "(", init, cond, change, ")", body) {
...
}
\end{verbatim}
would add new rule to parser, which allows using
\begin{verbatim}
for (i <- 0; i < n; i <- i + 2) a[i] <- i
\end{verbatim}
as shortcut to call mentioned before.

Macros are very useful for initial checking and processing of code
written as strings in programs. This relates to many simple languages,
like SQL, regular expressions, printf formatting string, which are often
used in programs directly. 

Let's consider common situation, when we want to parametrize SQL query
with some values from our program. Most database providers in 
\netf\ allows us to write commands with parameters, but neither their
syntax is checked during compilation, nor types are controlled to agree
between database and program.

With well written macro, we could write
\begin{verbatim}
  sql_loop (conn, "SELECT salary, LOWER (name) AS lname"
                  "  FROM employees"
                  "  WHERE salary > $min_salary",
            print ("$lname : $salary\n"))
\end{verbatim}

to obtain syntax and type-checked SQL query and code of following form
\begin{verbatim}
  def cmd = SqlCommand ("SELECT salary, LOWER (name)"
                        "  FROM employees"
                        "  WHERE salary > @parm1", conn);

  (cmd.Parameters.Add (SqlParameter ("@parm1", DbType.Int32)))
    .Value <- min_salary;
  def r = cmd.ExecuteReader ();
  while (r.Read ()) {
    def salary = r.GetInt32 (0);
    def lname = r.GetString (1);
    print ("$lname : $salary\n")
  }
\end{verbatim}

In fact in the 9th line of output we see another extension, that is translated
to:

\begin{verbatim}
  System.Console.Write (lname.ToString ());
  System.Console.Write (" : ");
  System.Console.Write (salary.ToString ());
  System.Console.Write ("\n")
\end{verbatim}

\section{Variable amount of arguments}

\begin{verbatim}
macro sql_loop (conn, query : string, body) {
  def (columns, parameters) = parse_sql (query);
  <[ { def cmd = SqlCommand ($(query : string), conn);
       {.. $(create_parameters (parameters, 0, [])) };
       def r = cmd.ExecuteReader ();
       while (r.Read ()) 
         {.. $(create_results (columns, 0, [body])) } } ]>
}
\end{verbatim}

First we need to parse query string to check if it is a proper SQL
statement. We do this during execution of macro with function
\begin{verbatim}
parse_sql : string ->   list (string * string) 
                      * list (string * string)
\end{verbatim}
which returns lists of columns and parameters used in query. This
function returns also their types, which it must obtain by accesing
database (during compile-time) or reading special files describing
it. We do not include definition of this function, because it doesn't
relate to this paper and involves only parsing and database manipulation.

More interesting things happen later, when we want to include preparation
of parameters and reading of columns into result of our macro. It's done
by creating sequences of expressions from lists returned by local functions
\verb,create_parameters, and \verb,create_results,. Special syntax 
\verb,{.. $args }, is used to build sequence, which can
have variable amount of arguments and we can't just write
\verb,{ e1; e2; ... },. 

\begin{verbatim}
  def create_parameters (parms, i, acc) {
    match (parms) {
      | [] => List.rev (acc)
      | (name, type_name) :: xs =>
        create_parameters ( xs, i + 1, <[ (cmd.Parameters.Add 
          (SqlParameter ($("@parm" + i.ToString() : string),
          DbType.$(type_name : var)))).Value <- $(name : var); 
        ]> :: acc)
    }
  };
  def create_results (res, i, acc) {
    match (parms) {
      | [] => List.rev (acc)
      | (res_name, type_name) :: xs =>
        create_results ( xs, i + 1
         <[ def $(res_name : var) = 
             r.$("Get" + type_name : name) ($(i : int)) ]> :: acc)
    }
  };
\end{verbatim}

Those functions use types returned by \verb,parse_sql,
to build assignments and casts, that are typesafe.

Quotion gives us full freedom in constructing any kind of expression.
For example we can decompose tuples of any size and print its elements.

\begin{verbatim}
macro print_tuple (tup, size : int) {
  mutable pvars <- [];
  for (mutable i <- n; i > 0; i <- i - 1)
    vars <- <[ pattern: $("elem" + i.ToInt32() : var) ]> :: vars;
  mutable exps <- [];
  for (mutable i <- n; i > 0; i <- i - 1)
    exps <- <[ System.WriteLine ($("elem" + i.ToInt32() : var)) ]> 
            :: exps;
  exps = <[ def (.. $pvars) = $tup ]> :: exps;
  <[ {.. $exps } ]>
}
\end{verbatim}

Note that here we need number describing size of tuple. Later, we show how
to obtain type of given expression within macro, thus also size of tuple
described by \verb,tup, variable.

\section{Pattern matching on programs}
Quotation can be used to analyze structure of program as easily as generate
it. Standard mechanisms of language, like pattern matching, fit perfect
for such a purpose. 

Let's suppose, we want to check code for occurences of following buggy
fragments:
\begin{verbatim}
if ( foo != null && foo.bar || foo.blah ) foo.blah
\end{verbatim}

We write macro, which inspects given program to signal such constructs.
\begin{verbatim}
macro analyze (exp) : void {
  def traverse (ex, checked) {
    match (exp) {
      | <[ $(name : var) != null ]> => checked.Add (name)
      | <[ $(name : var).$(_) ]> => 
        if (!checked.Contains (name)) 
          raise MaybeBug() 
        else 
          checked
      | <[ $e1 && $e2 ]> => traverse (e2, traverse (e1, checked))
      | <[ $e1 || $e2 ]> => 
        def chck1 = traverse (e1, checked);
        def chck2 = traverse (e2, checked);
        Intersect (chck1, chck2)
      | <[ if ($cond) $e1 else $e2 ]> =>
        traverse (e1, traverse (cond, checked));
        traverse (e2, checked)
      | _ => Macros.apply_expr (fun (x) { traverse (x, checked) }, 
                                exp)
    }
  };
  Macros.apply_expr (fun (x) { traverse (x, Set ()) }, exp)
}
\end{verbatim}

\section{Macros on declarations}
Macros can operate not only on expressions, patterns, types, but on
any part of language, like classes, interfaces, type declarations.
It's done by simply adding name of given construct from grammar at
the beggining of quotation, as we've seen before.

With such a tool, we can analyze, generate or change any declaration
in program. For example, dump definition of each data structure 
to XML file, create serialization methods, automatically
generate them from external description.

Usage of such macros is a little bit different. They aren't called
like ordinary functions, but added like attributes at the head
of declaration.

\begin{verbatim}
public [ToXML ("Company")] module Company {
  public [SerializeBinary ()] class Employee {
    ...
  }
  public [FromXML ("Product")] [Comparable ()] class Product;
}
\end{verbatim}

\section{Aspects-oriented programming}
AOP has been proposed as technique for separating of different 
\emph{concerns} in software. It's often a problem, when they crosscut 
natural modularity of the rest of implementation and must be written 
together in code, leading to tangled code. 

In contrary to many other systems, which define fixed \emph{join points}
in code (like AcpectJ), macros allow to place user code in arbitrary
parts of program. One can write a macro, which traverses all classes
and add some behaviour to their bodies. Defining these points isn't
restricted to any design, but user can write a program that defines them.

In general it should be possible to implement most Aspects-oriented
and Adaptive-programming systems' design with few macros.

\section{Details of our design}
\subsection{Names binding}
\subsection{Accesing compiler internals}
\subsection{Failure within macro}

\section{Typing during execution of macro}


\section{How it works}
\subsection{Operating on parsetrees}
\subsection{Typing macros}
\subsection{Compiling and loading}

\section{Related works}

%
% ---- Bibliography ----
%
\begin{thebibliography}{}
%
\bibitem {CommonLisp}
Scheme Lisp

\bibitem {MetaHaskell}
Sheard, T., Jones, S. P.:
Template Meta-programming for Haskell.
Haskell Workshop, Oct. 2002, Pittsburgh

\bibitem {Accomplishments:Meta}
Sheard, T.:
Accomplishments and Research Challenges in Meta-Programming
2001

\end{thebibliography}

\end{document}
