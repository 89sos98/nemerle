/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using SCG = System.Collections.Generic;

namespace Nemerle.Utility 
{
  /**
   * Helper functions, absent from System.Array.
   */
  public module NArray
  {
    /**
     * Iterates a function over an array.
     */
    public Iter ['a] (this arr : array ['a], f : 'a -> void) : void
    {
      def loop (i)
      {
        when (i < arr.Length) {
          f (arr [i]);
          loop (i + 1)
        }
      }
      
      loop (0)
    }


    /** Return a fresh copy of [arr] with first [n] elements removed.  */
    public ChopFirstN ['a] (this arr : array ['a], n : int) : array ['a]
    {
      if (arr.Length < n)
        throw System.ArgumentException ("NArray.ChopFirstN called for too short array")
      else {
        def res = array (arr.Length - n);
        System.Array.Copy (arr, n, res, 0, res.Length);
        res
      }
    }

    
    /** Return a fresh copy of [arr] with last [n] elements removed.  */
    public ChopLastN ['a] (this arr : array ['a], n : int) : array ['a]
    {
      if (arr.Length < n)
        throw System.ArgumentException ("NArray.LastFirstN called for too short array")
      else {
        def res = array (arr.Length - n);
        System.Array.Copy (arr, 0, res, 0, res.Length);
        res
      }
    }

    
    /**
     * Iterates a function over an array, passing both the array index
     * and value as the iterated function parameters.
     */
    public IterI ['a] (this arr : array ['a], f : int * 'a -> void) : void
    {
      def loop (i)
      {
        when (i < arr.Length) {
          f (i, arr [i]);
          loop (i + 1)
        }
      }
      
      loop (0)
    }
    
    public Map ['a, 'b] (this ar : array ['a], f : 'a -> 'b) : array ['b]
    {
      def result = array (ar.Length);

      for (mutable i = 0; i < ar.Length; ++i)
        result [i] = f (ar [i]);

      result
    }

    public Map ['a, 'b] (res_type : System.Type, ar : array ['a], f : 'a -> 'b) : array ['b]
    {
      assert (typeof ('b).Equals (res_type));
      Map (ar, f)
    }


    /**
     * Folds a function over an array.
     */
    public Fold ['a, 'b] (this arr : array ['b], ini : 'a, f : 'b * 'a -> 'a) : 'a
    {
      def loop (acc, i)
      {
        if (i >= arr.Length) acc
        else loop (f (arr [i], acc), i + 1)
      }
      
      loop (ini, 0)
    }


    /**
     * Folds a function over an array, passing the array index
     * as an additional parameter to the folded function parameters.
     */
    public FoldI ['a, 'b] (this arr : array ['b], ini : 'a, f : int * 'b * 'a -> 'a) : 'a
    {
      def loop (acc, i)
      {
        if (i >= arr.Length) acc
        else loop (f (i, arr [i], acc), i + 1)
      }
      
      loop (ini, 0)
    }

    
    /**
     * Returns 'true' if at least one of the 'l' arrays's elements
     * satisfies the condition 'f'.
     *
     * Example of use:
     *
     *   NArray.Exists (array ["a", "b", "abc", "d", "e"], fun (x) { x.Length > 2 })
     *
     * evaluates to 'true' as there is one string of length 3 on the list.
     */
    public Exists ['a] (this a : array ['a], f : 'a -> bool) : bool
    {
      def walk_array (i : int) : bool
      {
        i < a.Length && (f (a [i]) || walk_array (i + 1))
      }

      walk_array (0)
    }

    
    /**
     * Returns 'true' if exactly all of the 'l' arrays's elements
     * satisfy the condition 'f'.
     *
     * Example of use:
     *
     *   NArray.ForAll (array [2, 4, 6, 8, 10], fun (x) { x % 2 == 0 })
     *
     * evaluates to 'true' as all the array's elements are even integers.
     */
    public ForAll ['a] (this a : array ['a], f : 'a -> bool) : bool
    {
      def walk_array (i : int) : bool
      {
        i >= a.Length || (f (a [i]) && walk_array (i + 1))
      }

      walk_array (0)
    }

    public FromList ['a] (t : System.Type, x : list ['a]) : array ['a]
    {
      assert (t.Equals (typeof ('a)));
      x.ToArray ()
    }

    public ToList ['a] (this arr : array ['a]) : list ['a]
    {
      List.FromArray (arr)
    }

    public Iter2['a, 'b] (a : list ['a], b : array ['b], f : 'a  * 'b -> void) : void {
      def loop (l, acc) : void {
        match (l) {
          | [] => () 
          | x :: xs => f (x, b [acc]); loop (xs, acc + 1)
        }
      }

      loop (a, 0)
    }

    public Iter2['a, 'b] (a : array ['a], b : list ['b], f : 'a  * 'b -> void) : void {
      def loop (l, acc) : void {
        match (l) {
          | [] => ()
          | x :: xs  => f (a [acc], x); loop (xs, acc + 1)
        }
      }

      loop (b, 0)
    }

    public Map2['a, 'b, 'c] (a : list ['a], b : array ['b], f : 'a * 'b -> 'c) : list ['c] {
      def loop (l, acc) : list ['c] {
        match (l) {
          | [] => []
          | x :: xs => f (x, b [acc]) :: loop (xs, acc + 1)
        }
      }

      loop (a, 0)
    }

    public Map2['a, 'b, 'c] (a : array ['a], b : list ['b], f : 'a * 'b -> 'c) : list ['c] {
      def loop (l, acc) : list ['c] {
        match (l) {
          | [] => []
          | x :: xs => f (a [acc], x) :: loop (xs, acc + 1)
        }
      }

      loop (b, 0)
    }

    public RevMap2['a,'b,'c] (a : list ['a], b : array ['b], f : 'a * 'b -> 'c) : list ['c] {
      def loop (x, i, acc) : list ['c] {
        match (x) {
          | [] => acc
          | h :: t => loop (t, i + 1, f (h, b [i]) :: acc)
        }
      }

      loop(a, 0, [])
    }

    public RevMap2['a,'b,'c] (a : array ['a], b : list ['b], f : 'a * 'b -> 'c) : list ['c] {
      def loop (x, i, acc) : list ['c] {
        match (x) {
          | [] => acc
          | h :: t => loop (t, i + 1, f (a [i], h) :: acc)
        }
      }

      loop(b, 0, [])
    }

    public FoldLeft2['a, 'b, 'c] (a : list ['a], b : array ['b], acc : 'c, f : 'a  * 'b * 'c -> 'c) : 'c {
      def loop (x, i, ac) : 'c {
        match (x) {
          | [] => ac
          | h :: t => loop (t, i + 1, f (h, b [i], ac))
        }
      }

      loop (a, 0, acc)
    }

    public FoldLeft2['a, 'b, 'c] (a : array ['a], b : list ['b], acc : 'c, f : 'a  * 'b * 'c -> 'c) : 'c {
      def loop (x, i, ac) : 'c {
        match (x) {
          | [] => ac
          | h :: t => loop (t, i + 1, f (a [i], h, ac))
        }
      }

      loop (b, 0, acc)
    }

    public FoldRight2['a, 'b, 'c] (a : list ['a], b : array ['b], c : 'c, f : 'a * 'b  * 'c -> 'c) : 'c {
      def loop (x, i, acc) : 'c {
        match (x) {
          | [] => acc
          | h :: t => f (h, b [i], loop (t, i + 1, acc))
        }
      }

      loop (a, 0, c)
    }

    public FoldRight2['a, 'b, 'c] (a : array ['a], b : list ['b], c : 'c, f : 'a * 'b  * 'c -> 'c) : 'c {
      def loop (x, i, acc) : 'c {
        match (x) {
          | [] => acc
          | h :: t => f (a [i], h, loop (t, i + 1, acc))
        }
      }

      loop (b, 0, c)
    }

    public ForAll2['a, 'b] (a : list ['a], b : array ['b], f : 'a * 'b -> bool) : bool {
      def loop (x, i) : bool {
        match (x) {
          | [] => true
          | h :: t => f (h, b[i]) && loop (t, i + 1)
        }
      }

      loop (a, 0)
    }

    public ForAll2['a, 'b] (a : array ['a], b : list ['b], f : 'a * 'b -> bool) : bool {
      def loop (x, i) : bool {
        match (x) {
          | [] => true
          | h :: t => f (a [i], h) && loop (t, i + 1)
        }
      }

      loop (b, 0)
    }

    public Exists2['a, 'b] (a : array ['a], b : list ['b], f : 'a * 'b -> bool) : bool {
      def loop (x, i) : bool {
        match (x) {
          | [] => false
          | h :: t => f (a [i], h) || loop (t, i + 1)
        }
      }

      loop (b, 0)
    }

    public Exists2['a, 'b] (a : list ['a], b : array ['b], f : 'a * 'b -> bool) : bool {
      def loop (x, i) : bool {
        match (x) {
          | [] => false
          | h :: t => f (h, b [i]) || loop (t, i + 1)
        }
      }

      loop (a, 0)
    }

    /**
     * Cast array to covariant subtype.
     */
    public ToBase[Derive, Base] (this sourse : array [Derive]) : array [Base]
      where Base: class
      where Derive: Base, class
    {
      (sourse : object) :> array [Base]
    }

    /**
     * Convert array of one type to other.
     */
    public ConvertTo[From, To] (this sourse : array [From], f : From -> To) : array [To]
    {
      mutable dest = array(sourse.Length);
      
      for (mutable i = 0; i < sourse.Length; i++)
        dest[i] = f (sourse[i]);
        
      dest;
    }

    /** Convert collection to array. */
    public ToArray[T] (this sourse : SCG.ICollection[T]) : array [T]
    {
      if (sourse is null)
        array (0)
      else
      {
        def tmp = array (sourse.Count);
        sourse.CopyTo (tmp, 0);
        tmp
      }
    }

    /** Convert sequence to array. */
    public ToArray[T] (this sourse : SCG.IEnumerable [T]) : array [T]
    {
      match (sourse)
      {
        | coll is SCG.ICollection[T] => coll.ToArray();
        | null => array (0);
        | _ =>
          def dest = SCG.List();

          foreach (elem in sourse)
            dest.Add(elem);
            
          dest.ToArray()
      }
    }

    /**
     * Convert collection of one type to array of another type.
     */
    public ToArray[From, To] (this sourse : SCG.ICollection[From], 
      f : From -> To) : array [To]
    {
      if (sourse is null)
        array (0)
      else
      {
        def tmp = array (sourse.Count);
        sourse.CopyTo (tmp, 0);
        tmp.ConvertTo (f)
      }
    }

    /**
     * Convert sequence of one type to array of another type.
     */
    public ToArray[From, To] (this sourse : SCG.IEnumerable [From], 
      f : From -> To) : array [To]
    {
      match (sourse)
      {
        | coll is SCG.ICollection[From] => coll.ToArray (f);
        | null => array (0);
        | _ =>
          def dest = SCG.List();

          foreach (elem in sourse)
            dest.Add(f (elem));
            
          dest.ToArray()
      }
    }

    /** Attention! It's inplace sort. */
    public SortInplace[T] (this sourse : array [T], comparison : System.Comparison[T]) : array [T]
    {
      System.Array.Sort(sourse, comparison);
      sourse
    }

    //FixMe: narray.n(457,37,457,58): error : Internal compiler error, please report 
    // a bug to bugs.nemerle.org. Yon ``False'' failed in file generation/Typer4.n, line 186:
    ///** Attention! It's inplace sort. */
    //public Sort[T, Val] (this sourse : array [T], getComparableValue : T -> Val) : array [T]
    //  where Val: System.IComparable[Val]
    //{
    //  def Cmp(x : T, y : T) : int
    //  {
    //    getComparableValue(x).CompareTo(getComparableValue(y))
    //  }
    //  System.Array.Sort.[T](sourse, System.Comparison.[T](Cmp));
    //  sourse
    //}

    public Clone[T](this sourse : T) : T
      where T: System.ICloneable
    {
      (sourse.Clone() :> T)
    }

    /** Convert array to string. */
    public ToString['a] (this sourse : array ['a], separator : string) : string
    {
      string.Join(separator, sourse.ConvertTo(value => value.ToString()));
    }
  }
} /* end of namespace */
