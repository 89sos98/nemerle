<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003, 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>Nemerle type-safe macros</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        You can think about macros as of a system of compile-time transformations 
        and automatic generation of code with regard to some rules. 
        It can be used either to automate manipulations performed on similar
        data-types and fragments of code or to add syntax shortcuts to the language,
        optimize and make some computations safer by moving them from runtime
        to compile-time.
      </p>
      <p>
        The idea of making simple inline operations on the code comes from preprocessor
        macros, which many languages (especially C, C++) have contained since early 
        times of compiler design. We are following them in the direction of much more
	powerful, and at the same time more secure (type-safe) solutions
	like Haskell Template Meta-programming.
      </p>
    </body>
  </section>
  <section id="features">
    <title>Key features</title>
      <body>
        <ul>
          <li>built-in ability of extending language syntax</li>
	  <li>creating functions, whose amount and type of arguments depend
	    on each other (like C printf) with full type-checking during
            compile-time</li>
	  <li>algorithmic generation of code, which may be dependent on
	    external factors, like XML files, script programs, databases or 
            even remote web sites </li>
	  <li>completing datatypes with automatically created methods for
            performing arbitrary operations, e.g. reading datasets from a file,
	    sending them through the network or storing in an SQL database</li>
	  <li>using the context of compilation provided by compiler's internal
	    structures, like line numbers (for error reporting), names of
	    processed type, function, class or namespace and accessing
            datatype definitions by name</li>
	</ul>
    </body>
  </section>
  <section id="description">
    <title>What exactly is a macro?</title>
      <body>
        <p>
	  Basically every macro is a function, which takes a fragment
	  of code as parameter(s) and returns some other code. On the highest 
	  level of abstraction it doesn't matter if parameters are function calls, 
          type definitions or just a sequence of assignments. The most important fact is 
          that they are not common objects (e.g. instances of some types, like 
          integer numbers), but their internal representation in the compiler (i.e. 
          syntax trees).
	</p>
	<p>
	  A macro is defined in the program just like any other function, using
          common Nemerle syntax. The only difference is the structure of the data 
          it operates on and the way how it is used (executed at compile-time). 
	</p>
	<p>
	  A macro, once created, can be used to process some parts of the code.
	  It's done by calling it with block(s) of code as parameter(s). 
	  This operation is in most cases indistinguishable from a common function
	  call (like <tt>f(1)</tt>), so a programmer using a macro would not be confused 
          by unknown syntax. The main concept of our design is to make the usage of macros 
          as transparent as possible. From the user point of view, it is not 
          important if particular parameters are passed to a function, 
          which would process them at the compile-time and insert some new 
          code in their place, or to an ordinary one.
	</p>
      </body>
  </section>
  <section id="defining">
    <title>Defining a new macro</title>
      <body>
        <p>
          Writing the macro is as simple as writing the common function. It looks
          the same except it is preceded by a keyword <tt>macro</tt>. 
          This will make the compiler know about how to use defined method 
          (i.e. run it at the compile-time in every place where it is used). 
        </p>
        <p>
          Macros can take zero (if we just want to generate new code)
          or more parameters. They are all elements of the language 
          grammar, so their type is limited to the set of defined
          syntax objects. The same holds for a return value of a macro.
        </p>
        <p>
          Example:
        </p>  
<code>
macro generate_expression ()
{
  compute_some_expression ();
}
</code>
        <p>
          This example macro does not take any parameters and is used in the
          code by simply writing <tt>generate_expression ();</tt>. 
          The most important is the difference between <tt>generate_expression</tt>
          and <tt>compute_some_expression</tt> - the first one is a function
          executed by the compiler during compilation, while the latter is just
          some common function that must return syntax tree of expression
          (which is here returned and inserted into program code by
            <tt>generate_expression</tt>).
        </p>
        <subsection id="compiling">
          <title>Compiling a simplest macro</title>
            <body>
              <p>
                In order to create and use a macro you have to write a
                library, which will contain its executable form. You simply 
                create a new file <tt>mymacro.n</tt>, which can contain for 
                example
              </p>
<code>
macro m () {
  Nemerle.IO.printf ("compile-time\n");
  &lt;[ Nemerle.IO.printf ("run-time\n") ]&gt;
}
</code>
              <p>
                and compile it with command
              </p>
<code>
ncc -r Nemerle.Compiler.dll -tdll mymacro.n -o mymacro.dll
</code>
              <p>
                The library <tt>Nemerle.Compiler.dll</tt> will be probably
                loaded automatically in future releases. 
              </p>
              <p>
                Now you can use <tt>m()</tt> in any program, like here
              </p>
<code>
module M {
  public Main () : void {
    m ();
  }
}
</code>
              <p>
                You must add a reference to <tt>mymacro.dll</tt> during 
                compilation of this program. It might look like
              </p>
<code>
ncc -r mymacro.dll myprog.n -o myprog.exe
</code>
            </body>
        </subsection>
        <subsection id="exercise_4a">
          <title>Exercise 4.1</title>
            <body>
              <p>
                Write a macro, which, when used, should slow down the compilation by 5 seconds
                (use <tt>System.Timers</tt> namespace) and print the version of the operating
                system used to the compile program (use <tt>System.Environment</tt> namespace).
              </p>
            </body>
        </subsection>
      </body>
  </section>      
  <section id="syntax_trees">
    <title>Operating on syntax trees</title>
      <body>
        <p>
          Definition of function <tt>compute_some_expression</tt> might look
          like:
        </p>
<code>
compute_some_expression () : Expr 
{
  if (debug_on) 
    &lt;[ System.Console.WriteLine ("Hello, I'm debug message") ]>
  else
    &lt;[ () ]>
}
</code>
        <p>
          The examples above show a macro, which conditionally inlines expression
          printing a message. It's not quite useful yet, but it has introduced the
          meaning of compile-time computations and also some new syntax used only 
          in writing macros and functions operating on syntax trees.
          We have written here the <tt>&lt;[ ... ]&gt;</tt> constructor to
          build a syntax tree of expression (e.g. '<tt>()</tt>').
        </p>
        <subsection id="quotation">
          <title>Quotation operator</title>
            <body>
              <p>
                <tt>&lt;[ ... ]&gt;</tt> is used to both construction and 
                decomposition of syntax trees. Those operations are similar to
                quotation of code. Simply, everything which is written inside 
                <tt>&lt;[ ... ]&gt;</tt>, corresponds to its own syntax tree. 
                It can be any valid Nemerle code, so a programmer does not have to 
                learn internal representation of syntax trees in the compiler.
             </p>
<code>
macro print_date (at_compile_time)
{                   
  match (at_compile_time) {
    | &lt;[ true ]> => print_compilation_time ()
    | _ => &lt;[ WriteLine (DateTime.Now.ToString ()) ]>
  }
}
</code>
              <p>
                The quotation alone allows using only constant expressions, which
                is insufficient for most tasks. For example, to write function
                <tt>print_compilation_time</tt> we must be able to create an expression
                based on a value known at the compile-time. In next sections we introduce
                the rest of macros' syntax to operate on general syntax trees.
              </p>
            </body>
        </subsection>
        <subsection id="spliced">
          <title>Matching subexpressions</title>
            <body>
              <p>
                When we want to decompose some large code (or more precisely, 
                its syntax tree), we must bind its smaller parts to variables.
                Then we can process them recursively or just use them in an
                arbitrary way to construct the result.
              </p>
              <p>
                We can operate on entire subexpressions by writing 
                <tt>$( ... )</tt> or <tt>$ID</tt> inside the quotation operator 
                <tt>&lt;[ ... ]&gt;</tt>. This means binding the value of 
                <tt>ID</tt> or the interior of parenthesized expression to the part of 
                syntax tree described by corresponding quotation.
              </p>
<code>
macro for (init, cond, change, body)
{
  &lt;[ 
    $init;
    def loop () : void {
      if ($cond) { $body; $change; loop() } 
      else ()
    };
    loop ()
  ]&gt;
}
</code>
              <p>
                The above macro defines function <tt>for</tt>, which is
                similar to the loop known from C. It can be used like this
              </p>
<code>
for (mutable i &lt;- 0; i &lt; 10; i &lt;- i + 1, printf ("%d", i))
</code>
              <p>
                Later we show how to extend the language syntax to make the syntax
                of <tt>for</tt> exactly as in C.
              </p>
            </body>
        </subsection>
        <subsection id="base_splicing">
          <title>Base elements of grammar</title>
            <body>
              <p>
                Sometimes quoted expressions have literals inside of them
                (like strings, integers, etc.) and we want to operate on
                their value, not on their syntax trees. It is possible, 
                because they are constant expressions and their runtime
                value is known at the compile-time. 
              </p>
              <p>
                Let's consider the previously used function 
                <tt>print_compilation_time</tt>. 
              </p>
<code>
print_compilation_time () : Expr
{                   
  &lt;[ System.Console.WriteLine ($(DateTime.Now.ToString () : string)) ]>
}
</code>
              <p>
                Here we see some new extension of splicing syntax where we 
                create a syntax tree of string literal from a known value.
                It is done by adding <tt>: string</tt> inside the
                <tt>$(...)</tt> construct. One can think about it as of
                enforcing the type of spliced expression to a literal (similar
                to common Nemerle type enforcement), but in the matter
                of fact something more is happening here - a real value
                is lifted to its representation as syntax tree of a literal.
              </p>
              <p>
                Other types of literals (<tt>int</tt>, <tt>bool</tt>, <tt>float</tt>, 
				<tt>char</tt>) are treated the same.  
                This notation can be used also in pattern matching. We can
                match constant values in expressions this way.
              </p>
              <p>
                There is also a similar schema for splicing and matching 
                variables of a given name. <tt>$(v : name)</tt> denotes a
                variable, whose name is contained by object <tt>v</tt> 
                (of special type <tt>Name</tt>). There are some good 
                <a ref="#hygiene">reasons</a> for encapsulating a real identifier
                within this object. 
              </p>

            </body>
        </subsection>
        <subsection id="variable_elements">
          <title>Constructs with variable amount of elements</title>
            <body>
              <p>
                You might have noticed, that Nemerle has a few grammar elements, 
                which are composed of a list of subexpressions. For example, a sequence
                of expressions enclosed with <tt>{</tt> .. <tt>}</tt> braces may
                contain zero or more elements. 
              </p>
              <p>
                When splicing values of some expressions, we would like to decompose
                or compose such constructs in a general way - i.e. obtain all expressions
                in a given sequence. It is natural to think about them as if a list of expressions
                and to bind this list to some variable in meta-language. It is done with
                special syntax <tt>..</tt>:
              </p>
<code>
mutable exps &lt;- [ &lt;[ printf ("%d ", x) ]>, &lt;[ printf ("%d ", y) ]> ];
exps &lt;- &lt;[ def x = 1 ]> :: &lt;[ def y = 2 ]> :: exps;
&lt;[ {.. $exps } ]>
</code>
              <p>
                We used <tt>{ .. $exps }</tt> here to create the sequence of 
                expressions from list <tt>exps : list&lt;Expr>;</tt>. 
                A similar syntax is used to splice the content of tuples (<tt>( .. $elist )</tt>) 
                and other constructs, like <tt>array []</tt>:
              </p>
<code>
macro castedarray (e) {
 match (e) {
  | &lt;[ array [.. $elements ] ]> =>
     def casted = List.Map (elements, fun (x) {&lt;[ ($x :> object) ]>});
     &lt;[ array [.. $casted] ]>
  | _ => e
}
</code>
              <p>
                If the exact number of expressions in tuple/sequence is known during
                writing the quotation, then it can be expressed with
              </p>
<code>
&lt;[ $e_1; $e_2; $e_3; x &lt;- 2; f () ]&gt;
</code>
              <p>
                The <tt>..</tt> syntax is used when there are <tt>e_i : Expr</tt> for
                <tt>1 &lt;= i &lt;= n</tt>.
              </p>
            </body>
        </subsection>
        <subsection id="exercise_4b">
          <title>Exercise 4.2</title>
            <body>
              <p>
                Write a macro <tt>rotate</tt>, which takes two parameters: a pair of
                floating point numbers (describing a point in 2D space) and an angle (in 
                radians). The macro should return a new pair -- a point rotated by the given 
                angle. The macro should use as much information as is available at the 
                compile-time, e.g. if all numbers supplied are constant, then only the final 
                result should be inlined, otherwise the result must be computed at runtime.
              </p>
            </body>
        </subsection>
    </body>
  </section>
  <section id="defining_syntax">
    <title>Adding new syntax to the compiler</title>
      <body>
        <p>
          After we have written the <tt>for</tt> macro, we would like the compiler
          to understand some changes to its syntax. Especially the C-like notation
        </p>
<code>
for (mutable i &lt;- 0; i &lt; n; i &lt;- i + 1) {
  Nemerle.IO.printf ("%d\n", i);
  sum &lt;- sum + i;
}
</code>
        <p>  
          In order to achieve that, we have to define which tokens and grammar
          elements may form a call of <tt>for</tt> macro. We do that by changing
          its header to
        </p>
<code>
macro for (init, cond, change, body)
syntax ("for", "(", init, ";", cond, ";", change, ")", body)
</code>
        <p>
          The <tt>syntax</tt> keyword is used here to define a list of elements forming
          the syntax of the macro call. The first token must always be an unique identifier
          (from now on it is treated as a special keyword triggering parsing of
          defined sequence). It is followed by tokens composed of operators or
          identifiers passed as string literals or names of parameters of macro.
          Each parameter must occur exactly once.
        </p>
        <p>
          Parsing of syntax rule is straightforward - tokens from input
          program must match those from definition, parameters are parsed
          according to their type. Default type of a parameter is 
          <tt>Expr</tt>, which is just an ordinary expression (consult Nemerle
          grammar in <link>reference.html</link>). All allowed parameter types 
          will be described in the extended version of reference manual corresponding
          to macros.
        </p> 
        <subsection id="exercise_4c">
          <title>Exercise 4.3</title>
            <body>
              <p>
                Add a new syntactic construct <tt>forpermutation</tt> to your program.
                It should be defined as the macro
              </p>
<code>
macro forp (i, n : int, m : int, body)
</code>
              <p>
                and introduce syntax, which allows writing the following program
              </p>
<code>
mutable i &lt;- 0;
forpermutation (i in 3 to 10) Nemerle.IO.printf ("%d\n", i)
</code>
              <p>
                It should create a random permutation <tt>p</tt> of numbers 
                <tt>x_j, m &lt;= x_j &lt;= n</tt> at the compile-time. 
                Then generate the code executing body of the loop 
                <tt>n - m + 1</tt> times, preceding each of them with assignment of 
                permutation element to <tt>i</tt>.
              </p>
            </body>
        </subsection>
      </body>
  </section>      
  <section id="attributes">
    <title>Macros in custom attributes</title>
      <body>
        <subsection id="type_declarations">
          <title>Executing macros on type declarations</title>
            <body>
              <p>
                Nemerle macros are simply plugins to the compiler. We decided
                not to restrict them only to operations on expressions, but
                allow them to transform almost any part of program. 
              </p>
              <p>
                Macros can be used within custom attributes written near methods, 
                type declarations, method parameters, fields, etc. They are
                executed with those entities passed as their parameters.
              </p>
              <p>
                As an example, let us take a look at <tt>Serializable</tt> macro.
                Its usage looks like this:
              </p>
<code>
[Serializable]
class S {
  public this (v : int, m : S) { a &lt;- v; my &lt;- m; }
  my : S;
  a : int;
}
</code>
              <p>
                From now on, <tt>S</tt> has additional method <tt>Serialize</tt>
                and it implements interface <tt>ISerializable</tt>. We can use
                it in our code like this
              </p>
<code>
def s = S (4, S (5, null));
s.Serialize ();
</code>
              <p>
                And the output is
              </p>
<code>
<![CDATA[<a>4</a>
<my>
  <a>5</a>
  <my>
    <null/>
  </my>
</my>]]>
</code>
              <p>  
                The macro modifies type S at compile-time and adds some code to it. 
                Also inheritance relation of given class is changed, by making it 
                implement interface ISerializable
              </p>
<code>
public interface ISerializable {
  Serialize () : void;
}
</code>
            </body>
        </subsection>
        <subsection id="declarations_manipulation">
          <title>Manipulating type declarations</title>
            <body>
              <p>
                In general, macros placed in attributes can do many transformations 
                and analysis of program objects passed to them. To see 
                <tt>Serializable</tt> macro's internals and discuss some design 
                issues, let's go into its code.
              </p>
<code>
postscan macro Serializable (t : TypeBuilder)
{
  t.AddImplementedInterface (&lt;[ type: ISerializable ]>)
}
</code>
              <p>
                First we have to add interface, which given type is about to be
                implemented.
				<!-- bylo:  which given type is about to implement.-->
				But more important thing is the phase modifier 
                <tt>postscan</tt>. In general, we separate three stages of execution 
                for attribute macros. They are:
              </p>
              <ul>
                <li>
                  <tt>postscan</tt> performed after scanning all types in 
                  program. It gives freedom to change inheritance relations and
                  types in a much ''untyped'' way
                </li>
                <li>
                  <tt>preadd</tt> when inheritance of types is already set
                </li>
                <li>
                  <tt>postadd</tt> headers of methods, fields are in ''typed''
                  and bounded state, so we can easily traverse entire type space 
                  by reflecting type constructors of fields, method parameters, 
                  etc.
                </li>
              </ul>
              <p>
                (They are still under design)
              </p>
              <p>
                So, we have added interface to our type, we now must create 
                Serialize () method.
              </p>
<code>
<![CDATA[
postadd macro Serializable (t : TypeBuilder)
{
  /// here we list its fields and choose only those, which are not derived
  /// or static
  def fields = t.GetFields (BindingFlags.Instance %| BindingFlags.Public %|
                            BindingFlags.NonPublic %| BindingFlags.DeclaredOnly);

  /// now create list of expressions which will print object's data  
  mutable serializers <- [];

  /// traverse through fields, taking their type constructors  
  foreach (x : IField in fields) {
    def tc = Tyutil.GetTypeTycon (x.GetMemType ());
    def nm = Macros.UseSiteSymbol (x.Name);
    if (tc != null)
      if (tc.IsValueType)
        /// we can safely print value types as strings        
        serializers <- <[
                         printf ("<%s>", $(x.Name : string));
                         System.Console.Write ($(nm : name));
                         printf ("</%s>\n", $(x.Name : string));
                       ]>
                       :: serializers
      else
        /// we can try to check, if type of given field also implements ISerializable
        if (Tyutil.subtypes (x.GetMemType (), <[ ttype: ISerializable ]>))
          serializers <- <[
                           printf ("<%s>\n", $(x.Name : string));      
                           if ($(nm : name) != null)
                             $(nm : name).Serialize ()
                           else
                             printf ("<null/>\n");
                           printf ("</%s>\n", $(x.Name : string));
                         ]>
                         :: serializers
        else
          /// and finally, we encounter case when there is no easy way to serialize 
          /// given field
          Message.fatal_error ("field `" + x.Name + "' cannot be serialized")
    else
      Message.fatal_error ("field `" + x.Name + "' cannot be serialized")
  };
  // after analyzing fields, we create method in our type, to execute created
  // expressions
  t.Define (<[ decl: public Serialize () : void
                     implements ISerializable.Serialize {
                       .. $serializers
                     }
            ]>)
}
]]>
</code>
            </body>
        </subsection>
      </body>
  </section>      
  <section id="reference">
    <title>Reference to more advanced aspects</title>
      <body>
        <subsection id="hygiene">
          <title>Hygiene and alpha-renaming of identifiers</title>
            <body>
              <subsubsection id="capture">
                <title>Problem with names capture</title>
                  <body>
                    <p>
                      Identifiers in quoted code (object code) must be treated
                      in a special way, because we usually do not know in which
                      scope they would appear. Especially they should not mix
                      with variables with the same names from the macro-use site.
                    </p>
                    <p>
                      Consider the following macro defining a local function <tt>f</tt>
                    </p>
<code>
macro identity (e) { &lt;[ def f (x) { x }; f($e) ]> }
</code>
                    <p>
                      Calling it with <tt>identity (f(1))</tt> might generate 
                      confusing code like
                    </p>
<code>
def f (x) { x }; f (f (1))
</code>
                    <p>
                      To preserve names capture, all macro generated variables 
                      should be renamed to their unique counterparts, like in
                    </p>
<code>
def f_42 (x_43) { x_43 }; f_42 (f (1))
</code>
                  </body>
              </subsubsection>
              <subsubsection id="hygiene_details">
                <title>Hygiene of macros</title>
                  <body>
                    <p>
                      The idea of separating variables introduced by a macro from 
                      those defined in the plain code (or other macros) is called 
                      ``hygiene'' after Lisp and Scheme languages. In Nemerle 
                      we define it as putting identifiers created during a single 
                      macro execution into a unique namespace. Variables from
                      different namespaces cannot bind to each other.
                    </p>
                    <p>
                      In other words, a macro cannot create identifiers capturing
                      any external variables or visible outside of its own 
                      generated code. This means, that there is no need to care
                      about locally used names.
                    </p>
                    <p>
                      The Hygiene is obtained by encapsulating identifiers in special
                      <tt>Name</tt> class. The compiler uses it to distinguish names
                      from different macro executions and scopes (for details of
                      implementation consult <link>metaprogramming.pdf</link>).
                      Variables with appropriate information are created 
                      automatically by quotation.
                    </p>
<code>
def definition = &lt;[ def y = 4 ]>;
&lt;[ def x = 5; $definition; x + y ]>
</code>
                    <p>
                      When a macro creates the above code, identifiers <tt>y</tt> and 
                      <tt>x</tt> are tagged with the same unique mark. Now they
                      cannot be captured by any external variables (with a 
                      different mark). We operate on the <tt>Name</tt> class, when the
                      quoted code is composed or decomposed and we use 
                      <tt>&lt;[ $(x : name) ]></tt> construct. Here <tt>x</tt> 
                      is bound to am object of type <tt>Name</tt>, which we can use
                      in other place to create exactly the same identifier.
                    </p>
                    <p>
                      An identifier can be also created by calling method
                      <tt>Macros.NewSymbol()</tt>, which returns <tt>Name</tt>
                      with an unique identifier, tagged with a current mark.
                    </p>
<code>
def x = Macros.NewSymbol ();
&lt;[ def $(x : name) = 5; $(x : name) + 4 ]>
</code>
                  </body>
              </subsubsection>
              <subsubsection id="breaking_hygiene">
                <title>Controlled breaking hygiene</title>
                  <body>
                    <p>
                      Sometimes it is useful to generate identifiers, which
                      bind to variables visible in place where a macro is used.
                    </p>
                  </body>
              </subsubsection>
            </body>
        </subsection>
      </body>
  </section>      
</document>
