namespace Projekt
{
 using System;
 using System.IO;
 using System.Net;
 using System.Net.Dns;
 using System.Text.RegularExpressions;
 using System.Text.RegularExpressions.Regex;
 using System.Runtime.InteropServices;
 using Nemerle.Utility;
 using Nemerle.Collections;
 using Nemerle.Collections.List;
 using Nemerle.Text;

 module Projekt 
 {
  public static Main (): void {
   try {
    mutable device <- "/dev/cdrom";
    mutable database <- "http://freedb.freedb.org/~cddb/cddb.cgi";
    mutable helponly <- false;

    def opts = [
     Getopt.String(name    = "--database",
                   aliases = ["-d"],
                   help    = "Specify the cd databse url (default: http://freedb.freedb.org/~cddb/cddb.cgi).",
                   handler = fun (s) { database <- s; }),
     Getopt.Flag  (name = "--help",
                   aliases = ["-h"],
                   help = "Print this help and exit.",
                   handler = fun () { helponly <- true; }),
     Getopt.String(name    = "--device",
                   aliases = ["-i"],
                   help    = "Specify the cd-rom device (default: /dev/cdrom).",
                   handler = fun (s) { device <- s; })
    ];
    Getopt.Parse (opts);

    if (helponly) {
     Console.WriteLine(Getopt.Usage(opts));
    } else {
     def ui = UI.CursesIface();
     ui.WriteLine("Status:");
     ui.Write("* Reading CD TOC..");
     def cd = CD(device);
     ui.WriteLine(" Done.");
     ui.Write("* Checking localhost info..");
     def lcl = LocalInfo();
     ui.WriteLine(" Done.");
     ui.Write("* Sending DISCID query..");
     def db = CDDB(lcl, database);
     ui.WriteLine(" Done.");
     ui.Write("* Reading QUERY query..");
     def (heading,t) = db.QueryDiscInfoNoCateg(cd);
     ui.WriteLine(" Done.");
     ui.WriteLine("Finished.");

     def loop () :void {
      ui.NewPage();
      ui.GenerateMenu(heading,Map(t,fun(x) { "Genre: "+Replace(x,@"\+",@", discid: ") }),1);
      def choptnum = ui.NavigateMenu();
      def chopt = Nth(t,choptnum-1);
      db.QueryDiscInfoWithCateg(cd,chopt);
      ui.NewPage();
      Iter(cd.Details,fun(x: string, y: string) { 
                       match (y) {
                        | "" => ()
                        | _ => regexp match (x) {
                         | "TTITLE[0-9]+" => { def tnum = Int32.Parse(Replace(x,"[^0-9]","")) + 1;
                                               ui.WriteLine("Track "+tnum.ToString()+": "+y) }
                         | "DISCID" => ui.WriteLine("Discid: "+y)
                         | "DTITLE" => ui.WriteLine("Title: "+y)
                         | "DYEAR" => ui.WriteLine("Year: "+y)
                         | "DGENRE" => ui.WriteLine("Genre: "+y)
                         | "EXTD" => ui.WriteLine("Extended info: "+y)
                         | "EXTT[0-9]+" => { def tnum = Int32.Parse(Replace(x,"[^0-9]","")) + 1;
                                             ui.WriteLine("Extended track "+tnum.ToString()+": "+y) }
                         | "PLAYORDER" => ui.WriteLine("Playorder: "+y)
                         | _ => ui.WriteLine(x+": "+y) 
                        };
                       };
                      });     

      ui.WriteLine(""); 
      ui.WriteLine("");
      ui.WriteLine("Press any key to view the remaining matches, or 'q' to quit.");
      when (Curses.Input.GetNextChar() != ('q' :> int))
       loop()
     }

     if (heading != "No match found")
      loop();
     else {
      ui.NewPage();
      ui.WriteLine("Sorry, no matches found for this CD.");
      def _ = Curses.Input.GetNextChar();
      ()
     }

     ui.Close();
    };
   } catch { 
    | e : Exception => { 
       def dc = Curses.Window.Screen.DrawingContext;
       dc.Clear();
       dc.Move(1,1);
       dc.Add(e.Message);
       dc.Refresh();
       def _ = Curses.Input.GetNextChar();
       Curses.Setup.Exit (0); 
    }
   };
  }
 }

 namespace UI
 {
  public class CursesIface
  {
   mutable Heading: string;
   mutable Options: list <string>;
   mutable OptionsAmnt: int;
   mutable ChOpt: int;
   dc: Curses.DrawingContext;
   mutable xpos: int;
   mutable ypos: int;

   public this () {
    unless (Curses.Setup.Initialize ())
     throw System.Exception ("Cannot initialize curses.");
    this.dc <- Curses.Window.Screen.DrawingContext;
    this.dc.Clear();
    this.xpos <- 1;
    this.ypos <- 1;
    this.dc.Move(xpos,ypos);
    dc.Background <- Curses.Color.Black;
    dc.Foreground <- Curses.Color.White;
   }

   public NewPage () :void {
    this.xpos <- 1;
    this.ypos <- 1;
    this.dc.Move(xpos,ypos);
    this.dc.Clear();
   }
  
   public Close () :void {
    Curses.Setup.Exit (0);
   }
 
   public WriteLine (s: string) :void {
    this.dc.Move(this.xpos,this.ypos);
    this.dc.Add(s);
    this.dc.Refresh();
    this.ypos <- this.ypos + 1;
    this.xpos <- 1;
   }
  
   public Write (s: string) :void {
    this.dc.Move(this.xpos,this.ypos);
    this.dc.Add(s);
    this.dc.Refresh();
    this.xpos <- this.xpos + s.Length;
   }

   public GenerateMenu (h: string, o: list <string>, i: int) :void {
    this.xpos <- 1;
    this.ypos <- 1;
    this.Heading <- h;
    this.Options <- o;
    this.OptionsAmnt <- Length(this.Options);
    this.ChOpt <- i;
    this.dc.Move(1,3);
    this.dc.Clear();
    this.WriteLine(this.Heading);
    this.WriteLine("");
    def startpos = (xpos, ypos);

    def printoptions (l: list <string>, i: int, acc: int) :void {
     match(l) {
      | h::t => { if (acc == i) {
                   this.dc.Background <- Curses.Color.Blue;
                   this.WriteLine(h); 
                   this.dc.Background <- Curses.Color.Black;
                   this.WriteLine(""); 
                  } else {
                   this.WriteLine(h);
                   this.WriteLine("");
                  };
                  printoptions(t,i,acc+1) }
      | [] => ()
     };
    };
  
    printoptions(this.Options,this.ChOpt,1);
    this.dc.Move(startpos);
    this.dc.Refresh();
   }
   
   public NavigateMenu () :int {
    def loop (x) {
     if (x == Curses.KeyCode.KEY_DOWN || x == ('j' :> int)) {
      this.ChOpt <- this.ChOpt % this.OptionsAmnt + 1; 
      this.GenerateMenu(this.Heading,this.Options,this.ChOpt); 
      loop (Curses.Input.GetNextChar());
     } else if (x == Curses.KeyCode.KEY_UP || x == ('k' :> int)) {
      this.ChOpt <- (this.OptionsAmnt - this.ChOpt) % this.OptionsAmnt + 1; 
      this.GenerateMenu(this.Heading,this.Options,this.ChOpt);
      loop (Curses.Input.GetNextChar());
     } else if (x == 0x000D || x == Curses.KeyCode.KEY_ENTER || x == Curses.KeyCode.KEY_RIGHT || x == ('l' :> int)) 
      ()
     else loop (Curses.Input.GetNextChar());
    };
    loop (Curses.Input.GetNextChar());
    this.ChOpt
   }
  }
 }

 public class LocalInfo
 {
  public HostName: string;
  public UserName: string;
  public ClientName: string;
  public ClientVersion: string;
  public ClientProto: string;

  /* FIXME: user, cname, cversion, cproto */
  public this () {
   try {
    this.HostName <- Dns.GetHostName();
   } catch {
    | e : Exception => { 
          this.HostName <- "localhost"; 
          throw Exception("Unable to set hostname. Using \"localhost\" instead. Reason: "+e.Message); 
    };
   };
   this.UserName <- "user";
   this.ClientName <- "testclient";
   this.ClientVersion <- "0.1";
   this.ClientProto <- "6";
  }
 }

 public class CDDB
 {
  public DB: string;
  public Hello: string;

  public this (l: LocalInfo, db: string) {
   this.DB <- db;
   this.Hello <- MakeQueryString(["hello=",l.UserName,l.HostName,l.ClientName,l.ClientVersion,"proto=",l.ClientProto]);
  }

  /* FIXME: error handling */
  public QueryDiscid(cd: CD) :void {
   def query = MakeQueryString(["cmd=discid",cd.QOffsets,this.Hello]);
   def rs = StreamReader(WebRequest.Create(this.DB+"?"+query).GetResponse().GetResponseStream());
   cd.DISCID <- Replace(rs.ReadLine(),".* ","");
   rs.Close();
  }  

  public QueryDiscInfoNoCateg(cd: CD) :string * list <string> {
   when (cd.DISCID == null)
    this.QueryDiscid(cd);
   def query = MakeQueryString(["cmd=cddb+query",cd.DISCID,cd.QOffsets,this.Hello]);
   def rs = StreamReader(WebRequest.Create(this.DB+"?"+query).GetResponse().GetResponseStream());

   def mkretlist (sr: StreamReader) {
    def r = sr.ReadLine();
    match(r) {
     | "." | null => { sr.Close(); [] }
     | _ => Replace(r,@"(\w+) (\w+) .*",@"$1+$2") :: mkretlist(sr) 
    };
   };

   /* FIXME: other responses */
   def r = rs.ReadLine();
   match (r.Substring(0,3)) {
    | "200" => ("Found exact match.",[Replace(r,@"(\w+) (\w+) (\w+) .*",@"$2+$3")])
    | "210" => ("Found multiple matches.",mkretlist(rs))
    | "211" => ("Found inexact match(es).",mkretlist(rs))
    | _ => ("No match found",mkretlist(rs))
   };
  }

  public QueryDiscInfoWithCateg(cd: CD, s: string) :void  {
   when (cd.DISCID == null)
    this.QueryDiscid(cd);
   def query = MakeQueryString(["cmd=cddb+read",s,this.Hello]);
   def rs = StreamReader(WebRequest.Create(this.DB+"?"+query).GetResponse().GetResponseStream());

   def pairsplit (s: string, p: string) :(string*string) {
    def q = s.IndexOf(p);
    (s.Substring(0,q),s.Substring(q+1,s.Length-q-1))
   };

   def rr (sr: StreamReader) :list <(string*string)> {
    def r = sr.ReadLine();
    if (r == "." || r == null)
     []
    else if (r.IndexOf("=") > -1) 
     pairsplit(r,"=")::rr(sr)
    else
     rr(sr)
   };
   cd.Details <- rr(rs);
  }

  private MakeQueryString (li: list <string>): string {
   def aux (sep: string, l: list <string>) {
    match (l) {
     | h::t => if (h.IndexOf("=") > -1)
                if (sep == "BEGIN") 
                 if (h.IndexOf("=")<h.Length-1) h+aux("+",t) else h+aux("",t) 
                else
                 if (h.IndexOf("=")<h.Length-1) "&"+h+aux("+",t) else "&"+h+aux("",t) 
               else
                if (sep == "BEGIN")
                 h+aux("+",t)
                else
                 sep+h+aux("+",t)
     | [] => ""
    }
   };
   aux ("BEGIN",li)
  }  
 }

 public class CD
 {
  public mutable Details: list <(string*string)>;

  public mutable DISCID: string;
  public Offsets: string;
  public QOffsets: string;

  public this (dev: string) {
   this.Offsets <- MyExtrn.Offsets.GetOffsetString(dev);
   this.QOffsets <- this.Offsets.Replace(" ","+");
   when (this.Offsets == "")
    throw Exception("Could not read CD TOC")
  }
 }
}
