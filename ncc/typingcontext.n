/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public class TypingContext
{
  public this_ptr_decl : option <LocalValue>;
  public in_ctor : bool;
  public env : GlobalEnv;
  public tenv : Tyvar.TEnv;
  public current_fun : Fun_header;
  public locals : SystemMap <string, LocalValue>;
  public parent_type : Tyinfo;
  public in_tail_position : bool;

  public static mutable macro_color : int;
  public static mutable macro_use_color : int;

  public static this () { macro_color <- 1;
                          macro_use_color <- 1; }
  
  public this (this_ptr_decl : option <LocalValue>,
               in_ctor : bool, env : GlobalEnv, tenv : Tyvar.TEnv,
               current_fun : Fun_header,
               locals : SystemMap <string, LocalValue>,
               parent_type : Tyinfo,
               in_tail_position : bool)
  {
    this.this_ptr_decl <- this_ptr_decl;
    this.in_ctor <- in_ctor;
    this.env <- env;
    this.tenv <- tenv;
    this.current_fun <- current_fun;
    this.locals <- locals;
    this.parent_type <- parent_type;
    this.in_tail_position <- in_tail_position;
  }

  register_local (val : LocalValue) : void
  {
    val.parent_fun.all_locals <- val :: val.parent_fun.all_locals
  }

  public WithTEnv (e : Tyvar.TEnv) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, e, current_fun, locals, 
                   parent_type, in_tail_position)
  }
  
  public WithCurrentFunction (h : Fun_header) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, h, locals, 
                   parent_type, in_tail_position)
  }

  public WithLocal (val : LocalValue) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, 
                   locals.Replace (val.name, val), parent_type, 
                   in_tail_position)
  }
  
  public WithLocals (vals : list <LocalValue>) : TypingContext
  {
    TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, 
                   List.FoldLeft (vals, locals, fun (v : LocalValue, m : SystemMap <string, LocalValue>) 
                                { m.Replace (v.name, v) }), 
                   parent_type, in_tail_position)
  }
  
  public WithInTailPosition (itp : bool) : TypingContext
  {
    if (itp == in_tail_position) this
    else
      TypingContext (this_ptr_decl, in_ctor, env, tenv, current_fun, locals,
                     parent_type, itp)
  }
  
  public Closurise (val : LocalValue) : void
  {
    def head = val.parent_fun;
    when (head.id != current_fun.id && !val.used_in.Member (current_fun.id))
      val.used_in <- val.used_in.Add (current_fun.id, current_fun)
  }
  
  public DefineLocal (n : string, k : LocalValueKind, ty : Type) : LocalValue
  { 
    def val = LocalValue (n, k, ty, current_fun);
    register_local (val);
    val
  }

}

}
