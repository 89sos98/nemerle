using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;

using LRPEGCC.GrammarCreator;

namespace LRPEGCC
{
  macro Gramar (_rules : Token)
  syntax ("grammar", _rules)
  {
    //GrammarImpl.MakeParser(tb, startRule, rules);
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
    | e is Exception =>
        using(def f = System.IO.StreamWriter("e.txt"))
          f.WriteLine(e.ToString());
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      def grammar = CreateGrammar(typer, tb, startRule, rules);
        
      def compiler = RuleCompiler();
      
      mutable str = "";
      
      foreach (name in grammar.Names)
      {
        def rule = grammar.GetRule(name);
        def body = compiler.CompileRule(rule, grammar);
        def method = <[decl:
          private $(compiler.DecorateRuleName(name) : dyn)(pos : int) : int
          {
            $(body);
          }
        ]>;
        _ = tb.DefineWithSource(method);
        str = str + method.ToString() + "\n" + body.ToString() + "\n\n";
      }
      
      _ = tb.DefineWithSource(<[decl:
        protected override DoParse() : int
        {
          $(compiler.DecorateRuleName(grammar.StartRuleName) : dyn)(0);
        }
      ]>);
      
      
      tb.Define(<[decl:
        public override ToString() : string
        {
          $(str : string);
        }
      ]>);
    }
  }
}
