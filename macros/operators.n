/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Macros;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

module Operators {
  char_tc : Tycon;
  bool_tc : Tycon;
  enum_tc : Tycon;
  int_tc : Tycon;
  string_tc : Tycon;

  variant ArithmeticTypeKind
  {
    | ATK_signed
    | ATK_unsigned
    | ATK_default
  }

  [Record]
  class ArithmeticTypeDescriptor
  {
    public tycon : Tycon;
    public kind : ArithmeticTypeKind;
    public one : PT.Expr;
  }

  arithmetic_types : list <ArithmeticTypeDescriptor>;

  op_name (name : string, td : ArithmeticTypeDescriptor, is_checked : bool) : string
  {
    match (td.kind) {
      | ATK_unsigned when is_checked => name + ".u"
      | ATK_signed when is_checked => name + ".s"
      | _ => name + ".f"
    }
  }
  
  this () {
    int_tc = GlobalEnv.LookupInternalType (["System", "Int32"]);
    char_tc = GlobalEnv.LookupInternalType (["System", "Char"]);
    bool_tc = GlobalEnv.LookupInternalType (["System", "Boolean"]);
    enum_tc = GlobalEnv.LookupInternalType (["System", "Enum"]);
    string_tc = GlobalEnv.LookupInternalType (["System", "String"]);

    def f (name, kind, one) { 
      def t = GlobalEnv.LookupInternalType (["System", name]);
      ArithmeticTypeDescriptor (t, kind, one)
    };

    arithmetic_types = [
      f ("Int32", ATK_signed (), <[ 1 ]>),
      f ("Byte", ATK_unsigned (), <[ 1b ]>),
      f ("Single", ATK_default (), null),
      f ("Double", ATK_default (), null),
      f ("Int64", ATK_signed (), <[ 1l ]>),
      f ("Int16", ATK_signed (), <[ 1s ]>),
      f ("SByte", ATK_signed (), <[ 1sb ]>),
      f ("UInt32", ATK_unsigned (), <[ 1u ]>),
      f ("UInt64", ATK_unsigned (), <[ 1lu ]>),
      f ("UInt16", ATK_unsigned (), <[ 1su ]>)
    ];
  }

  internal lookup_overloaded_operator (name : string, parms : list <Expr>)
  : option <PT.Expr>
  {
    def collect (parm, acc) {
      match (Tyutil.top_expand (Tyexpr.type_of (parm))) {
        | T_app (tc, _) =>
          def is_op (m : IMember) {
            match (m.GetKind ()) {
              | MK_method => m.IsStatic
              | _ => false
            }
          };
          def loop (tc : Tycon) {
            // fscking special case, why there is no System.String.op_Addition ?
            def name =
              if (name == "op_Addition" && tc.FullName == "System.String")
                "Concat"
              else 
                name;
            match (List.Filter (tc.LookupMember (name), is_op)) {
              | [] =>
                match (tc.SuperClass ()) {
                  | Some (tc') => loop (tc')
                  | None => acc
                }
              | lst => List.Append (lst, acc)
            }
          };
          loop (tc)
        | _ => acc
      }
    };
    def collapse (mem : IMember, acc) {
      def tyname = mem.DeclaringType.FullName;
      match (acc) {
        | Some (tn) when tn == tyname => acc
        | Some (tn) =>
          Message.error (sprintf ("ambiguity resolution between `%s' from types"
                                  " `%s' and `%s'", name, tn, tyname));
          acc
        | None => Some (tyname)
      }
    };
    match (List.FoldLeft (List.FoldLeft (parms, [], collect), None (), collapse)) {
      | Some ("System.String") when name == "op_Addition" =>
        match (parms) {
          | [e1, e2] =>
            Tyexpr.expect_type ("left-hand side of the `+' operator", 
                                e1, T_app (string_tc, []));
            Tyexpr.expect_type ("right-hand side of the `+' operator",
                                e2, T_app (string_tc, []));
            Some (<[ System.String.Concat ($(e1 : typed), $(e2 : typed)) ]>)
          | _ => assert (false)
        }
      | Some (tn) =>
        def parms = List.Map (parms, fun (e) { 
          <[ $(e : typed) ]> 
        });
        def memberize (l) {
          | [x] => <[ $((x : string) : dyn) ]>
          | x :: xs => <[ $(memberize (xs)).$(x : dyn) ]>
          | _ => Util.ice ("empty")
        };
        def tn = memberize (List.Rev (NString.Split (tn, array ['.'])));
        Some (<[ $tn . $(name : dyn) (.. $parms ) ]>)
      | None => None ()
    }
  }

  try_emit_binary (name : string, arg_tc : Tycon, ret_tc : Tycon, e1 : Expr, 
                   e2 : Expr) : option <PT.Expr>
  {
    def type_of (e) { Tyutil.top_expand (Tyexpr.type_of (e)) };
    
    match ((type_of (e1), type_of (e2))) {
      | (T_app (tc, _), _) when arg_tc.SameAs (tc) 
      | (_, T_app (tc, _)) when arg_tc.SameAs (tc) =>
        def ret_type = T_app (ret_tc, []);
        def arg_type = T_app (arg_tc, []);
        def op_type = T_fun (T_prod ([arg_type, arg_type]), ret_type);
        
        Tyexpr.expect_type (sprintf ("left-hand side of the `%s' operator", name),
                            e1, arg_type);
        Tyexpr.expect_type (sprintf ("right-hand side of the `%s' operator", name),
                            e2, arg_type);
        
        Some (<[ $(E_call (e1.loc, ret_type, E_opcode (e1.loc, op_type, name), 
                       [Parm (e1), Parm (e2)]) : typed) ]>)
      | _ => None ()
    }
  }

  type_of (e : Expr) : Type
  {
    Tyutil.top_expand (Tyexpr.type_of (e))
  }

  internal lookup_one (e : Expr) : PT.Expr
  {
    def tc = match (type_of (e)) {
      | T_app (t, _) => t
      | _ =>
        Message.fatal_error ("incrementation and decrementation can be done"
                             " only on integral types or one having appropriate"
                             " overload")
    };
    def x = List.Find (arithmetic_types, fun (x : ArithmeticTypeDescriptor) {
      x.tycon.SameAs (tc)
    });
    match (x) {
      | Some (atd) when atd.one != null => atd.one
      | _ =>
        Message.fatal_error ("incrementation and decrementation can be done"
                             " only on integral types or one having appropriate"
                             " overload")
    }
  }
  
  internal lookup_binary_compare_operator (ctx : TypingContext, 
                                           name : string, long_name : string, 
                                           e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def emit (lst : list <ArithmeticTypeDescriptor>) {
      | td :: xs =>
        match (try_emit_binary (op_name (name, td, ctx.IsChecked), td.tycon, bool_tc, e1, e2)) {
          | Some (ret) => ret
          | None => emit (xs)
        }
      | [] =>
        match (try_emit_binary (name + ".u", char_tc, bool_tc, e1, e2)) {
          | Some (ret) => ret
          | None =>
            match (lookup_overloaded_operator (long_name, [e1, e2])) {
              | Some (expr) => expr
              | None =>
                Message.fatal_error ($ "no match for binary operator"
                                       " `$(name)' taking $(type_of (e1)) "
                                       "and $(type_of (e2)) arguments")
            }
        }
    };

    emit (arithmetic_types);
  }

  internal lookup_binary_arithmetic_operator (ctx : TypingContext, 
                                              name : string, long_name : string, 
                                              e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def try_arith (lst : list <ArithmeticTypeDescriptor>) {
      | td :: xs =>
        match (try_emit_binary (op_name (name, td, ctx.IsChecked),
                                td.tycon, td.tycon, e1, e2)) {
          | Some (ret) => ret
          | None => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error ($ "no match for binary operator"
                                   " `$(name)' taking $(type_of (e1)) "
                                   "and $(type_of (e2)) arguments")
        }
    };

    // set implicit ctx to one supplied by parameter
    DefineCTX (ctx);
    
    match ((e1, e2)) {
      | (E_literal (L_int (x1)), E_literal (L_int (x2))) =>
        def int_type = <[ ttype : int ]>;
        
        def val =
          if (ctx.IsChecked) {
            checked {
              def val =
                match (name) {
                  | "+" => (x1 :> long) + (x2 :> long)
                  | "-" => (x1 :> long) - (x2 :> long)
                  | "/" => (x1 / x2 :> long)
                  | "%" => (x1 % x2 :> long)
                  | "*" => (x1 :> long) * (x2 :> long)
                  | _ => Message.fatal_error ("Unknown operator " + name)
                }

              if (val < (System.Int32.MinValue :> long)) {
                Message.error (loc, "result of operation is less than System.Int32.MinValue");
                System.Int32.MinValue
              } else if (val > (System.Int32.MaxValue :> long)) {
                Message.error (loc, "result of operation is more than System.Int32.MaxValue");
                System.Int32.MaxValue
              }
              else (val :> int)
            }
          }
          else {
            unchecked {
              match (name) {
                | "+" => x1 + x2
                | "-" => x1 - x2
                | "/" => x1 / x2
                | "%" => x1 % x2
                | "*" => x1 * x2
                | _ => Message.fatal_error ("Unknown operator " + name)
              }
            }
          }
        <[ $(E_literal (loc, int_type, L_int (val)) : typed) ]>
      | _ =>
        try_arith (arithmetic_types)
    }
  }

  internal lookup_unary_arithmetic_operator (ctx : TypingContext, 
                                             name : string, long_name : string, 
                                             e1 : PT.Expr) : PT.Expr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (ctx, e1);

    def try_arith (lst : list <ArithmeticTypeDescriptor>) {
      | { kind = ATK_unsigned } :: xs when name == "-" => try_arith (xs)
      | td :: xs =>
        def et = type_of (e1);
        match (et) {
          | T_app (tc', _) when td.tycon.SameAs (tc') =>
            def op_type = <[ ttype: $et -> $et ]>;
            <[ $(E_call (loc, et, E_opcode (loc, op_type, "unary."
                                            + op_name (name, td, ctx.IsChecked)), 
                                            [Parm (e1)]) : typed) ]>
          | _ => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error ($ "no match for unary operator `$(name)'"
                                   " taking $(type_of (e1)) argument")
        }
    };

    DefineCTX (ctx);
    
    match (e1) {
      | E_literal (L_int (x)) =>
        def int_type = <[ ttype: int ]>;
        def val = 
          if (name == "-") -x
          else x;
        <[ $(E_literal (loc, int_type, L_int (val)) : typed) ]>
      | _ => try_arith (arithmetic_types)
    }
  }


  has_flags_attribute (t : Tycon) : bool
  {
    t.HasAttribute (InternalType.FlagsAttribute_tc)
  }
  
  /**
   * This method wraps around lookup_unary_arithmetic_operator.
   * It adds some extra checks for the ~ operator for enums.
   */
  internal lookup_unary_enum_operator (ctx : TypingContext, 
                                       name : string, long_name : string, 
                                       expr : PT.Expr) : PT.Expr
  {
    def typed_expr = Tyexpr.ty_expr (ctx, expr);
    def expr_ty = type_of (typed_expr);

    if (is_enum (expr_ty))
    {
      when (name != "~")
        Message.fatal_error ("invalid unary operator for enum types: `" + name + "'");

      def tc =
        match (expr_ty) {
          | T_app (tc, _) => tc
          | _ => Util.ice ("lookup_unary_enum_operator")
        }

      when (!has_flags_attribute (tc))
        Message.fatal_error (sprintf ("bit-wise negation is only allowed over enum types "
                                      "with the System.FlagsAttribute set, "
                                      "the enum type %s is not marked with the System.FlagsAttribute",
                                      tc.FullName));

      def op_type = <[ ttype: $expr_ty -> $expr_ty ]>;
                                      
      <[ $(E_call (expr.loc, expr_ty, E_opcode (expr.loc, op_type, "unary.~.u"),
                                                [Parm (typed_expr)]) : typed) ]>

    }
    else
    {
      lookup_unary_arithmetic_operator (ctx, name, long_name, expr)
    }
  }

  
  internal lookup_shift_operator (ctx : TypingContext, 
                                  name : string, long_name : string, 
                                  e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def t1 = Tyutil.top_expand (type_of (e1));
    def t2 = Tyutil.top_expand (type_of (e2));

    def try_arith (lst : list <ArithmeticTypeDescriptor>) {
      | { kind = ATK_default } :: xs => try_arith (xs)
      | td :: xs =>
        match (t1) {
          | T_app (tc, _) when td.tycon.SameAs (tc) =>
            def ret_type = T_app (tc, []);
            def int_ty = T_app (int_tc, []);
            def op_type = T_fun (T_prod ([ret_type, int_ty]), ret_type);
        
            Tyexpr.expect_type (sprintf ("left-hand side of the `%s' operator", name),
                                e1, ret_type);
            Tyexpr.expect_type (sprintf ("right-hand side of the `%s' operator", name),
                                e2, int_ty);

            def opcode = E_opcode (e1.loc, op_type, op_name (name, td, ctx.IsChecked));
            <[ $(E_call (e1.loc, ret_type, opcode, 
                         [Parm (e1), Parm (e2)]) : typed) ]>
            
          | _ => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (ret) => ret
          | None =>
            Message.fatal_error ($ "no match for the binary operator `$(name)' "
                                   "taking $t1 and $t2 arguments")
        }
    };

    try_arith (arithmetic_types)
  }


  /*
   * Checks if a type inherits from System.Enum
   */
  private is_enum (t : Type) : bool
  {
    match (t) {
      | T_app (tc, _) =>
        Option.IsSome (tc.SuperType (enum_tc))
      | _ =>
        false
    }
  }

  
  internal lookup_enum_operator (ctx : TypingContext, 
                                 name : string, long_name : string, 
                                 e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def t1 = type_of (e1);
    def t2 = type_of (e2);

    def try_arith (lst : list <ArithmeticTypeDescriptor>) {
      | { kind = ATK_default } :: xs => try_arith (xs)
      | td :: xs =>
        match (try_emit_binary (op_name (name, td, ctx.IsChecked), td.tycon, td.tycon,
                                e1, e2)) {
          | Some (ret) => ret
          | None => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (ret) => ret
          | None =>
            Message.fatal_error ($ "no match for binary operator"
                                   " `$(name)' taking $t1 and $t2 arguments")
        }
    };

    if (is_enum (t1) || is_enum (t2)) {
      match (Tyutil.unify (t1, t2)) {
        | Some (subst) =>
          Tyvar.global_store (subst);
          def tc =
            match (Tyutil.top_expand (t1)) {
              | T_app (tc, _) => tc
              | _ => Util.ice ()
            }
          
          def bit_op_names = ["&", "|", "^", "&&", "||", "^^"];
          
          def op_is_bit_op =
            List.Exists (bit_op_names, fun (op_name) { name == op_name });
          
          def allow_bit_ops = has_flags_attribute (tc);
            
          if (!op_is_bit_op || allow_bit_ops) {
            Option.UnSome (try_emit_binary (name + ".u", tc, tc, e1, e2))
          }
          else {
            Message.fatal_error (sprintf ("bit operations are only allowed over enum types "
                                          "with the System.FlagsAttribute set, "
                                          "the enum type %s (on sides of a bit `%s' "
                                          "operator) is not marked with the System.FlagsAttribute",
                                          tc.FullName, name));

          }
        | None =>
          Message.fatal_error ($ "the enum types $t1 and $t2 (on sides of "
                                 "`$(name)' operator) are not compatible")
      }
    } else
      try_arith (arithmetic_types)
  }
  

  // == or !=
  internal lookup_equality_operator (ctx : TypingContext, 
                                     name : string, long_name : string, 
                                     e1 : PT.Expr, e2 : PT.Expr) : PT.Expr
  {
    DefineCTX (ctx);

    def is_from_null (t) {
      | T_var ({ value = TV_free_from_null }) => true
      | _ => false
    }

    def ok_for_eq (t) {
      match (Tyutil.top_expand (t)) {
        | T_app (tc, _) =>
          tc.SameAs (InternalType.Object_tc) ||
          tc.SameAs (InternalType.Char_tc) ||
          tc.SameAs (InternalType.Boolean_tc) ||
          (tc.GetTydecl () matches TD_enum) ||
          NumericType.IsNumericType (tc)
        | _ =>
          false
      }
    }
    
    def is_object (t) {
      match (Tyutil.top_expand (t)) {
        | T_app (tc, _) =>
          tc.SameAs (InternalType.Object_tc)
        | _ =>
          false
      }
    }

    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    match (lookup_overloaded_operator (long_name, [e1, e2])) {
      | Some (expr) => expr
      | None =>
        def t1 = type_of (e1);
        def t2 = type_of (e2);

        mutable from_null = is_from_null (t1) || is_from_null (t2);

        match (Tyutil.unify (t1, t2)) {
          | Some (subst) =>
            def ret_type = <[ ttype: bool ]>;
            def op_type = <[ ttype: $t1 * $t2 -> bool ]>;
            
            Tyvar.global_store (subst);

            unless (from_null || (ok_for_eq (t1) && ok_for_eq (t2))) {
              Message.error ($ "the operator `$(name)' is not defined for "
                               "$t1 and $t2");
              Message.hint_once ("use (x : object) == (y : object) if "
                                 "reference equality is desired");
            }

            <[ $(E_call (e1.loc, ret_type, E_opcode (e1.loc, op_type, name), 
                         [Parm (e1), Parm (e2)]) : typed) ]>
          | None when is_object (t1) || is_object (t2) =>
            def op_type = <[ ttype: object * object -> bool ]>;
            def e1 = <[ ($(e1 : typed) : object) ]>;
            def e2 = <[ ($(e2 : typed) : object) ]>;
            <[ $(E_opcode (e1.loc, op_type, name) : typed) ($e1, $e2) ]>
          | None =>
            Message.error ($ "the types $t1 and $t2 (on sides of"
                             " the `$(name)' operator) are not compatible");
            Message.hint_once ("use (x : object) == (y : object) if "
                               "reference equality is desired");
            throw Recovery ()
        }
    }
  }

  internal cache_indices (expr : PT.Expr, idxes : list <PT.Expr>) 
                       : PT.Expr * list <PT.Expr>
  {
    def idx_names = List.Map (idxes, fun (_) { Macros.NewSymbol () });
    def idx_patterns = List.Map (idx_names, fun (n) { <[ pattern: $(n : name) ]> });
    def idx_exprs = List.Map (idx_names, fun (n) { <[ $(n : name) ]> });
    (<[ def (.. $(<[ pattern : tmp ]> :: idx_patterns)) = (.. $(expr :: idxes)) ]>,
     idx_exprs)
  }

  [Hygienic]
  internal cache_assign_expr (ctx : TypingContext, e : PT.Expr)
  : PT.Expr * PT.Expr
  {
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        (<[ def tmp = $obj ]>, <[ tmp.$mem ]>)
      | <[ $obj . $mem [.. $idxes] ]> when !Macros.IsTypeName (ctx, obj) =>
        def (cache, idx_exprs) = cache_indices (obj, idxes);
        (cache, <[ tmp . $mem [ .. $idx_exprs ] ]>)
      | <[ $tab [.. $idxes] ]> =>
        def (cache, idx_exprs) = cache_indices (tab, idxes);
        (cache, <[ tmp [ .. $idx_exprs ] ]>)
      | _ => (<[ () ]>, e)
    }
  }

  [Hygienic]
  internal cache_assign_typed_expr (ctx : TypingContext, e : PT.Expr)
  : PT.Expr * PT.Expr * Expr
  {
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        def obj = Tyexpr.ty_expr (ctx, obj);
        def cache = <[ def tmp = $(obj : typed) ]>;
        def safe = <[ tmp.$mem ]>;
        def ty = Tyexpr.ty_expr (ctx, <[ $cache; $safe ]>); 
        (cache, safe, ty)

      | <[ $obj . $mem [.. $idxes] ]> when !Macros.IsTypeName (ctx, obj) =>
        def obj = Tyexpr.ty_expr (ctx, obj);
        def idxes = List.Map (idxes, fun (e) { Tyexpr.ty_expr (ctx, e) });
        def pt_idxes = List.Map (idxes, fun (e) { <[ $(e : typed) ]> });
        def (cache, idx_exprs) = cache_indices (<[ $(obj : typed) ]>, pt_idxes);
        def safe = <[ tmp . $mem [ .. $idx_exprs ] ]>;
        def ty = Tyexpr.ty_expr (ctx, <[ $cache; $safe ]>); 
        (cache, safe, ty)

      | <[ $tab [..$idxes] ]> =>
        def tab = Tyexpr.ty_expr (ctx, tab);
        def idxes = List.Map (idxes, fun (e) { Tyexpr.ty_expr (ctx, e) });
        def pt_idxes = List.Map (idxes, fun (e) { <[ $(e : typed) ]> });
        def (cache, idx_exprs) = cache_indices (<[ $(tab : typed) ]>, pt_idxes);
        def safe = <[ tmp [ .. $idx_exprs ] ]>;
        def ty = Tyexpr.ty_expr (ctx, <[ $cache; $safe ]>); 
        (cache, safe, ty)

      | <[ $(_ : name) ]> | <[ $_.$_ ]> =>
        def te = Tyexpr.ty_expr (ctx, e);
        (<[ () ]>, e, te)

      | _ => 
        def e = Tyexpr.ty_expr (ctx, e);
        (<[ () ]>, <[ $(e : typed) ]>, e)
    }
  }

  internal event_add_or_remove (ctx : TypingContext, is_add : bool, 
                                e : PT.Expr, val : PT.Expr) : PT.Expr
  {
    def to_delegate (val, ty) {
      def val = Tyexpr.ty_expr (ctx, val);
      match ((Tyutil.top_expand (Tyexpr.type_of (val)),
              Tyutil.top_expand (ty))) {
        | (T_fun, T_app (tc, _)) =>
          <[ $(Util.expr_of_qid (tc.FullName)) ($(val : typed)) ]>
        | _ => 
          <[ $(val : typed) ]>
      }
    };
    
    def not_event (cached, safe, typed) {
      def ty = Tyexpr.type_of (typed);
      if (Tyutil.IsDelegate (ty)) {
          def val = to_delegate (val, ty);
          def ty = PT.T_typed (ty);
          if (is_add)
            <[ 
              $cached; 
              $safe = (System.Delegate.Combine (($safe : $ty), ($val : $ty)) :> $ty)
            ]>
          else
            <[ 
              $cached; 
              $safe = (System.Delegate.Remove (($safe : $ty), ($val : $ty)) :> $ty)
            ]>
      } else if (is_add)
        <[ $cached; $safe = $safe + $val ]>
      else
        <[ $cached; $safe = $safe - $val ]>
    };

    def fallback () {
      not_event (Operators.cache_assign_typed_expr (ctx, e))
    };

    def is_event (mem : IMember) {
      match (mem.GetKind ()) {
        | MK_event => true
        | _ => false
      }
    };
    
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        def is_event (im : IMember) {
          match (im.GetKind ()) { 
            | MK_event => true 
            | _ => false 
          } 
        };
        
        def obj = Tyexpr.ty_expr (ctx, obj);
        def mem_name = List.Head (Macros.UnSString (mem));
        def members = Tyexpr.LookupMembers (ctx, Tyexpr.type_of (obj), mem_name);
        //Message.debug ("lookup in `" + Tyexpr.type_of (obj).as_string () + "' for " + 
        //        mem_name + " res " + members.ToString ());
        if (List.Exists (members, is_event))
          match (members) {
            | [ev] =>
              def meth = 
                if (is_add)
                  (ev :> IEvent).GetAdder ()
                else
                  (ev :> IEvent).GetRemover ();
              def val = to_delegate (val, ev.GetMemType ());
              <[ $(obj : typed) . $(meth.Name : dyn) ($val) ]>

            | _ =>
              Message.fatal_error ("ambigious reference to an event `" 
                                   + mem_name + "'");
          }
        else {
          def cached = <[ def tmp = $(obj : typed) ]>;
          def safe = <[ tmp.$mem ]>;
          def typed = Tyexpr.ty_expr (ctx, <[ $cached; $safe ]>);
          not_event (cached, safe, typed)
        }

      | <[ $obj . $(name : dyn) ]> =>
        match (Util.qidl_of_expr (obj)) {
          | None =>
            fallback ()
          | Some ((tyname, env)) =>
            def env = env.GetEnv (ctx.env);
            match (env.LookupType (tyname)) {
              | Some (tc) =>
                def events = List.Filter (tc.LookupMember (name), is_event);
                match (events) {
                  | [ev] => 
                    def meth = 
                      if (is_add)
                        (ev :> IEvent).GetAdder ()
                      else
                        (ev :> IEvent).GetRemover ();
                    def val = to_delegate (val, ev.GetMemType ());
                    <[ $(Util.expr_of_qid (tc.FullName)) . 
                       $(meth.Name : dyn) ($val) ]>
                  | _ => fallback ()
                }
              | None =>
                // this case should be catched above
                assert (false)
            }
        }

      // FIXME: handling plain identfiers would require local lookups
      //| <[ $(id : name) ]> =>

      | _ => fallback ()
    }
  }
}

  macro @&& (e1, e2) 
  {
    <[ 
      match ($e1) {
        | false => false
        | _ => 
          match ($e2) { 
            | false => false
            | _ => true
          }
      }
    ]>
  }

  macro @|| (e1, e2) 
  {
    <[ 
      match ($e1) {
        | true => true
        | _ => 
          match ($e2) { 
            | true => true
            | _ => false
          }
      }
    ]>
  }

  macro @! (e)
  {
    def tval = Tyexpr.ty_expr (ImplicitCTX (), e);
    match (Operators.lookup_overloaded_operator ("op_LogicalNot", [tval])) {
      | Some (e) => e
      | None =>
        def bool_ty = <[ ttype: bool ]>;
        def op_ty = <[ ttype: bool -> bool ]>;
        Tyexpr.expect_type ("negated value", tval, bool_ty);
        <[ $(E_call (e.loc, bool_ty, E_opcode (e.loc, op_ty, "bool.!"), 
                     [Parm (tval)]) : typed) ]>
    }
  }

  macro @~ (e)
  {
      Operators.lookup_unary_enum_operator (ImplicitCTX (), "~", 
                                            "op_UnaryBitwiseNot", e)
  }

  macro @- (params args : array <expr>)
  {
    match (args.Length) {
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (ImplicitCTX (), "-",
                                                    "op_UnaryMinus", args[0])

      | 2 =>
        Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "-",
                                                     "op_Subtraction", args[0],
                                                     args[1])
      | _ => 
        Message.fatal_error ("the `-' operator can only take one or two"
                             " parameters")
    }
  }

  macro @+ (params parms : array <expr>) 
  {
    match (parms.Length) {
      | 2 =>
        Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "+",
                                                     "op_Addition",
                                                     parms[0], parms[1])
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (ImplicitCTX (), "+",
                                                    "op_UnaryPlus", parms[0])
      | _ =>
        Message.fatal_error ("the `+' operator can only take one or two"
                             " parameters")
    }
  }

  macro @* (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "*",
                                                 "op_Multiply", e1, e2)
  }

  macro @/ (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "/",
                                                 "op_Division", e1, e2)
  }

  macro @% (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "%",
                                                 "op_Modulus", e1, e2)
  }
  
  macro @< (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), "<",
                                              "op_LessThan", e1, e2)
  }
  
  macro @> (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), ">",
                                              "op_GreaterThan", e1, e2)
  }
  
  macro @<= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), "<=",
                                              "op_LessThanOrEqual", e1, e2)
  }
  
  macro @>= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), ">=",
                                              "op_GreaterThanOrEqual", e1, e2)
  }
  
  macro @%| (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "|", "op_BitwiseOr", e1, e2)
  }
  
  macro @%& (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "&", "op_BitwiseAnd", e1, e2)
  }
  
  macro @%^ (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "^", "op_ExclusiveOr",
                                    e1, e2)
  }

  macro @%|| (e1, e2)
  {
    def mask = 
      Operators.lookup_enum_operator (ImplicitCTX (), "|", "op_BitwiseOr", e1, e2);
    <[ ($mask :> int) != 0 ]>
  }
  
  macro @%&& (e1, e2)
  {
    def mask =     
      Operators.lookup_enum_operator (ImplicitCTX (), "&", "op_BitwiseAnd", e1, e2);
    <[ ($mask :> int) != 0 ]>    
  }
  
  macro @%^^ (e1, e2)
  {
    def mask =     
      Operators.lookup_enum_operator (ImplicitCTX (), "^", "op_ExclusiveOr",
                                      e1, e2);
    <[ ($mask :> int) != 0 ]>                                    
  }
  
  macro @<< (e1, e2)
  {
    Operators.lookup_shift_operator (ImplicitCTX (), "<<", "op_LeftShift",
                                     e1, e2)
  }
  
  macro @>> (e1, e2)
  {
    Operators.lookup_shift_operator (ImplicitCTX (), ">>", "op_RightShift",
                                     e1, e2)
  }
  
  macro @== (e1, e2)
  {
    Operators.lookup_equality_operator (ImplicitCTX (), "==", "op_Equality",
                                        e1, e2)
  }
  
  macro @!= (e1, e2)
  {
    Operators.lookup_equality_operator (ImplicitCTX (), "!=", "op_Inequality",
                                        e1, e2)
  }

  macro @++ (e) {
    def (cached, safe, e) = Operators.cache_assign_typed_expr (ImplicitCTX (), e);
    match (Operators.lookup_overloaded_operator ("op_Increment", [e])) {
      | Some (e) => <[ $cached; $e ]>
      | None =>
        def one = Operators.lookup_one (e);
        <[ $cached; $safe = $safe + $one ]>        
    }
  }

  macro @-- (e) {
    def (cached, safe, e) = Operators.cache_assign_typed_expr (ImplicitCTX (), e);
    match (Operators.lookup_overloaded_operator ("op_Decrement", [e])) {
      | Some (e) => <[ $cached; $e ]>
      | None =>
        def one = Operators.lookup_one (e);
        <[ $cached; $safe = $safe - $one ]>        
    }
  }

  macro @+= (e, val) {
    Operators.event_add_or_remove (ImplicitCTX (), true, e, val)
  }

  macro @-= (e, val) {
    Operators.event_add_or_remove (ImplicitCTX (), false, e, val)
  }

  macro @*= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe * $val ]>
  }

  macro @/= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe / $val ]>
  }

  macro @<<= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe << $val ]>
  }

  macro @>>= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe >> $val ]>
  }

  macro @%= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe % $val ]>
  }

  macro @|= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe %| $val ]>
  }

  macro @&= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe %& $val ]>
  }

  macro @^= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe %^ $val ]>
  }
  
  macro @<-> (e1, e2)
  {
    def (cached1, safe1) = Operators.cache_assign_expr (ImplicitCTX (), e1);
    def (cached2, safe2) = Operators.cache_assign_expr (ImplicitCTX (), e2);    
    <[
      $cached1;
      $cached2;
      def tmp = $safe1;
      $safe1 = $safe2;
      $safe2 = tmp;
    ]>
  }
}
