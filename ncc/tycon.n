(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

public variant MemberKind
{
  | MK_field { field : IField; }
  | MK_method { method : IMethod; }
  | MK_property { prop : IProperty; }
  | MK_type { tycon : Tycon; }
}

public variant TyconKind
{
  | TK_NemerleType { exact : Tyinfo; }
  | TK_ExternalNetType { exact : System.Type; }
  | TK_ExternalNemerleType { exact : System.Type; }
}

public interface IMember
{
  GetName () : string;
  GetMemType () : Type;
  GetKind () : MemberKind;
  GetDeclaringTycon () : Tycon;
  GetLocation () : Location;
  GetModifiers () : list (Modifier);
  IsStatic () : bool; // types are always static
  GetId () : int;
  GetHandle () : System.Reflection.MemberInfo;
  CanAccess (source : Tycon) : bool;
}

public interface IField extends IMember
{
  IsMutable () : bool;
}

public interface IMethod extends IMember
{
  GetFreshType () : Type;
  GetHeader () : Fun_header;
  GetFunKind () : Fun_kind;
}

public interface IProperty extends IMember
{
  IsMutable () : bool;
}

public variant LookupFlag
{
  | LF_instance
  | LF_static
  | LF_all
}

public interface Tycon extends IMember
{
  (** Return full qualified type name with namespaces.
   
      It probably should contain [+] instead of [.] for nested types.
   *)
  GetFullName () : string; // FIXME: this could be with + or . ?

  (** Look for specified member. 
   
      If [only_instance] is true, look only for instance members (methods
      and fields).  If [only_static] is set look only for static fields,
      static methods and nested types.

      Semantics of returning base class member is the same as for 
      [System.Type.GetMember] method.
   *)
  LookupMember (name : string, lookup_flag : LookupFlag) : list (IMember);

  (** Return kind of this tycon. *)
  GetTyconKind () : TyconKind;

  (** *)
  GetTydecl () : Type_decl;

  (** Construct substitution resulting from applying this type constructor
      to specified arguments.
      
      For example assuming our type parameters are are ('a, 'b), then
      [MakeSubst (t1, t2)] produces substitution { 'a := t1; 'b := t2 }.
   *)
  MakeSubst (parms : list (Type)) : Subst;

  FreshSubst () : Subst;

  (** If this tycon subtypes [tycon], then return instantiation using
      which we subtype it.
   *)
  SuperType (tycon : Tycon) : option (list (Type));

  (** *)
  SubtypingSubst (tycon : Tycon) : Subst;

  SuperClass () : option (Tycon);

  (** Return list of all members defined in this very type and its
      supertypes. *)
  GetMembers () : list (IMember);

  (** *)
  GetSuperTypes () : list (Type);

  GetDirectSuperTypes () : list (Type);

  (** Compare types for equality. *)
  SameAs (the_other : Tycon) : bool;
}

} // ns
