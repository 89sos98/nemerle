(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Typattern {
  
  variant Range {
    | R_omega        // _, x, everything
    | R_none         // nothing
    | R_any_except { lits : list (Literal); }
    | R_literal { l : Literal; }
    | R_variant_option { ti : Tyinfo; range : Range; }
    | R_tuple { ranges : list (Range); }
    | R_record { ranges : list (M_field * Range); }
    
    | R_or { ranges : list (Range); }
  }

  range_of_pattern (p : Pattern) : Range {
    match (p) {
      | P_underscore => R_omega ()
      | P_variable => R_omega ()
      | P_tuple (args) => R_tuple (List.map (range_of_pattern, args))
      | P_record (args) =>
        def f (n : Named_pattern) : M_field * Range {
          (n.name, range_of_pattern (n.pat))
        }
        R_record (List.map (f, args))
      | P_cons (ti, pat) =>
        R_variant_option (ti, range_of_pattern (pat))
      | P_literal (l) => R_literal (l)
    }
  }

  // debug routine
  string_of_range (r : Range) : string {
    match (r) {
      | R_omega => "_"
      | R_any_except ([L_bool (true)]) => "false"
      | R_any_except ([L_bool (false)]) => "true"
      | R_any_except (_) => "X" // FIXME
      | R_variant_option (ti, r) =>
        ti.fullname () + " (" + string_of_range (r) + ")"
      | R_tuple (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") string_of_range (r)
          else
            acc + ", " + string_of_range (r)
        }
        "(" + List.fold_left (concat, "", ranges) + ")"
        
      | R_record (ranges) =>
        def concat (acc : string, x : M_field * Range) : string {
          def (f, r) = x;
          def r' = f.name + " = " + string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        }
        "{ " + List.fold_left (concat, "", ranges) + " }"
        
      | R_none => "[[None]]"
      | R_literal => "[[Literal]]"
      
      | R_or (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") string_of_range (r)
          else
            acc + " | " + string_of_range (r)
        }
        "[ " + List.fold_left (concat, "", ranges) + " ]"
    }
  }

  // for user error messages, we just present first branch of R_or
  user_string_of_range (r : Range) : string {
    match (r) {
      | R_omega => "_"
      | R_any_except ([L_bool (true)]) => "false"
      | R_any_except ([L_bool (false)]) => "true"
      | R_any_except (_) => "X" // FIXME
      | R_variant_option (ti, r) =>
        ti.fullname () + " (" + user_string_of_range (r) + ")"
      | R_tuple (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") user_string_of_range (r)
          else
            acc + ", " + user_string_of_range (r)
        }
        "(" + List.fold_left (concat, "", ranges) + ")"
        
      | R_record (ranges) =>
        def concat (acc : string, x : M_field * Range) : string {
          def (f, r) = x;
          def r' = f.name + " = " + user_string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        }
        "{ " + List.fold_left (concat, "", ranges) + " }"
        
      | R_none => Util.ice ()
      | R_literal => Util.ice ()
      | R_or ([]) => Util.ice ()
      
      | R_or (x :: _) => user_string_of_range (x)
    }
  }

  simplify_range (r : Range) : Range {
  //  Message.debug ("simpl: " + string_of_range (r) );
    def aint_none (r : Range) : bool {
      match (r) {
        | R_none => false
        | _ => true
      }
    }
    match (r) {
      | R_or ([]) => R_none ()
      | R_or (lst) =>
        match (List.filter (aint_none, lst)) {
          | [] => R_none ()
          | [x] => x
          | l => R_or (l)
        }
      | R_any_except ([L_bool (true); L_bool (false)]) => R_none ()
      | R_any_except ([L_bool (false); L_bool (true)]) => R_none ()
      | R_variant_option (_, R_none) => R_none ()
      | R_tuple (ranges) =>
        if (List.forall (aint_none, ranges)) 
          r
        else
          R_none ()
      | R_record (ranges) =>
        def is_named_none (x : M_field * Range) : bool {
          match (x) {
            | (_, R_none) => true
            | _ => false
          }
        }
        if (List.exists (is_named_none, ranges))
          R_none ()
        else
          r
      | x => x 
    }
  }
    
  subtract (r1 : Range, r2 : Range) : bool * Range {
    mutable did_something <- false;

    // subtract new_r from cur_r
    def do_sub (cur_r : Range, new_r : Range) : Range {
//    Message.debug ("subx: " + string_of_range (cur_r) + "     " + string_of_range (new_r) );
      match ((cur_r, new_r)) {
        | (R_none, _) => R_none ()
        
        | (_, R_omega) => 
          did_something <- true; 
          R_none ()
          
        | (R_omega, R_literal (l)) =>
          did_something <- true;
          R_any_except ([l])

        | (R_or (ranges), _) =>
          R_or (List.map (fun (r : Range) : Range { sub (r, new_r) }, ranges))

        | (R_any_except (lits), R_literal (l)) =>
          // FIXME: check if l is in lits
          did_something <- true;
          R_any_except (l :: lits)

        | (R_any_except, _) => Util.ice ()

        | (R_variant_option (ti1, r1), R_variant_option (ti2, r2)) =>
          if (ti1.id == ti2.id)
            R_variant_option (ti1, sub (r1, r2))
          else
            cur_r
          
        | (cur, R_variant_option (ti, r)) =>
          def is_variant_option (ti : Tyinfo) : bool {
            match (ti.tydecl) {
              | TD_variant_option => true
              | _ => false
            }
          }
          def make_range (ti : Tyinfo) : Range {
            R_variant_option (ti, cur)
          }
          def types_in_parent = (ti.enclosing_tyinfo ()).contained_types;
          def variants = List.filter (is_variant_option, types_in_parent);
          sub (R_or (List.map (make_range, variants)), new_r)

        | (R_variant_option, R_record) => Util.ice ("FIXME")
       
        | (R_omega, R_tuple (ranges)) =>
          def args = List.map (fun (_ : Range) : Range { R_omega () }, ranges);
          sub (R_tuple (args), new_r)
          
        | (R_tuple (r1), R_tuple (r2)) =>
          mutable did <- true;
          def make_sub (r1 : Range, r2 : Range) : Range {
            def (d, r) = subtract (r1, r2);
            if (d) () else did <- false;
            r
          }
          def results = List.map2 (make_sub, r1, r2);
          if (did) {
            did_something <- true;

            mutable output <- [];
            // r1 - r2 = r3
            def dosub (pref : list (Range), 
                       cur : list (Range), 
                       after_sub : list (Range)) : void {
              match ((cur, after_sub)) {
                | (x :: xs, y :: ys) => 
                  def args = List.rev_append (pref, (y :: xs));
                  output <- simplify_range (R_tuple (args)) :: output;
                  dosub (x :: pref, xs, ys)
                | ([], []) => ()
                | _ => Util.ice ()
              }
            }
            dosub ([], r1, results);
            R_or (output)
          } else cur_r
        
        | (R_omega, R_record) =>
          sub (R_record ([]), new_r)

        | (R_record (r1), R_record (r2)) =>
//          Message.debug ("ransub: " + string_of_range (cur_r) + "   " + string_of_range (new_r));
          mutable all_did <- true;

          def loop (acc : list (Range), r2 : M_field * Range) : list (Range) {
            def (name, range) = r2;
            
            def loop2 (acc : list (M_field * Range), l : list (M_field * Range)) : list (M_field * Range) {
              match (l) {
                | (f, r) :: xs =>
                  if (name.id == f.id) {
                    def (did, res) = subtract (r, range);
                    if (did) () else all_did <- false;
                    List.rev_append (xs, (f, res) :: acc)
                  } else
                    loop2 ((f, r) :: acc, xs)
                | [] =>
                  (name, sub (R_omega (), range)) :: acc
              }
            }

            simplify_range (R_record (loop2 ([], r1))) :: acc
          }

          def r = R_or (List.fold_left (loop, [], r2));

          if (all_did) {
            did_something <- true;
            r
          } else cur_r

        | (R_variant_option, R_tuple) => Util.ice ()
        | (R_variant_option, R_literal) => Util.ice ()
        | (R_tuple, R_literal) => Util.ice ()
        | (R_record, R_literal) => Util.ice ()
        | (R_record, R_tuple) => Util.ice ()
        | (R_tuple, R_record) => Util.ice ()
        | (R_literal, _) => Util.ice ()
        | (_, R_any_except) => Util.ice ()
        | (_, R_or) => Util.ice ()
        | (_, R_none) => Util.ice ()
      }
    }

    and sub (r1 : Range, r2 : Range) : Range {
      simplify_range (do_sub (r1, r2))
    }

    def ret = sub (r1, r2);
//    Message.debug ("sub: " + string_of_range (r1) + " - " + string_of_range (r2) + " = " + string_of_range (ret));

    (did_something, ret)
  }

  (** Give warnings about ``pattern matching not exhaustive'' and 
      ``unused match clause''. *)
  public check_matching (cases : list (Match_case)) : void {
    def loop (acc : Range, m : Match_case) : Range {
      def (did_something, ret) = subtract (acc, range_of_pattern (m.pattern));
      if (did_something)
        ()
      else
        Message.warning (m.pattern.loc, "this match clause is unused");
      ret
    }
    def remaining = List.fold_left (loop, R_omega (), cases);
    match (remaining) {
      | R_none => ()
      | r =>
        Message.warning ("this matching is not exhaustive, example unmatched value:");
        Message.warning (user_string_of_range (r))
    }
  }

  public ty_pattern (ctx : Tyexpr.CTX, t : Type, p : PT.Pattern) : Pattern * Env {
    def mkcons (p1 : PT.Pattern, p2 : PT.Pattern) : PT.Pattern {
      def tup = PT.P_tuple ([p1; p2]);
      def ret = PT.P_cons ("Cons", tup);
      tup.loc <- p1.loc;
      ret.loc <- p1.loc;
      ret
    }

    def mknil (loc : Location) : PT.Pattern {
      def tup = PT.P_underscore ();
      def ret = PT.P_cons ("Nil", tup);
      tup.loc <- loc;
      ret.loc <- loc;
      ret
    }

    mutable pat_env <- ctx.env;
    mutable vars <- Map.string_map ();
    
    def do_walk (t : Type, p : PT.Pattern) : Pattern {
      match (p) {
        | PT.P_variable (n) =>
          if (n == "true")
            walk (t, PT.P_literal (L_bool (true)))
          else if (n == "false")
            walk (t, PT.P_literal (L_bool (false)))
          else {
            if (vars.mem (n))
              Message.error ("pattern variable `" + n + "' already seen in this pattern")
            else ();
            vars <- vars.add (n, 0);
            def (env', decl) = pat_env.add_local(n, D_pattern_variable(), t);
            pat_env <- env';
            P_variable (decl)
          }
          
        | PT.P_underscore => P_underscore ()

        | PT.P_list (lst) =>
          def mklst (lst : list (PT.Pattern)) : PT.Pattern {
            match (lst) {
              | Cons (x, xs) => mkcons (x, mklst (xs))
              | Nil => mknil (p.loc)
            }
          }
          walk (t, mklst (lst))
          
        | PT.P_list_cons (p1, p2) =>
          walk (t, mkcons (p1, p2))
          
        | PT.P_literal (lit) =>
          def t' = Tyexpr.ty_literal (ctx, lit);
          match (Tyutil.unify (t, t', false)) {
            | Some (s) => 
              Tyvar.global_store (s);
              P_literal (lit)
            | None =>
              Message.fatal_error ("literal has type " + t'.as_string () + 
                                   " while matched value has type " + t.as_string ())
          }

        | PT.P_tuple (pats) =>
          match (Tyutil.top_expand (t)) {
            | T_app (ti, args) =>
              def collect_fields (acc : list (string), m : Class_member) : list (string) {
                match (m) {
                  | M_field => Cons (m.name, acc)
                  | _ => acc
                }
              }
              def names = List.rev (List.fold_left (collect_fields, Nil (), ti.member_list));
              match (names) {
                | Cons =>
                  if (List.length (names) == List.length (pats)) {
                    def mk (n : string, p : PT.Pattern) : PT.Named_pattern {
                      PT.Named_pattern (n, p)
                    }
                    walk (t, PT.P_record (List.map2 (mk, names, pats)))
                  } else
                    Message.fatal_error ("pattern matches " + 
                                         string_of_int (List.length (pats)) + 
                                         " values, while type " + 
                                         ti.fullname () + " have " +
                                         string_of_int (List.length (names)) + 
                                         " fields")
                | Nil =>
                    Message.fatal_error ("pattern matches " + string_of_int (List.length (pats)) + 
                                         " values, while type " + ti.fullname () + " has no fields")
              }
              
            | T_prod (ts) =>
              if (List.length (ts) == List.length (pats))
                P_tuple (List.map2 (walk, ts, pats))
              else
                Message.fatal_error ("pattern matches " + 
                                     string_of_int (List.length (pats)) + 
                                     "-tuples, while " + 
                                     string_of_int (List.length (ts)) + 
                                     "-tuple is required")
                                     
            | _ =>
              Message.fatal_error ("pattern matches " + string_of_int (List.length (pats)) + 
                                   "-tuples, not values of type " + t.as_string ())
          }
          
        | PT.P_record (l) =>
          def fn (np : PT.Named_pattern) : Named_pattern {
            // just a placeholder with correct type
            def bogus_expr = E_type_enforcement (null, t);
            def loc = Location_stack.top ();
            bogus_expr.loc <- loc;
            bogus_expr.expr_ty <- t;
            def fr = Tyexpr.lookup_field (loc, bogus_expr, np.name);
            Named_pattern (fr.fld, walk (Tyexpr.type_of (fr), np.pat))
          }
          P_record (List.map (fn, l))
          
        | PT.P_cons (n, p) =>
          if (CSglue.is_capitalized (n)) {
            def ti = pat_env.lookup_type (n);
            match (ti.tydecl) {
              | TD_variant_option =>
                def t' = ti.fresh_generic_type ();
                if (t' >> t)
                  P_cons (ti, walk (t', p))
                else
                  Message.fatal_error ("variant option " + t'.as_string () + 
                                       " doesn't subtype " + t.as_string ())
              | _ =>
                Message.error ("`" + n + "' isn't variant case");
                P_underscore ()
            }
          } else
            match (p) {
              | PT.P_underscore => walk (t, PT.P_variable (n))
              | _ =>
                Message.fatal_error ("`" + n + "' cannot be variant option, " +
                                     "since it starts with lowercase letter")
            }
        | PT.P_quoted_expr (e) =>
          // we use Macros functions to translate quoted pattern
          walk (t, Macros.expr_to_pattern (Macros.quoted_expr (e)))
      }
    }
    and walk (t : Type, p : PT.Pattern) : Pattern {
      def r = do_walk (t, p);
      r.loc <- p.loc;
      r.ty <- t; 
      r
    }

    def r = walk (t, p);
    (r, pat_env)

  }

}
}
