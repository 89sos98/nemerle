(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

public class Hashtable ('a,'b)
where 'a :> System.Object, 'b :> System.Object
{
  mutable hashtable : System.Collections.Hashtable;

  (* constructors *)
  public this () {
    this.hashtable <- System.Collections.Hashtable ();
  }

  public this (capacity : int) {
    this.hashtable <- System.Collections.Hashtable(capacity);
  }

  public this (capacity : int, loadFactor : float) {
    this.hashtable <- System.Collections.Hashtable(capacity,loadFactor);
  }

  (* methods *)
  public add(key : ('a), val : ('b)) : void {
    this.hashtable.Add(key,val);
  }
  
  public get(key : ('a)) : ('b) {
    (this.hashtable [ key ] :> ('b))
  }

  public clear() : void {
    this.hashtable.Clear();
  }

  public clone() : Hashtable('a,'b) {
    (this.hashtable.Clone() :> Hashtable('a,'b))
  }

  public contains(key : ('a)) : bool {
    this.hashtable.Contains(key)
  }

  public count() : int {
    this.hashtable.Count
  }

  public containsValue(val : ('b)) : bool {
    this.hashtable.ContainsValue(val)
  }

  public remove(key : ('a)) : void {
    this.hashtable.Remove(key)
  }

  public iter(f : ('a * 'b) -> void) : void {
    def loop (enumerator : System.Collections.IDictionaryEnumerator) : void {
      if ( (enumerator :> System.Collections.IEnumerator).MoveNext() ) {
      	f( (enumerator.Key :> ('a)),
	   (enumerator.Value :> ('b)) );
	loop(enumerator)   
      } else 
        ()
    }

    loop( this.hashtable.GetEnumerator() )
  }

  public 'c , 'd 
  where 'c :> System.Object, 'd :> System.Object
  map(f : ('a * 'b) -> ('c * 'd)) : Hashtable('c,'d)
       {
    mutable ht <- Hashtable();

    def loop (enumerator : System.Collections.IDictionaryEnumerator) : void {
      if ( (enumerator :> System.Collections.IEnumerator).MoveNext() ) {
      	match ( f ( (enumerator.Key :> ('a)), (enumerator.Value :> ('b)) ) ) {
	  | (k,v) => ht.add(k,v)
	};
	  
	loop(enumerator)   
      } else 
        ()
    }

    loop( this.hashtable.GetEnumerator() );
    ht
  }
}