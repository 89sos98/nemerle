/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met :
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle;

namespace Nemerle.Collections
{
  /**
   * A functional Red-Black Trees implementation
   */
  public module Tree
  {
    /*
     * Definition of the node Node <'a> of tree
     */
    public variant Node <'a> where 'a : IComparable <'a> {
      | RedNode {
          key : 'a;
          lchild : Node <'a>;
          rchild : Node <'a>; 
        }
      | BlackNode {
          key : 'a;
          lchild : Node <'a>;
          rchild : Node <'a>; 
        }
      | Leaf
    }

    /**
     * Function finds a node and returns it (if any) as an option <'a>
     */
    public Get <'a> (tree : Node <'a>, elem : 'a) : option <'a>
      where 'a : IComparable <'a>
    {
      def get (tree : Node <'a>, candidate : option <'a>) : option <'a> 
      { 
        match (tree) {
          | (RedNode) as tree => 
            if (tree.key.CompareTo (elem) > 0)
              get (tree.lchild, candidate)
            else
              get (tree.rchild, Some (tree.key)) 
          | (BlackNode) as tree => 
            if (tree.key.CompareTo (elem) > 0)
              get (tree.lchild, candidate)
            else
              get (tree.rchild, Some (tree.key))
          | Leaf =>
            match (candidate) {
              | Some (key) =>
                if (elem.CompareTo (key) == 0)
                  candidate
                else 
                  None ()
              | None => None ()
            }
        }
      }
      
      get (tree, None ())
    }

    
    /**
     * Function returns a passed tree TREE with inserted element ELEM. If node
     * is already present in tree either throw exception or replace node,
     * depending on REPLACE.
     */
    public Insert<'a> (tree : Node <'a>, elem : 'a, replace : bool) : Node <'a>
      where 'a : IComparable <'a>
    {
      def insert (tree) {
        | RedNode (key, ltree, rtree) =>
          if (elem.CompareTo (key) > 0)
            RedNode (key, ltree, insert (rtree))
          else if (elem.CompareTo (key) < 0)
            RedNode (key, insert (ltree), rtree)
          else if (replace)
            RedNode (elem, ltree, rtree)
          else
            throw System.ArgumentException ("node already in the tree")
        | BlackNode (key, ltree, rtree) =>
          if (elem.CompareTo (key) > 0)
            BalanceRight (key, ltree, insert (rtree))
          else if (elem.CompareTo (key) < 0)
            BalanceLeft (key, insert (ltree), rtree)
          else if (replace)
            BlackNode (elem, ltree, rtree)
          else 
            throw System.ArgumentException ("node already in the tree")
        | Leaf => 
          RedNode (elem, Leaf (), Leaf ())
      }
      
      match (insert (tree)) {
        | (BlackNode) as tree => tree
        | RedNode (key, ltree, rtree) =>
          BlackNode (key, ltree, rtree)
        | Leaf => assert (false)
      }
    }

    
    /** 
     * Function returns a passed tree TREE with removed element ELEM. If element was
     * not in the tree exception is thrown.
     */ 
    public Delete<'a> (tree : Node <'a>, elem : 'a) : Node <'a>
      where 'a : IComparable <'a>
    {
      def delete (tree) {
        | RedNode (key, ltree, rtree)
        | BlackNode (key, ltree, rtree) =>
          if (elem.CompareTo (key) > 0)
            match (rtree) {
              | BlackNode =>
                BalRight (key, ltree, delete (rtree))
              | _ => 
                RedNode (key, ltree, delete (rtree))
            } 
          else if (elem.CompareTo (key) < 0)
            match (ltree) {
              | BlackNode =>
                BalLeft (key, delete (ltree), rtree)
              | _ =>
                RedNode (key, delete (ltree), rtree)
            }
          else 
            GetSubst (ltree, rtree)
            
        | Leaf =>
          throw System.ArgumentException ("node not in the tree")
      }
      
      match (delete (tree)) {
        | (BlackNode) as res => res
        | RedNode (key, ltree, rtree) =>
          BlackNode (key, ltree, rtree)
        | Leaf => Leaf ()
      } 
    }

    /**
     * Function goes through each TREE node and counts cumulative
     * value of function FUNC with intial value INI
     */
    public Fold<'a, 'b> (tree : Node <'a>, func : 'a * 'b -> 'b, ini : 'b) : 'b 
      where 'a : IComparable <'a> 
    {
      match (tree) {
        | RedNode (key, ltree, rtree)
        | BlackNode (key, ltree, rtree) =>
            Fold (rtree, func, func (key, Fold (ltree, func, ini)))
        | Leaf => ini
      }
    } 

    
    /**
     * Function returns true if and only if there exists such node X 
     * of TREE that FUNC(X) is true 
     */
    public Exists<'a> (tree : Node <'a>, func : 'a -> bool) : bool
      where 'a : IComparable <'a> 
    {
      match (tree) {
        | RedNode (key, ltree, rtree)
        | BlackNode (key, ltree, rtree) =>
          func (key) || Exists (ltree, func) || Exists (rtree, func)
        | _ => false
      }
    }

    
    /**
     * Function returns true if and only if for every node X 
     * of TREE FUNC(X) is true 
     */ 
    public ForAll<'a> (tree : Node <'a>, func : 'a -> bool) : bool
      where 'a : IComparable <'a> 
    {
      match (tree) {
        | RedNode (key, ltree, rtree)
        | BlackNode (key, ltree, rtree) =>
          func (key) && ForAll (ltree, func) && ForAll (rtree, func)
        | _ => true
      }
    }


    /**
     * Function returns TREE1 * INT1 * TREE2 * INT2 where tree TREE1 consists
     * of this nodes X of TREE that FUNC(X) is true and tree TREE2 contains
     * all nodes of TREE that are not in TREE1. INT1 is the size of TREE1 and
     * INT2 is the size of TREE2   
     */
    public CountPartition <'a> (tree : Node <'a>, func : 'a -> bool) 
      : Node <'a> * int * Node <'a> * int where 'a : IComparable <'a>
    {
      def partition (tree, yntree)
      {
        match (tree) {
          | RedNode (key, ltree, rtree)
          | BlackNode (key, ltree, rtree) =>
            def (ytree, ysize, ntree, nsize) = yntree;
            def yntree =
              if (func (key))
                (Insert (ytree, key, false), ysize + 1, ntree, nsize)
              else 
                (ytree, ysize, Insert (ntree, key, false), nsize + 1);
            partition (rtree, partition (ltree, yntree))
          | Leaf => yntree
        }
      }
      
      partition (tree, (Leaf (), 0, Leaf (), 0))
    } 

    
    /**
     * Function returns TREE1 * TREE2 where tree TREE1 consists of this nodes X
     * of TREE that FUNC(X) is true and tree TREE2 contains all nodes of TREE 
     * that are not in TREE1.   
     */
    public Partition <'a> (tree : Node <'a>, func : 'a -> bool)
      : Node <'a> * Node <'a> where 'a : IComparable <'a> 
    {
      def (ytree, _, ntree, _) = CountPartition (tree, func);
      (ytree, ntree)
    }

    
    /**
     * Functions returns TREE1 * INT1 where TREE1 is a tree that contains this nodes X 
     * of TREE that FUNC(X) is true and INT1 is the size of TREE1
     */
    public CountFilter <'a> (tree : Node <'a>, func : 'a -> bool)
      : Node <'a> * int where 'a : IComparable <'a> 
    {
      def filter (tree, ytree)
      {
        match (tree) {
          | RedNode (key, ltree, rtree)
          | BlackNode (key, ltree, rtree) =>
            def (ytree, ysize) = ytree;
            if (func (key))
              filter (rtree, filter (ltree, (Insert (ytree, key, false), ysize + 1)))
            else 
              filter (rtree, filter (ltree, (ytree, ysize)))
          | Leaf => ytree
        }
      }
      
      filter (tree, (Leaf (), 0))
    } 

    
    /**
     * Functions returns a tree that contains this nodes X 
     * of TREE that FUNC(X) is true
     */
    public Filter <'a> (tree : Node <'a>, func : 'a -> bool) : Node <'a>
      where 'a : IComparable <'a> 
    {
      def (tree, _) = CountFilter (tree, func);
      tree
    }

  
/*
  FIXME: There is a problem with this function - it doesn't need to do correct tranformation

    public Map<'a,'b> (tree : Node <'a>, func : 'a -> 'b) : Node <'b>
      where 'a : IComparable <'a>
      where 'b :> IComparable <'b>
    {
      def map (tree: Node <'a>) : Node <'b>
          {
            match (tree) {
              | Tr (key, color, ltree, rtree) =>
                  Tr (func (key), color, map (ltree), map (rtree))
              | Leaf => Leaf ()
            } 
          };
      map (tree)
    }
*/   

    /**
     * Internal functions used for tree balancing 
     */
    private BalRight <'a> (elem : 'a, lchild : Node <'a>, rchild : Node <'a>)
      : Node <'a> where 'a : IComparable <'a>
    {
      match ((elem, lchild, rchild)) {
        | (key, ltree, RedNode (key1, ltree1, rtree1)) =>
          RedNode (key, ltree, BlackNode (key1, ltree1, rtree1))
        | (key, BlackNode (key1, ltree1, rtree1), rtree) =>
          BalanceLeft (key, RedNode (key1, ltree1, rtree1), rtree)
        | (key, RedNode (key1, BlackNode (key3, ltree3, rtree3), BlackNode (key2, ltree2, rtree2)), rtree) =>
          RedNode (key2,
                   BalanceLeft (key1, RedNode (key3, ltree3, rtree3), ltree2),
                   BlackNode (key, rtree2, rtree))
        | _ =>
          assert (false, "balance violation")
      }
    }

    private BalLeft <'a> (elem : 'a, lchild : Node <'a>, rchild : Node <'a>)
      : Node <'a> where 'a : IComparable <'a>
    {
      match ((elem, lchild, rchild)) {
        | (key, RedNode (key1, ltree1, rtree1), rtree) =>
          RedNode (key, BlackNode (key1, ltree1, rtree1), rtree)
        | (key, ltree, BlackNode (key1, ltree1, rtree1)) =>
          BalanceRight (key, ltree, RedNode (key1, ltree1, rtree1))
        | (key, ltree, RedNode (key1, BlackNode (key3, ltree3, rtree3), BlackNode (key2, ltree2, rtree2))) =>
          RedNode (key3,
                   BlackNode (key, ltree, ltree3),
                   BalanceRight (key1, rtree3, RedNode (key2, ltree2, rtree2)))
        | _ =>
          assert (false, "balance violation")
      }
    }

    private GetSubst <'a> (lchild : Node <'a>, rchild : Node <'a>)
      : Node <'a> where 'a : IComparable <'a>
    {
      match ((lchild, rchild)) {
        | (Leaf, tree) => tree
        | (tree, Leaf) => tree
        | (RedNode (key, ltree, rtree), RedNode (key1, ltree1, rtree1)) =>
          match (GetSubst (rtree, ltree1)){
            | RedNode (key2, ltree2, rtree2) =>
              RedNode (key2, RedNode (key, ltree, ltree2), RedNode (key1, rtree2, rtree1))
            | tree => RedNode (key, ltree, RedNode (key1, tree, rtree1))
          }
        | (BlackNode (key, ltree, rtree), BlackNode (key1, ltree1, rtree1)) =>
          match (GetSubst (rtree, ltree1)){
            | RedNode (key2, ltree2, rtree2) =>
              RedNode (key2, BlackNode (key, ltree, ltree2), BlackNode (key1, rtree2, rtree1))
            | tree => BalLeft (key, ltree, BlackNode (key1, tree, rtree1))
          }
        | (tree, RedNode (key, ltree, rtree)) =>
          RedNode (key, GetSubst (tree, ltree), rtree)
        | (RedNode (key, ltree, rtree), tree) =>
          RedNode (key, ltree, GetSubst (rtree, tree))
      }
    }

    private BalanceLeft<'a> (elem : 'a, lchild : Node <'a>, rchild : Node <'a>)
      : Node <'a> where 'a : IComparable <'a>
    {
      match ((elem, lchild, rchild)) {
        | (key, RedNode (key1, ltree1, rtree1), RedNode (key2, ltree2, rtree2)) =>
          RedNode (key, BlackNode (key1, ltree1, rtree1), BlackNode (key2, ltree2, rtree2))
        | (key, RedNode (key1, RedNode (key2, ltree2, rtree2), rtree1), rtree) =>
          RedNode (key1, BlackNode (key2, ltree2, rtree2), BlackNode (key, rtree1, rtree))
        | (key, RedNode (key1, ltree1, RedNode (key2, ltree2, rtree2)), rtree) =>
          RedNode (key2, BlackNode (key1, ltree1, ltree2), BlackNode (key, rtree2, rtree))
        | (key, ltree, rtree) =>
          BlackNode (key, ltree, rtree)
      } 
    }

    private BalanceRight<'a> (elem : 'a, lchild : Node <'a>, rchild : Node <'a>)
      : Node <'a> where 'a : IComparable <'a>
    {
      match ((elem, lchild, rchild)) {
        | (key, RedNode (key1, ltree1, rtree1), RedNode (key2, ltree2, rtree2)) =>
          RedNode (key, BlackNode (key1, ltree1, rtree1), BlackNode (key2, ltree2, rtree2))
        | (key, ltree, RedNode (key1, ltree1, RedNode (key2, ltree2, rtree2))) =>
          RedNode (key1, BlackNode (key, ltree, ltree1), BlackNode (key2, ltree2, rtree2))
        | (key, ltree, RedNode (key1, RedNode (key2, ltree2, rtree2), rtree1)) =>
          RedNode (key2, BlackNode (key, ltree, ltree2), BlackNode (key1, rtree2, rtree1))
        | (key, ltree, rtree) =>
          BlackNode (key, ltree, rtree)
      } 
    } 
  } 


  /* ------------------------------------------------------------------------ */
  /* -- PUBLIC INTERFACES --------------------------------------------------- */
  /* ------------------------------------------------------------------------ */

  /**
   * Interface dedicated to be the only way to interact with Map object.
   *
   * FIXME: why this isn't IDictionary?
   */
  public interface IMap <'a, 'b>
  {
    /**
     * Method returns a IMap ('a, 'b) with added pair (k, v)
     */
    Add (k : 'a, v : 'b) : IMap <'a, 'b>;
    
    /**
     * Returns the value associated with a key.
     */
    Get (k : 'a) : 'b;

    /**
     * Method returns an empty IMap <'a, 'b>
     */
    Clear () : IMap <'a, 'b>;
    
    /**
     * Method returns a copy of THIS IMap <'a, 'b> 
     */
    Copy () : IMap <'a, 'b>;
    
    /**
     * Method returns true if and only if there exists such pair (X,Y) 
     * of THIS IMap ('a,'b) that FUNC(X,Y) is true 
     */
    Exists (func : 'a * 'b -> bool) : bool;
    
    /**
     * Method returns an IMAP that consists of THIS pair (X,Y)
     * of THIS IMap that FUNC(X) is true   
     */ 
    Filter (func : 'a * 'b -> bool) : IMap <'a, 'b>;
    
    /**
     * Method finds and returns a value associated with key K
     * (if there is no such value then None is returned)
     */
    Find (k : 'a) : option <'b>;
    
    /**
     * Method returns some value that is contained in IMap
     * Note: This value depends on IMap manipulation 
     */
    First () : 'b;
    
    /**
     * Method goes through each of THIS IMap pair and counts cumulative
     * value of function FUNC with intial value INI
     */  
    Fold<'c> (func : 'a * 'b * 'c -> 'c, ini : 'c) : 'c;
    
    /**
     * Method returns true if and only if for every pair (X,Y) 
     * of THIS IMap ('a,'b) FUNC(X,Y) is true 
     */
    ForAll (func : 'a * 'b -> bool) : bool;
    
    /**
     * Method goes through each of THIS Imap pair (X,Y) and computes
     * FUNC (X,Y) 
     */
    Iter (func : 'a * 'b -> void) : void;
    
    /**
     * Method return true if a key K is contained in THIS IMap
     */
    Member (k : 'a) : bool;
    
    /**
     * Method returns IMAP1 * IMAP2 where IMAP1 consists of this pair (X,Y)
     * of IMAP1 that FUNC(X) is true and IMAP2 contains all this pairs of THIS IMap 
     * that are not in IMAP1.   
     */
    Partition (func : 'a * 'b -> bool) : IMap <'a, 'b> * IMap <'a, 'b>;
    
    /**
     * Method returns THIS IMap with removed key K and associated value
     */
    Remove (k : 'a) : IMap <'a, 'b>;
    
    /**
     * Method returns THIS IMap with replaced pair (K,V)
     */
    Replace (k : 'a, v : 'b) : IMap <'a, 'b>;

    /**
     * Checks if there are any elements in the map.
     */
    IsEmpty : bool { get; }
    
    /**
     * Returns the number of elements in THIS IMap
     */
    Size : int { get; }

    /**
     * Returns the number of elements in THIS IMap
     */
    Count : int { get; }
  }     

  internal class NodeSys <'a, 'b>
    : IComparable <NodeSys <'a, 'b>> where 'a : System.IComparable 
  {
    public key : 'a;
    public val : 'b;
    
    internal CompareTo (x : NodeSys <'a, 'b>) : int implements IComparable.CompareTo
    {
      // workaround bug in Mono, CompareTo on strings is not transitive
      match ((key : object, x.key : object)) {
        | (key : string, xkey : string) =>
          string.CompareOrdinal (key, xkey)
        | _ =>
          key.CompareTo (x.key)
      }
    }

    public this (k : 'a, v : 'b) 
    { 
      this.key = k; 
      this.val = v;
    }

    public this (k : 'a) 
    {
      this.key = k;
    }
  } 

  internal class NodeNem <'a, 'b>
    : IComparable <NodeNem <'a, 'b>>
    where 'a : IComparable <'a> 
  {
    public key : 'a;
    public val : 'b;
    
    internal CompareTo (x : NodeNem <'a, 'b>) : int implements IComparable.CompareTo
    { 
      key.CompareTo (x.key) 
    }

    public this (k : 'a, v : 'b) 
    { 
      this.key = k; 
      this.val = v;
    }

    public this (k : 'a) 
    {
      this.key = k;
    }
  } 

  /* definition of Map class that uses Nemerle.IComparable.CompareTo method of 'a for comparision */
   
  public class NemerleMap <'a, 'b>
    : IMap <'a, 'b> 
    where 'a : IComparable <'a> 
  {
    private root : Tree.Node <NodeNem <'a, 'b>>;
    private size : int;

    // TODO : Make it implement ICollection (problem with names and being functional or imperative - both mb)

    public this ()
    {
      this.root = Tree.Leaf ();
      this.size = 0;
    }

    private this (size : int, r : Tree.Node <NodeNem <'a, 'b>>) 
    {
      this.size = size;
      this.root = r;
    }

    public Copy () : NemerleMap <'a, 'b> 
      implements IMap.Copy
    {
      this
    }


    public First () : 'b  
      implements IMap.First
    {
      match (root) {
        | Tree.Leaf => throw System.ArgumentException ("map is empty")
        | Tree.RedNode (key, _, _)
        | Tree.BlackNode (key, _, _) => key.val
      }
    }

    public IsEmpty : bool 
    {
      get
      {
        match (root) {
          | Tree.Leaf => true
          | _ => false
        }
      }
    }

    public Clear () : NemerleMap <'a, 'b> 
      implements IMap.Clear
    {
      NemerleMap ()
    }

    public Add (k : 'a, v : 'b) : NemerleMap <'a, 'b>  
      implements IMap.Add
    { 
      NemerleMap (size + 1, Tree.Insert (root, NodeNem (k, v), false))
    }

    public Replace (k : 'a, v : 'b) : NemerleMap <'a, 'b>  
      implements IMap.Replace
    {
      def node = NodeNem (k, v);
      if (Option.IsSome (Tree.Get (root, node)))
        NemerleMap (size, Tree.Insert (root, NodeNem (k, v), true))
      else
        NemerleMap (size + 1, Tree.Insert (root, NodeNem (k, v), true))
    }

    public Find (k : 'a) : option <'b>  
      implements IMap.Find
    {
      match (Tree.Get (root, NodeNem (k))) {
        | Some (n) => Some (n.val) 
        | None => None ()
      }
    }

    public Get (k : 'a) : 'b  
      implements IMap.Get
    {
      match (Tree.Get (root, NodeNem (k))) {
        | Some (n) => n.val 
        | None => throw System.ArgumentException ("key not found")
      }
    }

    public Member (k : 'a) : bool 
      implements IMap.Member
    {
      Option.IsSome (Tree.Get (root, NodeNem (k)))
    }
 
    public Remove (k : 'a) : NemerleMap <'a, 'b> 
      implements IMap.Remove
    {
      NemerleMap (size - 1, Tree.Delete (root, NodeNem (k)))
    }

    public Size : int 
    {
      get { size }
    }

    public Count : int 
    {
      get { size }
    }
    
    public Fold<'d> (func : 'a * 'b * 'd -> 'd, ini : 'd) : 'd 
      implements IMap.Fold
    {
      def wrap (n : NodeNem <'a, 'b>, ctx) { func (n.key, n.val, ctx) };
      Tree.Fold (root, wrap, ini)
    }

    public Iter (func : 'a * 'b -> void) : void 
      implements IMap.Iter
    {
      def wrap (n : NodeNem <'a, 'b>, ctx) { 
        func (n.key, n.val); ctx 
      };
      ignore (Tree.Fold (root, wrap, null));
    }
    
    public ForAll (func : 'a * 'b -> bool) : bool 
      implements IMap.ForAll
    {
      def wrap (keyval : NodeNem <'a, 'b>) {
        func (keyval.key, keyval.val) 
      }; 
      Tree.ForAll (root, wrap)
    }

    public Exists (func : 'a * 'b -> bool) : bool 
      implements IMap.Exists
    {
      def wrap (keyval : NodeNem <'a, 'b>) {
        func (keyval.key, keyval.val) 
      }; 
      Tree.Exists (root, wrap)
    }

    public Filter (func : 'a * 'b -> bool) : NemerleMap <'a, 'b> 
      implements IMap.Filter
    {
      def wrap (keyval : NodeNem <'a, 'b>) {
        func (keyval.key, keyval.val) 
      };
      def (ytree, ycount) = Tree.CountFilter (this.root, wrap);
      NemerleMap (ycount, ytree) 
    }

    public Partition (func : 'a * 'b -> bool) 
      : NemerleMap <'a, 'b> * NemerleMap <'a, 'b> 
      implements IMap.Partition
    {
      def wrap (keyval : NodeNem <'a, 'b>) { 
        func (keyval.key, keyval.val) 
      };
      def (ytree, ycount, ntree, ncount) = Tree.CountPartition (this.root, wrap);
      (NemerleMap (ycount, ytree), NemerleMap (ncount, ntree)) 
    }

  }

  /* definition of Map class that uses System.IComparable.CompareTo method of 'a for comparision */
  
  public class SystemMap <'a, 'b> : IMap <'a, 'b>
    where 'a : System.IComparable 
  {
    private root : Tree.Node <NodeSys <'a, 'b>>;
    private size : int;

    // TODO : Make it implement ICollection (problem with names and being functional or imperative - both mb)

    public this ()
    {
      this.root = Tree.Leaf ();
      this.size = 0;
    }

    private this (size : int, r : Tree.Node <NodeSys <'a, 'b>>) 
    {
      this.size = size;
      this.root = r;
    }

    public Copy () : SystemMap <'a, 'b> 
      implements IMap.Copy
    {
      this
    }


    public First () : 'b  
      implements IMap.First
    {
      match (root) {
        | Tree.Leaf => throw System.ArgumentException ("map is empty")
        | Tree.RedNode (key, _, _)
        | Tree.BlackNode (key, _, _) => key.val
      }
    }

    public IsEmpty : bool 
    {
      get
      {
        match (root) {
          | Tree.Leaf => true
          | _ => false
        }
      }
    }

    public Clear () : SystemMap <'a, 'b> 
      implements IMap.Clear
    {
      SystemMap ()
    }

    public Add (k : 'a, v : 'b) : SystemMap <'a, 'b>  
      implements IMap.Add
    { 
      SystemMap (size + 1, Tree.Insert (root, NodeSys (k, v), false))
    }

    public Replace (k : 'a, v : 'b) : SystemMap <'a, 'b>  
      implements IMap.Replace
    {
      def node = NodeSys (k, v);
      if (Option.IsSome (Tree.Get (root, node)))
        SystemMap (size, Tree.Insert (root, NodeSys (k, v), true))
      else
        SystemMap (size + 1, Tree.Insert (root, NodeSys (k, v), true))
    }

    public Find (k : 'a) : option <'b>  
      implements IMap.Find
    {
      match (Tree.Get (root, NodeSys (k))) {
        | Some (n) => Some (n.val) 
        | None => None ()
      }
    }

    public Get (k : 'a) : 'b  
      implements IMap.Get
    {
      match (Tree.Get (root, NodeSys (k))) {
        | Some (n) => n.val 
        | None => throw System.ArgumentException ("key not found")
      }
    }

    public Member (k : 'a) : bool 
      implements IMap.Member
    {
      Option.IsSome (Tree.Get (root, NodeSys (k)))
    }
 
    public Remove (k : 'a) : SystemMap <'a, 'b> 
      implements IMap.Remove
    {
      SystemMap (size - 1, Tree.Delete (root, NodeSys (k)))
    }

    public Size : int 
    {
      get { size }
    }

    public Count : int 
    {
      get { size }
    }

    public Fold<'d> (func : 'a * 'b * 'd -> 'd, ini : 'd) : 'd 
      implements IMap.Fold
    {
      def wrap (n : NodeSys <'a, 'b>, ctx) { func (n.key, n.val, ctx) };
      Tree.Fold (root, wrap, ini)
    }

    public Iter (func : 'a * 'b -> void) : void 
      implements IMap.Iter
    {
      def wrap (n : NodeSys <'a, 'b>, ctx) { 
        func (n.key, n.val); ctx 
      };
      ignore (Tree.Fold (root, wrap, null));
    }
    
    public ForAll (func : 'a * 'b -> bool) : bool 
      implements IMap.ForAll
    {
      def wrap (keyval : NodeSys <'a, 'b>) {
        func (keyval.key, keyval.val) 
      }; 
      Tree.ForAll (root, wrap)
    }

    public Exists (func : 'a * 'b -> bool) : bool 
      implements IMap.Exists
    {
      def wrap (keyval : NodeSys <'a, 'b>) {
        func (keyval.key, keyval.val) 
      }; 
      Tree.Exists (root, wrap)
    }

    public Filter (func : 'a * 'b -> bool) : SystemMap <'a, 'b> 
      implements IMap.Filter
    {
      def wrap (keyval : NodeSys <'a, 'b>) {
        func (keyval.key, keyval.val) 
      };
      def (ytree, ycount) = Tree.CountFilter (this.root, wrap);
      SystemMap (ycount, ytree) 
    }

    public Partition (func : 'a * 'b -> bool) 
      : SystemMap <'a, 'b> * SystemMap <'a, 'b> 
      implements IMap.Partition
    {
      def wrap (keyval : NodeSys <'a, 'b>) { 
        func (keyval.key, keyval.val) 
      };
      def (ytree, ycount, ntree, ncount) = Tree.CountPartition (this.root, wrap);
      (SystemMap (ycount, ytree), SystemMap (ncount, ntree)) 
    }
  }
}
