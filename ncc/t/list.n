(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open funs;

variant list ('a) = [
  | Cons { head : 'a; tail : list ('a); }
  | Nil {}
]

class funs {
  fun ('a, 'b) map (f : 'a -> 'b, x : list ('a)) : list ('b) = 
    match x with [
      | Nil => Nil ()
      | Cons (?h, ?t) => Cons (f (h), map (f, t))
    ];

  fun ('a) length (x : list ('a)) : int =
    letfun loop (acc : int, x : list ('a)) : int =
      match x with [
	| Cons ?x => loop (acc + 1, x#tail)
        | _ => acc
      ] in loop (0, x);

  fun ('a, 'b) fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b =
    match l with [
      | Nil ?_ => acc
      | Cons ?l => fold_left (f, f (acc, l#head), l#tail)
    ];

  fun ('a) iter (f : 'a -> void, l : list ('a)) : void =
    letfun i (dummy : int, e : 'a) : int { f (e); dummy } in
    let _ = fold_left (i, 0, l) in
    ();

  fun ('a) cons (e1 : 'a) : list ('a) =
    Cons (e1, Nil ());
    
  fun ('a) cons (e1 : 'a, e2 : 'a) : list ('a) =
    Cons (e1, cons (e2));
    
  fun ('a) cons (e1 : 'a, e2 : 'a, e3 : 'a) : list ('a) =
    Cons (e1, cons (e2, e3));
    
  fun Main () : void {
    let l = cons ("foo", "bar", "baz") in {
      let ref acc = ":" in
      letfun prt (s : string) : void {
        acc <- acc + ":" + s;
        print_endline(s) 
      } in
      {
        iter (prt, l);
        print_endline (acc)
      };
      letfun concat (acc : string, s : string) : string = acc + "." + s in
      print_endline (fold_left (concat, "", l))
    }
  }
}

(*
BEGIN-OUTPUT
foo
bar
baz
::foo:bar:baz
.foo.bar.baz
END-OUTPUT
*)
