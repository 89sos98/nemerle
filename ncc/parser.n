(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Collections;
open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

module Parser {

  class CTX {
    public lexer : ILexer;
    public mutable last_token : Token;
    public mutable push_back : option (Token);
  }

  'a where 'a :> Located 
  opt_locate (ctx : CTX, f : void -> option ('a)) : option ('a) {
    def loc = ctx.lexer.get_location ();
    def ret = Util.locate (loc, f);
    match (ret) {
      | Some (x) => x.loc <- loc
      | None => ()
    };
    ret
  }

  'a where 'a :> Located 
  locate (ctx : CTX, f : void -> 'a) : 'a {
    def loc = ctx.lexer.get_location ();
    def ret = Util.locate (loc, f);
    ret.loc <- loc;
    ret
  }

  get_token (ctx : CTX) : Token { 
    match (ctx.push_back) {
      | Some (x) =>
        ctx.push_back <- None ();
        x
      | None =>
        ctx.last_token <- ctx.lexer.get_token ();
        ctx.last_token
    }
  }

  peek_token (ctx : CTX) : Token {
    def tok = get_token (ctx);
    push_back (ctx);
    tok
  }
  
  push_back (ctx : CTX) : void {
    match (ctx.push_back) {
      | Some => Util.ice ()
      | None =>
        ctx.push_back <- Some (ctx.last_token)
    }
  }

  location (ctx : CTX) : Location {
    ctx.lexer.get_location ()
  }

  'a fatal_error (ctx : CTX, msg : string) : 'a {
    // FIXME: near symbol...
    Message.fatal_error (location (ctx), "parse error: " + msg)
  }

  error (ctx : CTX, msg : string) : void {
    Message.error (location (ctx), "parse error: " + msg)
  }

  get_qid (ctx : CTX) : string {
    def loop (acc) {
      match (get_token (ctx)) {
        | Tok_operator (".", _) =>
          match (get_token (ctx)) {
            | Tok_identifier (x) => loop (acc + "." + x)
            | _ => fatal_error (ctx, "expecting identifier after dot in qualified ID")
          }
        | _ =>
          push_back (ctx);
          acc
      }
    };

    match (get_token (ctx)) {
      | Tok_identifier (x) =>
        loop (x)
      | _ =>
        fatal_error (ctx, "expecting qualified identifier")
    }
  }
  
  get_id (ctx : CTX) : string {
    match (get_token (ctx)) {
      | Tok_identifier (x) => x
      | _ =>
        fatal_error (ctx, "expecting identifier")
    }
  }
  
  get_id_or_dummy (ctx : CTX) : string {
    match (get_token (ctx)) {
      | Tok_identifier (x) => x
      | Tok_keyword ("_") => "_N_d" + string_of_int (Util.next_id ())
      | _ =>
        fatal_error (ctx, "expecting identifier")
    }
  }
  
  get_tyvar (ctx : CTX) : string {
    match (get_token (ctx)) {
      | Tok_tyvar (tv) => tv
      | _ => fatal_error (ctx, "expecting type variable")
    }
  }

  expect_operator (ctx : CTX, op : string) : void {
    match (get_token (ctx)) {
      | Tok_operator (o, _) when op == o => ()
      | _ =>
        fatal_error (ctx, "expecting '" + op + "'");
    }
  }

  parse_fun_header (ctx : CTX, 
                    allow_inference : bool, 
                    allow_ctor : bool,
                    got_name : bool) : Fun_header 
  {
    def tok = get_token (ctx);
    locate (ctx, fun () {
      def typarms =
        match (tok) {
          | Tok_tyvar when !got_name =>
            push_back (ctx);
            def tyvars = operator_separated_list (ctx, ",", get_tyvar);
            parse_where_constraints (ctx, tyvars);
          | _ => 
            push_back (ctx); 
            Typarms ([], [])
        };
      def name =
        if (got_name) "?"
        else
          match (get_token (ctx)) {
            | Tok_keyword ("this") when allow_ctor => ".ctor"
            | Tok_identifier (n) => n
            | _ => fatal_error (ctx, "expecting function name")
          };
      expect_operator (ctx, "(");
      def parse_parm (_) {
        def id = get_id_or_dummy (ctx);
        def loc = location (ctx);
        def t =
          match (get_token (ctx)) {
            | Tok_operator (":", _) => parse_type (ctx)
            | _ when allow_inference => push_back (ctx); T_infer ()
            | _ => fatal_error (ctx, "expecting typing constraint after parameter name")
          };
        Fun_parm (loc = loc, name = id, ty = t)
      };
      def parms = operator_separated_list (ctx, ",", parse_parm);
      expect_operator (ctx, ")");
      def ret_type =
        match (get_token (ctx)) {
          | Tok_operator (":", _) => parse_type (ctx)
          | _ when allow_inference => push_back (ctx); T_infer ()
          | _ => fatal_error (ctx, "expecting typing constraint on function return value")
        };
      Fun_header (name = name,
                  ret_type = ret_type, 
                  parms = parms, 
                  typarms = typarms)
    })
  }

  parse_block (ctx : CTX) : Expr { null } // FIXME
  
  parse_type_member (ctx : CTX) : Class_member {
    ignore (peek_token (ctx));
    def loc = location (ctx);
    def attrs = get_attrs (ctx);

    def parse_extern () {
      match (get_token (ctx)) {
        | Tok_keyword ("extern") =>
          match (get_token (ctx)) {
            | Tok_string_literal (s) => 
              expect_operator (ctx, ";");
              s
            | _ => fatal_error (ctx, "found some junk after extern (expecting string)")
          }
        | _ => fatal_error (ctx, "found some junk after `=' (expecting extern)")
      }
    };

    def parse_fun (h : Fun_header) {
      def impl =
        match (get_token (ctx)) {
          | Tok_keyword ("implements") =>
            operator_separated_list (ctx, ",", get_qid)
          | _ => push_back (ctx); []
        };
      def body =
        match (peek_token (ctx)) {
          | Tok_operator ("=", _) =>
            ignore (get_token (ctx));
            FB_extern (parse_extern ())
          | Tok_operator ("{", _) =>
            FB_parsed_expr (parse_block (ctx))
          | _ => fatal_error (ctx, "expecting method body")
        };
      
      M_function (header = h, 
                  name = h.name, 
                  modifiers = attrs, 
                  loc = loc, 
                  body = body, 
                  kind = FK_method (impl))
    };
    
    def parse_field (is_ref, name) {
      expect_operator (ctx, ":");
      def t = parse_type (ctx);
      def valkind = 
        match (get_token (ctx)) {
          | Tok_operator (";", _) => Val_normal ()
          | Tok_operator ("=", _) => Val_extern (parse_extern ())
          | _ => fatal_error (ctx, "found some junk after field")
        };
      
      M_field (loc = loc,
               name = name, 
               modifiers = attrs, 
               ty = t, 
               is_ref = is_ref, 
               kind = valkind);
    };

    match (get_token (ctx)) {
      | Tok_tyvar =>
        def h = parse_fun_header (ctx, 
                                  allow_ctor = true, 
                                  allow_inference = false, 
                                  got_name = false);
        push_back (ctx);
        parse_fun (h)
        
      | Tok_keyword ("mutable") =>
        match (get_token (ctx)) {
          | Tok_identifier (name) => parse_field (true, name)
          | _ => fatal_error (ctx, "expecting field name")
        }
        
      | Tok_identifier (name) =>
        match (peek_token (ctx)) {
          | Tok_operator ("(", _) => 
            def h = parse_fun_header (ctx, 
                                      allow_ctor = true, 
                                      allow_inference = false, 
                                      got_name = true);
            h.name <- name;
            parse_fun (h)
          | _ => parse_field (false, name)
        }

      | _ =>
        def td = parse_type_decl (ctx);
        td.modifiers <- List.append (td.modifiers, attrs);
        M_type (td)
    }
  }
  
  parse_type (ctx : CTX) : Type { null } // FIXME

  get_attrs (ctx : CTX) : list (Modifier) {
    def loop (acc) {
      match (get_token (ctx)) {
        | Tok_keyword ("new") => loop (Mod_new () :: acc)
        | Tok_keyword ("public") => loop (Mod_public () :: acc)
        | Tok_keyword ("protected") => loop (Mod_protected () :: acc)
        | Tok_keyword ("internal") => loop (Mod_internal () :: acc)
        | Tok_keyword ("private") => loop (Mod_private () :: acc)
        | Tok_keyword ("abstract") => loop (Mod_abstract () :: acc)
        | Tok_keyword ("sealed") => loop (Mod_sealed () :: acc)
        | Tok_keyword ("static") => loop (Mod_static () :: acc)
        | _ =>
          push_back (ctx);
          List.rev (acc)
      }
    };
    loop ([])
  }
  
  'a operator_separated_list (ctx : CTX, op : string, f : CTX -> 'a) : list ('a) {
    def loop (acc) {
      match (get_token (ctx)) {
        | Tok_operator (o, _) when o == op => loop (f (ctx) :: acc)
        | _ => push_back (ctx); List.rev (acc)
      }
    };

    loop ([f (ctx)])
  }
  
  parse_tyvars (ctx : CTX) : list (string) {
    operator_separated_list (ctx, ",", get_tyvar)
  }

  parse_where_constraints (ctx : CTX, tyvars : list (string)) : Typarms {
    def constraints =
      if (flag_keyword (ctx, "where")) {
        def parse_constraint (_) {
          def tv = get_tyvar (ctx);
          expect_operator (ctx, ":>");
          def t = parse_type (ctx);
          Constraint (tv, t)
        };
        operator_separated_list (ctx, ",", parse_constraint)
      } else [];
    Typarms (tyvars, constraints)
  }

  flag_keyword (ctx : CTX, kw : string) : bool {
    match (get_token (ctx)) {
      | Tok_keyword (n) when n == kw => true
      | _ => push_back (ctx); false
    }
  }
  
  parse_type_decl (ctx : CTX) : Type_decl {
    def parse_header () {
      match (get_token (ctx)) {
        | Tok_identifier (name) =>
          def typarms =
            match (get_token (ctx)) {
              | Tok_operator ("(", _) =>
                def tyvars = parse_tyvars (ctx);
                expect_operator (ctx, ")");
                parse_where_constraints (ctx, tyvars);
              | _ => 
                push_back (ctx); 
                Typarms ([], [])
            };
            
          def t_extends =
            match (get_token (ctx)) {
              | Tok_keyword ("extends") =>
                Some (parse_type (ctx))
              | _ => 
                push_back (ctx); 
                None ()
            };
            
          def t_implements =
            match (get_token (ctx)) {
              | Tok_keyword ("implements") =>
                operator_separated_list (ctx, ",", parse_type)
              | _ => 
                push_back (ctx); 
                []
            };
          
          (name, typarms, t_extends, t_implements)

        | _ => fatal_error (ctx, "expecting type name")
      }
    };
    
    def parse_variant_member (ctx) {
      def tok = get_token (ctx);
      locate (ctx, fun () {
        match (tok) {
          | Tok_operator ("|", _) =>
            def id = get_id (ctx);
            def members =
              match (peek_token (ctx)) {
                | Tok_operator ("{", _) =>
                  def parse_field (ctx) {
                    ignore (peek_token (ctx));
                    locate (ctx, fun () {
                      def attrs = get_attrs (ctx);
                      def is_ref = flag_keyword (ctx, "mutable");
                      def id = get_id (ctx);
                      expect_operator (ctx, ":");
                      def ty = parse_type (ctx);
                      expect_operator (ctx, ";");
                      M_field (name = id,
                               modifiers = attrs,
                               ty = ty, 
                               is_ref = is_ref, 
                               kind = Val_normal ())
                    })
                  };
                  collect_braced_list (ctx, parse_field)
                | _ => []
              };
            TD_variant_option (name = id, 
                               modifiers = [], 
                               t_extends = None (),
                               t_implements = [],
                               typarms = Typarms ([], []),
                               decls = members)
          | _ => fatal_error (ctx, "expecting variant option")
        }
      })
    };
    
    def parse_iface_member (ctx) {
      ignore (peek_token (ctx));
      locate (ctx, fun () {
        def is_new = flag_keyword (ctx, "new");
        def h = parse_fun_header (ctx, allow_ctor = false, allow_inference = false, got_name = false);
        M_function (h, FK_iface_method (is_new), FB_abstract ())
      })
    };
    
    def parse_members () {
      collect_braced_list (ctx, parse_type_member)
    };
  
    def attrs = get_attrs (ctx);
    def tok = get_token (ctx);
    locate (ctx, fun () {
      match (tok) {
        | Tok_keyword ("type")
        | Tok_keyword ("class")
        | Tok_keyword ("struct")
        | Tok_keyword ("module")
        | Tok_keyword ("interface")
        | Tok_keyword ("variant") =>
          def (name, typarms, t_extends, t_implements) = parse_header ();
          def (attrs, td) =
            match (tok) {
              | Tok_keyword ("class") =>
                (attrs, TD_class (parse_members ()))
              | Tok_keyword ("struct") =>
                (Mod_struct () :: attrs, TD_class (parse_members ()))
              | Tok_keyword ("module") =>
                (Mod_module () :: attrs, TD_class (parse_members ()))
              | Tok_keyword ("type") =>
                expect_operator (ctx, "=");
                match (get_token (ctx)) {
                  | Tok_keyword ("extern") =>
                    match (get_token (ctx)) {
                      | Tok_string_literal (s) => 
                        expect_operator (ctx, ";");
                        (attrs, TD_external (s))
                      | _ => 
                        fatal_error (ctx, "expecting quoted type name after `extern'")
                    }
                    
                  | _ =>
                    push_back (ctx);
                    def t = parse_type (ctx);
                    expect_operator (ctx, ";");
                    (attrs, TD_alias (t))
                }
                
              | Tok_keyword ("interface") =>
                def decls = collect_braced_list (ctx, parse_iface_member);
                (attrs, TD_interface (decls))
                
              | Tok_keyword ("variant") =>
                expect_operator (ctx, "{");
                def decls = collect_list (ctx, parse_variant_member);
                expect_operator (ctx, "}");
                (attrs, TD_variant (decls))
             
              | _ => Util.ice ()
            };
            
          td.modifiers <- attrs;
          
          td.name <- name;
          td.typarms <- typarms;
          td.t_extends <- t_extends;
          td.t_implements <- t_implements;

          td
          
        | Tok_keyword ("macro") => Util.ice () // FIXME
        
        | _ => fatal_error (ctx, "expecting type declaration")
      }
    })
  }

  parse_topdecl (ctx : CTX) : Top_decl {
    def tok = get_token (ctx);
    locate (ctx, fun () {
      match (tok) {
        | Tok_keyword ("open") =>
          def id = get_qid (ctx);
          expect_operator (ctx, ";");
          TD_open (id)
          
        | Tok_keyword ("namespace") =>
          def id = get_qid (ctx);
          match (get_token (ctx)) {
            | Tok_operator ("=", _) =>
              when (id.IndexOf ('.') != -1) {
                Message.error ("namespace alias cannot contain dots")
              };
              def id' = get_qid (ctx);
              expect_operator (ctx, ";");
              TD_namespace_alias (id, id')
              
            | Tok_operator ("{", _) =>
              push_back (ctx);
              def decls = collect_braced_list (ctx, parse_topdecl);
              TD_namespace (id, decls)

            | _ =>
              fatal_error (ctx, "expecting '}' or '='")
          }

        | _ =>
          push_back (ctx);
          TD_type (parse_type_decl (ctx))
      }
    })
  }

  'a collect_braced_list (ctx : CTX, f : CTX -> 'a) : list ('a) {
    expect_operator (ctx, "{");
    def r = collect_list (ctx, f);
    expect_operator (ctx, "}");
    r
  }
  
  'a collect_list (ctx : CTX, f : CTX -> 'a) : list ('a) {
    def loop (acc) {
      match (peek_token (ctx)) {
        | Tok_operator ("}", _) | Tok_EOF => List.rev (acc)
        | _ =>
          loop (f (ctx) :: acc)
      }
    };
    loop ([])
  }

  public parse (lexer : ILexer) : list (Top_decl) {
    def ctx = CTX (lexer = lexer,
                   last_token = null, 
                   push_back = None ());
    def r = collect_list (ctx, parse_topdecl);
    match (peek_token (ctx)) {
      | Tok_EOF => r
      | _ => fatal_error (ctx, "expecting EOF")
    }
  }

} // end module
} // end namespace
