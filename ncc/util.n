/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Util;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {

  public class ICE extends System.Exception
    {
      public msg : string;
      public this (m : string) { this.msg <- m }
    }

  public class Recovery extends System.Exception
    {
      public this () {}
    }

  public module Util 
    {
      mutable current_id : int;
      public next_id () : int {
        current_id <- current_id + 1;
        current_id
      }

      public 'a ice (msg : string) : 'a { raise ICE (msg) }
      public 'a ice () : 'a { raise ICE ("(see backtrace)") }

      public 'a locate (l : Location, f : void -> 'a) : 'a
        {
          if (l == null) f ()
          else {
            Location_stack.push (l);
            try f () finally Location_stack.pop ()
          }
        }

      // of course this is broken and can be better
      public concat_strings (sep : string, l : list (string)) : string {
        match (l) {
          | [x] => x
          | x :: xs => x + sep + concat_strings (sep, xs)
          | [] => ""
        }
      }
      
      public is_new (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_new => true | _ => false };
        List.Exists (is_mod, mem.GetModifiers ());
      }
        
      public is_abstract (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_abstract => true | _ => false };
        List.Exists (is_mod, mem.GetModifiers ());
      }
        
      public is_override (mem : IMember) : bool
      {
        def is_mod (m : Modifier) : bool 
          { | Mod_override => true | _ => false };
        List.Exists (is_mod, mem.GetModifiers ());
      }
        
      public get_ns (s : string) : string {
        def idx = s.LastIndexOf('.');
        if (idx == -1) ""
        else
          s.Substring(0, idx);
      }
      
      public is_capitalized (s : string) : bool {
        def idx = s.LastIndexOf('.');
        s[idx + 1] >= 'A' && s[idx + 1] <= 'Z'
      }

      public tmpname (kind : string) : string {
        "_N_" + kind + string_of_int (Util.next_id ())
      }
    }
  
  public module Message 
    {
      mutable error_cnt : int;
      mutable warning_cnt : int;
      mutable emitted_hints : Hashtable (string, int);

      public location_to_string (l : Location) : string
      {
        if (l == null)
          "(no location)"
        else
          l.file + ":" + string_of_int(l.line) + ":" + 
          string_of_int(l.column)
      }

      public report (l : Location, m : string) : void
      {
        def l' =
          if (l == null) Location_stack.top()
          else l;
        Passes.KillProgressBar ();
        print_endline (Message.location_to_string(l') + ": " + m);
      }

      public error (l : Location, m : string) : void {
        Message.error_cnt <- Message.error_cnt + 1;
        Message.report (l, "error: " + m);
      }
        
      public error (m : string) : void { Message.error (null, m) }

      public warning (l : Location, m : string) : void {
        Message.warning_cnt <- Message.warning_cnt + 1;
        Message.report (l, "warning: " + m);
      }
        
      public warning (m : string) : void { Message.warning (null, m) }

      public hint (l : Location, m : string) : void {
        Message.report (l, "hint: " + m);
      }
      
      public hint (m : string) : void { Message.hint (null, m) }
      
      public hint_once (l : Location, m : string) : void {
        when (emitted_hints == null)
          emitted_hints <- Hashtable (20);
        unless (emitted_hints.Contains (m)) {
          Message.report (l, "hint: " + m);
          emitted_hints.Add (m, 0)
        }
      }
        
      public hint_once (m : string) : void { Message.hint_once (null, m) }

      public debug (l : Location, m : string) : void {
        Message.report (l, "debug: " + m);
      }
        
      public debug (m : string) : void { Message.debug (null, m) }

      public 'a fatal_error (l : Location, m : string) : 'a {
        Message.error (l, m);
        raise Recovery ()
      }
      
      public 'a fatal_error (m : string) : 'a { Message.fatal_error (null, m) }

      public 'a exit (ret : int) : 'a {      
        System.Environment.Exit (ret);
        raise Recovery () // FIXME: this code is unreachable but it seems to be the only trick to do the magic here
      }

      public maybe_bailout (fscked_up : bool) : void {
        if (Flags.ignore_confusion && fscked_up)
          ()
        else if (seen_error ()) {
          if (fscked_up)
            print_endline ("confused by earlier errors bailing out")
          else ();
          System.Environment.Exit (1)
        } else ()
      }
        
      public maybe_bailout () : void { Message.maybe_bailout (false) }

      public seen_error () : bool
      {
        error_cnt != 0
      }
    }

    public module Location_stack
      {
        mutable s : list (Location);
        
        public push (l : Location) : void {
          if (l == null) ice() else
          Location_stack.s <- l :: Location_stack.s
        }

        public pop () : void {
          match (Location_stack.s) {
            | [] => Util.ice()
            | _ :: t => Location_stack.s <- t
          }
        }

        public top () : Location {
          match (Location_stack.s) {
            | [] => Location("", 0, 0)
            | h :: _ => h
          }
        }

        this () { Location_stack.s <- []; }
      }
  
}
