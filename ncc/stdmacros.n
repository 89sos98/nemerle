/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

using Nemerle.Macros;
using Nemerle.Collections;
using System;
using System.Text.RegularExpressions;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

  /** MACROS EXTENDING SYNTAX OF LANGUAGE */

  /** specialized macro for [if] condition with good warning messages,
      it performs typing of given expressions to check their type
      correctness
   */
  macro @if (cond, e1, e2)
  syntax ("if", "(", cond, ")", e1, "else", e2) 
  {
    def tcond = ty_expr (_N_ctx, cond);
    def bool_ty = <[ ttype: bool ]>;
    Tyexpr.expect_type ("if condition", tcond, bool_ty);
    
    <[ 
      match ($(tcond : typed)) { 
        | true => $e1 
        | _ => $e2
      } 
    ]>
  }

  /** this macro provides convenient way to write simple while loop,
      which perform execution of [body] parameter as long as
      [condition] is true
    */
  macro @while (cond, body)
  syntax ("while", "(", cond, ")", body) 
  {
    <[ 
      def loop () : void {
        when ($cond) { $body; loop() }
      }; 
      loop (); 
    ]>
  }

  /** shortcut for [if (cond) body else ()] */
  macro @when (cond, body)
  syntax ("when", "(", cond, ")", body) 
  {
    <[ match ($cond) { | true => $body | _ => () } ]>
  }

  macro @for (init, cond, change, body)
  syntax ("for", "(", init, ";", cond, ";", change, ")", body) 
  {
    <[ 
      $init;
      def loop () : void {
        when ($cond) { $body; $change; loop() }
      }; 
      loop (); 
    ]>
  }

  /** shortcut for [if (cond) () else body] */
  macro @unless (cond, body)
  syntax ("unless", "(", cond, ")", body) 
  {
    <[ match ($cond) { | false => $body | _ => () } ]>
  }

  /** macro providing C# 'using' functionality
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vclrfusingstatement.asp
   */
  macro @using (body, params args : array <parm>)
  syntax ("using", "(", args, ")", body) 
  {
    def len = args.Length;
    def store_exprs (i, preexprs, postexprs) {
      if (i < len) 
        match (args[i]) {
          | <[ parameter: $ex ]> =>
            store_exprs (i + 1, preexprs, 
                         <[ when ($ex != null) $ex.Dispose () ]> :: postexprs)

          | <[ parameter: $(str : var) = $ex ]> =>
            store_exprs (i + 1, <[ def $(str : var) = $ex ]> :: preexprs, 
                         <[ $(str : var).Dispose () ]> :: postexprs)
                         
          | _ => Message.fatal_error ("Invalid parameters in 'using' macro")
        }
      else
        (List.Rev (preexprs), postexprs)
    };

    def (preexps, postexps) = store_exprs (0, [], []);
    def entire = List.Append (preexps, 
                              [ <[ try $body  finally {.. $postexps } ]> ]);
    <[ {.. $entire } ]>
  }

  macro @lock (x, body)
  syntax ("lock", "(", x, ")", body)
  {
    <[ 
      Threading.Monitor.Enter ($x);
      try 
        $body
      finally
        Threading.Monitor.Exit ($x);
    ]>
  }

  macro dowhile (cond, body) 
  syntax ("do", body, "while", "(", cond, ")") 
  {
    <[ 
      def loop () {
        $body; 
        when ($cond) loop ();
      };
      loop ()
    ]>
  }

  macro @repeat (cond, body) 
  syntax ("repeat", body, "until", "(", cond, ")") 
  {
    <[ do $body while (! $cond) ]>
  }

  macro @foreach (iter : funparm, collection, body)
  syntax ("foreach", "(", iter, "in", collection, ")", body)
  {
    match (iter) {
      | <[ funparm: $(iname : var) : $ty ]> =>
        <[ 
          def enumerator = $collection.GetEnumerator ();
          def loop () {
            when (enumerator.MoveNext ()) {
              def $(iname : var) = (enumerator.Current :> $ty);
              $body;
              loop ();
            }
          };
          loop ()
        ]>
      | _ =>
        Message.fatal_error ("iterator in foreach must be identifier" +
                             "with optional type")
    }
  }

  macro ignore (e) 
  {
    <[ def _ = $e; () ]>
  }

  macro assert (cond, message = <[ "" ]>) 
  {
    match (cond) {
      | <[ false ]> =>
        // skip cond in this case so it gets 'a type
        <[ throw AssertionException ($(cond.loc.file : string), 
                                     $(cond.loc.line : int), $message) ]>
      | _ =>
        <[ unless ($cond) 
             throw AssertionException ($(cond.loc.file : string), 
                                       $(cond.loc.line : int), $message) ]>
    }
  }

  macro abort (message = <[ "" ]>) 
  {
    <[ throw AssertionException ($(message.loc.file : string), 
                                 $(message.loc.line : int), $message) ]>
  }
}

namespace Nemerle.Macros {
  /** creates new symbol with given id and current global context */
  macro Symbol (id)
  {
    <[ Parsetree.Name.NameInCurrentColor ($id, 
         $("_N_MacroContexts" : dyn).Get ($(_N_ctx.env.GetMacroContext () : int))) ]>
  }

  macro pretty_print_expr (exp, expand : bool)
  {
    def ctx = if (expand) Some (_N_ctx) else None ();
    Macros.PrintExpr (ctx, exp);
    <[ () ]>
  }
}

namespace Nemerle {
module IO {

  variant FormatToken {
    | Text { body : string; }
    | TextNewline { body : string; }
    | FT_Number
    | NumberFloat
    | Str
    | Chr
  }

  parse_format (form : string) : list <FormatToken>
  {
    mutable i <- 0;
    mutable buf <- Text.StringBuilder ();
    mutable result <- [];
    def n = form.Length;

    while (i < n) { 
      match (form[i]) {
        | '%' =>
          // % occured - first, dump text from buffer
          when ( buf.Length > 0 ) {
            result <- Text (buf.ToString ()) :: result;
            buf <- buf.Remove (0, buf.Length);
          };
          // now analyze next character
          i <- i + 1;
          if ( i < n ) {
            match (form[i]) {
              | 'd' => result <- FT_Number () :: result
              | 'i' => result <- FT_Number () :: result
              | 'f' => result <- NumberFloat () :: result
              | 's' => result <- Str () :: result
              | 'c' => result <- Chr () :: result
              | _ => 
                Message.error ("Unsupported formatting sequence after % character")
            }
          }
          else
            Message.error ("Unexpected end of format after % character")
        | '\n' =>
          result <- TextNewline (buf.ToString ()) :: result;
          buf <- buf.Remove (0, buf.Length)
        | c =>
          buf <- buf.Append (c)
      };
      i <- i + 1;
    };

    when (buf.Length > 0) { result <- Text (buf.ToString ()) :: result; };

    // the result is reversed, but function using it will reverse it again
    result
  }
  
  macro printf (format : string, params parms : array <expr>) 
  {
    def make_expressions (toks, i, acc) {
      match ((toks, i)) {
        | ([], 0) => acc
        | (Text (t) :: xs, _) => 
          make_expressions (xs, i, 
            <[ Console.Write ($(t : string)) ]> :: acc)
        | (TextNewline (t) :: xs, _) => 
          make_expressions (xs, i, 
            <[ Console.WriteLine ($(t : string)) ]> :: acc)

        | (_, 0) =>
          Message.error ("not enough arguments for printf macro");
          acc
            
        | (FT_Number :: xs, _) =>
          make_expressions (xs, i - 1, <[ Console.Write (($(parms[i - 1]) : int))
                                       ]> :: acc)

        | (NumberFloat :: xs, _) =>
          make_expressions (xs, i - 1,
               <[ Console.Write (Convert.ToString (($(parms[i - 1]) : double),
                Globalization.NumberFormatInfo.InvariantInfo)) ]>
                :: acc)

        | (Str :: xs, _) =>
          make_expressions (xs, i - 1,
                            <[ Console.Write (($(parms[i - 1]) : string)) ]> :: acc)

        | (Chr :: xs, _) =>
          make_expressions (xs, i - 1,
                            <[ Console.Write (($(parms[i - 1]) : char)) ]> :: acc)

        | ([], _) =>
          Message.error ("too many arguments for printf macro");
          acc
      }
    };

    def seq = make_expressions (parse_format (format), parms.Length, []);
    <[ {.. $seq } ]>
  }

  macro scanf (format : string, params parms : array <expr>) 
  {
    def make_expressions (toks, i, acc) {
      match ((toks, i)) {
        | ([], 0) => acc
        | (Text (t) :: xs, _) => 
          make_expressions (xs, i, 
            <[ Nemerle.IO.CheckInput ($(t : string)) ]> :: acc)

        | (TextNewline (t) :: xs, _) => 
          make_expressions (xs, i, 
            <[ Nemerle.IO.CheckInput ($(t : string)) ]> :: acc)

        | (_, 0) =>
          Message.error ("not enough arguments for scanf macro");
          acc
            
        | (FT_Number :: xs, _) =>
          make_expressions (xs, i - 1, 
            <[ $(parms[i - 1]) <- Nemerle.IO.ReadInt () ]> :: acc)

        | (NumberFloat :: _, _) =>
          Message.fatal_error ("scaning floats not supported")

        | (Str :: xs, _) =>
          make_expressions (xs, i - 1, 
            <[ $(parms[i - 1]) <- Nemerle.IO.ReadString () ]> :: acc)

        | (Chr :: xs, _) =>
          make_expressions (xs, i - 1, 
            <[ $(parms[i - 1]) <- Char.ToChar (Console.Read ()) ]> :: acc)

        | ([], _) =>
          Message.error ("too many arguments for scanf macro");
          acc
      }
    };

    def seq = make_expressions (parse_format (format), parms.Length, []);
    <[ 
      Nemerle.IO.EatWhiteSpace ();
      {.. $seq } 
    ]>
  }

  macro sprintf (format : string, params parms : array <expr>)
  {
    def nsymb = Macros.NewSymbol ();
    def make_exprs (toks, i, acc) {
      match ((toks, i)) {
        | ([], 0) => acc
        | (Text (t) :: xs, _) => 
          make_exprs (xs, i, 
                      <[ ignore ($(nsymb : var).Append ($(t : string))) ]> :: acc)

        | (TextNewline (t) :: xs, _) => 
          make_exprs (xs, i, 
                      <[ ignore ($(nsymb : var).Append ($(t : string))) ]> ::
                      <[ ignore ($(nsymb : var).Append ("\n")) ]> :: acc)

        | (_, 0) =>
          Message.error ("not enough arguments for sprintf macro");
          acc
                      
        | (FT_Number :: xs, _) =>
          make_exprs (xs, i - 1, <[ ignore ($(nsymb : var).Append
                                            (($(parms[i - 1]) : int))) ]> :: acc)

        | (NumberFloat :: xs, _) =>
          make_exprs (xs, i - 1, <[ ignore ($(nsymb : var).Append
                                      (Convert.ToString (($(parms[i - 1]) : double),
                                 Globalization.NumberFormatInfo.InvariantInfo))) ]> :: acc)

        | (Str :: xs, _) =>
          make_exprs (xs, i - 1, <[ ignore ($(nsymb : var).Append
                                            (($(parms[i - 1]) : string))) ]> :: acc)

        | (Chr :: xs, _) =>
          make_exprs (xs, i - 1, <[ ignore ($(nsymb : var).Append
                                            (($(parms[i - 1]) : char))) ]> :: acc)

        | ([], _) =>
          Message.error ("too many arguments for sprintf macro");
          acc
        }
      };

    def seq = make_exprs (parse_format (format), parms.Length, 
                          [ <[ $(nsymb : var).ToString () ]> ]);
    <[ 
      def $(nsymb : var) = Text.StringBuilder ();
      {.. $seq } 
    ]>
  }

  macro print (str : string)
  {
    // take names after $
    def namesreg = Regex (@"(([^\$]*)\$(\w+))|(.+)", RegexOptions.Singleline);
    mutable m <- namesreg.Match (str);
    mutable res <- [];

    while (m.Success) {
      if (m.Groups[1].Success) {
        def variable_name = Macros.UseSiteSymbol (m.Groups[3].ToString ());
        res <- <[ Console.Write ($(variable_name : var).ToString ()) ]> ::
               <[ Console.Write ($(m.Groups[2].ToString () : string)) ]> ::
               res;
      }
      else
        res <- <[ Console.Write ($(m.Groups[4].ToString () : string)) ]> :: res;

      m <- m.NextMatch ();
    };

    <[ {.. $(List.Rev (res)) } ]>
  }

/*
    macro sscanf (..)
    {
      match (get_params (args)) {
        | valstr :: <[ $(format : string) ]> :: parms =>
          def make_expressions (toks, parms, acc) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ Nemerle.Input.CheckInput ($(t : string)) ]> :: acc)

              | (TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ Nemerle.Input.CheckInput ($(t : string)) ]> :: acc)

              | (FT_Number :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadInt () ]> :: acc)

              | (NumberFloat :: _, _) =>
                Util.ice ("scanning floats not supported")

              | (Str :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadString () ]> :: acc)

              | (Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Char.ToChar (Console.Read ()) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for sscanf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for sscanf macro");
                acc
            }
          };
          
          def seq = <[ def _N_sscanf_str = $valstr ]> ::
                    <[ mutable _N_sscanf_pos <- 0 ]> ::
                    <[ def _N_sscanf_len = _N_sscanf_str.Length ]> ::
                    <[ Nemerle.Input.EatWhiteSpace () ]> ::
            make_expressions (parse_format (format), List.Rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("sscanf macro expects string and formating " +
                               "string as first arguments")
      }
    }
  }
*/
}
}

namespace Nemerle.Text {

  /** translation of match on regular expressions to operations on .Net
      regular expressions and its Groups, which allows short and simple
      extraction of regular subpatterns.
      Syntax of this macro is like in following example:
      <code>
        regexp match (str) {
          | "a+.*" => printf ("a\n");
          | @"(?<num : int>\d+)-\w+" => printf ("%d\n", num + 3);
          | "(?<name>(Ala|Kasia))? ma kota" =>
            match (name) {
              | Some (n) => printf ("%s\n", n)
              | None => printf ("noname?\n")
            }
          | _ => printf ("default\n");
        }
      </code>
  */
  macro @regexp (mat)
  syntax ("regexp", mat) 
  {
    /// syntax is [regexp match { .. }], so [mat] must be [match]
    match (mat) {
      | <[ match ($val) { ..$cases } ]> =>
        // final pattern of regular expression for builded match
        mutable pat <- Text.StringBuilder ();
        // names of created groups of final regular expression, names
        // of existing named groups in patterns and associated expressions
        // to execute 
        mutable alternatives <- [];
        // variable used for valid creation of alternatives [(..)|(..)|(..)] 
        mutable first <- true;
        // default matching case if occurred
        mutable default <- None ();

        // walks through cases of given match and builds final regular
        // expression in [pat] and stores group names and related expressions
        // to [alternatives]
        def create_regpattern (cass : list <Parsetree.Match_case>) {
          mutable patnames <- [];

          // walks thorough guards of single case, collecting names
          // for each created group of regular expression and storing
          // names of existing group names inside in [patnames]
          def walk_guards (gs, acc) {
            match (gs) {
              | <[ caseguard: $(str : string) ]> :: xs =>
                // take names of named groups
                def namesreg = Regex (@"\(\?\<(\w+)\s*(:\s*((\w|\.)+))?");
                mutable m <- namesreg.Match (str); 
                // find all occurrenceces of existing gropus inside
                while (m.Success) {
                  mutable end <- false;
                  mutable paren <- 0;
                  mutable optional <- false;
                  // check if this group is optional (it's context information)
                  // so we must count [(] and [)]
                  for (mutable i <- m.Index; !end && i < str.Length; ++i) {
                    match (str[i]) {
                      | '(' => paren <- paren + 1
                      | ')' => 
                        paren <- paren - 1;
                        when (paren == 0 && i + 1 < str.Length && str[i + 1] == '?') {
                          end <- true;
                          optional <- true;
                        }
                      | _ => ()
                    }
                  };

                  // store this existing named group with its name, information 
                  // if it's optional and name of its enforced type  
                  // - [(?<name : type>..)?]
                  match ((m.Groups[1].Success, m.Groups[3].Success)) {
                    | (true, false) =>
                      patnames <- (m.Groups[1].ToString (), optional, 
                                   None ()) :: patnames
                    | (true, true) =>
                      patnames <- (m.Groups[1].ToString (), optional,
                                   Some (m.Groups[3].ToString ())) :: patnames;
                    | _ => ()
                  };
                  m <- m.NextMatch ();
                };
                def nsymb = Macros.NewSymbol ();
                // add | if it is not first alternative in our pattern
                unless (first) pat <- pat.Append ("|");
                first <- false;
                def newstr = namesreg.Replace (str, "(?<$1");
                // add current alternative to our pattern
                pat <- pat.Append("(?<" + nsymb.id + ">^" + newstr + "$)");
                walk_guards (xs, nsymb.id :: acc)

              | [] => acc

              | <[ caseguard: $_p when $(_) ]> :: _ =>
                Message.fatal_error ("guarded pattern not allowed in regexp macro")
              | _ :: _ =>
                Message.fatal_error ("only string patterns allowed in regexp macro")
            }
          };
          match (cass) {
            // default case it special and we must store it
            | [ <[ case: _ => $expr ]> ] => default <- Some (expr)

            | <[ case: | ..$guards => $expr ]> :: xs =>
              alternatives <- (walk_guards (guards, []), patnames, expr) 
                              :: alternatives;
              create_regpattern (xs)

            | [] => ()
          }
        };
        create_regpattern (cases);

        // build decision tree, which checks created groups one by one and if
        // some has matched executes corresponding expression
        def build_checking (cass) {
          // build || condition for patterns from one case in initial matching
          def build_alts (alts) {
            match (alts) {
              | [str] => 
                <[ matchobj.Groups[$(str : string)].Success ]>
              | x::xs =>
                <[ 
                  matchobj.Groups[$(x : string)].Success || 
                  $(build_alts (xs)) 
                ]>
                  
              | [] => Message.fatal_error ("empty list of guards?")
            }
          };
          // build expressions containing values of existing named groups
          // converting their type (parsing them from string) if needed
          def build_bindings (patnames, acc) {
            match (patnames) {
              | (name, opt, choosen_type) :: xs =>
                def strin = 
                  <[ matchobj.Groups[$(name : string)].ToString () ]>;
                def value =
                  match (choosen_type) {
                    | None => strin
                    | Some (t) =>
                      <[ $(Symbol (t) : var).Parse ($strin) ]>
                  };
                def name_symbol = Macros.UseSiteSymbol (name);
                def binding =
                  if (opt) 
                    <[ 
                      def $(name_symbol : var) = 
                        match (matchobj.Groups[$(name : string)].Success) {
                          | true => Some ($value) | _ => None ()
                        }
                    ]>
                  else
                    <[ def $(name_symbol : var) = $value ]>;
                build_bindings (xs, binding :: acc);
                
              | [] => acc
            }
          };
          match (cass) {
            // creates entire expression checking if one case have succeeded
            | (grds, patnames, expr) :: xs =>
              <[ 
                match ($(build_alts (grds))) { 
                  | true => {
                    .. $(List.Append (build_bindings (patnames, []), [expr])) 
                  }
                  | _ => $(build_checking (xs)) 
                }
              ]>
            
            | [] => <[ throw MatchFailureException () ]>
          }
        };
        //
        def defexpr = 
          match (default) {
            | None =>
              Message.warning ("this pattern might be not exhaustive");
              <[ () ]>
            | Some (defexpr) => defexpr
          };              

        // generation of final code for building regular expression and
        // extracting its groups
        <[ 
          def regobj = Regex ($(pat.ToString () : string), 
                              RegexOptions.ExplicitCapture);

          def matchobj = regobj.Match ($val);

          match (matchobj.Success) {
            | true => $(build_checking (alternatives))
            | _ => $defexpr 
          }
        ]>
      | _ =>
        Message.fatal_error ("regexp macro expects match construct")
    }
  }
}

namespace Nemerle.Extensions {
  /** MACROS, WHICH WE CAN DO BETTER THAN HASKELL */

  macro SelectFromTuple (k : int, n : int, tupl)
  {
    def symb = Macros.NewSymbol ();
    mutable tup <- [];
    for (mutable i <- n; i > 0; --i)
      if (i == k)
        tup <- <[ pattern: $(symb : var) ]> :: tup
      else
        tup <- <[ pattern: _ ]> :: tup;

    <[ def (.. $tup) = $tupl; $(symb : var) ]>
  }

  macro TupleMap (f, tup)
  {
    match (tup) {
      | <[ (.. $elms) ]> =>
        def mapped = List.Map (elms, fun (e) { <[ $f ($e) ]> });
        <[ (.. $mapped) ]>
      | _ => 
        Message.fatal_error ("'TupleMap' macro expects function and tuple")
      }
  }

  macro PrintTuple (tup, size : int)
  {
    def symbols = array (size);
    mutable pvars <- [];
    for (mutable i <- size - 1; i >= 0; --i) {
      symbols[i] <- Macros.NewSymbol ();
      pvars <- <[ pattern: $(symbols[i] : var) ]> :: pvars;
    };
    mutable exps <- [];
    for (mutable i <- size - 1; i >= 0; --i)
      exps <- <[ Console.WriteLine ($(symbols[i] : var)) ]> :: exps;

    exps <- <[ def (.. $pvars) = $tup ]> :: exps;
    <[ {.. $exps } ]>
  }

  macro PrintTupleTyped (tup)
  {
    match (type_of (ty_expr (_N_ctx, tup))) {
      | T_prod (args) =>
        def size = List.Length (args);
        def symbols = array (size);
        mutable pvars <- [];
        for (mutable i <- size - 1; i >= 0; --i) {
          symbols[i] <- Macros.NewSymbol ();
          pvars <- <[ pattern: $(symbols[i] : var) ]> :: pvars;
        };
        mutable exps <- [];
        for (mutable i <- size - 1; i >= 0; --i)
          exps <- <[ Console.WriteLine ($(symbols[i] : var)) ]> :: exps;
          
        exps <- <[ def (.. $pvars) = $tup ]> :: exps;
        <[ {.. $exps } ]>
      | _ => 
        Message.fatal_error ("expected tuple")
    }
  }
} // end ns
