open Nemerle.Compiler;
open Nemerle.Collections;


namespace Nemerle.Compiler {

(*
pass 1:
  Walk through Top_decls, set env field for all global symbols, register
  all global symbols. Return list of Type_decls.
*)

class Pass1 
  {
    fun run (decls : list (Top_decl)) : list (Type_decl) =
      letfun loop (state : Env * list (Type_decl), decl : Top_decl) : Env * list (Type_decl) =
        let (?env, ?acc) = state in
        match decl with [
          | TD_namespace (?n, ?d) =>
//            let _ = print_endline("ns: " + n) in
            let env' = env#copy() in {
              env'#current_namespace <- env#current_namespace + n + ".";
              let (_, ?acc) = List.fold_left (loop, (env', acc), d) in
              (env, acc)
            }
          | TD_open (?n) =>
            let env' = env#copy() in {
              env'#add_open(n);
              (env', acc)
            }
          | TD_namespace_alias (?s, ?l) =>
            let env' = env#copy() in {
              env'#add_namespace_alias(s, l);
              (env', acc)
            }
          | TD_type (?d) =>
            {
//        print_endline("d: " + d#name);
              d#env <- env;
              let mem = M_type(d) in {
                mem#name <- d#name;
                mem#loc <- d#loc;
                mem#modifiers <- d#modifiers;
                mem#env <- d#env;
                mem#id <- d#id;
                Env.add_global(env#current_namespace, mem);
              };
              (env, Cons(d, acc))
            }
        ]
      in 
      let (_, ?r) = List.fold_left (loop, (Env(), Nil()), decls) 
      in List.rev(r);
  }

  class Passes
    {
      fun run(decls : list (list (Top_decl))) : void =
        let _ = Env.globals <- Map.string_map() in
        let dd = List.map(Pass1.run, List.rev(decls)) in
        let decls = List.concat(dd) in ();
    }


} // N.C
