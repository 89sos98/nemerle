using Nemerle.Collections;
using Nemerle.Peg;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;

using System;
using System.Collections.Generic;
using SCG = System.Collections.Generic;

namespace Calculator
{
  [PegGrammar(
    rule1,
    grammar
    {
      rule1 : SCG.List[int] = rule11+ / rule12;
      rule11 : int = any;
      rule12 : SCG.List[int] = any;
      any = ['\u0000'..'\uFFFF'];
    }
  )]
  class Parser
  {
    rule1(@list : SCG.List[int]) : SCG.List[int]
    {
      @list;
    }
    
    rule11(_ : NToken) : int
    {
      1;
    }
    
    rule12(_ : NToken) : SCG.List[int]
    {
      SCG.List();
    }
  }
  
  type LoopTokens = NToken * int;
  
  [Record] public class ParserFatalError : Exception
  {
    public Pos     : int;
  }
  
  public class FakeGrammar { }
  
  /// <summary>
  /// Description of CalcParser.
  /// </summary>  
  [PegGrammar(start,
  grammar
  {
    //using Calculator.FakeGrammar;
    //using A = Calculator.FakeGrammar;
    //[Extensible(aaa)]
    //xxx;
    any                   = ['\u0000'..'\uFFFF'];
    digit                 = ['0'..'9']+;
    spaces : void         = ' '*;

    [Extends(simplExpr)]
    num                   : int = digit spaces;

    [Extends(simplExpr)]
    unaryMinus            : int = '-' spaces simplExpr;

    [Extends(simplExpr)]
    parenthesesExpr       : int = '(' spaces sumOrSub ')' spaces;

    //[Extends(simplExpr), Error]
    //parenthesesExprError  : int = '(' spaces sumOrSub (&any / !any);

    [Extensible(simplExprAmbiguityResolve)]
    simplExpr             : int;

    mulOrDiv              : int = simplExpr (('*' / '/') spaces simplExpr)*;
    sumOrSub              : int = mulOrDiv  (('+' / '-') spaces mulOrDiv )*;
    start                 : int = spaces sumOrSub !any;
  })]
  public class CalcParser
  {
//Requred for parser --------------------------------------------------------------------------------------------    
    private num(digit : NToken) : int
    {
      int.Parse(GetText(digit))
    }

    private unaryMinus(_ : NToken, se : int) : int
    {
      -se
    }

    private parenthesesExpr(_ : NToken, se : int, _ : NToken) : int
    {
      se
    }

    private mulOrDiv(se : int, lst : List[LoopTokens]) : int
    {
      DoOpHelper(se, lst)
    }

    private sumOrSub(se : int, lst : List[LoopTokens]) : int
    {
      DoOpHelper(se, lst)
    }

//End requred for parser --------------------------------------------------------------------------------------------    

    private DoOpHelper(se : int, lst : List[LoopTokens]) : int
    {
      def doOp(x : int, y : int, op : string) : int
      {
        match (op)
        {
          | "*" => x * y
          | "/" => x / y
          | "+" => x + y
          | "-" => x - y
          | _     => assert(false);
        }
      }

      mutable r = se;

      foreach ((opTok, secondTok) in lst)
        r = doOp(r, secondTok, GetText(opTok));

      r
    }
  }
}
