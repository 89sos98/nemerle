/*
 * Copyright (c) 2005-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  public partial class Typer
  {
    // FIXME: to stdlib?
    /** A simple O(n^2) algorithm for finding a set of minimal elements
        of [lst] using strict partial order [less].  */
    static internal GetMinimal[T] (lst : list [T], less : T * T -> bool) : list [T]
    {
      lst.FoldLeft([], (elem, minimal) =>
        if (minimal.Exists(min => less (min, elem)))
          minimal
        else
          elem :: minimal.Filter(min => !less (elem, min)))
    }


    IsBetterType (t1 : TyVar, t2 : TyVar) : bool
    {
      def real_check (t1, t2) 
      {
        mutable we_dont_care = null;

        SubtypingOrImplicitConv (t1, t2, out we_dont_care) 
          || (t1.IsFixed && t2.IsFixed 
              && match (t1.FixedValue) 
                 {
                   // treat all parametric types (including arrays) as covariant
                   | MType.Class (tc1, _ :: _ as a1) =>
                     match (t2.FixedValue) 
                     {
                       | MType.Class (tc2, a2) when tc1.Equals (tc2) =>
                         NList.ForAll2 (a1, a2, IsBetterType)
                       | _ => false
                     }

                   | MType.Array (a1, r1) =>
                     match (t2.FixedValue) 
                     {
                       | MType.Array (a2, r2) when r1 == r2 =>
                         IsBetterType (a1, a2)
                       | _ => false
                     }

                   | _ => false
                 })
      }


      def both_fixed = t1.IsFixed && t2.IsFixed;
      mutable tc1 = null;
      mutable tc2 = null;

      when (both_fixed)
        match (t1.FixedValue) 
        {
          | MType.Class (tc, []) => 
            tc1 = tc;
            match (t2.FixedValue) 
            {
              | MType.Class (tc, []) =>
                tc2 = tc;
              | _ => {}
            }
          | _ => {}
        }

      def res =
        if (tc2 == null) 
        {
          // cannot use cache
          real_check (t1, t2)
        }
        else
        {
          def ids = (tc1, tc2);
          def better_type_cache = Manager.Typer_BetterTypeCache;
          unless (better_type_cache.Contains (ids))
            better_type_cache [ids] = 
              real_check (t1, t2) 
              || (tc1.IsValueType && tc2.IsValueType 
                  && ((tc1.Equals (InternalType.SByte_tc) && tc2.Equals (InternalType.Byte_tc)) 
                       || (tc1.Equals (InternalType.Int16_tc) && tc2.Equals (InternalType.UInt16_tc)) 
                       || (tc1.Equals (InternalType.Int32_tc) && tc2.Equals (InternalType.UInt32_tc)) 
                       || (tc1.Equals (InternalType.Int64_tc) && tc2.Equals (InternalType.UInt64_tc))
                    )
                 );
          better_type_cache [ids]
        }
      //Message.Debug ($"better($t1,$t2)=$res");
      res
    }
    
    
    IsBetterOverload (o1 : OverloadPossibility, o2 : OverloadPossibility) : bool
    {
      def f1 = o1.FormalTypes;
      def f2 = o2.FormalTypes;
      // Message.Debug($"$o1==$(NList.FromArray(f1)) != $o2==$(NList.FromArray(f2))");

      System.Diagnostics.Debug.Assert(f1 != null && f2 != null);
      System.Diagnostics.Debug.Assert(f1.Length == f2.Length);
      Util.cassert (f1 != null && f2 != null);
      Util.cassert (f1.Length == f2.Length, 
                    $"$o1==$(NList.FromArray(f1)) != $o2==$(NList.FromArray(f2))");
                    
      def getBetterList(f1, f2)
      {
        Manager.Solver.PushState ();
        try 
        {
          def tyCmps = f1.Map2ToArray(f2, (t1, t2) => IsBetterType(t1, t2));
          tyCmps
        }
        finally { Manager.Solver.PopState() }
      }
      
      def tyCmpsForward  = getBetterList(f1, f2);
      def tyCmpsBackward = getBetterList(f2, f1);
      def tyCmpPairs = tyCmpsForward.ZipToArray(tyCmpsBackward);
      
      // exclude identical pairs (for example (true, true) or (false, false))
      // The (true, true) pair cause in case (object * object)
      // The (false, false) pair cause if type not comparable
      def differPairs = tyCmpPairs.FilterToArray(_ != _);
      
      def isBetterOverload = differPairs.Exists((p1, _) => p1) && !differPairs.Exists((_, p2) => p2);
      
      // Message.Debug($"X $o1==$(NList.FromArray(f1)) != $o2==$(NList.FromArray(f2))");
      //Message.Debug ($"cmp:$o1,$o2 $(f1.Length) ==> $res");
      isBetterOverload
    }
    
    /// Compare two overloads fore better match type of arguments.
    /// It prefer overload whith exect match type of arguments.
    /// For example, if we have ? -> ? and (? * ?) -> ? overloads and argument list
    /// [?] this function prefer first overload (? -> ?) because overload (? * ?) -> ? 
    /// demand of convertion from ? to ? * ?.
    static IsBetterOverload (o1 : OverloadPossibility, o2 : OverloadPossibility, argsTypes : list[TyVar]) : bool
    {
      def matchType(tyParam, tyArg)
      {
        def tyParam = tyParam.AnyHint;
        def tyArg   = tyArg.AnyHint;
        match (tyParam, tyArg)
        {
          | (Some(MType.Tuple(paramTypes)), Some(MType.Tuple(argTypes))) =>
            paramTypes.ForAll2(argTypes, matchType)

          //| (Some(MType.Tuple), _) => false
          //| (_, Some(MType.Tuple)) => false
            
          | (Some(MType.Fun(from = pFrom, argsCount = c1)), Some(MType.Fun(from = argFrom, argsCount = c2))) => 
            c1 == c2 && matchType(pFrom, argFrom)

          | (Some(MType.Fun), _) => false
          
          | (Some(MType.Class), Some(MType.Fun(from = argFrom, argsCount = ac))) =>
            def (_, _, args, _ret) = Typer.TryExtractFunType(tyParam);
            if (args != null)
              ac == args.Length && matchType(TyVar.FromList(args), argFrom)
            else false
            
          //| MType.TyVarRef(staticTyVar) =>
          //| MType.Array(tyVar, rank) => 
          //| MType.Ref(tyVar) => 
          //| MType.Out(tyVar) => 
          //| MType.Void =>
          //| Intersection =>
          | _ => true
        }
      }
      def makeArgsTypes(o)
      {
        if (o.ExtensionMethodObject == null) argsTypes 
        else o.ExtensionMethodObject.Type :: argsTypes
      }
      def matchs1 = o1.FormalTypes.Map2ToArray(makeArgsTypes(o1), matchType);
      def matchs2 = o2.FormalTypes.Map2ToArray(makeArgsTypes(o2), matchType);
      assert2(matchs1.Length == matchs2.Length);
      def differPairs = matchs1.ZipToArray(matchs2).Filter(_ != _);
      def isBetterOverload = differPairs.Exists((p1, _) => p1) && !differPairs.Exists((_, p2) => p2);
      isBetterOverload
    }

    static AintExtension (o : OverloadPossibility) : bool
    {
      o.ExtensionMethodObject == null
    }


    static AintVarArgs (o : OverloadPossibility) : bool
    {
      !o.VarArgs
    }


    static DidntMamboJumbo (o : OverloadPossibility) : bool
    {
      ! o.DidMamboJumbo
    }
    

    static AintGeneric (o : OverloadPossibility) : bool
    {
      ! o.IsGeneric
    }

    static RemoveExtensionMethods (parms : list [OverloadPossibility]) : list [OverloadPossibility]
    {
      if (NList.Exists (parms, AintExtension))
        NList.RevFilter (parms, AintExtension)
      else parms
    }

    public static FilterIfExists[T](this source : list[T], predicate : T -> bool) : list[T]
    {
      if (source.Exists (predicate)) source.RevFilter (predicate) else source
    }


    GetBestOverloads (parms : list [OverloadPossibility]) : list [OverloadPossibility]
    {
      match (parms) {
        | [] | [_] => parms
        | _ =>
          def res1 = RemoveExtensionMethods (parms);
          def res2 = GetMinimal (res1, IsBetterOverload);
          def res3 = res2.FilterIfExists(AintVarArgs);
          def res4 = res3.FilterIfExists(DidntMamboJumbo);
          def res5 = res4.FilterIfExists(AintGeneric);
            
          // Message.Debug ($"gbo: $parms ---> $res5");

          res5
      }
    }

    GetBestOverloads (parms : list [OverloadPossibility], argsTypes : list[TyVar]) : list [OverloadPossibility]
    {
      match (parms) 
      {
        | [] | [_] => parms
        | _ =>
          def res1 = GetBestOverloads (parms);
          def res2 = if (res1.Length <= 1) res1
                     else GetMinimal (res1, IsBetterOverload(_, _, argsTypes));
          res2
      }
    }

    #region Version using IMethod
    static MinimalTypes['a] (tyvars : list [TyVar * 'a]) : list [TyVar * 'a]
    {
      def less (a, b) {
        def (a, _) = a;
        def (b, _) = b;
        a.TryRequire (b) && !b.TryRequire (a)
      }
      GetMinimal (tyvars, less)
    }


    MinimalTypesWithImplicit['a] (tyvars : list [TyVar * 'a]) : list [TyVar * 'a]
    {
      def le (a, b) {
        if (a.IsFixed && b.IsFixed)
          match ((a.FixedValue, b.FixedValue)) {
            | (MType.Tuple (l1), MType.Tuple (l2)) =>
              l1.Length == l2.Length &&
              NList.FoldLeft2 (l1, l2, true, fun (x, y, acc) {
                acc &&
                IsBetterType (x, y)
              })

            | (x, y) => IsBetterType (x, y)
          }
        else false
      }

      def less (a, b) {
        def (a, _) = a;
        def (b, _) = b;
        le (a, b) && ! le (b, a)
      }

      GetMinimal (tyvars, less)
    }

    
    // FIXME! it won't work with named parameters
    GetBestOverloads1 (parms : list [IMethod]) : list [IMethod]
    {
      match (parms) {
        | [] | [_] => parms
        | _ =>
          def pairs =
            NList.RevMap (parms, fun (meth : IMethod) {
                match (meth.GetFreshType () [0]) {
                  | MType.Fun (from, _) => (from, meth)
                  | _ => assert (false)
                }
              });

          match (MinimalTypes (pairs)) {
            | [] => []
            | [(_, x)] => [x]
            | lst =>
              NList.RevMap (MinimalTypesWithImplicit (lst), Pair.Second)
          }
      }
    }

    GetBestOverloads1 (parms : list [MType * IMethod]) : list [MType * IMethod]
    {
      match (parms) {
        | [] | [_] => parms
        | _ =>
          def pairs =
            NList.RevMap (parms, fun (from, meth) {
                match (from.TypeOfMethodWithTyparms (meth) [0].Fix ()) {
                  | MType.Fun (src, _) => (src, (from, meth))
                  | _ => assert (false)
                }
              });

          match (MinimalTypes (pairs)) {
            | [] => []
            | [(_, x)] => [x]
            | lst =>
              NList.RevMap (MinimalTypesWithImplicit (lst), Pair.Second)
          }
      }
    }
    #endregion
  }
}
