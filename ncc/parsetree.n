/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler.Parsetree {

public variant SyntaxElement {
  | SyntaxExpr { body : Expr; }
  | SyntaxPattern { body : Pattern; }
  | SyntaxType { body : Type; }
  | SyntaxParm { body : Parm; }
  | SyntaxCase { body : Match_case; }
  | SyntaxCaseGuard { body : Pattern; guard : option <Expr>; }
  | SyntaxFunDecl { body : Function_decl; }
  | SyntaxFunParm { body : Fun_parm; }
  | SyntaxField { body : Class_member; }
  | SyntaxMethod { body : Class_member; }    
  | SyntaxProperty { body : Class_member; }    
  | SyntaxEvent { body : Class_member; }    
  | SyntaxTType { body : Type; }

  | SyntaxTTycon { body : Tyinfo; }
  | SyntaxTField { body : NemerleField; }
  | SyntaxTMethod { body : NemerleMethod; }
  | SyntaxTProperty { body : NemerleProperty; }
  | SyntaxTEvent { body : NemerleEvent; }
  | SyntaxTFunParm { body : Typedtree.Fun_parm; }
}

public class Decl_base : Located
{
  public mutable name : Splicable_string;
  public mutable modifiers : Modifiers;

  public this (name : Splicable_string, modifiers : Modifiers) {  
    this.name <- name;
    this.modifiers <- modifiers;
  }

  public this (loc : Location, name : Splicable_string, modifiers : Modifiers) {    
    this.loc <- loc;
    this.name <- name;
    this.modifiers <- modifiers;
  }
}

public variant Top_decl : Located
{
  | TD_namespace { 
      name : list <string>; 
      decls : list <Top_decl>;
    }
  | TD_open {
      what : list <string>;
    }
  | TD_namespace_alias {
      alias : string;
      expanded : list <string>;
    }
  | TD_type {
      decl : Type_decl;
    }
}

public class Type_decl_base : Decl_base
{
  public mutable typarms : Typarms;
  public mutable t_extends : list <Type>;
  public this (name : Splicable_string, modifiers : Modifiers,   
               typarms : Typarms, t_extends : list <Type>) {
    base (name, modifiers);
    this.typarms <- typarms;
    this.t_extends <- t_extends;
  }
  public this () { base (SS_string (Name ([])), Modifiers (NemerleAttributes.None, [], [])) }
}

[Record]
public class Constraint
{
  public tyvar : string;
  public ty : Type;
}

[Record]
public class Typarms
{
  public tyvars : list <string>;
  public constraints : list <Constraint>;
}
  
public variant Type_decl : Type_decl_base
{
  | TD_class { decls : list <Class_member>; }
  | TD_alias { ty : Type; }
  | TD_interface { methods : list <Class_member>; }   // only iface_member
  | TD_variant { decls : list <Class_member>; }
  | TD_variant_option { decls : list <Class_member>; }
  | TD_macro { header : Fun_header; synt : list <Expr>; expr : Expr; phase : int; }
  | TD_delegate { header : Fun_header; }
  | TD_enum { decls : list<Enum_field>; }
}

public class Enum_field : Decl_base
{
  public value : option <Literal>;

  public this (v : option <Literal>, name : Splicable_string,
                 modifiers : Modifiers) {
    base (name, modifiers);
    value <- v;
  }
}

public variant Class_member : Decl_base
{
  | M_type { td : Type_decl; }
  | M_field { ty : Type; }
  | M_function { 
      header : Fun_header;
      mutable kind : Fun_kind;
      mutable body : Fun_body;
    }
  | M_property {
      ty : Type;
      dims : list <Fun_parm>; // parameters of indexer property
      mutable get : option <Fun_body>;
      mutable set : option <Fun_body>;
    }
  | M_event {
      ty : Type;
      mutable add : option <Fun_body>;
      mutable remove : option <Fun_body>;
    }
}

/// class encapsulating name of variable for purpose of
/// quotation and renaming
public class Name : Nemerle.IComparable <Name>
{
  public idl : list <string>;  
  public color : int;
  public context : GlobalEnv;

  public this (idl : list<string>)
  {
    this.idl <- idl;
    this.color <- TypingContext.MacroColor;
    this.context <- null; // no global context
  }
  
  public this (id : string)
  {
    this.color <- TypingContext.MacroColor;
    this.context <- null; // no global context
    idl <- [id]
  }

  public this (id : list <string>, color : int, context : GlobalEnv)
  {
    this.color <- color;
    this.context <- context;
    idl <- id;
  }

  static public NameInCurrentColor (id : list <string>, context : GlobalEnv) : Name
  {
    Name (id, TypingContext.MacroColor, context)
  }

  public GetId () : string
  {
    Nemerle.Utility.NString.Concat (".", idl)
  }

  public GetHead () : string
  {
    Nemerle.Collections.List.Head (idl)
  }

  public CompareTo (other : Name) : int
  {
    def cmp (my, oth) {
      | (x :: xs, y :: ys) =>
        if (x == y) cmp (xs, ys)
        else string.CompareOrdinal (x, y)
      | ([], []) => 0
      | (_, []) => 1
      | ([], _) => -1
    };

    if (color == other.color || color < 0 || other.color < 0)
      cmp (idl, other.idl)
    else
      color - other.color
  }

  public GetEnv (default : GlobalEnv) : GlobalEnv
  {
    if (context != null)
      context
    else
      default
  }
}

public variant Splicable_string : Located 
{
  | SS_string { body : Name; }
  | SS_spliced_expr { expr : Expr; }
}

public variant Type
{
  | T_app {
      tycon : Splicable_string;
      args : list <Type>;
    }
  | T_ref { t : Type; }
  | T_out { t : Type; }
  | T_fun { from : Type; to : Type; }
  | T_void
  | T_prod { args : list <Type>; }
  | T_array { t : Type; }
  | T_infer

  | T_spliced { expr : Expr; }
  | T_spliced_special { ty : string; val : Expr; }
  | T_type_list { body: Type; }
  
  | T_typed { body : Typedtree.Type; }
}

public variant Fun_parm_modifier 
{
  | FP_normal
  | FP_params
  | FP_default { expr : Expr; }
}

public class Fun_parm : Located
{
  public name : Splicable_string;
  public ty : Type;
  public attr : Fun_parm_modifier;
  public this (name : Splicable_string, ty : Type, att : Fun_parm_modifier) 
    {
      this.loc <- Location ("", 0, 0, null);
      this.name <- name;
      this.ty <- ty;
      this.attr <- att;
    }
  public this (loc : Location, name : Splicable_string, ty : Type,
               att : Fun_parm_modifier) 
    {
      this.loc <- loc;
      this.name <- name;
      this.ty <- ty;
      this.attr <- att;
    }

  public this () {}
}
  
public class Fun_header : Located
{
  public typarms : Typarms;
  public mutable name : Splicable_string;
  public ret_type : Type;
  public parms : list <Fun_parm>;
  public this () {}
  public this (loc : Location, name : Splicable_string, ret_type : Type, 
               parms : list <Fun_parm>) 
    {
      this.typarms <- Typarms ([], []);
      this.loc <- loc;
      this.name <- name;
      this.ret_type <- ret_type;
      this.parms <- parms;
    }
  public this (typarms : Typarms, name : Splicable_string, ret_type : Type, 
               parms : list <Fun_parm>) 
    {
      this.typarms <- typarms;
      this.name <- name;
      this.ret_type <- ret_type;
      this.parms <- parms;
    }
}

[Record]
public class Function_decl
{
  public header : Fun_header;
  public mutable body : Expr;
}

public variant Pattern : Located
{
  | P_underscore
  | P_variable { name : Name; }
  | P_as { pat : Pattern; name : Splicable_string; }
  | P_tuple { args : list <Pattern>; }
  | P_record { args : list <string * Pattern>; }
  | P_cons { name : Splicable_string; arg : Pattern; }
  | P_literal { lit : Literal; }

  // macros stuff
  | P_quoted { body : SyntaxElement; }
  | P_spliced { pat : Expr; }
  | P_patt_list { body : Pattern; }
  | P_spliced_special { ty : string; val : Expr; }
  | P_typed { body: Typedtree.Pattern; }
}

[Record]
public class Match_case
{
  public patterns : list <Pattern * option <Expr>>;
  public body : Expr;
}
  
public variant Expr : Located 
{ 
  | E_ref { name : Name; }
  | E_member { obj : Expr; member : Splicable_string; }
  | E_call { func : Expr; parms : list <Parm>; }
  | E_assign { target : Expr; source : Expr; }
  | E_let { is_ref : bool; name : Splicable_string; val : Expr; }
  | E_letpat { pattern : Pattern; val : Expr; }
  | E_letfun { funs : list <Function_decl>; }
  | E_lambda { decl : Function_decl; }
  | E_match { expr : Expr; cases : list <Match_case>; }
  | E_raise { exn : Expr; }
  | E_try_with { body : Expr; exn : Splicable_string; exn_ty : Type; 
                 handler : Expr; }
  | E_try_finally { body : Expr; handler : Expr; }
  | E_literal { val : Literal; }
  | E_this
  | E_base
  | E_typeof { ty : Type; }
  | E_type_conversion { expr : Expr; ty : Type; }  // (expr :> ty)
  | E_type_enforcement { expr : Expr; ty : Type; } // (expr : ty)
  | E_sequence { body : list <Expr>; }
  | E_tuple { args : list <Expr>; }
  | E_mkarray { args : list <Expr>; }
  | E_empty_array { sizes : list <Expr>; }
  | E_indexer { obj : Expr; args : list <Expr>; }

  // macros stuff    
  | E_macrocall { name : Name; ns : GlobalEnv.NamespaceND;
                  parms : list <SyntaxElement>; }
  | E_quoted { body : SyntaxElement; }
  | E_spliced { body : Expr; }
  | E_spliced_patt { body : Pattern; }
  | E_spliced_special { ty : string; val : Expr; }
  | E_expr_list { body : Expr; }
  | E_typed_expr { body : Nemerle.Compiler.Typedtree.Expr; }
}

public class Parm
  {
    public is_ref : bool;
    public expr : Expr;
    public name : Splicable_string;  // "" if no name given

    public this (is_ref : bool, expr : Expr, name : Splicable_string) {
      this.is_ref <- is_ref;
      this.expr <- expr;
      this.name <- name;
    }
    public this (expr : Expr) {
      this.is_ref <- false;
      this.expr <- expr;
      this.name <- SS_string (Name ([]));
    }
  }

 
} // Nemerle.Compiler

