using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

[assembly: System.Reflection.AssemblyKeyFile("../../misc/keys/Nemerle.Compiler.snk")]
  
namespace Nemerle.Evaluation
{
  /**
   * <summary>
   *   Allows dynamic evaluation of code, with persistent computation 
   *   history (retaining computed variables, functions, etc.) between
   *   subsequent calls to Evaluator ().Eval ().
   * </summary>
   * <seealso cref="Nemerle.Compiler.NemerleCodeProvider">
   *   NemerleCodeProvider
   * </seealso>
   */
  public class Evaluator
  {
    // Evaluated code.
    static mutable code : string;
    // [(is_mutable, name, type)]
    static mutable locals : list [bool * string * PExpr];
    // [(Some (shortname), longname) or (None (), longname)]
    static mutable ns : list [option [string] * list [string]];
    // [value]
    public static mutable vals : list [object];
   
    public this () {
      Evaluator.locals = [];
      Evaluator.vals = [];
      Message.InitOutput (System.Console.Out);         
  
      Options.CompileToMemory = true;
      Options.IgnoreConfusion = true;
      Options.ProgressBar = false;
      Options.Sources = [""];
      // unused variable
      WarningOptions.Disable (168);   
      // ignore computed value
      WarningOptions.Disable (10005); 
  
      Passes.LexingPipeline = fun (_) { null };
      Passes.ParsingPipeline = fun (_) { [null] };
      Passes.ScanningPipeline = DoTheStuff;
    }
  
    /**
     * <summary>
     *   Evaluates supplied code in memory and returns computation results.
     *   Persistent computation history is maintained between subsequent calls.
     * </summary>
     * <param name="refr">
     *   A list of assembly names, that are to be linked during evaluation.
     * </param>
     * <param name="ns">
     *   A list of namespace aliases and namespaces that are to be opened
     *   within the evaluated code. 
     *   Namespace aliases take the form (Some (shortname), longname), while
     *   namespaces - (None (), longname).
     * </param>
     * <param name="code">
     *   The code to evaluate.
     * </param>
     * <returns>
     *   A sorted list of computed variables and functions with additional 
     *   descriptive information. The tuple members from the list are:
     *   #1 - true if the variable was introduced during the last Eval,
     *        false if it was onthe list before.
     *   #2 - true if the variable is mutable, false if not.
     *   #3 - name of the variable.
     *   #4 - value of the variable.
     *   #5 - type of the variable.
     *
     *   The last computed value - the return value of the evaluated code
     *   is returned as a special variable named "it".
     * </returns>
     */
    public Eval (refr: list [string], ns: list [option [string] * string],
                 code: string) : list [bool * bool * string * object * PExpr] {
      Evaluator.code = code;
      Evaluator.ns = List.FoldLeft (ns, [], fun (x, acc) { 
        def (x1, x2) = x;
        (x1, NString.Split (x2, array ['.'])) :: acc 
      });
      
      // Link ourselves.
      Options.ReferencedLibraries = System.Reflection.Assembly.GetAssembly 
                                    (this.GetType ()).Location :: refr;
      
      // Locals and vals from previous calls to Eval.
      def prevlocals = Evaluator.locals;
      def prevvals = Evaluator.vals;
  
      Passes.Run ();
      
      def ass = Passes.GeneratedAssembly;
      def meth = ass.GetTypes()[0].GetMethod ("Run");
      // And here are the new values (along with the old ones).
      def newvals = meth.Invoke (null, null) :> list [object];
  
      // Check which variables are new to this call and set the first field
      // in the return tuple - true for variable "it", new ones and those 
      // whose values and/or type has changed; false - for the rest.
      def loop (l1, l2, l3, l4, acc) {
        match ((l1, l2, l3, l4)) {
          | ([], [], [], []) => acc
          | ((mut, name, ty) :: t1, [], h3 :: t3, []) => 
            loop (t1, [], t3, [], (true, mut, name, h3, ty) :: acc)
          | ((mut, name, ty) :: t1, (prevmut, prevname, prevty) :: t2, 
            h3 :: t3, h4 :: t4) =>
            if (name == prevname)
              if (name == "it" ||
                  (h3 != null && !(h3.Equals (h4))) ||
                  (h3 == null && h4 != null) ||                
                  mut != prevmut)
                loop (t1, t2, t3, t4, (true, mut, name, h3, ty) :: acc)
              else
                loop (t1, t2, t3, t4, (false, mut, name, h3, ty) :: acc)
            else
              loop (t1, (prevmut, prevname, prevty) :: t2, t3, h4 :: t4,
                   (true, mut, name, h3, ty) :: acc)
          | _ => assert (false, "Error: internal error, please report a bug.")
        }
      }
  
      Evaluator.vals = List.Rev (newvals);
  
      loop (Evaluator.locals, prevlocals, newvals, List.Rev (prevvals), [])
    }
  
    internal static DoTheStuff (_tdecl : Parsetree.TopDeclaration) : void {
      MacroRegistry.register_macro (StagedMacro ());
      def n = (None (), ["Nemerle", "Core"]) :: 
              (None (), ["Nemerle", "Core", "option"]) :: Evaluator.ns;
      // Open namespaces and set aliases.
      def env = List.FoldLeft (n, GlobalEnv.Empty, fun (x, acc : GlobalEnv) { 
                  def (x1, x2) = x;
                  match (x1) {
                    | None => acc.AddOpenNamespace (x2, Location.Default)
                    | Some (sname) => acc.AddNamespaceAlias (sname, x2, 
                                                             Location.Default)
                  }
                });
  
      MacroColorizer.PushNewColor (-1, env);
  
      // Set the class in which we're going to put the evaluated code.
      def cname = Macros.NewSymbol ();
      def tb = GlobalEnv.DefineExact (<[ decl: public class $(cname : name) {
                                               } ]>);
      def body = MainParser.ParseExpr (env, Evaluator.code); 
      
      // If the code ends with an assignment, append `()'.
      // Put a call to stagedmacro at the end of the evaluated code
      // with the last expression moved to the stagedmacro argument.
      def whole = match (body) {
        | <[ {..$seq } ]> => 
          def (beg, last) = List.DivideLast (seq);
          def last = 
            match (last) {
              | <[ def $_ = $_ ]> 
              | <[ mutable $_ = $_ ]> 
              | <[ def .. $_ ]> =>
                <[ $last; $("stagedmacro" : usesite) (()) ]>
              | _ => <[ $("stagedmacro" : usesite) ($last) ]>
            }
          <[ {..$ (beg + [last]) } ]>
        | _ => <[ $("stagedmacro" : usesite) ($body) ]>
      }
  
      // Recreate variables defined in previous calls to Eval.
      def inits = List.FoldLeft (Evaluator.locals, [], fun (x, acc) {
        def (mut, name, ty) = x;
        match ((mut, ty)) {
          | (false, <[ System.Object ]>) => 
            <[ def $(name : usesite)  = 
            Nemerle.Collections.List.Hd (Evaluator.vals) : $ty ]> :: 
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc;
          | (false, _) => 
            <[ def $(name : usesite)  = 
            Nemerle.Collections.List.Hd (Evaluator.vals) :> $ty ]> :: 
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc;
          | (_, <[ System.Object ]>) => 
            <[ mutable $(name : usesite) = 
            Nemerle.Collections.List.Hd (Evaluator.vals) : $ty ]> ::
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc; 
          | _ => 
            <[ mutable $(name : usesite) = 
            Nemerle.Collections.List.Hd (Evaluator.vals) :> $ty ]> ::
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc; 
        }
      });
      def whole = <[ {.. $(inits + [whole]) } ]>;
  
//      PrettyPrint.PrintExpr (None (), whole);
      
      tb.Define (<[ decl: public static Run () : list [System.Object] {
                          $whole } ]>);
      tb.Compile ();
  
      MacroColorizer.PopColor ();
    }
  
    internal class StagedMacro : IMacro 
    {
      public Run (ctx : Typer, val : list [SyntaxElement]) : PExpr {
        match (val) {
          // Fish out variables/functions and store them in our fields.
          | [SyntaxElement.Expression (expr)] =>
            Evaluator.locals = [];
            def l = ctx.GetLocals ();
            def values = <[ $expr : System.Object ]> :: 
                            l.Fold ([], fun (n : Name, loc : LocalValue, acc) {
              regexp match (n.ToString ()) {
                | @"^it$" => acc
                | _ => 
                  Evaluator.locals = (loc.IsMutable, loc.Name, 
                                      PrettyPrint.TyVarToParseTree 
                                      (loc.Type)) :: Evaluator.locals;
                  <[ ($(n : name) : System.Object) ]> :: acc
              }
            });
            Evaluator.locals = (false, "it", PrettyPrint.TyVarToParseTree 
                               (ctx.TypeExpr (expr).Type)) :: Evaluator.locals;
            <[ [..$values] ]>
          | _ => Util.ice ()
        }
      }
  
      // This below is only to satisfy the interface requirements.
      public CallTransform (l : list [PExpr]) : list [SyntaxElement]
      { List.Map (l, SyntaxElement.Expression) }
      public GetName () : string { "stagedmacro" }
      public GetNamespace () : string { "" }
      public IsInherited : bool { get { false } }
      public IsTailRecursionTransparent : bool { get { false } }
      public Keywords : list [string] { get { [] } }
      public SyntaxExtension () : GrammarElement * (list [SyntaxElement] -> 
                                                    list [SyntaxElement])
      { (null, fun (_) { [] }) }
      public Usage : Nemerle.MacroUsageAttribute { get { null } }
    }
  }
}
