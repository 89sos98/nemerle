open Nemerle.Compiler;
open Nemerle.Compiler.Treeutil;
open Nemerle.Collections;

namespace Nemerle.Compiler {

  class Treeutil
    {
      class Skip_recursion extends System.Exception 
        {
          method this () {}
        }

      fun ('a) decl_walk(tydecl_f : 'a * Type_decl -> 'a,
                         decl_f : 'a * Class_member -> void,
                         ctx : 'a,
                         tydecls : list (Type_decl)) : void =

        letfun do_tydecl(ctx : 'a, decl : Type_decl) : void =
          try
            Util.locate(decl#loc, fun () : void =>
              //let _ = Message.error("in: " + decl#name) in
              let ctx' = tydecl_f(ctx, decl) in
              match decl with [
                | TD_class (?ds) => do_decls(ctx', ds)
                | TD_interface (?ds) => do_decls(ctx', ds)
                | TD_variant (?tds) => 
                  List.iter(fun (d : Type_decl) : void => do_tydecl(ctx', d), tds)
                | TD_variant_option (?ds) => do_decls(ctx', ds)
                | TD_alias => ()
                | TD_external => ()
              ])
          with ?x : Recovery => ()
        and do_decls(ctx : 'a, decls : list (Class_member)) : void =
          letfun do_decl (decl : Class_member) : void =
            try
              Util.locate(decl#loc, fun () : void => {
                //let _ = Message.error("ind: " + decl#name) in
                decl_f(ctx, decl);
                match decl with [
                  | M_type (?t) => do_tydecl(ctx, t)
                  | M_iface_method => ()
                  | M_function => ()
                  | M_field => ()
                  | M_value => ()
                ]})
            with ?x : Recovery => ()
          in 
          List.iter(do_decl, decls)
        in
        List.iter(fun (d : Type_decl) : void => do_tydecl(ctx, d), tydecls);
   
   fun ('a) pattern_fold (func : 'a * Pattern -> 'a, ini : 'a, pat : Pattern) : 'a =
     try
        try
          letfun self(ini : 'a, e : Pattern) : 'a = 
            pattern_fold(func, ini, e) 
          in
          let ini = func(ini, pat) in
          match pat with [
            | P_underscore => ini
            | P_variable => ini
            | P_tuple (?pts) => List.fold_left(self, ini, pts)
            | P_record (?pis) => 
              let mkpat = fun (x : Named_pattern) : Pattern => x#pat in
              List.fold_left(self, ini, List.map(mkpat, pis))
            | P_cons (_, ?a) => self(ini, a)
          ]
        with ?x : Skip_recursion => ini
     with ?x : Recovery => ini;
     
   
   fun ('a) expr_walk (func : 'a * Expr -> 'a, ini : 'a, expr : Expr) : void =
     try
       Util.locate(expr#loc, fun () : void =>
          try
            let ini' = func(ini, expr) in
            letfun self(e : Expr) : void = expr_walk(func, ini', e) in
            match expr with [
              | E_ref => ()
              | E_this => ()
              | E_literal => ()
              | E_member (?e, _) => self(e)
              | E_call (?e, ?ps) =>
                  {
                    self(e);
                    List.iter(fun (p : Parm) : void => self(p#expr), ps)
                  }
              | E_assign (?e1, ?e2) => { self(e1); self(e2) }
              | E_let (_, _, ?e1, ?e2) => { self(e1); self(e2) }
              | E_letfun (?fs, ?e) =>
                  letfun do_fun(f : Function_decl) : void = self(f#body) in {
                    List.iter(do_fun, fs);
                    self(e)
                  }
              | E_lambda (?d) => self(d#body)
              | E_match (?e, ?mcs) =>
                  {
                    self(e);
                    List.iter(fun (m : Match_case) : void => self(m#body), mcs);
                  }
              | E_raise (?e) => self(e)
              | E_if (?e1, ?e2, ?e3) => { self(e1); self(e2); self(e3) }
              | E_try_with (?e1, _, _, ?e2) => { self(e1); self(e2) }
              | E_try_finally (?e1, ?e2) => { self(e1); self(e2) }
              | E_type_conversion (?e, _) => self(e)
              | E_type_enforcement (?e, _) => self(e)
              | E_sequence (?es) => List.iter(self, es)
              | E_tuple (?es) => List.iter(self, es)
            ]
          with ?x : Skip_recursion => ())
     with ?x : Recovery => ();
     
    }

  class Passes
    {
      fun run(decls : list (list (Top_decl))) : void =
        let _ = Env.globals <- Map.string_map() in
        let dd = List.map(Scan_globals.run, List.rev(decls)) in
        let decls = List.concat(dd) in {
          Bind_types.run(decls);
          Check_refs.run(decls);
          Tyinfo.run(decls);
        };
    }

} // N.C
