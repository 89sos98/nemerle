/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

using Nemerle.Collections;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

  /** MACROS EXTENDING SYNTAX OF LANGUAGE */

  /** specialized macro for [if] condition with good warning messages,
      it performs typing of given expressions to check their type
      correctness
   */
  macro @if (cond, e1, e2)
  syntax ("if", "(", cond, ")", e1, Optional (";"), "else", e2) 
  {
    def tcond = ty_expr (Nemerle.Macros.ImplicitCTX (), cond);
    def bool_ty = <[ ttype: bool ]>;
    expect_type ("if condition", tcond, bool_ty);
    
    <[ 
      match ($(tcond : typed)) { 
        | true => $e1 
        | _ => $e2
      } 
    ]>
  }

  /** this macro provides convenient way to write simple while loop,
      which perform execution of [body] parameter as long as
      [condition] is true
    */
  macro @while (cond, body)
  syntax ("while", "(", cond, ")", body) 
  {
    <[ 
      def loop () : void {
        when ($cond) { $body; loop() }
      }; 
      loop (); 
    ]>
  }

  /** shortcut for [if (cond) body else ()] */
  macro @when (cond, body)
  syntax ("when", "(", cond, ")", body) 
  {
    <[ match ($cond) { | true => $body | _ => () } ]>
  }

  macro @for (init, cond, change, body)
  syntax ("for", "(", Optional (init), ";", Optional (cond), ";",
          Optional (change), ")", body) 
  {
    def init = if (init != null) init else <[ () ]>;
    def cond = if (cond != null) cond else <[ true ]>;
    def change = if (change != null) change else <[ () ]>;    
    
    <[ 
      $init;
      def loop () : void {
        when ($cond) { $body; $change; loop() }
      }; 
      loop (); 
    ]>
  }

  /** shortcut for [if (cond) () else body] */
  macro @unless (cond, body)
  syntax ("unless", "(", cond, ")", body) 
  {
    <[ match ($cond) { | false => $body | _ => () } ]>
  }

  /** macro providing C# 'using' functionality
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_8.asp  
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vclrfusingstatement.asp
   */
  macro @using (body, params args : array <parm>)
  syntax ("using", "(", args, ")", body) 
  {
    def maybe_valuetype_dispose (nm, typed_expr) {
      def tc = Tyutil.GetTypeTycon (Tyexpr.type_of (typed_expr));
      if (tc != null && tc.IsValueType ())
        <[ ($(nm : name) :> System.IDisposable).Dispose () ]>
      else
        <[
          when ($(nm : name) != null)
            ($(nm : name) :> System.IDisposable).Dispose ()
        ]>
    };
    
    def len = args.Length;
    def store_exprs (i, preexprs, postexprs) {
      if (i < len) 
        match (args[i]) {
          | <[ parameter: $ex ]> =>
            def x = Macros.NewSymbol ();
            def ex = Tyexpr.ty_expr (Nemerle.Macros.ImplicitCTX (), ex);
            
            store_exprs (i + 1, <[ def $(x : name) = $(ex : typed) ]> :: preexprs,
                         maybe_valuetype_dispose (x, ex) :: postexprs)

          | <[ parameter: $(str : name) = $ex ]> =>
            def ex = Tyexpr.ty_expr (Nemerle.Macros.ImplicitCTX (), ex);            
            
            store_exprs (i + 1, <[ def $(str : name) = $(ex : typed) ]> :: preexprs, 
                         maybe_valuetype_dispose (str, ex) :: postexprs)

          | _ => Message.fatal_error ("Invalid parameters in 'using' macro")
        }
      else
        (preexprs, postexprs)
    };

    def (preexps, postexps) = store_exprs (0, [], []);
    List.FoldLeft2 (preexps, postexps, <[ $body ]>, fun (pre, post, acc) {
      <[ $pre; try $acc finally $post ]>
    });
  }

  macro @lock (x, body)
  syntax ("lock", "(", x, ")", body)
  {
    <[ 
      System.Threading.Monitor.Enter ($x);
      try 
        $body
      finally
        System.Threading.Monitor.Exit ($x);
    ]>
  }

  macro dowhile (cond, body) 
  syntax ("do", body, "while", "(", cond, ")") 
  {
    <[ 
      def loop () {
        $body; 
        when ($cond) loop ();
      };
      loop ()
    ]>
  }

  macro @repeat (cond, body) 
  syntax ("repeat", body, "until", "(", cond, ")") 
  {
    <[ do $body while (! $cond) ]>
  }

  macro @foreach (iter : funparm, collection, body)
  syntax ("foreach", "(", iter, "in", collection, ")", body)
  {
    match (iter) {
      | <[ funparm: $(iname : name) : $ty ]> =>
        <[ 
          def enumerator = $collection.GetEnumerator ();
          def loop () {
            when (enumerator.MoveNext ()) {
              def $(iname : name) = (enumerator.Current :> $ty);
              $body;
              loop ();
            }
          };
          loop ()
        ]>
      | _ =>
        Message.fatal_error ("iterator in foreach must be identifier" +
                             "with optional type")
    }
  }

  macro ignore (e) 
  {
    <[ def _ = $e; () ]>
  }

  macro assert (cond, message = <[ "" ]>) 
  {
    match (cond) {
      | <[ false ]> =>
        // skip cond in this case so it gets 'a type
        <[ throw AssertionException ($(cond.loc.file : string), 
                                     $(cond.loc.line : int),
                                     "", $message) ]>
      | _ =>
        <[ unless ($cond) 
             throw AssertionException ($(cond.loc.file : string), 
                                       $(cond.loc.line : int),
                                       $(Macros.SprintExpr (None (), cond) : string),
                                       $message) ]>
    }
  }

  macro abort (message = <[ "" ]>) 
  {
    <[ throw AssertionException ($(message.loc.file : string), 
                                 $(message.loc.line : int), $message) ]>
  }

  /** MACROS EXTENDING TYPE SYSTEM OF LANGUAGE */

  postadd macro Record (par : TypeDecl)
  {
    def collect (mem : IField, acc) {
      def n = Macros.UseSiteSymbol (mem.Name);
      def fp = <[ funparm: $(n : name) : $(mem.GetMemType () : typed) ]>;
      def ex = <[ this.$(n : name) <- $(n : name) ]>;
      def (es, ps) = acc;
      (ex :: es, fp :: ps)
    };

    def make_ctor (base_ctor : IMember) {
      def base_ctor = (base_ctor :> IMethod);
      def (ctor_parms, base_call) =
        if (base_ctor == null)
          ([], <[ base () ]>)
        else {
          def pp = base_ctor.GetHeader ().parms;
          def callparms = List.Map (pp, fun (fp : Fun_parm) {
            <[ parameter: $(Macros.UseSiteSymbol (fp.name) : name) ]>
          });
          (List.Map (pp, fun (fp : Fun_parm) {
             def nm = Macros.UseSiteSymbol (fp.name);
             <[ funparm: $(nm : name) : $(fp.ty : typed) ]>
           }),
           <[ base (..$callparms) ]>)
        };

      def (assigns, parms) = List.FoldLeft (par.GetFields (with_static = false,
                                                           with_derived = false),
                                            ([], []), collect);
      def body = <[ { ..$(base_call :: assigns) } ]>;
      body.loc <- par.GetLocation ();
      def attrs = Modifiers (
        match (par.GetTydecl ()) {
          | TD_variant => NemerleAttributes.Protected
          | _ => NemerleAttributes.Public
        }, [], []);
      def parms = List.Append (ctor_parms, List.Rev (parms));
      def meth = <[ method: ..$attrs this (..$parms) $body ]>;
      meth.loc <- par.GetLocation ();
      meth
    };
      
    match (par.SuperClass ()) {
      | Some (baseti) =>
        def decls = baseti.LookupMember (".ctor");
        def is_ctor (m : IMember) {
          match (m.GetKind ()) {
            | MK_method (m) => 
              match (m.GetFunKind ()) {
                | FK_ctor => true
                | _ => false
              }
            | _ => false
          }
        };
        match (List.Filter (decls, is_ctor)) {
          | [] => 
            match (baseti.GetTydecl ()) {
              | TD_variant => par.DefineMember (make_ctor (null))
              | _ =>
                Message.fatal_error ("type `" + baseti.GetFullName () + "' (base of `" + 
                                     par.GetFullName () +
                                     "') has no constructors, cannot "
                                     "generate default constructor")
            }
          | decls =>
            List.Iter (decls, fun (x) { par.DefineMember (make_ctor (x)) })
        }
      | None =>
        par.DefineMember (make_ctor (null))
    }
  }

  postadd macro StaticInitializer (t : TypeDecl, f : BoundField, val)
  {
    def is_static = f.Attributes %&& NemerleAttributes.Static;
    def mems = List.Filter (t.GetMembers (), fun (x : IMember) {
      (x.IsStatic () == is_static) &&
      match (x.GetKind ()) {
        | MK_method (mem) =>
          match (mem.GetFunKind ()) {
            | FK_ctor => true
            | _ => false
          }
        | _ => false
      } 
    });
    def nm = Macros.UseSiteSymbol (f.Name);
    def (init, base_ctor) =
      if (is_static)
        (<[ $(nm : name) <- $val ]>, <[ () ]>)
      else
        (<[ this.$(nm : name) <- $val ]>, <[ base () ]>);
    def inject (ctor : NemerleMethod) {
      def bd = ctor.Body;
      def nbody =
        match (bd) {
          | <[ {.. $(e :: rest) } ]> =>
            match (e) {
              | <[ base (..$_) ]> => <[ $e; $init; {.. $rest } ]>
              | <[ this (..$_) ]> => bd
              | _ => <[ $base_ctor; $init; $bd ]>
            }
          | _ => <[ $base_ctor; $init; $bd ]>
        };
      ctor.Body <- nbody
    };
    match (mems) {
      | [] =>
        if (is_static) 
          t.DefineMember (<[ method: static public this () { $init } ]>)
        else
          t.DefineMember (<[ method: public this () { $base_ctor; $init } ]>)
      | _ =>
        List.Iter ((mems :> list <NemerleMethod>), inject)
    }
  }
}

namespace Nemerle.Compiler.Util {
  macro locate (l, body) {
    <[
      def pushpop = $l != null && $l != Located.default_loc;
      when (pushpop) Location_stack.push ($l);
      try $body finally when (pushpop) Location_stack.pop ()
    ]>
  }
}

namespace Nemerle.Macros {
/*
  preadd macro Hygienic (_ : TypeDecl, m : BoundMethod) {
    def body = (m.fun_body :> FB_parsed_expr).expr;
    def nbody = <[
      TypingContext.PushNewColor (TypingContext.NewColor (),
                                  GlobalEnv.Empty);
      def result = $body;
      TypingContext.PopColor ();
      result
    ]>;
      
    m.fun_body <- FB_parsed_expr (nbody)
  }
*/
  postscan macro Hygienic (_ : TypeDecl, m : Method) {
    m.body <- <[
      TypingContext.PushNewColor (TypingContext.MacroUseColor,
                                  TypingContext.MacroUseContext);
      def result = $(m.body);
      TypingContext.PopColor ();
      result
    ]>;
  }


  macro DefineCTX (ctx) {
    <[ def $(Nemerle.Compiler.Macros.GetImplicitCTXName () : name) = $ctx ]>
  }

  macro ImplicitCTX () {
    <[ $(Nemerle.Compiler.Macros.GetImplicitCTXName () : name) ]>
  }  
  
  /** creates new symbol with given id and current global context */
  macro Symbol (id)
  {
    def nr = Nemerle.Macros.ImplicitCTX ().env.GetMacroContext ();
    <[ PT.Name.NameInCurrentColor (Nemerle.Utility.NString.Split ($id, array ['.']), 
                                   $("_N_MacroContexts" : dyn).Get ($(nr : int))) ]>
  }

  macro pretty_print_expr (exp, expand : bool)
  {
    def ctx = if (expand) Some (Nemerle.Macros.ImplicitCTX ()) else None ();
    Macros.PrintExpr (ctx, exp);
    <[ () ]>
  }
}


namespace Nemerle.Extensions {
  /** MACROS, WHICH WE CAN DO BETTER THAN HASKELL */

  macro SelectFromTuple (k : int, n : int, tupl)
  {
    def symb = Macros.NewSymbol ();
    mutable tup <- [];
    for (mutable i <- n; i > 0; --i)
      if (i == k)
        tup <- <[ pattern: $(symb : name) ]> :: tup
      else
        tup <- <[ pattern: _ ]> :: tup;

    <[ def (.. $tup) = $tupl; $(symb : name) ]>
  }

  macro TupleMap (f, tup)
  {
    match (tup) {
      | <[ (.. $elms) ]> =>
        def mapped = List.Map (elms, fun (e) { <[ $f ($e) ]> });
        <[ (.. $mapped) ]>
      | _ => 
        Message.fatal_error ("'TupleMap' macro expects function and tuple")
      }
  }

  macro PrintTuple (tup, size : int)
  {
    def symbols = array (size);
    mutable pvars <- [];
    for (mutable i <- size - 1; i >= 0; --i) {
      symbols[i] <- Macros.NewSymbol ();
      pvars <- <[ pattern: $(symbols[i] : name) ]> :: pvars;
    };
    mutable exps <- [];
    for (mutable i <- size - 1; i >= 0; --i)
      exps <- <[ System.Console.WriteLine ($(symbols[i] : name)) ]> :: exps;

    exps <- <[ def (.. $pvars) = $tup ]> :: exps;
    <[ {.. $exps } ]>
  }

  macro PrintTupleTyped (tup)
  {
    match (type_of (ty_expr (Nemerle.Macros.ImplicitCTX (), tup))) {
      | T_prod (args) =>
        def size = List.Length (args);
        def symbols = array (size);
        mutable pvars <- [];
        for (mutable i <- size - 1; i >= 0; --i) {
          symbols[i] <- Macros.NewSymbol ();
          pvars <- <[ pattern: $(symbols[i] : name) ]> :: pvars;
        };
        mutable exps <- [];
        for (mutable i <- size - 1; i >= 0; --i)
          exps <- <[ System.Console.WriteLine ($(symbols[i] : name)) ]> :: exps;
          
        exps <- <[ def (.. $pvars) = $tup ]> :: exps;
        <[ {.. $exps } ]>
      | _ => 
        Message.fatal_error ("expected tuple")
    }
  }
} // end ns


namespace Nemerle.Attributes {

  /// Attribute macros TODO:
  
  /// Example: foo ([NotNull] o : objet) : void { ... }
  /*  postscan macro NotNull (p : MethodParm)
      {
      }
   */

  /// Example: foo ([Requires (value != 4)] i : int) : void { ... }
  ///  postscan macro Requires (p : MethodParm, assertion)

  /// Example: [Requires (i != 4 && boo ())] foo (i : int) : void { ... }
  postscan macro Requires (_ : TypeDecl, m : Method, assertion)
  {
    m.body <- <[
      assert ($assertion, "The ``Requires'' contract has been violated.");
      $(m.body)
    ]>
  }
  
  /// Example: [return: Ensures (value != 4)] foo (i : int) : int { ... }
  ///  postscan macro Ensures (p : MethodReturn, assertion)

  /// Example: [return: Ensures (foo () != 4)] foo (i : int) : int { ... }
  postscan macro Ensures (_ : TypeDecl, m : Method, assertion)
  {
    m.body <- <[ def result = $(m.body);
      assert ($assertion, "The ``Ensures'' contract has been violated."); result
    ]>
  }

  /// Adds code coverage noting functions to bodies of all methods inside class
  /// Example: [CheckCodeCoverage ("coverage.txt") class A { foo () : void { .. } ... }
  ///  postscan macro CheckCodeCoverage (t : TypeDecl, output_file : string = "")

  /// Verify - tries to check other attributes at compile time
  /// CheckUselessAssignments - looks for code like i <- i

  
  






}
