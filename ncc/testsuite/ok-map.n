using Nemerle.Collections.New;

public module foo {

  public Main () : void 
  {
    def map = Map.IntMap ();
    def map = map.Add (1,"1");
    def map = map.Add (2,"2");
    def map = map.Remove (3,"3");
    def map = map.Add (3, "2");
    def map = map.Add (3, "4");
    map.Iter (fun (elem, str) {print_endline (string_of_int (elem)+" "+str)});
    print_endline ("size : "+string_of_int (map.Size ()));
    when (! map.Member (3))
      print_endline ("wrong member");
    def map = map.Remove (3, "3");
    match (map.Find (3)) {
    | Some => print_endline ("wrong get")
    | None => print_endline ("ok")
    };
    print_endline ("size : "+string_of_int (map.Size ()));
    def map = map.Add (4, "3");
    def map = map.Replace (4, "4");
    print_endline ("size : "+string_of_int (map.Size ()));
    map.Iter (fun (elem, str) {print_endline (string_of_int (elem)+" "+str)});
    match (map.Partition ( fun (x, _) { x>2 })) {
      (ymap, nmap) =>
        print_endline ("1st part :");
        ymap.Iter (fun (elem, str) {print_endline (string_of_int (elem)+" "+str)});
        print_endline ("2nd part :");
        nmap.Iter (fun (elem, str) {print_endline (string_of_int (elem)+" "+str)})
    }
  }
}

/*
BEGIN-OUTPUT
1 1
2 2
3 2
size : 3
ok
size : 2
size : 3
1 1
2 2
4 4
1st part :
4 4
2nd part :
1 1
2 2
END-OUTPUT
*/
