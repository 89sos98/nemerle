/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler 
{
  using Nemerle.Collections;
  using Nemerle.Utility;
  using Nemerle.IO;

  using Nemerle.Compiler;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Compiler.Tyops;

  using SR = System.Reflection;
  using PT = Nemerle.Compiler.Parsetree;  

  /**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   */
  public class LibraryReferenceException : System.Exception 
  {
    public this () {}
  }


  /**
   * Manager for the referenced libraries
   */
  public module LibraryReferenceManager
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */
  
    /**
     * Static constructor. Always load the Framework core library.
     */
    public this () {
      namespace_nodes = Hashtable (300);

      def assembly_dir (t) {
        DirectoryOfCodebase ((t : System.Type).Assembly.CodeBase);
      };
      
      // include current directory and directories where 
      // mscorlib.dll, System.dll and Nemerle.dll reside
      _lib_path = [".",
                    assembly_dir (typeof (Nemerle.Core.AssertionException)),
                    assembly_dir (typeof (System.Text.RegularExpressions.Match)),
                    assembly_dir (typeof (System.Object))];

      _loaded_assemblies_by_name = Hashtable (20);
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public Init () : void
    {
      namespace_nodes.Clear ();
      _loaded_assemblies_by_name.Clear ();
      _libraries = [];
    }

  
    /**
     * Stores the referenced library for later lookup by the namespaces. Also
     * add transitive closure of libraries needed by given assembly.
     */
    public AddLibrary (name : string) : void 
    {
      def assembly =
        match (name) {
          | "mscorlib" when Flags.use_loaded_corlib =>
            typeof (System.Object).Assembly
          | "System" when Flags.use_loaded_corlib =>
            typeof (System.Text.RegularExpressions.Match).Assembly
          | name => LookupAssembly (name)
        };
      if (assembly == null) {
        Message.error ("cannot find assembly `" + name + "'");
        throw AssemblyFindException ()
      }
      else if (_loaded_assemblies_by_name.Contains (assembly.FullName))
        Message.warning ("assembly `" + name + "' already loaded")
      else
        AddAssembly (assembly)
    }

    public AddAssembly (assembly : SR.Assembly) : void
    {
      unless (_loaded_assemblies_by_name.Contains (assembly.FullName)) {
        _libraries = LibraryReference (assembly) :: _libraries;
        _loaded_assemblies_by_name.Set (assembly.FullName, assembly);
        def refs = assembly.GetReferencedAssemblies ();
        NArray.Iter (refs, fun (name : SR.AssemblyName) {
          def asm =
            try {
              SR.Assembly.Load (name)
            } catch { _ : System.IO.FileNotFoundException => 
              try {
                SR.Assembly.LoadFrom (name.CodeBase)
              } catch { _ : System.Exception => 
                LookupAssembly (name.Name)
              }
            };
          if (asm == null)
            Message.warning ("cannot load library '" + name.Name + 
                             "' referenced by `" + assembly.GetName ().Name + "'")
          else
            AddAssembly (asm)
        })
      }
    }
      
    public AddSearchDirectory (name : string) : void
    {
      _lib_path = name :: _lib_path;
    }
    
    /**
     * Remove assembly file name from URL returned by Assembly.CodeBase.
     */
    public DirectoryOfCodebase (path : string) : string
    {
      def path =
        if (path.LastIndexOf ('/') > path.LastIndexOf ('\\'))
          path.Substring (0, path.LastIndexOf ('/'));
        else
          path.Substring (0, path.LastIndexOf ('\\'));

      // hack for mono returning location in the GAC
      def mono_gac = path.IndexOf ("mono/gac");
      def path =
        if (mono_gac != -1)
          if (path.IndexOf ("Nemerle") == -1)
            path.Substring (0, mono_gac + 5) + "1.0/"
          else
            path.Substring (0, mono_gac + 5) + "nemerle/"
        else path;

      path
    }

    /* -- PRIVATE METHODS -------------------------------------------------- */

    private LookupAssembly (name : string) : SR.Assembly
    {
      def assembly_by_name (path : string) {
        try {
          def path =
            if (path.EndsWith (".dll")) path
            else path + ".dll";

          SR.Assembly.LoadFrom (path)
        } catch { _ : System.IO.FileNotFoundException => null };
      };

      match (name) {
        | x when x.IndexOf ('/') != -1 || x.IndexOf ('\\') != -1 =>
          assembly_by_name (x)

        | x when x.IndexOf (',') != -1 =>
          try {
            SR.Assembly.Load (x)
          }
          catch {
            | _ : System.IO.FileNotFoundException => null
            | _ : System.BadImageFormatException =>
              Message.error ("passed strong name is invalid or assembly was not found");
              null
          }

        | _ =>
          def lookup (libs) {
            | lib :: libs =>
              def ret = assembly_by_name (System.IO.Path.Combine (lib, name));
              if (ret == null) lookup (libs)
              else ret
            | [] => null
          };

          lookup (_lib_path);
      }
    }


    private load_macro (lib : SR.Assembly, macro_name : string) : void
    {
      def macro_type = lib.GetType (macro_name.Replace ("&", "\\&"));
      if (macro_type == null) {
        Message.warning ("failed to lookup macro `" + macro_name + "' in assembly " + 
                         lib.FullName);
      } else {
        def ctor = macro_type.GetConstructor (System.Type.EmptyTypes);
        if (ctor == null) {
          Message.warning ("failed to lookup constructor in macro `" + macro_name + 
                           "' from assembly " + lib.FullName);
        } else {
          def macro_object = ctor.Invoke (null);
          if (macro_object == null) {
            Message.warning ("failed to construct instance of macro `" + macro_name + 
                             "' from assembly " + lib.FullName);
          } else {
            def casted_macro =
              try {
                (macro_object :> IMacro)
              } catch {
                | _ : System.InvalidCastException =>
                  Message.warning ("instance of macro `" + macro_name + 
                                   "' from assembly " + lib.FullName + 
                                   " does not implement IMacro interface");
                  null
              };
              when (casted_macro != null) {
                def ns = casted_macro.GetNamespace ();
                when (namespace_nodes.Get (ns) matches None)
                  ignore (cache_namespace_node (ns));

                MacroRegistry.register_macro (casted_macro);
              }
          }
        }
      }
    }

    public LoadMacrosFrom (lib : SR.Assembly) : void
    {
      foreach (attribute in lib.GetCustomAttributes (true))
        when (attribute is Nemerle.Internal.ContainsMacroAttribute) {
          def meth = attribute.GetType ().GetMethod ("GetName");
          def macro_name = (meth.Invoke (attribute, null) :> string);
            load_macro (lib, macro_name)
        }
    }
    
    
    public LoadMacrosFrom (name : string) : void
    {
      def assembly = LookupAssembly (name);
      if (assembly == null)
        Message.error ("cannot load assembly with macros `" + name + "'")
      else
        LoadMacrosFrom (assembly);
    }
      
    
    /* -- PRIVATE VARIABLES ------------------------------------------------ */
    
    /**
     * The referenced library list
     */
    private mutable _libraries : list <LibraryReference>;

    /**
     * List of directories we look for assemblies in.
     */
    private mutable _lib_path : list <string>;

    private _loaded_assemblies_by_name : Hashtable <string, SR.Assembly>;

    private namespace_nodes : Hashtable <string, GlobalEnv.NamespaceND>;


    /* -- TYPE CACHE ----- */

    [Record]
    public class ExternalType {
      internal system_type : System.Type;
      internal library : LibraryReference;
      internal mutable tycon : Tycon;
      internal mutable message : string;
    }

    internal LoadTypesFrom (lib : LibraryReference) : void
    {
      def assembly = lib.GetAssembly ();
      def types = assembly.GetExportedTypes ();
      def codebasens = GlobalEnv.ExactPath ([assembly.CodeBase]);

      mutable i = 0;
      for (; i < types.Length; ++i) {
        def t = types[i];
        def name = t.FullName;
        def e = ExternalType (t, lib, null, null);
        def notcached = GlobalEnv.NotLoaded (e);

        def (ns_node, path_to_type) = framework_nesting (t);
        def mainnode = ns_node.Path (path_to_type);
        def fullnode = codebasens.Path (name.Replace ('+', '.'));

        // check if we have met such type before
        def ambiguous_other = 
          match ((mainnode.Value, fullnode.Value))
          {
            | (GlobalEnv.NotLoaded (x), _)
            | (_, GlobalEnv.NotLoaded (x)) => x
            | _ => null
          };

        when (ambiguous_other != null) {
          // such type was there somewhere, so create verbose message
          // for the case of ambiguous use
          assert (ambiguous_other.tycon == null);

          e.message = 
            "[" + assembly.FullName + "], " + 
            (if (ambiguous_other.message == null)
               "[" + ambiguous_other.library.GetAssembly ().FullName + "]"
             else 
               ambiguous_other.message);
        };
        
        // assign wrappers for future loading of typecons
        mainnode.Value = notcached;
        fullnode.Value = notcached;
      }
    }

    internal CacheTycon (t : System.Type, tc : Tycon) : void
    {
      def codebase = GlobalEnv.ExactPath ([t.Assembly.CodeBase]); 
      def (ns_node, path_to_type) = framework_nesting (t);
      def ns = codebase.Path (ns_node.Name).Path (path_to_type);
      match (ns.Value) {
        | GlobalEnv.NotLoaded (e) =>
          e.tycon = tc;
          ns.Value = GlobalEnv.Cached (tc)
        | GlobalEnv.No => ns.Value = GlobalEnv.Cached (tc)
        | GlobalEnv.NamespaceReference | GlobalEnv.MacroCall => 
          Util.ice ("wanted to cache in wrong place - value " + t.FullName)
        | GlobalEnv.Cached => Util.ice ("wanted to cache cached value " + t.FullName)
      }
    }

    internal GetInternalType (lib : LibraryReference, t : System.Type) : Tycon
    {
      def codebase = GlobalEnv.ExactPath ([t.Assembly.CodeBase]);
      def (ns_node, path_to_type) = framework_nesting (t);
      def ns = codebase.Path (ns_node.Name).Path (path_to_type);
      match (ns.Value) {
        | GlobalEnv.Cached (tc) => tc
        | GlobalEnv.No =>
          def tc = lib.ConstructTycon (t);
          ns.Value = GlobalEnv.Cached (tc);
          tc

        | GlobalEnv.MacroCall | GlobalEnv.NotLoaded | GlobalEnv.NamespaceReference => 
          Util.ice ("not loaded internal type... " + t.Assembly.CodeBase
                    + ":" + t.FullName)
      }
    }

    internal cache_namespace_node (namespc : string) : GlobalEnv.NamespaceND
    {
      def nd = GlobalEnv.ExactPath (NString.Split (namespc, array ['.']));
      nd.Value = GlobalEnv.NamespaceReference ();
      namespace_nodes.Add (namespc, nd);
      nd
    }

    internal framework_nesting (t : System.Type)
    : GlobalEnv.NamespaceND * list <string>
    {
      def loop (t : System.Type, acc) {
        def dt = t.DeclaringType;
        if (dt != null)
          loop (dt, dt.Name :: acc)
        else {
          def namespc = if (t.Namespace != null) t.Namespace else "";
          match (namespace_nodes.Get (namespc)) {
            | Some (nd) => (nd, acc)
            | None =>
              (cache_namespace_node (namespc), acc)
          }
        }
      }
      // workaround mono bug #63768
      if (t.IsPointer) {
        def find_name (acc, t : System.Type) {
          if (t.IsPointer)
            find_name (acc + "*", t.GetElementType ())
          else
            loop (t, [t.Name + acc])
        }
        find_name ("", t)
      } else
        loop (t, [t.Name])
    }
  }


  /**
   * This class stores information extracted from a referenced external library.
   */
  public class LibraryReference
  {
    /**
     * The assembly associated with this object
     */
    private mutable _library : SR.Assembly;

    /**
     * The location of this library
     */
    private mutable _location : Location;
    
    /**
     * The assembly's custom attributes
     */
    private mutable _assembly_attributes : list <System.Object>;
       
    /**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     */
    private mutable _is_generated_by_nemerle : bool;

    /**
     * Load an assembly. Extracts and processes the custom attributes array.
     */
    public this (assembly : SR.Assembly) 
    {
      _library = assembly;
      _location = Location (Location.GetFileIndex ("[library]"), 0, 0);
      _assembly_attributes = List.FromArray (_library.GetCustomAttributes (true));
      process_assembly_attributes ();

      LibraryReferenceManager.LoadTypesFrom (this);
      LibraryReferenceManager.LoadMacrosFrom (_library);
    }



    /**
     * Scans the assembly custom attributes looking for something interesting...
     */
    private process_assembly_attributes () : void
    {
      def loop (attributes : list <System.Object>) : void {
        match (attributes) {
          | [] => ()
          | (configuration_attribute : SR.AssemblyConfigurationAttribute) :: rest =>
            when (configuration_attribute.Configuration ==
                  "ContainsNemerleTypes") {
              //Message.debug ("Loaded assembly " + this._library.FullName
              //                 + " contains Nemerle types...");
              this._is_generated_by_nemerle = true
            }
            
            loop (rest)
          | _ :: xs => loop (xs)
        }
      };
      
      loop (this._assembly_attributes);
    }

    /**
     * Turns a Framework type into something edible by Nemerle's type system
     */
    private TypeOfType (framework_type : System.Type) : Type
    {
      if (framework_type.Name == "Void" && framework_type.Namespace == "System")
        T_void ()
      else
        if (framework_type.IsArray)
          T_array (TypeOfType (framework_type.GetElementType ()),
                   framework_type.GetArrayRank ())
        else 
          if (framework_type.IsByRef)
            // FIXME: out types, anyone?
            T_ref (TypeOfType (framework_type.GetElementType ()))
          else {
            def (ns_node, path_to_type) =
              LibraryReferenceManager.framework_nesting (framework_type);

            match (ns_node.LookupType (path_to_type)) {
              | Some (tc) => T_app (tc, [])
              | None =>
                def full = framework_type.FullName;
                match (LookupInternalType (full)) {
                  | Some (tc) => T_app (tc, [])
                  | None =>
                    def path = NString.Split (full, array ['.', '+']);
                    match (GlobalEnv.LookupExactType (path)) {
                      | Some (tc) => T_app (tc, [])
                      | None =>
                        Message.fatal_error ("unbound external type `" +
                                             framework_type.FullName + 
                                             "' referenced from library `" +
                                             _library.CodeBase + "'")
                    }
                }
            }
          }
    } 

    private TyconOfType (framework_type : System.Type) : Tycon
    {
      match (TypeOfType (framework_type)) {
        | T_app (tc, []) => tc
        | _ => Util.ice ()
      }
    } 

    /**
     * If true, the library seems to have been generated by the Nemerle compiler
     */
    internal IsGeneratedByNemerle () : bool 
    {
      this._is_generated_by_nemerle
    }

    internal GetAssembly () : SR.Assembly
    {
      this._library
    }
    
    /**
     * Construct Tycon object from given type in current assembly.
     */
    internal ConstructTycon (reflected_type : System.Type) : Tycon
    {
      if (_is_generated_by_nemerle && 
          has_attribute ("Nemerle.Internal.TypeAttribute",
                         reflected_type.GetCustomAttributes (false)))
        (TypeInfo (this, reflected_type) : Tycon)
      else
        (NetType (this, reflected_type) : Tycon)
    }

    /**
     * Looks for type named [name] that is internal to current assembly. Used
     * by type attribute decoder.
     */
    internal LookupInternalType (name : string) : option <Tycon>
    {
      def st = _library.GetType (name);
      if (st == null)
        None ()
      else
        Some (LibraryReferenceManager.GetInternalType (this, st))
    }

    private MethodOfMethodInfo (self : IMember, meth : SR.MethodInfo) : NetMethod
    {
      if (meth == null)
        null
      else
        match (self.DeclaringType) {
          | ti : TypeInfo => 
            MethodInfo (ti.tenv, this, meth)
          | tc =>
            when (IsGeneratedByNemerle ())
              Message.warning ($ "FIXME: non nemerle type $tc in nemerle assembly");
            NetMethod (this, meth)
        }
    }

    /* -----------------------------------------------------------------
     * .NET types
     * ----------------------------------------------------------------- 
     */
    private class NetType : Tycon
    {
      protected handle : System.Type;
      protected library : LibraryReference;
      protected id : int;
      protected attributes : NemerleAttributes;
      default_indexer : string;
      
      /* member_list is used to collect all members of given type
         When we are queried for member "foo", we look for it, and if
         it was never looked up before, we add it to the member_list.
         When we are queried for the "" member (which means to list all
         the members), we call handle.GetMembers () and skip
         members already in the member_list (they are marked in
         queried_members). This avoids creating duplicate members,
         which is crucial.  */
      mutable member_list : list <IMember>;
      queried_members : Hashtable <string, object>;

      /* members is kind of cache, but it is also used (in connection with
         member_list) to make sure each S.R.MemberInfo has only one 
         N.C.IMember */
      protected members : Hashtable <string, list <IMember>>;



      public this (lib : LibraryReference, h : System.Type)
      {
        // first cache ourself to avoid loops
        LibraryReferenceManager.CacheTycon (h, this);
        id = Util.next_id ();
        library = lib;
        handle = h;
        members = Hashtable (2);
        queried_members = Hashtable (2);
        member_list = [];

        // FIXME: get rid of this!
        when (IsDelegate) {
          def pref = "problem with delegate type `" + FullName + "': ";
          match (LookupMember (".ctor")) {
            | [ctor] =>
              def meth = (ctor :> IMethod);
              def fh = meth.GetHeader ();
              match (fh.parms) {
                | [_, p2] =>
                  match (LookupMember ("Invoke")) {
                    | [inv] => 
                      def ty = (inv :> IMethod).GetMemType ();
                      fh.parms = [p2];
                      p2.ty = ty
                    | invs =>
                      Message.warning (pref + sprintf ("invoke count %d",
                                                       List.Length (invs)))
                  }
                | parms =>
                  Message.warning (pref + sprintf ("ctor has %d parms",
                                                   List.Length (parms)))
              }
            | ctors => Message.warning (pref + sprintf ("%d constructors",
                                                        List.Length (ctors)))
          }
        }
        
        attributes = NemerleAttributes.None;

        when (handle.IsAbstract) attributes |= NemerleAttributes.Abstract;
        when (handle.IsSealed)   attributes |= NemerleAttributes.Sealed;
        when (handle.IsValueType) attributes |= NemerleAttributes.Struct;

        if (handle.DeclaringType == null) {
          if (handle.IsPublic) attributes |= NemerleAttributes.Public
          else attributes |= NemerleAttributes.Internal;
        } else {
          when (handle.IsNestedPrivate)  attributes |= NemerleAttributes.Private;
          when (handle.IsNestedPublic)   attributes |= NemerleAttributes.Public;
          when (handle.IsNestedFamily)   attributes |= NemerleAttributes.Protected;
          when (handle.IsNestedAssembly) attributes |= NemerleAttributes.Internal;
        }

        def attrs = handle.GetCustomAttributes (
                        SystemType.Reflection_DefaultMemberAttribute, true);
        default_indexer =
          if (attrs.Length > 0) {
            def dma = attrs [0] :> System.Reflection.DefaultMemberAttribute;
            dma.MemberName
          } else null;
      }

      /** Checks if underlying .NET type is value type */
      public IsValueType : bool {
        get { handle.IsValueType }
      }

      public DefaultIndexerName : option <string>
      {
        get {
          if (default_indexer == null)
            None ()
          else
            Some (default_indexer)
        }
      }
      
      public MemberType : MemberTypes
      { get { handle.MemberType } }

      public Name : string
      { get { handle.Name } }
      
      public GetLibraryReference () : LibraryReference
      { library }
      
      public IsDelegate : bool
      {
        get { handle.IsSubclassOf (SystemType.MulticastDelegate) }
      }
      
      public GetHandle () : SR.MemberInfo
      { handle }

      public virtual GetMemType () : Type
      {
        T_app (this, [])
      }

      public GetKind () : MemberKind
      {
        MK_type (this)
      }

      public virtual GetConstantObject () : option <IField>
      {
        None ()
      }

      public DeclaringType : Tycon {
        get {
          if (handle.DeclaringType == null)
            null
          else
            library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }
      
      public HasAttribute (attribute : Tycon) : bool
      {
        def t = attribute.GetSystemType ();
        handle.GetCustomAttributes (t, false).Length > 0
      }
      
      public GetAccessibility () : Accessibility
      {
        if (handle.IsPublic || handle.IsNestedPublic)
          A_public ()
        else if (handle.IsNestedFamily || handle.IsNestedFamORAssem)
          A_protected ()
        else {
          Message.debug ("non public, non prot " + FullName);
          assert (false)
        }
      }

      public IsExternallyAccessible : bool
      {
        // if it wasn't, we wouldn't have reflected it?
        get { true }
      }
      
      public IsStatic : bool
      {
        get { true }
      }

      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }
      
      public GetId () : int
      {
        id
      }

      public FullName : string
      {
        get { handle.FullName.Replace ('+', '.') }
      }

      public OverloadName : string
      {
        get { Name }
      }

      public override ToString () : string
      {
        FullName
      }

      public virtual GetTyconKind () : TyconKind
      {
        TK_ExternalNetType (handle)
      }

      public virtual GetTydecl () : Type_decl
      {
        if (handle.IsInterface)
          TD_interface ()
        else if (handle.IsEnum)
          TD_enum ()
        else
          TD_class ()
      }

      public virtual MakeSubst (parms : list <Type>) : Subst
      {
        match (parms) {
          | [] => ()
          | _ =>
            Message.error ("framework type `" + FullName +
                           "' supplied with type arguments")
        };
        SystemMap ()
      }

      public virtual FreshSubst () : Subst
      {
        SystemMap ()
      }

      public virtual SuperType (tc : Tycon) : option <list <Type>>
      {
        match (tc.GetTyconKind ()) {
          | TK_ExternalNetType (t) when t.IsAssignableFrom (handle)
          | TK_ExternalNemerleType (t) when t.IsAssignableFrom (handle) => Some ([])
          | _ => None ()
        }
      }

      public virtual SubtypingSubst (_ : Tycon) : Subst
      {
        SystemMap ()
      }

      public virtual SuperClass () : option <Tycon>
      {
        if (handle.BaseType == null)
          None ()
        else
          Some (library.TyconOfType (handle.BaseType))
      }

      public virtual GetSuperTypes () : list <Type>
      {
        def supertypes = Hashtable (30);
        def add_bt (t : Type) {
          match (t) {
            | T_app (tc, []) =>
              if (supertypes.Contains (tc.GetId ())) ()
              else {
                supertypes.Add (tc.GetId (), t);
                match (tc.SuperClass ()) {
                  | Some (tc) => add_bt (T_app (tc, []))
                  | None => ()
                }
              }
            | _ => Util.ice ()
          }
        };
        List.Iter (GetDirectSuperTypes (), add_bt);
        supertypes.Fold ([], fun (_, tc, acc) { tc :: acc })
      }

      public virtual GetDirectSuperTypes () : list <Type>
      {
        def ifaces = List.Map (List.FromArray (handle.GetInterfaces ()), 
                               library.TypeOfType);
        match (SuperClass ()) {
          | Some (r) => T_app (r, []) :: ifaces
          | None => ifaces
        }
      }

      public SameAs (tc : Tycon) : bool 
      {
        GetId () == tc.GetId ()
      }

      public override Equals (o : object) : bool
      {
        match (o) {
          | t : IMember => GetId () == t.GetId ()
          | _ => false
        }
      }

      public GetMembers () : list <IMember>
      {
        LookupMember ("")
      }
      
      public GetMembers (bindingAttr : BindingFlags) : list <IMember>
      {
        def check (x : IMember) {
          if (bindingAttr %&& BindingFlags.DeclaredOnly)
            this.SameAs (x.DeclaringType) &&
            TypeBuilder.constrain_member (x, bindingAttr)
          else
            TypeBuilder.constrain_member (x, bindingAttr)
        };
        List.Filter (GetMembers (), check)
      }

      public GetFields (bindingAttr : BindingFlags) : list <IField> 
      {
        def check (x : IMember) {
          if (TypeBuilder.constrain_member (x, bindingAttr))
            match (x.GetKind ()) {
              | MK_field => true
              | _ => false
            }
          else
            false
        };
        (List.Filter (GetMembers (bindingAttr), check) :> list <IField>)
      }

      public GetConstructors (bindingAttr : BindingFlags) : list <IMethod> 
      {
        def check (x : IMember) {
          if (TypeBuilder.constrain_member (x, bindingAttr))
            match (x.GetKind ()) {
              | MK_method (m) =>
                match (m.GetFunKind ()) {
                  | FK_ctor | FK_static_ctor => true
                  | _ => false
                }
              | _ => false
            }
          else
            false
        };
        (List.Filter (GetMembers (bindingAttr), check) :> list <IMethod>)
      }
      
      private is_internal (m : SR.MemberInfo) : bool
      {
        def x = m.MemberType;
        if (x %&& (MemberTypes.Constructor %| MemberTypes.Method)) 
        {
          def meth = m :> SR.MethodBase;
          meth.IsPrivate || meth.IsAssembly || meth.IsFamilyAndAssembly
        } 
        else if (x %&& MemberTypes.Field) 
        {
          def field = m :> SR.FieldInfo;
          field.IsPrivate || field.IsAssembly || field.IsFamilyAndAssembly
        } 
        else if (x %&& MemberTypes.Property) 
        {
          def prop = m :> SR.PropertyInfo;
          def accessors = prop.GetAccessors (true);
          def propMeth = NArray.Fold (accessors, null, fun (x : SR.MethodInfo, acc) { 
            if (x == null || x.IsPrivate || x.IsAssembly || x.IsFamilyAndAssembly) acc 
            else x
          });
          propMeth == null
        }
        else if (x %&& MemberTypes.NestedType) 
        {
          def ty = m :> System.Type;
          ty.IsNestedAssembly || ty.IsNestedPrivate || ty.IsNestedFamANDAssem
        }
        else if (x %&& MemberTypes.Event) 
        {
          def evMeth = (m :> SR.EventInfo).GetAddMethod (false);
          evMeth == null || evMeth.IsPrivate || evMeth.IsAssembly || evMeth.IsFamilyAndAssembly
        } 
        else true
      }

      protected virtual imember_of_memberinfo (m : SR.MemberInfo) : option <IMember>
      {
        def ret (x : IMember) { Some (x) };
        def x = m.MemberType;

        if (x %&& (MemberTypes.Constructor %| MemberTypes.Method))
          ret (NetMethod (library, (m :> SR.MethodBase)))
        else if (x %&& MemberTypes.Field)
          ret (FieldInfo (library, (m :> SR.FieldInfo)))
        else if (x %&& MemberTypes.Property)
          ret (NetProperty (library, (m :> SR.PropertyInfo)))
        else if (x %&& MemberTypes.Event)
          ret (NetEvent (library, (m :> SR.EventInfo)))
        else if (x %&& MemberTypes.NestedType)
          ret (library.TyconOfType ((m :> System.Type)))
        else
          None ()
      }

      private collect_members (name : string) : void
      {
        def fields_to_shadow = Hashtable ();

        assert (! queried_members.Contains (name));
        queried_members [name] = null;

        def store_by_name (m : IMember) {
          members [m.Name] =
            if (members.Contains (m.Name))
              m :: members [m.Name]
            else
              [m];
        }
        
        def add_member (m : SR.MemberInfo, acc) {
          if (! library.TyconOfType (m.DeclaringType).SameAs (this)) {
            // for some reason this happens for properties
            // Message.warning ($ "FIXME: add_member: $m to $(this) from $(m.DeclaringType)");
            acc
          } else if (is_internal (m) ||
                     (name == "" && queried_members.Contains (m.Name))) {
            acc
          } else {
            //Message.debug ($ "add_member: $m to $(this) [$(GetId ())]");
            match (imember_of_memberinfo (m)) {
              | Some (r) =>
                //Message.debug ($ "on: $(r.OverloadName)");
                fields_to_shadow [r.OverloadName] = null;
                store_by_name (r);
                r :: acc
              | None => acc
            }
          }
        }
        
        def flags = SR.BindingFlags.Public     %|
                    SR.BindingFlags.NonPublic  %|
                    SR.BindingFlags.Static     %|
                    SR.BindingFlags.Instance   %|
                    SR.BindingFlags.DeclaredOnly;

        def member_array = 
          if (name == "")
            handle.GetMembers (flags) 
          else 
            handle.GetMember (name, flags);

        def collected_now = NArray.Fold (member_array, [], add_member);

        def our_fields =
          if (name == "") {
            foreach (m : IMember in member_list)
              fields_to_shadow [m.OverloadName] = null;
            member_list + collected_now
          } else {
            member_list = collected_now + member_list;
            collected_now
          }

        def fields_from_parents =
          match (SuperClass ()) {
            | Some (sc) => sc.LookupMember (name)
            | None =>
              // make sure each and every member gets its place just once
              def uniq (lst) {
                def ht = Hashtable ();
                List.Filter (lst, fun (e : IMember) { 
                  if (ht.Contains (e.GetId ())) false
                  else { ht [e.GetId ()] = null; true }
                })
              }
              
              if (handle.IsInterface)
                // collect members from inherited interfaces
                uniq (
                  NArray.Fold (handle.GetInterfaces (), [], 
                  fun (st, acc) {
                    library.TyconOfType (st).LookupMember (name) + acc
                  }) +
                  // and from System.Object
                  InternalType.Object_tc.LookupMember (name))
              else []
          };

        def fields_from_parents = 
          List.Filter (fields_from_parents, 
                       fun (mem : IMember) {
                         !mem.IsStatic &&
                         mem.Name != ".ctor" &&
                         mem.Name != ".cctor" &&
                         ! fields_to_shadow.Contains (mem.OverloadName)
                       });

        if (name == "") {
          foreach (mem : IMember in fields_from_parents)
            unless (queried_members.Contains (mem.Name))
              store_by_name (mem);
          members [""] = List.RevAppend (our_fields, fields_from_parents);
        } else
          List.Iter (fields_from_parents, store_by_name);
      }

      public LookupMember (name : string) : list <IMember> 
      {
        match (members.Get (name)) {
          | Some (r) => r
          | None =>
            collect_members (name);
            if (members.Contains (name))
              members [name]
            else {
              members [name] = [];
              []
            }
        }
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || handle.IsNestedPublic ||
          (handle.DeclaringType != null &&
           Option.IsSome (source.SuperType (DeclaringType)) &&
           (handle.IsNestedFamily || handle.IsNestedFamORAssem))
      }

      public GetSystemType () : System.Type
      {
        handle
      }
    }
    
    private class FieldInfo : IField
    {
      protected handle : SR.FieldInfo;
      protected library : LibraryReference;
      protected id : int;
      protected mutable tt_type : Type;
      protected mutable attributes : NemerleAttributes;

      public this (lib : LibraryReference, h : SR.FieldInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        tt_type = null;
        set_attributes ();
      }

      public this (tenv : SystemMap <int, Tyvar.T>, lib : LibraryReference,
                   h : SR.FieldInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        tt_type = TyCodec.DecodeType (lib, tenv, attr_str);
        set_attributes ();
      }

      set_attributes () : void
      {
        attributes = NemerleAttributes.None;
        when (!handle.IsInitOnly) attributes |= NemerleAttributes.Mutable;
        when (handle.IsStatic)    attributes |= NemerleAttributes.Static;
       
        when (handle.IsPrivate)  attributes |= NemerleAttributes.Private;
        when (handle.IsPublic)   attributes |= NemerleAttributes.Public;
        when (handle.IsFamily)   attributes |= NemerleAttributes.Protected;
        when (handle.IsAssembly) attributes |= NemerleAttributes.Internal;
        when (handle.IsFamilyAndAssembly) attributes |=
          NemerleAttributes.Internal %| NemerleAttributes.Protected;
      }

      public DeclaringType : Tycon
      {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public override ToString () : string
      {
        handle.ToString ()
      }

      public OverloadName : string
      {
        get { Name }
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Field }
      }

      public GetFieldInfo () : SR.FieldInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        when (tt_type == null)
          tt_type = library.TypeOfType (handle.FieldType);
        tt_type
      }

      public override Equals (o : object) : bool
      {
        //Message.debug ($ "$(this).Equals($o)");
        match (o) {
          | t : IMember => 
            //Message.debug ($ "$(GetId ()) == $(t.GetId ())");
            GetId () == t.GetId ()
          | _ => false
        }
      }

      public GetKind () : MemberKind
      {
        MK_field (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }

      public IsStatic : bool
      {
        get { handle.IsStatic }
      }

      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }
      
      public IsLiteral : bool
      {
        get { handle.IsLiteral }
      }

      public GetValue () : object
      {
        assert (IsLiteral);
        handle.GetValue (null)
      }

      public GetId () : int
      {
        id
      }

      public IsMutable : bool
      {
        get { !handle.IsInitOnly }
      }

      public IsVolatile : bool
      {
        get
        {
          def modreqs = handle.GetCustomAttributes (false);

          NArray.Exists (modreqs,
                         fun (x : System.Object) {
                           (x is System.Runtime.CompilerServices.IsVolatile) ||
                           (x is Nemerle.Internal.VolatileModifier)
                         })
        }
      }
      
      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (DeclaringType)) &&
           (handle.IsFamily || handle.IsFamilyOrAssembly))
      }
    }

    class NetEvent : IEvent
    {
      protected handle : SR.EventInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected adder : NetMethod;
      protected remover : NetMethod;
      protected mutable mem_type : Type;

      public this (lib : LibraryReference, h : SR.EventInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        
        def add_method = handle.GetAddMethod ();
        def remove_method = handle.GetRemoveMethod ();

        is_static =
          (add_method != null && add_method.IsStatic) ||
          (remove_method != null && remove_method.IsStatic);

        adder = library.MethodOfMethodInfo (this, add_method);
        remover = library.MethodOfMethodInfo (this, remove_method);

        assert (adder != null);
        assert (remover != null);

        match (adder.GetMemType ()) {
          | T_fun (t, _) => mem_type = t
          | _ => assert (false)
        }
      }

      public DeclaringType : Tycon
      {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public OverloadName : string
      {
        get { Name }
      }

      public override ToString () : string
      {
        handle.ToString ()
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Event }
      }

      public GetAdder () : IMethod
      {
        adder
      }

      public GetRemover () : IMethod
      {
        remover
      }

      public GetEventInfo () : SR.EventInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public override Equals (o : object) : bool
      {
        match (o) {
          | t : IMember => GetId () == t.GetId ()
          | _ => false
        }
      }

      public GetKind () : MemberKind
      {
        MK_event (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { adder.Attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }
      
      public IsStatic : bool
      {
        get { is_static }
      }

      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }
      
      public GetId () : int
      {
        id
      }

      public CanAccess (_source : Tycon) : bool
      {
        // FIXME: this is broken... we need to check method attributes
        true
      }
    }
    
    class NetProperty : IProperty
    {
      protected handle : SR.PropertyInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected getter : NetMethod;
      protected setter : NetMethod;
      protected any_method : NetMethod;
      protected mutable mem_type : Type;
      protected overload_name : string;

      public this (lib : LibraryReference, h : SR.PropertyInfo)
      {
        id = Util.next_id ();
        library = lib;
        handle = h;
        
        def get_method = handle.GetGetMethod (true);
        def set_method = handle.GetSetMethod (true);

        getter = library.MethodOfMethodInfo (this, get_method);
        setter = library.MethodOfMethodInfo (this, set_method);

        if (getter == null)
          any_method = setter;
        else
          any_method = getter;

        assert (any_method != null);

        is_static = any_method.Attributes %&& NemerleAttributes.Static;
        
        def ret_type = library.TypeOfType (handle.PropertyType);

        def (args, ret_type) =
          if (getter != null)
            match (getter.GetMemType ()) {
              | T_fun (t, r) =>
                (Tyutil.fun_args (t), r)
              | _ => assert (false)
            }
          else if (setter != null)
            match (setter.GetMemType ()) {
              | T_fun (t, _) =>
                def (args, r) = List.DivideLast (Tyutil.fun_args (t));
                (args, r)
              | _ => assert (false)
            }
          else
            ([], ret_type);

        mem_type =
          match (args) {
            | [] => ret_type
            | [x] => T_fun (x, ret_type)
            | lst => T_fun (T_prod (lst), ret_type)
          };
          
        overload_name =
          if (args.IsEmpty ()) Name
          else $ "$(this.Name)[$args]";
      }

      public DeclaringType : Tycon
      {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public OverloadName : string
      {
        get { overload_name }
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Property }
      }

      public override ToString () : string
      {
        handle.ToString ()
      }

      public GetGetter () : IMethod
      {
        getter
      }

      public GetSetter () : IMethod
      {
        setter
      }

      public GetPropertyInfo () : SR.PropertyInfo
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public override Equals (o : object) : bool
      {
        match (o) {
          | t : IMember => GetId () == t.GetId ()
          | _ => false
        }
      }

      public GetKind () : MemberKind
      {
        MK_property (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { any_method.Attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }
      
      public IsStatic : bool
      {
        get { is_static }
      }
      
      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }

      public GetId () : int
      {
        id
      }

      public IsMutable : bool
      {
        get { handle.CanWrite }
      }

      public CanAccess (source : Tycon) : bool
      {
        any_method.CanAccess (source)
      }

      public IsIndexer : bool
      {
        get
        {
          def index_parms = handle.GetIndexParameters ();

          index_parms.Length > 0
        }
      }
    }
    
    class NetMethod : IMethod
    {
      protected handle : SR.MethodBase;
      protected library : LibraryReference;
      protected id : int;
      protected fun_header : Fun_header;
      protected attributes : NemerleAttributes;
      protected is_var_args : bool;
      protected overload_name : string;

      public this (lib : LibraryReference, h : SR.MethodBase)
      {
        library = lib;
        handle = h;
        def mkparm (p : SR.ParameterInfo) {
          def ty =
            match (library.TypeOfType (p.ParameterType)) {
              | T_ref (t) when p.IsOut => T_out (t)
              | t => t
            };
          Fun_parm (
            loc = library._location,
            name = p.Name,
            color = 0,
            ty = ty,
            decl = null,
            modifiers = Modifiers.Empty // FIXME?
          )
        };
        def ret_type =
          if (handle.Name == ".ctor" || handle.Name == ".cctor")
            T_void ()
          else
            library.TypeOfType ((handle :> SR.MethodInfo).ReturnType);
        
        def parms = handle.GetParameters ();

        when (parms.Length > 0) {
          def attrs = parms [parms.Length - 1]
                .GetCustomAttributes (SystemType.ParamArrayAttribute, false);
          is_var_args = attrs.Length > 0;
        }

        fun_header =
          Fun_header (
            loc = library._location,
            name = Name,
            ret_type = ret_type,
            parms = List.Map (List.FromArray (parms), mkparm),
            typarms = [],
            tenv = null
          );

        def parm_types = List.Map (fun_header.parms, 
                                   fun (p : Fun_parm) { p.ty });
        overload_name = $ "$(this.Name)($parm_types)";

        id = fun_header.id;

        attributes = NemerleAttributes.None;
        when (handle.IsAbstract) attributes |= NemerleAttributes.Abstract;
        when (handle.IsVirtual)  attributes |= NemerleAttributes.Virtual;
        when (handle.IsFinal)    attributes |= NemerleAttributes.Sealed;
        when (handle.IsStatic)   attributes |= NemerleAttributes.Static;
       
        when (handle.IsPrivate)  attributes |= NemerleAttributes.Private;
        when (handle.IsPublic)   attributes |= NemerleAttributes.Public;
        when (handle.IsFamily)   attributes |= NemerleAttributes.Protected;
        when (handle.IsAssembly) attributes |= NemerleAttributes.Internal;
        when (handle.IsFamilyAndAssembly) attributes |=
          NemerleAttributes.Internal %| NemerleAttributes.Protected;
      }
      
      public DeclaringType : Tycon
      {
        get {
          library.TyconOfType (handle.DeclaringType)
        }
      }
      
      public Name : string
      {
        get { handle.Name }
      }

      public MemberType : MemberTypes
      {
        get { MemberTypes.Method }
      }

      public OverloadName : string
      {
        get { overload_name }
      }

      public override ToString () : string
      {
        handle.ToString ()
      }

      public IsVarArgs : bool
      {
        get { is_var_args }
      }

      // FIXME: there should be an error here -- it's supposed to be 'override' or 'new'
      public virtual GetExternName () : option <string>
      {
        None ()
      }

      public GetMethodBase () : SR.MethodBase
      {
        handle
      }
      
      public GetHandle () : SR.MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        Tyutil.fun_type (GetHeader ())
      }

      public override Equals (o : object) : bool
      {
        match (o) {
          | t : IMember => GetId () == t.GetId ()
          | _ => false
        }
      }

      public GetKind () : MemberKind
      {
        MK_method (this)
      }

      public Location : Location
      {
        get { library._location }
      }

      public Attributes : NemerleAttributes
      {
        get { attributes }
      }

      public GetModifiers () : Modifiers
      {
        Util.ice ("GetModifiers not supported on external entities")
      }
      
      public IsStatic : bool
      {
        get { handle.IsStatic }
      }
      
      public HasBeenUsed : bool
      {
        get { true }
        set { ignore (value) }
      }

      public GetId () : int
      {
        id
      }

      public virtual GetFreshType () : Type
      {
        GetMemType ()
      }

      public GetFunKind () : Fun_kind
      {
        if (handle.DeclaringType.IsInterface)
          FK_iface_method ()
        else
          if (handle.IsConstructor)
            if (handle.IsStatic)
              FK_static_ctor ()
            else
              FK_ctor ()
          else
            if (handle.IsStatic)
              FK_function ()
            else
              FK_bound_method ([])
      }

      public GetConstructorInfo () : SR.ConstructorInfo
      {
        assert (handle.IsConstructor);
        (handle :> SR.ConstructorInfo)
      }

      public GetMethodInfo () : SR.MethodInfo
      {
        assert (!handle.IsConstructor);
        (handle :> SR.MethodInfo)
      }

      public GetHeader () : Fun_header
      {
        fun_header
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.IsSome (source.SuperType (DeclaringType)) &&
           (handle.IsFamily || handle.IsFamilyOrAssembly))
      }
    }
   
    /* -----------------------------------------------------------------
     * External Nemerle types
     * ----------------------------------------------------------------- 
     */
     
    private static get_string_attribute (attr_name : string, meth_name : string,
                                         attributes : array <object>) : string
    {
      def loop (i) {
        if (i >= attributes.Length) null
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == attr_name) {
            def meth = attr_ty.GetMethod (meth_name);
            (meth.Invoke (attr, null) :> string)
          } else loop (i + 1)
        }
      };
      loop (0)
    }

    private static get_encoded_type (attributes : array <object>) : string
    {
      get_string_attribute ("Nemerle.Internal.TypeAttribute", "GetEncodedType", attributes)
    }

    private static get_variant_options (attributes : array <object>) : list <string>
    {
      def str = get_string_attribute ("Nemerle.Internal.VariantAttribute", 
                                      "GetVariantOptions", attributes);
      NString.Split (str, array [','])
    }

    private static has_attribute (name : string, attributes : array <object>) : bool
    {
      def loop (i) {
        if (i >= attributes.Length) false
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == name) true
          else loop (i + 1)
        }
      };
      loop (0)
    }
    
    private class TypeInfo : NetType
    {
      internal tenv : SystemMap <int, Tyvar.T>;
      typarms : list <Tyvar.T>;
      direct_supertypes : list <Type>;
      supertypes : list <Type>;
      supertype_map : SystemMap <int, Type>;
      tydecl : Type_decl;
      constant_object : option <IField>;
      
      public this (lib : LibraryReference, h : System.Type)
      {
        base (lib, h);
        
        def tenv =
          if (handle.DeclaringType != null)
            (library.TyconOfType (handle.DeclaringType) :> TypeInfo).tenv
          else SystemMap ();

        def type_attrs = h.GetCustomAttributes (false);

        def attr_str = get_encoded_type (type_attrs); 
        def (typarms, tenv, dst, st) = TyCodec.DecodeTypeBuilder (lib, tenv, attr_str);

        this.typarms = typarms;
        this.tenv = tenv;
        direct_supertypes = dst;
        supertypes = st;

        def add (t, m : SystemMap <int, Type>) {
          match (t) {
            | T_app (tc, _) => m.Add (tc.GetId (), t)
            | _ => Util.ice ("invalid supertype")
          }
        };

        supertype_map = List.FoldLeft (supertypes, SystemMap (), add);
        constant_object = None ();

        if (has_attribute ("Nemerle.Internal.VariantAttribute", type_attrs)) {
          def names = get_variant_options (type_attrs);
          def get_opt (name : string) {
            match (GlobalEnv.LookupExactType (NString.Split (name, array ['.', '+']))) {
              | Some (tc) => tc
              | None => Util.ice ("cannot find variant option named " + name)
            }
          };
          tydecl = TD_variant (List.Map (names, get_opt))
        } else if (has_attribute ("Nemerle.Internal.VariantOptionAttribute", type_attrs)) {
          tydecl = TD_variant_option ()
        } else if (has_attribute ("Nemerle.Internal.ConstantVariantOptionAttribute",
                                  type_attrs)) {
          tydecl = TD_variant_option ();
          match (LookupMember ("_N_constant_object")) {
            | [fld] =>
              constant_object = Some ((fld :> IField))
            | _ => Util.ice ("cannot find _N_constant_object")
          }
        } else if (has_attribute ("Nemerle.Internal.TypeAliasAttribute", type_attrs)) {
          def type_string = 
            get_string_attribute ("Nemerle.Internal.TypeAliasAttribute",
                                  "GetAliasedType", type_attrs);
          tydecl = TD_alias (TyCodec.DecodeType (lib, tenv, type_string))
        } else if (handle.IsInterface)
          tydecl = TD_interface ()
        else if (handle.IsEnum)
          tydecl = TD_enum ()
        else
          tydecl = TD_class ();
      }

      mutable self_type : Type;

      public override GetMemType () : Type
      {
        when (self_type == null)
          self_type = T_app (this, List.Map (typarms, fun (tv) { T_var (tv) }));
        self_type
      }

      public override GetTyconKind () : TyconKind
      {
        TK_ExternalNemerleType (handle)
      }

      public override GetTydecl () : Type_decl
      {
        tydecl
      }

      public override GetConstantObject () : option <IField>
      {
        constant_object
      }

      public override MakeSubst (parms : list <Type>) : Subst
      {
        TypeBuilder.ConstructSubst (this, typarms, parms)
      }

      public override FreshSubst () : Subst
      {
        Tyvar.fresh_subst (typarms)
      }

      public override SuperType (tc : Tycon) : option <list <Type>>
      {
        match (supertype_map.Find (tc.GetId ())) {
          | Some (T_app (_, args)) => Some (args)
          | Some => Util.ice ()
          | None when tc.SameAs (this) =>
            match (GetMemType ()) {
              | T_app (_, parms) => Some (parms)
              | _ => assert (false)
            }
          | None when tc.Equals (InternalType.Object_tc) => Some ([])
          | None => None ()
        }
      }

      public override SubtypingSubst (tc : Tycon) : Subst
      {
        if (tc.GetId () == GetId ())
          SystemMap () // current type, no substitution
        else
          tc.MakeSubst (Option.UnSome (SuperType (tc)));
      }

      public override GetSuperTypes () : list <Type>
      {
        supertypes
      }

      public override GetDirectSuperTypes () : list <Type>
      {
        direct_supertypes
      }

      protected override imember_of_memberinfo (m : SR.MemberInfo) : option <IMember>
      {
        def ty = m.MemberType;
        def is_nem (x : SR.MemberInfo) {
          has_attribute ("Nemerle.Internal.TypeAttribute", x.GetCustomAttributes (false))
        };
        def ret (x : IMember) { Some (x) };
        
        if (ty %&& MemberTypes.Constructor || ty %&& MemberTypes.Method) {
          if (is_nem (m))
            ret (MethodInfo (tenv, library, (m :> SR.MethodBase)))
          else
            ret (NetMethod (library, (m :> SR.MethodBase)))
        } else if (ty %&& (MemberTypes.Field)) {
          if (is_nem (m))
            ret (FieldInfo (tenv, library, (m :> SR.FieldInfo)))
          else
            ret (FieldInfo (library, (m :> SR.FieldInfo)))
        } else if (ty %&& MemberTypes.Property)
          ret (NetProperty (library, (m :> SR.PropertyInfo)))
        else if (ty %&& MemberTypes.Event)
          ret (NetEvent (library, (m :> SR.EventInfo)))
        else if (ty %&& MemberTypes.NestedType)
          ret (library.TyconOfType ((m :> System.Type)))
        else
          Util.ice ("unknown object in nemerle type " + m.Name + " in " + FullName)
      }
    }
    
    class MethodInfo : NetMethod
    {
      public this (tenv : SystemMap <int, Tyvar.T>, lib : LibraryReference,
                   h : SR.MethodBase)
      {
        base (lib, h);
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        TyCodec.FixupFunctionHeader (lib, tenv, fun_header, attr_str);
      }
      
      public override GetExternName () : option <string>
      {
        None ()
      }

      public override GetFreshType () : Type
      {
        GetMemType () /- Tyvar.fresh_subst (fun_header.typarms)
      }
    }
  }
} /* namespace */
