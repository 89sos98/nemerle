/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using System.Reflection;

namespace Nemerle.Compiler {

class CG_method
{
  public mutable name : string;
  public mutable parms : list [CG_val];
  public mutable ret_type : System.Type;
  public mutable body : CExpr;
  public mutable implemented_methods : list [IMethod];
  public mutable modifiers : NemerleAttributes;

  public mutable lambda_ctor : Emit.ConstructorBuilder;
  public mutable lambda_type_builder : Emit.TypeBuilder;
  public mutable closure_type : System.Type;
  public mutable closure_pointers : SystemMap [int, FieldInfo];

  public mutable method_builder : Emit.MethodBuilder;
  public mutable constructor_builder : Emit.ConstructorBuilder;

  public this () { }  
}
  
class CG_parm_info
{
  public parm_kind : Typedtree.ParmKind;
  public modifiers : Modifiers;
  public mutable builder : Emit.ParameterBuilder;
  public this (parm_kind : Typedtree.ParmKind, modifiers : Modifiers)
  {
    this.parm_kind = parm_kind;
    this.modifiers = modifiers;
  }
}

class CG_val : Located
{
  public mutable name : string;
  public mutable ty : System.Type;
  public mutable val : CExpr;

  public mutable local_slot : option [System.Reflection.Emit.LocalBuilder];
  public mutable parm_index : option [int];

  public mutable parm_info : CG_parm_info;

  public this (loc : Location, name : string, ty : System.Type, val : CExpr) 
  { 
    base (loc);
    this.name = name;
    this.ty = ty;
    this.val = val;
    this.local_slot = None ();
    this.parm_index = None ();
    this.parm_info = null;
  }
}

[System.Flags]
enum CgExprFlags {
  | None           = 0x0000
  | NeedAddress    = 0x0001
  | WishAddress    = 0x0002
  | NeedLValue     = 0x0004
  | Throws         = 0x0008
  | WishGranted    = 0x0010
}
 
/** A node of compiled tree, intermediate representation between TypedTree and IL */ 
variant CExpr : Located
{ 
  | Ref               { decl : CG_val; }
  | GlobalRef         { decl : System.Reflection.MemberInfo; } // not ctor
  | VolatileGlobalRef { decl : System.Reflection.MemberInfo; } // not ctor    
  | ConstructorRef    { ctor : System.Reflection.ConstructorInfo; }
  | FieldRef          { obj : CExpr; fld : System.Reflection.FieldInfo; }
  | VolatileFieldRef  { obj : CExpr; fld : System.Reflection.FieldInfo; }
  | MethodRef         { obj : CExpr; meth : System.Reflection.MethodInfo; notvirtual : bool; }
  | InitValueType     { value_type : System.Type; }
  | MethodAddress     { meth : System.Reflection.MethodInfo; } // ldftn
  | Ignore            { expr : CExpr; } // pop
  | Opcode            { name : string; } // like +, == etc
  | Call              { func : CExpr; parms : list [CExpr]; }
  | TailCall          { func : CExpr; parms : list [CExpr]; }
  | SelfTailCall      { parms : list [CExpr]; }
  | Assign            { target : CExpr; source : CExpr; }
  | Define            { name : CG_val; body : CExpr; }
  | HasType           { expr : CExpr; test_type : System.Type; }
  | NotNull           { expr : CExpr; }
  | Throw             { exn : CExpr; }
  | If                { cond : CExpr; mutable e_then : CExpr; mutable e_else : CExpr; }
  | TryWith           { mutable body : CExpr; exn : CG_val; mutable handler : CExpr; }
  | TryFinally        { mutable body : CExpr; mutable handler : CExpr; }
  | Literal           { val : Nemerle.Compiler.Literal; }
  | This
  | Cast              { expr : CExpr; target_type : System.Type; is_checked : bool; }
  | Sequence          { body : list [CExpr]; }
  | Array             { element_type : System.Type; initializers : list [CExpr]; dimensions : list [CExpr]; }
  | ArrayAccess       { obj : CExpr; args : list [CExpr]; }
  | TypeOf            { target_type : System.Type; }
  | Address           { expr : CExpr; }          // for ref/out params
  | Indirect          { expr : CExpr; }      // like * in C, for ref/out

  | Loop              { mutable body : CExpr; mutable label : option [Emit.Label]; }
  | ContinueLoop      { which_one : Loop; }
  | MultipleAssign    { assigns : list [CG_val * CExpr]; }

  /** reference to a base class constructor */
  | BaseCtorRef { base_ctor : System.Reflection.ConstructorInfo; }
    
  /** 
   * Creates a jump table. The 'indexing_expr' is evaluated to an integer 
   * in range [0 .. List.Length (branches) - 1], then the corresponding
   * branch (or the default expression) gets calculated.
   */
  | Switch { 
      indexing_expr : CExpr; 
      mutable default : option [CExpr];
      mutable cases : list [int * CExpr]; 
    }
   
  /** denotes an empty program */
  | Nop

  /** this is a cache for the type of the expression */
  public mutable ty : System.Type;
  public mutable flags : CgExprFlags;

  public this (ty : System.Type)
  {
    this.ty = ty;
  }

  public this () { }

  /** Copy flags and location from given expression. Return self. */
  public WithCtx (e : CExpr) : CExpr
  {
    flags = e.flags;
    loc = e.loc;
    this
  }
  
  public SystemType : System.Type
  {
    get {
      if (ty != null) ty
      else {
      def ty =
        match (this) {
          | CExpr.Ref (d)                 => d.ty
          | CExpr.GlobalRef (obj)
          | CExpr.VolatileGlobalRef (obj) =>
            if (obj.MemberType %&& MemberTypes.Field)
              (obj :> FieldInfo).FieldType
            else if (obj.MemberType %&& MemberTypes.Property)
              (obj :> PropertyInfo).PropertyType
            else
              Util.ice ("strange global ref")
              
          | CExpr.FieldRef (_, f)
          | CExpr.VolatileFieldRef (_, f) => f.FieldType

          | CExpr.MethodAddress => SystemType.IntPtr
          
          | CExpr.TailCall (CExpr.GlobalRef (m), _)
          | CExpr.Call (CExpr.GlobalRef (m), _) => (m :> MethodInfo).ReturnType
          
          | CExpr.TailCall (CExpr.MethodRef (_, m, _), _)
          | CExpr.Call (CExpr.MethodRef (_, m, _), _) => m.ReturnType
          
          | CExpr.TailCall (CExpr.ConstructorRef (c), _)
          | CExpr.Call (CExpr.ConstructorRef (c), _) => c.DeclaringType
          
          | CExpr.TailCall (CExpr.BaseCtorRef, _)
          | CExpr.Call (CExpr.BaseCtorRef, _) => SystemType.Void

          | CExpr.TypeOf => SystemType.Type

          | CExpr.Address (expr) => CompileTypedTree.make_ref_type (expr.SystemType)

          | CExpr.Indirect (expr) =>
            def ty = expr.SystemType;
            def ety = ty.GetElementType ();
            assert (ty.IsByRef && ety != null);
            ety

          | CExpr.Loop (expr, _) => expr.SystemType
          
          | CExpr.SelfTailCall
          | CExpr.TailCall
          | CExpr.Call => Util.ice ("strange call")
          
          | CExpr.MultipleAssign
          | CExpr.Assign => SystemType.Void
          | CExpr.Define (_, b) => b.SystemType
          | CExpr.HasType => SystemType.Boolean
          | CExpr.NotNull => SystemType.Void
          | CExpr.ContinueLoop
          | CExpr.Throw => SystemType.Void
          | CExpr.If (_, _, _) => Util.ice ("ought to be cached")
          | CExpr.TryWith (e, _, _) => e.SystemType
          | CExpr.TryFinally (e, _) => e.SystemType
          | CExpr.Literal (l) => l.GetSystemType ()
          | CExpr.This => SystemType.Object // cheat a bit 
          | CExpr.Cast (_, t, _) => t
          | CExpr.Sequence (b) => List.Last (b).SystemType
          | CExpr.Switch (_, _, (_, expr) :: _) => expr.SystemType
              
          | CExpr.InitValueType (t) => t

          | CExpr.Array 
          | CExpr.ArrayAccess (_, _) => Util.ice ("should be cached")
          | CExpr.Opcode => Util.ice ("opcode")
          | CExpr.Ignore => SystemType.Void

          // can't tell
          | CExpr.Nop => Util.ice ("none")

          // these are supported only as part of call
          | CExpr.ConstructorRef => Util.ice ("ctorref")
          | CExpr.MethodRef => Util.ice ("methodref")
          | CExpr.BaseCtorRef => Util.ice ("basectorref")
          
          | CExpr.Switch => Util.ice ("switch without branches")
        };
      this.ty = ty;
      ty
      }
    }
  }
 
  public override ToString () : string {
    CodeGenerator.pretty_print (this);
  }
 
  public static TrueLiteral : CExpr = CExpr.Literal (typeof (bool), Nemerle.Compiler.Literal.Bool (true));
  public static FalseLiteral : CExpr = CExpr.Literal (typeof (bool), Nemerle.Compiler.Literal.Bool (false));
}
} // end ns
