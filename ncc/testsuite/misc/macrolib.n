
using Nemerle.Collections;
using Nemerle.Compiler;
using System;

macro forp (i, n : int, m : int, body)
syntax ("forpermutation", "(", i, "in", n, "to", m, ")", body)
{
  def a = array (m - n + 1);
  for (mutable j <- 0; j < m - n + 1; j <- j + 1)
    a[j] <- j + n;
  mutable p <- [];
  def r = System.Random ();
  for (mutable k <- m - n; k >= 0; k <- k - 1) {
    def rand = r.Next (k + 1);
    p <- <[ $(a[rand] : int) ]> :: p;
    a[rand] <-> a[k];
  };
  <[
    def p = array [..$p];
    for (mutable j <- 0; j < $(m - n + 1 : int); j <- j + 1) {
      $i <- p[j];
      $body
    }
  ]>
}

namespace A {
  macro gg (a)
  syntax ("ggg", a) { a }
}

macro ala()
{
  def c = Nemerle.Macros.ImplicitCTX ().env.DefineClass([Mod_public ()], "haha", []);
  c.DefineMember(<[ field: x : int; ]>);
  c.DefineMember(<[ method: public this(){}]>);
  <[ Console.WriteLine ("proba") ]>;
}

public interface ISerializable {
  Serialize () : void;
}

postscan macro Serializable (t : TypeDecl)
{
//  def t = (t :> Tyinfo);
  t.pt_tydecl.t_extends <- List.Append (t.pt_tydecl.t_extends,
                                        [<[ type: ISerializable ]> ]);
}

postadd macro Serializable (t : TypeDecl)
{
//  def t = (t :> Tyinfo);
  def fields =
    List.Filter (t.GetFields (), fun (m : IMember) {
      m.GetDeclaringTycon ().SameAs (t)
    });
    
  mutable serializers <- [];
  List.Iter (fields, fun (x : IField) {
    def tc = Tyutil.GetTypeTycon (x.GetMemType ());
    if (tc != null)
      if (tc.IsValueType ())
        serializers <- <[
                         Nemerle.IO.printf ("<%s>", $(x.GetName () : string));
                         System.Console.Write ($(x.GetName () : dyn));
                         Nemerle.IO.printf ("</%s>\n", $(x.GetName () : string));
                       ]>
                       :: serializers
      else
        if (Tyutil.subtypes (x.GetMemType (), <[ ttype: ISerializable ]>))
          serializers <- <[
                           Nemerle.IO.printf ("<%s>\n", $(x.GetName () : string));          
                           if ($(x.GetName () : dyn) != null)
                             $(x.GetName () : dyn).Serialize ()
                           else
                             Nemerle.IO.printf ("<null/>\n");
                           Nemerle.IO.printf ("</%s>\n", $(x.GetName () : string));
                         ]> :: serializers
        else
          Message.fatal_error ("field `" + x.GetName () + "' cannot be serialized")
    else
      Message.fatal_error ("field `" + x.GetName () + "' cannot be serialized")
  });
  t.DefineMember (<[ method: public Serialize () : void implements ISerializable.Serialize {
    .. $serializers
  } ]>)
}
