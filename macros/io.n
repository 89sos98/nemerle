/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle; 
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Utility;

using System;
using System.Text;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.IO
{
  using Nemerle.IO.Helper;
  
  macro printf (format : string, params parms : array [expr]) 
  {
    def (evals, refs) = make_evaluation_exprs (parse_format (format), parms);
    def seq = List.Append (evals, List.Map (refs, fun (x) { 
      <[ Console.Write ($x) ]> 
    }));
    <[ {.. $seq } ]>
  }

  macro sprintf (format : string, params parms : array [expr])
  {
    when (parms.Length == 0)
      Message.Warning ("sprintf whith no parametrs");
    
    def format = parse_format (format);
    def (evals, refs) = make_evaluation_exprs (format, parms);
    def exprs = match (refs)
    {
        | []     => Message.Warning ("empty format"); [<[ "" ]>]
      | [expr] => 
        if (format.Head.NeedsNullCheck)
          evals + [<[ if ($expr == null) string.Empty else $expr.ToString () ]>]
        else 
          evals + [<[ $expr.ToString () ]>]
      | _ :: _ => evals + [<[ string.Concat (..$refs) ]>]
    }
    <[ { ..$exprs } ]>
  }

  /** Writes output to given System.IO.TextWriter */
  macro fprintf (writer, format : string, params parms : array [expr])
  {
    def (evals, refs) = make_evaluation_exprs (parse_format (format), parms);
    def seq = List.Append (evals, List.Map (refs, fun (x) { 
      <[ writer_v.Write ($x) ]> 
    }));
    <[ 
      def writer_v = $writer : IO.TextWriter;
      {.. $seq } 
    ]>
  }

  macro scanf (format : string, params parms : array [expr]) 
  {
    def seq = make_scan_expressions (format, parms, <[ stdin ]>);
    <[
      def stdin = Console.In; 
      ConsumeWhiteSpace (stdin);
      {.. $seq } 
    ]>
  }

  macro fscanf (stream, format : string, params parms : array [expr]) 
  {
    def seq = make_scan_expressions (format, parms, <[ stream_cached ]>);
    <[
      def stream_cached = $stream; 
      ConsumeWhiteSpace (stream_cached);
      {.. $seq } 
    ]>
  }

  macro sscanf (str, format : string, params parms : array [expr]) 
  {
    def seq = make_scan_expressions (format, parms, <[ stream_cached ]>);
    <[
      def stream_cached = IO.StringReader ($str); 
      ConsumeWhiteSpace (stream_cached);
      {.. $seq } 
    ]>
  }

  /** If string literal is supplied, then prints it to System.Console, replacing all
      occurences of $id with id.ToString () invocation
      If any other expression is supplied, it is equivalent to System.Console.Write 
  */
  macro print (value)
  {
    match (value) {
      | <[ $(str : string) ]> =>
        def seq = List.RevMap (make_splice_distribution (str, Macros.ImplicitCTX().Env), fun (x) {
          <[ Console.Write ($x) ]> 
        });
        <[ {.. $seq } ]>

      | _ =>
        <[ Console.Write ($value) ]>       
    }
  }

  macro sprint (str : string)
  {
    if (string.IsNullOrEmpty (str))
    {
      Message.Warning ("empty spliced string");
      <[ string.Empty ]>
    }
    else
    {
      def seq = make_splice_distribution (str, Macros.ImplicitCTX().Env).Rev ();

      match (seq)
      {
        | [PT.PExpr.Literal as lit] =>
          Message.Warning ($"spliced string without splices: '$str'");
          lit

        | _ => <[ string.Concat (..$seq) ]>
      }
    }
  }

  /** Writes text to given System.IO.TextWriter */
  macro fprint (writer, str : string)
  {
    def seq = List.RevMap (make_splice_distribution (str, Macros.ImplicitCTX().Env), fun (x) {
      <[ writer_v.Write ($x) ]> 
    });
    <[ def writer_v = $writer : IO.TextWriter; {.. $seq }; ]>
  }

  // module internal to this assembly used for compile time analysis of string formatters, etc.
  internal module Helper {
    public variant FormatToken {
      | Text { body : string; }
      | Number { unsigned : bool; longformat : bool; }
      | NumberFloat { longformat : bool; }
      | Str
      | Chr
      
      public NeedsNullCheck : bool {
        get { 
          match (this) {
            | Text | Str => true
            | Number | NumberFloat | Chr => false
          }    
        }   
      }
    }

    /// parse printf-style formatting string
    /// http://www.gnu.org/software/libc/manual/html_node/Formatted-Output.html#Formatted%20Output
    public parse_format (form : string) : list [FormatToken]
    {
      def buf = StringBuilder ();
      mutable result = [];
      mutable i = 0;
      def n = form.Length;
  /*    
      def parse_percent () : FormatToken {
        match (form [i]) {
          |

        }
       };
  */
      def append_text () {
        match (result) {
          | FormatToken.Text (t) :: rest =>
              result = FormatToken.Text (t + buf.ToString ()) :: rest
          | _ =>
              result = FormatToken.Text (buf.ToString ()) :: result
        }
        ignore (buf.Remove (0, buf.Length));
      };

      while (i < n) { 
        match (form[i]) {
          | '%' =>
            // % occured - first, dump text from buffer
            when ( buf.Length > 0 ) append_text ();

            mutable longform = false;

            def next_char () {
              // now analyze next character
              ++i;

              if ( i < n ) {
                match (form[i]) {
                  | 'd' | 'i' => result = FormatToken.Number (false, longform) :: result
                  | 'u' => result = FormatToken.Number (true, longform) :: result
                  | 'f' => result = FormatToken.NumberFloat (longform) :: result
                  | 's' => result = FormatToken.Str () :: result
                  | 'c' => result = FormatToken.Chr () :: result
                  | '%' => ignore (buf.Append ('%'))
                  | 'l' => 
                    if (longform) 
                      Message.Error ("`l' in printf-format specified twice")
                    else {
                      longform = true; next_char ();
                    }
                  | _ => 
                    Message.Error ("Unsupported formatting sequence after % character")
                }
              }
              else
                Message.Error ("Unexpected end of format after % character")
            }
            next_char ();

          | c => ignore (buf.Append (c))
        };
        ++i;
      };

      when (buf.Length > 0) append_text ();

      // the result is reversed, but function using it will reverse it again
      result
    }

    public make_evaluation_exprs (toks : list [FormatToken], parms : array [PT.PExpr]) 
    : list [PT.PExpr] * list [PT.PExpr]
    {
      def make_expressions (toks, i, acc_eval, acc_ref) {
        def continue (x, xs) {
          def sym = Macros.NewSymbol ();
          make_expressions (xs, i - 1, <[ def $(sym : name) = $x ]> :: acc_eval,
                            <[ $(sym : name) ]> :: acc_ref)
        }

        match (toks) {
          | [] when i == 0 => (acc_eval, acc_ref)
          | FormatToken.Text (t) :: xs => 
            make_expressions (xs, i, acc_eval, <[ $(t : string) ]> :: acc_ref)

          | _ when i == 0 =>
            Message.Error ("not enough arguments for printf macro");
            (acc_eval, acc_ref)

          | FormatToken.Number (false, false) :: xs => continue (<[ $(parms[i - 1]) : int   ]>, xs)
          | FormatToken.Number (true,  false) :: xs => continue (<[ $(parms[i - 1]) : uint  ]>, xs)
          | FormatToken.Number (false, true)  :: xs => continue (<[ $(parms[i - 1]) : long  ]>, xs)
          | FormatToken.Number (true,  true)  :: xs => continue (<[ $(parms[i - 1]) : ulong ]>, xs)

          | FormatToken.NumberFloat (false) :: xs =>
            continue (<[ Convert.ToString (($(parms[i - 1]) : float),
                           Globalization.NumberFormatInfo.InvariantInfo) ]>, xs)
          | FormatToken.NumberFloat (true) :: xs =>
            continue (<[ Convert.ToString (($(parms[i - 1]) : double),
                           Globalization.NumberFormatInfo.InvariantInfo) ]>, xs)

          | FormatToken.Str :: xs => continue (<[ $(parms[i - 1]) : string ]>, xs)
          | FormatToken.Chr :: xs => continue (<[ $(parms[i - 1]) : char   ]>, xs)

          | [] => 
            Message.Error ("too many arguments for printf macro");
            (acc_eval, acc_ref)
        }
      };

      make_expressions (toks, parms.Length, [], []);
    }


    public make_scan_expressions (format : string, parms : array [PT.PExpr], 
                           stream : PT.PExpr) : list [PT.PExpr] {
      def iter_through (toks, i, acc) {                        
        match ((toks, i)) {
          | ([], 0) => acc
          | (FormatToken.Text (t) :: xs, _) => 
            iter_through (xs, i, <[ 
              CheckInput ($(t : string), $stream)
            ]> :: acc)

          | (_, 0) =>
            Message.Error ("not enough arguments for scanf-style macro");
            acc

          | (FormatToken.Number (false, false) :: xs, _) =>
            iter_through (xs, i - 1, 
              <[ $(parms[i - 1]) = Convert.ToInt32 (ReadIntDigits ($stream)) ]> :: acc)

          | (FormatToken.Number (true, false) :: xs, _) =>
            iter_through (xs, i - 1, 
              <[ $(parms[i - 1]) = Convert.ToUInt32 (ReadIntDigits ($stream)) ]> :: acc)

          | (FormatToken.Number (false, true) :: xs, _) =>
            iter_through (xs, i - 1, 
              <[ $(parms[i - 1]) = Convert.ToInt64 (ReadIntDigits ($stream)) ]> :: acc)

          | (FormatToken.Number (true, true) :: xs, _) =>
            iter_through (xs, i - 1, 
              <[ $(parms[i - 1]) = Convert.ToUInt64 (ReadIntDigits ($stream)) ]> :: acc)

          | (FormatToken.NumberFloat :: _, _) =>
            Message.FatalError ("scaning floats not supported")

          | (FormatToken.Str :: xs, _) =>
            iter_through (xs, i - 1, 
              <[ $(parms[i - 1]) = ReadString ($stream) ]> :: acc)

          | (FormatToken.Chr :: xs, _) =>
            iter_through (xs, i - 1, 
              <[ $(parms[i - 1]) = Convert.ToChar ($stream.Read ()) ]> :: acc)

          | ([], _) =>
            Message.Error ("too many arguments for scanf macro");
            acc
        }
      };
      iter_through (parse_format (format), parms.Length, []);
    }

    /** for $(...) and ..$(...) expressions:
        - first evaluate expressions
        - store intermediate results in variables
        - return list of evaluators and reference variables in reverse order
     */
    public make_splice_distribution (str : string, env : GlobalEnv) : list [PT.PExpr]
    {
      def makeEllipsisSplaceExpr(env : GlobalEnv, expr : string, isComplexExpr : bool) : PT.PExpr
      {
        if (isComplexExpr)
        {
          env.Manager.MacroColors.PushUseSiteColor ();
          try
          {
            def pExpr = MainParser.ParseExpr (env, expr);
            def makeSeqExpr(seqExpr, sepExpr, cnvFuncExpr)
            {
              <[ string.Join($sepExpr, NCollectionsUtils.MapToArray($seqExpr, $cnvFuncExpr)) ]>
            }
            match (pExpr)
            {
              | <[ $seqExpr; $sepExpr; $cnvFuncExpr; ]> => makeSeqExpr(seqExpr, sepExpr, cnvFuncExpr)
              | <[ $seqExpr; $sepExpr; ]> => makeSeqExpr(seqExpr, sepExpr, <[ Convert.ToString(_) ]>)
              | _ => makeSeqExpr(pExpr, <[ ", " ]>, <[ Convert.ToString(_) ]>)
            }
          }
          finally { env.Manager.MacroColors.PopColor (); }
        } else if (expr == "this")
             <[ string.Join(", ", NCollectionsUtils.MapToArray(this,              Convert.ToString(_))) ]>
        else <[ string.Join(", ", NCollectionsUtils.MapToArray($(expr : usesite), Convert.ToString(_))) ]>;
      }      
      
      def makeSplaceExpr(env : GlobalEnv, expr : string, isComplexExpr : bool) : PT.PExpr
      {
        if (isComplexExpr)
        {
          env.Manager.MacroColors.PushUseSiteColor ();
          try
          {
            def pExpr = MainParser.ParseExpr (env, expr);
            <[ Convert.ToString ($pExpr) ]>
          }
          finally { env.Manager.MacroColors.PopColor (); }
        } else if (expr == "this") <[ Convert.ToString (this) ]>
        else                       <[ Convert.ToString ($(expr : usesite)) ]>;
      }
      
      make_splice_distribution (str, env, makeSplaceExpr, makeEllipsisSplaceExpr)
    }

    public make_splice_distribution (
      str                    : string,
      _env                   : GlobalEnv,
      makeSplaceExpr         : GlobalEnv * string * bool -> PT.PExpr, // env * strExpr * isComplexExpr
      makeEllipsisSplaceExpr : GlobalEnv * string * bool -> PT.PExpr  // env * strExpr * isComplexExpr
    )
      : list [PT.PExpr]
    {
      mutable seen_non_alnum = false;
      
      def find_end (balance, idx) {
        when (idx >= str.Length)
          Message.FatalError ("runaway $(...) in format string");

        def ch = str[idx];
        seen_non_alnum = seen_non_alnum || !(System.Char.IsLetterOrDigit (ch) || ch == '_');
        match (ch) {
          | ')' when balance == 1 => idx
          | ')' => find_end (balance - 1, idx + 1)
          | '(' => find_end (balance + 1, idx + 1)
          | _ => find_end (balance, idx + 1)
        }
      }

      def find_end_normal (idx) {
        if (idx >= str.Length) idx
        else
          match (str[idx]) {
            | '_' 
            | ch when System.Char.IsLetterOrDigit (ch) => find_end_normal (idx + 1)
            | _ => idx
          }
      }
      
      def indexOfDollar(idx)
      {
        def str = str;
        if (idx >= str.Length) -1
        else if (char.IsWhiteSpace(str[idx])) indexOfDollar(idx + 1)
        else if (str[idx] == '$') idx
        else -1
      }

      mutable nestLevel = 0;

      def loop (res, idx)
      {
        def str = str;
        nestLevel++;
        Diagnostics.Trace.Assert(nestLevel < 200);

        if (idx < 0 || idx >= str.Length)
          res
        else if (str[idx] == '.') // try recognize pattern '..$x'
        {
          if (idx + 3 < str.Length && str[idx + 1] == '.' && indexOfDollar(idx + 2) >= 0)
            parceSpliceEx(res, indexOfDollar(idx + 2), false);  // found pattern '..$'
          else
            loop (<[$("." : string)]> :: res, idx + 1)
        }
        else if (str[idx] == '$')
          parceSpliceEx(res, idx, true)
        else
        {
          def str = str;
          def get(index) { if (index < 0 || index >= str.Length) '\0' else str[index] }
          def getElipseIndex(index)
          { // If '..' prefix exists return it index. Otherwise return initial index.
            def ch = get(index - 1);
            
            if (char.IsWhiteSpace(ch)) getElipseIndex(index - 1)
            else if (get(index - 1) == '.' && get(index - 2) == '.') index - 2
            else -1
          }
          def nextIdx   = str.IndexOf('$', idx);
          def elipseIdx = getElipseIndex(nextIdx);
          def nextIdx   = if (elipseIdx >= 0) elipseIdx else nextIdx;
          def next_str = if (nextIdx == -1) str.Substring (idx)
                         else str.Substring (idx, nextIdx - idx);
          loop (<[ $(next_str : string) ]> :: res, nextIdx)
        }
      }
      and parceSpliceEx(res, idx, isSimple)
      {
        def str = str;

        when (idx + 1 >= str.Length)
        {
          //Diagnostics.Trace.Assert(false);
          Message.Error ("lone `$' at the end of the format string");
          Nemerle.Imperative.Return ([<[ "$" ]>]);
        }
          
        def nextIndex = idx + 1;
          
        if (str[nextIndex] == '(')
        {
          def end = find_end (1, idx + 2);
          def expr = str.Substring (idx + 2, end - idx - 2);
          def isComplexExpr = expr == "" || expr == "_" || seen_non_alnum || char.IsDigit(expr[0]);
          def expr = if (isSimple) makeSplaceExpr(_env, expr, isComplexExpr) 
                     else  makeEllipsisSplaceExpr(_env, expr, isComplexExpr);
          loop (expr :: res, end + 1)
        }
        else if (str[nextIndex] == '$')
          loop (<[$("$" : string)]> :: res, idx + 2)
        else
        {
          def end = find_end_normal (nextIndex);
          def variable_name = str.Substring (nextIndex, end - idx - 1);
          
          if (variable_name == "")
          {
            Message.Warning ("expected variable name or expression enclosed with (..) after $ in splice string");
            loop (<[$("$" : string)]> :: res, nextIndex)
          }
          else
          {
            def expr = if (isSimple) makeSplaceExpr(_env, variable_name, false) 
                       else  makeEllipsisSplaceExpr(_env, variable_name, false);
            loop (expr :: res, end)
          }
        }
      }

      loop ([], 0)
    }
  }
}
