/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler {


module TyCodec 
{

  variant Term
  {
    | App { name : string; args : list <Term>; }
  }
  

  ParseTerm (s : string) : Term
  {
    def get_name (pos) {
      def idx = s.IndexOf ('(', pos);
      assert (idx != -1);
      (idx + 1, s.Substring (pos, idx - pos))
    };
    
    def maybe_get (pos) {
      if (s[pos] == ')') (pos + 1, None ())
      else {
        def (pos, name) = get_name (pos);
        def (pos, args) = get_list ([], pos);
        (pos, Some (App (name, args)))
      }
    } 
    and get_list (acc, pos) {
      match (maybe_get (pos)) {
        | (pos, None) => (pos, List.Rev (acc))
        | (pos, Some (x)) => get_list (x :: acc, pos)
      }
    };
    
    match (maybe_get (0)) {
      | (pos, Some (ret)) =>
        assert (pos == s.Length);
        ret
      | (_, None) =>
        assert (false);
    }
  }
  

  FlattenTerm (t : Term) : string
  {
    def ret = System.Text.StringBuilder ();
    def walk (t) {
      | App (name, args) =>
        ignore (ret.Append (name));
        ignore (ret.Append ('('));
        List.Iter (args, walk);
        ignore (ret.Append (')'));
    };
    walk (t);
    ret.ToString ()
  }


  encode (t : Type) : Term
  {
    match (t) {
      | T_ref (t) => 
        App (".r", [encode (t)])
      | T_out (t) =>
        App (".o", [encode (t)])
      | T_array (t, rank) =>
        App (".a", [App (rank.ToString (), []), encode (t)])
      | T_var (tv) =>
        App (".v", [App (tv.id.ToString (), [])])
      | T_void =>
        App ("System.Void", [])
      | T_fun (arg, rt) =>
        App (".f", [encode (arg), encode (rt)])
      | T_prod (args) =>
        App (".p", List.Map (args, encode))
      | T_app (ti, args) =>
        App (Tyutil.FrameworkTypeName (ti), List.Map (args, encode))
    }
  }
    
  /**
   * Used to emit Nemerle types in assembly metadata
   *
   * <remarks>
   *   The type tree is converted to prefix, term-like notation.
   * </remarks>
   */
  public EncodeType (t : Type) : string
  {
    FlattenTerm (encode (t))
  }

  decode (lib : LibraryReference, tenv : SystemMap <int, Tyvar.T>, t : Term) : Type
  {
    def self (t) { decode (lib, tenv, t) };
    match (t) {
      | App (name, args) when name[0] != '.' =>
        match (GlobalEnv.LookupExactType (Nemerle.Utility.NString.Split (name, array ['.', '+']))) {
          | Some (tc) =>
            if (tc.FullName == "System.Void") T_void ()
            else
              T_app (tc, List.Map (args, self))
          | None =>
            match (lib.LookupInternalType (name)) {
              | Some (tc) =>
                T_app (tc, List.Map (args, self))
              | None => Util.ice ("unbound encoded type " + name)
            }
        }
      | App (".r", [t]) => T_ref (decode (lib, tenv, t))
      | App (".o", [t]) => T_out (decode (lib, tenv, t))
      | App (".a", [App (srank, []), t]) => T_array (decode (lib, tenv, t), System.Int32.Parse (srank))
      | App (".f", [t1, t2]) => T_fun (decode (lib, tenv, t1), decode (lib, tenv, t2))
      | App (".v", [App (no, [])]) =>
        match (tenv.Find (System.Int32.Parse (no))) {
          | Some (tv) => T_var (tv)
          | None => Util.ice ("unboud type variable in encoded type " + no)
        }
      | App (".p", types) => T_prod (List.Map (types, self))
      | App (name, _) => Util.ice ("invalid encoded type opcode " + name)
    }
  }


  /**
   * Used to decode Nemerle types extracted from assembly metadata
   */
  public DecodeType (lib : LibraryReference, tenv : SystemMap <int, Tyvar.T>, tokens : string) : Type
  {
    decode (lib, tenv, ParseTerm (tokens))
  }
  

  encode_typarms (tyvars : list <Tyvar.T>) : Term
  {
    def encode_tyvar (tv : Tyvar.T) {
      App ("", [App (tv.id.ToString (), []),
                App (tv.name, []),
                App ("", List.Map (tv.constraints, encode))])
    };
    
    App (".tp", List.Map (tyvars, encode_tyvar))
  }
  
   
  decode_typarms (lib : LibraryReference, 
                  tenv : SystemMap <int, Tyvar.T>, 
                  t : Term) : list <Tyvar.T> * SystemMap <int, Tyvar.T>
  {
    mutable tyvars = [];
    def decode_tyvar (t, acc : SystemMap <int, Tyvar.T>) {
      match (t) {
        | App (_, [App (no, []), App (name, []), _]) =>
          def tv = Tyvar.T (name);
          tyvars = tv :: tyvars;
          acc.Replace (System.Int32.Parse (no), tv)
        | _ => Util.ice ("evil encoded tyvar")
      }
    };

    def vars =
      match (t) {
        | App (".tp", vars) => vars
        | App (name, _) => Util.ice ("invalid typarms in encoded type " + name)
      };
      
    def tenv = List.FoldLeft (vars, tenv, decode_tyvar);
    
    def set_constraints (t, tv : Tyvar.T) {
      match (t) {
        | App (_, [_, _, App (_, constraints)]) =>
          def add_constraint (t) { tv.add_constraint (decode (lib, tenv, t)) };
          List.Iter (constraints, add_constraint);
        | _ => Util.ice ("evil encoded tyvar")
      }
    };

    tyvars = List.Rev (tyvars);
    List.Iter2 (vars, tyvars, set_constraints);
    
    (tyvars, tenv)
  }
  

  encode_tyinfo (ti : TypeBuilder) : Term
  {
    App (".ti", [
      encode_typarms (ti.GetTyparms ()),
      App ("", List.Map (ti.GetDirectSuperTypes (), encode)),
      App ("", List.Map (ti.GetSuperTypes (), encode))
    ])
  }

  public DecodeTypeBuilder (lib : LibraryReference, 
                       tenv : SystemMap <int, Tyvar.T>, 
                       s : string) 
    : list <Tyvar.T> * SystemMap <int, Tyvar.T> * list <Type> * list <Type>
  {
    match (ParseTerm (s)) {
      | App (".ti", [tp, App (_, dst), App (_, st)]) =>
          def (tyvars, tenv) = decode_typarms (lib, tenv, tp);
          def decode_ty (t) { decode (lib, tenv, t) };
          (tyvars, tenv, List.Map (dst, decode_ty), List.Map (st, decode_ty))
      | _ => Util.ice ("evil encoded tyinfo " + s)
    }
  }


  public FixupFunctionHeader (lib : LibraryReference,
                              tenv : SystemMap <int, Tyvar.T>, 
                              fh : Fun_header, 
                              tokens : string) : void
  {
    match (ParseTerm (tokens)) {
      | App (".m", [tp, ty]) =>
        def (tyvars, tenv) = decode_typarms (lib, tenv, tp);
        fh.typarms = tyvars;
        match (decode (lib, tenv, ty)) {
          | T_fun (arg, rt) =>
            fh.ret_type = rt;
            def arg_types = Tyutil.fun_args (arg);
            def set_type (p : Fun_parm, t) {
              p.ty = t;
            };
            List.Iter2 (fh.parms, arg_types, set_type);
          | _ => Util.ice ("encoded method type aint ->")
        }
      | _ => Util.ice ("evil encoded method header " + tokens)
    }
  }
  
  
  public EncodeMemberType (m : IMember) : string
  {
    match (m.GetKind ()) {
      | MK_field (m) => EncodeType (m.GetMemType ())
      | MK_method (m) =>
        def tp = encode_typarms (m.GetHeader ().typarms);
        def mt = encode (m.GetMemType ());
        FlattenTerm (App (".m", [tp, mt]))
      | MK_property (m) =>
        EncodeType (m.GetMemType ())
      | MK_event (m) =>
        EncodeType (m.GetMemType ())
      | MK_type (t) =>
        match (t.GetTyconKind ()) {
          | TK_NemerleType (ti) =>
            FlattenTerm (encode_tyinfo (ti))
          | _ => assert (false)
        }
    }
  }
}

} // ns
