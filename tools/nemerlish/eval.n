using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

[assembly: System.Reflection.AssemblyKeyFile("../../misc/keys/Nemerle.Compiler.snk")]
  
namespace Nemerle.Evaluation
{
  public class Evaluator
  {
    static mutable code : string;
    static mutable locals : list [bool * string * PExpr];
    static mutable ns : list [option [string] * list [string]];
    public static mutable vals : list [object];
   
    public this () {
      Evaluator.locals = [];
      Evaluator.vals = [];
      Message.InitOutput (System.Console.Out);         
  
      Options.CompileToMemory = true;
      Options.IgnoreConfusion = true;
      Options.ProgressBar = false;
      Options.Sources = [""];
      WarningOptions.Disable (168);   // unused variable
      WarningOptions.Disable (10005); // ignore computed value
  
      Passes.LexingPipeline = fun (_) { null };
      Passes.ParsingPipeline = fun (_) { [null] };
      Passes.ScanningPipeline = DoTheStuff;
    }
  
    public Eval (refr: list [string], ns: list [option [string] * string],
                 code: string) : list [bool * bool * string * object * PExpr] {
      Evaluator.code = code;
      Evaluator.ns = List.FoldLeft (ns, [], fun (x, acc) { 
        def (x1, x2) = x;
        (x1, NString.Split (x2, array ['.'])) :: acc 
      });
      
      Options.ReferencedLibraries = System.Reflection.Assembly.GetAssembly 
                                    (this.GetType ()).Location :: refr;
      
      def prevlocals = Evaluator.locals;
      def prevvals = Evaluator.vals;
  
      Passes.Run ();
      
      def ass = Passes.GeneratedAssembly;
      def meth = ass.GetTypes()[0].GetMethod ("Run");
      def newvals = meth.Invoke (null, null) :> list [object];
  
      def loop (l1, l2, l3, l4, acc) {
        match ((l1, l2, l3, l4)) {
          | ([], [], [], []) => acc
          | ((mut, name, ty) :: t1, [], h3 :: t3, []) => 
            loop (t1, [], t3, [], (true, mut, name, h3, ty) :: acc)
          | ((mut, name, ty) :: t1, (prevmut, prevname, prevty) :: t2, 
            h3 :: t3, h4 :: t4) =>
            if (name == prevname)
              if (name == "it" ||
                  (h3 != null && !(h3.Equals (h4))) ||
                  (h3 == null && h4 != null) ||                
                  mut != prevmut)
                loop (t1, t2, t3, t4, (true, mut, name, h3, ty) :: acc)
              else
                loop (t1, t2, t3, t4, (false, mut, name, h3, ty) :: acc)
            else
              loop (t1, (prevmut, prevname, prevty) :: t2, t3, h4 :: t4,
                   (true, mut, name, h3, ty) :: acc)
          | _ => assert (false, "Error: internal error, please report a bug.")
        }
      }
  
      Evaluator.vals = List.Rev (newvals);
  
      loop (Evaluator.locals, prevlocals, newvals, List.Rev (prevvals), [])
    }
  
    internal static DoTheStuff (_tdecl : Parsetree.TopDeclaration) : void {
      MacroRegistry.register_macro (StagedMacro ());
      def n = (None (), ["Nemerle", "Core"]) :: 
              (None (), ["Nemerle", "Core", "option"]) :: Evaluator.ns;
      def env = List.FoldLeft (n, GlobalEnv.Empty, fun (x, acc : GlobalEnv) { 
                  def (x1, x2) = x;
                  match (x1) {
                    | None => acc.AddOpenNamespace (x2, Location.Default)
                    | Some (sname) => acc.AddNamespaceAlias (sname, x2, 
                                                             Location.Default)
                  }
                });
  
      MacroColorizer.PushNewColor (-1, env);
  
      def cname = Macros.NewSymbol ();
      def tb = GlobalEnv.DefineExact (<[ decl: public class $(cname : name) {
                                               } ]>);
      def body = MainParser.ParseExpr (env, Evaluator.code); 
      
      def whole = match (body) {
        | <[ {..$seq } ]> => 
          def (beg, last) = List.DivideLast (seq);
          def last = 
            match (last) {
              | <[ def $_ = $_ ]> 
              | <[ mutable $_ = $_ ]> 
              | <[ def .. $_ ]> =>
                <[ $last; $("stagedmacro" : usesite) (()) ]>
              | _ => <[ $("stagedmacro" : usesite) ($last) ]>
            }
          <[ {..$ (beg + [last]) } ]>
        | _ => <[ $("stagedmacro" : usesite) ($body) ]>
      }
  
      def inits = List.FoldLeft (Evaluator.locals, [], fun (x, acc) {
        def (mut, name, ty) = x;
        match ((mut, ty)) {
          | (false, <[ System.Object ]>) => 
            <[ def $(name : usesite)  = 
            Nemerle.Collections.List.Hd (Evaluator.vals) : $ty ]> :: 
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc;
          | (false, _) => 
            <[ def $(name : usesite)  = 
            Nemerle.Collections.List.Hd (Evaluator.vals) :> $ty ]> :: 
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc;
          | (_, <[ System.Object ]>) => 
            <[ mutable $(name : usesite) = 
            Nemerle.Collections.List.Hd (Evaluator.vals) : $ty ]> ::
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc; 
          | _ => 
            <[ mutable $(name : usesite) = 
            Nemerle.Collections.List.Hd (Evaluator.vals) :> $ty ]> ::
            <[ Evaluator.vals = 
            Nemerle.Collections.List.Tl (Evaluator.vals) ]> :: acc; 
        }
      });
      def whole = <[ {.. $(inits + [whole]) } ]>;
  
//      PrettyPrint.PrintExpr (None (), whole);
      
      tb.Define (<[ decl: public static Run () : list [System.Object] {
                          $whole } ]>);
      tb.Compile ();
  
      MacroColorizer.PopColor ();
    }
  
    internal class StagedMacro : IMacro 
    {
      public Run (ctx : Typer, val : list [SyntaxElement]) : PExpr {
        match (val) {
          | [SyntaxElement.Expression (expr)] =>
            Evaluator.locals = [];
            def l = ctx.GetLocals ();
            def values = <[ $expr : System.Object ]> :: 
                            l.Fold ([], fun (n : Name, loc : LocalValue, acc) {
              regexp match (n.ToString ()) {
                | @"^it$" => acc
                | _ => 
                  Evaluator.locals = (loc.IsMutable, loc.Name, 
                                      PrettyPrint.TyVarToParseTree 
                                      (loc.Type)) :: Evaluator.locals;
                  <[ ($(n : name) : System.Object) ]> :: acc
              }
            });
            Evaluator.locals = (false, "it", PrettyPrint.TyVarToParseTree 
                               (ctx.TypeExpr (expr).Type)) :: Evaluator.locals;
            <[ [..$values] ]>
          | _ => Util.ice ()
        }
      }
  
      public CallTransform (l : list [PExpr]) : list [SyntaxElement]
      { List.Map (l, SyntaxElement.Expression) }
      public GetName () : string { "stagedmacro" }
      public GetNamespace () : string { "" }
      public IsInherited : bool { get { false } }
      public IsTailRecursionTransparent : bool { get { false } }
      public Keywords : list [string] { get { [] } }
      public SyntaxExtension () : GrammarElement * (list [SyntaxElement] -> 
                                                    list [SyntaxElement])
      { (null, fun (_) { [] }) }
      public Usage : Nemerle.MacroUsageAttribute { get { null } }
    }
  }
}
