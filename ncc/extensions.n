(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Parsetree;
open Nemerle.Compiler.Extensions;

namespace Nemerle.Compiler {

  class Extensions
    {
      static lc (ex : Expr) : Expr =
        letfun f (e : Expr) : void = 
          e#loc <- Location_stack.top () 
        in {
          Treeutil.expr_walk (f, ex);
          ex
        };
      
      static implicit_ctor (par : Type_decl, decls : list (Class_member)) : Class_member =
        letfun collect (acc : list (Expr) * list (Fun_parm), decl : Class_member) 
                        : list (Expr) * list (Fun_parm) =
          match decl with [
            | M_field (t, _) =>
              let n = decl#name in
              let fp = Fun_parm (Location_stack.top (), n, t) in 
              let ex = E_assign (E_member (E_this (), n), E_ref (n)) in
              let (es, ps) = acc in
              (Cons (ex, es), Cons (fp, ps))

            | _ => acc
          ]
        in 
        let (assigns, parms) = List.fold_left (collect, (Nil (), Nil ()), decls) in
        let fh = Fun_header (Location_stack.top (), ".ctor", T_void (), List.rev (parms)) in
        let body = lc (E_sequence (assigns)) in
        let f = M_function (fh, FK_ctor (), FB_expr (body)) in {
          Tyvars.set_parms (fh#id, Nil ());
          Tyinfo.infos <- Tyinfo.infos#add (f#id, Tyinfo.lookup (par#id));
          f#modifiers <- Nil();
          f#name <- ".ctor";
          f#env <- par#env;
          Env.add_global (Tyinfo.td_name (par) + ".", f);
          f
        };
    }
  
} // end ns
