/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  /** A class responsible for typing a single (global or local) function.  */
  public partial class Typer
  {
    is_instance_ctor : bool;
    is_method : bool;
    env : GlobalEnv;
    tenv : Tyvar.TEnv;
    current_fun : Fun_header;
    current_type : TypeBuilder;
    parent_typer : option <Typer>;
    outer_context : OuterContext;
    mutable local_context : LocalContext;
    messenger : Messenger;
    
    static solver : Solver = Solver ();

    /** Represent a context common to a set of functions typed together. */
    class OuterContext
    {
      public suspended1 : Queue [DelayedTyping];
      public suspended2 : Queue [DelayedTyping];

      public this ()
      {
        suspended1 = Queue ();
        suspended2 = Queue ();
      }
    }


    #region Toplevel typing
    // FIXME: copy doc from TypeMethod
    /** Walk through method body typing it. */
    public this (m : NemerleMethod)
    {
      current_type = m.DeclaringType :> TypeBuilder;
      parent_typer = None ();
      env = parent_type.env;
      current_fun = m.GetHeader ();
      tenv = current_fun.tenv;
      messenger = solver.CurrentMessenger;

      outer_context = OuterContext ();
      local_context = LocalContext.Empty;

      match (m.GetFunKind ()) {
        | FunKind.Constructor =>
          is_instance_ctor = true;
          is_method = true;
        | FunKind.Method | FunKind.BoundMethod =>
          is_method = true;
        | _ => ()
      }

      MaybeAddBaseCall ();
      
      try {
        RunTyper ();
      } catch {
        | _ : RestartInErrorMode =>
          assert (!messenger.InErrorMode);
          assert (messenger.IsTopLevel);
          messenger.InErrorMode = true;
          outer_context = OuterContext ();
          local_context = LocalContext.Empty;
          try {
            RunTyper ();
          } finally {
            messenger.InErrorMode = false;
          }
      }
      
      MaybeDumpTypedTree ();
    }

    /** Walk through a local function body typing it. */
    public this (parent : Typer, fn : Fun_header)
    {
      parent_typer = Some (parent);

      // copy from parent
      current_type = parent.current_type;
      outer_context = parent.outer_context;
      local_context = parent.local_context;
      is_method = parent.is_method;
      is_instance_ctor = parent.is_instance_ctor;
      env = parent.env;
      messenger = parent.messenger;
      
      current_fun = fn;
      tenv = current_fun.tenv; // FIXME

      RunTyper ();
    }


    MaybeAddBaseCall () : void
    {
      when (is_instance_ctor && !m.DeclaringType.IsValueType)
        match (m.fun_body) {
          | FunBody.Parsed (expr) =>
            match (expr) {
              | PT.PExpr.Sequence (<[ base (.. $_) ]> :: _) => ()
              | PT.PExpr.Sequence (<[ this (.. $_) ]> :: _) => ()
              | PT.PExpr.Sequence =>
                Util.locate (expr.loc,
                  m.fun_body = FunBody.Parsed (<[ { base (); $expr } ]>)
                )
              | _ => assert (false)
            }
          | _ => ()
        }
    }


    MaybeDumpTypedTree () : void
    {
      when (Options.DumpTypedTree) {
        match (current_fun.fun_body) {
          | FunBody.Typed (expr) =>
            Message.debug (expr.loc, $ "$current_type.$(current_fun.name) -> "
                                       "$(current_fun.ret_type) : " +
                                     PrettyPrint.SprintTyExpr (Some (ctx), expr) + "\n")
          | _ => ()
        }
      }
    }


    RunTyper () : void
    {
      foreach (p : Fun_parm in current_fun.parms) {
        Util.locate (p.loc, {
          when (p.kind != ParmKind.Normal && !IsTopLevel)
            ReportError (messenger, "ref/out parameters are not supported in local methods");
          def is_mutable = p.modifiers.mods %&& NemerleAttributes.Mutable;
          def l = LocalValue (current_fun, p.name, p.ty,
                              LocalValue.Kind.FunParm (p.kind),
                              is_mutable = is_mutable);
          AddLocal (PT.Name (p.name, p.color, null), l)
          p.decl = l;
        })
      }

      match (current_fun.body) {
        | FunBody.Parsed (e) =>
          def e' = TypeExpr (e, current_fun.ret_type);
          current_fun.body = FunBody.Typed (e');
        | FunBody.Typed => assert (false)
        | FunBody.Compiled => assert (false)
        | FunBody.Extern
        | FunBody.Abstract => ()
      }
    }
    #endregion


    #region Utilities
    IsTopLevel : bool
    {
      get { parent_typer matches Some }
    }

    AddLocal (name : PT.Name, local : LocalValue) : void
    {
      local_context = local_context.WithLocal (name, local);
    }


    TypeOf (expr : TExpr) : TyVar
    {
      if (expr.ty == null) Util.ice ("type of TT.TExpr was not initialized")
      else expr.ty;
    }


    DefineLocal (name : PT.Name, ty : TyVar,
                 kind : LocalValue.Kind, is_mutable : bool) : LocalValue
    {
       LocalValue (current_fun, name.Id, ty, kind, is_mutable)
    }


    [Nemerle.NotImplemented]
    Delay (expr : PT.PExpr, reason : string) : TExpr
    {
    }


    /** Filter out wrong nodes, and if more then one left -- make the
        [Overloaded] node, and register it.

        Wrong node is [Error] node, or one type of which cannot unify with
        [expected].
        
        Nodes are registered only if solver stack is empty.
        
        Remove duplicates!  */
    [Nemerle.NotImplemented]
    MakeOverloadedNode (exprs : list [OverloadPossibility], expected : TyVar) : TExpr
    {
    }


    /** Run given typing action, without possiblity of any error messages. */
    TryTyping (fn : void -> TExpr) : TExpr
    {
      TryTyping (IsError, fn)
    }


    /** Run given typing action, without possiblity of any error messages. */
    TryTyping<'a> (is_error : 'a -> bool,
                   fn : void -> 'a) : 'a
    {
      solver.PushState ();
      def res = fn ();
      def is_wrong = is_error (res);
      solver.PopState ();
      if (is_wrong) res
      else
        // we cannot reuse the previous result, since it's has been
        // popped off the stack
        fn ()
    }


    IsError (expr : TExpr) : bool
    {
      expr matches TExpr.Error
    }


    /** Check if [e] is an l-value, and if not display an error message
        mentioning [desc]. Additionally is [need_ref] require location of
        the expression to be known (i.e. no properties and indexers).
      */
    CheckLValue (e : TExpr, need_ref : bool, desc : string) : void
    {
      def is_lvalue =
        match (e) {
          | TExpr.LocalRef (d) => d.is_ref
          | TExpr.StaticRef (m) =>
            match (m.GetKind ()) {
              | MemberKind.Field (f) =>
                f.IsMutable || (current_fun.name == ".cctor" &&
                                f.DeclaringType.SameAs (current_type))
              | MemberKind.Property (p) when !need_ref => p.IsMutable
              | _ => false
            }
          | TExpr.StaticPropertyRef (p) when !need_ref => p.IsMutable
          | TExpr.FieldMember (TExpr.This, _) when is_instance_ctor => true
          | TExpr.FieldMember (_, mem) => mem.IsMutable
          | TExpr.PropertyMember (_, p) when !need_ref => p.IsMutable
          | TExpr.Call (TExpr.PropertyMember (_, p), _) when !need_ref => p.IsMutable
          | TExpr.ArrayIndexer => true
          | _ => false
        }
      
      when (!is_lvalue)
        ReportError (messenger, $ "needed an l-value for $desc, "
                                  "got $(DescribeExpression (e))");
    }

    IsIndexerProperty (prop : IProperty) : bool
    {
      def getter = prop.GetGetter ();
      def setter = prop.GetSetter ();
      (getter != null && (getter.GetHeader ().parms matches _ :: _)) ||
      (setter != null && !(setter.GetHeader ().parms matches [_]))
    }
    #endregion


    #region Solver interaction
    MonoType (m : MType, src : string) : TyVar
    {
      def tv = solver.MonoType (m);
      tv.AddSource (src);
      tv
    }


    FreshTyVar (src : string) : TyVar
    {
      def tv = solver.FreshTyVar ();
      tv.AddSource (src);
      tv
    }

    
    ConstructFunctionType (parms : list [TyVar], res : TyVar) : TyVar
    {
      def from =
        match (parms) {
          | [x] => x
          | [] => MonoType (MType.Void (), "")
          | lst => MonoType (MType.Tuple (lst), "")
        }

      MonoType (MType.Fun (from, res), "")
    }


    AtLeast (m : MType, src : string) : TyVar
    {
      def tv = solver.FreshTyVar ();
      tv.AddSource (src);
      tv.Require (m);
      tv
    }


    [Nemerle.NotImplemented]
    PushLocals () : void
    {
    }


    [Nemerle.NotImplemented]
    PopLocals () : void
    {
    }
    #endregion


    #region Expression typing
    TypeExpr (e : PT.PExpr, expected : TyVar) : TExpr
    {
      Util.locate (e.loc, {
        // FIXME: expand macros here
        def e' = 
          try {
            if (solver.InErrorState)
              TExpr.Error ()
            else
              DoType (e, expected);
          } catch {
            | _ : Recovery =>
              MarkError ();
              TExpr.Error ()
          }

        e'.ty = expected;
        e'
      })
    }

   
    [Nemerle.NotImplemented]
    TypeMatch (m : PT.PExpr.Match, expected : TyVar) : TExpr
    {
    }


    TypeLocalDefinition (is_mutable : bool, name : PT.Name, val : PT.PExpr) : TExpr
    {
      // check for mutable symbol redefinitions
      match (local_context.FindLocal (name)) {
        | Some (l) =>
          def warn (was_of_kind, is_of_kind) {
              Message.warning ($ "redefinition of a local $was_of_kind "
                                 "value `$(l.Name)' $is_of_kind");
              Message.warning (l.loc, "  <-- previously seen here")
          }

          match ((is_mutable, l.IsMutable)) {
            | (true, true) =>
              warn ("mutable", "")
            | (false, true) =>
              warn ("mutable", " as non-mutable")
            | (true, false) =>
              warn ("non-mutable", " as mutable")
            | _ => {}
          }
        | _ => {}
      }
      
      def tv = FreshTyVar ("");
      def val = TypeExpr (val, tv);
      def decl = DefineLocal (name, tv, 
                              LocalValue.Kind.LocalVariable (), 
                              is_mutable);
      AddLocal (name, decl);
      TExpr.DefValIn (decl, val, null)
    }

    
    DoType (expression : PT.PExpr, expected : TyVar) : TExpr
    {
      match (expression) {
        | PT.PExpr.ParmByRef
        | PT.PExpr.ParmOut =>
          ReportFatal (messenger, 
                       "ref and out parameters are only allowed in function calls")

        | PT.PExpr.Define (is_mutable, PT.Splicable.Name (name), val) =>
          expected.Unify (MonoType (MType.Void (), "definition ``result''"));
          TypeLocalDefinition (is_mutable, name, val)


        | PT.PExpr.Define =>
          ReportFatal (messenger,
                       "$ operator used outside quotation <[ ... ]> context")

        | PT.PExpr.DefPattern =>
          Message.fatal_error ("def pattern binding not followed by any expression")

        | PT.PExpr.DefFunctions =>
          Message.fatal_error ("letfun binding not followed by any expression")


        // FIXME: this should be a macro
        | PT.PExpr.Lambda (d) =>
          def newname = Util.tmpname ("l");
          d.header.name = PT.Splicable.Name (PT.Name (newname));
          def sq = PT.PExpr.Sequence ([PT.PExpr.DefFunctions ([d]),
                                       PT.PExpr.Ref (PT.Name (newname))]);
          TypeExpr (sq, expected)


        // array [...]
        | PT.PExpr.Array (<[ $(r : int) ]>, <[ [] ]> ) =>
          def list_of_zeros (r) {
            | 1 => [ <[ 0 ]> ]
            | _ => <[ 0 ]> :: list_of_zeros (r - 1)
          }
          TypeExpr (<[ array (..$(list_of_zeros (r))) ]>, expected)


        | PT.PExpr.Array (<[ $(rank : int) ]>, args) =>
          TypeArray (rank, args, expected)


        | PT.PExpr.Array (PT.PExpr.Spliced, _) =>
          ReportFatal (messenger, "$ splicing outside of <[ quotation ]>")


        | PT.PExpr.Array => Util.ice ("wrongly parsed array initializer")


        | PT.PExpr.EmptyArray (sizes) =>
          mutable size = 0;
          def tsizes = List.Map (sizes, fun (x) {
            ++size;
            def tv = MonoType (InternalType.Int32, "array size initializer");
            TypeExpr (x, tv)
          });
          expected.Unify (MType.Array (FreshTyVar ("empty array object"), size));
          TExpr.Array ([], tsizes)


        | PT.PExpr.Indexer (obj, args) =>
          TypeIndexer (obj, args, expected)


        | (PT.PExpr.TryWith) as x =>
          def res1 = FreshTyVar ("try block result");
          def res2 = FreshTyVar ("catch handler result");
          expected.Provide (res1);
          expected.Provide (res2);
          def body = TypeExpr (x.body, res1);
          def exn = match (x.exn) {
            | PT.Splicable.Name (e) => e
            | _ =>
              ReportFatal (messenger, 
                           "$ operator used outside quotation <[ ... ]> context")
          };
          def decl = DefineLocal (exn, BindType (x.exn_ty),
                                  LocalValue.Kind.ExceptionValue (), false);
          PushLocals ();
          try {
            AddLocal (exn, decl);
            def handler = TypeExpr (x.handler, res2);
          } finally {
            PopLocals ();
          }

          TExpr.TryWith (body, decl, handler)


        | PT.PExpr.TryFinally (e1, e2) =>
          expected.AddSource ("try-finally result");
          def body = TypeExpr (e1, expected);
          def tv = FreshTyVar ("finally {...} result");
          def handler = TypeExpr (e2, tv);
          TExpr.TryFinally (body, handler)


        | PT.PExpr.Typeof (t) =>
          expected.Unify (InternalType.Type);
          TExpr.TypeOf (BindType (t))


        | PT.PExpr.TypeConversion (e, t) =>
          def t = BindType (t);
          expected.Unify (t);

          def fv = FreshTyVar ("type-cast body");
          def e' = TypeExpr (e, fv);

          if (fv.IsFixed)
            TypeConversion (e', t)
          else
            // FIXME: can we do better?
            if (cannot_delay)
              ReportFatal (messenger, 
                           "the type of type-casted expression cannot be "
                           "deduced")
            else Delay (expression)


        | PT.PExpr.TypeEnforcement (e, t) =>
          def t = BindType (t);
          def fv = AtLeast (t, "type-enforcement body");
          expected.Unify (t);
          def e = TypeExpr (e, fv);
          TExpr.TypeEnforcement (e, t)


        | PT.PExpr.Ref (name) =>
          TypeName (name, expected)

          
        | PT.PExpr.Member (obj, PT.Splicable.Name (name)) =>
          assert (List.Length (name.idl) == 1);
          def mem_name = name.Id;
          def overloads =
            match (Util.qidl_of_expr (expression)) {
              | Some ((idl, name)) => 
                def name' = PT.Name (idl, name.color, name.context);

                def res1 = TryTyping (List.IsEmpty, fun () {
                  TypeName (name', expected)
                });
                def res2 = TryTyping (List.IsEmpty, fun () {
                  TypeMember (obj, mem_name, expected) 
                });

                if (res1.IsEmpty && res2.IsEmpty) {
                  // run the typing again, so it will present
                  // the error message if needed
                  TypeName (name', expected);
                } else
                  res1 + res2

              | None =>
                TypeMember (obj, mem_name, expected)
            }
            
          MakeOverloadedNode (overloads, expected)


        | PT.PExpr.Member (_, _) =>
          ReportFatal (messenger,
                       "$ operator outside quotation <[ ... ]> context")


        | PT.PExpr.Call (fnc, parms) =>
          TypeCall (fnc, parms, expected)


        | PT.PExpr.Assign (PT.PExpr.Tuple (vars), e2) =>
          expected.Unify (MonoType (MType.Void (), "assignment result"));
          def tempnames = List.Map (vars, fun (_) { <[ $(Macros.NewSymbol () : name) ]> });
          def assigns = List.Map2 (vars, tempnames, fun (x, y) { <[ $x = $y ]> });
          def expr = <[
            def (..$tempnames) = $e2;
            {..$assigns }
          ]>;
          TypeExpr (expr, expected)


        | PT.PExpr.Assign (PT.PExpr.Wildcard, e2) =>
          expected.Unify (MonoType (MType.Void (), "assignment result"));
          TypeExpr (<[ def _ = $e2 ]>, expected)


        | PT.PExpr.Assign (e1, e2) =>
          expected.Unify (MonoType (MType.Void (), "assignment result"));
          def target_type = FreshTyVar ("assignment target");
          def source_type = FreshTyVar ("assignment source");
          source_type.Require (target_type);
          def e1 = TypeExpr (e1, target_type);
          CheckLValue (e1, need_ref = false, desc = "assignment target");
          def e2 = TypeExpr (e2, source_type);
          TExpr.Assign (e1, e2)


        | PT.PExpr.Throw (e) =>
          def ty = AtLeast (InternalType.Exception, "thrown value");
          def e = TypeExpr (e, ty);
          TExpr.Throw (e)


        | PT.PExpr.Literal (l) =>
          expected.Unify (TypeOfLiteral (l));
          TExpr.Literal (l)


        | PT.PExpr.This =>
          if (is_method) {
            expected.Unify (current_type.GetMemType ());
            TExpr.This ()
          } else
            ReportFatal (messenger, "`this' used outside method");


        | PT.PExpr.Base =>
          if (is_method) {
            def baseti = Option.UnSome (current_type.SuperClass ());
            def parms = Option.UnSome (ti.SuperType (baseti));
            def parms = List.Map (parms, solver.MonoType);
            def ty = MType.Class (baseti, parms);
            expected.Unify (ty);
            TExpr.This ()
          } else
            ReportFatal (messenger, "`base' used outside method");


        | PT.PExpr.Sequence ([]) =>
          TypeLiteral (Literal.Void (), expected)


        | PT.PExpr.Sequence (l) =>
          def loop (res, lst) {
            | [e] =>
              def e' = TypeExpr (e, expected);
              TExpr.Sequence (List.Rev (e' :: res))
            | x :: xs =>
              def x' = TypeExpr (x, FreshTyVar (""));
              loop (x' :: res, xs)
            | [] => assert (false)
          }

          PushLocals ();
          def res = loop ([], l);
          PopLocals ();
          res


        | PT.PExpr.Tuple (l) =>
          mutable res_exprs = [];
          mutable res_types = [];
          foreach (e in l) {
            def tv1 = FreshTyVar ("tuple component");
            def tv2 = FreshTyVar ("tuple component");
            tv1.Require (tv2);
            def e = TypeExpr (e, tv1);
            res_exprs = e :: res_exprs;
            res_types = tv2 :: res_types;
          }
          expected.Unify (MType.Tuple (res_types));
          TExpr.Tuple (res_exprs)


        | (PT.PExpr.Match) as m =>
          TypeMatch (m, expected)


        | PT.PExpr.Typed (tytree) =>
          expected.Unify (TypeOf (tytree));
          tytree


        | PT.PExpr.Quoted (parse_element) =>
          def lifted =
            match (parse_element) {
              | PT.SyntaxElement.Expression (e) => Macros.quoted_expr (ctx, e)
              | PT.SyntaxElement.Type (e) => Macros.quoted_type (ctx, e)
              | PT.SyntaxElement.MatchCase (e) => Macros.QuotedMatchCase (ctx, e)
              | PT.SyntaxElement.MatchCaseGuard (a, b) => Macros.QuotedCaseGuard (ctx, (a, b))
              | PT.SyntaxElement.Function (e) => Macros.quoted_fundecl (ctx, e)
              | PT.SyntaxElement.Parameter (e) => Macros.quoted_fparam (ctx, e)
              | PT.SyntaxElement.ClassMember (e) => Macros.quoted_member (ctx, e)
              | PT.SyntaxElement.TType (e) => Macros.quoted_ttype (ctx, e)

              | PT.SyntaxElement.TypeBuilder
              | PT.SyntaxElement.MethodBuilder
              | PT.SyntaxElement.FieldBuilder
              | PT.SyntaxElement.EventBuilder
              | PT.SyntaxElement.PropertyBuilder
              | PT.SyntaxElement.ParameterBuilder =>
                Util.ice ("strange syntax element appeared in quotation")
            };
          TypeExpr (lifted, expected)


        | PT.PExpr.Spliced =>
          ReportFatal (messenger, "$ macro keyword used in regular expression")
          

        | PT.PExpr.Wildcard | PT.PExpr.Application | PT.PExpr.As =>
          ReportFatal (messenger, "found pattern expression inside a raw expression")
          

        | PT.PExpr.Ellipsis =>
          Util.ice ("List of expression parameters out of any construct")
          

        | PT.PExpr.MacroCall  =>
          Util.ice ("Macrocalls should have been expanded already")


        | PT.PExpr.TypedPattern  =>
          Util.ice ("typed pattern in raw expr")
      }
    }
    #endregion


    #region Array, literal typing
    // FIXME: make this tail rec
    TypeArray (rank : int, args : list [PT.PExpr], expected : TyVar) : TExpr
    {
      def expr_list_length (e) {
        | <[ [] ]> => 0
        | <[ $_ :: $rest ]> => 1 + expr_list_length (rest)
        | _ =>
          ReportError (messenger, 
                       "array initializer must be of form "
                       "`array [rank] [ [..], .., [..] ]'");
          0
      }

      def expr_list_flatten_and_count (e, remaining) {
        | (<[ [] ]>, 0) => []
        | (<[ [] ]>, _)
        | (_, 0) =>
          ReportError (messenger, "incorrectly structured array initializer");
          []
        | (<[ $x :: $xs ]>, n) => x :: expr_list_flatten_and_count (xs, n - 1)
        | _ =>
          ReportError (messenger,
                       "array initializer must be of form "
                       "`array [rank] [ [..], .., [..] ]'");
          []
      }

      def dimensions (args, remaining_rank) {
        | (_, 0) => []
        | (<[ $head :: $_ ]>, n) =>
          expr_list_length (args) :: dimensions (head, n - 1)
        | _ =>
          ReportError (messenger, 
                       "array initializer must be of form "
                       "`array [rank] [ [..], .., [..] ]'");
          []
      }
      
      /* Flattens the initializers and checks that there are the correct
         number of them */
      def flatten (args, dims) {
        | (elem, []) => [elem]
        | (l, h::t) => 
          def flat = expr_list_flatten_and_count (l, h);
          List.FoldLeft (flat, [], 
                         fun (i, a) {
                           List.Concat ([a, flatten (i, t)])
                         })
      }

      def dimensions = dimensions (args, rank);
      def lst = flatten (args, dimensions);

      if (messenger.SeenError)
        TExpr.Error ()
      else {
        def dimensions =
          List.Map (dimensions,
                    fun (x) { TExpr.Literal (Literal.Int (x)) });
        def element_type = FreshTyVar ("array element type");

        def initalizers =
          List.Map (lst,
                    fun (expr) {
                      def tv = AtLeast (element_type);
                      TypeExpr (expr, tv)
                    });

        expected.Unify (MType.Array (element_type, rank);

        TExpr.Array (initializers, dimensions)
      }
    }


    TypeOfLiteral (l : Literal) : TyVar
    {
      def mono_type =
        match (l) {
          | Literal.Null => null
          | Literal.Void => MType.Void ()
          | Literal.Byte => InternalType.Byte
          | Literal.SByte => InternalType.SByte
          | Literal.Short => InternalType.Int16
          | Literal.UShort => InternalType.UInt16
          | Literal.Int => InternalType.Int32
          | Literal.UInt => InternalType.UInt32
          | Literal.Long => InternalType.Int64
          | Literal.ULong => InternalType.UInt64
          | Literal.Char => InternalType.Char
          | Literal.String => InternalType.String
          | Literal.Float => InternalType.Single
          | Literal.Double => InternalType.Double
          | Literal.Decimal => InternalType.Decimal
          | Literal.Bool => InternalType.Boolean
          | Literal.Enum (_, tc) => MType.Class (tc, [])
        }

      if (mono_type == null) {
        def tv = FreshTyVar ();
        tv.IsFromNull = true;
        tv
      } else {
        MonoType (mono_type, "literal type")
      }
    }
    #endregion


    #region Member access typing
    TypeToConstructor (t : TypeInfo) : list [OverloadPossibility]
    {
      match (t.GetTydecl ()) {
        | TypeDeclaration.Alias (TType.Class (t, _)) => TypeToConstructor (t)
        | _ =>
          if (t.Attributes %&& NemerleAttributes.Abstract)
            ReportError (messenger, 
                         $ "the type `$(t)' is abstract and cannot "
                           "be constructed");
          else
            match (t.GetConstantObject ()) {
              | None =>
                mutable seen_empty_ctor = false;
                mutable res = [];

                foreach (meth : IMethod in t.LookupMember (".ctor")) {
                  match (meth.GetFunKind ()) {
                    | FunKind.Constructor 
                      when meth.CanAccess (current_type) =>
                      when (meth.GetHeader ().parms.IsEmpty)
                        seen_empty_ctor = true;
                      def from =
                        match (meth.GetMemType ().LowerBound) {
                          | Some (MType.Fun (from, _)) => from
                          | None => assert (false)
                        }
                      // XXX if we want variant ctor to be of variant type
                      // here is the place
                      def mt = MType.Fun (from, t.GetMemType ());
                      def ty = t.FreshSubst (solver.MonoType (mt, ""));
                      res = OverloadPossibility (solver, ty, null, meth) :: res;
                    | _ => {}
                  }
                }

                when (t.IsValueType && !seen_empty_ctor) {
                  def res = t.FreshSubst ().Apply (f.GetMemType ());
                  def ty = ConstructFunctionType ([], res);
                  res = OverloadPossibility (solver, ty, null, t) :: res;
                }

                res

              | Some (f) =>
                def res = t.FreshSubst ().Apply (f.GetMemType ());
                def ty = ConstructFunctionType ([], res);
                [OverloadPossibility (solver, ty, null, f)]
            }
       }
    }


    InterpretGlobal (symbol : Symbol) : list [OverloadPossibility]
    {
      def single (ty, mem) {
         [OverloadPossibility (solver, ty, null, mem)]
      }
      
      match (symbol) {
        | Symbol.TypeMember (mem) =>
          if (!mem.IsStatic) {
            when (!is_method)
              ReportError (messenger,
                           $ "trying to access an instance member "
                             "$(mem.DeclaringType).$(mem.Name) from a static "
                             "method");
            []
          } else if (!mem.CanAccess (current_type)) {
            ReportError (messenger,
                         $ "cannot access `$(mem.DeclaringType).$(mem.Name)'");
            []
          } else {
            match (mem.GetKind ()) {
              | MemberKind.Type (t) =>
                TypeToConstructor (t)

              | MemberKind.Method (m) =>
                single (m.GetFreshType (), m)

              | MemberKind.Property
              | MemberKind.Field =>
                single (mem.GetMemType (), mem)

              | MemberKind.Event (e) =>
                if (e.DeclaringType.Equals (current_type)) {
                  def field = (e :> NemerleEvent).storage_field;
                  if (field == null)
                    [] // XXX how?
                  else
                    single (field.GetMemType (), field)
                } else []
            }
          }

        | Symbol.Type (t) =>
          if (!t.CanAccess (current_type)) {
            ReportError (messenger, $ "cannot access type `$(t)'");
            []
          } else {
            TypeToConstructor (t)
          }
      }
    }

    
    InterpretGlobals (symbols : list [Symbol], expected : TyVar) 
                              : list [OverloadPossibility]
    {
      List.Flatten (List.Map (symbols, InterpretGlobal))
    }


    TypeMember (obj : PT.PExpr, mem_name : string, expected : TyVar) 
                    : list [OverloadPossibility]
    {
      // XXX we should add a bound here, that the type should have the
      // field mem_name
      def tv = FreshTyVar ("left hand side of the dot");
      def obj = TypeExpr (obj, tv);
      if (tv.IsFixed) {
        def mems = Hashtable ();
        def visited = Hashtable ();
        mutable res = [];

        def lookup (t) {
          | MType.Class (tc, args) when (! visited.Contains (tc.GetId ())) =>
            visited [tc.GetId ()] = null;
            foreach (mem : IMember in tc.LookupMember (mem_name))
              when (!mems.Contains (mem.GetId ())) {
                mems [mem.GetId ()] = null;
                when (!mem.IsStatic && mem.CanAccess (current_type)) {
                  def ty =
                    match (mem) {
                      | meth : IMethod =>
                        meth.GetFreshType ()
                      | mem : IMember =>
                        mem.GetMemType ()
                    };
                  def ty = tc.SubtypingSubst (mem.DeclaringType).Apply (ty);
                  def ty = tc.MakeSubst (args).Apply (ty);
                  res = OverloadPossibility (solver, ty, obj, mem) :: res;
                }
              }
          | MType.TyVar (tv) =>
            List.Iter (tv.Constraints, lookup)
          | MType.Array =>
            lookup (InternalType.Array)
          | MType.Intersection (lst) =>
            List.Iter (lst, lookup)
          | _ => ()
        }
        lookup (Option.UnSome (tv.LowerBound));
        res
      } else if (IsError (obj)) {
        []
      } else {
        // FIXME: here we should traverse all type paths from lower to
        // upper bound and look how this field is defined there, and finally
        // add maybe-more-specific lower bound
        if (cannot_delay) {
          ReportFatal (messenger, 
                       $ "cannot determine proper type for `$(tv)', "
                         "to find member `$(mem_name)'")
        } else
          Delay (<[ $(obj : typed) . $mem_name ]>)
      }
    }


    TypeName (name : PT.Name, expected : TyVar) : TExpr
    {
      match (name.idl) {
        | [_] when local_context.FindLocal (name) matches Some =>
          def local = Option.UnSome (local_context.FindLocal (name));
          def ty =
            match (local.ValKind) {
              | LocalValue.Kind.Function (fun_header, _) =>
                Subst.Fresh (solver, fun_header.typarms).Apply (local.Type)
              | _ => local.Type
            }
          expected.Unify (ty);
          TExpr.LocalRef (local)

        | _ =>
          def from_this =
            match (name.idl) {
              | [name] when is_method =>
                solver.PushState ();
                def res = TypeMember (<[ this ]>, name, expected);
                solver.PopState ();
                if (res.IsEmpty) []
                else TypeMember (<[ this ]>, name, expected)
              | _ => []
            };
          def globals = name.GetEnv (env).LookupSymbol (name.idl);
          def from_global = InterpretGlobals (globals, expected);

          MakeOverloadedNode ([from_this, from_global], expected)
      }
    }
    #endregion


    #region Function call typing
    TryTypeCall (fnc : TExpr, parms : list [Parm], expected : TyVar,
                 var_args : bool) : TExpr
    {
      def ct = CallTyper (this, fnc, parms, expected);
      ct.is_var_args = var_args;
      ct.Run ();
      ct.result
    }


    ResolveOverload (overloads : list [OverloadPossibility], 
                     parms : list [Parm], expected : TyVar) : TExpr
    {
      def try_type (overload : OverloadPossibility)
      {
        TryTypeCall (overload.Compile (), 
                     parms, 
                     expected, 
                     var_args = overload.VarArgs);
      }

      def error_message (overload : OverloadPossibility) {
        solver.PushState ();
        try_type (overload);
        def msg = messenger.GetErrorMessage ();
        solver.PopState ();
        msg
      }

      match (OverloadPossibility.OnlyPossible (overloads)) {
        | [] =>
          TExpr.Error ()

        | overloads =>
          mutable ok = [];

          foreach (overload in overloads) {
            solver.PushState ();
            unless (IsError (try_type (overload)))
              ok = overload :: ok;
            solver.PopState ();
          }

          match (GetBestOverload (ok)) {
            | [] =>
              when (messenger.NeedMessage) {
                match (overloads) {
                  | [o] =>
                    ReportError (messenger, $ "typing error in call: $(error_message (o)))");
                  | _ =>
                    ReportError (messenger, "each overload has an error during call:");
                    mutable cnt = 1;
                    foreach (o in overloads)
                      ReportError (messenger, $ "  overload #$cnt, $(o): $(error_message (o))")
                }
              }
              TExpr.Error ()
            | [one] =>
              try_type (one)
            | _ =>
              // XXX somehow
              Delay ()
          }
      }
    }

    
    TypeCall (fnc : PT.PExpr, parms : list [PT.PExpr], expected : TyVar) : TExpr
    {
      def refout (name, expr) {
        def tv = FreshTyVar ("call parameter");
        match (expr) {
          | PT.PExpr.ParmByRef (ex)
          | PT.PExpr.ParmOut (ex) =>
            def ex = TypeExpr (ex, tv);
            CheckLValue (ex, need_ref = true, desc = "ref/out parameter");
            def kind =
              match (expr) {
                | PT.PExpr.ParmByRef => ParmKind.Ref
                | _ => ParmKind.Out
              };
            Parm (kind, ex, name)
          | ex =>
            def ex = TypeExpr (ex, tv);
            Parm (ParmKind.Normal, ex, name)
        }
      }

      def compile_parm (p : PT.PExpr) {
        | <[ $(name : name) = $e ]> => refout (name.Id, e)
        | e => refout ("", e)
      };

      def parms = List.Map (parms, compile_parm);

      def res =
        match (TypeExpr (fnc, FreshTyVar ("called value"))) {
          | _ when messenger.SeenError =>
            TExpr.Error ()

          | TExpr.Overloaded (overloads) =>
            ResolveOverload (overloads, parms, expected)

          | _ =>
            TryTypeCall (fnc, parms, expected, var_args = false);
            def msg = messenger.GetErrorMessage ();
            when (msg != null)
              ReportError (messenger, $ "typing error in call: $msg");
        }
      
      // XXX what's that?
      match (res) {
        | TExpr.Call (TExpr.PropertyMember (_, prop), _) when IsIndexerProperty (prop) =>
          ReportError (messenger, "attempt to call an indexer property `$(prop.Name)'");
        | _ => ()
      };

      res
    }
    #endregion


    #region Type conversion typing
    [Nemerle.NotImplemented]
    TypeConversion (expr : TExpr, ty : MType) : TExpr
    {
            def has_xpl =
              match (t) {
                | MType.Class (tinfo, _) =>
                  !tinfo.LookupMember ("op_Explicit").IsEmpty ()
                | _ => false
              };
          t = Tyutil.top_expand (bind_ty (t));
          def val = ty_expr (ctx, e);
          def valt = Tyutil.top_expand (val.ty);
          def conv = match (valt) {
            | TType.Class (tinfo, _) =>
              def loop (mems : list [IMember]) {
                | mem :: xs when mem.IsStatic =>
                  match (mem.GetMemType ()) {
                    | TType.Function (_, to) when Tyutil.types_eq (to, t) =>
                      Some (TExpr.Call (TExpr.StaticRef (mem), [Parm (val)]))
                    | _ => loop (xs)
                  }
                | _ :: xs => loop (xs)
                | _ => None ()
              }
              loop (tinfo.LookupMember ("op_Explicit"))

            | _ => None ()
          }
          match (conv) {
            | Some (x) => (x, t)
            | None =>
              if (Tyutil.is_value_type (t) || Tyutil.is_value_type (valt))
                // FIXME: do more conservative checking
                (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
              else
                if (t >:> valt)
                  (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
                else if (valt >:> t)
                  (val, t) /// nothing to be done, warn about redundancy of cast?
                else {
                  // FIXME: unfortunately we use some forbidden casts in compiler
                  // Message.error ($"cannot convert type `$(Tyutil.string_of_type (val.ty))'"
                  //               " to `$(Tyutil.string_of_type (t))'");
                  // (val, val.ty)
                  (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
                }
          }
    }
    #endregion


    #region Pattern typing
    class PatternTyper
    {
      typer : Typer;
      matched_value_type : TyVar;
      patterns : list [PT.PExpr * option [PT.PExpr]];

      mutable common_variables : NemerleMap [PT.Name, LocalValue];
      mutable current_pattern_variables : NemerleMap [PT.Name, LocalValue];


      public this (typer : Typer,
                   matched_value_type : TyVar,
                   patterns : list [PT.PExpr * option [PT.PExpr]])
      {
        this.typer = typer;
        this.matched_value_type = matched_value_type;
        this.patterns = patterns;
      }


      public Run () : list [Pattern * TExpr]
      {
        mutable result = [];

        foreach ((pattern, guard) in patterns) {
          current_pattern_variables = NemerleMap ();
          def typed_pattern = TypePattern (pattern);

          // FIXME: shouldn't this be in the library?
          def intersect (map1, map2) {
            map1.Fold (fun (key, value, res : NemerleMap [_, _]) {
              if (map2.Member (key))
                res.Add (key, value)
              else
                res
            }, NemerleMap ())
          }

          if (common_variables == null)
            common_variables = current_pattern_variables;
          else
            common_variables = intersect (common_variables,
                                          current_pattern_variables);

          typer.PushLocals ();
            current_pattern_variables.Iter (typer.AddLocal);

            def expr =
              match (expr) {
                | None => <[ true ]>
                | Some (expr) => expr
              }

            def bool_ty =
              typer.MonoType (InternalType.Boolean, "when guard type");
              
            def expr' = TypeExpr (expr, bool_ty)
          typer.PopLocals ();

          result = (typed_pattern, typed_expr) :: result;
        }

        common_variables.Iter (fun (_, v : LocalValue) {
                                v.UsedInPatternBody = true
                               });
        common_variables.Iter (typer.AddLocal);
      }


      TypeTuplePattern (matched_value_type : TyVar,
                        pats : list [PT.PExpr]) : Pattern
      {
        def is_assignment (expr) {
          expr matches PT.PExpr.Assign (PT.PExpr.Ref, _) 
        }

        if (List.Exists (pats, is_assignment)) {
          if (List.ForAll (pats, is_assignment)) {
              match (matched_value_type.LowerBound) {
                | Some (MType.Class (ti, _)) when matched_value_type.IsFixed =>
                  def is_instance_field (_) {
                    | field : IField => !field.IsStatic
                    | _ => false
                  }
                  def lookup_field (expr) {
                    | PT.PExpr.Assign (PT.PExpr.Ref (name), pat) =>
                      def fields = List.Filter (ti.LookupMember (name.Id), 
                                                is_instance_field);
                      match (fields) {
                        | [] =>
                          ReportError (messenger,
                                       "the type `$(ti)' has no field named `$(name)'");
                          Pattern.Error ()

                        | [field] =>
                          def ty = matched_value_type.TypeOfMember (field);
                          (field, TypePattern (ty, pat))

                        | _ =>
                          // I don't thinks this can happen
                          ReportError (messenger,
                                       "overload ambiguity during "
                                       "selection of `$(ti).$(name)'");
                          Pattern.Error ()
                      }

                    | _ => assert (false)
                  }

                  Pattern.Record (List.Map (pats, lookup_field))
                  
                  
                | _ =>
                  ReportError (messenger,
                               "the (fieldname = ...) pattern is not allowed "
                               "here, try prefixing it with the class name");
                  Pattern.Error ()
              }

          } else {
            ReportError (messenger, 
                         "not all, but some patterns in tuple are named");
            Pattern.Error ()
          }
        } else {
          match (matched_value_type.LowerBound) {
            // if we expecte to match on a class, transform the pattern
            // to include field names
            | Some (MType.Class (ti, _)) =>
              def mems = ti.GetFields (BindingFlags.DeclaredOnly %|
                                       BindingFlags.Public %|
                                       BindingFlags.Instance);
              def names = List.Map (mems, fun (x : IField) { x.Name });
              if (names.Length == pats.Length) {
                def assigns = List.Map2 (names, pats,
                  fun (n, p) {
                    PT.PExpr.Assign (PT.PExpr.Ref (PT.Name ([n])), p)
                  });
                TypeTuplePattern (matched_value_type, assigns)
              } else {
                ReportError (messenger,
                             $ "pattern matches $(pats.Length) values, "
                               "while the type `$(ti)' has $(names.Length) "
                               "fields");
                Pattern.Error ()
              }
              
            | Some (MType.Tuple (types)) 
              when types.Length != pats.Length =>
              ReportError (messenger,
                           $ "pattern matches $(pats.Length)-tuples, "
                             "while the value matched is a "
                             "$(types.Length)-tuple");
              Pattern.Error ()
              
            | _ =>
              def types =
                List.Map (pats, fun (_) { typer.FreshTyVar ("") });
              matched_value_type.Unify (MType.Tuple (types));
              if (messenger.SeenError) {
                ReportError (messenger,
                             $ "type clash in pattern typing");
                Pattern.Error ()
              } else {
                def typed_pats = List.Map2 (types, pats, TypePattern);
                Pattern.Tuple (typed_pats)
              }
          }
        }
      }
        
        
      TypePattern (matched_value_type : TyVar, pattern : PT.PExpr) : Pattern
      {
        Util.locate (pattern.loc, {
          def typed = DoTypePattern (matched_value_type, pattern);
          when (typed.ty == null)
            typed.ty = matched_value_type;
          typed
        })
      }


      TypeApplication (matched_value_type : TyVar, 
                       name : PT.PExpr, pattern : PT.PExpr) : Pattern
      {
        match (Util.qidl_of_expr (name)) {
          | Some ((li, name)) =>
            def name = PT.Name (li, name.color, name.context);

            if (System.Char.IsUpper (List.Last (name.idl) [0])) {
              def env = name.GetEnv (typer.env);
              def proper_symbol (sym) {
                | Symbol.TypeMember (fld : IField) =>
                  fld.CanAccess (typer.current_type) &&
                  fld.IsLiteral && 
                  (fld.DeclaringType.GetTydecl () matches TypeDeclaration.Enum)

                | Symbol.Type (ti) =>
                  ti.CanAccess (typer.current_type)
              }

              match (List.Filter (env.LookupSymbol (name.idl), is_proper_symbol)) {
                | [Symbol.TypeMember (fld : IField)]  =>
                  if (pattern matches PT.PExpr.Wildcard) {
                    matched_value_type.Require (fld.GetMemType ());
                    def val = Option.UnSome (ConstantFolder.FieldValueAsLiteral (fld));
                    Pattern.Enum (fld, val)
                  } else {
                    ReportError (messenger, 
                                 "a pattern was supplied after enum field name");
                    Pattern.Error ()
                  }

                | [Symbol.Type (ti)] =>
                  def lookup (ti) {
                    match (ti.GetTydecl ()) {
                      | TypeDeclaration.VariantOption =>
                        def parent_tycon = Option.UnSome (ti.SuperClass ());
                        def option_type = ti.FreshSubst ().Apply (ti.GetMemType ());
                        matched_value_type.Provide (option_type);
                        //else if (option_type >:> t)
                        //  Message.warning ($ "matching of $t with $option_type is redundant");
                        //  Message.hint_once ("refer to fields of this variant option without matching");

                        Pattern.Application (ti, TypePattern (option_type, pattern));
                        
                      | TypeDeclaration.Alias (TType.Class (tc, _)) =>
                        lookup (tc)

                      | _ =>
                        ReportError (messenger, "`$(name)' is not a variant option");
                        Pattern.Wildcard ()
                    }
                  }

                  lookup (ti)
              }
            } 
            else
              match (pattern) {
                | PT.PExpr.Wildcard =>
                  TypePattern (matched_value_type,
                  walk (t, PT.PExpr.As (PT.PExpr.Wildcard (), PT.Splicable.Name (n)))
                | _ =>
                  Message.fatal_error ("`" + n.FullId + "' cannot be variant option, "
                                       "since it starts with lowercase letter")
              }

          | None =>
            ReportError (messenger, "expected qualified identifier in pattern");
            Pattern.Error ()
        }
      }


      DoTypePattern (matched_value_type : TyVar, pattern : PT.PExpr) : Pattern
      {
        match (pattern) {
          | PT.PExpr.As (pat, PT.Splicable.Name (name)) =>
            def typed_pattern = TypePattern (matched_value_type, pattern);
            def fixed_type =
              match (typed_pattern) {
                | Pattern.Application (ti, _) =>
                  def raw_type = ti.FreshSubst ().Apply (ti.GetMemType ());
                  raw_type.Require (matched_value_type);
                  raw_type
                | _ => matched_value_type
              }
              
            when (current_pattern_variables.Member (name))
              ReportError (messenger, 
                           $ "pattern variable `$(name)' already seen "
                             "in this pattern");

            def decl =
              if (common_variables == null || !common_variables.Member (name)) {
                DefineLocal (name, 
                             fixed_type,
                             LocalValue.Kind.PatternVariable (false),
                             false)
              } else {
                def decl = common_variables [name];
                decl.Type.Provide (fixed_type);
                when (messenger.SeenError) {
                  ReportError (messenger,
                               $ "$decl used to have type $(decl.Type) but now it "
                                         "has type $");
                  when (messenger.InErrorMode)
                    Message.hint ("rename variable if they have no connection");
                }
                decl
              }

            current_pattern_variables =
              current_pattern_variables.Add (name, decl);
              
            Pattern.As (typed_pattern, decl)

            
          | PT.PExpr.As (_, PT.Splicable.Expression) =>
            ReportError (messenger, 
                         "$ operator used outside of quotation <[ ... ]> "
                         "context");
            Pattern.Error ()
            

          | PT.PExpr.TypeEnforcement (nested, needed_type) =>
            def needed_type = BindType (needed_type);
            
            solver.PushState ();
            matched_value_type.Require (needed_type);
            def just_a_hint = !messenger.SeenError ();
            solver.PopState ();

            if (just_a_hint) {
              matched_value_type.Require (needed_type);
              TypePattern (nested, matched_value_type)
            } else {
              solver.PushState ();
              matched_value_type.Provide (needed_type);
              def properly_subtypes = !messenger.SeenError ();
              solver.PopState ();

              if (properly_subtypes) {
                matched_value_type.Provide (needed_type);
              } else {
                if (needed_type.IsInterface ||
                    Option.UnSome (matched_value_type.UpperBound)
                       .IsInterface) {
                  // ok, we allow interfaces here
                } else
                  ReportError (messenger,
                               $ "matched value has type $matched_value_type "
                                 "while the pattern enforces $needed_type")
              }

              match (needed_type) {
                | MType.Class (ti, _) => ti
                  def typed_pattern =
                    Pattern.HasType (pattern.loc, matched_value_type, ti);
                  match (TypePattern (MonoType (needed_type), nested)) {
                    | Pattern.As (Pattern.Wildcard, decl) =>
                      Pattern.As (pattern.loc, matched_value_type, 
                                  typed_pattern, decl)
                    | Pattern.Wildcard => typed_pattern
                    | _ =>
                      ReportError (messenger,
                                   "only variable patterns are allowed "
                                   "(here : type)");
                      Pattern.Error ()
                  }
                | _ =>
                  ReportError (messenger,
                               $ "invalid type in (x : type) pattern: "
                                 "$needed_type");
                  Pattern.Error ()
              }
            }


          | PT.PExpr.Wildcard => Pattern.Wildcard ()


          | PT.PExpr.Literal (lit) =>
            matched_value_type.Unify (typer.TypeOfLiteral (lit));
            Pattern.Literal (lit)


          | PT.PExpr.Tuple (pats) =>
            TypeTuplePattern (matched_value_type, pats)
            

          | PT.PExpr.Ref
          | PT.PExpr.Member => 
            TypeApplication (pattern, PT.PExpr.Wildcard ())

             
          | PT.PExpr.Call (PT.PExpr.Ref (n), _) when ConstantFolder.is_known_operator (n.Id) => 
            TypePattern (matched_value_type, 
                         ConstantFolder.FoldConstants (typer, pattern))
                         

          | PT.PExpr.Application (f, PT.PExpr.Wildcard)
          | PT.PExpr.Call (f, []) =>
            TypeApplication (f, PT.PExpr.Wildcard ())


          | PT.PExpr.Application (f, pa) => 
            TypeApplication (f, PT.PExpr.Tuple ([pa]))

          
          | PT.PExpr.Call (f, args) =>
            TypeApplication (f, PT.PExpr.Tuple (args))
            

          | PT.PExpr.TypedPattern (body) => body

              
          | PT.PExpr.Quoted (parse_element) =>
            // we use Macros functions to translate quoted element
            Macros.in_pattern = true;          
            def lifted = 
              match (parse_element) {
                | PT.SyntaxElement.Expression (e) => Macros.quoted_expr (ctx, e)
                | PT.SyntaxElement.MatchCase (e) => Macros.QuotedMatchCase (ctx, e)
                | PT.SyntaxElement.MatchCaseGuard (a, b) => Macros.QuotedCaseGuard (ctx, (a, b))
                | PT.SyntaxElement.Function (e) => Macros.quoted_fundecl (ctx, e)
                | PT.SyntaxElement.Parameter (e) => Macros.quoted_fparam (ctx, e)
                | PT.SyntaxElement.ClassMember (e) => Macros.quoted_member (ctx, e)                
                | PT.SyntaxElement.TType =>
                  Message.fatal_error ("matching over typed types not supported")
                | PT.SyntaxElement.TypeBuilder
                | PT.SyntaxElement.MethodBuilder
                | PT.SyntaxElement.EventBuilder
                | PT.SyntaxElement.FieldBuilder
                | PT.SyntaxElement.PropertyBuilder
                | PT.SyntaxElement.ParameterBuilder => 
                  Util.ice ("strange syntax element appeared in quotation")
              };
            Macros.in_pattern = false;            
            TypePattern (matched_value_type, Macros.patternize_quotation (lifted))
            

          | PT.PExpr.Spliced =>
            ReportError (messenger, 
                         "$ operator may appear only within <[ ... ]> quotation");
            Pattern.Error ()
            

          | PT.PExpr.Ellipsis =>
            ReportError (messenger, 
                         ".. arguments list may appear only within <[ ... ]> quotation");
            Pattern.Error ()
            
            
          | _ =>
            ReportError (messenger, "invalid pattern");
            Pattern.Error ()
        }
      }
    }
    #endregion


    #region Pretty printing
    DescribeExpression (expr : TExpr) : string
    {
      match (expr) {
        | TExpr.LocalRef (d) =>
          $ "a reference to local symbol `$(d)'"
        | TExpr.StaticRef (m) =>
          def tyname =
            if (m.DeclaringType == null)
              ""
            else
              m.DeclaringType.FullName + ".";
          "a reference to global symbol `" + tyname + m.Name + "'"
        | TExpr.FieldMember (_, f) =>
          "a reference to field `" + f.Name + "'"
        | TExpr.ConstantObjectRef (m) =>
          "a reference to constant constructor of `" +
          m.DeclaringType.FullName + "'"
        | TExpr.ImplicitValueTypeCtor (t) =>
          "a reference to implicit constructor of `" +
          t.FullName + "'"
        | TExpr.StaticPropertyRef (p)
        | TExpr.PropertyMember (_, p) =>
          "a reference to property `" + p.Name + "'"
        | TExpr.MethodRef (_, m, _) =>
          "a reference to method `" + m.Name + "'"
        | TExpr.TailCall (f, _)
        | TExpr.Call (f, _) =>
          "a function call to " + describe_expression (f)
        | TExpr.SelfTailCall =>
          "self-recursive function call"
        | TExpr.Assign => "an assignment"
        | TExpr.DefValIn => "a value binding"
        | TExpr.DefFunctionsIn => "a function binding"
        | TExpr.Match => "a `match' expression"
        | TExpr.Throw => "a throw expression"
        | TExpr.TryWith => "a try...with expression"
        | TExpr.TryFinally => "a try...finally expression"
        | TExpr.Literal => "a literal value"
        | TExpr.This => "a this pointer reference"
        | TExpr.Base => "a base class reference"
        | TExpr.TypeConversion => "a type conversion (:>)"
        | TExpr.TypeEnforcement => "a type enforcement (:)"
        | TExpr.Sequence => "a sequence"
        | TExpr.Tuple => "a tuple constructor"
        | TExpr.Array => "an array constructor"
        | TExpr.ArrayIndexer => "an array indexer reference"
        | TExpr.TypeOf => "a typeof expression"
        | TExpr.OpCode => "an operator reference"
      }
    }
    #endregion

  }
}


#region Old code
  ty_indexer (ctx : CTX, obj : PT.PExpr, args : list [PT.PExpr]) : TExpr * TType
  {
    def typed_objs =
      match (obj) {
        | <[ base ]> | <[ this ]> => [ty_expr (ctx, obj)]
        | _ =>  make_value_reference (ctx, obj, fallback = true);
      };
    match (typed_objs) {
      | TExpr.PropertyMember (_, prop) :: _ when is_indexer_property (prop) =>
        def typed_parms = List.Map (args, fun (x) {
          Parm (ty_expr (ctx, x))
        });
        def ex = resolve_overloaded_call (ctx, false, typed_objs, typed_parms);
        (ex, type_of (ex))

       [typed_obj] =>
        match (Tyutil.top_expand (typed_obj.ty)) {
          | TType.Array (indexer_over_type, rank) =>
            /* indexers over arrays */
            def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });
            
            mutable args_amount = rank;
            foreach (index in typed_args) {
              expect_type ("indexer type", index, InternalType.Int32);
              --args_amount;
            }
            when (args_amount != 0)
              Message.fatal_error ("wrong number of index parameters");

            def resolved_obj = convert_getter_property (typed_obj);
            (TExpr.ArrayIndexer (indexer_over_type, resolved_obj, typed_args),
             indexer_over_type)

          | TType.Class (tc, _) when Option.IsSome (tc.DefaultIndexerName) =>
            /* user-defined indexers */
            def member_name = Option.UnSome (tc.DefaultIndexerName);
            ty_indexer (ctx, <[ $(typed_obj : typed) . $(member_name : dyn) ]>, args)
            
          | _ =>
            def ty = typed_obj.ty;
            Message.fatal_error ($ "indexer applied to non-indexer type $ty")
        }

      | l =>
        Message.error ("expression is ambiguous:");
        foreach (ex in l) Message.error ("  " + describe_expression (ex));
        throw Recovery ()
    }
  }



  ty_sequence (ctx : CTX, l : list [PT.PExpr]) : TExpr
  {
    def in_tail_pos = ctx.in_tail_position;
    def orig_ctx = ctx;
    def ctx = ctx.WithInTailPosition (false);

    def go () : TExpr {
      match (l) {
        | [x] =>
          def x = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, x);
          ty_expr (orig_ctx, MacroRegistry.expand_macro (orig_ctx, ctx, x))

        | x :: xs =>
          def x = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, x);          
          match (MacroRegistry.expand_macro (ctx, ctx, x)) {
            | PT.PExpr.DefFunctions (fs) =>
              def (fs', ctx') = ty_letfun (ctx, fs);
              def body = ty_sequence (ctx'.WithInTailPosition (in_tail_pos), xs);
              fixup (TExpr.DefFunctionsIn (fs', body), type_of (body))

            | (PT.PExpr.Define) as x =>
              def val = ty_expr (ctx, x.val);
              def name = match (x.name) {
                | PT.Splicable.Name (n) => n
                | _ =>
                  Message.fatal_error ("$ operator used outside quotation "
                                       "<[ ... ]> context")
              };

              // check for mutable symbol redefinitions
              match (ctx.LookupLocal (name)) {
                | Some (l) when l.name == x.name.GetName ().Id =>
                  def warn =
                    if (x.is_ref && l.is_ref)
                      Some (("mutable", ""))
                    else if (!x.is_ref && l.is_ref)
                      Some (("mutable", " as non-mutable"))
                    else if (x.is_ref && !l.is_ref)
                      Some (("non-mutable", " as mutable"))
                    else
                      None ();

                  match (warn) {                    
                    | Some ((was_of_kind, is_of_kind)) =>                      
                      Message.warning (x.loc, "redefinition of a local " +
                                       was_of_kind + " value `" + l.name +
                                       "'" + is_of_kind);
                      Message.warning (l.loc, "  <-- previously seen here")
                    | _ => ()                      
                  }                      
                | _ => ()
              }
              
              def decl = ctx.DefineLocal (name, LocalValueKind.LocalVariable(), type_of (val));
              decl.is_ref = x.is_ref;
              def body = ty_sequence (ctx.WithLocal (decl).
                                      WithInTailPosition (in_tail_pos), xs);
              fixup (TExpr.DefValIn (decl, val, body), type_of (body))

            | PT.PExpr.DefPattern (p, v) =>
              def body = PT.PExpr.Sequence (xs);
              def mtch = PT.PExpr.Match (p.loc, v, [PT.MatchCase ([(p, None ())], body)]);
              body.loc = (List.Head (xs)).loc;
              ty_expr (orig_ctx, mtch)

            | x =>
              def ex = ty_expr (ctx, x);
              def t = type_of (ex);
              if (t >:> TType.Void ()) {
                def tl = ty_sequence (orig_ctx, xs);
                fixup (TExpr.Sequence (ex, tl), type_of (tl))
              }
              else {
                when (Options.IgnoredValueWarnings) {
                  Message.warning ($ "ignored computed value of type $t");
                  Message.hint_once ("use _ = ...; or -Wno-ignore to avoid the warning");
                }

                def tmp = Util.tmpname ("ign");
                def decl = ctx.DefineLocal (tmp, 1, LocalValueKind.LocalVariable (), type_of (ex));
                def body = ty_sequence (ctx.WithLocal (decl).
                                        WithInTailPosition (in_tail_pos), xs);
                fixup (TExpr.DefValIn (decl, ex, body), type_of (body))
              }
          }
        | [] => Util.ice ("empty sequence")
      }
    };

    Util.locate ((List.Head (l)).loc, go ())
  }



  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.PExpr.Match) : TExpr * TType
  {
    def itp = ctx.in_tail_position;
    def ctx = ctx.WithInTailPosition (false);
    def matched_value = ty_expr (ctx, mtch.expr);
    mutable disable_warnings = false;

    def do_case (c : PT.MatchCase, acc) {
      when (c.disable_warnings) disable_warnings = true;
      def (pat, ctx') = PatternTyping.TypePatterns (ctx, type_of (matched_value), c.patterns);
      def body = ty_expr (ctx'.WithInTailPosition (itp), c.body);
      match (acc) {
        | (Some (t), l) =>
          match (Tyutil.unify_branches (t, type_of (body))) {
            | Some (t') => (Some (t'), Match_case (pat, body) :: l)
            | None =>
              expect_type ("match case body", body, t);
              Util.ice () // not reached
          }
        | (None, l) =>
          (Some (type_of (body)), Match_case (pat, body) :: l)
      }
    };

    match (List.FoldLeft (mtch.cases, (None (), []), do_case)) {
      | (Some (t), mcs') =>
        def mcs = List.Rev (mcs');
        unless (disable_warnings) PatternTyping.check_matching (mcs);
        foreach (mc : Match_case in mcs) {
          mc.patterns = 
            List.Map (mc.patterns, 
                      fun (p, e) { 
                         (PatternTyping.strip_enums (p), e) 
                      });
          mc.body = TExpr.TypeEnforcement (mc.body, t);
        }
        (TExpr.Match (matched_value, mcs), t)
      | (None, _) =>
        Message.fatal_error ("cannot have empty match construct");
    }
  }



  ty_letfun (ctx : CTX, fs : list [PT.Function_decl]) : list [Fun_header] * CTX
  {
    def make_fun (d : PT.Function_decl) {
      def pars = {
        def h = ctx.current_fun;
        h :: h.GetParents ()
      };

      def h = d.header;
      def name_obj = h.name.GetName ();
      def (tenv, typarms) = ctx.parent_type.BindTyparms (ctx.tenv, h.typarms);
      def mkparm (p : PT.Fun_parm) : Fun_parm {
        def name = p.name.GetName ();
        Fun_parm (loc = p.loc, name = name.Id, color = name.color,
                  ty = ctx.parent_type.BindType (tenv, p.ty), decl = null,
                  modifiers = p.modifiers)
      };
      def h' = Fun_header (
         ret_type = ctx.parent_type.BindType (tenv, h.ret_type),
         typarms = typarms,
         name = name_obj.Id,
         parms = List.Map (h.parms, mkparm),
         tenv = tenv,
         loc = h.loc);

      def lv = ctx.DefineLocal (name_obj,
                                LocalValueKind.Function (h', pars), 
                                Tyutil.fun_type (h'));
      h'.decl = lv;
      h'
    };

    def headers = List.Map (fs, make_fun);
    def localvals = List.Map (headers, fun (h : Fun_header) { h.decl });
    def ctx = ctx.WithLocals (localvals);
    def loop (headers : list [Fun_header], parsed : list [PT.Function_decl]) {
      | (h :: hs, d :: ds) => h.body = ty_function (ctx, h, d.body); loop (hs, ds);
      | _ => () // both must / will be empty
    } 
    loop (headers, fs);
    (headers, ctx)
  }

#endregion
