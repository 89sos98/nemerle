(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyvars;
open Nemerle.Compiler.Tyops;

namespace Nemerle.Compiler {

  class Tyvars
    {
      class Tyvar
        {
          name : string;
          ref constraints : list (Type);
          ref is_free : bool;
        }
        
      static ref tyvars : Int_map (Tyvar);
      static ref typarms : Int_map (list (int));

      static ref global_subst : Subst;

      static global_store (s : Subst) : void {
        if global_subst == null then
          global_subst <- Map.int_map () else ();
        letfun f (s : Subst, id : int, t : Type) : Subst {
          (Util.unsome (tyvars.find (id))) . is_free <- false;
          s.add (id, t)
        } in global_subst <- s.fold (f, global_subst)
      }

      static global_expand (t : Type) : Type =
        if global_subst == null then t
        else t /- global_subst;
      
      static this () 
        { 
          tyvars <- Map.int_map(); 
          typarms <- Map.int_map(); 
        }

      static add (name : string) : int =
        let id = Util.next_id() in {
          tyvars <- tyvars.add(id, Tyvar(name, Nil(), false));
          id
        };

      static fresh_subst (parms : list (int)) : Subst =
        letfun loop (ctx : Subst * list (Tyvar), proto_id : int) : Subst * list (Tyvar) =
          let proto = Util.unsome (tyvars.find (proto_id)) in
          let id = Util.next_id() in
          let (sub, vars) = ctx in
          let tv = Tyvar(proto.name, proto.constraints, true) in { 
            tyvars <- tyvars.add (id, tv); 
            (sub.add (proto_id, T_var (proto.name, id)),
             Cons (tv, vars))
          }
        in
        let (sub, vars) = List.fold_left (loop, (Map.int_map (), Nil ()), parms) in
        letfun sub_constraints (tv : Tyvar) : void =
          tv.constraints <- List.map (fun (t : Type) : Type => t /- sub, tv.constraints)
        in {
          List.iter (sub_constraints, vars);
          sub
        };

      static free_variable () : Type =
        let id = Util.next_id() in {
          tyvars <- tyvars.add (id, Tyvar("", Nil(), true));
          T_var ("", id)
        };

      static is_free (id : int) : bool =
        match tyvars.find(id) with [
          | Some (tv) => tv.is_free
          | None => Util.ice()
        ];

      static add_constraint (id : int, ty : Type) : void =
        match tyvars.find(id) with [
          | Some (tv) => tv.constraints <- Cons(ty, tv.constraints)
          | None => Util.ice()
        ];

      static constraints (id : int) : list (Type) =
        match tyvars.find(id) with [
          | Some (l) => l.constraints
          | None => Nil ()
        ];

      static name (id : int) : string =
        match tyvars.find(id) with [
          | Some (l) => l.name
          | None => "?"
        ];

      static set_parms (id : int, parms : list (int)) : void =
        typarms <- typarms.add(id, parms);
        
      static get_parms (id : int) : list (int) = 
        match typarms.find(id) with [
          | Some (x) => x
          | None => Util.ice()
        ];
        
    }

} // end ns
