/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  public class Typer3
  {
    // this can be Fun_header of a function expanded to a loop:
    current_fun : Fun_header;
    // and this not:
    mutable real_current_fun : Fun_header;
    mutable current_closure : LocalValue;
    mutable local_function_type : TypeBuilder;
    current_type : TypeBuilder;
    messenger : Messenger;
    mutable static_proxies : Hashtable [int, IField] = Hashtable ();
    mutable closure_fields : Hashtable [int, IField] = Hashtable ();
    mutable start_label : TExpr.Label;


    #region Entry points
    public this (ty : TypeBuilder, fn : Fun_header)
    {
      current_fun = fn;
      current_type = ty;
      real_current_fun = current_fun;

      messenger = Passes.Solver.CurrentMessenger;
    }


    public Run () : void
    {
      Util.locate (current_fun.loc, {
        start_label = TExpr.Label (null, null);

        def initializers = PrepareProlog ();

        match (current_fun.body) {
          | FunBody.Typed (body) =>
            // FIXME: Typed3
            current_fun.body = FunBody.Typed (start_label);
            start_label.body = BuildRevSequence (Walk (body) :: initializers);
          | _ => assert (false)
        }
      })
    }
    #endregion


    #region Utilities
    // expects reversed list
    BuildRevSequence (exprs : list [TExpr]) : TExpr
    {
      match (exprs) {
        | [] =>
          TExpr.Literal (InternalType.Void, Literal.Void ())
        | x :: xs =>
          def loop (acc, l) {
            match (l) {
              | [] => acc
              | TExpr.DefValIn (name, val, null) :: xs =>
                loop (TExpr.DefValIn (acc.Type, name, val, acc), xs)
              | x :: xs =>
                loop (TExpr.Sequence (acc.Type, x, acc), xs)
            }
          }
          loop (x, xs)
      }
    }


    SingleMemberLookup (tb : TypeInfo, name : string) : IMember
    {
      match (tb.LookupMember (name)) {
        | [mem] => mem
        | _ => assert (false)
      }
    }


    IsTopLevelFun : bool
    {
      get { real_current_fun.decl == null }
    }


    /** Just a shorthand for TExpr.LocalRef.  */
    PlainRef (decl : LocalValue) : TExpr
    {
      assert (decl != null);
      TExpr.LocalRef (decl.Type, decl)
    }


    StaticRef (mem : IMember) : TExpr
    {
      assert (mem is IMethod || mem is IField);
      TExpr.StaticRef (mem.GetMemType (), mem)
    }
    #endregion


    #region Local reference through closures
    /** Return code referencing closure of [hd].  */
    ClosureRef (hd : Fun_header) : TExpr
    {
      if (hd.id == real_current_fun.id) {
        PlainRef (current_closure)
      } else {
        assert (closure_fields.Contains (hd.id));
        TExpr.FieldMember (TExpr.This (local_function_type.GetMemType ()),
                           closure_fields [hd.id])
      }
    }


    LocalRef (decl : LocalValue) : TExpr
    {
      LocalRef (decl, for_store = false)
    }


    LocalRef (decl : LocalValue, for_store : bool) : TExpr
    {
      def decl = decl.Redirect;
      def is_this = decl.ValKind is LocalValue.Kind.ClosurisedThisPointer;

      def res =
        if (decl.InClosure)
          if (!for_store && is_this && IsTopLevelFun)
            TExpr.This ()
          else {
            assert (decl.ClosureField != null);
            TExpr.FieldMember (ClosureRef (decl.DefinedIn), decl.ClosureField)
          }
        else if (is_this)
          TExpr.This ()
        else
         PlainRef (decl);

      res.ty = decl.Type;
      res
    }
    #endregion


    #region Proxies
    AddTupledMethod (tb : TypeBuilder, parm_cnt : int) : void
    {
      if (parm_cnt == 0)
        tb.Define (<[ decl:
          public apply (_ : object) : object {
            apply ()
          } ]>)
      else if (parm_cnt == 1) {}
      else {
        def objects = List.Repeat (<[ object ]>, parm_cnt);
        tb.Define (<[ decl:
          public apply (o : object) : object
          {
            apply (o :> @* (.. $objects))
          }
        ]>);
      }
    }
    

    EmitStaticProxy (meth : IMethod) : TExpr
    {
      unless (static_proxies.Contains (meth.GetId ())) {
        def parms = meth.GetHeader ().parms;
        def parm_cnt = parms.Length;
        def fnty = InternalType.GetFunctionType (parm_cnt).InternalType;
        
        def name = Util.tmpname ("_N_static_proxy");
        def parm_names =
          parms.Map (fun (_) { Util.tmpname ("_N_sp_parm") });
        def formal_parms =
          parm_names.Map (fun (name) { <[ parameter: $(name : dyn) : object ]> });
        def parm_refs =
          List.Map2 (parm_names, parms, fun (name, parm) {
            <[ $(name : dyn) :> $(parm.ty : typed) ]> 
          });
          
        def builder =
          current_type.DefineNestedType (<[ decl:
            private class $(name : dyn) : $(fnty : typed)
            {
              public single_instance : $(name : dyn);
              static this ()
              {
                single_instance = $(name : dyn) ();
              }

              public apply (.. $formal_parms) : object
              {
                $(StaticRef (meth) : typed) (.. $parm_refs)
              }
            }
          ]>);

        AddTupledMethod (builder, parm_cnt);
        
        builder.MarkWithSpecialName ();
        builder.Compile ();

        static_proxies [meth.GetId ()] =
          SingleMemberLookup (builder, "single_instance") :> IField;
      }

      def field = static_proxies [meth.GetId ()];
      StaticRef (field)
    }
    

    EmitDelegateProxy (expr : TExpr) : TExpr * IMethod
    {
      def decl =
        match (expr.Type.Fix ()) {
          | MType.Fun (from, ret_type) as ty =>
            def parms =
              from.Fix ().GetFunctionArguments ().Map (fun (ty) {
                def name = Util.tmpname ("_N_parm");
                (<[ parameter: $(name : dyn) : $(ty : typed) ]>,
                 <[ $(name : dyn) ]>)
              });
            def (parms, parm_refs) = List.Split (parms);
            
            <[ decl: 
              private class $(Util.tmpname ("_N_delegate_proxy") : dyn)
              {
                funptr : $(ty : typed);
                public this (fp : $(ty : typed))
                {
                  funptr = fp;
                }

                public InvokeDelegate (.. $parms) : $(ret_type : typed)
                {
                  funptr (.. $parm_refs)
                }
              }
            ]>

          | _ => assert (false)
        }

      def tb = current_type.DefineNestedType (decl);
      tb.MarkWithSpecialName ();
      tb.Compile ();

      def ctor = SingleMemberLookup (tb, ".ctor");

      def ctor_call =
        TExpr.Call (tb.GetMemType (), StaticRef (ctor), [Parm (expr)]);

      (ctor_call, SingleMemberLookup (tb, "InvokeDelegate") :> IMethod)
    }
    #endregion


    #region Function prolog
    PrepareClosure () : list [TExpr]
    {
      if (current_fun.closure_vars.IsEmpty) []
      else {
        def clo_type = current_type.DefineNestedType (<[ decl:
          private class $(Util.tmpname ("_N_closure") : dyn)
          {
            internal this () {}
          }
        ]>);
        current_fun.closure_type = clo_type;
        def closure_val =
          LocalValue (current_fun, "_N_closure", clo_type.GetMemType (), 
                      LocalValue.Kind.Plain (), is_mutable = false);
        current_closure = closure_val;
        foreach (decl in current_fun.closure_vars) {
          def ptdecl = <[ decl: 
            internal mutable 
              $(Util.tmpname (decl.Name) : dyn) : $(decl.Type : typed);
          ]>;
          def fld = Option.UnSome (clo_type.DefineAndReturn (ptdecl));
          decl.ClosureField = fld :> IField;
        }
        def ctor = SingleMemberLookup (clo_type, ".ctor");
        def ctor_call = 
          TExpr.Call (clo_type.GetMemType (),
                      StaticRef (ctor), []);
                      
        clo_type.MarkWithSpecialName ();
        clo_type.Compile ();

        [TExpr.DefValIn (InternalType.Void, closure_val, ctor_call, null)]
      }
    }


    LoadParameters () : list [TExpr]
    {
      mutable initializers = [];
      
      foreach (fp in current_fun.parms) {
        def parm = fp.decl;

        if (parm.InClosure) {
          def a = TExpr.Assign (InternalType.Void,
                                LocalRef (parm, for_store = true), 
                                PlainRef (parm));
          
          initializers = a :: initializers
        // this should be dead code with generics
        } else if (fp.ty.Fix ().IsSystemObject && ! parm.Type.Fix ().IsSystemObject) {
          def local = LocalValue (current_fun, parm.Name, parm.Type, 
                                  LocalValue.Kind.Plain (), is_mutable = parm.IsMutable);
          parm.Redirect = local;
          def val =
            TExpr.TypeConversion (parm.Type,
                                  TExpr.LocalRef (fp.ty, parm),
                                  parm.Type,
                                  ConversionKind.IL (true));
                                 
          def a = TExpr.DefValIn (InternalType.Void, local, val, null);
          initializers = a :: initializers
        } else {}
      }

      initializers
    }


    GetBaseCall () : option [TExpr]
    {
      // put base () / this () call before storing 'this' in closure inside constructor
      if (current_fun.name == ".ctor" && !current_type.IsValueType)
        match (current_fun.body) {
          | FunBody.Typed (TExpr.Sequence (TExpr.Call as basecall, rest)) =>
            current_fun.body = FunBody.Typed (rest);
            Some (Walk (basecall))

          | FunBody.Typed (TExpr.Call as basecall) =>
            current_fun.body = FunBody.Typed (BuildRevSequence ([]));
            Some (Walk (basecall))

          | FunBody.Typed (TExpr.TailCall as basecall) =>
            current_fun.body = FunBody.Typed (BuildRevSequence ([]));
            Some (Walk (basecall))
            
          | FunBody.Typed (body) =>
            Message.Warning (body.loc, body.ToString ());
            assert (false)

          | _ => assert (false)
        }
      else None ()
    }
    

    // the result is reversed!
    PrepareProlog () : list [TExpr]
    {
      // assigments of parameters and 'this' to closure fields
      // interleaved with base (..) call in constructor
      mutable initializers = [];

      // we build the initialization stuff of method:
      // 1. method's closure ctor()
      // 2. store parameters into closure
      // 3. base (..) / this (..) for constructors
      // 4. store 'this' in closure

      initializers = PrepareClosure ();

      initializers = LoadParameters () + initializers;

      match (GetBaseCall ()) {
        | Some (call) =>
          initializers = call :: initializers;
        | None => {}
      }

      // store 'this' into closure object
      foreach (d in current_fun.closure_vars) 
        when (d.InClosure && 
              d.ValKind is LocalValue.Kind.ClosurisedThisPointer) {
          def ini =
            TExpr.Assign (InternalType.Void,
                          LocalRef (d, for_store = true),
                          TExpr.This (current_type.GetMemType ()));
          initializers = ini :: initializers;
        }

      initializers
    }
    #endregion


    #region Local function generation
    ParentsWithClosures (h : Fun_header) : list [Fun_header]
    {
      def loop (fh : Fun_header, acc) {
        match (fh.closure_vars) {
          | [] => acc
          | vars => 
            if (vars.Exists (fun (var) {
                // FIXME: doesn't work, because function have to be removed from external closures
                //var.id != h.decl.id && // call to our function shouldn't be closurised
                (h :: h.children_funs).Exists (fun (child) { 
                  var.UsedIn.Contains (child) 
                })
              })) 
              fh :: acc
            else
              acc
        }
      }
      List.FoldLeft (h.GetParents (), [], loop);
    }


    EmitStaticLocalFunction (fn : Fun_header) : void
    {
      def parms = fn.parms.Map (fun (fp) {
        <[ parameter: $(fp.decl.Name : dyn) : $(fp.decl.Type : typed) ]>
      });
        
      def meth =
        Option.UnSome (current_type.DefineAndReturn (<[ decl:
          private $(Util.tmpname (fn.name) : dyn) (.. $parms) 
                    : $(fn.ret_type : typed)
          {
          }
        ]>)) :> IMethod;

      fn.static_method = meth;
      def new_header = meth.GetHeader ();
      
      List.Iter2 (fn.parms, new_header.parms, fun (orig : Fun_parm, copy) {
        orig.decl = copy.decl;
      });

      new_header.body = fn.body;

      def child = Typer3 (current_type, new_header);
      // the child can reuse our static proxies
      child.static_proxies = static_proxies;
      child.Run ();
    }


    EmitFunctionalValue (fn : Fun_header, closures : list [Fun_header]) : TExpr
    {
      def parm_cnt = fn.parms.Length;
      def fnty = InternalType.GetFunctionType (parm_cnt).InternalType;
      
      def formal_parms =
        fn.parms.Map (fun (fp) { <[ parameter: 
          $(fp.name : dyn) : object
        ]> });

      def builder = current_type.DefineNestedType (<[ decl:
        private class $(Util.tmpname ("_N_lm") : dyn) : $(fnty : typed)
        {
          public apply (.. $formal_parms) : object
          {
          }
        }
      ]>);

      def closure_fields = Hashtable ();

      def (parms, assigns) =
        List.Split (closures.Map (fun (hd) {
          def name = Util.tmpname (hd.name + "_clo");
          assert (hd.closure_type != null);
          def clo_type = hd.closure_type.GetMemType ();
          def field =
            Option.UnSome (builder.DefineAndReturn (<[ decl: 
              $(name : dyn) : $(clo_type : typed) 
            ]>)) :> IField;
          closure_fields [hd.id] = field;
          (<[ parameter: $(name : dyn) : $(clo_type : typed) ]>,
           <[ this . $(name : dyn) = $(name : dyn) ]>)
        }));

      def ctor =
        builder.DefineAndReturn (<[ decl:
          public this (.. $parms)
          {
            { .. $assigns }
          }
        ]>);
      def ctor = Option.UnSome (ctor);
      
      def the_method = SingleMemberLookup (builder, "apply") :> IMethod;
      AddTupledMethod (builder, parm_cnt);

      def new_header = the_method.GetHeader ();
      List.Iter2 (fn.parms, new_header.parms, fun (orig : Fun_parm, copy) {
        orig.decl = copy.decl;
      });

      new_header.body = fn.body;

      def child = Typer3 (current_type, new_header);
      child.local_function_type = builder;
      child.closure_fields = closure_fields;
      child.Run ();

      builder.MarkWithSpecialName ();
      builder.Compile ();

      def ctor_parms = closures.Map (fun (hd) { Parm (ClosureRef (hd)) });
      TExpr.Call (fnty, StaticRef (ctor), ctor_parms)
    }

    
    HandleLocalFunction (fn : Fun_header, is_single : bool) : list [TExpr]
    {
      def closures = ParentsWithClosures (fn);
      
      match (fn.usage) {
        | FunctionUsage.UsedJustOnce => 
          // handled in EmitLoop
          []

        | FunctionUsage.NotUsed =>
          // obvious
          []

        | FunctionUsage.Used when is_single && closures.IsEmpty =>
          EmitStaticLocalFunction (fn);
          []

        | FunctionUsage.Used
        | FunctionUsage.UsedAsFirstClass =>
          def fval = EmitFunctionalValue (fn, closures);
          assert (fn.decl != null);
          [TExpr.DefValIn (fn.decl, fval, null)] 
      }
    }
    #endregion
    

    #region Language constructs
    EmitLoop (hd : Fun_header, parms : list [Parm]) : TExpr
    {
      def child = Typer3 (current_type, hd);
      child.real_current_fun = current_fun;
      // the child can reuse our static proxies and our closure
      child.static_proxies = static_proxies;
      child.current_closure = current_closure;
      child.Run ();

      def body =
        match (hd.body) {
          | FunBody.Typed (x) => x
          | _ => assert (false);
        }

      // need to pass parameters
      def assigns = List.RevMap2 (parms, hd.parms, fun (actual, formal) {
        assert (actual.kind == ParmKind.Normal);
        TExpr.DefValIn (formal.decl, actual.expr, null)
      });

      BuildRevSequence (body :: assigns);
    }


    EmitDelegateCtor (ctor : IMethod, parm : TExpr) : TExpr
    {
      def (obj, meth) =
        match (parm) {
          | TExpr.StaticRef (meth is IMethod) =>
            (TExpr.Literal (InternalType.Object, Literal.Null ()),
             meth)
             
          | TExpr.MethodRef (obj, meth, _) =>
            (Walk (obj), meth)
            
          | _ =>
            EmitDelegateProxy (Walk (parm))
        }

      TExpr.Call (ctor.DeclaringType.GetMemType (),
                  StaticRef (ctor),
                  [Parm (obj), Parm (TExpr.MethodAddress (meth))])
    }


    EmitCall (func : TExpr, parms : list [Parm], is_tail : bool) : TExpr
    {
      foreach (p in parms)
        p.expr = Walk (p.expr);

      def just_call (func) {
        if (is_tail)
          TExpr.TailCall (func, parms)
        else
          TExpr.Call (func, parms)
      }

      def plain_call () {
        def meth = InternalType.GetFunctionType (parms.Length).ApplyMethod;
        just_call (TExpr.MethodRef (func.ty, Walk (func), meth, false))
      }

      match (func) {
        // check if it's a base.Foo call
        | TExpr.MethodRef (
           TExpr.LocalRef (ty = ty, 
                           decl = LocalValue where (ValKind = 
                                      LocalValue.Kind.ClosurisedThisPointer) as decl) as obj, 
                         meth, _) when ! ty.Equals (decl.Type) =>
          just_call (TExpr.MethodRef (func.ty, Walk (obj), meth, true))
                           
        | TExpr.MethodRef (obj, meth, notvirt) =>
          just_call (TExpr.MethodRef (func.ty, Walk (obj), meth, notvirt))
          
        | TExpr.StaticRef (_ is IMethod)
        | TExpr.OpCode
        | TExpr.Base =>
          just_call (func)

        | TExpr.LocalRef (LocalValue where 
                          (ValKind = LocalValue.Kind.Function (hd, _))) =>
          match (hd.usage) {
            | FunctionUsage.UsedJustOnce =>
              EmitLoop (hd, parms)

            | _ =>
              if (hd.static_method != null)
                just_call (StaticRef (hd.static_method))
              else
                plain_call ()
          }

        | _ => plain_call ()
      }
    }
    #endregion


    #region Top level stuff
    Walk (expr : TExpr) : TExpr
    {
      expr.Walk (DoWalk)
    }


    DoWalk (expr : TExpr) : TExpr
    {
      //Message.Debug ($ "dowalk: $(expr.GetType()) $(expr)");
      match (expr) {
        | TExpr.LocalRef (decl) =>
          LocalRef (decl)
          
        | TExpr.StaticRef (_ is IField) =>
          null

        | TExpr.StaticRef (meth is IMethod) =>
          EmitStaticProxy (meth)

        // we do not support any other staticrefs here
        // everything should be handled by Typer2 already
        | TExpr.StaticRef => assert (false)
          
        | TExpr.DefFunctionsIn (funs, body) =>
          def res =
            match (funs) {
              | [single] =>
                HandleLocalFunction (single, is_single = true);
              | _ =>
                List.Flatten (funs.Map (fun (fn) {
                  HandleLocalFunction (fn, is_single = false)
                }))
            }
          BuildRevSequence (Walk (body) :: res)

        // handled by Typer2.LambdaTransform
        | TExpr.MethodRef => assert (false)

        | TExpr.Call (TExpr.StaticRef (m is IMethod), [parm])
          when
            m.GetFunKind () is FunKind.Constructor && 
            m.DeclaringType.IsDelegate =>
          EmitDelegateCtor (m, parm.expr)

        | TExpr.TailCall (func, parms)
        | TExpr.Call (func, parms) =>
          EmitCall (func, parms, expr is TExpr.TailCall)

        | TExpr.SelfTailCall (parms) =>
          def assigns =
            List.Map2 (parms, current_fun.parms, fun (parm, fp) {
              assert (parm.kind == ParmKind.Normal);
              (fp.decl, parm.expr)
            });

          def beg =
            if (assigns.IsEmpty)
              [] 
            else
              [TExpr.MultipleAssign (InternalType.Void, assigns)];
              
          def goto = TExpr.Goto (InternalType.Void, start_label);
          
          BuildRevSequence (goto :: beg)

        | _ => null
      }
    }
    #endregion
  }
}
