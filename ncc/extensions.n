(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyexpr;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler.Extensions;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Extensions {

  public implicit_ctor (par : Tyinfo) : list (IMember) {
    def collect (acc, mem : IMember) {
      match (mem.GetKind ()) {
        | MK_field =>
          def n = mem.GetName ();
          def fp = Fun_parm (loc = par.GetLocation (), name = n, ty = mem.GetMemType (), decl = null);
          def ex = PT.E_assign (PT.E_member (PT.E_this (), PT.SS_string (n)), 
                                PT.E_ref (n));
          def (es, ps) = acc;
          (ex :: es, fp :: ps)
        | _ => acc
      }
    };

    def make_ctor (base_ctor : IMember) : IMember {
      def base_ctor = (base_ctor :> IMethod);
      def (ctor_parms, base_call) =
        if (base_ctor == null) ([], PT.E_literal (L_void ()))
        else {
          def pp = base_ctor.GetHeader ().parms;
          def callparms = List.map (fun (fp : Fun_parm) { PT.Parm (PT.E_ref (fp.name)) }, pp);
          (List.map (fun (fp : Fun_parm) {
                       Fun_parm (loc = par.GetLocation (), name = fp.name, 
                                 ty = fp.ty, decl = null)
                     }, pp),
           PT.E_call (PT.E_base (), callparms))
        };

      def (assigns, parms) = List.fold_left (collect, ([], []), par.GetDirectMembers ());
      def fh = Fun_header (loc = par.GetLocation (), 
                           name = ".ctor", 
                           id = Util.next_id (),
                           ret_type = T_void (), 
                           parms = List.append (ctor_parms, List.rev (parms)),
                           typarms = [],
                           tenv = par.tenv,
                           closure_vars = [],
                           decl = null);
      def bogus_fh = PT.Fun_header (loc = par.GetLocation (), name = ".ctor", ret_type = PT.T_void (), parms = []);
      def body = PT.E_sequence (base_call :: assigns);
      body.loc <- par.GetLocation ();
      def f = PT.M_function (modifiers = [Mod_public ()], loc = fh.loc, name = fh.name, 
                             header = bogus_fh, kind = FK_ctor (), body = FB_parsed_expr (body));
      def memb = NemerleMethod (par, (f :> PT.M_function));
      memb.SetHeader (fh);
      memb
    };
      
    match (par.SuperClass ()) {
      | Some (baseti) =>
        def decls = baseti.LookupMember (".ctor", LF_instance ());
        def is_ctor (m : IMember) {
          match (m.GetKind ()) {
            | MK_method (m) => 
              match (m.GetFunKind ()) {
                | FK_ctor => true
                | _ => false
              }
            | _ => false
          }
        };
        match (List.filter (is_ctor, decls)) {
          | [] => 
            match (baseti.GetTydecl ()) {
              | TD_variant => [make_ctor (null)]
              | _ =>
                Message.fatal_error ("type `" + baseti.GetFullName () + "' (base of `" + 
                                     par.GetFullName () + "') has no constructors, cannot " +
                                     "generate default constructor")
            }
          | decls =>
            List.map (make_ctor, decls)
        }
      | None =>
        [make_ctor (null)]
    }
  }

  public get_params (pa : list (PT.Parm)) : list (PT.Expr)
    {
      def get_parm (p : PT.Parm) : PT.Expr { p.expr };
      List.map (get_parm, pa)
    }

  
  (* HARD WRITTEN MACROS SECTION ***************************************)

  (** MACROS EXTENDING SYNTAX OF LANGUAGE *)

  (** this macro provides convenient way to write simple while loop,
      which perform execution of [body] parameter as long as
      [condition] is true
      <parm>condition</parm>
      <parm>body</body>
      <remarks>
        macro is registered as _N_while, but parser provides syntax
        shotcut [while (condition) { body }] for using while
      </remarks>
    *)
  private macro whilemacro (cond, body) : PT.Expr 
          syntax ("while", "(", cond, ")", body) {
    <[ { def _N_whileloop () : void {
           if ($cond) { $body; _N_whileloop() } 
           else () 
         }; 
         _N_whileloop (); 
       } 
    ]>
  }

  private macro formacro (init, cond, change, body) : PT.Expr 
          syntax ("for", "(", init, ";", cond, ";", change, ")", body) {
    <[ { $init;
         def _N_forloop () : void {
           when ($cond) { $body; $change; _N_forloop() } 
         }; 
         _N_forloop (); 
       } 
    ]>
  }

  (** shortcut for [if (cond) () else body] *)
  private macro unlessmacro (cond, body) : PT.Expr 
          syntax ("unless", "(", cond, ")", body) {
    <[ if ($cond) () else $body ]>
  }

  (** shortcut for [if (cond) body else ()] *)
  private macro whenmacro (cond, body) : PT.Expr 
          syntax ("when", "(", cond, ")", body) {
    <[ if ($cond) $body else () ]>
  }

  (** macro providing C# 'using' functionality
      http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vclrfusingstatement.asp
   *)
  private macro usingmacro (args : list(parm)) : PT.Expr
          syntax ("using", "(", args, ")", body) 
  {
    def store_exprs (args : list(PT.Parm), acc)
    {
      def (preexprs, postexprs) = acc;

      match (args) {
        | [] => acc
        | {is_ref = false; name = ""; expr = ex } :: xs =>
          store_exprs (xs, (preexprs, <[ $ex . Dispose () ]> :: postexprs))
        | {is_ref = false; name = str; expr = ex } :: xs =>
          def name = PT.SS_string (str);
          store_exprs (xs, (<[ def $name = $ex ]> :: preexprs, 
                            <[ $(str : var).Dispose () ]> :: postexprs))

        | _ => Message.fatal_error ("Invalid parameters in 'using' macro")
      }
    };

    match (List.rev (args)) {
      | {is_ref = false; name = ""; expr = body } :: xs =>
        def (preexps, postexps) = store_exprs (xs, ([], [body]));
        def all_exps = List.append (List.rev (preexps), List.rev (postexps));
        <[ {.. $all_exps } ]>
      | _ =>
        Util.ice ("'using' macro have zero parameters")
    }
  }

  private class AndMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [ e1; e2 ] =>
            <[ if ($e1) if ($e2) true else false else false ]>
        | _ => 
          Util.ice ("&& operator didn't get two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "&&" }
    
    public this () {}
  }

  private class OrMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [ e1; e2 ] =>
            <[ { if ($e1) true else if ($e2) true else false } ]>
        | _ => 
          Util.ice ("|| operator didn't get two arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "||" }
    
    public this () {}
  }

  private macro ifmacro (cond, e1, e2) : PT.Expr 
          syntax ("if", "(", cond, ")", e1, "else", e2) 
  {
    def tcond = Tyexpr.ty_expr (_N_ctx, cond);
    def te1 = ty_expr (_N_ctx, e1);
    def te2 = ty_expr (_N_ctx, e2);
    def bool_ty = Tyutil.make_tapp ("Nemerle.Core.Aliases.bool");
    Tyexpr.expect_type ("if condition", tcond, bool_ty);
    match (Tyutil.unify_branches (type_of (te1), type_of (te2))) {
      | Some (t) =>
        <[ match ($(tcond : typed)) { | true => $(te1 : typed) | _ => $(te2 : typed) } ]>
      | None =>
        Message.fatal_error ("if...else body has type " +
          (type_of (te1)).as_string () + " while the else clause has type " +
          (type_of (te2)).as_string ())
    }
  }

  (** TOOL MACROS *)
  
  private class PrintfMacro implements IMacro 
  {
    public variant FormatToken {
      | Text { body : string; }
      | TextNewline { body : string; }
      | Number
      | Str
      | Chr
    }

    public static parse_format (form : string) : list(FormatToken)
    {
      mutable i <- 0;
      mutable buf <- System.Text.StringBuilder ();
      mutable result <- [];
      def n = form.Length;
      
      while (i < n) { 
        match (form[i]) {
          | '%' =>
            // % occured - first, dump text from buffer
            when ( buf.Length > 0 ) {
              result <- Text (buf.ToString ()) :: result;
              buf <- buf.Remove (0, buf.Length);
            };
            // now analyze next character
            i <- i + 1;
            if ( i < n ) {
              match (form[i]) {
                | 'd' => result <- Number () :: result
                | 'i' => result <- Number () :: result
                | 's' => result <- Str () :: result
                | 'c' => result <- Chr () :: result
                | _ => 
                  Message.error ("Unsupported formatting sequence after % character")
              }
            }
            else
              Message.error ("Unexpected end of format after % character")
          | '\n' =>
            result <- TextNewline (buf.ToString ()) :: result;
            buf <- buf.Remove (0, buf.Length)
          | c =>
            buf <- buf.Append (c)
        };
        i <- i + 1;
      };

      when (buf.Length > 0) { result <- Text (buf.ToString ()) :: result; };

      // the result is reversed, but function using it will reverse it again
      result
    }

    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | <[ $(format : string) ]> :: parms =>
          def make_expressions (toks, parms, acc) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.Write ($(t : string)) ]> :: acc)
              | (TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.WriteLine ($(t : string)) ]> :: acc)

              | (Number :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : int)) ]> :: acc)

              | (Str :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : string)) ]> :: acc)

              | (Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : char)) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for printf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for printf macro");
                acc
            }
          };
          
          def seq = make_expressions (parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("printf macro expects formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "printf" }
    
    public this () {}
  }

//  private macro scanf (format : string, parms : list (parm)) {
  private class ScanfMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | <[ $(format : string) ]> :: parms =>
          def make_expressions (toks, parms, acc) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ Nemerle.Input.CheckInput ($(t : string)) ]> :: acc)

              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ Nemerle.Input.CheckInput ($(t : string)) ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadInt () ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadString () ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- System.Char.ToChar (System.Console.Read ()) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for scanf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for scanf macro");
                acc
            }
          };
          
          def seq = <[ Nemerle.Input.EatWhiteSpace () ]> ::
            make_expressions (PrintfMacro.parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("scanf macro expects formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "scanf" }
    
    public this () {}
  }

  public class SprintfMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | (<[ $(_ : var) ]>) as target :: <[ $(format : string) ]> :: parms =>
          def make_expressions (toks, parms, acc) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ def _ = _N_sb.Append ($(t : string)) ]> :: acc)
              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ def _ = _N_sb.Append ($(t : string)) ]> :: 
                  <[ def _ = _N_sb.Append ("\n") ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ def _ = _N_sb.Append (($p : int)) ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ def _ = _N_sb.Append (($p : string)) ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ def _ = _N_sb.Append (($p : char)) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for sprintf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for sprintf macro");
                acc
            }
          };
          
          def seq = <[ def _N_sb = System.Text.StringBuilder () ]> ::
                    make_expressions (PrintfMacro.parse_format (format), List.rev (parms), 
                    [ <[ $target <- _N_sb.ToString () ]>; (target : PT.Expr) ]);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("sprintf macro expects string variable and formating string as first argument")
      }
    }

    GetName () : string implements IMacro.GetName { "sprintf" }
    
    public this () {}
  }

  public class SscanfMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | valstr :: <[ $(format : string) ]> :: parms =>
          def make_expressions (toks, parms, acc) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (PrintfMacro.Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ Nemerle.Input.CheckInput ($(t : string)) ]> :: acc)

              | (PrintfMacro.TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ Nemerle.Input.CheckInput ($(t : string)) ]> :: acc)

              | (PrintfMacro.Number :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadInt () ]> :: acc)

              | (PrintfMacro.Str :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- Nemerle.Input.ReadString () ]> :: acc)

              | (PrintfMacro.Chr :: xs, p :: ps) =>
                make_expressions (xs, ps, 
                  <[ $p <- System.Char.ToChar (System.Console.Read ()) ]> :: acc)

              | (_, _ :: _) =>
                Message.error ("too many arguments for sscanf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for sscanf macro");
                acc
            }
          };
          
          def seq = <[ def _N_sscanf_str = $valstr ]> ::
                    <[ mutable _N_sscanf_pos <- 0 ]> ::
                    <[ def _N_sscanf_len = _N_sscanf_str.Length ]> ::
                    <[ Nemerle.Input.EatWhiteSpace () ]> ::
            make_expressions (PrintfMacro.parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("sscanf macro expects string and formating string as first arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "sscanf" }
    
    public this () {}
  }

  private class AssertMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [ cond ] =>             
            <[ if ($cond) () else 
               raise Assertion_failed ($(cond.loc.file : string), 
                                       $(cond.loc.line : int), "") ]>
        | [ cond; message ] =>
            <[ if ($cond) () else 
               raise Assertion_failed ($(cond.loc.file : string), 
                                       $(cond.loc.line : int), $message) ]>
        | _ => 
          Message.fatal_error ("assert macro expects one or two arguments" +
           " (the condition and an optional message)")
      }
    }

    GetName () : string implements IMacro.GetName { "assert" }
    
    public this () {}
  }


  (** MACROS, WHICH WE CAN DO BETTER THAN HASKELL *)

  private class SelectFromTupleMacro implements IMacro 
  {
    Run (ctx : CTX, args : list (PT.Parm)) : PT.Expr implements IMacro.Run
    {
      match (get_params (args)) {
        | [ <[ $(k : int) ]>; <[ $(n : int) ]>; tupl ] =>
          mutable tup <- [];
          for (mutable i <- n; i > 0; i <- i - 1) {
//            def pn = PT.SS_string ("_N_tp" + string_of_int (n - i + 1));
//            tup <- <[ pattern: $pn (.. []) ]> :: tup;
            tup <- PT.P_variable ("_N_tp" + string_of_int (n - i + 1)) :: tup
          };
          <[ { def (.. $tup) = $tupl; $("_N_tp" + string_of_int (k) : var) } ]>
        | _ => 
          Message.fatal_error ("'selectFromTuple' macro expects three arguments")
      }
    }

    GetName () : string implements IMacro.GetName { "selectFromTuple" }
    
    public this () {}
  }

  private macro tupleMap (f : expr, tup : expr)
  {
    match (tup) {
      | <[ (.. $elms) ]> =>
          def mapped = List.map (fun (e) { <[ $f ($e) ]> }, elms);
	        <[ (.. $mapped) ]>
      | _ => 
        Message.fatal_error ("'tupleMap' macro expects function and tuple")
    }
  }

  /// always register standard macros when compiler starts
  static this () {
    MacroRegistry.register_macro (_N_whilemacro_class ());
    MacroRegistry.register_macro (_N_usingmacro_class ());
    MacroRegistry.register_macro (_N_whenmacro_class ());
    MacroRegistry.register_macro (_N_unlessmacro_class ());
    MacroRegistry.register_macro (AssertMacro ());
    MacroRegistry.register_macro (_N_formacro_class ());
    MacroRegistry.register_macro (AndMacro ());
    MacroRegistry.register_macro (OrMacro ());
    MacroRegistry.register_macro (_N_ifmacro_class ());

    MacroRegistry.register_macro (PrintfMacro ());
    MacroRegistry.register_macro (SprintfMacro ());
    MacroRegistry.register_macro (ScanfMacro ());

    MacroRegistry.register_macro (SelectFromTupleMacro ());
    MacroRegistry.register_macro (_N_tupleMap_class ());

    MacroRegistry.register_macro (PrettyPrintMacro ());
  }
  
} // end module Extensions
} // end ns

