(*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Compiler;
  open Nemerle.Compiler.Tyops;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Collections;
  
  open System.Reflection;
  open System.Reflection.Emit;


  (**
   * The CGIL tree holds information about types and their members.
   *)
  variant CGIL_tree {
    | CGIL_class { type_builder : TypeBuilder; subtree : list (CGIL_tree); }
    | CGIL_field { field : CM_field; field_builder : FieldBuilder; }
    | CGIL_constructor { constructor : CM_method; constructor_builder : ConstructorBuilder; }
    | CGIL_method { method : CM_method; method_builder : MethodBuilder; }
  }


  (**
   * An IL code generator
   *)
  public class CGIL
  {
    (* -- PUBLIC CONSTRUCTORS ---------------------------------------------- *)
    
    (** 
     * Outputs objects from cgtree.n as IL code. 
     *)
    public this (decls : list (CM_class))
    {
      (* create the type builder queue *)
      this._type_builder_queue <- Queue ();
      
      (* create a weak assembly name and define a dynamic assembly *)
      this._assembly_name <- System.Reflection.AssemblyName ();
      this._assembly_name.Version <- System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name <- "CGILTest"; // FIXME

      this._assembly_builder <- 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      (* create a dynamic module *)
      this._module_builder <- 
        this._assembly_builder.DefineDynamicModule ("CGILTest", "cgil-test.dll"); // FIXME

      (* select the classes that have to be generated separately *)
      def (aux_decls, standard_decls) =
        this.select_aux_and_standard_decls (decls);

      (* process the declarations *)
      def add_classes (decl) { this.make_class (decl, null) };
      def add_declarations (tree) { this.add_declarations (tree, null) }; // FIXME: aargh
      def add_implementations (tree) { this.add_implementations (tree) }; // FIXME: aargh

      (* emit the auxiliary declarations *)
      this._emit_nemerle_attributes <- false;

      def aux_classes_tree = List.map (add_classes, aux_decls);
      def aux_declarations_tree = List.map (add_declarations, aux_classes_tree);
      def aux_implementations_tree = List.map (add_implementations, aux_declarations_tree);

      (* execute the type builder queue *)
      create_types_in_queue ();

      (* emit all the other declarations *)
      this._emit_nemerle_attributes <- true;
      
      def classes_tree = List.map (add_classes, standard_decls);
      def declarations_tree = List.map (add_declarations, classes_tree);
      def implementations_tree = List.map (add_implementations, declarations_tree);
            
      (* execute the type builder queue *)
      create_types_in_queue ();
            
      (* save the assembly *)
      this._assembly_builder.Save ("cgil-test.dll"); // FIXME
    }



    (* -- PRIVATE METHODS -------------------------------------------------- *)

    (**
     * Calls the CreateType method for all the elements in the queue.
     * The queue is cleared after the types have been created.
     *)
    private create_types_in_queue () : void
    {
      def create_type (tb : TypeBuilder) : void {
        def _ = tb.CreateType ();
        ()
      };      
    
      _type_builder_queue.iter (create_type);
      _type_builder_queue.clear ();
    }
    
    (**
     * Splits the declarations into two separate lists. The first list
     * will be processed in the first order (typically you'll want to
     * put all the auxiliary definitions there).
     *)
    private select_aux_and_standard_decls (decls : list (CM_class)) : list (CM_class) * list (CM_class)
    {
      def is_aux (decl : CM_class) : bool {
        match (decl.ns + decl.name) {
          | "Nemerle.TypeAttribute"
          | "Nemerle.VariantAttribute"
          | "Nemerle.VariantOptionAttribute" => true
          | _ => false
        }
      };
      
      List.partition (is_aux, decls)
    }
    
    
    (**
     * Builds a Nemerle type attribute
     *)
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.TypeAttribute", false, false);
      def constructor_param_types = mkarray [reflect_type ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     * Builds a Nemerle variant attribute
     *)
    private make_nemerle_variant_attribute () : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.VariantAttribute", false, false);
      def constructor_info = attr_type.GetConstructor (mkarray []);
      def attr_builder = CustomAttributeBuilder (constructor_info, (mkarray [] :> array (System.Object)));
      attr_builder
    }
    

    (**
     * Builds a Nemerle variant option attribute
     *)
    private make_nemerle_variant_option_attribute (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.VariantOptionAttribute", false, false);
      def constructor_param_types = mkarray [reflect_type ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }



    (**
     * A search for a (possibly partial) type of a given name is executed.
     * The partial types in the local module builder are always searched.
     * If specified, the external declarations and the currently loaded
     * types are scanned, too.
     *)
    private reflect_type (type_name : string, scan_externals : bool, scan_system : bool) : System.Type
    {
      def ty = this._module_builder.GetType (type_name);
      if (ty != null) ty
      else {
        def ty = null; // FIXME: search in Env.externals here!
        if (ty != null && scan_externals) ty
        else {
          def ty = System.Type.GetType (type_name);
          if (ty != null && scan_system) ty
          else {
            // brute, brute, brute hack...
            def last_dot = type_name.LastIndexOf ('.');
            
            if (last_dot != -1) {
              def replaced_dot = type_name.Substring (0, last_dot) + 
                "+" + type_name.Substring (last_dot + 1);
              reflect_type (replaced_dot, scan_externals, scan_system);
            }
            else {
              Message.warning ("CGIL: unable to reflect type: " + type_name);
              typeof (System.Object)
            }
          }
        }
      }    
    }


    (**
     * Same as above, but always searches in externals and System.
     *)
    private reflect_type (type_name : string) : System.Type
    {
      reflect_type (type_name, true, true)
    }


    (**
     * Converts a CG type to it's closest approximation as a System.Type
     *)
    private reflect_nemerle_type (ty : CG_type) : System.Type
    {
      match (ty) {
        | CT_array (t) => 
          def internal_type = reflect_nemerle_type (t);          
          this.reflect_type (internal_type.FullName + "[]", true, true)

        | CT_ref (name) => 
          this.reflect_type (name, true, true)
        
        | CT_tuple (arity) =>
          this.reflect_type ("Nemerle.Tuple" + string_of_int (arity), false, false)
          
        | CT_fun (arity) =>
          this.reflect_type ("Nemerle.Func" + string_of_int (arity), false, false)
          
        | CT_void => typeof(System.Void)
        | CT_object => typeof(System.Object)
        | CT_bool => typeof(System.Bool)
        
        | CT_unreached => Util.ice ("nemerle_to_framework_type:CT_unreached")
      }          
    }
    
    
    (**
     * Converts Nemerle field modifiers to the CLI field attributes.
     *)
    private make_field_attributes (attrs : list (Modifier)) : FieldAttributes
    {
      def process_modifier (modifier : Modifier) : FieldAttributes {
        match (modifier) {
          | Mod_public => FieldAttributes.Public
          | Mod_private => FieldAttributes.Private
          | Mod_new => Util.ice ("Mod_new is not supported for fields")
          | Mod_protected => FieldAttributes.Family
          | Mod_internal => FieldAttributes.FamORAssem
          | Mod_abstract => Util.ice ("Mod_abstract is not supported for fields")
          | Mod_virtual => Util.ice ("Mod_virtual is not supported for fields")
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for fields")
          | Mod_static => FieldAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for fields")
          | Mod_module => Util.ice ("Mod_module is not supported for fields")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) + this.make_field_attributes (rest)
        | [] =>
          FieldAttributes.PrivateScope
      }
    }


    (**
     * Converts Nemerle method modifiers to the CLI method attributes.
     *)
    private make_method_attributes (attrs : list (Modifier)) : MethodAttributes
    {
      def process_modifier (modifier : Modifier) : MethodAttributes {
        match (modifier) {
          | Mod_public => MethodAttributes.Public
          | Mod_private => MethodAttributes.Private
          | Mod_new => MethodAttributes.NewSlot
          | Mod_protected => MethodAttributes.Family
          | Mod_internal => MethodAttributes.FamORAssem
          | Mod_abstract => MethodAttributes.Abstract
          | Mod_virtual => MethodAttributes.Virtual
          | Mod_sealed => Util.ice ("Mod_sealed is not supported for methods")
          | Mod_static => MethodAttributes.Static
          | Mod_struct => Util.ice ("Mod_struct is not supported for methods")
          | Mod_module => Util.ice ("Mod_module is not supported for methods")
        }
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) + this.make_method_attributes (rest)
        | [] =>
          MethodAttributes.PrivateScope
      }
    }


    (**
     *
     *)  
    private type_list_to_type_array (x : list (System.Type)) : array (System.Type) {

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), List.length (x)) :> array (System.Type));
      
      def loop (index : int, x : list (System.Type)) : void {        
        match (x) {
          | head :: tail =>
            result [index] <- (head :> System.Type);
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }


    (**
     *
     *)
    private determine_inheritance (m : CM_class) : (System.Type * array (System.Type))
    {
(*            
          def inh =
            match (m.inheritance) {
              | [] => ST_leaf ("")
              | _ => " : " ++ st_concat (", ", List.map (flat_ty, m.inheritance))
            };
*)

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), 0) :> array (System.Type));
        
      (typeof (System.Object), result) // FIXME
    }
  

    (**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     *)
    private make_class (m : CM_class, type_builder : TypeBuilder) : CGIL_tree
    {       
      (* create optional custom attributes for this type *)
      def custom_attribute =
        match (m.kind) {          
          | CK_variant => 
            this.make_nemerle_variant_attribute ()
          | CK_variant_option (encoded_type) =>
            this.make_nemerle_variant_option_attribute (encoded_type)
          | _ => null
        };

      (* decide the new type attributes *)
      def type_kind_attrs = 
        match (m.kind) { 
          | CK_class => TypeAttributes.Class
          | CK_struct => Util.ice ("CK_struct")
          | CK_interface => TypeAttributes.Interface + TypeAttributes.Abstract
          | CK_variant => TypeAttributes.Class
          | CK_variant_option (_) => TypeAttributes.Class
        };
        
      def attrs = type_kind_attrs + TypeAttributes.Public;

      (* determine the inheritance relation for this type *)
      def (extends_class, implements_interfaces) = this.determine_inheritance (m);

      (* create the type builder for a top-level or nested class declaration *)
      def new_type_builder = 
        if (type_builder == null)
          this._module_builder.DefineType (m.ns + m.name, attrs)
        else
          type_builder.DefineNestedType (m.name, TypeAttributes.NestedPublic + attrs);

      when (custom_attribute != null && this._emit_nemerle_attributes) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      this._type_builder_queue.add (new_type_builder);

      (* create the type builder's CGIL subtree *)
      def walk_members (decls : list (CG_member)) : list (CGIL_tree) {
        match (decls) {
          | decl :: rest => 
            this.make_subtree (decl, new_type_builder) :: walk_members (rest)
          | [] => []
        }
      };
      
      CGIL_class (new_type_builder, walk_members (m.decls))    
    }



    (**
     * This method walks the declarations tree, creating partial types
     * and building the CGIL tree of the compilation unit.
     *)
    make_subtree (m : CG_member, type_builder : TypeBuilder) : CGIL_tree
    {
      assert (type_builder != null);
      
      match (m) {
        | (CM_class) as m =>
          this.make_class (m, type_builder)

        | (CM_field) as f =>
          CGIL_field (f, null)
                               
        | (CM_property) as p =>
          Message.fatal_error ("emitting properties is not supported yet")
                            
        | (CM_method) as m =>
          CGopt.tail_call_optimize (m);

          match (m.ret_type) {
            | CT_unreached => CGIL_constructor (m, null)
            | _ => CGIL_method (m, null)
          }
      }          
    }


    (**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     *)
    add_declarations (m : CGIL_tree, type_builder : TypeBuilder) : CGIL_tree
    {
      match (m) {
        | CGIL_class (class_type_builder, members) =>
          def walk_members (decls : list (CGIL_tree)) : list (CGIL_tree) {
            match (decls) {
              | decl :: rest => 
                this.add_declarations (decl, class_type_builder) :: walk_members (rest)
              | [] => []
            }
          };          
          CGIL_class (type_builder, walk_members (members))    

        | CGIL_field (field, _) =>
          assert (type_builder != null);
          
          def field_builder = 
            type_builder.DefineField (field.name, 
                                      this.reflect_nemerle_type (field.ty), 
                                      this.make_field_attributes (field.modifiers));

          when (this._emit_nemerle_attributes) {
            field_builder.SetCustomAttribute (this.make_nemerle_type_attr (field.encoded_type));
          };
          
          CGIL_field (field, field_builder)
                            
        | CGIL_constructor (constructor, _) =>
          assert (type_builder != null);

          this.make_constructor_skeleton (constructor, type_builder)

        | CGIL_method (method, _) =>
          assert (type_builder != null);

          this.make_method_skeleton (method, type_builder)
      }          
    }


    (**
     * This method adds implementations to methods, where applicable...
     *)
    private add_implementations (tree : CGIL_tree) : CGIL_tree
    {
      match (tree) {
        | CGIL_class (type_builder, subtree) => 
          def walk_branches (branch) { this.add_implementations (branch) }; // FIXME: aargh
          CGIL_class (type_builder, List.map (walk_branches, subtree))
          
        | (CGIL_constructor (constructor, constructor_builder)) as member =>
          this.add_constructor_body (constructor, constructor_builder);
          member
        
        | (CGIL_method (method, method_builder)) as member =>
          this.add_method_body (method, method_builder);
          member
        
        | member => member
      }
    }



    private make_constructor_skeleton (m : CM_method, type_builder : TypeBuilder) : CGIL_tree
    {
      (* build the parameter types array *)      
      def mkparm (v : CG_val) : System.Type {
        this.reflect_nemerle_type (v.ty)
      };
                    
      def parameter_types = this.type_list_to_type_array (List.map (mkparm, m.parms));

      (* create the constructor builder *)
      def constructor_builder = 
        type_builder.DefineConstructor (this.make_method_attributes (m.modifiers),
                                        CallingConventions.Standard, parameter_types);

      CGIL_constructor (m, constructor_builder)
    }

    

    (**
     *
     *)    
    private add_constructor_body (constructor : CM_method, constructor_builder : ConstructorBuilder) : void
    {
      def il_generator = constructor_builder.GetILGenerator ();

      il_generator.Emit (OpCodes.Ret);
    }



    (**
     *
     *)
    private make_method_skeleton (m : CM_method, type_builder : TypeBuilder) : CGIL_tree
    {
      (* build the return type and parameter types *)      
      def mkparm (v : CG_val) : System.Type {
        this.reflect_nemerle_type (v.ty)
      };
      
      def return_type = this.reflect_nemerle_type (m.ret_type);
              
      def parameter_types = this.type_list_to_type_array (List.map (mkparm, m.parms));

      (* add the method to the type builder *)
      def method_builder = 
        type_builder.DefineMethod (m.name, this.make_method_attributes (m.modifiers),
                                   return_type, parameter_types);

      CGIL_method (m, method_builder)
    }


    (**
     *
     *)    
    private add_method_body (method : CM_method, method_builder : MethodBuilder) : void
    {
      def il_generator = method_builder.GetILGenerator ();

      il_generator.Emit (OpCodes.Ldstr, "Hello world!");

      def system_console = typeof(System.Console);

      def method_info =
        system_console.GetMethod ("WriteLine", (mkarray [typeof(string)] :> array (System.Type)));

      il_generator.Emit (OpCodes.Call, method_info);
      il_generator.Emit (OpCodes.Ret);

    (*
      def (pref, r) = make_complex (flat (m.body));
      def ret =
        if (is_dummy_type (m.ret_type))
          side_effect_run (r)
        else
          if (is_dummy_type (type_of (m.body)))
            side_effect_run (r) ++ "return null;\n"
          else
            "return " ++ r ++ ";\n";

      print_st ("\n{\n" ++ pref ++ ret ++ "} // end of fun " ++ m.name ++ "\n")
    *)

    }


    (**
     *
     *)    
    emit_il (ilg : ILGenerator, expr : CG_expr) : void {

      match (expr) {

(*

        | CE_literal (l) =>
          def s =
            match (l) {
              | L_void => Util.ice ("CGIL: emit_il: CE_literal: L_void")
              | L_null => ilg.Emit (Opcodes.Ldnull)
              | L_int (k) => ilg.Emit (Opcodes.Ldc_I4, k)
              | L_bool (v) => if (v) "true" else "false"
              | L_char (k) => "((char)" + string_of_int (k) + ")"
              | L_string (s) => "\"" + quote (s) + "\""
              | L_float (v) => Util.ice ("FIXME: cgfloat")
            };
          CS_simple (ST_leaf (s))


        | CE_ref (d) => CS_simple (ST_leaf (d.name))
        | CE_global_ref (m) =>
          def n = if (m.extern_name != "") m.extern_name else m.name;
          CS_simple (ST_leaf (n))      
        | CE_field_ref (e, f) =>
          def e = flat (e);
          mono (e, csref (e) ++ "." ++ f.name)
        | CE_property_ref (e, p) =>
          def e = flat (e);
          mono (e, csref (e) ++ "." ++ p.name)

        | CE_tuple_ref (e, n) => 
          def e = flat (e);
          mono (e, csref (e) ++ ".field" ++ string_of_int (n + 1))

        | CE_call (e, es) => 
          match ((e, flat (e))) {
            | (CE_base, CS_simple (s)) => 
              match (flat_call (s, es)) {
                | CS_simple (s) => base_class_ctor <- s; CS_simple (ST_leaf (""))
                | _ => Util.ice ("complex expressions in base call")
              }
            | (_, CS_simple (s)) => flat_call (s, es)
            | (_, CS_complex (pref, v)) => 
              Util.ice ("CE_call on a complex instruction (" + st_flatten(pref) + ": " + st_flatten(v) + ")")
          }
            
        | CE_assign (e1, e2) =>
          def (p1, r1) = make_complex (flat (e1));
          def (p2, r2) = make_complex (flat (e2));
          CS_complex (p1 ++ p2, r1 ++ " = " ++ r2)
          
        | CE_indexer (_, obj, args) =>
          def (obj_pre, obj_val) = make_complex (flat (obj));
          mutable indexers_pre <- ST_leaf ("");
          def serialize (e : CG_expr) : String_tree {
            def (pre, val) = make_complex (flat (e));
            indexers_pre <- indexers_pre ++ pre;
            val
          };
          def concat (acc : String_tree, indexers : list (CG_expr)) : String_tree {
            match (indexers) {
              | [] =>
                acc ++ ST_leaf ("]")
              | [indexer] =>          
                acc ++ serialize (indexer) ++ ST_leaf ("]")
              | indexer :: rest =>
                concat (acc ++ serialize (indexer) ++ ST_leaf (", "), rest)
            }
          };
          def indexers_val = concat (ST_leaf ("["), args);
          simplify (CS_complex (obj_pre ++ indexers_pre, obj_val ++ indexers_val))

          
        | CE_let (v, e) =>
          match (v.val) {
            | CE_none =>
              def (p, r) = make_complex (flat (e));
              CS_complex (flat_ty (v.ty) ++ " " ++ v.name ++ ";\n" ++ p, r)
            | _ =>
              def (p, r) = make_complex (flat (v.val));
              def pref = 
                if (is_dummy_type (v.ty))
                  p ++ side_effect_run (r)
                else
                  p ++ flat_ty (v.ty) ++ " " ++ v.name ++ " = " ++ r ++ ";\n";
              def (p, r) = make_complex (flat (e));
              CS_complex (pref ++ p, r)
          }
          
        | CE_has_type (e, t) =>
          def e = flat (e);
          mono (e, "((" ++ csref (e) ++ " == null &&" ++ 
                  " Nemerle.Core.Null_match.raise_self ()) || (" 
                  ++ csref (e) ++ " is " ++ flat_ty (t) ++ "))")
          
        | CE_raise (x) =>
          def (p, r) = make_complex (flat (x));
          CS_complex (p ++ "throw " ++ r ++ ";\n", ST_leaf ("null"))


// FIXME: It for some reason fails.
//
//        | CE_if (_, CE_true, e, _) =>
//          Message.debug ("In if (true), subexpr is: " + pretty_print (e));
//          flat (e)
//        | CE_if (_, CE_false, _, e) =>
//          Message.debug ("In if (false), subexpr is: " + pretty_print (e));
//          flat (e)

        | CE_if (t, c, e1', e2') =>
          def (p1, c) = make_complex (flat (c));
          def (p2, e1) = make_complex (flat (e1'));
          def (p3, e2) = make_complex (flat (e2'));
          if (is_dummy_type (t))
            CS_complex (p1 ++ 
                        "if (" ++ c ++ ") {\n" ++
                          p2 ++
                          side_effect_run (e1) ++
                        "} else {\n" ++
                          p3 ++
                          side_effect_run (e2) ++
                        "}\n", ST_leaf ("null"))
          else {
            def tmpname = tmp ();
            def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";

            CS_complex (p1 ++ df ++ 
                        "if (" ++ c ++ ") {\n" ++
                          (if (is_raise (e1')) p2 else (p2 ++ tmpname ++ " = " ++ e1 ++ ";\n")) ++
                        "} else {\n" ++
                          (if (is_raise (e2')) p3 else (p3 ++ tmpname ++ " = " ++ e2 ++ ";\n")) ++
                        "}\n", ST_leaf (tmpname))
          }
          
        | CE_true => CS_simple (ST_leaf ("true"))

        | CE_false => CS_simple (ST_leaf ("false"))
        
        | CE_try_with (e1', v, e2') =>
          def (p1, e1) = make_complex (flat (e1'));
          def (p2, e2) = make_complex (flat (e2'));
          def t = type_of (e1');
          if (is_dummy_type (t))
            CS_complex ("try {\n" ++
                          p1 ++
                          side_effect_run (e1) ++
                        "} catch (" ++ flat_ty (v.ty) ++ " " ++ v.name ++ ") {\n" ++
                          p2 ++
                          side_effect_run (e2) ++
                        "}\n", ST_leaf ("null"))
          else {
            def tmpname = tmp ();
            def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
            CS_complex (df ++
                        "try {\n" ++
                          p1 ++
                          tmpname ++ " = " ++ e1 ++ ";\n" ++
                        "} catch (" ++ flat_ty (v.ty) ++ " " ++ v.name ++ ") {\n" ++
                          p2 ++
                          tmpname ++ " = " ++ e2 ++ ";\n" ++
                        "}\n", ST_leaf (tmpname))
          }
                      
        | CE_try_finally (e1', e2') =>
          def (p1, e1) = make_complex (flat (e1'));
          def (p2, e2) = make_complex (flat (e2'));
          def t = type_of (e1');
          if (is_dummy_type (t))
            CS_complex ("try {\n" ++
                          p1 ++
                          side_effect_run (e1) ++
                        "} finally {\n" ++
                          p2 ++
                          side_effect_run (e2) ++
                        "}\n", ST_leaf ("null"))
          else {
            def tmpname = tmp ();
            def df = flat_ty (t) ++ " " ++ tmpname ++ ";\n";
            CS_complex (df ++
                        "try {\n" ++
                          p1 ++
                          tmpname ++ " = " ++ e1 ++ ";\n" ++
                        "} finally {\n" ++
                          p2 ++
                          side_effect_run (e2) ++
                        "}\n", ST_leaf (tmpname))
          }
                      
          
        | CE_mkarray (initializers) =>
          mutable pref <- ST_leaf ("");
          def serialize (e : CG_expr) : String_tree {
            def (pre, val) = make_complex (flat (e));
            pref <- pref ++ pre;
            val
          };
          def concat (acc : String_tree, initializers : list (CG_expr)) : String_tree {
            match (initializers) {
              | [] =>
                acc ++ ST_leaf (" }")
              | [initializer] =>          
                acc ++ serialize (initializer) ++ ST_leaf (" }")
              | initializer :: rest =>
                concat (acc ++ serialize (initializer) ++ ST_leaf (", "), rest)
            }
          };
          def body = concat (ST_leaf ("{ "), initializers);
          CS_complex (pref, body)
          
        | CE_this => CS_simple (ST_leaf ("this"))
        | CE_base => CS_simple (ST_leaf ("base"))
        | CE_skip => CS_simple (ST_leaf ("null"))
        
        | CE_cast (e, CT_void) => flat (e) // C# doesn't like (void)foo
        
        | CE_cast (e, t) =>
          def e = flat (e); 
          mono (e, "((" ++ flat_ty (t) ++ ")" ++ csref (e) ++ ")")
          
        | CE_sequence ([]) => CS_simple (ST_leaf ("null"))

        | CE_sequence (body) =>
          def cutoff_after_raise (e : list (CG_expr), acc : list (CG_expr)) : list (CG_expr) {
            match (e) {
              | [] => List.rev (acc)
              // FIXME: use the "as" construct here
              | CE_raise (expr) :: _ => 
                cutoff_after_raise ([], CE_raise (expr) :: acc) 
              | CE_restart :: _ => 
                cutoff_after_raise ([], CE_restart () :: acc) 
              | expr :: rest => 
                cutoff_after_raise (rest, expr :: acc)
            }
          };
          def serialize (e : CG_expr) : String_tree
            {
              def (pre, r) = make_complex (flat (e));
              pre ++ side_effect_run (r)
            };
          def concat (acc : String_tree, es : list (CG_expr)) : CS_code {
            match (es) {
              | [x] => 
                def (pre, r) = make_complex (flat (x));
                CS_complex (acc ++ pre, r)
              | CE_skip :: xs =>
                concat (acc, xs)
              | x :: xs =>
                concat (acc ++ serialize (x), xs)
              | [] => CS_simple (ST_leaf ("null"))
            }
          };

          concat (ST_leaf (""), cutoff_after_raise (body, []))
        
        | CE_tuple_ctor (es) =>
          flat_call (ST_leaf ("new Nemerle.Tuple") ++ string_of_int (List.length (es)), es)
        
        | CE_ctor_ref (c) => 
          if (c.extern_name == "") 
            Util.ice ("empty extern name " + c.ns + ":" + c.name)
          else
            CS_simple (ST_leaf ("new " + c.extern_name))
        
        | CE_method_ref (e, f) => 
          def e = flat (e); 
          mono (e, csref (e) ++ "." ++ f.name)

        | CE_block (e) =>
          def (pref, val) = make_complex (flat (e));
          CS_complex ("_N_block_beg:\n" ++ pref, val)

        | CE_restart =>
          CS_complex (ST_leaf ("goto _N_block_beg;"), ST_leaf ("null"))
*)

        | CE_none => Util.ice ("CGIL: emit_il: CE_none")

        | _ => Message.warning ("CGIL: emit_il: expression match was not exhaustive")
      }
    }     


    (* -- PRIVATE FIELDS --------------------------------------------------- *)

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _type_builder_queue : Queue (TypeBuilder);
    private mutable _emit_nemerle_attributes : bool;
    
  } (* end of the module *)
  
} (* end of the namespace *)
