using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;
using Nemerle.Imperative;

using LRPEGCC.GrammarCreator;

namespace LRPEGCC
{
  macro Grammar (_rules : Token)
  syntax ("grammar", _rules)
  {
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
      | e is GrammarException =>
        def loc = if(e.Location != Location.Default) e.Location else tb.Location;
        Message.Error(loc,  e.Message);
      | e is Exception =>
        Message.Error(tb.Location,  $"Exception $e");
    }
  }

  macro GetLocation(params args : array[expr])
  {
    def typer = Macros.ImplicitCTX();
    def manager = Macros.Manager();
    match(NList.ToList(args))
    {
      | [<[ _ ]>] with (t1 = <[ _ ]>, t2 = <[ _ ]>)
      | [t1, t2] =>
        try {
          def make_chain(parms) {
            | parm :: others when parm.ty.IsFixed =>
              match(parm.ty.Fix()) {
                | FixedType.Class(opt, [_])  // TODO: ensure thar _ is NToken or VToken
                  when opt.Equals(manager.InternalType.Nemerle_option_tc) =>
                  <[
                    match($(parm.Name : usesite)) { 
                      | Some(tok) => tok : Nemerle.Peg.IToken
                      | _ => $(make_chain(others)) : Nemerle.Peg.IToken
                    }
                  ]>
                | _ =>
                  <[ $(parm.Name : usesite) ]>
              }
            | parm :: _ =>
              <[ $(parm.Name : usesite) ]>
            | _ =>
              Message.Error("To few parameters."); <[ () ]>
          }

          def mb = typer.CurrentMethodBuilder;
          def t1 = match(t1) {
            | <[ _ ]> => make_chain(mb.GetParameters())
            | x => x
          }
          def t2 = match(t2) {
            | <[ _ ]> => make_chain(mb.GetParameters().Rev())
            | x => x
          }
          <[ Nemerle.Peg.Location.FromToken(this.ParsingSource, $t1, $t2) ]>
        } catch {
          | _ => Message.Error("Grammar rule handler does not contain any parameters."); <[ () ]>
        }
      | [t] => <[ Nemerle.Peg.Location.FromToken(this.ParsingSource, $t) ]>
      | [] => Message.Error("One or two token arguments required."); <[ () ]>
      | _ => Message.Error("Too many arguments specified."); <[ () ]>
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      def grammar = CreateGrammar(typer, tb, startRule, rules);
        
      def compiler = RuleCompiler(typer);
      
      mutable str = "";
      
      def tyParam = 
        match (grammar.GetRule(grammar.StartRuleName))
        {
          | Rule.Capture(argType = RuleType.NType(ty)) => ty
          | _ => 
            Message.Error(tb.Location,  "Start rule must be a capture rule");
            <[ object ]>
        };

      foreach (name in grammar.Names)
      {
        def rule          = grammar.GetRule(name);
        rule.UpdateIndecis();
        def body          = compiler.CompileRule(rule);
        
        CheckRuleMethodHandler(name, grammar, tb, typer);
        
        def resultType : PExpr = // Make type parametr name
          match (rule)
          {
            | Rule.CaptureNamedTerminalSymbol            => <[ Nemerle.Peg.NToken ]>
            | Rule.Capture(argType = RuleType.NType(ty)) => <[ Nemerle.Peg.VToken[$ty] ]>
            | Rule.Capture(argType = argType) as c => 
              Message.Error($"Wrong return type ($argType) in '$(c.name)' rule");
              <[ Nemerle.Peg.NToken ]>
            | _                                          =>
              Message.Error($"Top level rule must be Capture. ($(rule.GetType().Name) $rule)");
              <[ Nemerle.Peg.NToken ]>
          };
        
        def method = <[decl:
          private $(compiler.DecorateRuleName(name.Id) : dyn)(pos : int, result : ref $resultType, text : string) : int
          {
            mutable c : char;
            _ = c; // eliminate wornint "a local value c was never used"
            $body;
          }
        ]>;
        _ = tb.DefineWithSource(method);
        str = str + method.ToString() + "\n" + body.ToString() + "\n\n";
        
        //create parse method for single capture rule
        unless (name.Equals(grammar.StartRuleName))
        {
          match (rule)
          {
            | Rule.Capture  as r => CreateSimpleParseMethod(r, compiler, tb);
            | _                  => ();
          }
        }
      }

      CreateStartParseMethods(grammar.StartRuleName.Id, tyParam, compiler, tb);
      
      tb.Define(<[decl:
        public override ToString() : string
        {
          $(str : string);
        }
      ]>);

      tb.Define(<[decl:
        private mutable _maxRollbackPos : int;
      ]>);

      tb.Define(<[decl:
        public MaxRollbackPos : int
        {
          get { _maxRollbackPos }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        private SetMaxRollbackPos(pos : int) : void
        {
          when (pos > _maxRollbackPos)
          {
            _maxRollbackPos = pos;
          }
        }
      ]>);
    }

    private CreateStartParseMethods(startRuleName : string, tyParam : PExpr, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      tb.Define(<[decl: mutable _parsingSource : Nemerle.Peg.SourceSnapshot; ]>);
      tb.Define(<[decl:
        public ParsingSource : Nemerle.Peg.SourceSnapshot
        {
          get { _parsingSource }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse(text : string) : int * $tyParam
        {
          TryParse(Nemerle.Peg.SourceSnapshot(text))
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse([Nemerle.Assertions.NotNull] source : Nemerle.Peg.SourceSnapshot) : int * $tyParam
        {
          _parsingSource = source;

          mutable result : Nemerle.Peg.VToken[$tyParam];
          def pos = $(compiler.DecorateRuleName(startRuleName) : dyn)(0, ref result, _parsingSource.Text);

          (pos, result.Value)
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public Parse(text : string) : option[$tyParam]
        {
          def (pos, res) = TryParse(text);
          
          if (pos < 0) None() else Some(res)
        }
      ]>);
    }

    private CheckRuleMethodHandler(ruleName : RuleRef, grammar : Grammar, tb : TypeBuilder, typer : Typer) : void
    {
      def rule = grammar.GetRule(ruleName);
      def mems = tb.GetParsedMembers(true).Filter(m => m.Name == ruleName.Id);
      
      match (rule)
      {   // Capture with defined type. User must define handler for it!
        | Rule.Capture(argType = RuleType.NType(ty), rule = rule) => 
          def tTy = typer.BindFixedType(ty);
          def methods = mems.MapFiltered(_ is ClassMember.Function, _ :> ClassMember.Function);
          
          def unpacParams(rule : Rule) : list[Rule]
          {
            | Rule.Sequence(rules) => rules
            | _ => [rule]
          }
          def nTokTy = FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Peg.NToken", 0), []);
          def vTokTc = typer.Manager.LookupTypeInfo("Nemerle.Peg.VToken", 1);
          def ruleToType(rule : Rule) : FixedType
          {
            | Call(name)                                =>
              def subRule = grammar.GetRule(name);
              match (subRule)
              {
                | Rule.Capture(argType = RuleType.NType(ty)) =>
                  def tTy = typer.BindFixedType(ty);
                  FixedType.Class(vTokTc, [tTy])
                  
                | _ => nTokTy
              }

            | Choice(rule :: _)          => ruleToType(rule)
            | Choice(_)                  => assert(false)
            | Sequence(rules)            => FixedType.Tuple(rules.Map(x => ruleToType(x)))
            | RepeatMin(0, rule)         => makeLoopTy(rule) // rule*
            | RepeatMin(1, rule)         => makeLoopTy(rule) // rule+
            | RepeatMin(_, rule)         => makeLoopTy(rule)
            | RepeatMinMax(0, 1, rule)   => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Core.option", 1), [ruleToType(rule)]) // rule?
            | RepeatMinMax(_, _, rule)   => makeLoopTy(rule)
            | Chars                      => nTokTy
            | Not(rule)                  => ruleToType(rule)
            | And(rule)                  => ruleToType(rule)
            | Capture(_, _, _, rule)     => ruleToType(rule)
            | CaptureNamedTerminalSymbol => nTokTy
            | ExtensionPoint             => assert(false)
          }
          and makeLoopTy(rule)
          {
            FixedType.Class(typer.Manager.LookupTypeInfo("System.Collections.Generic.List", 1), [ruleToType(rule)])
          }
          def errorMsg(ruleName, types, tTy)
          {
            assert2(false);
            $<#You need define method-handler for "$ruleName" rule with signature: $ruleName(_ : ..$(types; ", _ : ")) : $tTy#>
          }
          
          def topRules = unpacParams(rule);
          def types    = topRules.Map(ruleToType);

          match (methods)
          {
            | [m] => 
              def parms = m.header.Parameters;
              if (parms.Length == types.Length)
              {
                foreach ((need, p) in types.ZipLazy(parms))
                {
                  def real = typer.BindFixedType(p.Type);
                  
                  unless (need.TryUnify(real))
                  {
                    Message.Error(p.Location, $<#The parameter "$(p.Name)" has wrong type $real (need type $need).#>);
                    Message.Error(p.Location, errorMsg(ruleName, types, tTy));
                    break;
                  }
                }
              }
              else
                Message.Error(m.Location, $<#The method-handler of rule "$ruleName" must have $(types.Length) parameters. $(errorMsg(ruleName, types, tTy))#>)
              
            | m :: _ => Message.Error(m.Location, "Overloading not supported for rule method-handler");
            | []     => Message.Error(ty.Location, errorMsg(ruleName, types, tTy));
          }
          
        | _ => ()
      }
    }

    private CreateSimpleParseMethod(rule : Rule.Capture, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      def ruleName = rule.name;
      def methodName = "ParseRule_" + ruleName.Id;
      
      match(rule.argType)
      {
        | RuleType.NType(ty)  =>      
          def parseMethod1 = <[decl:
            public $(methodName : dyn)(startPos : int, text : string) : option[$ty]
            {
              mutable result : Nemerle.Peg.VToken[$ty];
              
              def pos = $(compiler.DecorateRuleName(ruleName.Id) : dyn)(startPos, ref result, text);
              
              if (pos < 0) 
                None() 
              else 
                Some(result.Value)
            }
          ]>;
          def parseMethod2 = <[decl:
            public $(methodName : dyn)(text : string) : option[$ty]
            {
              $(methodName : dyn)(0, text)
            }
          ]>;
        
          _ = tb.DefineWithSource(parseMethod1);
          _ = tb.DefineWithSource(parseMethod2);
          
        | _                   => assert(false);
      };
    }
  }
}
