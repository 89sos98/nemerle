(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Env;
open Nemerle.Collections;


namespace Nemerle.Compiler {

variant Decl_kind =
  [
    | D_local_fun { header : Fun_header; parents : list (Decl); }
    | D_fun_parm
    | D_local_value
    | D_exn
    | D_pattern_variable
    | D_class_member { mem : Class_member; }
  ]
  
class Decl 
  {
    field loc : Location;
    field name : string;
    field ref is_ref : bool;
    field ref ty : Type;
    field id : int;
    field kind : Decl_kind;
    
    field ref in_closure : bool;
    field ref closure_vars : list (Decl);
    field ref parent_fun : option (Decl);

    method this (n : string, k : Decl_kind, ty : Type, par : Decl)
      {
        this#loc <- Location_stack.top();
        this#name <- n;
        this#ty <- ty;
        this#kind <- k;
        this#is_ref <- false;
        this#closure_vars <- Nil (); 
        this#parent_fun <- Some (par);
        this#id <- Util.next_id();
      }

    method this (mem : Class_member)
      {
        this#loc <- mem#loc;
        this#name <- mem#env#current_namespace + mem#name;
        this#id <- mem#id;
        this#kind <- D_class_member(mem);
        this#parent_fun <- None ();
        this#closure_vars <- Nil (); 
        this#ty <-
          match mem with [
            | M_type => null
            | M_value (?t, ?rf) => { this#is_ref <- rf; t }
            | M_field (?t, ?rf) => { this#is_ref <- rf; t }
            | M_function (?h, _, _) => { Tyutil.fun_type (h) }
          ]
      }
  }

class Env 
  {
    value ref globals : String_map (list (Decl));
    value ref globals_by_id : Int_map (Decl);

    field ref open_namespaces : list (string);
    field ref current_namespace : string;
    field ref namespace_aliases : String_map (string);
    field ref locals : String_map (Decl);
    field ref parent_fun : option (Decl);
    
    fun strip_last_part (_ : string) : string = 
        extern "CS_glue.strip_last_part";
        
    fun strip_ns (_ : string) : string = extern "CS_glue.strip_ns";
    fun get_ns (_ : string) : string = extern "CS_glue.get_ns";

    fun add_global (pref : string, m : Class_member) : void =
      letfun allow_overload (d : Decl) : bool =
        let n =
          match d with [
            | { kind = D_class_member(?n) } => n
            | _ => Util.ice()
          ]
        in
        match (n, m) with [
          | (M_function {fun_kind = FK_method}, 
             M_function {fun_kind = FK_method}) => true
          | (M_function {fun_kind = FK_function}, 
             M_function {fun_kind = FK_function}) => true
          | (M_function {fun_kind = FK_iface_method}, 
             M_function {fun_kind = FK_iface_method}) => true
          | (M_function {fun_kind = ?k1}, 
             M_function {fun_kind = ?k2}) =>
               match (k1, k2) with [
                 | (FK_ctor, FK_ctor) => true
                 | (FK_ctor, FK_static_ctor) => true
                 | (FK_static_ctor, FK_ctor) => true
                 | (FK_static_ctor, FK_static_ctor) => true
                 | _ => false
               ]
          | (M_type (TD_variant_option), 
             M_type (TD_variant_option)) => true
          | _ => false
        ]
      in
      letfun do_add(fullname : string, d : Decl) : void =
//        let _ = Message.debug ("add " + fullname) in
        match globals#find (fullname) with [
          | Some (Cons (?x, ?xs)) =>
            if allow_overload (x) then
              globals <- globals#replace(fullname, Cons (d, Cons (x, xs)))
            else {
              Message.error (m#loc, "redefinition of `" + m#name + "'");
              Message.error (x#loc, "first defined here")
            }
          | Some (Nil) =>
            raise ICE("empty list in env")
          | None =>
            globals <- globals#add(fullname, List.cons(Decl(m)))
        ]
      in
      let decl = Decl(m) in
      {
        match m with [
          | M_type (TD_variant_option) =>
            {
              do_add(pref + m#name, decl);
              do_add(strip_last_part(pref) + m#name, decl);
            }
          | _ => do_add(pref + m#name, decl)
        ];
        if globals_by_id == null then globals_by_id <- Map.int_map () else ();
        globals_by_id <- globals_by_id#add (decl#id, decl)
      };

    fun global_by_id (id : int) : Decl =
      match globals_by_id#find (id) with [
        | Some (?r) => r
        | None => Util.ice ()
      ];

    method expand_namespace_aliases (sym : string) : string =
      let ns = get_ns (sym) in
      if ns == "" then sym
      else
        match this#namespace_aliases#find (ns) with [
          | Some (?r) => r + "." + strip_ns (sym)
          | None => sym
        ];

    fun lookup_global (name : string) : Decl =
      match globals#find (name) with [
        | Some (Cons (?x, Nil)) => x
        | Some (Cons) => Util.ice ("multibound internal symbol " + name)
        | None => Util.ice ("unbound internal symbol " + name)
      ];

    method bare_lookup(name : string) : list (Decl) =
      letfun append_not_in (acc : list (Decl), d : Decl) : list(Decl) =
        if List.exists(fun (x : Decl) : bool => x#id == d#id, acc) then
          acc
        else
          Cons(d, acc)
      in
      let name' = this#expand_namespace_aliases (name) in
      letfun lookup_in (acc : list (Decl), pref : string) : list (Decl) =
        match globals#find(pref + name') with [
          | Some (?lst) => 
            List.fold_left(append_not_in, acc, lst)
          | None => acc
        ]
      in
      if name == name' then
        match this#locals#find(name) with [
          | Some (?d) => 
            List.cons(d) // locals shadow globals
          | None =>
            let path = Cons("", Cons(this#current_namespace, 
                                     this#open_namespaces)) in
            List.fold_left(lookup_in, Nil(), path)
        ]
      else
        lookup_in (Nil (), "");
          
    method lookup_type(name : string) : Type_decl =
      match this#bare_lookup(name) with [
        | Cons({kind = D_class_member(M_type (?t))}, Nil) => t
        | Cons({kind = D_class_member(M_type)}, _) =>
          {
            Message.error("type name `" + name + "' is ambiguous:");
            letfun print_one(d : Decl) : void =
               Message.error(d#loc, "  - this")
            in List.iter(print_one, this#bare_lookup(name));
            raise Recovery();
          }
        | Nil =>
          Message.fatal_error("name `" + name + "' is unbound")
        | _ =>
          Message.fatal_error("name `" + name + "' was expected to be type")
      ];

    method add_open (ns : string) : void =
      let ns =
        if ns == "" then ns
        else ns + "."
      in
      this#open_namespaces <- List.append (this#open_namespaces, List.cons (ns));

    method add_namespace_alias (short_name : string, long_name : string) : void =
      this#namespace_aliases <- this#namespace_aliases#add(short_name, long_name);
    
    method add_local (name : string, kind : Decl_kind, ty : Type) : (Env * Decl) =
      let c = this#copy() in
      let d = Decl(name, kind, ty, Util.unsome (this#parent_fun)) in {
        c#locals <- c#locals#replace(name, d);
        (c, d)
      };
      
    method copy () : Env =
      let c = Env () in {
        c#open_namespaces <- this#open_namespaces;
        c#current_namespace <- this#current_namespace;
        c#namespace_aliases <- this#namespace_aliases;
        c#parent_fun <- this#parent_fun;
        c#locals <- this#locals;
        c
      };

    method this () 
      {
        this#current_namespace <- "";
        this#open_namespaces <- Nil();
        this#locals <- Map.string_map();
        this#namespace_aliases <- Map.string_map();
      }
  }


} // ns
