open Nemerle.Compiler;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;

namespace Nemerle.Compiler {

(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

class Tyinfo
  {
    variant Member =
      [
        | Mem_methods { methods : list (M_function); }
        | Mem_field { fld : M_field; }
      ]
      
    record Subtyping_relation
      {
        td : Type_decl;
        args : list (option (Type));
      }
    
    field enclosing_type : option (Type_decl);
    field tydecl : Type_decl;
    field ref subtypes : Int_map (Subtyping_relation);
    field ref members : String_map (Member);
    field ref working_on : bool;
    // FIXME methods to implement
    
    method this (par : option (Type_decl), td : Type_decl) 
      { 
        this#enclosing_type <- par;
        this#tydecl <- td;
      }

    method lookup_method (name : string) : list (M_function) =
      match this#members#find(name) with [
        | Some (Mem_methods (?x)) => x
        | _ => Nil()
      ];
      
    method lookup_field (name : string) : option (M_field) =
      match this#members#find(name) with [
        | Some (Mem_field (?x)) => Some(x)
        | _ => None()
      ];

    method how_subtypes (td : Type_decl) : option (list (option (Type))) =
      match this#subtypes#find(td#id) with [
        | Some (?sr) => Some(sr#args)
        | None => None()
      ];

    method full_name () : string = 
      let td = this#tydecl in td#env#current_namespace + td#name;

    method parent_tyinfos () : list (Tyinfo) =
      let td = this#tydecl in
      let types =
        match td#t_extends with [
          | Some (?t) => Cons (t, td#t_implements)
          | None => td#t_implements
        ]
      in
      letfun get_td (t : Type) : Tyinfo =
        match t with [
          | T_app ?a => lookup(a#ref_to)
          | _ =>
            {
              Message.error("cannot implement nor extend non-class type");
              raise Recovery()
            }
        ]
      in List.map(get_td, types);

    value ref infos : Int_map(Tyinfo);
    
    fun lookup (id : int) : Tyinfo =
      match infos#find(id) with [
        | Some (?ti) => ti
        | None => Util.ice()
      ];

    fun lookup (td : Type_decl) : Tyinfo = lookup(td#id);
    
    fun make (decls : list (Type_decl)) : void =
      letfun tydecl_f (par : option (Type_decl), d : Type_decl) : option (Type_decl) = {
        infos <- infos#add(d#id, Tyinfo(par, d));
        Some (d)
      } and decl_f (_ : option (Type_decl), _ : Class_member) : void = () 
      in {
        infos <- Map.int_map();
        Treeutil.decl_walk(tydecl_f, decl_f, None(), decls);
      };

    fun determine_subtyping () : void = 
      letfun make_srs (ti : Tyinfo) : void =
        if ti#subtypes != null then ()
        else
          Util.locate(ti#tydecl#loc, fun () : void =>
            if ti#working_on then
              Message.error("type definition for `" + ti#full_name() + "' is cyclic")
            else {
              ti#working_on <- true;
              List.iter(make_srs, ti#parent_tyinfos());
              ti#working_on <- false;
            }
          )
      in infos#iter(fun (_ : int, ti : Tyinfo) : void => make_srs(ti));

    fun run (decls : list (Type_decl)) : void {
      make(decls);
      determine_subtyping();
    }
  }

} // ns
