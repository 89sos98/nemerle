/* What is it and why is it so bad ?:
 * ==================================
 * This was the author's first program in Nemerle and in fact
 * his first piece of code in an OO language, which should
 * explain it's quality ;]
 * The program downloads and displays information about the 
 * audio CD present inside the drive, using a simple
 * ncurses(-sharp) menu.
 * This is by no means a complete and/or usefull tool, but
 * rather an example of Nemerle code.
 * 
 * Requirements:
 * =============
 * The dotnet environment for linux, apropriate compilers and
 * ncurses-sharp.
 *
 * Compiling:
 * ==========
 * $ gcc -shared -o getoffsets.so getoffsets.c
 * $ mcs -t:library -o provideoffsets.dll provideoffsets.cs 
 * $ ncc -r provideoffsets.dll -r Curses.dll projekt.n
 */

namespace Projekt
{
 using System;
 using System.IO;
 using System.Net;
 using System.Net.Dns;
 using System.Text.RegularExpressions;
 using System.Text.RegularExpressions.Regex;
 using System.Runtime.InteropServices;
 using Nemerle.Utility;
 using Nemerle.Collections;
 using Nemerle.Collections.List;
 using Nemerle.Text;

 module Projekt 
 {
  public static Main (): void {
   try {
    mutable device = "/dev/cdrom";
    mutable database = "http://freedb.freedb.org/~cddb/cddb.cgi";
    mutable helponly = false;

    def opts = [
     Getopt.String(name    = "--database",
                   aliases = ["-d"],
                   help    = "Specify the cd databse url (default: http://freedb.freedb.org/~cddb/cddb.cgi).",
                   handler = fun (s) { database = s; }),
     Getopt.Flag  (name = "--help",
                   aliases = ["-h"],
                   help = "Print this help and exit.",
                   handler = fun () { helponly = true; }),
     Getopt.String(name    = "--device",
                   aliases = ["-i"],
                   help    = "Specify the cd-rom device (default: /dev/cdrom).",
                   handler = fun (s) { device = s; })
    ];
    Getopt.Parse (opts);

    if (helponly) {
     Console.WriteLine(Getopt.Usage(opts));
    } else {
     def ui = UI.CursesIface();
     ui.WriteLine("Status:");
     ui.Write("* Reading CD TOC..");
     def cd = CD(device);
     ui.WriteLine(" Done.");
     ui.Write("* Checking localhost info..");
     def lcl = LocalInfo();
     ui.WriteLine(" Done.");
     ui.Write("* Sending DISCID query..");
     def db = CDDB(lcl, database);
     ui.WriteLine(" Done.");
     ui.Write("* Sending QUERY query..");
     def (heading,t) = db.QueryDiscInfoNoCateg(cd);
     ui.WriteLine(" Done.");
     ui.WriteLine("Finished.");

     def loop () :void {
      ui.NewPage();
      ui.GenerateMenu(heading,Map(t,fun(x) { "Genre: "+Replace(x,@"\+",@", discid: ") }),1);
      def choptnum = ui.NavigateMenu();
      def chopt = Nth(t,choptnum-1);
      db.QueryDiscInfoWithCateg(cd,chopt);
      ui.NewPage();
      Iter(cd.Details,fun(x: string, y: string) { 
                       match (y) {
                        | "" => ()
                        | _ => regexp match (x) {
                         | "TTITLE[0-9]+" => { def tnum = Int32.Parse(Replace(x,"[^0-9]","")) + 1;
                                               ui.WriteLine("Track "+tnum.ToString()+": "+y) }
                         | "DISCID" => ui.WriteLine("Discid: "+y)
                         | "DTITLE" => ui.WriteLine("Title: "+y)
                         | "DYEAR" => ui.WriteLine("Year: "+y)
                         | "DGENRE" => ui.WriteLine("Genre: "+y)
                         | "EXTD" => ui.WriteLine("Extended info: "+y)
                         | "EXTT[0-9]+" => { def tnum = Int32.Parse(Replace(x,"[^0-9]","")) + 1;
                                             ui.WriteLine("Extended track "+tnum.ToString()+": "+y) }
                         | "PLAYORDER" => ui.WriteLine("Playorder: "+y)
                         | _ => ui.WriteLine(x+": "+y) 
                        };
                       };
                      });     

      ui.WriteLine(""); 
      ui.WriteLine("");
      ui.WriteLine("Press any key to view the remaining matches, or 'q' to quit.");
      when (Curses.Input.GetNextChar() != ('q' :> int))
       loop()
     }

     if (heading != "No match found")
      loop();
     else {
      ui.NewPage();
      ui.WriteLine("Sorry, no matches found for this CD.");
      def _ = Curses.Input.GetNextChar();
      ()
     }
    };
   } catch { 
    | e : Exception => { 
       def dc = Curses.Window.Screen.DrawingContext;
       dc.Clear();
       dc.Move(1,1);
       dc.Add(e.Message);
       dc.Refresh();
       def _ = Curses.Input.GetNextChar();
       ()
    }
   } finally {
    Curses.Setup.Exit (0);
   };
  }
 }

 namespace UI
 {
  public class CursesIface
  {
   mutable Heading: string;
   mutable Options: list <string>;
   mutable OptionsAmnt: int;
   mutable ChOpt: int;
   dc: Curses.DrawingContext;
   mutable xpos: int;
   mutable ypos: int;

   public this () {
    unless (Curses.Setup.Initialize ())
     throw System.Exception ("Cannot initialize curses.");
    dc = Curses.Window.Screen.DrawingContext;
    dc.Clear();
    xpos = 1;
    ypos = 1;
    dc.Move(xpos,ypos);
    dc.Background = Curses.Color.Black;
    dc.Foreground = Curses.Color.White;
   }

   public NewPage () :void {
    xpos = 1;
    ypos = 1;
    dc.Move(xpos,ypos);
    dc.Clear();
   }
  
   public WriteLine (s: string) :void {
    dc.Move(xpos,ypos);
    dc.Add(s);
    dc.Refresh();
    ++ypos;
    xpos = 1;
   }
  
   public Write (s: string) :void {
    dc.Move(xpos,ypos);
    dc.Add(s);
    dc.Refresh();
    xpos += s.Length;
   }

   public GenerateMenu (h: string, o: list <string>, i: int) :void {
    xpos = 1;
    ypos = 1;
    Heading = h;
    Options = o;
    OptionsAmnt = Length(Options);
    ChOpt = i;
    dc.Move(1,3);
    dc.Clear();
    WriteLine(Heading);
    WriteLine("");
    def startpos = (xpos, ypos);

    def printoptions (l: list <string>, i: int, acc: int) :void {
     match(l) {
      | h::t => { if (acc == i) {
                   dc.Background = Curses.Color.Blue;
                   WriteLine(h); 
                   dc.Background = Curses.Color.Black;
                   WriteLine(""); 
                  } else {
                   WriteLine(h);
                   WriteLine("");
                  };
                  printoptions(t,i,acc+1) }
      | [] => ()
     };
    };
  
    printoptions(Options,ChOpt,1);
    dc.Move(startpos);
    dc.Refresh();
   }
   
   public NavigateMenu () :int {
    def loop (x) {
     if (x == Curses.KeyCode.KEY_DOWN || x == ('j' :> int)) {
      ChOpt = ChOpt % OptionsAmnt + 1; 
      GenerateMenu(Heading,Options,ChOpt); 
      loop (Curses.Input.GetNextChar());
     } else if (x == Curses.KeyCode.KEY_UP || x == ('k' :> int)) {
      if (ChOpt==1)
       ChOpt = OptionsAmnt;
      else
       --ChOpt;
      GenerateMenu(Heading,Options,ChOpt);
      loop (Curses.Input.GetNextChar());
     } else if (x == 0x000D || x == Curses.KeyCode.KEY_ENTER || x == Curses.KeyCode.KEY_RIGHT || x == ('l' :> int)) 
      ()
     else loop (Curses.Input.GetNextChar());
    };
    loop (Curses.Input.GetNextChar());
    ChOpt
   }
  }
 }

 public class LocalInfo
 {
  public HostName: string;
  public UserName: string;
  public ClientName: string;
  public ClientVersion: string;
  public ClientProto: string;

  /* FIXME: user, cname, cversion, cproto */
  public this () {
   try {
    HostName = Dns.GetHostName();
   } catch {
    | e : Exception => { 
          HostName = "localhost"; 
          throw Exception("Unable to set hostname. Using \"localhost\" instead. Reason: "+e.Message); 
    };
   };
   UserName = "user";
   ClientName = "testclient";
   ClientVersion = "0.1";
   ClientProto = "6";
  }
 }

 public class CDDB
 {
  public DB: string;
  public Hello: string;

  public this (l: LocalInfo, db: string) {
   DB = db;
   Hello = MakeQueryString(["hello=",l.UserName,l.HostName,l.ClientName,l.ClientVersion,"proto=",l.ClientProto]);
  }

  /* FIXME: error handling */
  public QueryDiscid(cd: CD) :void {
   def query = MakeQueryString(["cmd=discid",cd.QOffsets,Hello]);
   def rs = StreamReader(WebRequest.Create(DB+"?"+query).GetResponse().GetResponseStream());
   cd.DISCID = Replace(rs.ReadLine(),".* ","");
   rs.Close();
  }  

  public QueryDiscInfoNoCateg(cd: CD) :string * list <string> {
   when (cd.DISCID == null)
    QueryDiscid(cd);
   def query = MakeQueryString(["cmd=cddb+query",cd.DISCID,cd.QOffsets,Hello]);
   def rs = StreamReader(WebRequest.Create(DB+"?"+query).GetResponse().GetResponseStream());

   def mkretlist (sr: StreamReader) {
    def r = sr.ReadLine();
    match(r) {
     | "." | null => { sr.Close(); [] }
     | _ => Replace(r,@"(\w+) (\w+) .*",@"$1+$2") :: mkretlist(sr) 
    };
   };

   /* FIXME: other responses */
   def r = rs.ReadLine();
   match (r.Substring(0,3)) {
    | "200" => ("Found exact match.",[Replace(r,@"(\w+) (\w+) (\w+) .*",@"$2+$3")])
    | "210" => ("Found multiple matches.",mkretlist(rs))
    | "211" => ("Found inexact match(es).",mkretlist(rs))
    | _ => ("No match found",mkretlist(rs))
   };
  }

  public QueryDiscInfoWithCateg(cd: CD, s: string) :void  {
   when (cd.DISCID == null)
    QueryDiscid(cd);
   def query = MakeQueryString(["cmd=cddb+read",s,Hello]);
   def rs = StreamReader(WebRequest.Create(DB+"?"+query).GetResponse().GetResponseStream());

   def pairsplit (s: string, p: string) :(string*string) {
    def q = s.IndexOf(p);
    (s.Substring(0,q),s.Substring(q+1,s.Length-q-1))
   };

   def rr (sr: StreamReader) :list <(string*string)> {
    def r = sr.ReadLine();
    if (r == "." || r == null)
     []
    else if (r.IndexOf("=") > -1) 
     pairsplit(r,"=")::rr(sr)
    else
     rr(sr)
   };
   cd.Details = rr(rs);
  }

  private MakeQueryString (li: list <string>): string {
   def aux (sep: string, l: list <string>) {
    match (l) {
     | h::t => if (h.IndexOf("=") > -1)
                if (sep == "BEGIN") 
                 if (h.IndexOf("=")<h.Length-1) h+aux("+",t) else h+aux("",t) 
                else
                 if (h.IndexOf("=")<h.Length-1) "&"+h+aux("+",t) else "&"+h+aux("",t) 
               else
                if (sep == "BEGIN")
                 h+aux("+",t)
                else
                 sep+h+aux("+",t)
     | [] => ""
    }
   };
   aux ("BEGIN",li)
  }  
 }

 public class CD
 {
  public mutable Details: list <(string*string)>;

  public mutable DISCID: string;
  public Offsets: string;
  public QOffsets: string;

  public this (dev: string) {
   Offsets = MyExtrn.Offsets.GetOffsetString(dev);
   QOffsets = Offsets.Replace(" ","+");
   when (Offsets == "")
    throw Exception("Could not read CD TOC")
  }
 }
}
