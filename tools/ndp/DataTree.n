

namespace NemerleDoc
{

  using System;
  using Nemerle.Collections;
  using System.Reflection;

  /// <summary>
  /// Contains common html headers and footers, generates and writes html to a file.
  /// </summary>  
  internal module HtmlGenerator
  {
    
    // how the  n-tuple looks like in true speech
    nemerle_tuple(n : int, start_index : int = 1) : string
    {
      mutable res = "Nemerle.Builtins.Tuple`" + n.ToString() + "[";
      mutable i = start_index;
      while (i < n) { res += "'p" + i.ToString() + ","; ++i }
      res += "'p" + i.ToString() + "]";
      res
    }
    
    n_tuple(n : int) : string
    {
      mutable res = "(";
      mutable i = 1;
      while (i < n) { res += "'p" + i.ToString() + ","; ++i }
      res += "'p" + i.ToString() + ")";
      res
    }
    
    /// <summary>
    /// Replaces some complicated functions to simpler ones.
    /// </summary>
    replace (text : System.Text.StringBuilder) : void
    {
      // first deal with Nemerle.Builtins.Tuples*
      for (mutable i = 1, i < 21, ++i) {
        def orig_tuple = nemerle_tuple(i);
        def repl_tuple = "<span title=\"" + orig_tuple + "\">" + n_tuple(i) + "</span>";
        _ = text.Replace(orig_tuple, repl_tuple);
      }
      
    }
    /// <summary>
    /// Writes a html file. f is a function returns a body string.
    /// </summary>
    public Page (f : void -> string, fname : string) : void
    {
    
        def body = f();
        
        def buf = System.Text.StringBuilder();
        _ = buf.Append("<?xml version=\"1.0\"?>\n");
        _ = buf.Append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n");
        _ = buf.Append("  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n");
        _ = buf.Append("<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n");
        _ = buf.Append("<head>\n");
        _ = buf.Append("<title>Nemerle Documentation Project</title>\n");
        _ = buf.Append("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n");
        _ = buf.Append("<link rel=\"stylesheet\" type=\"text/css\" href=\"nemerle-doc.css\" />\n");
        _ = buf.Append("</head>\n");
        _ = buf.Append("<body>\n");
        _ = buf.Append(body);
        _ = buf.Append("<div class=\"footer\">Nemerle Documentation Project</div>");
        _ = buf.Append("</body>\n");
        _ = buf.Append("</html>\n");
        
        // some refinements
        // replace(buf);
        _ = buf.Replace("&", "&amp;");

        def outf = IO.StreamWriter(fname);
        outf.Write(buf);
        outf.Close();
        // Console.WriteLine("---> zapis do {0}", fname);
    }

    /// <summary>
    /// Generates a header of a page.
    /// </summary>
    public Title (title : string, subtitle : string) : string
    {
      mutable content = "";
      content += "<div class=\"title\">";
      content += "<span class=\"title\">" + title + "</span><br />";
      content += "<span class=\"subtitle\">";
      content += subtitle;
      content += "</span>";
      content += "</div>\n\n";
      content;  
    }
  } // module htmlgenerator

  /// <summary>
  /// Type of an element, set by XML parser (see: T:, M:, F: elements)
  /// </summary>
  public variant ElementType
  {
    | Unknown
    | Property
    | Method
    | Field
    | Event
    | Type
  }

  /// <summary>
  /// Records attributes dragged from assemblies by reflection
  /// </summary>
  [Record]
  sealed class ReflAttribs
  {
    internal is_interface : bool;
    internal is_abstract : bool;
    internal is_class : bool;
    internal is_array : bool;
    internal attr : System.Reflection.TypeAttributes;
    internal Private : bool
    {
      // get { (attr & TypeAttributes.NotPublic != 0) || (attr & TypeAttributes.NestedPrivate != 0) }
      get { (attr & TypeAttributes.Public == 0)  }
    }
  }  // Atributes

  /// <summary>
  /// Top node of a tree. It must be always namespace, it is a root namespace.
  /// </summary>
  public class TopNode
  {
    // it is a list of elements
    internal mutable elements : list [ Node ] = [];
    
    /// <summary>An anchor ref, used in html generation</summary>
    public virtual href () : string 
    {
      this.ToString() + this.GetHashCode().ToString()
    }
    
    /// <summary>Returns the name of a html file which includes a description of the current element</summary>
    internal virtual html_file() : string
    {
        "index.html"
    }
  
    internal mutable attribute : ReflAttribs;

    // attributes dragged out from XML file  
    internal mutable comment : string = "";
    internal mutable remark  : string = "";
    internal mutable return  : string = "";
    internal mutable param   : string = "";
    internal mutable example : string = "";
    internal mutable exception : string = "";
    internal mutable permission : string = "";
  
    /// <summary>
    /// Given list of elements, it creates a div block in the form of a table of content.
    /// </summary>
    /// <remarks>Used in index.html</remarks>
    internal listOfContent (elements : list [ Node ], ns : string, publicOnly : bool) : string
    {
      mutable res = "";
      res += "<div class=\"ns-index\">\n";
      res += "<span class=\"ns-index\" id=\"" + this.href() + "\">" + (if (ns.Length == 0) "Root namespace" else "Namespace " + ns) +"</span>\n";
      
      // do TOC in the following order: first ordered namespaces, then ordered classes
      def sort = fun (x, y) { String.Compare(x.name, y.name) };
      def class_list = List.Sort(List.RevFilter(elements, fun (cl) { cl.XMLattrib.Equals(ElementType.Type() ) }), sort);
      def ns_list = List.Sort(List.RevFilter(elements, fun (cl) { cl.XMLattrib.Equals(ElementType.Unknown() ) }), sort);
      def ord_list = ns_list + class_list;
      
      foreach (e in ord_list)
        when (!publicOnly || (e.attribute == null  || !e.attribute.Private))
          when (e.XMLattrib.Equals(ElementType.Type()) || e.XMLattrib.Equals(ElementType.Unknown()))
          {
            // for each namespace a separate html file is generated. So, if e is another namespace the
            // reference must point to another file, otherwise to the current file
            def ahref = match (e.XMLattrib) { | Unknown => "#" + e.href() | _ => e.html_file() + "#" + e.href() };
            
            res += "<div title=\"" + e.full_name + "\" class=\"index-element\">";
            res += match (e.XMLattrib) { | Type => "class" | Unknown => "namespace" | _ => e.XMLattrib.ToString() };
            res += " ";
            res += "<a href=\"" + ahref + "\">" + e.name + "</a>";
            res += if (comment.Length > 0) "<div class=\"comment\">Comment: " + comment + "</div>" else "";
            res += if (remark.Length > 0) "<div class=\"remark\">Remark: " + remark + "</div>" else "";
            res += "</div>\n";
          }
      res += "</div>\n";
      res
    }
  
    /// <summary>Creates body of TOC for the current namespace. The current node is
    /// always a namespace.</summary>
    /// <remarks>Used in index.html</remarks>
    internal virtual ToIndex (content : ref string, publicOnly : bool) : void
    {
      // first group types in the root namespace
      mutable is_root_ns = false;
      foreach (e in elements)      
        when (e.XMLattrib.Equals(ElementType.Type())) is_root_ns = true;
    
      // add elements in root
      when (is_root_ns)
      {
        content += listOfContent(this.elements, "", publicOnly);
        foreach (e in this.elements)
            unless (e.XMLattrib.Equals(ElementType.Unknown()))
              when (!publicOnly || (e.attribute == null || !e.attribute.Private))
                content += e.ToHtml()
      }
      
      // create toc for nested namespaces recursively
      foreach (e in elements)
         when (e.XMLattrib.Equals(ElementType.Unknown()))
             e.ToIndex(ref content, publicOnly)
   }
  
    /// <summary>
    /// This method is called for each 'namespace' element of the tree, what results in
    /// in a html file for each namespace.
    /// </summary>
    public virtual createPages (publicOnly : bool, title : string) : void
    {       
      foreach (e in elements)
          when (e.XMLattrib.Equals(ElementType.Unknown())) e.createPages(publicOnly, title);    
    }
  
    /// <summary>Add comment to the current element</summary>
    public Comment(str : string) : void { 
      this.comment += str;
    }
  
    /// <summary>Add remark to the current element</summary>
    public Remark(str : string) : void { 
      this.remark += str;
    }
  
    /// <summary>Add return info to the current element</summary>
    public Return(str : string) : void { 
      this.return += str;
    }
  
    /// <summary>Add param info to the current element</summary>
    public Param(str : string) : void { 
      this.param += str;
    }   
  
    /// <summary>Add example to the current element</summary>
    public Example(str : string) : void { 
      this.example += str;
    }   
    
    /// <summary>Add exception description to the current element</summary>
    public Exception(str : string) : void { 
      this.exception += str;
    }   
    
    /// <summary>Add permission description to the current element</summary>
    public Permission(str : string) : void { 
      this.permission += str;
    }
    
    mutable internal seealso : string;
    internal SeeAlso(name : string) : void {
       this.seealso = name;
    }
    
    internal postAnalysis () : void
    {          
        foreach (elem in elements) elem.postAnalysis()
    }
    
    internal mutable datatree : DataTree;
    
    internal this (dt : DataTree)
    {
      this.datatree = dt;
    }
    
    internal this () {}
    
  } // class TopNode

  
  /// <summary>
  /// Represents a 'concrete' (i.e. classes, fields, methods etc.) elements.
  /// </summary>
  public class Node : TopNode
  {
    internal mutable parent : TopNode;
    
    /// <summary>A type of of a node.
    /// This field is set by XML analyzer</summary>
    public mutable XMLattrib : ElementType = ElementType.Unknown();
    
    /// <summary>Name of the element</summary>
    public mutable name : string;
    
    /// <summary>An anchor ref, used in html generation</summary>
    public override href () : string 
    {
      if (XMLattrib.Equals(ElementType.Unknown())) this.ToString() + this.GetHashCode().ToString()
      else "id" + this.GetHashCode().ToString()
    }
    
    /// <summary>Full name of the element (with namespace path)</summary>
    public mutable full_name : string = "";
  
    /// <summary>Returns the name of a file including description of the current node</summary>
    internal override html_file (): string
    {
      if (this.XMLattrib.Equals(ElementType.Unknown())) this.full_name + ".html"
      else this.parent.html_file()
    }
    
    /// <summary>If the current node is a namespace, it creates a table of content.</summary>
    /// <remarks>Used in index.html</remarks>
    internal override ToIndex (content : ref string, publicOnly : bool) : void
    {
      when (this.XMLattrib.Equals(ElementType.Unknown()))
      {
        // self-explanation
        content += listOfContent(this.elements, this.full_name, publicOnly);
    
        foreach (e in elements)
          when (e.XMLattrib.Equals(ElementType.Unknown())) e.ToIndex(ref content, publicOnly : bool);
      }
    }

    /// <summary>Creates a html page for the current namespace</summary>
    public override createPages (publicOnly : bool, title : string) : void
    {    
      // Console.WriteLine("Zapis pliku {0}", this);
      // crreates a html page for the current namespace
      when (this.XMLattrib.Equals(ElementType.Unknown()))
      {
        def fname = this.full_name;
        mutable content = "";
        content += HtmlGenerator.Title(title, "Namespace " + fname);
        foreach (e in elements) {
          mutable priv = false;
          when (e.attribute != null)
              priv = e.attribute.Private;
          // Console.WriteLine("--> Element={0}, publicOnly={1}, priv={2}, cond={3}", e.name, publicOnly, priv, !publicOnly || !priv);
          when (!publicOnly || !priv)
            content += e.ToHtml();
          }
        HtmlGenerator.Page ( fun () { content }, this.html_file ());
      }
   
      // creates a html page for each sub namespace
      foreach (e in elements)
        when (e.XMLattrib.Equals(ElementType.Unknown()))
          e.createPages(publicOnly, title);
    }
  
    internal new postAnalysis () : void
    {
        // first, fix the following problem: there exist references, e.g. Nemerle.Builtins.Function.apply,
        // where Nemerle.Builtins is a namespace, Function - class, and apply - method.
        // but there is no class declaration. It makes then problems.
        when (this.XMLattrib.Equals(ElementType.Unknown()))
          foreach (elem in this.elements)
            when (elem.XMLattrib.Equals(ElementType.Method()))
            {
              // this must be a type
              this.XMLattrib = ElementType.Type();
              // Console.WriteLine("Fixed {0}, assigned for {1}", elem.full_name, this.full_name);
              // Console.WriteLine((next.parent :> Node).XMLattrib);
            }
            
        // now find reference for seealso tag
        when (this.datatree.seealsoDict != null)
        {
          // find a reference
          mutable key = null;
          foreach (kV in this.datatree.seealsoDict)
            when (name.StartsWith(kV.Key)) key = kV.Key;
          when (key != null)
          {
           // Console.WriteLine("Dodanie do klucza" +  key);
           this.datatree.seealsoDict[key] = this;
          }
        }
            
        foreach (elem in elements) elem.postAnalysis()
    }

    public this(name : string, prefiks : string, parent : TopNode)
    {
      this.name = name;
      this.full_name = prefiks;
      this.parent = parent;
      this.datatree = parent.datatree;
      // Console.WriteLine("Nowy element Name " + prefiks);
    }

  
    filteredIter (l : list [ Node ], cond : Node -> bool, iter : Node -> string) : string
    {
      // ctors to the beginning!
      def sort = fun (a : Node, b : Node) {
      
        // ctor(System.String) are compared incorrectly, so use the prefix
        def comp_a = if (a.name.StartsWith(".ctor")) ".ctor" else if (a.name.StartsWith("ctor")) "ctor" else if (a.name.StartsWith("cctor")) "cctor" else a.name;
        def comp_b = if (b.name.StartsWith(".ctor")) ".ctor" else if (b.name.StartsWith("ctor")) "ctor" else if (b.name.StartsWith("cctor")) "cctor" else b.name;
        
        def r = match ((comp_a, comp_b)) {
          | (".ctor", "ctor") => -1
          | ("ctor", ".ctor") => 1
          | (".ctor", "cctor") => -1
          | ("cctor", ".ctor") => 1
          | ("ctor", "cctor") => -1
          | ("cctor", "ctor") => 1
          | (".ctor", _) => -1
          | (_, ".ctor") => 1
          | ("ctor", _) => -1
          | (_, "ctor") => 1
          | ("cctor", _) => -1
          | (_, "cctor") => 1
          | _ => String.Compare(a.name, b.name)
        }
        // Console.WriteLine("Porównanie '{0}' i '{1}' zwraca {2}", a.name, b.name, r);
        r;
      };
      // first sort the list
      def l1 = Nemerle.Collections.List.Sort(l, sort);
      // foreach (x in l1) Console.WriteLine(x.name);
      mutable res = "";
      foreach (e in l1) when (cond(e)) res += iter(e);
      res;
    }
  
    /// <summary>Create a full html description of the current node.</summary>
    public ToHtml () : string
    {
      mutable res = "";
      mutable com = if (comment.Length > 0) "<div class=\"comment\">" + comment + "</div>\n" else "";
      com += if (remark.Length > 0) "<div class=\"remark\">Remark: " + remark + "</div>\n" else "";
      com += if (return.Length > 0) "<div class=\"return\">Return: " + return + "</div>\n" else "";
      com += if (param.Length > 0) "<div class=\"param\">Parameter: " + param + "</div>\n" else "";
      com += if (example.Length > 0) "<div class=\"example\">Example:<br />" + example + "</div>\n" else "";
      com += if (exception.Length > 0) "<div class=\"exception\">Exception:<br />" + exception + "</div>\n" else "";
      com += if (permission.Length > 0) "<div class=\"permission\">Permission:<br />" + permission + "</div>\n" else "";
      // resolve 'seealso'
      when (this.seealso != null && this.seealso.Length > 0)
      {
        com += "<div class=\"seealso\">See also ";
        def refTo = this.datatree.seealsoDict[this.seealso];
        if (this.datatree.seealsoDict.Contains(this.seealso) && refTo != null)
        {
          def ahref = (if (this.html_file().Equals(refTo.html_file())) "" else refTo.html_file()) + "#" + refTo.href ();
          com += "<a href=\"" + ahref + "\">" + this.seealso + "</a>"
        }
        else
        {
          com += this.seealso;
          Console.WriteLine("*** Warning: 'seealso' reference '{0}' cannot be resolved", this.seealso);
        }
        com += "</div>\n";
      }
    
      mutable att = "";
      when (attribute != null)
      {
        when ( (attribute.attr & TypeAttributes.NotPublic) != 0) att += " notpublic ";
        when ( (attribute.attr & TypeAttributes.Sealed) != 0) att += " sealed ";
        // when ( attribute.Private) att += " PRIVATE ";
        when (attribute.is_abstract) att += " abstract ";
        when ( (attribute.attr & TypeAttributes.NestedPublic) != 0) att += " nested public class ";
        when (attribute.is_class && att.IndexOf("class") == -1) att += " class ";
        when ( (attribute.attr & TypeAttributes.Public) != 0 && att.IndexOf("public") == -1) att += " public ";
        when (attribute.is_array) att += " array ";
        when (attribute.is_interface) att += " interface ";
        // last chance
        when (att.Length == 0) att = attribute.attr.ToString();
      }
      
      when (this.XMLattrib != null && this.XMLattrib.Equals(ElementType.Type()) && att.IndexOf("class") == -1)
        att += " class ";
    
      match (XMLattrib) {
        | Unknown => 
            res += "<div>Unknown element " + this.full_name + "</div>";
            
        | Property => res += "<span title=\"" + this.full_name + "\">" + att + name + "</span>" + com;
        
        | Method => res += "<span title=\"" + this.full_name + "\">" + att + name + "</span>" + com;
        
        | Field => res += att + name + com;
        
        | Event => res += att + name + com;
        
        | Type =>
            res += "<div class=\"ns-index\"" + (" id=\"" + this.href() + "\"") + ">" + att;
            res += "<span class=\"ns-index\" title=\"" + this.full_name + "\">" + name + "</span>\n";
            res += com;
          
            def mk_element = fun (e) { "<div class=\"element\" id=\"" + e.href() + "\">" + e.ToHtml() + "</div>\n"};
            def mk_type = fun (e) { "<div class=\"element\">" + e.ToHtml() + "</div>\n"};
            
            def methods = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Method()) }, mk_element  );
            when (methods.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Methods:</span>" + methods + "</div>";
          
            def events = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Event()) }, mk_element  );
            when (events.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Events:</span>" + events + "</div>";
          
            def props = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Property()) }, mk_element);
            when (props.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Properties:</span>" + props + "</div>";
          
            def fields = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Field()) },   mk_element);
            when (fields.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Fields:</span>" + fields + "</div>";
          
            def types = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Type()) },  mk_type);
            when (types.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Types:</span>" + types + "</div>";
          
            res += "</div>\n";
      }
      res  
    } // method ToHtml
  } // class Node

  /// <summary>
  /// The class DataTree is a front-end for other modules which analyse input files.
  /// </summary>
  class DataTree
  {
    split (str : string) : char*string { (str[0], str.Substring(2)) }
    
    // top node of the tree
    mutable tree : TopNode = TopNode(this);
    
    // recently added or processed node.
    mutable currentNode : Node;
    
    // list of the sources
    mutable sources : list [ string ] = [];

    ///<summary>Creates a string (html) representation of the sources of the program</summary>
    public sourcesToString () : string
    {
      mutable res = "";
      res += 
          match (sources.Length) {
                | 0 => "No sources?"
                | 1 => "Source: "
                | _ => "Sources:<br /> "
          }
      when (sources.Length > 0)
      {
        res += List.Head(sources);
        def r = List.Tail(sources);
        foreach (e in r) res += ", " + e;
      }
      res
    }
  
    /// <summary> Adds info about a file name being the current input</summary>
    public AddSource(src : string) : void
    {
      sources += [ src ]
    }     
  
    smart_strip1(path : string) : list [ string ]
    {
      smart_strip(path, '(')
    }
  
    /// <summary>Strip, but avoid stripping '[' char</summary>
    smart_strip2(path : string) : list [ string ]
    {
      smart_strip(path, '[')
    }
  
    smart_strip(path : string, sep : char) : list [ string ]
    {
      // first split into name and parameters
      def par_pos = path.IndexOf(sep);
      def path_name = if (par_pos != -1) path.Substring(0, par_pos) else path;
      def param = if (par_pos != -1) path.Substring(par_pos) else "";
     
      // Console.WriteLine("{0} = ({1},{2})", path, path_name, param);
    
      mutable token_list = Nemerle.Collections.List.FromArray(path_name.Split(array ['.', '+']));
      mutable res = [];
      // analyze name
      while (token_list.Length > 1)
      {
        mutable r = List.Hd(token_list);
  
        // when not .., i.e. ctor
        when (r.Length != 0)
        {
          res += [ r ];
          // Console.WriteLine("<-- " + r);
        }
        when (token_list.Length > 0) token_list = List.Tl(token_list)
      } // while ()
      def last = List.Hd(token_list);
      def last_token = if (par_pos > -1) (last + param) else last;
      res += [ last_token ];
      res
    }
  
    // From XML, names are with arguments, but from assembly without, so
    // we have to compare
    private equal_names(x : string, y : string) : bool
    {
      mutable res = x.Equals(y);
      when (!res && x.Length != y.Length)
      {
        def patt = ['(', '['];
        when (x.StartsWith(y) && patt.Contains(x[y.Length])) res = true;
        when (y.StartsWith(x) && patt.Contains(y[x.Length])) res = true;
        
        // when (!res && (x.StartsWith(y) || y.StartsWith(x))) Console.WriteLine("Not equals {0}<>{1}", x, y);
      }
      // when (res && x.Length != y.Length) Console.WriteLine("Considered equal names: {0}={1}", x, y);
      res;
    }
    
    memb (set : TopNode, name : string) : Node
    {
      mutable res = null;
      foreach (e in set.elements) // when (name.Equals(e.name)) res = e;
          when (equal_names(e.name, name)){
              res = e;
              when (name.Length > e.name.Length) e.name = name;
          }
      res;
    }
  
    /// <summary>
    /// Adds a new element (typically a class) to the tree. Used by assembly analyzer.
    /// </summary>
    public AddItem(str : string, ty : ElementType, attr : ReflAttribs) : void
    {
      def path = smart_strip2(str);
      // Console.WriteLine("Ścieżka {0}", str);
      // foreach (x in path) Console.WriteLine("--> {0}", x);
      mutable pointer = tree;
      mutable next;
      foreach (edge in path)
      {    
        // Console.WriteLine("--> podścieżka " + edge);
        next = memb(pointer, edge);
        // if there are two 'equal' names, e.g. Main and Main(srting[])
        // when (next != null && edge.Length > next.name.Length) next.name = edge;
        
        when (next == null)
        {
          def pref = if (pointer is Node) ((pointer :> Node).full_name + "." + edge) else edge;
          next = Node(edge, pref, pointer);
          pointer.elements = pointer.elements + [ next ];
        }
        pointer = next;
      }
      pointer.attribute = attr;
      next.XMLattrib = ty
    } // AddItem
  

    /// <summary>
    /// Adds a new element (a member of a class) to the tree. Used by assembly analyzer.
    /// </summary>
    public AddItem(ns_path : string, typename : string, ty : ElementType) : void
    {
      def path = smart_strip2(ns_path) + [ typename ];
      // Console.WriteLine("Ścieżka {0}, typename {1}, type: {2}", ns_path, typename, ty);
      // foreach (x in path) Console.WriteLine("*** " + x);
      mutable pointer = tree;
      mutable next;
      foreach (edge in path)
      {    
        // Console.WriteLine("--> podścieżka " + edge);
        next = memb(pointer, edge);
        when (next == null)
        {
          def prefix = if (pointer is Node) ((pointer :> Node).full_name + "." + edge) else edge;
          next = Node(edge, prefix, pointer);
          pointer.elements = pointer.elements + [ next ];
        }
        pointer = next;
      }
      next.XMLattrib = ty;
      
    }
  
    /// <summary>
    /// Add a new element to the tree. An argument is a string consisting of
    /// a stringified declaration of an element. Used by the XML analyzer.
    /// </summary>
    public AddItem (str : string) : void
    {
      // System.Console.WriteLine("---> " + str);
      def (tySy, path) = split(str);
      // System.Console.WriteLine("---> split({0}) = ({1}, {2})", str, tySy, path);
      def ty = 
        match (tySy) {
          | 'T' => ElementType.Type();
          | 'F' => ElementType.Field();
          | 'M' => ElementType.Method();
          | 'P' => ElementType.Property()
          | 'E' => ElementType.Event()
          |  _  => Console.WriteLine("*** Warning: the value '{0}' of the attribute 'name' is not supported", tySy); ElementType.Unknown()
        }
    
      def pathList = smart_strip1(path);
      // Console.WriteLine("Path to strip: {0}", path);
      // foreach (n in pathList) Console.WriteLine("--> {0}", n);
      mutable pointer = tree;
      mutable next;
      foreach (edge in pathList)
      {    
        next = memb(pointer, edge);
        when (next == null)
        {
          def pref = if (pointer is Node) ((pointer :> Node).full_name + "." + edge) else edge;
          next = Node(edge, pref, pointer);
          pointer.elements = pointer.elements + [ next ];
        }
        pointer = next;
      }
      currentNode = next;
      currentNode.XMLattrib = ty;
      // Console.WriteLine("Added {0} {1}", tree.current.full_name, tree.current.elemType);
    }
    
    public AddComment (str : string) : void 
    {
      currentNode.Comment(str);
    }
  
    public AddRemark (str : string) : void 
    {
      currentNode.Remark(str);
    }
  
    public AddReturn (str : string) : void 
    {
      currentNode.Return(str);
    }
  
    public AddParam (str : string) : void 
    {
      currentNode.Param(str);
    }
  
    public AddExample (str : string) : void 
    {
      currentNode.Example(str);
    }
  
    public AddException (str : string) : void 
    {
      currentNode.Exception(str);
    }
    
    public AddPermission (str : string) : void 
    {
      currentNode.Permission(str);
    }
    
    // neccessary for 'seealso'
    mutable internal seealsoDict : Nemerle.Collections.Hashtable[string, TopNode];
    
    public AddSeeAlso(name : string) : void
    {
      when (seealsoDict == null) seealsoDict = Nemerle.Collections.Hashtable();
      
      seealsoDict[name] = null;
      currentNode.SeeAlso(name);
    }
    
    // creates a TOC
    index_content (publicOnly : bool, title : string) : string
    {
      mutable content = "";
      def t = if (title.Length == 0) "Nemerle Library" else title;
      content += HtmlGenerator.Title(t, this.sourcesToString());
      // teraz zawartość
     
      tree.ToIndex(ref content, publicOnly);
      content;
    }
  
  
    /// <seealso cref="AddSeeAlso"/>
    public ToHtml (publicOnly : bool, title : string) : void
    {
      tree.postAnalysis();
      // foreach ((k,v) in seealsoDict.KeyValuePairs) Console.WriteLine("({0}, {1}", k, v);
      
      HtmlGenerator.Page(fun () { index_content(publicOnly, title) }, "index.html");
      tree.createPages(publicOnly, title);
    }
    
  
  } // class DataTree

} // namespace NemerleDoc
