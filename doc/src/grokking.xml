<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Grokking Nemerle</title>

  <friendly>Don't Panic!</friendly>

  <motto from="wizard">
    ,,This is as rock; tolk in the True Speech.''
  </motto>


  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        This document contains materials used to teach Nemerle during
        the ,,Nemerle Programming Language'' course taught at our
        institute. It should make a good tutorial. For more information
        about the lecture itself please visit <link>lecture.html</link>.
      </p>
      <p>
        There are references to various languages throughout this document.
        If you don't know much about these languages -- just ignore these
        remarks. As for remarks for the C language -- unless otherwise
        stated they also apply to C# and Java.
      </p>
      <p>
        Some links: <a
        ref="http://en.wikipedia.org/wiki/Grok">grokking?!</a>, <a
        ref="http://en.wikipedia.org/wiki/The_Hitchhiker's_Guide_to_the_Galaxy">don't
        panic</a>.
      </p>
    </body>

  </section>
    
  

  <section id="base-structure-of-programs">
    <title>Base structure of programs</title>
    <body>
      <p>
        This chapter explains how a basic program looks like
        in Nemerle.
      </p>
    </body>
    
  
    <subsection id="running-compiler">
      <title>Running the compiler</title>
      <body>
        <p>
          In order to run programs written in Nemerle you need
          to compile them to .NET bytecode first. This is done with the
          <tt>ncc</tt> (Nemerle Compiler Compiler) command. Assuming the 
          Nemerle is installed properly on your system, you need to do
          the following:
        </p>
        <ul>
          <li>
            write the program text with your favorite text editor and
            save it as a file with extension <file>.n</file>, for example
            <file>myfile.n</file>
          </li>
          <li>
            run the Nemerle compiler by typing <tt>ncc myfile.n</tt>
          </li>
          <li>
            the output goes to <file>out.exe</file>
          </li>
          <li>
            run it by typing <tt>out</tt> (Windows) or <tt>mono
            out.exe</tt> (Linux)
          </li>
        </ul>
      </body>
    </subsection>

    
    <subsection id="classes">
      <title>Classes and modules</title>
      <body>
        <p>
          You cannot define neither functions nor values at the top level
          in Nemerle. You need to pack them into <b>classes</b> or
          <b>modules</b>.  For C#, Java and C++ programmers: a module is
          a class with all members static, there can be no instance of
          module class.
        </p>
        <p>
          For now you should consider the module to be a form of packing
          related functions together.
        </p>
<code>
class Foo 
{ 
  // ... some comment ... 
}

module Bar
{
  /* ... some comment ... */
}
</code>
        <p>
          The above example also introduces two kinds of <b>comments</b>
          used in Nemerle. The comments starting with <tt>//</tt> are active
          until the end of line, while the comments starting with <tt>/*</tt> are
          active until <tt>*/</tt>. This is the same as in C (well, C99).
        </p>
      </body>
    </subsection>
    
    
    <subsection id="methods">
      <title>Methods</title>
      <body>
        <p>
          Classes can contain <b>methods</b> (functions) as well as
          <b>fields</b> (values). Both kind of members can be prefixed
          with access attributes likes <tt>private</tt>, <tt>internal</tt>
          or <tt>public</tt>.
        </p>
        <p>
          <tt>public</tt> defines a method or a field that can be accessed
          from outside the module.
        </p>
        <p>
          <tt>private</tt> defines a member that is local to module.
          This is the default.
        </p>
        <p>
          <tt>internal</tt> defines a member that is local to module a
          given library of executable.
        </p>
        <p>
          In the method declaration header you first write modifiers, then
          the name of the method, then parameters with a type specification and
          finally a type of values returned from this function.
        </p>
        <p>
          Typing constraints are in general written after a colon
          (<tt>:</tt>).
        </p>
<code>
class Foo
{
  public SomeMethod () : void
  {
    // ...
  }
  private some_other_method (x : int) : int
  {
    // ... 
  }
  private Frobnicate (x : int, y : string) : int
  {
    // ... 
  }
  internal foo_bar () : int
  {
    // ...
  }
}
</code>
      </body>
    </subsection>
    

    <subsection id="fields">
      <title>Fields</title>
      <body>
        <p>
          Fields define global values inside the module.
        </p>
        <p>
          Fields accept the same access attributes as methods. However,
          there is one additional very important attribute for fields --
          <tt>mutable</tt>.
        </p>
        <p>
          By default fields are read only, that is they can be assigned
          values only in the module initializer function (codenamed
          <tt>this</tt>; we will talk about it later). If you want to
          assign values to fields in other places you need to mark a field
          <tt>mutable</tt>.
        </p>
<code>
class Bar
{
  public mutable qux : int;
  private quxx : int;
  mutable bar : float;
}
</code>
      </body>
    </subsection>


    <subsection id="expr">
      <title>Expressions</title>
      <body>
        <p>
          There is no expression versus statement distinction in
          Nemerle. There are only expressions. In particular, there
          are no jump statements like <tt>break</tt>, <tt>goto</tt>
          or <tt>continue</tt>.
        </p>
        <p>
          There is also no <tt>return</tt> statement. The value returned
          from a function is the last value computed in a sequence expression
          defining function. You can think that there is implicit
          <tt>return</tt> at the beginning of each function. This is the
          same as in ML.
        </p>
        <p>
          Despite all that, the most basic example looks almost like in C#.
          The entry point for a program is a function called <tt>Main</tt>.
          It is also possible to take command line arguments and/or return
          integer return code from the <tt>Main</tt> method, consult .NET
          reference for details.
        </p>
        <p>
          Note that unlike in ML function call requires <tt>()</tt>.
        </p>
<code>
class Hello
{
  public static Main () : void
  {
    System.Console.WriteLine ("Hello cruel world!")
  }
}
</code>
      </body>  
    </subsection>


    <subsection id="simple-fib">
      <title>Simple function</title>
      <body>
        <p>
          However, the following example (computing <a
          ref="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci
          sequence</a>) looks somewhat different. You can see the usage of a
          <b>conditional expression</b>. Note how the value is returned
          from the function without any explicit <tt>return</tt> statement.
        </p>
        <p>
          Note that this example and the following ones are not complete. To be
          compiled they need to be packed into the module, equipped with the
          <tt>Main</tt> function and so on.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  if (n < 2)
    1
  else
    fib (n - 1) + fib (n - 2)
}]]>
</code>
      </body>
    </subsection>


    <subsection id="def-mutable">
      <title>Imperative loops and value definitions</title>
      <body>
        <p>
          It is possible to use regular <b>imperative loops</b> like
          <tt>while</tt> and <tt>for</tt>. Both work as in C. As for
          the <tt>for</tt> case -- the first expression is put before the loop,
          the second expression is the condition (the loop is executed as long
          as the condition holds), and the last expression is put at the
          end of the loop.
        </p>
        <p>
          However, the most important thing about this example is the variable
          definition used there. <b>Variables</b> (values that can be
          changed) are defined using <tt>mutable</tt> expression. You
          do not specify type, but you do specify initial value. The type of the
          defined variable is inferred based on the initial value (for example
          the type of <tt>1</tt> is obviously an <tt>int</tt>). The variable
          introduced with <tt>mutable</tt> is visible till the end of
          the current sequence. Lexical scoping rules apply -- definition
          of next value with the same name hides the previous one.
        </p>
        <p>
          <b>Sequence</b> is a list of expressions enclosed
          in braces (<tt>{}</tt>) and separated with semicolons
          (<tt>;</tt>). An optional semicolon is allowed at the end of
          the sequence.  Note that the function definition also introduces
          a sequence (as the function body is written in <tt>{}</tt>).
        </p>
        <p>
          <tt>mutable</tt> defines <b>variables</b> that can be updated
          using the assignment operator (<tt>=</tt>). In contrast <tt>def</tt>
          defines <b>values</b> that cannot be updated -- in our example
          we use <tt>tmp</tt> as such value.
        </p>
        <p>         
          Older versions of the Nemerle compiler required a semicolon 
          after the closing brace inside a sequence. This is no longer
          mandatory: note that <tt>for</tt> expression's closing brace
          is not followed by a semicolon. In some rare cases this can introduce
          compilation errors -- remember that you can always put a semicolon there!
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  mutable last1 = 1;
  mutable last2 = 1;
  
  for (mutable cur = 1; cur < n; ++cur) {
    def tmp = last1 + last2;
    last1 = last2;
    last2 = tmp;
  }

  last2
}]]>
</code>
        <p>
          In this example we see no gain from using <tt>def</tt> instead
          of <tt>int</tt> as you would do in C# (both are 3 characters
          long :-).  However, in most cases type names are far longer:
        </p>
<code>
FooBarQuxxFactory fact = new FooBarQuxxFactory (); // C#
def fact = FooBarQuxxFactory (); // Nemerle
</code>
      </body>
    </subsection>


    <subsection id="local-functions">
      <title>Local functions</title>
      <body>
        <p>
          Local functions are functions defined within other functions.
          For this reason they are also called <b>nested functions</b>.
        </p>
        <p>
          There are three reasons for defining local functions. The first one
          is not to pollute the class namespace. We have the <tt>private</tt>
          keyword for that, so this does not seem to be any good reason.
        </p>
        <p>
          The second one is that local functions can access variables
          defined in an outer function. This allows for somewhat different
          (better?) code structuring than in C. You can have several
          variables and local functions using them defined in a function.
        </p>
        <p>
          The most important reason for local function is however the
          fact that you can pass them to other functions so that they can
          be run from there, implementing for example iterators for
          data structures. This is explained in more detail
          <a ref="#functional-values">later</a>.
        </p>
        <p>
          Local functions are defined just like other values with
          the <tt>def</tt> keyword. A local function definition looks
          similar to the global one (despite the lack of access modifiers,
          leading <tt>def</tt> and the trailing semicolon).
        </p>
<code>
sum_cubes (v1 : int, v2 : int, v3 : int) : int
{
  def cube (x : int) : int {
    x * x * x
  } 
   
  cube (v1) + cube (v2) + cube (v3)
}
</code>
        <p>
          Using local functions is one of way of implementing loops in
          Nemerle.
        </p>
<code>
<![CDATA[module Sum {
  public Main () : void
  {
    def sum (x : int) : int {
      if (x <= 0) 
        0
      else
        x + sum (x - 1)
    }
    
    System.Console.WriteLine ("Sum of numbers from " +
                              "20 to 0 is: {0}", sum (20))
  }
}]]>
</code>
        <p>
          Notice how the local function is used to organize the loop. This
          is typical for Nemerle. It is therefore quite important
          for you to grok this concept. Some external links -- <a
          ref="http://en.wikipedia.org/wiki/Tail_recursion">tail
          recursion</a>, <a
          ref="http://en.wikipedia.org/wiki/Recursion">recursion</a>.
        </p>
        <p>
          Here goes another example of a loop constructed with a local
          function.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  def my_loop (last1 : int, last2 : int, cur : int) : int {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  }
  
  my_loop (1, 1, 1)
}]]>
</code>
        <p>
          If you are concerned about performance of such form of writing
          loops -- fear you not. When the function body ends with a call
          to another function -- no new stack frame is created. It is
          called a <b>tail call</b>. Thanks to it the example above is as
          efficient as the <tt>for</tt> loop we have seen before.
        </p>
      </body>
    </subsection>


    <subsection id="type-inf">
      <title>Type inference</title>
      <body>
        <p>
          You can specify types of parameters as well as return types
          for local functions. However in some (most?) cases the compiler can
          guess (infer) the types for you, so you can save your fingers by
          not typing them. This is always safe, that is the program should not
          in principle change the meaning if type annotations are added.
        </p>
        <p>
          It fails sometimes to guarantee this safeness property type inference. 
          It means that type annotations are required. This
          manifests itself mostly with an error message.
        </p>
        <p>
          In the following example we have omitted the return type, as well
          as types of the <tt>last2</tt> and <tt>cur</tt> parameters. However,
          we have given a type to the <tt>last1</tt> parameter.
        </p>
        <p>
          If we omit the type for the <tt>last1</tt> parameter, then the compiler
          would report an error in expression <tt>last1 + last2</tt>
          crying about ,,no match for operator +''. This is because
          the <tt>+</tt> operator is defined not only for integers but
          also for floats, chars and so on. It is also possible to add
          new overloads for this operator. Therefore the compiler looks
          for it in the class of left and right arguments. If none is
          found -- it bails out.  However, after you specify explicitly
          the type for <tt>last1</tt>, the overloading is resolved in
          favor of <tt>+</tt> having type <tt>int * int -> int</tt>
          (so <tt>last2</tt> also becomes an <tt>int</tt>).
        </p>
        <p>
          Another typical case when type annotation is required is
          using the dot (<tt>.</tt>) operator to access members of an
          unknown type, as well as overloading resolution errors. These
          manifest themselves with error messages like ,,no constrain of
          _N_fv36_36* provides member `Foo''' or ,,overloading resolution
          ambiguity''.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  def my_loop (last1 : int, last2, cur) {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  }
  
  my_loop (1, 1, 1)
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="ext-fun">
      <title>External functions</title>
      <body>
        <p>
          One of the best things about Nemerle is that you can use rich
          class libraries that come with the Framework as well as the
          third party libraries. Links to the documentation about .NET class
          libraries can be found <a ref="#class-docs">here</a>.
        </p>
        <p>
          New objects are constructed by simply naming the type and
          supplying arguments to its constructor. Note that unlike
          in C# or Java you don't use the <tt>new</tt> keyword to
          construct new objects. Methods of objects can be
          invoked later, using the dot operator (<tt>some_object.SomeMethod
          (some_argument)</tt>).  Static methods are invoked using the
          <tt>NameSpace.TypeName.MethodName ()</tt> syntax.  We will
          talk more about this object oriented stuff later.
        </p>
        <p>
          We use two methods of output formatting here. The first is the
          <tt>System.Console.WriteLine</tt> (a function from the .NET
          Framework). When given more then one argument it replaces
          occurrences of <tt>{N}</tt> with (N+2)-th parameter (counting
          from one).
        </p>
        <p>
          The second is the <tt>printf</tt> macro that works much like the
          <tt>printf(3)</tt> C function or <tt>Printf.printf</tt>
          in OCaml.
        </p>
        <p>
          For more information about <i>The answer to the Ultimate
          Question of Life, the Universe and Everything</i> please visit <a
          ref="http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything">this
          site</a>. Please note that this program run on a computer not as powerful as
          Deep Thought will be right only in 1% of cases.
        </p>
<code>
<![CDATA[the_answer_to_the_universe () : int
{
  // Construct new random number generator.
  def r = System.Random ();
  // Return new random number from [0, 99] range.
  r.Next (100)
}

print_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  System.Console.WriteLine ("The answer to the Ultimate " +
                            "Question of Life, the " +
                            "Universe and Everything " +
                            "is {0}", the_answer)
}

printf_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  printf ("The answer is %d\n", the_answer);
}]]>
</code>
      </body>
    </subsection>


    <subsection id="array">
      <title>Arrays</title>
      <body>
        <p>
          The type of array of <meta>T</meta> is denoted <tt>array
          &lt;<meta>T</meta>></tt>.  This is a one-dimensional, zero-based
          array. There are two special expressions for constructing new
          arrays: <tt>array ["foo", "bar", "baz"]</tt> will construct a
          3-element array of strings, while <tt>array (100)</tt> creates a
          100-element array of something. The ,,something'' is inferred
          later, based on an array usage.  The array is initialized with
          <tt>0</tt>, <tt>0.0</tt> or <tt>null</tt> for reference types.
        </p>
        <p>
          One interesting thing about this example is the usage of the type
          enforcement operator -- colon (<tt>:</tt>). We use it to enforce the
          <tt>left</tt> type to be int. We could have as well written
          <tt>def loop (left : int, right) {</tt>. There are simply two
          ways to achieve this.
        </p>
        <p>
          Another interesting thing is the <tt>when</tt> expression -- it
          is <tt>if</tt> without <tt>else</tt>. For symmetry purposes we also have
          <tt>if</tt> without <tt>then</tt> called <tt>unless</tt>. As
          you might have already noted <tt>unless</tt> is equivalent to
          <tt>when</tt> with condition negated.
        </p>
        <p>
          In Nemerle the <tt>if</tt> expression always needs to have the
          <tt>else</tt> clause. It's done this way to avoid stupid bugs
          with a dangling else:
        </p>
<code>
// C#, misleading indentation hides real code meaning
if (foo)
   if (bar)
     m1 ();
else
   m2 ();
</code>
        <p>
          If you do not want the <tt>else</tt> clause, use
          <tt>when</tt> expression, as seen in the example. There is
          also the <tt>unless</tt> expression, equivalent to <tt>when</tt>
          with condition negated.
        </p>
        <p>
          The assignment operator (<tt>&lt;-</tt>) can be also used to
          assign elements in arrays.
        </p>
        <p>
          Note the <tt>ar.Length</tt> expression -- it gets the length of
          array <tt>ar</tt>. It looks like a field reference in an array
          object but under the hood it is a method call. This mechanism
          is called ,,property''.
        </p>
        <p>
          Our arrays are subtypes of <tt>System.Array</tt>, so all methods
          available for <tt>System.Array</tt> are also available for
          <tt>array &lt;<meta>T</meta>></tt>.
        </p>
<code>
<![CDATA[class ArraysTest {
  static reverse_array (ar : array <int>) : void
  {
    def loop (left, right) {
      when ((left : int) < right) {
        def tmp = ar[left];
        ar[left] = ar[right];
        ar[right] = tmp;
        loop (left + 1, right - 1)
      }
    }
    loop (0, ar.Length - 1)
  }

  static print_array (ar : array <int>) : void
  {
    for (mutable i = 0; i < ar.Length; ++i)
      printf ("%d\n", ar[i])
  }

  static Main () : void
  {
    def ar = array [1, 42, 3];
    print_array (ar);
    printf ("\n");
    reverse_array (ar);
    print_array (ar);
  }
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="misc_1">
      <title>Miscellaneous information</title>
      <body>
        <p>
          The equality predicate is written <tt>==</tt> and the
          inequality is <tt>!=</tt> as in C.
        </p>
        <p>
          The boolean operators (<tt>&amp;&amp;</tt>, <tt>||</tt> and
          <tt>!</tt>) are all available and work the same as in C.
        </p>
      </body>
    </subsection>
    

    <subsection id="exercises_1">
      <title>Exercises -- List 1</title>
      <body>
        <p>
          <b>1.1.</b> Write a program that prints out to the console:
        </p>
<code>
1 bottle of beer.
2 bottles of beer.
3 bottles of beer.
...
99 bottles of beer.
</code>
        <p>
          With an appropriate amount of beer instead of <tt>...</tt>. The program
          source code should not exceed 30 lines.
        </p>
        <p>
          <b>1.2.</b> Implement <a
          ref="http://www.catb.org/~esr/jargon/html/B/bogo-sort.html">bogo
          sort</a> algorithm for an array of integers. (WARNING: you
          should not implement ,,destroy the universe'' step). Test it
          by sorting the following array: <tt>[4242, 42, -42, 31415]</tt>.
        </p>
        <p>
          <b>1.3.</b> As 1.2, but don't use the imperative loops --
          rewrite them with recursion.
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="namespaces">
    <title>Namespaces</title>
    <body>
      <p>
      </p>
    </body>

    <subsection id="namespaces-intro">
      <title>Namespaces</title>
      <body>
        <p>
          Classes and modules can be put in namespaces. Namespaces at
          the conceptual level prepend a string to names of objects
          defined within them.
        </p>
<code>
namespace Deep.Thought
{
  class Answer
  {
    static Get () : int
    {
      42
    }
  }
}

namespace Loonquawl
{
  class Brain
  {
    static Main () : void
    {
      System.Console.WriteLine ("The answer {0}", 
                                Deep.Thought.Answer.Get ())
    }
  }
}
</code>
        <p>
          As you can see, the name of the <tt>Get</tt> function
          is first prepended with the name of the module (<tt>Answer</tt>)
          and then with the current namespace (<tt>Deep.Thought</tt>),
          forming its full name: <tt>Deep.Thought.Answer.Get</tt>.
        </p>
        <p>
          Another example is the <tt>WriteLine</tt> method of the
          <tt>Console</tt> module, defined in the <tt>System</tt>
          namespace.
        </p>
      </body>
    </subsection>


    <subsection id="using">
      <title>Making long names short</title>
      <body>
        <p>
          In order not to write <tt>System.Console.WriteLine</tt> or
          <tt>Deep.Thought.Answer.Get</tt> all the time you can import
          all declarations from the specified namespace into the current
          scope with the <tt>using</tt> directive.
        </p>
        <p>
          Thus the <tt>Loonquawl.Brain</tt> module from the example
          above could be:
        </p>
<code>
<![CDATA[namespace Loonquawl
{
  using System.Console;
  using Deep.Thought.Answer;
  
  class Brain
  {
    static Main () : void
    {
      WriteLine ("The answer is {0}", Get ())
    }
  }
}
]]>
</code>
        <p>
          While we see not much gain from the <tt>using</tt>
          directive in this example, it can be handy when you use the
          <tt>WriteLine</tt> method 100 times, and/or your classes are
          in <tt>Some.Very.Long.Namespaces</tt>.
        </p>
        <p>
          Note that unlike in C# all methods of a class can be imported
          into the current namespace. Thus, <tt>using</tt> is not limited
          to namespaces, but it also works for classes.
        </p>
        <p>
          It is also possible to create (shorter) aliases for
          namespaces and modules. It is sometimes useful in case when
          two namespaces share several types, so they cannot be imported
          with <tt>using</tt> simultaneously.
        </p>
<code>
<![CDATA[namespace Loonquawl
{
  namespace SC = System.Console;
  namespace DTA = Deep.Thought.Answer;
  
  class Brain
  {
    static Main () : void
    {
      SC.WriteLine ("The answer is {0}", DTA.Get ())
    }
  }
}
]]>
</code>
      </body>
    </subsection>
  </section>


  
  <section id="functionals">
    <title>Functionals</title>
    <body>
      <p>
      </p>
    </body>

    <subsection id="functional-values">
      <title>Functional values</title>
      <body>
        <p>
          In Nemerle you can pass functions as arguments of other
          functions, as well as return them as results. This way functions
          are not worse then any other data types (think about Equal
          Rights for Functions movement :-)
        </p>
        <p>
          In C# there are delegates. This concept is quite similar to
          functional values.  However, functional values are far more
          efficient and their types need not be declared before use.
        </p>
        <p>
          As a first example consider:
        </p>
<code>
// C#
delegate int IntFun (int);

class M {
  static int f(int x)
  {
    return x * 2;
  }

  static int run_delegate_twice(IntFun f, int v)
  {
    return f(f(v));
  }
  
  static void Main ()
  {
    System.Console.WriteLine("{0}", 
                   run_delegate_twice(new IntFun (f), 3));
  }
}
</code>
<code>
// Nemerle
class M {
  static f (x : int) : int
  {
    x * 2
  }

  static run_funval_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }
  
  static Main () : void
  {
    System.Console.WriteLine ("{0}", run_funval_twice (f, 3))
  }
}
</code>
        <p>
          In this example delegates seem just like function pointers
          in C.  Functional values do not appear any better, except
          maybe for the shorter syntax.  However, the real power of delegates comes
          from the fact that methods can be used as delegates (thus
          effectively embedding the <tt>this</tt> pointer in the delegate).
          This is much like "functional objects" design pattern in C++.
          We will not show it here, please refer to the C# manual for details.
        </p>
        <p>
          Still using methods as delegates does not demonstrate their full power.
          The funny part begins when we use nested functions as functional
          values.
        </p>
<code>
class M {
  static run_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }

  static run_adder (x : int) : void
  {
    def f (y : int) : int { x + y };
    System.Console.WriteLine ("{0}", run_twice (f, 1))
  }

  static Main () : void
  {
    run_adder (1);
    run_adder (2);
  }
}
</code>
        <p>
          This example prints 3 and 5. Note how <tt>x</tt> is captured in the local
          function <tt>f</tt>.
        </p>
        <p>
          Types of functions taking more then one argument are represented
          as tuples. For example, the following function:
        </p>
<code>
some_function (arg_1 : int, arg_2 : string, arg_3 : Foo) : float
{
   // ...
}
</code>
        <p>
          has the type <tt>int * string * Foo -> float</tt>. Functions that take no
          arguments pretend to take one argument of the type <tt>void</tt>. Thus the
          function:
        </p>
<code>
other_function () : string { ... }
</code>
        <p>
          possesses the type <tt>void -> string</tt>.
        </p>
        <!-- TODO: mention iterators -->
      </body>
    </subsection>
    
      
    <subsection id="lambda-expr">
      <title>Lambda expressions</title>
      <body>
        <p>
          Lambda expressions are just a syntactic sugar to defined unnamed
          local functions. Unnamed local functions are useful when you
          need to pass some function to the iterator, so you use it just once.
        </p>
        <p>
          Lambda expressions are defined using the <tt>fun</tt> keyword,
          followed by formal parameters, an optional return type and the
          function body.
        </p>
<code>
def x = List.Map ([1, 2, 3], fun (x) { 2 * x });
def y = List.FoldLeft (x, 0, fun (val : int, acc) { acc + val });
assert (y == 12);
</code>
        <p>
          In general:
        </p>
<code>
fun (<meta>parms</meta>) { <meta>exprs</meta> }
</code>
        <p>
          is equivalent to:
        </p>
<code>
{ 
  def tmp (<meta>parms</meta>) { <meta>exprs</meta> };
  tmp
}
</code>
        <p>
          This feature is similar to anonymous delegates in C# 2.0.
        </p>
      </body>
    </subsection>


    <subsection id="exercises_2a">
      <title>Exercises</title>
      <body>
        <p>
          <b>2.1</b>. Write a function
        </p>
<code>
string_pow : int * (string -> string) * string -> string
</code>.
        <p>
          The call <tt>string_pow (3, f, "foo")</tt> should result
          in calling <tt>f</tt> three times, i.e. returning result
          of <tt>f (f (f ("foo")))</tt>. When you are done, write a second
          version of <tt>string_pow</tt> using recursion (if you used
          imperative loop) or imperative loop (otherwise). 
        </p>
        <p>
          Test it by passing function that replaces "42"
          with "42ans". You can try passing the functional
          argument to <tt>string_pow</tt> as a lambda expression. <a
          ref="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfSystemStringClassReplaceTopic.asp">This
          method</a> might be useful.
        </p>
      </body>
    </subsection>
  </section>

  <section id="various-data-structures">
    <title>Various data structures</title>
    <body>
      <p>
      </p>
    </body>
    
    <subsection id="tuple">
      <title>Tuples</title>
      <body>
        <p>
          Tuples are forms of nameless data structures. They are usable
          when you need to return two or three values from a function.
        </p>
        <p>
          A tuple is constructed with:
        </p>
<code>
(<meta>expr1</meta>, <meta>expr2</meta>, ..., <meta>exprN</meta>)
</code>
        <p>
          and deconstructed with:
        </p>

<code>
def (<meta>id1</meta>, <meta>id2</meta>, ..., <meta>idN</meta>) = <meta>expr</meta>;
</code>
        <p>
          This <tt>def</tt> thing defines values called <meta>id1</meta>
          through <meta>idN</meta> and puts respective tuple members
          into them.
        </p>
        <p>
          Tuple types are written using the <tt>*</tt> operator. For
          example, pair of integers <tt>(42, 314)</tt> has the type <tt>int
          * int</tt>, while <tt>("Zephod", 42.0, 42)</tt> has the type
          <tt>string * float * int</tt>.
        </p>
        <p>
          An example follows:
        </p>
<code>
/** Parses time in HH:MM format. */
parse_time (time : string) : int * int
{
  def arr = time.Split (array [':']);
  (System.Int32.Parse (arr[0]), System.Int32.Parse (arr[1]))
}

seconds_since_midnight (time : string) : int
{
  def (hours, minutes) = parse_time (time);
  (hours * 60 + minutes) * 60
}

foo () : void
{
  def secs = seconds_since_midnight ("17:42");
  ...
}
</code>
        <p>
          Another example could be:
        </p>
<code>
// split (3.7) => (3, 0.7)
split (x : double) : int * double
{
  def floor = System.Math.Floor (x);
  (System.Convert.ToInt32 (floor), x - floor)
}
</code>
      </body>
    </subsection>
    
        
    <subsection id="list-literals">
      <title>List literals</title>
      <body>
        <p>
          List literals are special forms of writing lists. Lists are data
          structures that are used very often in Nemerle - often enough to
          get their own syntax. Lists in Nemerle are somewhat different then
          the <tt>ArrayList</tt> type in .NET.
        </p>
        <ul>
          <li>
            the lists in Nemerle are immutable (cannot be changed once
            created)
          </li>
          <li>
            items can be appended at the beginning only (constructing
            new lists)
          </li>
        </ul>
        <p>
          Of course you are free to use the .NET <tt>ArrayList</tt>.
        </p>
        <p>
          Anyway, to construct a list consisting of a given head (first element)
          and a tail (rest of elements, also a list), write:
        </p>
<code>
<meta>head</meta> :: <meta>tail</meta>
</code>
        <p>
          To construct a list with specified elements write:
        </p>
<code>
[ <meta>element_1</meta>, <meta>element_2</meta>, ..., <meta>element_n</meta> ]
</code>
        <p>
          This way you can also construct an empty list (<tt>[]</tt>).
        </p>
      </body>
    </subsection>
  </section>
    


  <section id="variants-and-matching">
    <title>Variants and matching</title>
    <body>
      <p>
        Variants (called data types or sum types in
        <a ref="http://www.smlnj.org/">SML</a> and <a
        ref="http://www.ocaml.org">OCaml</a>) are forms of expressing
        data of several different kinds. 
      </p>
      <p>
        Matching is a way of destructuring complex data structures,
        especially variants.
      </p>
    </body>
    
    <subsection id="variants">
      <title>Variants</title>
      <body>
        <p>
          The simplest example of variants are enum types known from C.
        </p>
<code>
// C
enum Color {
  Red, 
  Yellow, 
  Green 
}
</code>
<code>
// Nemerle
variant Color {
  | Red 
  | Yellow 
  | Green 
}
</code>
        <p>
          Note that you can define C#-like <tt>enum</tt> types in Nemerle anyway.
          However, the variant options might be more useful because they can carry 
          some extra data with them:
        </p>
<code>
variant Color {
  | Red
  | Yellow
  | Green
  | Different { 
      red : float; 
      green : float; 
      blue : float; 
    }
}
</code>
        <p>
          So if color is neither red, yellow nor green, it can be
          represented with RGB.
        </p>
        <p>
          You can think about variants as of a union with a selector in C. In
          OO world sometimes modeling variants with sub classing can be seen sometimes:
        </p>
<code>
// C#
class Color { }
class Red : Color { }
class Green : Color { }
class Yellow : Color { }
class Different : Color {
  float red;
  float green;
  float blue;
}
</code>
        <p>
          Of course you need to write a constructor, mark fields
          <tt>public</tt> and so on. When you're done -- using this kind
          of stuff is quite hard -- you need to use lots of runtime type
          checks.
        </p>
        <p>
          On the other hand, Nemerle provides an easy and convenient method of
          dealing with variants -- pattern matching.
        </p>
      </body>
    </subsection>


    <subsection id="matching">
      <title>Matching</title>
      <body>
        <p>
          <b>Pattern matching</b> is accomplished with the <tt>match</tt>
          expression. Its semantics is to check each pattern in turn,
          from top to bottom, and execute expression after the first pattern
          that matched. If no pattern matched, the exception is raised.
          This is like the <tt>switch</tt> statement known from C,
          but using large dose of steroids.
        </p>
<code>
string_of_color (color : Color) : string
{
  match (color) {
    | Red => "red"
    | Yellow => "yellow"
    | Green => "green"
    | Different (r, g, b) => 
      System.String.Format ("rgb({0},{1},{2})", r, g, b)
  }
}
</code>
        <p>
          The main idea behind patterns is that they match values that
          look like them. For example, the Nemerle compiler creates a default
          constructor for the <tt>Different</tt> variant option with
          the following body:
        </p>
<code>
<![CDATA[public this (red : float, green : float, blue : float)
{
  this.red = red;
  this.green = green;
  this.blue = blue;
}]]>
</code>
        <p>
          Therefore, the constructor call <tt>Different (r, g, b)</tt> creates
          a new variant option instance with specified arguments. The
          pattern looks the same -- it binds actual values of
          <tt>red</tt>, <tt>green</tt> and <tt>blue</tt> fields to
          <tt>r</tt>, <tt>g</tt> and <tt>b</tt> respectively. You can
          also spell the field names explicitly:
        </p>
<code>
  | Different { red = r; green = g; blue = b; } => 
    System.String.Format ("rgb({0},{1},{2})", r, g, b)
</code>
      </body>
    </subsection>


    <subsection id="other-patterns">
      <title>Other patterns</title>
      <body>
        <p>
          We have already seen a so called ,,<b>constructor pattern</b>''
          in action.  It is used to match over variants. The constructor
          pattern consists of variant option name (starting with an
          uppercase letter) followed by optional tuple or record pattern.
        </p>
<code>
// examples of constructor patterns
// plain one, without sub-pattern:
Red 
// followed by tuple pattern:
Different (r, g, b)
// followed by record pattern:
Different { red = r; green = g; blue = b; }
</code>
        <p>
          The <b>variable pattern</b> matches any value, and binds
          it to a specified variable. The variable pattern is an identifier
          starting with a lowercase letter. They are used mostly inside
          other patterns, but here we give a (rather pointless) example
          of using them as the top-level pattern:
        </p>
<code>
// it prints 42
match (42) {
  | x => // here x is bound to 42
    printf ("%d\n", x)
}
</code>
        <p>
          The <b>throw-away pattern</b>, written <tt>_</tt>, matches
          any value and has no further effects. It is a way of specifying
          the <tt>default:</tt> case in matching.
        </p>
<code>
match (color) {
  | Red => "red"
  | _ => "other"
}
</code>
        <p>
          The <b>tuple pattern</b> consists of one or more patterns
          separated by commas and surrounded by parens. We have
          already used them in the <a ref="#tuple">section about tuples</a>
          above. There they were used in <tt>def</tt> expressions.
        </p>
<code>
// matches any pair, binding its elements
// to specified variables
(first_element, second_element)

// matches a pair whose first element is Foo
(Foo, _) 
</code>
        <p>
          The <b>record pattern</b> consists of zero or more named
          patterns separated by semicolons enclosed in braces. It matches
          a class, whose field values are matched by sub-patterns.
        </p>
<code>
class Foo {
  public number : int;
  public name : string;
}

StringOfFoo (f : Foo) : string
{
  if (f.name == "")
    f.number.ToString ()
  else
    f.name
}

// do the same as above
StringOfFooMatch (f : Foo) : string
{
  match (f) {
    | { name = ""; number = k } =>
      k.ToString ()
    | { name = s } => 
      s
  }
}
</code>
        <p>
          It might be doubtful if <tt>string_of_foo_match</tt> is any
          better then <tt>string_of_foo</tt>. Record patterns are mostly
          useful when used inside a complex pattern, or when they contain
          complex patterns.
        </p>
        <p>
          The <b>literal pattern</b> is an integer, character or string
          constant. It matches the exact specified value.
        </p>
<code>
StringOfInt (n : int) : string
{
  match (n) {
    | 0 => "null"
    | 1 => "one"
    | 2 => "two"
    | 3 => "three"
    | _ => "more"
  }
}

IntOfString (n : string) : int
{
  | "null" => 0
  | "one" => 1
  | "two" => 2
  | "three" => 3
  | _ => 42
}
</code>
        <p>
          Note lack of <tt>match</tt> in the second example. When the function
          body starts with <tt>|</tt> -- the <tt>match</tt> expression
          is automagically inserted.
        </p>
        <p>
          The <b>as pattern</b> tries to match a value with a pattern enclosed
          within it, and in case of success binds the value that matched to a
          specified variable. We will show it later.
        </p>
      </body>
    </subsection>
    
        
    <subsection id="variant-trees">
      <title>Using variants as trees</title>
      <body>
        <p>
          The example above, while simple, is not the best usage of
          variants. Variants are best at handling tree-like data
          structures.  A common example of tree data structures are XML
          documents.  However, we will deal with plain binary trees first.
        </p>
        <p>
          The following example defines the type of trees of integers
          (representing sets).
        </p>
<code>
<![CDATA[variant Tree {
  | Node {
      left  : Tree;
      elem  : int;
      right : Tree;
    }
  | Null
}

// return tree t with element e inserted
Insert (t : Tree, e : int) : Tree
{
  match (t) {
    | Node (l, cur, r) =>
      if (e < cur)
        Node (insert (l, e), cur, r)
      else if (e > cur)
        Node (l, cur, insert (r, e))
      else
        // node already in the tree,
        // return the same tree
        t
    | Null =>
      Node (Null (), e, Null ())
  }
}]]>
</code>
<code>
<![CDATA[// check if specified integer is in the tree
Contains (t : Tree, e : int) : bool
{
  match (t) {
    | Node (l, cur, r) when e < cur => 
      Contains (l, e)
    | Node (l, cur, r) when e > cur => 
      Contains (r, e)
    | Node => true
    | Null => false
  }
}]]>
</code>
      </body>
    </subsection>
    
        
    <subsection id="xml-trees">
      <title>XML trees</title>
      <body>
        <p>
          As you can see binary trees are not very interesting, so we will go
          to XML. If XML is interesting remains a doubtful question, but
          at least is somewhat more practical.
        </p>
<code><![CDATA[
variant Node {
  | Text { 
      value : string; 
    }
  | Element {
      name : string; 
      children : list <Node>;
    }
}]]>
</code>
        <p>
          This variant defines a simplistic data structure to hold XML trees.
          An XML node is either a text node with a specified text inside,
          or an element node, with a name and zero or more children.
          A sequence of children is represented as a Nemerle list data structure
          (Nemerle has even a <a ref="#list-literals">special syntax</a> for lists).
          The type is written here <tt>list &lt;Node></tt> -- a list of nodes.
          We will learn more about polymorphic variants later.
        </p>
        <p>
          For example the following tree:
        </p>
<code><![CDATA[<tree>
  <branch>
    <leaf/>
  </branch>
  <branch>
    Foo
  </branch>
</tree>]]>
</code>
       <p>
         would be represented by:
       </p>
<code><![CDATA[Element ("tree", 
  [Element ("branch", [Element ("leaf", [])]),
   Element ("branch", [Text ("Foo")])])]]>
</code>

       <p>
         Of course XML by itself is just a data format. Using data in the
         above form wouldn't be too easy. So we want some different internal
         representation of data, and use XML only to save it or send it over
         the network.
       </p>
<code><![CDATA[class Refrigerator
{
  minimal_temperature : float;
  content : list <RefrigeratorContent>;
}

variant RefrigeratorContent
{
  | Beer { name : string; volume : float; }
  | Chips { weight : int; }
  | Ketchup
}]]>
</code>
       <p>
         Now we'll write simple XML parsing function.
       </p>
<code><![CDATA[ParseRefrigerator (n : Node) : Refrigerator
{
  | Element ("refrigerator", 
      Element ("minimal-temperature", [Text (min_temp)]) 
            :: content) =>
        Refrigerator (System.Float.Parse (min_temp), 
                      ParseRefrigeratorContent (content))
  | _ =>
    throw System.ArgumentException ()
}

ParseRefrigeratorContent (nodes : list <Node>) 
  : list <RefrigeratorContent>
{
  | [] => []
  
  | node :: rest =>
    def food =
      match (node) {
        | Element ("ketchup", []) =>
          Ketchup ()
          
        | Element ("beer", 
            [Element ("name", [Text (name)]),
             Element ("volume", [Text (volume)])]) =>
          Beer (name, System.Float.Parse (volume))
          
        | Element ("chips",
            [Element ("weight", [Text (weight)])]) =>
          Chips (System.Int32.Parse (weight))
          
        | _ =>
          throw System.ArgumentException ()
      };
    food :: ParseRefrigeratorContent (rest)
}]]>
</code>
        <p>
          The reader will easily note that a) this code looks a bit
          like a junk, b) it can be generated automatically and c) in C#
          it would be even worse. Later we will learn how to
          write macros to generate this kind of code automatically. 
        </p>
        <p>
          But let's leave the ideology behind. 
          There are probably few interesting things about this example. The first is the usage of
          list patterns and constructors. We can check if a list is empty, and if not, deconstruct
          it with the following code:
        </p>
<code>
match (l) {
  | [] => 
    // the list is empty
    // ...
  | head :: rest =>
    // the list isn't empty, the first element 
    // of the list is bound to the 'head' variable
    // and the rest of the list to 'rest'
    // ...
}
</code>
        <p>
          We can also construct new lists with <tt>::</tt> operator --
          it prepends an element to an existing list. If we know all list
          elements in advance we can use the <tt>[ ... ]</tt> thing in
          both expressions and patterns.
        </p>
        <p>
          The second interesting thing is that we throw an exception in
          case of problems. We will talk about it later, for now assume, it just
          terminates the program with an error message.
        </p>
      </body>
    </subsection>
    
    <subsection id="exercises_2b">
      <title>Exercises</title>
      <body>
        <p>
          <b>2.2</b> (2 points). Write a function that reads XML 
          from specified files and puts it into the <tt>Node</tt> variant
          defined above. Then write a function to dump your data in a
          lispy format, something like:
        </p>
<code><![CDATA[(tree
(branch
(leaf)
)
(branch
($text "Foo")
)
)]]>
</code>
        <p>
          For an extra point implement indentation of output.
        </p>
<code><![CDATA[(tree
  (branch
    (leaf))
  (branch
    ($text "Foo")))]]>
</code>
        <p>
          Then copy the Parser functions from above, fix any errors you
          find in them and try to parse the following file:
        </p>
<code><![CDATA[<?xml version='1.0' encoding='utf-8' ?>
<refrigerator>
  <minimal-temperature>-3.0</minimal-temperature>
  <beer>
    <name>Hyneken</name>
    <volume>0.6</volume>
  </beer>
  <beer>
    <name>Bydweisser</name>
    <volume>0.5</volume>
  </beer>
  <beer>
    <name>Plsner</name>
    <volume>0.5</volume>
  </beer>
  <chips>
    <weight>500</weight>
  </chips>
  <ketchup/>
</refrigerator>]]>
</code>
        <p>
          Warning: you do not need to write the
          XML parser. You should not do it, actually.  Use the <a
          ref="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemxml.asp">System.Xml</a>
          namespace from the .NET Framework. In order to link with the System.Xml library
          you need to compile with the <tt>-r System.Xml</tt> option. For example:
        </p>
<code>
ncc -r System.Xml myprogram.n
</code>
        <p>
          should do.
        </p>
      </body>
    </subsection>
  </section>


  <section id="lecture_3">
    <title>The rest</title>

    <subsection id="named-parms">
      <title>Named parameters</title>
      <body>
        <p>
          This feature (in this form) comes from <a
          ref="http://www.python.org/">python</a>.  When you call a
          function you can name some of its parameters (which allows
          putting them in a different order then in the definition).
        </p>
<code>
<![CDATA[frobnicate (foo : int, do_qux : bool, 
                       do_baz : bool, 
                       do_bar : bool) : int
{
  // this is completely meaningless
  if (do_qux && !do_baz) foo * 2
  else if (do_bar) foo * 7
  else if (do_baz) foo * 13
  else 42
}

Main () : void
{
  // Parameters' names can be omitted.
  def res1 = frobnicate (7, true, false, true);
  
  // This is the indented usage -- the first 
  // (main) parameter comes without a name
  // and the following flags with names
  def res2 = frobnicate (7, do_qux = true,
                            do_baz = false, 
                            do_bar = true);
                            
  // You can however name every parameter:
  def res3 = frobnicate (foo = 7, do_qux = true, 
                         do_baz = false, do_bar = true);
                         
  // And permute them:
  def res3 = frobnicate (do_qux = true, do_bar = true, 
                         do_baz = false, foo = 7);
                         
  // You can also omit names for any number of leading 
  // parameters and permute the trailing ones.
  def res2 = frobnicate (7, true,
                            do_bar = true,
                            do_baz = false);
  ()
}]]>
</code>
        <p>
          The rules behind named parameters are simple:
        </p>
        <ul>
          <li>
            named parameters must come after all unnamed (positional)
            parameters
          </li>
          <li>
            positional parameters are assigned first
          </li>
          <li>
            the remaining parameters are assigned based on their names
          </li>
        </ul>
        <p>
          Named parameters can be used only when names of parameters are
          known (which basically mean they do not work in conjunction
          with functional values).
        </p>
      </body>
    </subsection>
    
    
    <subsection id="void-value">
      <title>The void literal</title>
      <body>
        <p>
          The void literal is written: <tt>()</tt>.
        </p>
        <p>
          The void literal is quite a tricky thing, since it represents
          the only value of type <tt>void</tt>, which, judging from the
          name, should be ergh... void. In fact, in some other functional
          languages this type is called <tt>unit</tt>, but in Nemerle
          the name comes from <tt>System.Void</tt> and the
          <tt>void</tt> type is an alias for it.
        </p>
        <p>
          In C# the <tt>void</tt> type is used as a return type of
          functions. It does not make much sense to use it elsewhere.
          It could be needed, however, if, for example, you want to use the
          <tt>Hashtable &lt;a, b&gt;</tt> type as a set representation of
          strings. You can use <tt>Hashtable &lt;string, void&gt;</tt>
          then. And this is the place to use the void value -- when you
          call a set method, you need to pass something as a value to set --
          and you pass the void value.
        </p>
        <p>
          You can also use the void value to return it from a function -- as you
          remember, the return value of function is the last expression
          in its body. However, in most cases the last expression will
          already have the right <tt>void</tt> type.
        </p>
      </body>
    </subsection>

    <subsection id="macros">
      <title>Macros</title>
      <body>
        <p>
          Nemerle has very powerful code-generating macros. They are more
          akin to Lisp macros than macros found in C preprocessor. We are not
          going to explain here how to write macros (if you are curious,
          please see <link>macros.html</link>), but will describe a few
          often used macros.
        </p>
        <p>
          First of all, <tt>if</tt>, <tt>while</tt>, <tt>for</tt>,
          <tt>foreach</tt>, <tt>when</tt>, <tt>using</tt>, <tt>lock</tt>,
          etc. are all macros.
        </p>
        <p>
          Other examples of macros:
        </p>
        <ul>
          <li>
            <tt>printf</tt>, <tt>sprintf</tt> -- uses a similar syntax to
            the same function in C, but is checked at the compile time
          </li>
          <li>
            <tt>scanf</tt> -- likewise
          </li>
          <li>
            <tt>print</tt> -- it does the $-expansion known from shell
            or perl, we are working on it
          </li>
          <li>
            <tt>assert</tt> -- much like the C macro
          </li>
        </ul>
      </body>
    </subsection>
    
  </section>
  

  <section id="objects">
    <title>Object oriented programming</title>
    <body>
      <p>
        Once again a <a
        ref="http://en.wikipedia.org/wiki/Object-oriented_programming">definition</a>
        from Wikipedia. 
      </p>
      <p>
        OOP is all about <a
        ref="http://en.wikipedia.org/wiki/Object_(computer_science)">objects</a>.
        Objects consist of some data and methods to operate on this data.
        In functional programming we have functions (algorithm) and
        data. The things are separate. One can think about objects as
        of records (structures) with attached functions.
      </p>
      <p>
        Nemerle allows programmers to program in this style. Moreover,
        the class library is very deeply object oriented. Therefore OOP
        is unavoidable in Nemerle.
      </p>
    </body>

    
    <subsection id="refrigerator-oop">
      <title>Back in the Refrigerator</title>
      <body>
        <p>
          While <a ref="#xml-trees">talking about XML</a>, we have shown
          an example of a refrigerator. It was a degenerated object --
          a record. Record is a bunch of data, or an object without methods.
          Now we will try to extend it a bit.
        </p>
<code><![CDATA[class Refrigerator
{
  public mutable minimal_temperature : float;
  public mutable content : list <RefrigeratorContent>;

  public AddContent (elem : RefrigeratorContent) : void
  {
    content = elem :: content
  }
}

variant RefrigeratorContent
{
  | Beer { name : string; volume : float; }
  | Chips { weight : int; }
  | Ketchup
}]]>
</code>
        <p>
          Now, in addition to fields with content and temperature,
          the refrigerator has a method for adding new content.
        </p>
        <p>
          The definition of method looks much like the definition of a function
          within a module.
        </p>
        <p>
          It is quite important to understand the difference between
          classes and objects. Classes is type definition, while object
          (class instance) is a value. Class define a template to create
          new objects.
        </p>
        <p>
          Non static methods defined in class <tt>C</tt> have access to a
          special value called <tt>this</tt>. It has type <tt>C</tt> and
          is immutable. It refers to the current object. You can use the
          dot (<tt>.</tt>) operator to access fields of current object.
          You can see usage of <tt>this</tt> in <tt>AddContent</tt> method.
        </p>
        <p>
          The <tt>this</tt> value is quite often used in object oriented
          programming. Therefore it can be omitted for brevity. For example:
        </p>
<code><![CDATA[public AddContent (elem : RefrigeratorContent) : void
{
  content <- elem :: content
}]]>
</code>
        <p>
          However, if the method had a formal parameter called
          <tt>content</tt>, or a local value with such a name, one would
          need to use <tt>this.content</tt> to access the field.
        </p>
        <p>
          There is one special method in a class called a constructor.
          It is called whenever you request creation of new instance of
          an object. It the responsibility of the constructor to setup
          values of all fields within an object. Fields start with value
          of <tt>null</tt>, <tt>0</tt> or <tt>0.0</tt>.
        </p>
<code><![CDATA[public this ()
{
  minimal_temperature = -273.15;
  content = [];
}]]>
</code>
        <p>
          Constructors can take parameters. For example, if we wanted to
          set the <tt>minimal_temperature</tt> already at the object construction
          stage, we could write:
        </p>
<code>
<![CDATA[public this (temp : float)
{
  minimal_temperature = temp;
  content = [];
}]]>
</code>
        <p>
          For variant options and classes with fields only Nemerle provides
          a default constructor, that assigns each field. For example for 
          class:
        </p>
<code>
<![CDATA[class Foo
{
  x : int;
  y : float;
  z : string;
}]]>
</code>
        <p>
          The following constructor is generated:
        </p>
<code>
<![CDATA[public this (x : int, y : float, z : string)
{
  this.x = x;
  this.y = y;
  this.z = z;
}]]>
</code>
        <p>
          The constructor is called with the name of the class when
          creating new objects. Other methods are called using the
          dot operator. For example in <tt>refr.AddContent (Ketchup ())</tt>
          the <tt>refr</tt> is passed to the <tt>AddContent</tt> method
          as the <tt>this</tt> pointer and <tt>Ketchup ()</tt> is passed as
          <tt>elem</tt> formal parameter.
        </p>
<code><![CDATA[module Party {
  Main () : void
  {
    def refr = Refrigerator ();
    refr.AddContent (Beer ("Tiskie", 0.60));
    refr.AddContent (Ketchup ());
  }
}]]>
</code>
        <p>
          Fortunately, objects are not just a fancy notation for a function
          application on records.
        </p>
      </body>
    </subsection>
    

    <subsection id="inheritance">
      <title>Inheritance</title>
      <body>
        <p>
          Classes can <a
          ref="http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">inherit</a>
          from other classes. The fact that a class B inherits from a
          class A has a few consequences. The first one is that B has now
          all the fields and methods of A. The second one is that B is
          now <b>subtype</b> of A. This means that all the functions
          operating on A can now also operate on B.
        </p>
        <p>
          Class A is often called <b>parent</b> or <b>base</b> class of B
          (which is <b>derived</b> class).
        </p>
        <p>
          In the following example we can see how we can call methods
          defined in the base class (<tt>AddContent</tt>), as well as
          from the derived class (<tt>MoveToBedroom</tt>).
        </p>
        <p>
          Static methods and the constructor are not derived. The
          parameterless constructor is defined in this example. As the
          first thing to do, it calls parameterless constructor of the
          base class. It does it, so the derived fields are initialized 
          first. Then it initializes the new fields.
        </p>
        <p>
          The call to the parameterless parent constructor is in
          fact redundant. When there is no call to the parent class
          constructor, such a parameterless parent constructor call is
          assumed in the first line of a constructor.
        </p>
<code><![CDATA[class RefrigeratorWithRolls : Refrigerator
{
  public mutable position_x : int;
  public mutable position_y : int;

  public MoveBy (dx : int, dy : int) : void
  {
    position_x += dx;
    position_y += dy;
  }

  public MoveToBedroom () : void
  {
    position_x =  42;
    position_y = -42;
  }

  public this ()
  {
    base ();
    
    position_x = 0;
    position_y = 0;
  }
}

class TheDayAfter
{
  static Main () : void
  {
    def refr = RefrigeratorWithRolls ();
      for (mutable i = 0; i < 10; ++i)
      refr.AddContent (Beer ("Liech", 0.5));
    refr.MoveToBedroom ();
    // drink
  }
}]]>
</code>
 
      </body>
    </subsection>
    
    
    <subsection id="callvirt">
      <title>Virtual calls</title>
      <body>
        <p>
          The funny part begins where objects can react to calling some
          methods in a way dependent on the class of the object. It is
          possible to define <tt>virtual</tt> methods, which means they
          can be redefined in a derived class. Then when we have a function
          working on the base class, whenever it calls the virtual method,
          an appropriate method is selected base on actual object type.
		  <!--niejasne: method is selected basing on actual object type?-->
        </p>
        <p>
          This feature is called polymorphism in object-oriented world.
          We will, however, mostly use this word for another kind of
          polymorphism -- parametric polymorphism.
        </p>
        <p>
          When one wants to override a virtual method from a base class,
          it needs to be declared with <tt>override</tt> modifier.
        </p>
<code><![CDATA[class Refrigerator
{
  public mutable minimal_temperature : float;
  public mutable content : list <RefrigeratorContent>;

  public virtual AddContent (elem : RefrigeratorContent) : void
  {
    content = elem :: content
  }
  
  public this ()
  {
    minimal_temperature = -273.15;
    content = [];
  }
}

class RestrictedRefrigerator : Refrigerator
{
  public override AddContent (elem : RefrigeratorContent) : void
  {
    match (elem) {
      | Ketchup =>
        // don't add!
        printf ("Ketchup is not healthy!\n")
      | _ =>
        content = elem :: content
    }
  }
  
  public this ()
  {
  }
}]]>
</code>
        <p>
          Here we can see how the <tt>AddKetchup</tt> calls different
          methods depending on actual object type. The first call adds
          ketchup, the second call refuses to do so.
        </p>
<code><![CDATA[module Shop
{
  AddKetchup (refr : Refrigerator) : void
  {
    refr.AddContent (Ketchup ())
  }

  Main () : void
  {
    def r1 = Refrigerator ();
    def r2 = RestrictedRefrigerator ();
    AddKetchup (r1);
    AddKetchup (r2);
  }
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="interfaces">
      <title>Interfaces</title>
      <body>
        <p>
          The .NET Framework supports only single inheritance. This
          means that any given class can derive from just one base
          class. However, it is sometimes needed for a class to be two or
          more different things depending on context.  .NET supports it
          (just like Java) through interfaces. An interface is a contract
          specifying a set of methods  given class should implement. A
          class can implement zero or more interfaces (in addition to
          deriving from some base class).
        </p>
        <p>
          Implementing interface implies subtyping it. That is if you
          have a class A implementing I and method taking I as parameter,
          then you can pass A as this parameter.
        </p>
        <p>
          Interfaces most commonly state some ability of type. For
          example, the ability to convert itself to some other type or to
          compare with some other types.
        </p>
<code>
<![CDATA[interface IPrintable {
  Print () : void;
}

class RefrigeratorNG : Refrigerator, IPrintable
{
  public Print () : void
  {
    printf ("I'm the refrigerator!\n")
  }

  public this ()
  {
  }
}

module RP {
  PrintTenTimes (p : IPrintable) : void
  {
    for (mutable i = 0; i < 10; ++i)
      p.Print ()
  }
  
  Main () : void
  {
    def refr = RefrigeratorNG ();
    PrintTenTimes (refr)
  }
}]]>
</code>
        <p>
          The base class must come first after the colon in class
          definition. Then come interfaces in any order.
        </p>
      </body>
    </subsection>
    
  </section>
  
  
  <section id="poly">
    <title>Parametric polymorphism</title>
    <body>
      <p>
        <a
        ref="http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Parametric_polymorphism">
        Parametric polymorphism</a> is a wise way to say that function
        can operate on values of any type. Kind of <tt>System.Object</tt>
        and/or <tt>void*</tt> on steroids. This is very much like
        Generics in C# 2.0 or Java 1.5 and somewhat less like templates
        in C++.
      </p>
      <p>
        Both functions and types can be parameterized over types.
      </p>
    </body>
    
    <subsection id="poly-simple">
      <title>Simple polymorphism</title>
      <body>
        <p>
          Here we define a list of values of any type (it is also defined
          in Nemerle standard library but this is not the point here).
        </p>
<code>
<![CDATA[variant list <T> {
  | Cons { hd : T; tl : list <T>; }
  | Nil
}]]>
</code>
        <p>
          Here we used <tt>T</tt> as a type parameter to the list type.
          The ML-lovers would rather write <tt>'a</tt> instead and read
          it just as they read <i>alpha</i> (it is a convention to use
          identifiers starting with an apostrophe for type parameters).
          We will however stick to a C++-like convention.
        </p>
        <p>
          In the body of the <tt>list</tt> definition <tt>T</tt> can be used
          like any other type name. It is called <b>type variable</b>
          in this scope.
        </p>
        <p>
          Next we define the method parameterized on a type (it is
          reflected by listing <tt>&lt;'a></tt> after <tt>Head</tt>). We
          use the same <tt>T</tt>, but we could have used <tt>'b</tt>
          or <tt>foobar42</tt> as well.  Anyhow the algorithm of
          taking the head out of the list does not depend on the type
          of the actual values stored in the list. This method for
          <tt>list&lt;int></tt>, <tt>list&lt;string></tt> and even
          <tt>list&lt;list&lt;int>></tt> would look exactly the same.
          Therefore we can use generic <tt>'a</tt> type.
        </p>
        <p>
          You can see that the type of elements of the list (a
          parameter in <tt>list&lt;'a></tt>) is used as return type
          of this method.  This way we can ensure that we take an
          <tt>int</tt> out of <tt>list&lt;int></tt> and not some generic
          <tt>System.Object</tt>.
        </p>
<code>
<![CDATA[class List {
  public static Head<T> (l : list<T>) : T
  {
    match (l) {
      | Cons (hd, _) => hd
      | Nil =>
        throw System.ArgumentException ()
    }
  }
}]]>
</code>
      </body>
    </subsection>

    
    <subsection id="where-constraints">
      <title>Constraints on type variables</title>
      <body>
        <p>
          It is sometimes necessary for types to be substituted for type
          variables to conform to some specific interface. This concept is known
          as F-bounded polymorphism. We will address this issue in more detail,
          as it is probably new for most readers.
        </p>
        <p>
          For example the elements stored in a tree need to provide a
          comparison method. Thus, we can define an appropriate interface and
          then require <tt>'a</tt> in <tt>Tree&lt;'a></tt> to conform to
          it:
        </p>
<code>
<![CDATA[interface IComparable<'a> {
  CompareTo (elem : 'a) : int;
}

variant Tree<'a> 
  where 'a : IComparable<'a>
{
  | Node {
      left : Tree<'a>;
      elem : 'a;
      right : Tree<'a>;
    }
  | Tip
}]]>
</code>
        <p>
          In fact the <tt>IComparable</tt> interface is already defined
          in the standard library, but that is not the point.
        </p>
        <p>
          Now, once we ensured that elements in the tree conform
          to <tt>IComparable</tt>, we can use the <tt>CompareTo</tt>
          method. For example, to insert a thing into the tree we
          can use the following function:
        </p>

<code><![CDATA[
module TreeOperations {
  public Insert<'a> (t : Tree<'a>, e : 'a) : Tree<'a>
    where 'a : IComparable<'a>
  {
    match (t) {
      | Node (l, c, r) =>
        if (e.CompareTo (c) < 0)
          Node (Insert (l, e), c, r)
        else if (e.CompareTo (c) > 0)
          Node (r, c, Insert (r, e))
        else
          Node (r, e, l)
      | Tip =>
        Node (Tip (), e, Tip ())
    }
  }
}]]>
</code>
        <p>
          The people familiar with C# or Java will ask why not simply
          use something like:
        </p>
<code>
<![CDATA[interface IComparable {
  CompareTo (elem : IComparable) : int;
}

variant Tree
{
  | Node {
      left : Tree;
      elem : IComparable;
      right : Tree;
    }
  | Tip
}]]>
</code>
        <p>
          But this is only half good. The most often case for using a
          tree is to store elements of some specific type, for example
          strings. We don't want integers and strings to be stored in
          the same tree, for the very simple reason that we cannot compare
          integer with string in a reasonable way. Well, even if we could,
          we plainly cannot predict what other types beside integers and
          strings implement <tt>IComparable</tt> and thus can be passed
          to string's <tt>CompareTo</tt>.
        </p>
        <p>
          But the design above makes it impossible to ensure
          statically whether we're using the tree with correct
          types. When inserting nodes to the tree we upcast them all to
          <tt>IComparable</tt>. We will get runtime exception when
          string's <tt>CompareTo</tt> is passed integer argument. The
          second drawback is that when we extract elements out of the
          tree, we need to downcast them to a specific type. This is
          second possibility for runtime errors.
        </p>
        <p>
          To fully understand this issue please look at the following
          example:
        </p>
<code>
<![CDATA[interface IFrobincatable {
  Frobnicate (x : int) : void;
}

class C1 : IFrobincatable 
{
  public this () {}
  public Frobnicate (_ : int) : void {}
}

class C2 : IFrobincatable 
{
  public this () {}
  public Frobnicate (_ : int) : void {}
}

module M {
  f1<'a> (o : 'a) : 'a
    where 'a : IFrobincatable
  {
    o.Frobnicate (3);
    o
  }

  f2 (o : IFrobincatable) : IFrobincatable
  {
    o.Frobnicate (3);
    C1 ()
  }

  Main () : void
  {
    def x1 = f1 (C1 ()); // x1 : C1
    def x2 = f1 (C2 ()); // x2 : C2
    def x3 = f2 (C1 ()); // x3 : IFrobincatable
    def x4 = f2 (C2 ()); // x4 : IFrobincatable

    ()
  }
}
]]>
</code>
        <p>
          In the <tt>Main</tt> function you can see what types get the
          <tt>x1</tt>, <tt>x2</tt> etc values.
        </p>
      </body>
    </subsection>

    
  </section>

  
  <section id="exceptions">
    <title>Exceptions</title>
    <body>
      <p>
        In Nemerle you can use exceptions in a similar way you would
        use them in C#. The only difference is the syntax for the <tt>catch</tt>
        handlers -- it looks more or less like matching, you can even use the
        <tt>_</tt> to denote any exception that has to be caught.
      </p>
<code>
some_function (foo : string) : void
{
  when (foo == null)
    throw System.ArgumentException ("foo");
  // do something
}
</code>
<code>
some_other_function () : void
{
  try {
    some_function ()
  } 
  catch {
    | e : System.ArgumentException =>
      printf ("a problem:\n%s\n", e.Message)
  } 
  finally {
    printf ("yikes")
  }
}
</code>
<code>
some_other_function () : void
{
  try {
    some_function ()
  } catch {
    | e : System.ArgumentException =>
      printf ("invalid argument\n")
    | _ : System.Exception =>
      printf ("a problem\n")
  }
}
</code>
<code>
some_other_function () : void
{
  def f = open_file ();
  try {
    some_function ()
  } 
  finally {
    f.close ()
  }
}
</code>
<code>
class MyException : System.Exception {
  public this () {}
}
</code>
    </body>
  </section>
  
  
  <section id="properties-and-such">
    <title>Properties, indexers, delegates and events</title>
    <body>
      <p>
      </p>
    </body>
    
    <subsection id="properties">
      <title>Properties</title>
      <body>
        <p>
          syntactic sugar for get/set
        </p>
<code>
<![CDATA[class Button {
  text : string;
  public Text : string {
    get { text }
    set { text = value; Redraw () }
  }
}]]>
</code>
<code>
<![CDATA[def b = Button ();
b.Text = b.Text + "..."]]>
</code>
        <p>
          design: get should not have side effects
        </p>
      </body>
    </subsection>
    
    <subsection id="indexers">
      <title>Indexers</title>
      <body>
        <p>
        </p>
<code>
<![CDATA[class Table {
  store : array <array <string>>;
  // or Item...
  public this [row : int, column : int] : string
  {
    get { store[row][column] }
    set { store[row][column] = value }
  }
}]]>
</code>
<code>
<![CDATA[def t = Table ();
t[2, 3] = "foo";
t[2, 2]]]>
</code>
      </body>
    </subsection>
    
    <subsection id="delegates">
      <title>Delegates</title>
      <body>
        <p>
        </p>
<code>
<![CDATA[delegate Foo : int * string -> void;
delegate Callback : void -> void;
module X {
  some_fun () : void
  {
    mutable f = Foo (fun (_, _) {});
    f (3, "foo");
    f += fun (_, s) { System.Console.WriteLine (s) };
    f (42, "bar");
  }
}
]]>
</code>
      </body>
    </subsection>


    <subsection id="events">
      <title>Events</title>
      <body>
        <p>
        </p>
<code>
<![CDATA[class Button {
  public event OnClick : Callback;
}]]>
</code>
<code>
<![CDATA[def b = Button ();
b.OnClick += fun () { ... }]]>
</code>
      </body>
    </subsection>
  </section>


  <section id="design-by-contract">
    <title>Design by contract</title>
    <body>
      <p>
        Description of the <tt>Requires</tt>, <tt>Ensures</tt> and
        <tt>Invariant</tt> macros.
      </p>
<![CDATA[
[Invariant (m_temperature <= 6.0)]
class BeerControl {
  [Requires (how_much > 0.0)]
  public DrinkUsingAStraw (how_much : float) : void
  {
    m_amount -= how_much
  }

  [Ensures (m_amount > 0.0)]
  public DissipationHandler () : void
  {
    when (AReallySmallNumber < m_amount) {
      m_temperature += (Room.Temperature - m_temperature) / 100.0;
      m_amount -= 0.1; // loss due to the evaporation
    }
  }
  
  private mutable m_temperature : float;
  private mutable m_amount : float;
}]]>  
    </body>
  </section>


  <section id="class-docs">
    <title>Class library reference</title>
    <body>
      <p>
        Class library reference from Microsoft can be found under
        <link>http://msdn.microsoft.com/library/en-us/cpref/html/cpref_start.asp</link>.
      </p>
    </body>
  </section>

  <!-- TODO:
         - null
         - : vs :>
         - overloading
    -->
  
  
  <!--
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
<code>
<![CDATA[
}]]>
</code>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>
