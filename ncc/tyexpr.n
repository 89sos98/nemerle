/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
public module Tyexpr {
  public type CTX = TypingContext;

  variant Call_result
  {
    | CR_error { msg : string; }
    | CR_ok { call : Expr; sub : Subst; }
  }

  class Typing_error : System.Exception
  {
    public msg : string;
    public this (s : string) { this.msg <- s; }
  }

  public type_of (expr : Expr) : Type
  {
    if (expr.expr_ty == null) Util.ice ()
    else expr.expr_ty;
  }

  fixup (expr : Expr, loc : Location, t : Type) : Expr
  {
    expr.loc <- loc;
    expr.expr_ty <- t;
    expr
  }

  fixup (expr : Expr, t : Type) : Expr
  {
    expr.loc <- Location_stack.top ();
    expr.expr_ty <- t;
    expr
  }

  public expect_type (name : string, expr : Expr, t : Type) : void
  {
    if (type_of (expr) >:> t) ()
    else
      Message.error (expr.loc, name + " was expected to have type " +
                               t.as_string () + " while it has " +
                               (type_of (expr)).as_string ())
  }

  // given an expression return list of symbols it can expand to
  make_value_reference (ctx : CTX, expr : PT.Expr, fallback : bool) : list <Expr>
  {
    def lookup_type (expr) {
      match (Util.qidl_of_expr (expr)) {
        | Some ((r, name)) =>
          match (name.GetEnv (ctx.env).LookupType (r, ctx.parent_type)) {
            | (Some) as tc => tc
            | _ => None ()
          }
        | _ => None ()
      }
    };

    def unalias (ti : Tycon) {
      match (ti.GetTydecl ()) {
        | TD_alias (T_app (ti, _)) => unalias (ti)
        | _ => ti
      }
    };

    def lookup_ctors (ti : Tycon) {
      def ti = unalias (ti);
      def is_ctor (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_ctor when m.CanAccess (ctx.parent_type) => true
              | _ => false
            }
          | _ => false
        }
      };
      match (List.Filter (ti.LookupMember (".ctor"), is_ctor)) {
        | [] =>
          Message.fatal_error ("type `" + ti.GetFullName () +
                               "' has no accessible constructors")
        | decls => decls
      }
    };

    def convert_symbols (acc, syms) {
      def handle_type (t : Tycon) {
        def mkctor (m : IMember) {
          def ty =
            match (m.GetMemType ()) {
              | T_fun (arg, T_void) =>
                def ret_t =
                  match (t.GetTydecl ()) {
                    | TD_variant_option =>
                      def t' = Option.UnSome (t.SuperClass ());
                      t'.GetMemType () /- t.SubtypingSubst (t')
                    | _ =>
                      t.GetMemType ()
                  };
                def ret = T_fun (arg, ret_t) /- t.FreshSubst ();
                // Message.debug ("arg " + arg.as_string () +  " ret "
                //                + ret.as_string ());
                ret
                
              | t => Util.ice ("fscked ctor type " + t.as_string ())
            };
          E_static_ref (loc = expr.loc, ty = ty, mem = m)
        };
        match (t.GetConstantObject ()) {
          | None =>
            List.Map (lookup_ctors (t), mkctor)
          | Some (f) =>
            [E_constant_object_ref (loc = expr.loc, 
                                    ty = T_fun (T_void (), 
                                                f.GetMemType () /- t.FreshSubst ()), 
                                    mem = f)]
        }
      };
      
      def last_chance () {
        match ((acc, syms)) {
         | ([], [_]) => true
         | _ => false
        }
      };
        
      def can_access () {
        match (syms) {
          | Sym_type_member (x) :: _
            when x.CanAccess (ctx.parent_type) => true
          | Sym_type (t) :: _
            when t.CanAccess (ctx.parent_type) => true
          | _ => false
        }
      };

      match (syms) {
        | [] => acc
        | Sym_type_member (x) :: xs when x.IsStatic () =>
          if (can_access ()) {
              def acc =
                match (x.GetKind ()) {
                  | MK_type (t) => List.RevAppend (handle_type (t), acc)
                  | MK_method (m) =>
                      def name = m.GetExternName ();
                      if (name == null || name.StartsWith ("%op"))
                        E_static_ref (loc = expr.loc, ty = m.GetFreshType (),
                                      mem = x) :: acc
                      else {
                        def split_at_dots (str : string) {
                          def idx = str.LastIndexOf ('.');
                          if (idx == -1) PT.E_ref (PT.Name (str))
                          else PT.E_member (split_at_dots (str.Substring (0, idx)),
                                            PT.SS_string (PT.Name (str.Substring (idx + 1))))
                        };
                        def exprs =
                          make_value_reference (ctx, split_at_dots (name),
                                                fallback = false);
                        def valid (expr) {
                          match (expr) {
                            | E_static_ref (mem) =>
                              Tyutil.types_eq (mem.GetMemType (), m.GetMemType ())
                            | _ => false
                          }
                        };
                        match (List.Filter (exprs, valid)) {
                          | [x] => x :: acc
                          | [] =>
                            Message.fatal_error ("unbound extern symbol `" + name + "'")
                          | _ =>
                            Message.fatal_error ("wrong extern symbol `" + name + "'")
                        }
                      }
                  | MK_property (x) =>
                    E_static_property_ref (loc = expr.loc, ty = x.GetMemType (),
                                           prop = x) :: acc
                  | MK_field =>                    
                    E_static_ref (loc = expr.loc, ty = x.GetMemType (), mem = x) :: acc
                };
              convert_symbols (acc, xs)
          } else {
            when (last_chance ())
              Message.error ("cannot access `" +
                             x.GetDeclaringTycon ().GetFullName () + 
                             "." + x.GetName () + "'");
            convert_symbols (acc, xs)
          }
        | Sym_type_member :: xs =>
          convert_symbols (acc, xs)
        | Sym_type (t) :: xs when can_access () => 
          convert_symbols (List.RevAppend (handle_type (t), acc), xs)
        | Sym_type (t) :: xs => 
          when (last_chance ())
            Message.error ("cannot access type `" + t.GetFullName () + "'");
          convert_symbols (acc, xs)
      }
    };

    def error_when_empty (lst, msg) {
      match (lst) {
        | [] => Message.fatal_error (msg)
        | _ => lst
      }
    };

    Util.locate (expr.loc, fun () {
      match (expr) {
        | PT.E_ref (n) =>
          match (ctx.LookupLocal (n)) {
            | Some (d) =>
              ctx.Closurise (d);
              d.ever_used <- true;
              def ty =
                match (d.kind) {
                  | D_local_fun (h, _) =>
                    d.ty /- Tyvar.fresh_subst (h.typarms)
                  | _ => d.ty
                };
              [E_local_ref (loc = expr.loc, ty = ty, decl = d)]
            | None =>
              def from_this =
                match (ctx.this_ptr_decl) {
                  | Some ({ty = T_app (ti, _)}) when n.context == null =>
                    def is_instance (m : IMember) { ! m.IsStatic () };
                    if (List.Exists (ti.LookupMember (n.id), is_instance))
                      lookup_member (ctx, expr.loc,
                                     ty_expr (ctx, PT.E_this ()), n.id, 
                                     error_when_not_found = false)
                    else []
                  | _ => []
                };
              def env = n.GetEnv (ctx.env);
              def res = convert_symbols (from_this, env.LookupSymbol (n.id));
              error_when_empty (res, "unbound symbol `" + n.id + "'")
          }

        | PT.E_member (e1, PT.SS_string ({ id = x })) =>
          match (lookup_type (e1)) {
            | Some (t) =>
              def err = "unbound member `" + x + "' in type `"
                        + t.GetFullName () + "'";
              def t = unalias (t);
              match (t.LookupMember (x)) {
                | [] =>
                  match (lookup_type (expr)) {
                    | Some (t) =>
                      convert_symbols ([], [Sym_type (t)])
                    | None =>
                      Message.fatal_error (err)
                  }
                | lst =>
                  def loop (x : IMember, acc) { 
                    if (x.IsStatic ())
                      Sym_type_member (x) :: acc
                    else acc
                  };
                  def lst' = List.FoldLeft (lst, [], loop);
                  error_when_empty (convert_symbols ([], lst'), err)
              }
            | None =>
              match (lookup_type (expr)) {
                | Some (t) =>
                  convert_symbols ([], [Sym_type (t)])
                | None =>
                  lookup_member (ctx, expr.loc, ty_expr (ctx, e1), x)
              }
          };

        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_base =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = T_app (ti, _)}); in_ctor = true} =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  // FIXME: check access
                  def mkbase (m : IMember) {
                    E_base (loc = expr.loc,
                            ty = m.GetMemType () /- ti.SubtypingSubst (baseti),
                            base_ctor = (m :> IMethod))
                  };
                  List.Map (lookup_ctors (baseti), mkbase)

                | None =>
                  Message.fatal_error ("class " + ti.GetFullName () +
                                       " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base' used outside constructor")
          }

        | _ when fallback => [ty_expr (ctx, expr)]
        | _ => Util.ice ("evil value passed to make_value_reference")
      }
    })
  }

  // given list of formal parms names and actual parms names,
  // reorder actuals to match formals
  reorder_named_parms (names : list <string>, parms : list <Parm>) : list <Parm>
  {
    def is_named (p : Parm) : bool { p.name != "" };
    mutable seen_kw <- false;

    def loop (acc : list <Parm>, names : list <string>,
              parms : list <Parm>) : list <Parm> {
      match ((parms, names)) {
        | (p :: ps, n :: ns) =>
          if (p.name == "")
            if (seen_kw)
              throw Typing_error ("unnamed parameters after named")
            else
              loop (p :: acc, ns, ps)
          else {
            seen_kw <- true;
            def lookup (parms : list <Parm>) : Parm * list <Parm> {
              match (parms) {
                | p :: ps =>
                  if (p.name == n)
                    (p, ps)
                  else {
                    def (r, ps) = lookup (ps);
                    (r, p :: ps)
                  }
                | [] =>
                  throw Typing_error ("keyword parameter `" + n + "' not found")
              }
            };
            def (p, ps) = lookup (parms);
            loop (p :: acc, ns, ps)
          }
        | ([], []) => List.Rev (acc)
        | _ => Util.ice ()
      }
    };
    if (List.Exists (parms, is_named))
      match (names) {
        | [] =>
          throw Typing_error ("named parameters given but formals' names cannot"
                              " be inferred")
        | _ =>
          loop ([], names, parms)
      }
    else
      parms
  }

  // check if FN can be called with PARMS
  check_call_to (parms : list <Parm>, fn : Expr) : Call_result
  {
    def check_arg (parm : Parm, ty : Type, ctx : int * Subst) : int * Subst {
      def (arg_no, sub) = ctx;
      match (Tyutil.unify (sub, type_of (parm.expr), ty, true)) {
        | Some (u) =>
          (arg_no + 1, u)
        | None =>
          throw Typing_error (sprintf ("in arg #%d needed %s got %s", 
                                       arg_no, (ty /- sub).as_string (),
                                       (type_of (parm.expr) /- sub).as_string ()))
      }
    };

    def formal_names = {
      def from_header (h : Fun_header) : list <string> {
        List.Map (h.parms, fun (p : Fun_parm) : string { p.name })
      };
      match (fn) {
        | E_local_ref ({kind = D_local_fun (h, _)}) =>
          from_header (h)
        | E_static_ref (m) =>
          match (m.GetKind ()) {
            | MK_method (m) => from_header (m.GetHeader ())
            | _ => []
          }
        | E_method_ref (_, m) =>
          from_header (m.GetHeader ())
        | _ => []
      }
    };

    match (Tyutil.top_expand (type_of (fn))) {
      | T_fun (from, ret) =>
        def args = Tyutil.fun_args (from);
        def wrong_args_cnt () {
          throw Typing_error ("needed " + (List.Length (args)).ToString () +
                              " parameters, got " + (List.Length (parms)).ToString ())
        };
        try {
          def args =
            match ((parms, args)) {
              | ([parm], _ :: _ :: _) =>
                match (Tyutil.top_expand (type_of (parm.expr))) {
                  | T_prod (types) when List.Length (types) == List.Length (args) =>
                    [T_prod (args)]
                  | _ => wrong_args_cnt ()
                }
              | _ when List.Length (args) != List.Length (parms) => wrong_args_cnt ()
              | _ => args
            };
          def parms = reorder_named_parms (formal_names, parms);
          def (_, sub) =
            List.FoldLeft2 (parms, args, (1, SystemMap ()), check_arg);
          def res_expr =
            match (fn) {
              | E_constant_object_ref (mem) =>
                E_static_ref (fn.loc, ret /- sub, mem)
              | _ => 
                E_call (fn.loc, ret /- sub, fn, parms)
            };
          //Message.debug ("ret type = " + (ret /- sub).as_string ());
          CR_ok (res_expr, sub)
        } catch { x : Typing_error => CR_error (x.msg) }
      | _ =>
        CR_error ("called value has non-functional type " +
                  (type_of (fn)).as_string ())
    }
  }

  transform_tail_call (ctx : CTX, ex : Expr) : Expr
  {
    match (ex) {
      | E_call ((E_local_ref (({kind = D_local_fun (h, _)}) as decl)) as fn, parms) =>
        if (ctx.in_tail_position && ctx.current_fun.id == h.id)
          E_self_tail_call (ex.loc, ex.expr_ty, parms)
        else {
          match (h.usage) {
            | FU_not_used =>
              if (decl.parent_fun.id == ctx.current_fun.id &&
                  List.Length (parms) == List.Length (h.parms))
                h.usage <- FU_used_just_once ()
              else
                h.usage <- FU_used ()
            | FU_used_just_once =>
              h.usage <- FU_used ()
            | FU_used | FU_used_as_first_class => ()
          };
          if (ctx.in_tail_position)
            E_tail_call (ex.loc, ex.expr_ty, fn, parms)
          else
            ex
        }
      | E_call ((E_static_ref (mem)) as fn, parms) when ctx.in_tail_position =>
        match (mem.GetKind ()) {
          | MK_method (meth) when meth.GetHeader ().id == ctx.current_fun.id =>
            E_self_tail_call (ex.loc, ex.expr_ty, parms)
          | _ =>
            E_tail_call (ex.loc, ex.expr_ty, fn, parms)
        }
      | E_call (fn, parms) when ctx.in_tail_position =>
        E_tail_call (ex.loc, ex.expr_ty, fn, parms)
      | _ => ex
    }
  }

  resolve_overloaded_call (ctx : CTX, in_tail_pos : bool, fncs : list <Expr>,
                           parms : list <Parm>) : Expr
  {
    match (fncs) { [] => Util.ice ("empty fncs") | _ => () };
    def check_one (fn, ctx) {
      def (errs, rets) = ctx;
      match (check_call_to (parms, fn)) {
        | CR_ok (ex, sub) => (errs, (ex, sub) :: rets)
        | CR_error (e) => ((e, fn) :: errs, rets)
      }
    };

    match (List.FoldLeft (fncs, ([], []), check_one)) {
      // special case (simple)
      | (_, [(x, sub)]) =>
        Tyvar.global_store (sub);
        transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x)
      | ([(err, fn)], []) =>
        Message.error (err + " calling " + describe_expression (fn)); 
        throw Recovery ()
      | (p, []) =>
        Message.error ("typing error in call:");
        def print_err (err, fn) {
          Message.error ("  " + err + " calling " + describe_expression (fn)) 
        };
        List.Iter (p, print_err);
        throw Recovery ()
      // in general we look for set of maximal argument types
      | (_, l) =>
        def get_type (ex : Expr, s : Subst) : Type * (Expr * Subst) {
          match (ex) {
            | E_call (fn, _) =>
              match (Tyutil.top_expand (type_of (fn))) {
                | T_fun (t1, _) => (t1, (ex, s))
                | _ => Util.ice ()
              }
            | _ => Util.ice ()
          }
        };

        match (Tyutil.maximal_types (List.Map (l, get_type))) {
          | [(_, (x, sub))] =>
            Tyvar.global_store (sub);
            transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x)
          | l =>
            def print_err (_ : Type, x : Expr * Subst) : void {
              match (x) {
                /*
                | (E_call (E_ref (d), _), _) =>
                  // FIXME: we could do better
                  Message.error (d.loc, "    functional value of type "
                                 + d.ty.as_string ())
                */
                | (E_call (ex, _), _) =>
                  Message.error ("    functional value of type "
                                 + (type_of (ex)).as_string ())
                | _ => Util.ice ("non-call")
              }
            };
            Message.error ("overloading resolution ambiguity between:");
            List.Iter (l, print_err);
            throw Recovery ()
        }
    }
  }

  public lookup_member (ctx : CTX, loc : Location, o : Expr, mem : string)
  : list <Expr>
  {
    lookup_member (ctx, loc, o, mem, true);
  }

  // lookup member MEM in type_of (O)
  // return list of how we can call it
  public lookup_member (ctx : CTX, loc : Location, o : Expr, mem : string, 
                        error_when_not_found : bool) : list <Expr>
  {
    mutable problem <- "???";
    def visited = Hashtable (10);

    def collect_from (t, acc) {
      match (Tyutil.top_expand (t)) {
        | T_app (ti, args) =>
          if (visited.Contains (ti.GetId ())) acc
          else {
            visited.Add (ti.GetId (), null);

            def subst = ti.MakeSubst (args);
            def can_access (mem : IMember, acc) {
              if (!mem.IsStatic () && mem.CanAccess (ctx.parent_type))
                mem.GetKind () :: acc
              else
                acc
            };
            def members = ti.LookupMember (mem);
            def accessible_members = List.FoldLeft (members, [], can_access);
            def mems =
              match (accessible_members) {
                | [MK_field (f)] =>
                  [E_field_ref (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [] =>
                  def how =
                    match (members) {
                      | [] => "unbound"
                      | _ => "inaccessible"
                    };
                  problem <- how + " member `" + mem + "' in type `" +
                             ti.GetFullName () + "'";
                  []
                  
                | lst =>
                  mutable was_prop <- false;
                  mutable was_meth <- false;
                  def make (m) {
                    match (m) {
                      | MK_property (p) when !was_meth =>
                        was_prop <- true;
                        E_property_ref (loc, Tyutil.TypeOfMemberIn (p, ti) /- subst, o, p)
                      | MK_method (m) when !was_prop =>
                        was_meth <- true;
                        E_method_ref (loc, Tyutil.TypeOfMethodIn (m, ti) /- subst, o, m)
                      | _ =>
                        Message.fatal_error ("ambiguous member name `" + mem +
                                             "' in type `" + ti.GetFullName () + "'")
                    }
                  };
                  List.Map (lst, make)
               };
            List.Append (mems, acc)
          }

        | T_var (tv) =>
          if (visited.Contains (tv.id)) acc
          else {
            visited.Add (tv.id, null);
            match (List.FoldLeft (Tyvar.constraints (tv), acc, collect_from)) {
              | [] =>
                problem <- "no constrain of " + t.as_string () +
                           " provides member `" + mem + "'";
                []
              | acc => acc
            }
          }

        | T_ref (t) =>
          collect_from (t, acc) // FIXME: this is a quick hack for Kamil

        | T_array =>
          collect_from (Tyutil.make_tapp ("System.Array"), acc)

        | _ =>
          problem <- "type `" + t.as_string () + "' was expected to be class";
          acc
      }
    };

    match (collect_from (type_of (o), [])) {
      | [] when error_when_not_found => Message.fatal_error (problem)
      | x => x
    }
  }

  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.E_match) : Expr * Type
  {
    def itp = ctx.in_tail_position;
    def ctx = ctx.WithInTailPosition (false);
    def matched_value = ty_expr (ctx, mtch.expr);

    def do_case (c : PT.Match_case, acc) {
      def (pat, ctx') = Typattern.ty_patterns (ctx, type_of (matched_value), c.patterns);
      def body = ty_expr (ctx'.WithInTailPosition (itp), c.body);
      match (acc) {
        | (Some (t), l) =>
          match (Tyutil.unify_branches (t, type_of (body))) {
            | Some (t') => (Some (t'), Match_case (pat, body) :: l)
            | None =>
              expect_type ("match case body", body, t);
              Util.ice () // not reached
          }
        | (None, l) =>
          (Some (type_of (body)), Match_case (pat, body) :: l)
      }
    };

    match (List.FoldLeft (mtch.cases, (None (), []), do_case)) {
      | (Some (t), mcs') =>
        def mcs = List.Rev (mcs');
        Typattern.check_matching (mcs);
        (E_match (matched_value, mcs), t)
      | (None, _) =>
        Message.fatal_error ("cannot have empty match construct");
    }
  }

  ty_letfun (ctx : CTX, fs : list <PT.Function_decl>) : list <Function_decl> * CTX
  {
    def make_fun (d : PT.Function_decl) {
      def pars = {
        def h = ctx.current_fun;
        if (h.decl == null) [h]
        else
          match (h.decl.kind) {
            | D_local_fun (_, pars) => h :: pars
            | _ => Util.ice ()
          }
      };

      def h = d.header;
      def name_obj = Macros.NameOfSString (h.name);
      def (tenv, typarms) = ctx.parent_type.BindTyparms (ctx.tenv, h.typarms);
      def mkparm (p : PT.Fun_parm) : Fun_parm {
        def name = Macros.NameOfSString (p.name);
        Fun_parm (loc = p.loc, name = name.id, color = name.color,
                  ty = ctx.parent_type.BindType (tenv, p.ty), decl = null)
      };
      def h' = Fun_header (
         ret_type = ctx.parent_type.BindType (tenv, h.ret_type),
         typarms = typarms,
         name = name_obj.id,
         parms = List.Map (h.parms, mkparm),
         tenv = tenv,
         loc = h.loc);

      def lv = ctx.DefineLocal (name_obj,
                                D_local_fun (h', pars), 
                                Tyutil.fun_type (h'));
      h'.decl <- lv;
      h'
    };

    def headers = List.Map (fs, make_fun);
    def localvals = List.Map (headers, fun (h : Fun_header) { h.decl });
    def ctx = ctx.WithLocals (localvals);
    def do_fun (d : PT.Function_decl, h : Fun_header) : Function_decl {
      Function_decl (h.decl, ty_function (ctx, h, d.body))
    };
    (List.Map2 (fs, headers, do_fun), ctx)
  }

  ty_sequence (ctx : CTX, l : list <PT.Expr>) : Expr
  {
    def in_tail_pos = ctx.in_tail_position;
    def orig_ctx = ctx;
    def ctx = ctx.WithInTailPosition (false);

    def go () : Expr {
      match (l) {
        | [x] => ty_expr (orig_ctx, MacroRegistry.expand_macro (ctx, x))

        | x :: xs =>
          match (MacroRegistry.expand_macro (ctx, x)) {
            | PT.E_letfun (fs) =>
              def (fs', ctx') = ty_letfun (ctx, fs);
              def body = ty_sequence (ctx'.WithInTailPosition (in_tail_pos), xs);
              fixup (E_letfun (fs', body), type_of (body))

            | (PT.E_let) as x =>
              def val = ty_expr (ctx, x.val);
              def name = match (x.name) {
                | PT.SS_string (n) => n
                | _ =>
                  Message.fatal_error ("$ operator used outside quotation "
                                       "<[ ... ]> context")
              };
              def decl = ctx.DefineLocal (name, D_local_value(), type_of (val));
              decl.is_ref <- x.is_ref;
              def body = ty_sequence (ctx.WithLocal (decl).
                                      WithInTailPosition (in_tail_pos), xs);
              fixup (E_let (decl, val, body), type_of (body))

            | PT.E_letpat (p, v) =>
              def body = PT.E_sequence (xs);
              def mtch = PT.E_match (v, [PT.Match_case ([(p, None ())], body)]);
              body.loc <- (List.Head (xs)).loc;
              mtch.loc <- p.loc;
              ty_expr (orig_ctx, mtch)

            | x =>
              def ex = ty_expr (ctx, x);
              def t = type_of (ex);
              if (t >:> T_void ()) {
                def tl = ty_sequence (orig_ctx, xs);
                fixup (E_sequence (ex, tl), type_of (tl))
              } else {
                Message.warning ("ignored computed value of type " + t.as_string ());
                Message.hint_once ("use ignore (...); to avoid the warning");

                def tmp = Util.tmpname ("ign");
                def decl = ctx.DefineLocal (tmp, 1, D_local_value (), type_of (ex));
                def body = ty_sequence (ctx.WithLocal (decl).
                                        WithInTailPosition (in_tail_pos), xs);
                fixup (E_let (decl, ex, body), type_of (body))
              }
          }
        | [] => Util.ice ("empty sequence")
      }
    };

    Util.locate ((List.Head (l)).loc, go)
  }

  public ty_literal (_ : CTX, l : Literal) : Type
  {
    match (l) {
      | L_void => T_void ()
      | L_null =>
        match (Tyvar.free_variable ()) {
          | (T_var (tv)) as r => tv.value <- TV_free_from_null (); r
          | _ => Util.ice ()
        }
      | L_byte => Tyutil.make_tapp ("System.Byte")
      | L_sbyte => Tyutil.make_tapp ("System.SByte")        
      | L_short => Tyutil.make_tapp ("System.Int16")
      | L_ushort => Tyutil.make_tapp ("System.UInt16")        
      | L_int => Tyutil.make_tapp ("System.Int32")
      | L_uint => Tyutil.make_tapp ("System.UInt32")        
      | L_long => Tyutil.make_tapp ("System.Int64")
      | L_ulong => Tyutil.make_tapp ("System.UInt64")        
      | L_char => Tyutil.make_tapp ("System.Char")
      | L_string => Tyutil.make_tapp ("System.String")
      | L_float => Tyutil.make_tapp ("System.Single")
      | L_double => Tyutil.make_tapp ("System.Double")
      | L_decimal => Tyutil.make_tapp ("System.Decimal")        
      | L_bool => Tyutil.make_tapp ("System.Boolean")
      | L_enum (_, t) => Tyutil.make_tapp (t.ToString ())
    }
  }

  describe_expression (expr : Expr) : string
  {
    match (expr) {
      | E_local_ref (d) =>
        "a reference to local symbol `" + d.name + "'"
      | E_static_ref (m) =>
        def tyname =
          if (m.GetDeclaringTycon () == null)
            ""
          else
            m.GetDeclaringTycon ().GetFullName () + ".";
        "a reference to global symbol `" + tyname + m.GetName () + "'"
      | E_field_ref (_, f) =>
        "a reference to field `" + f.GetName () + "'"
      | E_constant_object_ref (m) =>
        "a reference to constant constructor of `" + 
        m.GetDeclaringTycon ().GetFullName () + "'"
      | E_static_property_ref (p)
      | E_property_ref (_, p) =>
        "a reference to property `" + p.GetName () + "'"
      | E_method_ref (_, m) =>
        "a reference to method `" + m.GetName () + "'"
      | E_tail_call (f, _)
      | E_call (f, _) =>
        "a function call to " + describe_expression (f)
      | E_self_tail_call =>
        "self-recursive function call"
      | E_assign => "an assignment"
      | E_let => "an value binding"
      | E_letfun => "an function binding"
      | E_match => "an `match' expression"
      | E_raise => "a throw expression"
      | E_try_with => "a try...with expression"
      | E_try_finally => "a try...finally expression"
      | E_literal => "a literal value"
      | E_this => "a this pointer reference"
      | E_base => "a base class reference"
      | E_type_conversion => "a type conversion (:>)"
      | E_type_enforcement => "a type enforcement (:)"
      | E_sequence => "a sequence"
      | E_tuple => "a tuple constructor"
      | E_mkarray => "a array constructor"
      | E_array_indexer => "an array indexer reference"
      | E_typeof => "an typeof expression"
      | E_opcode => "an operator reference"
    }
  }

  is_indexer_property (prop : IProperty) : bool
  {
    def getter = prop.GetGetter ();
    def setter = prop.GetSetter ();
    (getter != null && List.Length (getter.GetHeader ().parms) != 0) ||
    (setter != null && List.Length (setter.GetHeader ().parms) != 1)
  }

  make_first_class (ctx : CTX, expr : Expr) : Expr
  {
    match (expr) {
      | E_method_ref (obj_ref, mem) =>
        match (Tyutil.top_expand (type_of (expr))) {
          | T_fun (from, _) =>
            def mkparm (_, acc) {
               def t = Util.tmpname ("parm");
               def (fps, ps) = acc;
               (PT.Fun_parm (expr.loc, PT.SS_string (PT.Name (t)), PT.T_infer (), 
                             PT.FP_normal ()) :: fps,
                             PT.Parm (PT.E_ref (expr.loc, PT.Name (t))) :: ps)
            };
            def (fps, ps) = List.FoldLeft (Tyutil.fun_args (from), ([], []), mkparm);
            def ptr_name = Util.tmpname ("ptr");
            def header =
              PT.Fun_header (expr.loc, PT.SS_string (PT.Name (Util.tmpname ("ml"))), 
                             PT.T_infer (), fps);
            def body = PT.E_call (PT.E_member (PT.E_ref (PT.Name (ptr_name)), 
                                  PT.SS_string (PT.Name (mem.GetName ()))), ps);
            //def body = <[ $(ptr_name : var) . $mem_name (.. $ps) ]>;
            def lambda = PT.E_lambda (expr.loc, PT.Function_decl (header, body));
            ty_expr (ctx, PT.E_sequence ([
                PT.E_let (false, PT.SS_string (PT.Name (ptr_name)),
                          PT.E_typed_expr (obj_ref)),
                lambda
                ]))
            //ty_expr (ctx, <[ { def $ptr_name = $(PT.E_typed_expr (tye));
            //              $lambda } ]>)
          | _ => Util.ice ()
        }
      | E_local_ref ({kind = D_local_fun (h, _)}) =>
        h.usage <- FU_used_as_first_class ();
        expr
      | E_property_ref (_, prop) when is_indexer_property (prop) =>
        Message.fatal_error ("indexer property `" + prop.GetName () + 
                             "' used as first class value")
      | _ => expr
    }
  }

  public ty_expr (ctx : CTX, expr : PT.Expr) : Expr
  {
    def expr = ty_expr_with_no_properties_conversion (ctx, expr);
    def make_getter (obj, prop : IProperty, args) {
      def meth = prop.GetGetter ();
      E_call (expr.loc, expr.expr_ty, 
              E_method_ref (expr.loc, meth.GetMemType (), obj, meth),
              args)
    };
    def make_static_getter (prop : IProperty, args) {
      def meth = prop.GetGetter ();
      E_call (expr.loc, expr.expr_ty, 
              E_static_ref (expr.loc, meth.GetMemType (), meth),
              args)
    };
    match (expr) {
      | E_property_ref (obj, prop) => make_getter (obj, prop, [])
      | E_call (E_property_ref (obj, prop), args) => make_getter (obj, prop, args)
      | E_static_property_ref (prop) => make_static_getter (prop, [])
      | E_call (E_static_property_ref (prop), args) => make_static_getter (prop, args)
      | expr => expr
    }
  }

  convert_setter_property (_ctx : CTX, expr : Expr, val : Expr) : Expr * Type
  {
    def make_setter (obj, prop : IProperty, args) {
        def meth = prop.GetSetter ();
        E_call (expr.loc, T_void (), 
                E_method_ref (expr.loc, meth.GetMemType (), obj, meth),
                List.Append (args, [Parm (false, val, "")]))
    };
      
    def make_static_setter (prop : IProperty, args) {
        def meth = prop.GetSetter ();
        E_call (expr.loc, T_void (), 
                E_static_ref (expr.loc, meth.GetMemType (), meth),
                List.Append (args, [Parm (false, val, "")]))
    };
      
    def res =
      match (expr) {
        | E_property_ref (obj, prop) =>
          make_setter (obj, prop, [])
        | E_call (E_property_ref (obj, prop), args) =>
          make_setter (obj, prop, args)
        | E_static_property_ref (prop) =>
          make_static_setter (prop, [])
        | E_call (E_static_property_ref (prop), args) =>
          make_static_setter (prop, args)
        | expr => E_assign (expr.loc, T_void (), expr, val)
      };

    (res, T_void ())
  }
  
  ty_expr_with_no_properties_conversion (ctx : CTX, expr : PT.Expr) : Expr
  {
    def do_typing () : Expr * Type {
      def restart (e : PT.Expr) : Expr * Type {
        def ex = ty_expr (ctx, e);
        (ex, type_of (ex))
      };
      def bind_ty (t : PT.Type) : Type {
        ctx.parent_type.BindType (ctx.tenv, t)
      };

      def orig_ctx = ctx;
      // default to non-tail position (good for most expressions)
      def ctx = ctx.WithInTailPosition (false);

      def expr = MacroRegistry.expand_macro (ctx, expr);
      
      match (expr) {
        // this doesn't make much sense I hope
        | PT.E_let =>
          Message.fatal_error ("let binding not followed by any expression")
        | PT.E_letpat =>
          Message.fatal_error ("letpat binding not followed by any expression")
        | PT.E_letfun =>
          Message.fatal_error ("letfun binding not followed by any expression")

        | PT.E_lambda (d) =>
          def newname = Util.tmpname ("l");
          d.header.name <- PT.SS_string (PT.Name (newname));
          def rf = PT.E_ref (PT.Name (newname));
          def lf = PT.E_letfun ([d]);
          def sq = PT.E_sequence ([lf, rf]);
          rf.loc <- expr.loc;
          lf.loc <- expr.loc;
          sq.loc <- expr.loc;
          restart (sq)

        | PT.E_mkarray ([]) => restart (<[ array (0) ]>)

        | PT.E_mkarray (lst) =>
          def (typed_initializers, array_type) =
          match (lst) {
            | [] => Util.ice ()
            | head :: _ =>
              def typed_head = ty_expr (ctx, head);
              def array_type = type_of (typed_head);
              def type_array_initializers (initializers) {
                match (initializers) {
                  | [] => []
                  | initializer :: rest =>
                    def typed_initializer = ty_expr (ctx, initializer);
                    expect_type ("array initializer", typed_initializer, array_type);
                    typed_initializer :: type_array_initializers (rest)
                }
              };
              (E_mkarray (type_array_initializers (lst)), T_array (array_type))
          };
          typed_initializers.expr_ty <- array_type;
          typed_initializers.loc <- expr.loc;
          def fresh_name = Util.tmpname ("array_initializer");
          def decl = ctx.DefineLocal (fresh_name, 1, D_local_value (), array_type);
          decl.is_ref <- false;
          def array_as_let = E_let (decl, typed_initializers, E_local_ref (decl));
          array_as_let.loc <- expr.loc;
          (array_as_let, array_type)

        | PT.E_empty_array (sizes) =>
          match (sizes) {
            | [size] =>
              def fv = Tyvar.free_variable ();
              def type_of_expr = E_typeof (expr.loc,
                                           Tyutil.make_tapp ("System.Type"), fv);
              def call_expr =
                <[ System.Array.CreateInstance ($(type_of_expr : typed), $size) ]>;
              def ex = ty_expr (ctx, call_expr);
              def ex_ty = T_array (fv);
              (E_type_conversion (ex, ex_ty), ex_ty)
            | _ =>
              Message.fatal_error ("multi-dimensional arrays not supported yet")
          }

        // FIXME: allow for multi-dimensional indexers
        | PT.E_indexer (obj, args) =>
          def typed_obj = ty_expr (ctx, obj);
          def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });

          def problem () {
            Message.fatal_error (sprintf ("indexer applied to non-indexer type %s",
                                          typed_obj.expr_ty.as_string ()))
          };

          match (Tyutil.top_expand (typed_obj.expr_ty)) {
            | T_array (indexer_over_type) =>
              /* indexers over arrays */
              def typed_index =
              match (typed_args) {
                | [index] => index
                | [] =>
                  Message.fatal_error ("empty indexer applied to indexer type")
                // FIXME: allow for multi-dimensional indexers
                | _ => Message.fatal_error ("multi-dimensional indexers not"
                                            " supported yet")
              };
              expect_type ("indexer type", typed_index,
                           Tyutil.make_tapp ("System.Int32"));
              (E_array_indexer (indexer_over_type, typed_obj, [typed_index]),
               indexer_over_type)

            | T_app (tc, _) =>
              /* user-defined indexers */
              match (tc.GetTyconKind ()) {
                | TK_ExternalNetType (st) =>
                  def ht = Hashtable ();
                  def add_name (el : System.Reflection.MemberInfo) {
                    ht.Set (el.Name, null)
                  };
                  NArray.Iter (st.GetDefaultMembers (), add_name);
                  def check_for_indexer_property (prop_name, _, acc) {
                    match (acc) {
                      | Some => acc
                      | None =>
                        def lst = lookup_member (ctx, expr.loc, typed_obj, 
                                                 prop_name, 
                                                 error_when_not_found = false);
                        match (lst) {
                          | (E_property_ref :: _) as lst =>
                            def args' = List.Map (typed_args, fun (x) {
                              Parm (false, x, "")
                            });
                            def ex = resolve_overloaded_call (ctx, false, lst,
                                                              args');
                            Some ((ex, type_of (ex)))
                          | _ => None ()
                        }
                    }
                  };
                  match (ht.Fold (None (), check_for_indexer_property)) {
                    | Some (r) => r
                    | None => problem ()
                  }
                | _ => problem ()
              }
            | _ => problem ()
          }

        | (PT.E_try_with) as x =>
          def b = ty_expr (ctx, x.body);
          def exn = match (x.exn) {
            | PT.SS_string (e) => e
            | _ =>
            Message.fatal_error ("$ operator used outside quotation <[ ... ]>"
                                 " context")
          };
          def decl = ctx.DefineLocal (exn, D_exn (), bind_ty (x.exn_ty));
          def h = ty_expr (ctx.WithLocal (decl), x.handler);
          match (Tyutil.unify_branches (type_of (h), type_of (b))) {
            | Some (t) =>
              (E_try_with (b, decl, h), t)
            | None =>
              Message.fatal_error (h.loc, "try...with body has type " +
                                          (type_of (b)).as_string () +
                                          " while the handler has type " +
                                          (type_of (h)).as_string ())
          }

        | PT.E_try_finally (e1, e2) =>
          def e1 = ty_expr (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("try...finally handler", e2, T_void ());
          (E_try_finally (e1, e2), type_of (e1))

        | PT.E_typeof (t) =>
          (E_typeof (bind_ty (t)), Tyutil.make_tapp ("System.Type"))

        | PT.E_type_conversion (e, t) =>
          // FIXME shall we check sth here ?
          def t = bind_ty (t);
          (E_type_conversion (ty_expr (ctx, e), t), t)

        | PT.E_type_enforcement (e, t) =>
          def ex = ty_expr (ctx, e);
          def t = bind_ty (t);
          expect_type ("type-enforced expression", ex, t);
          (E_type_enforcement (ex, t), t)

        | PT.E_ref ({ id = n }) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              (x, type_of (x))

            | l =>
              Message.error ("name `" + n + "' is ambiguous:");
              def print (ex) { Message.error ("  " + describe_expression (ex)) };
              List.Iter (l, print);
              throw Recovery ()
          }

        | PT.E_member (_, PT.SS_string ({id = mem_name})) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              (x, type_of (x))

            | l =>
              Message.error ("reference to member `" + mem_name + "' is ambiguous:");
              def print (ex) { Message.error ("  " + describe_expression (ex)) };
              List.Iter (l, print);
              throw Recovery ()
          }

        | PT.E_member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.E_call (fnc, parms) =>
          def fp (p : PT.Parm) {
            def ex = ty_expr (ctx, p.expr);
            Parm (p.is_ref, ex, Macros.UnSString (p.name))
          };
          def parms = List.Map (parms, fp);
          def fncs = make_value_reference (ctx, fnc, fallback = true);
          def ex = resolve_overloaded_call (ctx, orig_ctx.in_tail_position,
                                            fncs, parms);
          match (ex) {
            | E_call (E_property_ref (_, prop), _) when is_indexer_property (prop) =>
              Message.error ("attempt to call an indexer property `" + 
                             prop.GetName () + "'");
            | _ => ()
          };

//          def foldedex = FoldConstants (ex);
//          (foldedex, type_of (ex))
          (ex, type_of (ex))

        | PT.E_assign (e1, e2) =>
          def e1 = ty_expr_with_no_properties_conversion (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("assigned value", e2, type_of (e1));
          def is_lval =
            match (e1) {
              | E_local_ref (d) => d.is_ref
              | E_static_ref (m) =>
                match (m.GetKind ()) {
                  | MK_field (f) =>
                    f.IsMutable () || (ctx.current_fun.name == ".cctor" && 
                                       f.GetDeclaringTycon ().SameAs (ctx.parent_type))
                  | MK_property (p) => p.IsMutable ()
                  | _ => false
                }
              | E_static_property_ref (p) => p.IsMutable ()
              | E_field_ref (E_local_ref ({kind = D_closurised_this_ptr}), _)
                when ctx.in_ctor => true
              | E_field_ref (_, mem) => mem.IsMutable ()
              | E_property_ref (_, p) => p.IsMutable ()
              | E_call (E_property_ref (_, p), _) => p.IsMutable ()
              | E_array_indexer => true
              | _ => false
            };
          unless (is_lval)
            Message.error ("assignment to " + describe_expression (e1) +
                           " (which is read-only)");
            
          convert_setter_property (ctx, e1, e2)

        | PT.E_raise (e) =>
          def ex = ty_expr (ctx, e);
          def exn_ty = Tyutil.make_tapp ("System.Exception");
          expect_type ("raised value", ex, exn_ty);
          (E_raise (ex), Tyvar.free_variable ())

        | PT.E_literal (l) =>
          (E_literal (l), ty_literal (ctx, l))

        | PT.E_this =>
          match (ctx.this_ptr_decl) {
            | Some (d) =>
              ctx.Closurise (d);
              (E_local_ref (d), d.ty)
            | None =>
              Message.error ("`this' used outside method");
              (E_literal (L_null ()), Tyvar.free_variable ())
          }

        | PT.E_sequence ([]) =>
          (E_literal (L_void ()), T_void ())

        | PT.E_sequence (l) =>
          def ex = ty_sequence (orig_ctx, l);
          (ex, type_of (ex))

        | PT.E_tuple (l) =>
          def self (e : PT.Expr) : Expr { ty_expr (ctx, e) };
          def parms = List.Map (l, self);
          (E_tuple (parms), T_prod (List.Map (parms, type_of)))

        | (PT.E_match) as m => ty_match (orig_ctx, m)

        | PT.E_typed_expr (tytree) => (tytree, type_of (tytree))

        | PT.E_quoted (parse_element) =>
          def lifted =
            match (parse_element) {
              | PT.SyntaxExpr (e) => Macros.quoted_expr (ctx, e)
              | PT.SyntaxType (e) => Macros.quoted_type (ctx, e)
              | PT.SyntaxPattern (e) => Macros.quoted_pattern (ctx, e)
              | PT.SyntaxParm (e) => Macros.quoted_param (ctx, e)
              | PT.SyntaxCase (e) => Macros.quoted_case (ctx, e)
              | PT.SyntaxCaseGuard (a, b) => Macros.quoted_case_guard (ctx, (a, b))
              | PT.SyntaxFunDecl (e) => Macros.quoted_fundecl (ctx, e)
              | PT.SyntaxFunParm (e) => Macros.quoted_fparam (ctx, e)
              | PT.SyntaxField (e) => Macros.quoted_field (ctx, e)
              | PT.SyntaxMethod (e) => Macros.quoted_method (ctx, e)
              | PT.SyntaxTType (e) => Macros.quoted_ttype (ctx, e)
              | PT.SyntaxProperty // FIXME kamil
              | PT.SyntaxTTycon
              | PT.SyntaxTMethod
              | PT.SyntaxTField
              | PT.SyntaxTProperty
              | PT.SyntaxTFunParm => 
                Util.ice ("strange syntax element appeared in quotation")
            };
          def b = ty_expr (ctx, lifted);
          (b, type_of (b))

        | PT.E_base =>
          Message.fatal_error ("`base' can be only used to call base class"
                               " constructor")

        | PT.E_spliced | PT.E_spliced_patt | PT.E_spliced_special =>
          Message.fatal_error ("$ macro keyword used in regular expression")

        | PT.E_expr_list =>
          Util.ice ("List of expression parameters out of any construct")

        | PT.E_macrocall  =>
          Util.ice ("Macrocalls should have been expanded already")
      }
    };

    def (ret, expr_ty) =
      try
        Util.locate (expr.loc, do_typing)
      catch { _ : Recovery =>
        (E_literal (L_null ()), Tyvar.free_variable ()) };
        
    //Message.debug (expr.loc, "compilied " + describe_expression (ret) + 
    //                    if (ctx.in_tail_position) " [tp]" else "");

    fixup (ret, expr.loc, expr_ty)
  }

  check_unused_values (ctx : CTX) : void
  {
    def warned = Hashtable (50);
    
    def check_value (v : LocalValue) {
      when (!v.ever_used && v.name[0] != '_' && !warned.Contains (v.id)) {
        Message.warning (v.loc, v.kind_as_string () + " `" + v.name + 
                         "' was never used");
        Message.hint_once (v.loc, "replace name with `_' or prefix it like"
                           " `_foo' to avoid the warning");
        warned.Set (v.id, null)
      }
    };

    def mark_broken (v : LocalValue) {
      match (v.kind) {
        | D_local_fun (h, _) =>
          match (h.closure_vars) {
            | [] => ()
            | _ => 
              // we cannot yet deal with expanding these to loops
              h.usage <- FU_used_as_first_class ()
          }
        | _ => ()
      };
    };

    def closurise (v : LocalValue) {
      def in_clo = v.used_in.Fold (fun (_, h : Fun_header, in_clo) {
        in_clo ||
        match (h.usage) {
          | FU_used_just_once when h.decl.parent_fun.id == ctx.current_fun.id => false
          | _ => true
        }
      }, false);
      when (in_clo) {
        v.in_closure <- true;
        v.parent_fun.closure_vars <- v :: v.parent_fun.closure_vars;
      }
    };
    
    def locals = List.Rev (ctx.current_fun.all_locals);
    ctx.current_fun.all_locals <- null; // GC it
    
    List.Iter (locals, check_value);
    List.Iter (locals, mark_broken);
    List.Iter (locals, closurise);
  }

  ty_function (ctx : CTX, h : Fun_header, b : Fun_body) : Fun_body
  {
    def ctx = ctx.WithCurrentFunction (h).WithInTailPosition (true);
    
    def make_parm_decl (p : Fun_parm) {
      Util.locate (p.loc, fun () {
                            def d = ctx.DefineLocal (p.name, p.color, D_fun_parm (), p.ty);
                            p.decl <- d;
                            d
                         })
    };

    def ctx = ctx.WithLocals (List.Map (h.parms, make_parm_decl));

    match (b) {
      | FB_parsed_expr (e) =>
        def ctx = ctx.WithTEnv (h.tenv);
        def e' = ty_expr (ctx, e);
        if (type_of (e') >:> h.ret_type) ()
        else
          Message.error (e.loc, "function return type was declared to be " +
                                h.ret_type.as_string() + " while it is " +
                                (type_of (e')).as_string ());
        check_unused_values (ctx);
        FB_typed_expr (e')
      | FB_typed_expr => Util.ice ()
      | FB_compiled_expr => Util.ice ()
      | FB_extern => b
      | FB_abstract => b
    }
  }

  ty_function (ctx : CTX, h : Fun_header, b : PT.Expr) : Expr
  {
    match (ty_function (ctx, h, FB_parsed_expr (b))) {
      | FB_typed_expr (e) => e
      | _ => Util.ice ()
    }
  }

  /**
   * Walk through method body typing it.
   *
   * <remarks>
   *   Typing generally involves rewriting from [Parsetree] to [Typedtree]
   *   namespace. Also entry point for expression is changed from
   *   [FB_parsed_expr] to [FB_typed_expr].
   *
   *   During typing we do few things:
   *
   *   <list>
   *     - Infer types and check if they are correct. Store information
   *       about types in resulting [Typedtree.Expr] objects.
   *     - Define (generate [LocalValue] objects) and later resolve local values.
   *     - Rewrite few redundant source language constructs into
   *       unambiguous equivalents from [Typedtree].
   *     - Bind type expressions occurring in source code.
   *     - Mark which values should go into closures.
   *   </list>
   *
   *   This is however all done in parallel to improve efficiency.
   *
   *   Documentation FIXME: overloading resolution, CTX type, more
   *   about closures, binding method implement list.
   * </remarks>
   */
  internal TypeMethod (m : NemerleMethod) : void
  {
    def ti = (m.GetDeclaringTycon () :> Tyinfo);

    def (in_ctor, is_method) =
      match (m.GetFunKind ()) {
        | FK_ctor => (true, true)
        | FK_method | FK_bound_method => (false, true)
        | _ => (false, false)
      };

    // Message.debug ("type " + m.GetName () + if (is_method) " method" else "");

    def ctx = TypingContext 
                  (in_ctor = in_ctor,
                   this_ptr_decl =
                     if (is_method)
                       Some (LocalValue ("_N_this", 0, D_closurised_this_ptr (),
                                         ti.GetMemType (), m.GetHeader ()))
                     else None (),
                   env = ti.env,
                   tenv = m.GetHeader ().tenv,
                   current_fun = m.GetHeader (),
                   locals = NemerleMap (),
                   parent_type = ti,
                   in_tail_position = true);
    match (ctx.this_ptr_decl) {
      | Some (decl) => 
        decl.parent_fun.all_locals <- decl :: decl.parent_fun.all_locals
      | None => ()
    };
    try
      m.fun_body <- ty_function (ctx, m.GetHeader (), m.fun_body)
    catch { _ : Recovery => () }
  }
}

} // end ns
