open Nemerle.Compiler;
open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler.Parsetree {

record Function_decl
  {
    fun_header : Fun_header;
    body : Expr;
  }

record Named_pattern
  {
    name : string;
    pat : Pattern;
  }
  
variant Pattern extends Located =
  [
    | P_underscore
    | P_variable { name : string; }
    | P_tuple { args : list (Pattern); }
    | P_record { args : list (Named_pattern); }
    | P_cons { name : long_id; arg : Pattern; }
  ]
  
record Match_case
  {
    loc : Location;
    pattern : Pattern;
    body : Expr;
  }
  
variant Expr extends Located = 
  [ 
    | E_ref { name : long_id; }
    | E_member { obj : Expr; member : long_id; }
    | E_call { func : Expr; parms : list (Parm); }
    | E_assign { target : Expr; source : Expr; }
    | E_let { is_ref : bool; name : id; val : Expr; body : Expr; }
    | E_letfun { funs : list (Function_decl); body : Expr; }
    | E_lambda { decl : Function_decl; }
    | E_match { expr : Expr; cases : list (Match_case); }
    | E_raise { exn : Expr; }
    | E_if { cond : Expr; e_then : Expr; e_else : Expr; }
    | E_try_with { body : Expr; exn : id; exn_ty : Type; handler : Expr; }
    | E_try_finally { body : Expr; handler : Expr; }
    | E_literal { val : Literal; }
    | E_this
    | E_type_conversion { expr : Expr; ty : Type; }  // (expr :> ty)
    | E_type_enforcement { expr : Expr; ty : Type; } // (expr : ty)
    | E_sequence { body : list (Expr); }
    | E_tuple { args : list (Expr); }
  ]

record Parm
  {
    is_ref : bool;
    expr : Expr;
    name : id;  // "" if no name given
  }

 
} // Nemerle.Compiler

