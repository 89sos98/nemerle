// Copyright (c) 2003-2005 The University of Wroclaw.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. The name of the University may not be used to endorse or promote
//       products derived from this software without specific prior
//       written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
// NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

using Nemerle.Collections;

namespace Nemerle.CSharp
{
    public partial variant STree
    {
	private mutable mod_by_ge : bool;

	private set_mod_by_ge () : void
	{
	    mod_by_ge = true;    
	}

	private mutable labels_inside : list [string];
	private mutable gotos_inside : list [string];

	private add_condition (cond : string, op : string) : STree
	{
	    match (this)
	    {
		| Statement("WHEN",[ when_st , lp , TokS(old_cond) , rp , st ] ) =>
		    Statement("WHEN",[ when_st , lp , TokS(old_cond + " " + op + " " + cond) , rp , st ] )
		    
		| Statement("WHEN",[ when_st , lp , Tok(old_cond) , rp , st ] ) =>
		    Statement("WHEN",[ when_st , lp , TokS(ExtendedToken.getTextOnly(old_cond) + " " + op + " " + cond) , rp , st ] )

		| Statement("DO",[d,block,w,lp,Tok(old_cond),rp,s]) =>
		    Statement("DO",[d,block,w,lp,TokS(ExtendedToken.getTextOnly(old_cond) + " " + op + " " + cond),rp,s])

		| Statement("DO",[d,block,w,lp,TokS(old_cond),rp,s]) =>
		    Statement("DO",[d,block,w,lp,TokS(old_cond + " " + op + " " + cond),rp,s])

		| x => x
	    }
	}

	private _add_and_condition (cond : string) : STree {add_condition (cond , "&&");}
	
	private _add_or_condition (cond : string) : STree {add_condition (cond , "||");}		
	
	public this ()
	{
	    labels_inside = [];
	    gotos_inside = [];

	    mod_by_ge = false;
	}
	
	private add_label (label : string) : void
	{
	    labels_inside = label :: labels_inside
	}

	private add_goto (goto : string) : void
	{
	    gotos_inside = goto :: gotos_inside    
	}
	
	/**
	 *  returns: init_vars * changed_tree * lifted_gotos
	 */
	protected eliminate_gotos (single_label : option [string]) : list [STree] * STree * list [STree]
	{
	    def get_labels_and_gotos (lst , acc1 , acc2 )
	    {
		match(lst)
		{
		    | [] => ( acc1 , acc2 )
		    | Statement( "LABEL" , Tok(id) :: _) :: tail=>
		    	
			get_labels_and_gotos (tail , ExtendedToken.getTextOnly (id) :: acc1 , acc2 )

		    | Statement("WHEN", [ _ , _ , _ , _ , Statement( "GOTO" , [_ , Tok (id), _] ) ] )  :: tail =>
		    
			get_labels_and_gotos (tail , acc1 , ExtendedToken.getTextOnly (id) :: acc2 )
		
		    | _ :: tail=>
		     
			get_labels_and_gotos (tail , acc1, acc2)
		}
	    }

	    def lift_up_gotos ( labels , statements , acc1 , acc2 , acc3)
	    {
		match(statements)
		{
		    | [] => (acc1 , List.Rev(acc2) , acc3)
		    
		    | Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , Statement( "GOTO" , [ Tok(b) , Tok (id), s] ) ] ) as goto_st :: tail=>

			if ( !List.Member (labels , ExtendedToken.getTextOnly (id) ))
			    lift_up_gotos ( labels , tail, acc1 , goto_st :: acc2 , acc3);
			else
			{
			    def ws = ExtendedToken.getWhitespaces (when_tok);
			    
			    def ( vars , block , gotos ) = Statement ("BLOCK" , 
				make_token (ws , "{") :: tail + [make_token(ws , "}")]).eliminate_gotos (None ());
			    
			    def gs = new_goto_symbol ();
			    add_symbol ( ExtendedToken.getTextOnly (id) , gs);
			    def es = TokS (ws + gs + " = true;");
			    
			    def if_st = 
			    if(tail matches [])
				Statement ("WHEN" , [Tok (ExtendedToken (ws, "when")) , lp , cond , rp , es ]);
			    else
				Statement ("IF" , [make_token (ws, "if") , lp , cond , rp , es ,
							   make_token (ws, "else") , block ]);

			    (if_st : STree).set_mod_by_ge ();

			    def when_st = Statement ( "WHEN" , [make_token (ws,"when"), 
							TokS("("), TokS(gs), TokS(")"), Statement( "GOTO" , [ Tok(b) , Tok (id), s] )] );
			   
			    lift_up_gotos ( labels , [] , when_st :: gotos + acc1 , if_st :: acc2 , 
					    make_token(ws , "mutable " + gs + " = false;") :: acc3 + vars)
			}
		    | head :: tail => 

			lift_up_gotos ( labels , tail, acc1 , head :: acc2 , acc3);
		}
	    }	    

	    def search (statements , goto , label , acc ) 
	    {
		match(statements)
		{
		    | [] => (acc , None () , []) 

		    | Statement("WHEN", [ _ , _ , cond , _ , Statement( "GOTO" , [ _ , Tok (id), _] ) ] ) as goto_st :: tail when goto =>
			if (ExtendedToken.getTextOnly (id) == label)
			    (List.Rev (acc) , Some (cond) , tail) //second argument passes condition for do
			else
			    search ( tail , goto , label , goto_st :: acc )
			    
		    | Statement ("LABEL", [Tok(id), _ , _ ] ) as label_st :: tail when !goto =>
			if (ExtendedToken.getTextOnly (id) == label)
			    (List.Rev (acc) , Some (label_st) , tail ) //second argument passes labelled statement
			else
			    search ( tail , goto , label , label_st :: acc )

		    | head :: tail =>
			
			search ( tail , goto , label , head :: acc )
		}
	    }

	    def search_for_label (statement , label , acc) { search (statement , false , label , acc) }
	    def search_for_goto (statement , label , acc) { search (statement , true , label , acc) }

	    // eliminates gotos which are on the same level as corresponding label
	    def eliminate_equal ( statements , acc , label)
	    {
		match(statements)
		{
		    | [] => (List.Rev (acc) , false)

		    // we found goto first, now we are searching for corresponding label 
		    | Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , Statement( "GOTO" , [ _ , Tok (id), _] ) ] ) as goto_st :: tail =>
			def ws = ExtendedToken.getWhitespaces (when_tok);
			def lid = ExtendedToken.getTextOnly (id);
			
			if( lid == label)
			{
			    def (crossed, st , rest ) = search_for_label ( tail , lid , [] );
			    if(Option.IsSome (st))
			    {
				def start =
				match(crossed)
				{
				    | [] => []
				    | _ =>
					def block = Statement ("BLOCK" , make_token(ws, "{") :: crossed + [make_token(ws, "}" )]);
					def new_when = Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , block ] );
					
					(new_when : STree).set_mod_by_ge ();
					[new_when]
				}
			    
				(List.Rev(acc) + start + (Option.UnSome (st) :: rest) , true)
			    }
			    else
				(statements , false)
			}
			else
			    eliminate_equal (tail, goto_st  :: acc , label);
			    
		    // we found label first, now we are searching for corresponding goto
		    | Statement ("LABEL", [Tok(id), _ , _ ] ) as label_st :: tail =>
			def ws = ExtendedToken.getWhitespaces (id);
			def lid = ExtendedToken.getTextOnly (id);
			
			if( lid == label)
			{
			    def (crossed , cond , rest) = search_for_goto ( tail , ExtendedToken.getTextOnly (id) , []);
			    if(Option.IsSome (cond))
			    {
				def block = Statement ("BLOCK" , make_token (ws , "{") :: label_st :: crossed  + [make_token (ws , "}")]);	
				def new_do = Statement("DO",[Tok (ExtendedToken (ws , "do")) , block , 
					Tok ( ExtendedToken (ws , "while")) , TokS("(") , Option.UnSome (cond) , TokS(")") , TokS(";")]);

				(new_do : STree).set_mod_by_ge ();

				(List.Rev(acc) + (new_do :: rest) , true)
			    }
			    else
				(statements, false)
			}
			else
			    eliminate_equal (tail, label_st :: acc , label);

		    | head :: tail =>
			eliminate_equal (tail , head :: acc , label);
		}
		    
	    }

	    def lift_single_goto (statements , label , acc)
	    {
		match (statements)
		{
		    | Statement ("WHEN",[_,_,_,_, Statement( "GOTO" , [ _ , Tok (id), _] ) ] ) as when_st :: tail =>
			if (ExtendedToken.getTextOnly (id) == label)
			    assert (false)
			else
			    lift_single_goto (tail , label , when_st :: acc)

		    | head :: tail =>

			if((head : STree).mod_by_ge && head.jump_inside (Jump.Goto, Some (label)))
			{
			    def ( init_vars , x_el , gotos) = head.eliminate_gotos ( Some (label));			    
			    List.Rev (acc) + init_vars + [x_el] + gotos + tail;
			}
			else
			    lift_single_goto (tail , label , head :: acc)

		    | [] => List.Rev (acc)
		}
	    }

	    def _search_for_nested_label (statements , label , acc1 , acc2)
	    {
		def add_to_acc1 (st)
		{
		    match (acc1)
		    {
			| None => None ()
			| Some (lst) => Some (st :: lst)
		    }
		}
		
		def add_to_acc2 (st)
		{
		    match (acc1)
		    {
			| None => st :: acc2
			| Some (_) => acc2
		    }
		}
		
		match(statements)
		{
		    | [] =>  List.Rev (acc2)

		    | Statement ("LABEL", [Tok(id), _ , _ ] ) as label_st :: tail =>
			assert (! (ExtendedToken.getTextOnly (id) == label));			
			_search_for_nested_label ( tail , label , add_to_acc1 (label_st) , add_to_acc2 (label_st) )
			//FIXME: look into labelled statement
		
		    | Statement ("WHEN",[Tok(when_tok),_, cond ,_, Statement( "GOTO" , [ _ , Tok (_id), _] ) ] ) as when_st :: tail =>
			def ws = ExtendedToken.getWhitespaces (when_tok);
			match (acc1)
			{
			    | None => 
				_search_for_nested_label ( tail , label , Some ([when_st]) , acc2 )
			    | Some (lst) =>
				def block = Statement ("BLOCK" , make_token (ws , "{") :: lst + [make_token (ws , "}")]);	
				def new_do = Statement("DO",[Tok (ExtendedToken (ws , "do")) , block , 
					Tok ( ExtendedToken (ws , "while")) , TokS("(") , cond , TokS(")") , TokS(";")]);
				List.Rev (acc2) + (new_do :: tail)
			}
			
		    | head :: tail =>
			if ((head : STree).label_inside (label))
			{
			    match (acc1)
			    {
				| None => _search_for_nested_label ( tail , label , Some ([head]) , acc2)
				| Some ( Statement ("WHEN", [ Tok(when_tok) ,lp, cond ,rp, _ ] ) :: tail) => 
				    def ws = ExtendedToken.getWhitespaces (when_tok);
				    
				    def block = Statement ("BLOCK" , make_token(ws, "{") :: tail + [make_token(ws, "}" )]);
				    def new_when = Statement("WHEN", [ Tok(when_tok) , lp , cond , rp , block ] );
				    List.Rev (acc2) + ( new_when :: tail)
				| _ => assert (false)
			    }
			}
			else
			    _search_for_nested_label ( tail , label , add_to_acc1 (head) , add_to_acc2 (head) )
		}
	    }

	    def eliminate_not_equal (statements , label)
	    {
		def (_ , cond_goto , _ ) = search_for_goto ( statements , label , []);
		
		def new_statements = 
		if(cond_goto matches None ())
		{
		    lift_single_goto (statements ,label , []);
		}
		else
		    statements; 
		    
		def (_ , cond_label , _ ) = search_for_label ( new_statements , label , []);
		
		match (cond_label)
		{
		    | None => 
			//System.Console.WriteLine (search_for_nested_label (new_statements , label , None () , []));
			new_statements
			// FIXME: we should now look for label being nested somewhere
			// and insert goto into that nested statement
		        // when we equal goto and label run eliminate_equal again
		    | Some (_) =>
			def ( out_statements , c ) = eliminate_equal (new_statements , [] ,label );
			assert(c);
			out_statements
		}    				
	    }

	    // this function eliminates all gotos remaining from lifting up
	    def annihilate_gotos (statements, gotos)
	    {
		match(gotos)
		{
		    | [] => statements
		    | head :: tail =>
			def (statements_annihilated , cond) = eliminate_equal (statements, [] , head);
			if(cond)
			{			    
			    annihilate_gotos(statements_annihilated , tail )
			}
			else
			{			    
			    annihilate_gotos(eliminate_not_equal (statements , head), tail )
			}
		}
	    }

	    match(this)
	    {
		//
		// BLOCK statement
		//
		| Statement ("BLOCK", xs ) => 
		    def (lb , sts , rb ) = cut_off_braces ( xs );
		
		    def end_whitespaces = 
		    match(rb)
		    {
			| Tok (r) => ExtendedToken.getWhitespaces (r);
			| _ => "\n";
		    }
		    
		    def _begin_whitespaces = 
		    match(lb)
		    {
			| Tok (l) => ExtendedToken.getWhitespaces (l);
			| _ => "\n";
		    }

		    mutable all_init_vars = [];

		    def triple_to_list ( x , y , z)
		    {
			all_init_vars = x + all_init_vars;
			[y] + z
		    }
		    
		    mutable sts_eliminated = List.Flatten (List.Map (sts , 
			fun (x) { def (a , b ,c) = x.eliminate_gotos (single_label); triple_to_list (a , b , c) } 
		    ));
		    
		    def (labels, gotos ) = get_labels_and_gotos (sts_eliminated , [] , []);

		    List.Iter ( labels , add_label );
		    List.Iter ( gotos , add_goto );

		    def new_labels = 
		    match(single_label)
		    {
			| None => 
			    List.Filter ( gotos , fun (x) { !List.Member (labels , x) });
			    
			| Some (l) => 
			    [l]
		    }

		    def ( lifted , sts_el , init_vars) = lift_up_gotos ( new_labels , sts_eliminated , [] , [] , []);

		    def equal_statement (st)
		    {
			| Statement ("WHEN" , _ :: rest ) =>			    
			    Statement ("WHEN" , make_token(end_whitespaces, "when") :: rest)

			| Tok (t) =>
			    Tok ( ExtendedToken ( end_whitespaces , ExtendedToken.getTextOnly (t) ))
			
			| x => x
		    }

		    def ( _ , gotos ) = get_labels_and_gotos (sts_el , [] , []);

		    ( List.Map (all_init_vars + init_vars , equal_statement), 
			Statement ("BLOCK" , lb :: annihilate_gotos(sts_el , gotos) + [rb]) , 
			//Statement ("BLOCK" , lb :: sts_el + [rb]) , 
			    List.Map (lifted , equal_statement))
		
		| Statement ("IF" , [ Tok(if_tok) , lp , cond , rp , statement1 , else_tok , statement2 ]) =>
		    
		    def ws = ExtendedToken.getWhitespaces (if_tok);
		    
		    def st1 = 
		    if( statement1 matches Statement ( "WHEN", [ _ , _ , _ , _ , Statement ("GOTO" , _)  ] ) )
		    {
			Statement ("BLOCK" , make_token(ws , "{") :: 
				statement1 :: [ make_token(ws , "}") ] );
		    }
		    else
			statement1;
		    
		    def st2 = 
		    if( statement2 matches Statement ( "WHEN", [ _ , _ , _ , _ , Statement ("GOTO" , _)  ] ) )
		    {
			Statement ("BLOCK" , make_token(ws , "{") :: 
				statement2 :: [ make_token(ws , "}") ] );
		    }
		    else
			statement2;
		    
		    def (init_vars1 , st1_eliminated , gotos1) = st1.eliminate_gotos (single_label);
		    def (init_vars2 , st2_eliminated , gotos2) = st2.eliminate_gotos (single_label);

		    (init_vars1 + init_vars2 , 
			Statement ("IF" , [ Tok(if_tok) , lp , cond , rp , st1_eliminated, else_tok , st2_eliminated ])
			    , gotos2 + gotos1)


		| Statement ("WHEN" , [ when_tok , lp , cond , rp , statement ] ) =>

		    def (init_vars , st_eliminated , gotos) = statement.eliminate_gotos (single_label);

		    (init_vars, 
			Statement ("WHEN" , [ when_tok , lp , cond , rp , st_eliminated ] )
			    , gotos)

		| Statement ("DO",[ d , block , w , lp , TokS(old_cond) , rp , s ]) =>

		    def (init_vars , st_eliminated , gotos) = block.eliminate_gotos (single_label);

		    mutable new_cond = old_cond;

		    def get_labels (_)
		    {
			| Statement ("WHEN" , [ _ , _ , Tok(cond) , _ , _ ] ) =>
			    new_cond = new_cond + " && !" + ExtendedToken.getTextOnly (cond);
			| Statement ("WHEN" , [ _ , _ , TokS(cond) , _ , _ ] ) =>
			    new_cond = new_cond + " && !" + cond;
			| _ => ()
		    }

		    List.Iter ( gotos , get_labels );

		    (init_vars, 
			Statement ("DO",[ d , st_eliminated , w , lp , TokS(new_cond) , rp , s ])
			    , gotos)

		| x => ( [] , x , [])
	    }	    
	}
	
	protected transform_gotos_to_conditionals () : STree
	{
	    match(this)
	    {
		| Statement ("WHEN",[when_,lp,cond,rp,maybe_goto]) as when_st=>
		    if(maybe_goto matches Statement ("GOTO",_))
			when_st
		    else
			Statement ("WHEN",[when_,lp,cond,rp,maybe_goto.transform_gotos_to_conditionals ()])
			
		| Statement ("GOTO", goto :: _ ) as goto_st=>
		    
		    def ws = get_first_whitespace (goto);

		    Statement("WHEN", [ make_token (ws,"when"), TokS(" ("), TokS(" true ") , TokS (")"), goto_st])

		| Statement ( name , children) =>
    
		    Statement (name , List.Map ( children , fun (x) { x.transform_gotos_to_conditionals () } ) )

		| x => x
		    
	    }
	}

	private label_inside (label : string) : bool
	{
	    def loop(xs : list [STree]) : bool
            {
		| head :: tail =>
		    if(head.label_inside (label))
			true
                    else
                        loop(tail)
                | _ => false
            }

	    match(this)
	    {
		| Statement ("LABEL", [Tok(id), _ , _ ] )  =>
		    ExtendedToken.getTextOnly (id) == label

                | Statement("BLOCK",xs) =>  loop(xs);
                | Statement("IF",[_,_,_,_,st1,_,st2]) =>
		    st1.label_inside (label) || st2.label_inside (label)
                    
                | Statement("WHEN",[_,_,_,_,st]) => st.label_inside (label)

		| Statement("SWITCH",[_,_,_,_,Statement("SWITCH_BLOCK",xs)]) =>
			loop(xs)

		| Statement("SWITCH_SECTION",[_,Statement("SWITCH_SECTION_STATEMENTS",xs)]) =>
		    loop(xs)		
		
		| Statement("TRY",_ :: block :: _) 
		| Statement("USING_STATEMENT",[_,_,_,_,block])
		| Statement("LOCK",[_,_,_,_,block])
		| Statement("CHECKED",[_,block]) 
		| Statement("UNCHECKED",[_,block]) =>
		    block.label_inside (label)
		
		| Statement("DO", _ :: block :: _) =>
			block.label_inside (label)
		
                | _ => false
            }	    
	}

	private make_token (ws : string, text : string) : STree
	{
	    STree.Tok (ExtendedToken(ws,text));
	}

	private new_goto_symbol () : string
        {
            new_symbol ("_goto_")
        }

	private add_symbol (label : string , symbol : string) : void
	{
	    def symbols = label_symbols.Get (label);
	    match (symbols)
	    {
		| None =>
		    label_symbols.Add (label , [symbol]);
		| Some  (lst) =>
		    label_symbols.Remove (label);
		    label_symbols.Add (label , symbol :: lst);
	    }

	    System.Console.WriteLine (label_symbols.Get (label));
	}

	internal eliminate_goto () : STree
	{
	    def st = this.transform_gotos_to_conditionals ();
	    def ( init , block , gotos ) =  st.eliminate_gotos (None ());

	    if ( gotos matches _ :: _ )
	    {
		System.Console.WriteLine("gotos to nonexisting labels");
		throw System.Exception ();
	    }
	    else
	    {
		def (lb,sts,rb) = cut_off_braces (block);
		Statement ("BLOCK" , lb :: init + sts + [rb] )	    
	    }
	}

	/* -- PRIVATE FIELDS ---------------------------------------------------- */ 

	private static label_symbols : Nemerle.Collections.Hashtable [string , list [string]] = Nemerle.Collections.Hashtable ();
    }
}

