/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Macros;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Core {

module Operators
{
  variant NumericKind
  {
    | Signed
    | Unsigned
    | Default
  }

  [Record]
  class ArithmeticTypeDescriptor
  {
    public tycon : TypeInfo;
    public kind : NumericKind;
    public one : PT.PExpr;
  }

  arithmetic_types : list [ArithmeticTypeDescriptor];

  op_name (name : string, td : ArithmeticTypeDescriptor, is_checked : bool) : string
  {
    match (td.kind) {
      | NumericKind.Unsigned when is_checked => name + ".u"
      | NumericKind.Signed when is_checked => name + ".s"
      | _ => name + ".f"
    }
  }
  
  this () {
    def f (name, kind, one) { 
      def t = GlobalEnv.LookupInternalType (["System", name]);
      ArithmeticTypeDescriptor (t, kind, one)
    };

    arithmetic_types = [
      f ("Int32", NumericKind.Signed (), <[ 1 ]>),
      f ("Byte", NumericKind.Unsigned (), <[ 1b ]>),
      f ("Single", NumericKind.Default (), null),
      f ("Double", NumericKind.Default (), null),
      f ("Int64", NumericKind.Signed (), <[ 1l ]>),
      f ("Int16", NumericKind.Signed (), <[ 1s ]>),
      f ("SByte", NumericKind.Signed (), <[ 1sb ]>),
      f ("UInt32", NumericKind.Unsigned (), <[ 1u ]>),
      f ("UInt64", NumericKind.Unsigned (), <[ 1lu ]>),
      f ("UInt16", NumericKind.Unsigned (), <[ 1su ]>)
    ];
  }

  internal lookup_overloaded_operator (name : string, parms : list [TExpr])
  : option [PT.PExpr]
  {
    def collect (parm, acc) {
      match (Tyutil.top_expand (Tyexpr.type_of (parm))) {
        | TType.Class (tc, _) =>
          def is_op (m : IMember) {
            match (m.GetKind ()) {
              | MemberKind.Method => m.IsStatic
              | _ => false
            }
          };
          def loop (tc : TypeInfo) {
            // fscking special case, why there is no System.String.op_Addition ?
            def name =
              if (name == "op_Addition" && tc.Equals (InternalType.String_tc))
                "Concat"
              else 
                name;
            match (List.Filter (tc.LookupMember (name), is_op)) {
              | [] =>
                match (tc.SuperClass ()) {
                  | Some (tc') => loop (tc')
                  | None => acc
                }
              | lst => List.Append (lst, acc)
            }
          };
          loop (tc)
        | _ => acc
      }
    };
    def collapse (mem : IMember, acc) {
      def tyname = mem.DeclaringType.FullName;
      match (acc) {
        | Some (tn) when tn == tyname => acc
        | Some (tn) =>
          Message.error (sprintf ("ambiguity resolution between `%s' from types"
                                  " `%s' and `%s'", name, tn, tyname));
          acc
        | None => Some (tyname)
      }
    };
    match (List.FoldLeft (List.FoldLeft (parms, [], collect), None (), collapse)) {
      | Some ("System.String") when name == "op_Addition" =>
        match (parms) {
          | [e1, e2] =>
            Tyexpr.expect_type ("left-hand side of the `+' operator", 
                                e1, InternalType.String);
            Tyexpr.expect_type ("right-hand side of the `+' operator",
                                e2, InternalType.String);
            Some (<[ System.String.Concat ($(e1 : typed), $(e2 : typed)) ]>)
          | _ => assert (false)
        }
      | Some (tn) =>
        def parms = List.Map (parms, fun (e) { 
          <[ $(e : typed) ]> 
        });
        def memberize (l) {
          | [x] => <[ $((x : string) : dyn) ]>
          | x :: xs => <[ $(memberize (xs)).$(x : dyn) ]>
          | _ => Util.ice ("empty")
        };
        def tn = memberize (List.Rev (NString.Split (tn, array ['.'])));
        Some (<[ $tn . $(name : dyn) (.. $parms ) ]>)
      | None => None ()
    }
  }

  try_emit_binary (name : string, arg_tc : TypeInfo, ret_tc : TypeInfo, e1 : TExpr, 
                   e2 : TExpr) : option [PT.PExpr]
  {
    def type_of (e) { Tyutil.top_expand (Tyexpr.type_of (e)) };
    
    match ((type_of (e1), type_of (e2))) {
      | (TType.Class (tc, _), _) when arg_tc.Equals (tc) 
      | (_, TType.Class (tc, _)) when arg_tc.Equals (tc) =>
        def ret_type = TType.Class (ret_tc, []);
        def arg_type = TType.Class (arg_tc, []);
        def op_type = TType.Function (TType.Product ([arg_type, arg_type]), ret_type);
        
        Tyexpr.expect_type (sprintf ("left-hand side of the `%s' operator", name),
                            e1, arg_type);
        Tyexpr.expect_type (sprintf ("right-hand side of the `%s' operator", name),
                            e2, arg_type);
        
        Some (<[ $(TExpr.Call (e1.loc, ret_type, TExpr.OpCode (e1.loc, op_type, name), 
                       [Parm (e1), Parm (e2)]) : typed) ]>)
      | _ => None ()
    }
  }

  type_of (e : TExpr) : TType
  {
    Tyutil.top_expand (Tyexpr.type_of (e))
  }

  internal lookup_one (e : TExpr) : PT.PExpr
  {
    def tc = match (type_of (e)) {
      | TType.Class (t, _) => t
      | _ =>
        Message.fatal_error ("incrementation and decrementation can be done"
                             " only on integral types or one having appropriate"
                             " overload")
    };
    def x = List.Find (arithmetic_types, fun (x : ArithmeticTypeDescriptor) {
      x.tycon.Equals (tc)
    });
    match (x) {
      | Some (atd) when atd.one != null => atd.one
      | _ =>
        Message.fatal_error ("incrementation and decrementation can be done"
                             " only on integral types or one having appropriate"
                             " overload")
    }
  }
  
  internal lookup_binary_compare_operator (ctx : TypingContext, 
                                           name : string, long_name : string, 
                                           e1 : PT.PExpr, e2 : PT.PExpr) : PT.PExpr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def emit (lst : list [ArithmeticTypeDescriptor]) {
      | td :: xs =>
        match (try_emit_binary (op_name (name, td, ctx.IsChecked), td.tycon,
                                InternalType.Boolean_tc, e1, e2)) {
          | Some (ret) => ret
          | None => emit (xs)
        }
      | [] =>
        match (try_emit_binary (name + ".u", InternalType.Char_tc,
                                InternalType.Boolean_tc, e1, e2))
        {
          | Some (ret) => ret
          | None =>
            match (lookup_overloaded_operator (long_name, [e1, e2])) {
              | Some (expr) => expr
              | None =>
                Message.fatal_error ($ "no match for binary operator"
                                       " `$(name)' taking $(type_of (e1)) "
                                       "and $(type_of (e2)) arguments")
            }
        }
    };

    emit (arithmetic_types);
  }

  internal lookup_binary_arithmetic_operator (ctx : TypingContext, 
                                              name : string, long_name : string, 
                                              e1 : PT.PExpr, e2 : PT.PExpr) : PT.PExpr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def try_arith (lst : list [ArithmeticTypeDescriptor]) {
      | td :: xs =>
        match (try_emit_binary (op_name (name, td, ctx.IsChecked),
                                td.tycon, td.tycon, e1, e2)) {
          | Some (ret) => ret
          | None => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error ($ "no match for binary operator"
                                   " `$(name)' taking $(type_of (e1)) "
                                   "and $(type_of (e2)) arguments")
        }
    };
    try_arith (arithmetic_types)
  }

  internal lookup_unary_arithmetic_operator (ctx : TypingContext, 
                                             name : string, long_name : string, 
                                             e1 : PT.PExpr) : PT.PExpr
  {
    def loc = e1.loc;
    def e1 = Tyexpr.ty_expr (ctx, e1);

    def try_arith (lst : list [ArithmeticTypeDescriptor]) {
      | ({ kind = NumericKind.Unsigned }) :: xs when name == "-" => try_arith (xs)
      | td :: xs =>
        def et = type_of (e1);
        match (et) {
          | TType.Class (tc', _) when td.tycon.Equals (tc') =>
            def op_type = <[ ttype: $et -> $et ]>;
            <[ $(TExpr.Call (loc, et, TExpr.OpCode (loc, op_type, "unary."
                                            + op_name (name, td, ctx.IsChecked)), 
                                            [Parm (e1)]) : typed) ]>
          | _ => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1])) {
          | Some (expr) => expr
          | None =>
            Message.fatal_error ($ "no match for unary operator `$(name)'"
                                   " taking $(type_of (e1)) argument")
        }
    };
    try_arith (arithmetic_types)
  }


  has_flags_attribute (t : TypeInfo) : bool
  {
    t.HasAttribute (InternalType.FlagsAttribute_tc)
  }
  
  /**
   * This method wraps around lookup_unary_arithmetic_operator.
   * It adds some extra checks for the ~ operator for enums.
   */
  internal lookup_unary_enum_operator (ctx : TypingContext, 
                                       name : string, long_name : string, 
                                       expr : PT.PExpr) : PT.PExpr
  {
    def typed_expr = Tyexpr.ty_expr (ctx, expr);
    def expr_ty = type_of (typed_expr);

    if (is_enum (expr_ty))
    {
      when (name != "~")
        Message.fatal_error ("invalid unary operator for enum types: `" + name + "'");

      def tc =
        match (expr_ty) {
          | TType.Class (tc, _) => tc
          | _ => Util.ice ("lookup_unary_enum_operator")
        }

      when (!has_flags_attribute (tc) && Options.EnumFlagsWarnings)
        Message.warning ($ "bit-wise negation is only allowed over enum types "
                           "with the System.FlagsAttribute set, "
                           "the enum type $tc is not marked with the System.FlagsAttribute");

      def op_type = <[ ttype: $expr_ty -> $expr_ty ]>;
                                      
      <[ $(TExpr.Call (expr.loc, expr_ty, TExpr.OpCode (expr.loc, op_type, "unary.~.u"),
                                                [Parm (typed_expr)]) : typed) ]>
    }
    else
      lookup_unary_arithmetic_operator (ctx, name, long_name, expr)
  }

  
  internal lookup_shift_operator (ctx : TypingContext, 
                                  name : string, long_name : string, 
                                  e1 : PT.PExpr, e2 : PT.PExpr) : PT.PExpr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def t1 = Tyutil.top_expand (type_of (e1));
    def t2 = Tyutil.top_expand (type_of (e2));

    def try_arith (lst : list [ArithmeticTypeDescriptor]) {
      | ({ kind = NumericKind.Default }) :: xs => try_arith (xs)
      | td :: xs =>
        match (t1) {
          | TType.Class (tc, _) when td.tycon.Equals (tc) =>
            def ret_type = TType.Class (tc, []);
            def op_type = TType.Function (TType.Product ([ret_type, InternalType.Int32]), ret_type);
        
            Tyexpr.expect_type (sprintf ("left-hand side of the `%s' operator", name),
                                e1, ret_type);
            Tyexpr.expect_type (sprintf ("right-hand side of the `%s' operator", name),
                                e2, InternalType.Int32);

            def opcode = TExpr.OpCode (e1.loc, op_type, op_name (name, td, ctx.IsChecked));
            <[ $(TExpr.Call (e1.loc, ret_type, opcode, 
                         [Parm (e1), Parm (e2)]) : typed) ]>
            
          | _ => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (ret) => ret
          | None =>
            Message.fatal_error ($ "no match for the binary operator `$(name)' "
                                   "taking $t1 and $t2 arguments")
        }
    };

    try_arith (arithmetic_types)
  }


  /*
   * Checks if a type inherits from System.Enum
   */
  private is_enum (t : TType) : bool
  {
    match (t) {
      | TType.Class (tc, _) =>
        Option.IsSome (tc.SuperType (InternalType.Enum_tc))
      | _ =>
        false
    }
  }

  
  internal lookup_enum_operator (ctx : TypingContext, 
                                 name : string, long_name : string, 
                                 e1 : PT.PExpr, e2 : PT.PExpr) : PT.PExpr
  {
    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def t1 = type_of (e1);
    def t2 = type_of (e2);

    def try_arith (lst : list [ArithmeticTypeDescriptor]) {
      | ({ kind = NumericKind.Default }) :: xs => try_arith (xs)
      | td :: xs =>
        match (try_emit_binary (op_name (name, td, ctx.IsChecked), td.tycon, td.tycon,
                                e1, e2)) {
          | Some (ret) => ret
          | None => try_arith (xs)
        }
      | [] =>
        match (lookup_overloaded_operator (long_name, [e1, e2])) {
          | Some (ret) => ret
          | None =>
            Message.fatal_error ($ "no match for binary operator"
                                   " `$(name)' taking $t1 and $t2 arguments")
        }
    };

    if (is_enum (t1) || is_enum (t2)) {
      match (Tyutil.unify (t1, t2)) {
        | Some (subst) =>
          Tyvar.global_store (subst);
          def tc =
            match (Tyutil.top_expand (t1)) {
              | TType.Class (tc, _) => tc
              | _ => Util.ice ()
            }

          when (!has_flags_attribute (tc) && Options.EnumFlagsWarnings)
            Message.warning ($ "bit operations are only allowed over enum types "
                               "with the System.FlagsAttribute set, "
                               "the enum type $tc (on sides of a bit `$(name)' "
                               "operator) is not marked with the System.FlagsAttribute");

          
          Option.UnSome (try_emit_binary (name + ".u", tc, tc, e1, e2))
        | None =>
          Message.fatal_error ($ "the enum types $t1 and $t2 (on sides of "
                                 "`$(name)' operator) are not compatible")
      }
    } else
      try_arith (arithmetic_types)
  }
  

  // == or !=
  internal lookup_equality_operator (ctx : TypingContext, 
                                     name : string, long_name : string, 
                                     e1 : PT.PExpr, e2 : PT.PExpr) : PT.PExpr
  {
    DefineCTX (ctx);

    def is_from_null (t) {
      | TType.Variable ({ value = TvValue.FreeFromNull }) => true
      | _ => false
    }

    def ok_for_eq (t) {
      match (Tyutil.top_expand (t)) {
        | TType.Class (tc, _) =>
          tc.Equals (InternalType.Object_tc) ||
          tc.Equals (InternalType.Char_tc) ||
          tc.Equals (InternalType.Boolean_tc) ||
          (tc.GetTydecl () matches TypeDeclaration.Enum) ||
          NumericType.IsNumericType (tc)
        | _ =>
          false
      }
    }
    
    def is_object (t) {
      match (Tyutil.top_expand (t)) {
        | TType.Class (tc, _) =>
          tc.Equals (InternalType.Object_tc)
        | _ =>
          false
      }
    }

    def e1 = Tyexpr.ty_expr (ctx, e1);
    def e2 = Tyexpr.ty_expr (ctx, e2);

    def emit_ceq () {
      def op_type = <[ ttype: object * object -> bool ]>;
      def e1 = <[ ($(e1 : typed) : object) ]>;
      def e2 = <[ ($(e2 : typed) : object) ]>;
      <[ $(TExpr.OpCode (e1.loc, op_type, name) : typed) ($e1, $e2) ]>
    }

    if (is_from_null (type_of (e1)) || is_from_null (type_of (e2)))
      emit_ceq ()
    else
      match (lookup_overloaded_operator (long_name, [e1, e2])) {
        | Some (expr) => expr
        | None =>
          def t1 = type_of (e1);
          def t2 = type_of (e2);

          match (Tyutil.unify (t1, t2)) {
            | Some (subst) =>
              def ret_type = InternalType.Boolean;
              def op_type = <[ ttype: $t1 * $t2 -> bool ]>;
              
              Tyvar.global_store (subst);

              unless (ok_for_eq (t1) && ok_for_eq (t2)) {
                Message.error ($ "the operator `$(name)' is not defined for "
                                 "$t1 and $t2");
                Message.hint_once ("use (x : object) == (y : object) if "
                                   "reference equality is desired");
              }

              <[ $(TExpr.Call (e1.loc, ret_type, TExpr.OpCode (e1.loc, op_type, name), 
                           [Parm (e1), Parm (e2)]) : typed) ]>
            | None when is_object (t1) || is_object (t2) =>
              emit_ceq ()
            | None =>
              Message.error ($ "the types $t1 and $t2 (on sides of"
                               " the `$(name)' operator) are not compatible");
              Message.hint_once ("use (x : object) == (y : object) if "
                                 "reference equality is desired");
              throw Recovery ()
          }
      }
  }

  internal cache_indices (expr : PT.PExpr, idxes : list [PT.PExpr]) 
                       : PT.PExpr * list [PT.PExpr]
  {
    def idx_exprs = List.Map (idxes, fun (_) { 
      <[ $(Macros.NewSymbol () : name) ]> 
    });
    (<[ def (.. $(<[ tmp ]> :: idx_exprs)) = (.. $(expr :: idxes)) ]>,
     idx_exprs)
  }

  [Hygienic]
  internal cache_assign_expr (ctx : TypingContext, e : PT.PExpr)
  : PT.PExpr * PT.PExpr
  {
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        (<[ def tmp = $obj ]>, <[ tmp.$mem ]>)
        
      | <[ $obj . $mem [.. $idxes] ]> when !Macros.IsTypeName (ctx, obj) =>
        def (cache, idx_exprs) = cache_indices (obj, idxes);
        (cache, <[ tmp . $mem [ .. $idx_exprs ] ]>)
        
      | <[ $tab [.. $idxes] ]> =>
        def (cache, idx_exprs) = cache_indices (tab, idxes);
        (cache, <[ tmp [ .. $idx_exprs ] ]>)
        
      | _ => (<[ () ]>, e)
    }
  }

  [Hygienic]
  internal cache_assign_typed_expr (ctx : TypingContext, e : PT.PExpr)
  : PT.PExpr * PT.PExpr * TExpr
  {
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        def obj = Tyexpr.ty_expr (ctx, obj);
        def cache = <[ def tmp = $(obj : typed) ]>;
        def safe = <[ tmp.$mem ]>;
        def ty = Tyexpr.ty_expr (ctx, <[ $cache; $safe ]>); 
        (cache, safe, ty)

      | <[ $obj . $mem [.. $idxes] ]> when !Macros.IsTypeName (ctx, obj) =>
        def obj = Tyexpr.ty_expr (ctx, obj);
        def idxes = List.Map (idxes, fun (e) { Tyexpr.ty_expr (ctx, e) });
        def pt_idxes = List.Map (idxes, fun (e) { <[ $(e : typed) ]> });
        def (cache, idx_exprs) = cache_indices (<[ $(obj : typed) ]>, pt_idxes);
        def safe = <[ tmp . $mem [ .. $idx_exprs ] ]>;
        def ty = Tyexpr.ty_expr (ctx, <[ $cache; $safe ]>); 
        (cache, safe, ty)

      | <[ $tab [..$idxes] ]> =>
        def tab = Tyexpr.ty_expr (ctx, tab);
        def idxes = List.Map (idxes, fun (e) { Tyexpr.ty_expr (ctx, e) });
        def pt_idxes = List.Map (idxes, fun (e) { <[ $(e : typed) ]> });
        def (cache, idx_exprs) = cache_indices (<[ $(tab : typed) ]>, pt_idxes);
        def safe = <[ tmp [ .. $idx_exprs ] ]>;
        def ty = Tyexpr.ty_expr (ctx, <[ $cache; $safe ]>); 
        (cache, safe, ty)

      | <[ $(_ : name) ]> | <[ $_.$_ ]> =>
        def te = Tyexpr.ty_expr (ctx, e);
        (<[ () ]>, e, te)

      | _ => 
        def e = Tyexpr.ty_expr (ctx, e);
        (<[ () ]>, <[ $(e : typed) ]>, e)
    }
  }

  internal event_add_or_remove (ctx : TypingContext, is_add : bool, 
                                e : PT.PExpr, val : PT.PExpr) : PT.PExpr
  {
    def to_delegate (val, ty) {
      def val = Tyexpr.ty_expr (ctx, val);
      match ((Tyutil.top_expand (Tyexpr.type_of (val)),
              Tyutil.top_expand (ty))) {
        | (TType.Function, TType.Class (tc, _)) =>
          <[ $(Util.expr_of_qid (tc.FullName)) ($(val : typed)) ]>
        | _ => 
          <[ $(val : typed) ]>
      }
    };
    
    def not_event (cached, safe, typed) {
      def ty = Tyexpr.type_of (typed);
      if (Tyutil.IsDelegate (ty)) {
          def val = to_delegate (val, ty);
          def ty = PT.PType.Typed (ty);
          if (is_add)
            <[ 
              $cached; 
              $safe = (System.Delegate.Combine (($safe : $ty), ($val : $ty)) :> $ty)
            ]>
          else
            <[ 
              $cached; 
              $safe = (System.Delegate.Remove (($safe : $ty), ($val : $ty)) :> $ty)
            ]>
      } else if (is_add)
        <[ $cached; $safe = $safe + $val ]>
      else
        <[ $cached; $safe = $safe - $val ]>
    };

    def fallback () {
      not_event (Operators.cache_assign_typed_expr (ctx, e))
    };

    def is_event (mem : IMember) {
      match (mem.GetKind ()) {
        | MemberKind.Event => true
        | _ => false
      }
    };
    
    match (e) {
      | <[ $obj.$mem ]> when !Macros.IsTypeName (ctx, obj) =>
        def is_event (im : IMember) {
          match (im.GetKind ()) { 
            | MemberKind.Event => true 
            | _ => false 
          } 
        };
        
        def obj = Tyexpr.ty_expr (ctx, obj);
        def mem_name = mem.GetName ().Id;
        def members = Tyexpr.LookupMembers (ctx, Tyexpr.type_of (obj), mem_name);
        //Message.debug ("lookup in `" + Tyexpr.type_of (obj).as_string () + "' for " + 
        //        mem_name + " res " + members.ToString ());
        if (List.Exists (members, is_event))
          match (members) {
            | [ev] =>
              def meth = 
                if (is_add)
                  (ev :> IEvent).GetAdder ()
                else
                  (ev :> IEvent).GetRemover ();
              def val = to_delegate (val, ev.GetMemType ());
              <[ $(obj : typed) . $(meth.Name : dyn) ($val) ]>

            | _ =>
              Message.fatal_error ("ambigious reference to an event `" 
                                   + mem_name + "'");
          }
        else {
          def cached = <[ def tmp = $(obj : typed) ]>;
          def safe = <[ tmp.$mem ]>;
          def typed = Tyexpr.ty_expr (ctx, <[ $cached; $safe ]>);
          not_event (cached, safe, typed)
        }

      | <[ $obj . $(name : dyn) ]> =>
        match (Util.qidl_of_expr (obj)) {
          | None =>
            fallback ()
          | Some ((tyname, env)) =>
            def env = env.GetEnv (ctx.env);
            match (env.LookupType (tyname)) {
              | Some (tc) =>
                def events = List.Filter (tc.LookupMember (name), is_event);
                match (events) {
                  | [ev] => 
                    def meth = 
                      if (is_add)
                        (ev :> IEvent).GetAdder ()
                      else
                        (ev :> IEvent).GetRemover ();
                    def val = to_delegate (val, ev.GetMemType ());
                    <[ $(Util.expr_of_qid (tc.FullName)) . 
                       $(meth.Name : dyn) ($val) ]>
                  | _ => fallback ()
                }
              | None =>
                // this case should be catched above
                assert (false)
            }
        }

      // FIXME: handling plain identfiers would require local lookups
      //| <[ $(id : name) ]> =>

      | _ => fallback ()
    }
  }
}

  macro @&& (e1, e2) 
  {
    <[ 
      match ($e1) {
        | false => false
        | _ => $e2
      }
    ]>
  }

  macro @|| (e1, e2) 
  {
    <[ 
      match ($e1) {
        | true => true
        | _ => $e2
      }
    ]>
  }

  macro @! (e)
  {
    def tval = Tyexpr.ty_expr (ImplicitCTX (), e);
    match (Operators.lookup_overloaded_operator ("op_LogicalNot", [tval])) {
      | Some (e) => e
      | None =>
        def op_ty = <[ ttype: bool -> bool ]>;
        Tyexpr.expect_type ("negated value", tval, InternalType.Boolean);
        <[ $(TExpr.Call (e.loc, InternalType.Boolean, TExpr.OpCode (e.loc, op_ty, "bool.!"), 
                     [Parm (tval)]) : typed) ]>
    }
  }

  macro @~ (e)
  {
      Operators.lookup_unary_enum_operator (ImplicitCTX (), "~", 
                                            "op_UnaryBitwiseNot", e)
  }

  macro @- (params args : array [expr])
  {
    match (args.Length) {
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (ImplicitCTX (), "-",
                                                    "op_UnaryMinus", args[0])

      | 2 =>
        Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "-",
                                                     "op_Subtraction", args[0],
                                                     args[1])
      | _ => 
        Message.fatal_error ("the `-' operator can only take one or two"
                             " parameters")
    }
  }

  macro @+ (params parms : array [expr]) 
  {
    match (parms.Length) {
      | 2 =>
        Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "+",
                                                     "op_Addition",
                                                     parms[0], parms[1])
      | 1 =>
        Operators.lookup_unary_arithmetic_operator (ImplicitCTX (), "+",
                                                    "op_UnaryPlus", parms[0])
      | _ =>
        Message.fatal_error ("the `+' operator can only take one or two"
                             " parameters")
    }
  }

  macro @* (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "*",
                                                 "op_Multiply", e1, e2)
  }

  macro @/ (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "/",
                                                 "op_Division", e1, e2)
  }

  macro @% (e1, e2) 
  {
    Operators.lookup_binary_arithmetic_operator (ImplicitCTX (), "%",
                                                 "op_Modulus", e1, e2)
  }
  
  macro @< (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), "<",
                                              "op_LessThan", e1, e2)
  }
  
  macro @> (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), ">",
                                              "op_GreaterThan", e1, e2)
  }
  
  macro @<= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), "<=",
                                              "op_LessThanOrEqual", e1, e2)
  }
  
  macro @>= (e1, e2)
  {
    Operators.lookup_binary_compare_operator (ImplicitCTX (), ">=",
                                              "op_GreaterThanOrEqual", e1, e2)
  }
  
  macro @%| (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "|", "op_BitwiseOr", e1, e2)
  }
  
  macro @%& (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "&", "op_BitwiseAnd", e1, e2)
  }
  
  macro @%^ (e1, e2)
  {
    Operators.lookup_enum_operator (ImplicitCTX (), "^", "op_ExclusiveOr",
                                    e1, e2)
  }

  macro @%|| (e1, e2)
  {
    def mask = 
      Operators.lookup_enum_operator (ImplicitCTX (), "|", "op_BitwiseOr", e1, e2);
    <[ ($mask :> int) != 0 ]>
  }
  
  macro @%&& (e1, e2)
  {
    def mask =     
      Operators.lookup_enum_operator (ImplicitCTX (), "&", "op_BitwiseAnd", e1, e2);
    <[ ($mask :> int) != 0 ]>    
  }
  
  macro @%^^ (e1, e2)
  {
    def mask =     
      Operators.lookup_enum_operator (ImplicitCTX (), "^", "op_ExclusiveOr",
                                      e1, e2);
    <[ ($mask :> int) != 0 ]>                                    
  }
  
  macro @<< (e1, e2)
  {
    Operators.lookup_shift_operator (ImplicitCTX (), "<<", "op_LeftShift",
                                     e1, e2)
  }
  
  macro @>> (e1, e2)
  {
    Operators.lookup_shift_operator (ImplicitCTX (), ">>", "op_RightShift",
                                     e1, e2)
  }
  
  macro @== (e1, e2)
  {
    Operators.lookup_equality_operator (ImplicitCTX (), "==", "op_Equality",
                                        e1, e2)
  }
  
  macro @!= (e1, e2)
  {
    Operators.lookup_equality_operator (ImplicitCTX (), "!=", "op_Inequality",
                                        e1, e2)
  }

  macro @++ (e) {
    def (cached, safe, e) = Operators.cache_assign_typed_expr (ImplicitCTX (), e);
    match (Operators.lookup_overloaded_operator ("op_Increment", [e])) {
      | Some (e) => <[ $cached; $e ]>
      | None =>
        def one = Operators.lookup_one (e);
        <[ $cached; $safe = $safe + $one ]>        
    }
  }

  macro @-- (e) {
    def (cached, safe, e) = Operators.cache_assign_typed_expr (ImplicitCTX (), e);
    match (Operators.lookup_overloaded_operator ("op_Decrement", [e])) {
      | Some (e) => <[ $cached; $e ]>
      | None =>
        def one = Operators.lookup_one (e);
        <[ $cached; $safe = $safe - $one ]>        
    }
  }

  macro @+= (e, val) {
    Operators.event_add_or_remove (ImplicitCTX (), true, e, val)
  }

  macro @-= (e, val) {
    Operators.event_add_or_remove (ImplicitCTX (), false, e, val)
  }

  macro @*= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe * $val ]>
  }

  macro @/= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe / $val ]>
  }

  macro @<<= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe << $val ]>
  }

  macro @>>= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe >> $val ]>
  }

  macro @%= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe % $val ]>
  }

  macro @|= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe %| $val ]>
  }

  macro @&= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe %& $val ]>
  }

  macro @^= (e, val) {
    def (cached, safe) = Operators.cache_assign_expr (ImplicitCTX (), e);
    <[ $cached; $safe = $safe %^ $val ]>
  }
  
  macro @<-> (e1, e2)
  {
    def (cached1, safe1) = Operators.cache_assign_expr (ImplicitCTX (), e1);
    def (cached2, safe2) = Operators.cache_assign_expr (ImplicitCTX (), e2);    
    <[
      $cached1;
      $cached2;
      def tmp = $safe1;
      $safe1 = $safe2;
      $safe2 = tmp;
    ]>
  }
}
