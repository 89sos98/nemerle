#if READLINE
using Mono.ReadLine;
#endif
using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility.NString;
using SC = System.Console;
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions.Regex;
using Interp = Nemerle.Evaluation.Interpreter.Internals;
  
namespace Nemerle.Evaluation.Interpreter
{  
  module MainClass
  {
    public Main (args : array [string]) : void {
      def fromfile (filename) {
        def sr = File.OpenText (filename);
        def loop (acc) {
          def l = sr.ReadLine ();
          if (l != null) 
            loop (acc + "\n" + l)
          else
            acc
        }

        def res = loop ("");
        sr.Close ();
        res
      } 

       //FIXME: Handle speacial situations
      def initialcode = if (args.Length == 2)
                          match ((args [0], args [1])) {
                            | ("-f", filename)
                            | (filename, "-f") => fromfile (filename)
                            | _ => "" 
                          }
                        else 
                          try {
                            fromfile (Environment.GetFolderPath
                                     (Environment.SpecialFolder.Personal) +
                                     "/.nemerlish_profile");
                          }
                          catch {
                            | _ is FileNotFoundException => ""
                            | _ => ""
                          }
      def print_welcome () : void {
        SC.WriteLine ("Welcome to Nemerle interpreter.\n");
        SC.WriteLine ("Please enter expressions appended with \";;\".");
        SC.WriteLine ("To add open namespaces, reference libraries or set "
                      "various preferences, use");
        SC.WriteLine ("properties from the Interp namespace. Their list is "
                      "available via \"Interp.Help;;\"\n");
      }
      print_welcome ();
  
      def e = Nemerle.Evaluation.Evaluator ();
      def printev (c) {
        try { 
          def (nmnvts) = e.Eval (Interp.RefParsed, 
                                 Interp.UsingParsed, c);
          Iter (nmnvts, fun (x) {
            def (newvar, mut, name, val, ty) = x;
            when (newvar) 
              match ((mut, val, ty)) {
                | (false, null, _) =>
                  SC.WriteLine ($"def $name : $ty")
                | (_, null, _) =>
                  SC.WriteLine ($"mutable $name : $ty")
                | (_, _, <[ $_ -> $_ ]>) =>
                  SC.WriteLine ($"def $name : $ty")
                | (false, _, _) => 
                  SC.WriteLine ($"def $name = $val : $ty")
                | _ => 
                  SC.WriteLine ($"mutable $name = $val : $ty")
            }
          })
        } 
        catch {
          | e is Exception =>
            unless (Nemerle.Compiler.Message.SeenError) {
              SC.WriteLine (e.Message + e.StackTrace);
              SC.WriteLine (e.ToString ())
            }
        } 
      }

#if READLINE
      def histfile = Environment.GetFolderPath 
                     (Environment.SpecialFolder.Personal) + 
                     "/.nemerlish_history"; 
#endif

#if READLINE
      def rl = GnuReadLine ();
      def usehist = HistoryFile.RecreateHistory (100, rl, histfile);
#endif

      def matching (code, line) {
        match (line) {
          | null => ()
          | _ => 
#if READLINE
            rl.AddHistory (line);
            when (usehist)
              HistoryFile.AddHistory (histfile, line);
#endif
            regexp match (line) {
              | @"^\s*$" => 
#if READLINE
                matching (code, rl.ReadLine (Interp.Prompt));
#else
                SC.Write (Interp.Prompt);
                matching (code, SC.ReadLine ())
#endif
              | _ =>  { 
                def l = line.TrimEnd ();
                if (l.EndsWith (";;")) {
                  def m = code + l.TrimEnd (array [';',' ','\t']);
                  regexp match (m) {
                    | @"(?<beg>.*([;}]\s*|^\s*))using\s+(?<use>[a-zA-Z0-9]+((\.[a-zA-Z0-9]+)*(\s*=\s*[a-zA-Z0-9]+)*)*)[\s;]*(?<end>.*)$" => 
                      if (Interp.Using != "") 
                        Interp.Using = use + ", " + Interp.Using
                      else 
                        Interp.Using = use;
                      def c = beg + end;
                      when (c != "")
                        printev (c)
                    | @"^\s*!(?<input>.*)$" => 
                      def p = Diagnostics.Process ();
                      match (input) {
                        | "" => 
                          if (Environment.
                              GetEnvironmentVariable ("SHELL") != "")
                            p.StartInfo.FileName = "$SHELL"
                          else
                            p.StartInfo.FileName = "cmd.exe"
                        | _ => p.StartInfo.FileName = input
                      }
                      p.StartInfo.UseShellExecute = true;
                      _ = p.Start();    
                      p.WaitForExit()
                    | _ => printev (m)
                  }
                  Interp.Prompt = Interp.PS1;
#if READLINE
                matching ("", rl.ReadLine (Interp.Prompt));
#else
                SC.Write (Interp.Prompt);
                matching ("", SC.ReadLine ())
#endif
                }
                else { 
                  Interp.Prompt = Interp.PS2;
#if READLINE
                  matching (code + line + " ", rl.ReadLine (Interp.Prompt));
#else
                  SC.Write (Interp.Prompt);
                  matching (code + line + " ", SC.ReadLine ())
#endif
                }
              }
            }
        }
      }

      //FIXME: this is a temporary workaround, to be removed later
      Interp.Ref = "";
      Interp.Using = "";
      
      if (initialcode != "") {
        SC.WriteLine ("Please wait while evaluating the config file..");
        matching (initialcode, ";;")
      } 
      else
#if READLINE
        matching ("", rl.ReadLine (Interp.Prompt))
#else
        SC.Write (Interp.Prompt);
        matching ("", SC.ReadLine ())
#endif
    }
  }

#if READLINE
  module HistoryFile {
    public AddHistory (filename: string, line : string) : void {
      try {
        def sw = File.AppendText (filename);
        sw.WriteLine (line);
        sw.Close ();
      } 
      catch {
        | e => SC.WriteLine (e.Message)
      }
    }

    public RecreateHistory (ln : int, rl : GnuReadLine, filename : string) 
    : bool {
      try {
        def sr = File.OpenText (filename);
        def loop (i, prev) {
          def l = sr.ReadLine ();
          when (l != null && i < ln) {
            when (l != prev) 
              rl.AddHistory (l);
            loop (i + 1, l)
          }
        }

        loop (0, "");
        sr.Close ();
        true
      } 
      catch {
        | _ is FileNotFoundException => _ = AddHistory (filename, ""); true
        | e => SC.WriteLine (e.Message); false
      }
    }
  }
#endif
} 
