using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;
using Nemerle.Imperative;

using LRPEGCC.GrammarCreator;

namespace LRPEGCC
{
  macro Grammar (_rules : Token)
  syntax ("grammar", _rules)
  {
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
      | e is GrammarException =>
        def loc = if(e.Location != Location.Default) e.Location else tb.Location;
        Message.Error(loc,  e.Message);
      | e is Exception =>
        Message.Error(tb.Location,  $"Exception $e");
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      def (parsedGrammar, grammar) = CreateGrammar(typer, tb, startRule, rules);
        
      def compiler = RuleCompiler(typer);
      
      mutable str = "";
      
      def tyParam = 
        match (grammar.GetRule(grammar.StartRuleName))
        {
          | Rule.Capture(argType = RuleType.NType(ty)) => ty
          | _ => 
            Message.Error(tb.Location,  "Start rule must be a capture rule");
            <[ object ]>
        };
        
      
      foreach (name in parsedGrammar.Names)
        MakeGotoInfos(name, parsedGrammar, tb, typer);

      foreach (name in grammar.Names)
      {
        def rule = grammar.GetRule(name);
        rule.UpdateIndecis();

        CheckRuleMethodHandler(name, grammar, tb, typer);
        
        def body          = if (typer.Manager.IsIntelliSenseMode) <[ _ = pos; _ = result; _ = text ]>
                            else compiler.CompileRule(rule);
        
        def resultType : PExpr = // Make type parametr name
          match (rule)
          {
            | Rule.CaptureNamedTerminalSymbol            => <[ Nemerle.Peg.NToken ]>
            | Rule.Capture(argType = RuleType.NType(ty)) => <[ Nemerle.Peg.VToken[$ty] ]>
            | Rule.Capture(argType = argType) as c => 
              Message.Error($"Wrong return type ($argType) in '$(c.name)' rule");
              <[ Nemerle.Peg.NToken ]>
            | _                                          =>
              Message.Error($"Top level rule must be Capture. ($(rule.GetType().Name) $rule)");
              <[ Nemerle.Peg.NToken ]>
          };
        
        def method = <[decl:
          private $(compiler.DecorateRuleName(name.Id) : dyn)(pos : int, result : ref $resultType, text : string) : int
          {
            mutable c : char;
            _ = c; // eliminate wornint "a local value c was never used"
            $body;
          }
        ]>;
        _ = tb.DefineWithSource(method);
        str = str + method.ToString() + "\n" + body.ToString() + "\n\n";
        
        //create parse method for single capture rule
        unless (name.Equals(grammar.StartRuleName))
        {
          match (rule)
          {
            | Rule.Capture  as r => CreateSimpleParseMethod(r, compiler, tb);
            | _                  => ();
          }
        }
      }

      CreateStartParseMethods(grammar.StartRuleName.Id, tyParam, compiler, tb);
      
      tb.Define(<[decl:
        public override ToString() : string
        {
          $(str : string);
        }
      ]>);

      tb.Define(<[decl:
        private mutable _maxRollbackPos : int;
      ]>);

      tb.Define(<[decl:
        public MaxRollbackPos : int
        {
          get { _maxRollbackPos }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        private SetMaxRollbackPos(pos : int) : void
        {
          when (pos > _maxRollbackPos)
          {
            _maxRollbackPos = pos;
          }
        }
      ]>);
    }

    private CreateStartParseMethods(startRuleName : string, tyParam : PExpr, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      tb.Define(<[decl: mutable _parsingSource : Nemerle.Peg.SourceSnapshot; ]>);
      tb.Define(<[decl:
        public ParsingSource : Nemerle.Peg.SourceSnapshot
        {
          get { _parsingSource }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse(text : string) : int * $tyParam
        {
          TryParse(Nemerle.Peg.SourceSnapshot(text))
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public TryParse([Nemerle.Assertions.NotNull] source : Nemerle.Peg.SourceSnapshot) : int * $tyParam
        {
          _parsingSource = source;

          mutable result : Nemerle.Peg.VToken[$tyParam];
          def pos = $(compiler.DecorateRuleName(startRuleName) : dyn)(0, ref result, _parsingSource.Text);

          (pos, result.Value)
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public Parse(text : string) : option[$tyParam]
        {
          def (pos, res) = TryParse(text);
          
          if (pos < 0) None() else Some(res)
        }
      ]>);
      _ = tb.DefineWithSource(<[decl:
        public Parse(source : Nemerle.Peg.SourceSnapshot) : option[$tyParam]
        {
          def (pos, res) = TryParse(source);
          
          if (pos < 0) None() else Some(res)
        }
      ]>);
    }

    private static GetGotoMap(tb : TypeBuilder) : Hashtable[Location, Location]
    {
      mutable gotoMap = tb.UserData["GoToInfoMap"] :> Hashtable[Location, Location];
      
      when (gotoMap == null)
      {
        gotoMap = Hashtable();
        tb.UserData["GoToInfoMap"] = gotoMap;
      }
      gotoMap
    }
    
    private MakeGotoInfos(ruleName : RuleRef, grammar : Grammar, tb : TypeBuilder, typer : Typer) : void
    {
      def rule = grammar.GetRule(ruleName);
      def gotoMap = GetGotoMap(tb);
      def getRuleLocation(ruleRef : RuleRef) : Location
      {
        match (grammar.GetRule(ruleRef))
        {
          | Rule.Capture              (name = name)
          | CaptureNamedTerminalSymbol(name = name)
          | ExtensionPoint            (name = name) => name.Location
          | _                                       => Location.Default
        }
      }
      def makeGotoRuleDef(r : Rule) : void
      {
        | Choice(rules)                       => foreach (r in rules) makeGotoRuleDef(r)
        | Sequence(rules)                     => foreach (r in rules) makeGotoRuleDef(r)
        | Call(name)                          => gotoMap[name.Location] = getRuleLocation(name)
        | RepeatMin(_, rule)                  => makeGotoRuleDef(rule)
        | RepeatMinMax(_, _, rule)            => makeGotoRuleDef(rule)
        | Chars                               => ()
        | Not(rule)                           => makeGotoRuleDef(rule)
        | And(rule)                           => makeGotoRuleDef(rule)
        | Capture(name, _, _, _)              => gotoMap[name.Location] = getRuleLocation(name)
        | CaptureNamedTerminalSymbol(name, _) => gotoMap[name.Location] = getRuleLocation(name)
        | ExtensionPoint                      => ()
      }
      
      when (typer.Manager.IsIntelliSenseMode)
        match (rule)
        { // skip top capture...
          | Capture(_, _, _, rule)              => makeGotoRuleDef(rule);
          | CaptureNamedTerminalSymbol(_, rule) => makeGotoRuleDef(rule);
          | _                                   => makeGotoRuleDef(rule);
        }
    }

    private CheckRuleMethodHandler(ruleName : RuleRef, grammar : Grammar, tb : TypeBuilder, typer : Typer) : void
    {
      def gotoMap = GetGotoMap(tb);
      def rule = grammar.GetRule(ruleName);
      def mems = tb.GetParsedMembers(true).Filter(m => m.Name == ruleName.Id);
      
      match (rule)
      {   // Capture with defined type. User must define handler for it!
        | Rule.Capture(argType = RuleType.NType(ty), rule = rule, name = name) => 
          def tTy = typer.BindFixedType(ty);
          def methods = mems.MapFiltered(_ is ClassMember.Function, _ :> ClassMember.Function);
          
          def isNotPredicate(rule : Rule) : bool
          {
            | Rule.And | Rule.Not => false
            | _ => true
          }
          def unpacParams(rule : Rule) : list[Rule]
          {
            | Rule.Sequence(rules) => rules.Filter(isNotPredicate)
            | Rule.And | Rule.Not => []
            | _ => [rule]
          }
          def nTokTy = FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Peg.NToken", 0), []);
          def vTokTc = typer.Manager.LookupTypeInfo("Nemerle.Peg.VToken", 1);
          def ruleToType(rule : Rule) : FixedType
          {
            | Call(name)                                =>
              def subRule = grammar.GetRule(name);
              match (subRule)
              {
                | Rule.Capture(argType = RuleType.NType(ty)) =>
                  def tTy = typer.BindFixedType(ty);
                  FixedType.Class(vTokTc, [tTy])
                  
                | _ => nTokTy
              }

            | Choice(rule :: _)          => ruleToType(rule)
            | Choice(_)                  => assert(false)
            | Sequence(rules)            => 
              def types = rules.Filter(isNotPredicate).Map(x => ruleToType(x) : TypeVar);
              match (types)
              {
                | [ty] => ty.Fix()
                | []   => FixedType.Void()
                | _    => FixedType.Tuple(types)
              }
              
            | RepeatMin(0, rule)         => makeLoopTy(rule) // rule*
            | RepeatMin(1, rule)         => makeLoopTy(rule) // rule+
            | RepeatMin(_, rule)         => makeLoopTy(rule)
            | RepeatMinMax(0, 1, rule)   => FixedType.Class(typer.Manager.LookupTypeInfo("Nemerle.Core.option", 1), [ruleToType(rule)]) // rule?
            | RepeatMinMax(_, _, rule)   => makeLoopTy(rule)
            | Chars                      => nTokTy
            | Not(rule)                  => ruleToType(rule)
            | And(rule)                  => ruleToType(rule)
            | Capture(_, _, _, rule)     => ruleToType(rule)
            | CaptureNamedTerminalSymbol => nTokTy
            | ExtensionPoint             => assert(false)
          }
          and makeLoopTy(rule)
          {
            FixedType.Class(typer.Manager.LookupTypeInfo("System.Collections.Generic.List", 1), [ruleToType(rule)])
          }
          def errorMsg(ruleName, types, tTy)
          {
            //assert2(false);
            $<#You need define method-handler for "$ruleName" rule with signature: $ruleName(_ : ..$(types; ", _ : ")) : $tTy#>
          }
          def topRules = unpacParams(rule);
          def types    = topRules.Filter(isNotPredicate).Map(ruleToType);

          match (methods)
          {
            | [m] => 
              when (typer.Manager.IsIntelliSenseMode)
              {
                gotoMap[name.Location]  = m.NameLocation;
                gotoMap[m.NameLocation] = name.Location;
              }

              def parms = m.header.Parameters;
              if (parms.Length == types.Length)
              {
                foreach ((need, p) in types.ZipLazy(parms))
                {
                  def real = typer.BindFixedType(p.Type);
                  
                  unless (need.TryUnify(real))
                  {
                    //assert2(false);
                    Message.Error(p.Location, $<#The parameter "$(p.Name)" has wrong type $real (need type $need).#>);
                    Message.Error(p.Location, errorMsg(ruleName, types, tTy));
                    break;
                  }
                }
              }
              else
                Message.Error(m.Location, $<#The method-handler of rule "$ruleName" must have $(types.Length) parameters. $(errorMsg(ruleName, types, tTy))#>)
              
            | m :: _ => Message.Error(m.Location, "Overloading not supported for rule method-handler");
            | []     => Message.Error(ty.Location, errorMsg(ruleName, types, tTy));
          }
          
        | _ => ()
      }
    }

    private CreateSimpleParseMethod(rule : Rule.Capture, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      def ruleName = rule.name;
      def methodName = "ParseRule_" + ruleName.Id;
      
      match(rule.argType)
      {
        | RuleType.NType(ty)  =>      
          def parseMethod1 = <[decl:
            public $(methodName : dyn)(startPos : int, text : string) : option[$ty]
            {
              mutable result : Nemerle.Peg.VToken[$ty];
              
              def pos = $(compiler.DecorateRuleName(ruleName.Id) : dyn)(startPos, ref result, text);
              
              if (pos < 0) 
                None() 
              else 
                Some(result.Value)
            }
          ]>;
          def parseMethod2 = <[decl:
            public $(methodName : dyn)(text : string) : option[$ty]
            {
              $(methodName : dyn)(0, text)
            }
          ]>;
        
          _ = tb.DefineWithSource(parseMethod1);
          _ = tb.DefineWithSource(parseMethod2);
          
        | _                   => assert(false);
      };
    }
  }
}
