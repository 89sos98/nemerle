(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Util;

namespace Nemerle.Compiler {

  class ICE extends System.Exception
    {
      msg : string;
      this (m : string) = this.msg <- m;
    }

  class Recovery extends System.Exception
    {
      this () {}
    }

  class Util 
    {
      static ref current_id : int;
      static next_id () : int {
        current_id <- current_id + 1;
        current_id
      }

      static 'a ice (msg : string) : 'a = raise ICE(msg);
      static 'a ice () : 'a = raise ICE("(see backtrace)");

      static 'a locate (l : Location, f : void -> 'a) : 'a
        {
          if l == null then f()
          else {
            Location_stack.push(l);
            try f() finally Location_stack.pop()
          }
        }

      // of course this is broken and can be better
      static concat_strings (sep : string, l : list (string)) : string =
        match l with [
          | Cons (x, Nil) => x
          | Cons (x, xs) => x + sep + concat_strings (sep, xs)
          | Nil => ""
        ];
      
      static is_new (d : Class_member) : bool =
        letfun is_mod (m : Modifier) : bool =
          match m with [ Mod_new => true | _ => false ]
        in List.exists (is_mod, d.modifiers);
        
      static is_private (d : Class_member) : bool =
        letfun is_mod (m : Modifier) : bool =
          match m with [ Mod_private => true | _ => false ]
        in List.exists (is_mod, d.modifiers);

      static is_protected (d : Class_member) : bool =
        letfun is_mod (m : Modifier) : bool =
          match m with [ Mod_protected => true | _ => false ]
        in List.exists (is_mod, d.modifiers);
      
      static is_public (d : Class_member) : bool =
        if is_private (d) then false
        else if is_protected (d) then false
        else true;

      static 'a unsome (x : option ('a)) : 'a =
        match x with [
          | Some (x) => x
          | None => ice ("unsome")
        ];
    }
  
  class Message 
    {
      static ref error_cnt : int;
      static ref warning_cnt : int;

      static location_to_string (l : Location) : string =
        if l == null then
          "(no location)"
        else
          l.file + ":" + string_of_int(l.line) + ":" + 
          string_of_int(l.column);

      static report (l : Location, m : string) : void =
        let l' =
          if l == null then Location_stack.top()
          else l
        in print_endline (Message.location_to_string(l') + ": " + m);

      static error (l : Location, m : string) : void {
        Message.error_cnt <- Message.error_cnt + 1;
        Message.report (l, "error: " + m);
      }
        
      static error (m : string) : void = Message.error (null, m);

      static warning (l : Location, m : string) : void {
        Message.warning_cnt <- Message.warning_cnt + 1;
        Message.report (l, "warning: " + m);
      }
        
      static warning (m : string) : void = Message.warning (null, m);

      static debug (l : Location, m : string) : void {
        Message.report (l, "debug: " + m);
      }
        
      static debug (m : string) : void = Message.debug (null, m);

      static 'a fatal_error (l : Location, m : string) : 'a {
        Message.error(l, m);
        raise Recovery()
      }
      
      static 'a fatal_error (m : string) : 'a = Message.fatal_error (null, m);

      static 'a exit (ret : int) : 'a = extern "System.Environment.Exit";

      static maybe_bailout (fscked_up : bool) : void =
        if Message.error_cnt != 0 then {
          if fscked_up then
            print_endline ("confused by earlier errors bailing out")
          else ();
          Message.exit (1)
        } else ();
        
      static maybe_bailout () : void = Message.maybe_bailout (false);
    }

    class Location_stack
      {
        static ref s : list (Location);
        
        static push (l : Location) : void =
          if l == null then ice() else
          Location_stack.s <- Cons(l, Location_stack.s);

        static pop () : void =
          match Location_stack.s with [
            | Nil => Util.ice()
            | Cons(_, t) => Location_stack.s <- t
          ];

        static top () : Location =
          match Location_stack.s with [
            | Nil => Location("", 0, 0)
            | Cons(h, _) => h
          ];

        static this () { Location_stack.s <- Nil(); }
      }
  
}
