(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Macros {

  (** Interface, which will be implemented by class encapsulating macro
      function. It will allow dynamic execution of macro by compiler
      itself
   *)
  interface I_Macro {
    RunExprToExpr (tr : Expr) : Expr;
  } 

  (** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => <[ Nil () ]>
        | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
      }
    }

  (** create syntax tree for constructing given string and int *)
  quoted_string (st : string) : Expr
    { E_literal (L_string (st)); }

  quoted_int (i : int) : Expr
    { E_literal (L_int (i)) }

  (** tree of string literal, describing constant of given bool value *)
  quoted_bool (va : bool) : Expr
    { E_literal (L_bool (va)) }

  quoted_literal (lit : Literal) : Expr
    {
      match (lit) {
        | L_void => <[ Nemerle.Compiler.L_void ]>

    	| L_null => <[ Nemerle.Compiler.L_null ]>

    	| L_int (val) =>
          <[ Nemerle.Compiler.L_int ($(quoted_int (val))) ]>

    	| L_string (val) =>
          <[ Nemerle.Compiler.L_string ($(quoted_string (val))) ]>

    	| L_float (val) =>
	  <[ Nemerle.Compiler.L_float ($(E_literal (L_float (val)))) ]>

    	| L_char (val) =>
	  <[ Nemerle.Compiler.L_char ($(E_literal (L_char (val)))) ]>

    	| L_bool (val) =>
  	  <[ Nemerle.Compiler.L_bool ($(quoted_bool (val))) ]>
      }	
    }

  quoted_location (loc : Location) : Expr
    {
      <[ Nemerle.Compiler.Location ($(quoted_string (loc.file)), 
                                    $(quoted_int (loc.line)),
 	                            $(quoted_int (loc.column))) ]>
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  public quoted_type (t : Type) : Expr
  {
    match (t) {
      | T_app (tycon, args) =>
        <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_string (tycon)), 
                                             $(make_quoted_list (quoted_type, args))) ]>

      | T_var (name) => 
        <[ Nemerle.Compiler.Parsetree.T_var ($(quoted_string (name))) ]>
        
      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ty))) ]>
	
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ty))) ]>
	
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (from)), 
                                             $(quoted_type (to))) ]>
	
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Parsetree.T_void ]>
	
      | T_prod (args) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quoted_type, args))) ]>

      | <[ type: array ($ty) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_array ($(quoted_type (ty))) ]>

      | T_unquoted (e) => e
    }	
  }

  public quoted_expr (expr : Expr) : Expr 
    {
      def quoted_funheader ( h : Fun_header ) : Expr
        {
          def quoted_param (p : Fun_parm) : Expr
            {
    	      <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_location (p.loc)),
                                                      $(quoted_string (p.name)),
	                                              $(quoted_type (p.ty))) ]>
  	    };
    
          <[ Nemerle.Compiler.Parsetree.Fun_header ($(quoted_location (h.loc)),
                                                    $(quoted_string (h.name)),
	    	      				    $(quoted_type (h.ret_type)),
  		      				    $(make_quoted_list (quoted_param, h.parms))) ]>
        };
    
      def quoted_fundecl (d : Function_decl) : Expr
        {
  	  <[ Nemerle.Compiler.Parsetree.Function_decl ($(quoted_funheader (d.header)),
 	                                               $(quoted_expr (d.body))) ]>
	};

      match (expr) {
        | E_ref (id) =>
	  <[ Nemerle.Compiler.Parsetree.E_ref ($(quoted_string (id))) ]>

//        | <[ $ obj . $(member) ]>
	| E_member (obj, member) =>
	  def convert_member_to_qid (expr : Expr) : Expr {
	    def ret =
	    match (expr) {
	      | E_member (obj, member_name) =>
	      match (convert_member_to_qid (obj)) {
	      	| E_ref (n) => E_ref (n + "." + member_name)
	      	| x => E_member (x, member_name)
	      }
	      | _ => expr
	    };
	    ret.loc <- expr.loc;
	    ret
	  };

	  match (convert_member_to_qid (obj)) {
	    | E_ref (o) => quoted_expr (E_ref (o + "." + member))
	    | _ =>
              <[ Nemerle.Compiler.Parsetree.E_member 
	        ($(quoted_expr (convert_member_to_qid (obj))), 
		                $(quoted_string (member))) ]>
	  }
	
//        | <[ $func ($params) ]> =>
	| E_call (func, params) =>
	  // create construction tree of given call parameter
	  def quoted_param (p : Parm) : Expr
	    {
              <[ Nemerle.Compiler.Parsetree.Parm ($(quoted_bool (p.is_ref)), 
                                                  $(quoted_expr (p.expr)), 
                                                  $(quoted_string (p.name))) ]>
	    };

          <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (func)), 
                                                $(make_quoted_list (quoted_param, params))) ]>

        | <[ $target <- $source ]> =>
          <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (target)), 
                                                  $(quoted_expr (source))) ]>

	| E_let (is_ref, name, val) =>
	  <[ Nemerle.Compiler.Parsetree.E_let ($(quoted_bool (is_ref)), 
                                               $(quoted_string (name)), 
                                               $(quoted_expr (val))) ]>

	| E_letpat (pat, val) =>
	  <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (pat)), 
                                                  $(quoted_expr (val))) ]>

	| E_letfun (funs) =>
	  <[ Nemerle.Compiler.Parsetree.E_letfun ($(make_quoted_list (quoted_fundecl, funs))) ]>

	| E_lambda (decl) =>
	  <[ Nemerle.Compiler.Parsetree.E_lambda ($(quoted_fundecl (decl))) ]>

//      | <[ match ($(expr)) 
	| E_match (expr, cases) =>
	  def quoted_case (cas : Match_case) : Expr
	    {
	      <[ Nemerle.Compiler.Parsetree.Match_case ($(quoted_location (cas.loc)), 
                                                        $(quoted_pattern (cas.pattern)),
                               	                        $(quoted_expr (cas.body))) ]>
	    };
	
    	  <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (expr)), 
                                                 $(make_quoted_list (quoted_case, cases))) ]>

	| <[ raise $exc ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (exc))) ]>

        | <[ if ($cond) $e_then else $e_else ]> =>
	  def re = <[ Nemerle.Compiler.Parsetree.E_if ($(quoted_expr (cond)), 
                                              $(quoted_expr (e_then)), 
                                              $(quoted_expr (e_else))) ]>;
          //print_tree (re, "");
          re

	| E_try_with (body, exn, exn_ty, handler) => 
	  <[ Nemerle.Compiler.Parsetree.E_try_with ($(quoted_expr (body)), 
                                                    $(quoted_string (exn)),
                                                    $(quoted_type (exn_ty)), 
                                                    $(quoted_expr (handler))) ]>

        | <[ try $body finally $handler ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (body)), 
                                                       $(quoted_expr (handler))) ]>

        | <[ require { $assertions } ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_require ($(quoted_expr (assertions))) ]>
	  
        | <[ ensure { $assertions } ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_ensure ($(quoted_expr (assertions))) ]>

	| E_literal (l) => 
	  <[ Nemerle.Compiler.Parsetree.E_literal ($(quoted_literal (l))) ]>

        | <[ this ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_this ]>

        | <[ ( $expr :> $ty ) ]> =>
          <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (expr)),
	                                                   $(quoted_type (ty))) ]>

        | <[ ( $expr : $ty ) ]> =>
	  <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (expr)),
	                                                    $(quoted_type (ty))) ]>

//      this is soooo tricky, not sure if using quoted sequence here would 
//      bury some names into binary of compiler
//	| <[ { $seq } ]> =>
        | E_sequence ([seq]) =>
	  // we treat expression as syntax tree of list containing expressions 
          // of this sequence
	  def decompose_list (ex : Expr) : Expr
	    {
	      match (ex) {
	      	| E_call (E_ref ("Cons"), [h; t]) => 
	          <[ $(quoted_expr (h.expr)) :: $(decompose_list (t.expr)) ]>
	      	| E_call (E_ref ("Nil"), _) => <[ Nil () ]>
		| E_list (exprs) => make_quoted_list (quoted_expr, exprs)
		| E_list_cons (h, t) =>
	          <[ $(quoted_expr (h)) :: $(decompose_list (t)) ]>
                | E_unquoted (e) => e
		| _ => Message.error ("Bad expression in quoted sequence: "); 
		  print_tree(ex, ""); quoted_expr (ex)
	      }
            };
	    
//	  def t = [ <[ 1 ]>; <[ 2 ]> ];
//	  def r = <[ {1::$t} ]>;
//	  print_tree (r, "");
          <[ Nemerle.Compiler.Parsetree.E_sequence ($(decompose_list (seq))) ]>;

	| E_sequence (_) =>
	  Message.fatal_error ("Quoted sequence must contain list of expr, e.g. {[e1; e2; ...]}")

	| E_tuple (args) =>
	  <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quoted_expr, args))) ]>

	| E_unquoted (e) => e

    	| E_list (args) =>
	  // we lift up generated list, because it was designed to be spliced not returned
	  // and it's being evaluated by typechecker
          def 'a id (x : 'a) : 'a { x; };
 	  quoted_expr (make_quoted_list (id, args))

        | E_list_cons (hd, tl) =>
	  // here we first compute what compiler should have given us in form of 
          // Cons constructor and then lift it up
          quoted_expr (<[ Cons ($(hd), $(tl)) ]>)

    	| E_mkarray (args) =>
	  <[ E_mkarray ($(make_quoted_list (quoted_expr, args))) ]>
	  
    	| E_indexer (obj, args) =>
	  <[ E_indexer ($(quoted_expr (obj)), $(make_quoted_list (quoted_expr, args))) ]>

	| E_quoted_expr (e) => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_quoted_patt (e) => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
	| E_quoted_type (e) => 
	  Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
      };
    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction 
      tree 
   *)	  
  public quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | <[ match: _ ]> => <[ Nemerle.Compiler.Parsetree.P_underscore () ]>

        | P_variable (name) => 
          <[ Nemerle.Compiler.Parsetree.P_variable ($(quoted_string (name))) ]>

        | P_as (pat, name) => 
          <[ Nemerle.Compiler.Parsetree.P_as ($(quoted_pattern (pat)), $(quoted_string (name))) ]>

        | P_tuple (args) =>
          <[ Nemerle.Compiler.Parsetree.P_tuple ($(make_quoted_list (quoted_pattern, args))) ]>
          
        | P_record (args) => 
          def quoted_named_pattern (patt : Named_pattern) : Expr
            {
              <[ Nemerle.Compiler.Parsetree.Named_pattern ($(quoted_string (patt.name)),
 	                                                   $(quoted_pattern (patt.pat))) ]>
            };
             
           <[ Nemerle.Compiler.Parsetree.
              P_record ($(make_quoted_list (quoted_named_pattern, args))) ]>

        | P_cons (name, arg) =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_string (name)),
                                                $(quoted_pattern (arg))) ]>

        | P_literal (lit) =>
  	  <[ Nemerle.Compiler.Parsetree.P_literal ($(quoted_literal (lit))) ]>

        // FIXME: it is still some temporary hack, should be E_unquoted_patt(p)
	| P_unquoted (p) => E_quoted_patt (p)

        | P_list (args) =>
	  // we lift up generated list, because it was designed to be spliced not returned
	  // and it's being evaluated by typechecker
 	  quoted_pattern (expr_to_pattern (make_quoted_list (quoted_pattern, args)));

        | P_list_cons (hd, tl) =>
	  // here we first compute what compiler should have given us in form of 
          // Cons constructor and then lift it up
          quoted_pattern (expr_to_pattern (<[ P_cons ("Cons", 
                                                      P_tuple ($(quoted_pattern (hd)), 
                                                               $(quoted_pattern (tl)))) ]>));

        | P_quoted_expr =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_quoted_patt => 
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
	| P_quoted_type =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
      } 
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  public expr_to_pattern (exp : Expr) : Pattern 
    {
      def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
        match (pars) {
          | [] => 
            match (acc) {
	      | [] => P_underscore ()
	      | _ => P_tuple (List.rev (acc))
            }
          | x::xs => convert_params (xs, expr_to_pattern (x.expr) :: acc)
        }
      };

      match (exp) {
        | E_ref (id) => P_cons (id, P_underscore ())
        | E_call (E_ref ("Nemerle.Compiler.Parsetree.Parm"), 
                  [{ expr = is_ref }; { expr = constr }; { expr = name  }]) => 
          P_record ([Named_pattern ("is_ref", expr_to_pattern (is_ref));
                     Named_pattern ("expr", expr_to_pattern (constr));
                     Named_pattern ("name", expr_to_pattern (name))])
        | E_call (E_ref (constr), params) => 
          P_cons (constr, convert_params (params, []))
        | E_literal (lit) => P_literal (lit)
	| E_quoted_patt (p) => p
        | _ => 
          print_tree (exp, "");
          Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
      }
    }

  // DEBUG SECTION

  (* first macro? 
  public while (cond : Expr, body : Expr) : Expr
    {
      <[ { def whileloop () : void { if ($cond) { [$body; whileloop()] } else () } whileloop ();} ]>
    }
*)
  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  print_tree (exp : Expr, empty : string) : void
    {
      def convert_params (pars : list (Parm)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_tree (x.expr, empty + "  "); convert_params (xs )
        }
      };

      print_string (empty);

      def print_literal (lit : Literal ) : void
        {
	  match (lit) {
	    | L_string (s) => print_string (s)
            | L_int (i) => print_string (string_of_int (i))
	    | _ => print_string ("some literal")
          }
        };

      match (exp) {
        | E_ref (id) => print_string ("E_ref ("); print_string (id); print_endline (")")
        | E_call (E_ref (constr), params) => 
          print_string ("E_call (E_ref ("); print_string (constr); print_endline ("),");
          convert_params (params);
          print_string (empty);
	  print_endline (")")
        | E_literal (lit) => print_string ("E_literal ("); print_literal (lit); print_endline (")")
	| E_list (args) =>      
     	  print_endline("E_list (");
	  def pr (e : Expr ) : void { print_tree (e, empty + "  "); };
	  def _ = List.map (pr, args);
	  print_endline(empty + ")");
	  ()
	| E_list_cons _ =>           
	  print_endline ("Bad constructed quoted expression in print - list_cons ")
	| E_sequence (seq) =>
	  print_endline("E_sequence ("); 
	  def pr (e : Expr ) : void { print_tree (e, empty + "  "); };
	  def _ = List.map (pr, seq);
	  print_endline(empty + ")")

	| E_tuple (args) =>
	  print_endline ("Bad constructed quoted expression in print - tuple ")
        | E_member (o, x) =>
	  print_endline ("Bad constructed quoted expression in print - member " + x);
          print_tree (o, empty)
    	| E_assign => 
	  print_endline ("Bad constructed quoted expression in print - assign ")
    	| E_let  => 
	  print_endline ("Bad constructed quoted expression in print - let ")
    	| E_letpat  => 
	  print_endline ("Bad constructed quoted expression in print - letpat ")
    	| E_letfun => 
	  print_endline ("Bad constructed quoted expression in print - letfun ")
    	| E_lambda => 
	  print_endline ("Bad constructed quoted expression in print - lambda ")
    	| E_match  => 
	  print_endline ("Bad constructed quoted expression in print - match ")
    	| E_raise  => 
	  print_endline ("Bad constructed quoted expression in print - raise ")
    	| E_if  => 
	  print_endline ("Bad constructed quoted expression in print - if ")
    	| E_try_with => 
	  print_endline ("Bad constructed quoted expression in print - try_with ")
    	| E_try_finally => 
	  print_endline ("Bad constructed quoted expression in print - try_finally ")
    	| E_require => 
	  print_endline ("Bad constructed quoted expression in print - require ")
    	| E_ensure  => 
	  print_endline ("Bad constructed quoted expression in print - ensure ")
    	| E_this => 
	  print_endline ("Bad constructed quoted expression in print - this ")
    	| E_type_conversion => 
	  print_endline ("Bad constructed quoted expression in print - type_conversion ")
    	| E_type_enforcement => 
	  print_endline ("Bad constructed quoted expression in print - type_enforc ")
    	| E_quoted_expr => 
	  print_endline ("Bad constructed quoted expression in print - quoted_ex ")
    	| E_quoted_patt => 
	  print_endline ("Bad constructed quoted expression in print - quoted_patt ")
    	| E_quoted_type => 
	  print_endline ("Bad constructed quoted expression in print - quoted_ty ")
    	| E_unquoted => 
	  print_endline ("Bad constructed quoted expression in print - unquoted ")
    	| E_mkarray => 
	  print_endline ("Bad constructed quoted expression in print - mkarray ")
    	| E_indexer => 
	  print_endline ("Bad constructed quoted expression in print - indexer ")
        | _ => 
	   print_endline ("other")
      }
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  print_pattern (pat : Pattern, empty : string) : void
    {
      def convert_params (pars : list (Pattern)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_pattern (x, empty + "  "); convert_params (xs)
        }
      };

      def print_args (args : list (Named_pattern)) : void {
	match (args) {
	  | [] => ()
	  | x::xs => print_string (empty + "  "); print_string (x.name); print_endline(" = "); 
                     print_pattern (x.pat, empty + "    "); print_args (xs)
 	}  
      };

      print_string (empty);

      match (pat) {
        | P_cons (id, arg) => print_string ("P_cons ("); print_string (id); print_endline (",");
                              print_pattern (arg, empty + "  "); print_string (empty); print_endline (")")
        | P_underscore => print_endline ("P_under")
        | P_record (args) => 
	   print_endline ("P_record (");
	   print_args (args); print_string (empty); print_endline (")")
        | P_tuple (args) => print_endline ("P_tuple ("); convert_params (args); 
            print_string (empty); print_endline (")")
        | _ => 
	   print_endline ("other")
      }
    }
  
}
} // end ns
