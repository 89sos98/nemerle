/*
 * Copyright (c) 2003-2007 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Internal;
using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;

using Reflector.CodeModel;
using Reflector.CodeModel.Memory;
using Reflector.NemerleLanguage.CodeModel;

namespace Reflector.NemerleLanguage
{
  internal class LanguageWriter : LanguageWritterBase
  {
    _configuration : LanguageWriterConfiguration;

    public this
      ( formatter     : IFormatter
      , configuration : ILanguageWriterConfiguration
      )
    {
      base(formatter);
      _configuration = LanguageWriterConfiguration(configuration);
    }

    #region Module

    public override WriteAssembly([NotNull] value : IAssembly) : void
    {
      Write("// Assembly ");
      WriteDeclaration(value.Name);
      when (value.Version != null)
        Write($", Version $(value.Version)");

      WriteLine();

      WriteCustomAttributeList(value.Attributes.ToList(), "assembly");

      WriteProperty("Location", value.Location);
      WriteProperty("Name",     value.ToString());
      WriteProperty("Type",
      match(value.Type)
      {
      | AssemblyType.Console     => "Console Application"
      | AssemblyType.Application => "Windows Application"
      | AssemblyType.Library     => "Class Library"
      | _                        => "<Unknown>"
      }
      );
    }

    public override WriteAssemblyReference([NotNull] value : IAssemblyReference) : void
    {
      Write("// Assembly Reference ");
      WriteDeclaration(value.Name);
      WriteLine();
      WriteProperty("Version", value.Version.ToString());
      WriteProperty("Name", value.ToString());
    }

    public override WriteModule([NotNull] value : IModule) : void
    {
      Write("// Module ");
      WriteDeclaration(value.Name);
      WriteLine();

      WriteCustomAttributeList(value.Attributes.ToList(), "module");

      WriteProperty("Version", value.Version.ToString());
      WriteProperty("Location", value.Location);
      def loc = Environment.ExpandEnvironmentVariables(value.Location);
      when (File.Exists(loc))
        WriteProperty("Size", $"$(FileInfo(loc).Length) Bytes");
    }

    public override WriteModuleReference([NotNull] value : IModuleReference) : void
    {
      Write("// Module reference ");
      WriteDeclaration(value.Name);
      WriteLine();
    }

    public override WriteNamespace([NotNull] value : INamespace) : void
    {
      def global = string.IsNullOrEmpty(value.Name);
      unless (global)
      {
          WriteKeyword("namespace");
          Write(" ");
          WriteDeclaration(value.Name);
      }

      when (_configuration.ShowNamespaceBody)
      {
        unless (global)
        {
          WriteLine();
          WriteLine("{");
          WriteIndent();
        }

        when (_configuration.ShowNamespaceImports)
        {
          def visitor = UsingNamespaceVisitor();
          visitor.VisitNamespace(value);
          
          mutable foundAny = false;
          visitor.Namespaces.Sort(string.Compare).Iter(ns =>
            unless (string.IsNullOrEmpty(ns))
            {
              WriteKeyword("using");
              Write(" ");
              Write(ns);
              WriteLine(";");
              foundAny = true;
            });

          when (foundAny)
            WriteLine();
        }

        def visibleTypes = value.Types.ToList()
          .Filter(e : ITypeDeclaration => _configuration.IsVisible(e));

        visibleTypes.Sort((x, y) => string.Compare(x.Name, y.Name)).Iter(ty =>
          {
            WriteTypeDeclaration(ty);
            WriteLine();

            // An extra line for readability
            //
            WriteLine();
          });

        unless (global)
        {
            WriteOutdent();
            WriteLine("}");
        }
      }
    }

    public override WriteResource(value : IResource) : void
    {
      Write("// ");
      WriteKeyword(
        match (value.Visibility)
        {
        | ResourceVisibility.Public  => "public";
        | ResourceVisibility.Private => "private";
        });

      Write(" ");
      WriteKeyword("resource");
      Write(" ");
      WriteDeclaration(value.Name);
      WriteLine();

      match (value)
      {
      | embedded is IEmbeddedResource =>
          WriteProperty("Size", $"$(embedded.Value.Length) Bytes");
      | file     is IFileResource     =>
        WriteProperty("Location", file.Location);
        def loc = Environment.ExpandEnvironmentVariables(file.Location);
        when (File.Exists(loc))
          WriteProperty("Size", $"$(FileInfo(loc).Length) Bytes");
      | _                             => throw NotImplementedException();
      }
    }

    public override WriteStatement(value : IStatement) : void
    {
      Write($"Statement $value");
    }

    #endregion

    #region WriteExpression

    public override WriteExpression(value : IExpression) : void
    {
    | null                                     => throw ArgumentNullException("expression");
    | expr is ILiteralExpression               => WriteLiteralExpression(expr);
    | expr is IAssignExpression                => WriteAssignExpression(expr);
    | expr is ITypeOfExpression                => WriteTypeOfExpression(expr);
    | expr is INamedArgumentExpression         => WriteNamedArgumentExpression(expr);
    | expr is ITypeReferenceExpression         => WriteTypeReferenceExpression(expr);
    | expr is IFieldReferenceExpression        => WriteFieldReferenceExpression(expr);
    | expr is IEventReferenceExpression        => WriteEventReferenceExpression(expr);
    | expr is IMethodReferenceExpression       => WriteMethodReferenceExpression(expr);
    | expr is IArgumentListExpression          => WriteArgumentListExpression(expr);
    | expr is IStackAllocateExpression         => WriteStackAllocateExpression(expr);
    | expr is IPropertyReferenceExpression     => WritePropertyReferenceExpression(expr);
    | expr is IArrayCreateExpression           => WriteArrayCreateExpression(expr);
    | expr is IArrayInitializerExpression      => WriteArrayInitializerExpression(expr);
    | expr is IBaseReferenceExpression         => WriteBaseReferenceExpression(expr);
    | expr is IUnaryExpression                 => WriteUnaryExpression(expr);
    | expr is IBinaryExpression                => WriteBinaryExpression(expr);
    | expr is ITryCastExpression               => WriteTryCastExpression(expr);
    | expr is ICanCastExpression               => WriteCanCastExpression(expr);
    | expr is ICastExpression                  => WriteCastExpression(expr);
    | expr is IConditionExpression             => WriteConditionExpression(expr);
    | expr is INullCoalescingExpression        => WriteNullCoalescingExpression(expr);
    | expr is IDelegateCreateExpression        => WriteDelegateCreateExpression(expr);
    | expr is IArgumentReferenceExpression     => WriteArgumentReferenceExpression(expr);
    | expr is IVariableDeclarationExpression   => WriteVariableDeclarationExpression(expr);
    | expr is IVariableReferenceExpression     => WriteVariableReferenceExpression(expr);
    | expr is IPropertyIndexerExpression       => WritePropertyIndexerExpression(expr);
    | expr is IArrayIndexerExpression          => WriteArrayIndexerExpression(expr);
    | expr is IMethodInvokeExpression          => WriteMethodInvokeExpression(expr);
    | expr is IDelegateInvokeExpression        => WriteDelegateInvokeExpression(expr);
    | expr is IObjectCreateExpression          => WriteObjectCreateExpression(expr);
    | expr is IThisReferenceExpression         => WriteThisReferenceExpression(expr);
    | expr is IAddressOfExpression             => WriteAddressOfExpression(expr);
    | expr is IAddressOutExpression            => WriteAddressOutExpression(expr);
    | expr is IAddressReferenceExpression      => WriteAddressReferenceExpression(expr);
    | expr is IAddressDereferenceExpression    => WriteAddressDereferenceExpression(expr);
    | expr is ISizeOfExpression                => WriteSizeOfExpression(expr);
    | expr is IGenericDefaultExpression        => WriteGenericDefaultExpression(expr);
    | expr is ITypeOfTypedReferenceExpression  => WriteTypeOfTypedReferenceExpression(expr);
    | expr is IValueOfTypedReferenceExpression => WriteValueOfTypedReferenceExpression(expr);
    | expr is ITypedReferenceCreateExpression  => WriteTypedReferenceCreateExpression(expr);
    | expr is IObjectInitializeExpression      => WriteObjectInitializeExpression(expr);
    | expr is ISnippetExpression               => WriteSnippetExpression(expr);
    | _                                        => throw NotImplementedException();
    }

    private WriteLiteralExpression(expression : ILiteralExpression) : void
    {
      match (expression.Value)
      {
      | null                => WriteLiteral("null");
      | str is string       => WriteLiteral($"\"$(EscapeString(str))\"")
      | chr is char         => WriteLiteral($"'$(EscapeChar(chr))'")
      | other               => WriteLiteral(Convert.ToString(other, CultureInfo.InvariantCulture))
      }
    }

    private WriteAssignExpression(expr : IAssignExpression) : void
    {
    | binExpr is IBinaryExpression
      when expr.Target.Equals(binExpr.Left) =>

      def op =
        match (binExpr.Operator)
        {
        | BinaryOperator.Add                => "+=";
        | BinaryOperator.Subtract           => "-=";
        | BinaryOperator.Multiply           => "*=";
        | BinaryOperator.Divide             => "/=";
        | BinaryOperator.BitwiseOr          => "|=";
        | BinaryOperator.BitwiseAnd         => "&=";
        | BinaryOperator.BitwiseExclusiveOr => "^=";
        | _                                 => null;
        }

      if (op != null)
      {
        WriteExpression(binExpr.Left);
        Write(" ");
        Write(op);
        Write(" ");
        WriteExpression(binExpr.Right);
      }
      else
      {
        WriteExpression(expr.Target);
        Write(" = ");
        WriteExpression(expr.Expression);
      }

    | _                                     =>
      WriteExpression(expr.Target);
      Write(" = ");
      WriteExpression(expr.Expression);
    }

    private WriteTypeOfExpression(expr : ITypeOfExpression) : void
    {
      WriteKeyword("typeof");
      Write("(");
      WriteType(expr.Type);
      Write(")");
    }

    private WriteNamedArgumentExpression(expr : INamedArgumentExpression) : void
    {
      WriteMemberReference(expr.Member);
      Write("=");
      WriteExpression(expr.Value);
    }

    private WriteTypeReferenceExpression(expr : ITypeReferenceExpression) : void
    {
      WriteType(expr.Type);
    }

    private WriteFieldReferenceExpression(expr : IFieldReferenceExpression) : void
    {
      unless (expr.Target == null)
      {
        WriteExpression(expr.Target);
        Write(".");
      }
      WriteFieldReference(expr.Field);
    }

    private WriteEventReferenceExpression(expr : IEventReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteMethodReferenceExpression(expr : IMethodReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteArgumentListExpression(expr : IArgumentListExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteStackAllocateExpression(expr : IStackAllocateExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WritePropertyReferenceExpression(expr : IPropertyReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteArrayCreateExpression(expr : IArrayCreateExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteArrayInitializerExpression(expr : IArrayInitializerExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteBaseReferenceExpression(expr : IBaseReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteUnaryExpression(expr : IUnaryExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteBinaryExpression(expr : IBinaryExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteTryCastExpression(expr : ITryCastExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteCanCastExpression(expr : ICanCastExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteCastExpression(expr : ICastExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteConditionExpression(expr : IConditionExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteNullCoalescingExpression(expr : INullCoalescingExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteDelegateCreateExpression(expr : IDelegateCreateExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteArgumentReferenceExpression(expr : IArgumentReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteVariableDeclarationExpression(expr : IVariableDeclarationExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteVariableReferenceExpression(expr : IVariableReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WritePropertyIndexerExpression(expr : IPropertyIndexerExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteArrayIndexerExpression(expr : IArrayIndexerExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteMethodInvokeExpression(expr : IMethodInvokeExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteDelegateInvokeExpression(expr : IDelegateInvokeExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteObjectCreateExpression(expr : IObjectCreateExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteThisReferenceExpression(expr : IThisReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteAddressOfExpression(expr : IAddressOfExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteAddressOutExpression(expr : IAddressOutExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteAddressReferenceExpression(expr : IAddressReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteAddressDereferenceExpression(expr : IAddressDereferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteSizeOfExpression(expr : ISizeOfExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteGenericDefaultExpression(expr : IGenericDefaultExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteTypeOfTypedReferenceExpression(expr : ITypeOfTypedReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteValueOfTypedReferenceExpression(expr : IValueOfTypedReferenceExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteTypedReferenceCreateExpression(expr : ITypedReferenceCreateExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteObjectInitializeExpression(expr : IObjectInitializeExpression) : void { WriteLiteral($"$(expr.ToString())") }
    private WriteSnippetExpression(expr : ISnippetExpression) : void { WriteLiteral($"$(expr.ToString())") }

    #endregion

    #region Type members

    public override WriteEventDeclaration([NotNull] value : IEventDeclaration) : void
    {
      WriteDocumentation(value);
      WriteCustomAttributeList(value.Attributes.ToList());

      unless (value.DeclaringType.IsInterface())
        WriteMethodVisibility(value.GetVisibility());

      WriteKeyword("event");
      Write(" ");
      WriteDeclaration(value.Name);
      Write(" : ");
      WriteType(value.EventType);
      WriteLine(";");
    }

    public override WriteFieldDeclaration(value : IFieldDeclaration) : void
    {
      WriteDocumentation(value);
      WriteCustomAttributeList(value.Attributes.ToList());

      match (value.GetVisibility())
      {
      | FieldVisibility.Private           => WriteKeyword("private");
      | FieldVisibility.PrivateScope      => WriteComment("/* private scope */");
      | FieldVisibility.FamilyAndAssembly => WriteKeyword("protected internal");
      | FieldVisibility.Assembly          => WriteKeyword("internal");
      | FieldVisibility.Family            => WriteKeyword("protected");
      | FieldVisibility.FamilyOrAssembly  => WriteKeyword("internal protected");
      | FieldVisibility.Public            => WriteKeyword("public");
      | _                                  => throw NotSupportedException()
      }

      Write(" ");

      when (value.Static)
      {
        if (value.Literal)
          WriteKeyword("const");
        else
          WriteKeyword("static");
        Write(" ");
      }

      unless (value.ReadOnly || value.Literal)
      {
        WriteKeyword("mutable");
        Write(" ");
      }

      WriteDeclaration(value.Name);

      Write(" : ");
      WriteType(value.FieldType);

      unless (value.Initializer == null)
      {
        Write(" = ");
        WriteExpression(value.Initializer);
      }

      WriteLine(";");
    }

    public override WriteMethodDeclaration(value : IMethodDeclaration) : void
    {
      def wrapper = CustomAttributeWrapper.Method(value);
      WriteDocumentation(value);
      WriteCustomAttributeList(wrapper.Attributes);
      WriteCustomAttributeList(value.ReturnType.Attributes.ToList(), "return");

      unless (value.DeclaringType.IsInterface())
        WriteMethodVisibility(value.GetVisibility());

      when (value.Static)
      {
        WriteKeyword("static");
        Write(" ");
      }

      if (value.IsConstructor())
      {
        WriteKeyword("this");
        Write("(");
        WriteList(value.Parameters.ToList(), WriteParameterDeclaration);
        Write(")");
      }
      else
      {
        def genArgs = value.GenericArguments.ToList();
        WriteDeclaration(value.Name);
        WriteList(genArgs, "[", "]", WriteType);
        Write("(");
        when (value.Static && wrapper.IsExtension)
        {
          WriteKeyword("this");
          Write(" ");
        }
        WriteList(value.Parameters.ToList(), WriteParameterDeclaration);
        Write(")");
        Write(" : ");
        WriteType(value.ReturnType.Type);
        WriteGenericParameterConstraintList(genArgs);

        def overrides = value.Overrides.ToList();
        unless (overrides.IsEmpty)
        {
          Write(" ");
          WriteKeyword("implements");
          Write(" ");
          WriteList(overrides, WriteMethodReference);
        }
      }
      WriteLine(";");
    }

    public override WritePropertyDeclaration(value : IPropertyDeclaration) : void
    {
      WriteDocumentation(value);
      WriteCustomAttributeList(value.Attributes.ToList());

      def getMethod = if (value.GetMethod != null) value.GetMethod.Resolve() else null;
      def setMethod = if (value.SetMethod != null) value.SetMethod.Resolve() else null;

      def isInterface    = value.DeclaringType.IsInterface();
      def propVisibility = value.GetVisibility();

      unless (isInterface)
        WriteMethodVisibility(propVisibility);

      WriteDeclaration(value.Name);
      WriteList(value.Parameters.ToList(), "[", "]", WriteParameterDeclaration);
      Write(" : ");
      WriteType(value.PropertyType);

      unless (getMethod == null && setMethod == null)
      {
        Write(" { ");

        unless (getMethod == null)
        {
          WriteList(getMethod.Attributes.ToList(), "[", "] ", WriteCustomAttribute);

          unless (isInterface || propVisibility == getMethod.GetVisibility())
            WriteMethodVisibility(getMethod.GetVisibility());

          WriteKeyword("get");
          Write("; ");
        }

        unless (setMethod == null)
        {
          WriteList(setMethod.Attributes.ToList(), "[", "] ", WriteCustomAttribute);

          unless (isInterface || propVisibility == getMethod.GetVisibility())
            WriteMethodVisibility(setMethod.GetVisibility());

          WriteKeyword("set");
          Write("; ");
        }

        Write("}");
      }
      WriteLine();
    }

    #endregion

    #region WriteTypeDeclaration

    public override WriteTypeDeclaration([NotNull] value : ITypeDeclaration) : void
    {
      unless (value.Namespace.Length == 0 && value.Name == "<Module>")
      {
        def wrapper = CustomAttributeWrapper.Type(value);
        WriteDocumentation(value);
        WriteCustomAttributeList(wrapper.Attributes);

        // Variant options has the same access as the outer variant.
        //
        unless (wrapper.IsVariantOption)
        {
          WriteKeyword(
            match (value.Visibility)
            {
            | TypeVisibility.Private
            | TypeVisibility.NestedAssembly          => "internal"
            | TypeVisibility.Public
            | TypeVisibility.NestedPublic            => "public"
            | TypeVisibility.NestedPrivate           => "private"
            | TypeVisibility.NestedFamily            => "protected"
            | TypeVisibility.NestedFamilyAndAssembly => "protected internal"
            | TypeVisibility.NestedFamilyOrAssembly  => "internal protected"
            | _                                      => throw NotSupportedException()
            });
          Write(" ");
        }

        match (value.GetBaseTypeName())
        {
        | ("System", "Delegate")
        | ("System", "MulticastDelegate") => WriteDelegateDeclaration(value)
        | ("System", "Enum")              => WriteEnumDeclaration(value, wrapper)
        | ("System", "ValueType")         => WriteTypeDeclaration(value, "struct")
        | _                               =>
          if (value.Interface)
            if (wrapper.TypeAlias != null)
              WriteTypeAliasDeclaration(value, wrapper)
            else
              WriteTypeDeclaration(value, "interface")
          else if (value.Abstract)
            if (value.Sealed)
              WriteTypeDeclaration(value, "module")
            else if (wrapper.IsVariant)
              WriteTypeDeclaration(value, "variant")
            else
            {
              WriteKeyword("abstract");
              Write(" ");
              WriteTypeDeclaration(value, "class")
            }
          else if (value.Sealed)
            if (wrapper.IsVariantOption)
              WriteTypeDeclaration(value, "|")
            else
            {
              WriteKeyword("sealed");
              Write(" ");
              WriteTypeDeclaration(value, "class")
            }
          else
              WriteTypeDeclaration(value, "class")
        }
      }
    }

    private WriteDelegateDeclaration(value : ITypeDeclaration) : void
    {
      WriteKeyword("delegate");
      Write(" ");
      def decl = value.Methods.Find(m : IMethodDeclaration => m.Name == "Invoke");
      if (decl != null)
      {
        def genArgs = value.GenericArguments.ToList();
        WriteDeclaration(value.Name);
        WriteList(genArgs, "[", "]", WriteType);
        Write("(");
        WriteList(decl.Parameters.ToList(), WriteParameterDeclaration);
        Write(")");
        Write(" : ");
        WriteType(decl.ReturnType.Type);
        WriteGenericParameterConstraintList(genArgs);
      }
      else
      {
        Debug.WriteLine($"Invoke method not found for delegate '$(value.GetUserFriendlyName())'");
        WriteDeclaration(value.Name);
      }

      Write(";");
    }

    private WriteEnumDeclaration
      ( value   : ITypeDeclaration
      , wrapper : CustomAttributeWrapper.Type
      )         : void
    {
      WriteKeyword("enum");
      Write(" ");
      WriteDeclaration(value.Name);

      // Usually, the first enum field is the enum underlying type.
      // The rest is the enum values.
      //
      def underliyngTypeField = value.Fields.Find(f : IFieldDeclaration =>
        f.SpecialName && f.RuntimeSpecialName && !f.FieldType.Equals(value));

      when (underliyngTypeField != null)
      {
        def (ns, name) = underliyngTypeField.FieldType.GetTypeName();

        // int is the default enum type. So hide them.
        //
        unless (ns == "System" && name == "Int32")
        {
          Write(" : ");
          WriteType(underliyngTypeField.FieldType)
        }
      }

      // Enum can contain only fields (values).
      // No events/methods/properties.
      //
      when (_configuration.ShowTypeDeclarationBody)
      {
        WriteLine();
        WriteLine("{");
        WriteOptionIndent();

        mutable expectedValue = 0L;
        value.Fields.Iter(f : IFieldDeclaration =>
        {
          unless (f.SpecialName && f.RuntimeSpecialName && !f.FieldType.Equals(value))
          {
            Write("| ");
            WriteDeclaration(f.Name);

            // Initializer optimization.
            // Do not write redundant initializers.
            // Also [FlagsAttribute] marked enum values are written in hex.
            //
            def suppressInitializer =
              match (f.Initializer)
              {
              | literal is ILiteralExpression =>
                if (wrapper.IsFlagsEnumeration)
                {
                  match (literal.Value)
                  {
                  | fmt is IFormattable =>
                    Write(" = ");
                    WriteLiteral("0x" + fmt.ToString("X2", CultureInfo.InvariantCulture));
                    true
                  | _                   => false
                  }
                }
                else
                {
                  match (literal.Value)
                  {
                  | cvt is IConvertible =>
                    try
                    {
                      def actualValue = cvt.ToInt64(CultureInfo.InvariantCulture);
                      def same = (actualValue == expectedValue);
                      expectedValue = actualValue + 1;
                      same
                    }
                    catch
                    {
                    | _ =>
                      // On error turn off the optimization.
                      //
                      expectedValue = 0;
                      false
                    }
                  | _                   => false
                  }
                }
              | null                    => true
              | _                       => false
              }

            unless (suppressInitializer)
            {
              Write(" = ");
              WriteExpression(f.Initializer);
            }

            WriteLine();
          }
        });

        WriteOptionOutdent();
        Write("}");
      }
    }

    private WriteTypeAliasDeclaration
      ( value   : ITypeDeclaration
      , wrapper : CustomAttributeWrapper.Type
      )         : void
    {
      // TODO: Decode alias string to real type name and generic parameters
      // See ncc\external\Codec.n for details
      //
      def alias    = wrapper.TypeAlias;
      def dotIndex = alias.LastIndexOf('.');
      def typeRef  = TypeReference();

      if (dotIndex > 0)
      {
        typeRef.Namespace = alias.Substring(0, dotIndex);
        typeRef.Name      = alias.Substring(dotIndex + 1);
      }
      else
        typeRef.Name      = alias;

      WriteKeyword("type");
      Write(" ");

      WriteDeclaration(value.Name);
      Write(" = ");

      WriteReference(alias, alias, typeRef);
      Write(";");
    }

    private WriteTypeDeclaration
      ( value    : ITypeDeclaration
      , keyword  : string
      )          : void
    {
      WriteKeyword(keyword);
      Write(" ");

      def genArgs = value.GenericArguments.ToList();
      WriteDeclaration(value.Name);

      // Skip variant option base type, generic arguments and constraints.
      //
      unless (keyword == "|")
      {
        WriteList(genArgs, "[", "]", WriteType);

        def baseTypes =
          match (value.GetBaseTypeName())
          {
          | (null, null)
          | ("System", "Object")
          | ("System", "ValueType") => value.Interfaces.ToList();
          | _                       => value.BaseType :: value.Interfaces.ToList();
          }

        WriteList(baseTypes, " : ", null, WriteType);
        WriteGenericParameterConstraintList(genArgs);
      }

      when (_configuration.ShowTypeDeclarationBody)
      {
        WriteLine();
        WriteLine("{");
        WriteIndent();

        def events      = value.Events     .ToList().Filter(e => !e.RuntimeSpecialName);
        def fields      = value.Fields     .ToList().Filter(e => !e.Name.StartsWith("_N_") && !e.RuntimeSpecialName);
        def innerTypes  = value.NestedTypes.ToList().Filter(e => !e.Name.StartsWith("_N_"));
        def properties  = value.Properties .ToList().Filter(e => !e.Name.StartsWith("_N_"));
        mutable methods = value.Methods    .ToList().Filter(e => !e.Name.StartsWith("_N_"));

        events.Iter(e : IEventDeclaration =>
          {
            unless (e.AddMethod == null)
              methods = methods.Remove(e.AddMethod.Resolve());
            unless (e.RemoveMethod == null)
              methods = methods.Remove(e.RemoveMethod.Resolve());
            unless (e.InvokeMethod == null)
              methods = methods.Remove(e.InvokeMethod.Resolve());
          });

        properties.Iter(e : IPropertyDeclaration =>
          {
            unless (e.GetMethod == null)
              methods = methods.Remove(e.GetMethod.Resolve());
            unless (e.SetMethod == null)
              methods = methods.Remove(e.SetMethod.Resolve());
          });

        innerTypes.Iter(t : ITypeDeclaration => WriteTypeDeclaration(t));

        WriteMembersDeclaration(events,     "Events",     WriteEventDeclaration);
        WriteMembersDeclaration(fields,     "Fields",     WriteFieldDeclaration);
        WriteMembersDeclaration(methods,    "Methods",    WriteMethodDeclaration);
        WriteMembersDeclaration(properties, "Properties", WritePropertyDeclaration);
      }

      WriteOutdent();
      WriteLine("}");
    }

    private WriteMembersDeclaration['a](lst : list['a], name : string, writer : 'a -> void) : void
    {
      unless (lst.IsEmpty)
      {
        WriteKeyword("#region");
        Write(" ");
        WriteLine(name);
        WriteLine();

        lst.Iter(writer);

        WriteLine();
        WriteKeyword("#endregion");
        Write(" ");
        WriteLine(name);
        WriteLine();
      }
    }

    #endregion

    #region Helpers

    private WriteFieldReference(value : IFieldReference) : void
    {
      WriteReference(value.Name, value.GetUserFriendlyName(), value);
    }

    private WriteMethodReference(value : IMethodReference) : void
    {
      def ty = value.DeclaringType;
      
      def name =
        if (value.IsConstructor())
         ty.GetName();
        else
         ty.GetName() + "." + value.Name;

      WriteReference(name, value.GetUserFriendlyName(), value);
    }

    private WritePropertyReference(value : IPropertyReference) : void
    {
      WriteReference(value.Name, value.GetUserFriendlyName(), value);
    }

    private WriteEventReference(value : IEventReference) : void
    {
      WriteReference(value.Name, value.GetUserFriendlyName(), value);
    }

    private WriteMemberReference(memberReference : IMemberReference) : void
    {
    | f is IFieldReference    => WriteFieldReference   (f);
    | m is IMethodReference   => WriteMethodReference  (m);
    | p is IPropertyReference => WritePropertyReference(p);
    | e is IEventReference    => WriteEventReference   (e);
    | _                       => throw NotSupportedException();
    }

    private WriteType(value : IType) : void
    {
    | typeRef is ITypeReference    =>
      match (typeRef.GetTypeName())
      {
      | ("Nemerle.Builtins", "Tuple")        =>
        WriteList(typeRef.GenericArguments.ToList(), "(", ")", " * ", WriteType);
      | ("Nemerle.Builtins", "Function")     =>
        def (genArgs, retType) = typeRef.GenericArguments.ToList().DivideLast();
        WriteList(genArgs, null, " -> ", " * ", WriteType);
        WriteType(retType);
      | ("Nemerle.Builtins", "FunctionVoid") =>
        WriteList(typeRef.GenericArguments.ToList(), null, " -> ", " * ", WriteType);

        // Extract the return type from the type itself.
        // We need a reference, not a name.
        //
        def found =
          match (typeRef.Resolve())
          {
          | null => false;
          | d    =>
            match (d.Methods.Find(m : IMethodDeclaration => m.Name == "apply_void"))
            {
            | null => false;
            | m    => WriteType(m.ReturnType.Type); true;
            }
          }

        unless (found)
          WriteKeyword("void");
      | _ =>
        def name = Helper.GetUserFriendlyName(typeRef);
        WriteTypeReference(typeRef, name, typeRef);
        WriteList(typeRef.GenericArguments.ToList(), "[", "]", WriteType);
      }

    | arrType is IArrayType        =>
      WriteKeyword("array");
      Write("[");

      def dims = arrType.Dimensions;
      when (dims.Count > 1)
      {
        WriteLiteral(dims.Count.ToString(CultureInfo.InvariantCulture));
        Write(", ");
      }

      for (mutable i = 0; i < dims.Count; ++i)
      {
        def dim = dims[i];
        when (dim.LowerBound > 0)
          WriteComment($"/* Dim $i LowerBound = $(dim.LowerBound)*/");
        when (dim.UpperBound != -1)
          WriteComment($"/* Dim $i UpperBound = $(dim.UpperBound)*/");
      }

      WriteType(arrType.ElementType);
      Write("]");

    | ptrType is IPointerType      =>
      WriteType(ptrType.ElementType);
      Write("*");

    | refType is IReferenceType    =>
      WriteKeyword("ref");
      Write(" ");
      WriteType(refType.ElementType);

    | modOpt  is IOptionalModifier =>
      WriteType(modOpt.ElementType);
      Write(" ");
      WriteKeyword("modopt");
      Write("(");
      WriteType(modOpt.Modifier);
      Write(")");

    | modReq  is IRequiredModifier =>
      match (modReq.Modifier)
      {
      | typeRef when typeRef != null
            && typeRef.Namespace == "System.Runtime.CompilerServices"
            && typeRef.Name      == "IsVolatile" =>
        WriteKeyword("volatile");
        Write(" ");
        WriteType(modReq.ElementType);
      | _                              =>
        WriteType(modReq.ElementType);
        Write(" ");
        WriteKeyword("modreq");
        Write("(");
        WriteType(modReq.Modifier);
        Write(")");
      }

    | funPtr  is IFunctionPointer  =>
      WriteType(funPtr.ReturnType.Type);
      Write(" *(");
      for (mutable i = 0; i < funPtr.Parameters.Count; ++i)
      {
        when (i != 0)
          Write(", ");

        WriteType(funPtr.Parameters[i].ParameterType);
      }
      Write(")");

    | genParm is IGenericParameter =>
      WriteDeclaration(genParm.Name);

    | genArg  is IGenericArgument  =>
      match (genArg.Resolve())
      {
      | genParm is IGenericParameter =>
        def name = genParm.Name + " // Generic Argument";
        WriteReference(genParm.Name, name, null);
      | other                        => WriteType(other)
      }

    | _                            =>
      throw NotSupportedException($"Unknown kind of type '$(value.GetType().Name)'.");
    }

    private WriteCustomAttribute(value : ICustomAttribute) : void
    {
      def ty       = value.Constructor.DeclaringType;
      def typeName = ty.GetName();

      WriteReference(
        {
          if (typeName.EndsWith("Attribute"))
            typeName.Substring(0, typeName.Length - 9);
          else
            typeName;
        }, ty.GetUserFriendlyName(), value.Constructor);

      WriteList(value.Arguments.ToList(), "(", ")", WriteExpression);
    }

    private WriteCustomAttributeList
      ( attrs  : list[ICustomAttribute]
      )        : void
    {
      WriteCustomAttributeList(attrs, null)
    }

    private WriteCustomAttributeList
      ( attrs  : list[ICustomAttribute]
      , target : string
      )        : void
    {
      when (_configuration.ShowCustomAttributes && !attrs.IsEmpty)
      {
        if (target != null)
        {
          attrs.Iter(attr =>
            {
              Write("[");
              WriteKeyword(target);
              Write(": ");
              WriteCustomAttribute(attr);
              WriteLine("]");
            })
        }
        else
          WriteList(attrs, "[", "]", WriteCustomAttribute);
        WriteLine();
      }
    }

    private WriteOptionIndent() : void
    {
      when (_configuration.OptionIndent)
        WriteIndent();
    }

    private WriteOptionOutdent() : void
    {
      when (_configuration.OptionIndent)
        WriteOutdent();
    }

    private WriteDocumentation(value : IDocumentationProvider ) : void
    {
      when (_configuration.ShowDocumentation)
      {
        def doc = value.Documentation;
        unless (string.IsNullOrEmpty(doc))
        {
          using (rdr = StringReader(doc))
          {
            while (rdr.Peek() != -1)
            {
              def line = rdr.ReadLine();
              WriteComment("/// ");
              WriteComment(line);
              WriteLine();
            }
          }
        }
      }
    }

    private WriteGenericParameterConstraint(value : IType) : void
    {
    | _ is IDefaultConstructorConstraint =>
      WriteKeyword("new");
      Write("()");
    | _ is IReferenceTypeConstraint      =>
      WriteKeyword("class");
    | _ is IValueTypeConstraint          =>
      WriteKeyword("struct");
    | _                                                  =>
      WriteType(value);
    }

    private WriteGenericParameterConstraintList(lst : list[IType]) : void
    {
      lst.Iter(e =>
        {
        | p is IGenericParameter when p.Constraints.Count != 0 =>
          Write(" ");
          WriteKeyword("where");
          Write(" ");
          Write(p.Name);
          Write(" : ");

          WriteList(p.Constraints.ToList(), WriteGenericParameterConstraint);
        | _                                                    => ()
        }
      );
    }

    private WriteParameterDeclaration(value : IParameterDeclaration ) : void
    {
      WriteList(value.Attributes.ToList(), "[", "] ", WriteCustomAttribute);
      // TODO: out/ref, parms; default value
     def name = if (value.Name.StartsWith("_N_")) "_" else value.Name;
     WriteIdentifier(name);
     Write(" : ");
     WriteType(value.ParameterType);
    }

    private WriteMethodVisibility(value : MethodVisibility) : void
    {
      WriteKeyword(
        match (value)
        {
        | MethodVisibility.Private
        | MethodVisibility.PrivateScope      => "private"
        | MethodVisibility.FamilyAndAssembly => "protected internal"
        | MethodVisibility.Assembly          => "internal"
        | MethodVisibility.Family            => "protected"
        | MethodVisibility.FamilyOrAssembly  => "internal protected"
        | MethodVisibility.Public            => "public"
        | _                                  => throw NotSupportedException()
        });
      Write(" ");
    }

    private EscapeString(value : string) : string
    {
      def builder = StringBuilder(value.Length * 2);
      for (mutable i = 0; i < value.Length; ++i)
        _ = builder.Append(EscapeChar(value[i]));

      builder.ToString();
    }

    private EscapeChar(value : char) : string
    {
    | '\\' => @"\\";
    | '\'' => @"\'";
    | '\0' => @"\0";
    | '\b' => @"\b";
    | '\t' => @"\t";
    | '\n' => @"\n";
    | '\r' => @"\r";
    | '"'  => @"""";
    | _ when value < ' '     =>
      @"\x" + (value :> IFormattable).ToString("X2", CultureInfo.InvariantCulture);
    | _ when value > '\x100' =>
      @"\u" + (value :> IFormattable).ToString("X4", CultureInfo.InvariantCulture);
    | _                      =>
      value.ToString();
    }

    #endregion

    #region Keywords

    protected override EscapeKeyword(value : string) : string
    {
      "@" + value;
    }

    protected override GetKeywords() : Set[string]
    {
      Set(
      [ "abort",     "abstract", "and",        "array",   "as",        "assert"
      , "base"
      , "catch",     "class"
      , "def",       "delegate", "do"
      , "else",      "enum",     "event",      "extends", "extern"
      , "false",     "finally",  "for",        "foreach", "fun"
      , "if",        "ignore",   "implements", "in",      "interface", "internal"
      , "lock"
      , "macro",     "match",    "module",     "mutable"
      , "namespace", "new",      "null"
      , "out",       "override"
      , "params",    "private",  "protected",  "public"
      , "ref"
      , "sealed",    "static",   "struct",     "syntax"
      , "this",      "throw",    "true",       "try",     "type",      "typeof"
      , "unless",    "using"
      , "variant",   "virtual"
      , "when",      "where",    "while"
      ]);
    }

    protected override GetTypes() : Map[string, string]
    {
      Map()
        .Add("System.Boolean", "bool")
        .Add("System.Byte",    "byte")
        .Add("System.Char",    "char")
        .Add("System.Decimal", "decimal")
        .Add("System.Double",  "double")
        .Add("System.Int16",   "short")
        .Add("System.Int32",   "int")
        .Add("System.Int64",   "long")
        .Add("System.Object",  "object")
        .Add("System.SByte",   "sbyte")
        .Add("System.Single",  "float")
        .Add("System.String",  "string")
        .Add("System.UInt16",  "ushort")
        .Add("System.UInt32",  "uint")
        .Add("System.UInt64",  "ulong")
        .Add("System.Void",    "void")
        ;
      }

    protected override GetSpecialMethods() : Map[string, string]
    {
      Map()
        .Add("op_UnaryPlus", "+")
        .Add("op_Addition", "+")
        .Add("op_Increment", "++")
        .Add("op_UnaryNegation", "-")
        .Add("op_Subtraction", "-")
        .Add("op_Decrement", "--")
        .Add("op_Multiply", "*")
        .Add("op_Division", "/")
        .Add("op_Modulus", "%")
        .Add("op_BitwiseAnd", "&")
        .Add("op_BitwiseOr", "|")
        .Add("op_ExclusiveOr", "^")
        .Add("op_Negation", "!")
        .Add("op_OnesComplement", "~")
        .Add("op_LeftShift", "<<")
        .Add("op_RightShift", ">>")
        .Add("op_Equality", "==")
        .Add("op_Inequality", "!=")
        .Add("op_GreaterThanOrEqual", ">=")
        .Add("op_LessThanOrEqual", "<=")
        .Add("op_GreaterThan", ">")
        .Add("op_LessThan", "<")
        .Add("op_True", "true")
        .Add("op_False", "false")
        .Add("op_Implicit", "implicit")
        .Add("op_Explicit", "explicit")
        ;
    }

    #endregion

  }
}
