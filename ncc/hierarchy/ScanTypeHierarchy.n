/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

namespace Nemerle.Compiler
{
  public module ScanTypeHierarchy
  {
    private handle_type (parent : option [TypeBuilder], vop : option [TypeBuilder], 
                         env : GlobalEnv, t : TopDeclaration) : void
    {
      match (t) {
        | TopDeclaration.Macro (header, synt, expr) =>
          Macros.GenerateMacroClass (env, parent, t.modifiers, header,
                                     synt, expr)

        | TopDeclaration.Delegate (header) =>
          Delegates.GenerateDelegateClass (env, parent, t.modifiers, header)

        | _ =>
          def ti = GlobalEnv.AddType (parent, vop, env, t);
          def me = Some (ti);
          def env_in_type = env.EnterIntoNamespace (t.name.GetIdList ());

          match (t) {
            | TopDeclaration.VariantOption (ds)
            | TopDeclaration.Interface { methods = ds }
            | TopDeclaration.Class { decls = ds } =>
              foreach (ClassMember.TypeDeclaration (t) in ds)
                handle_type (me, None (), env_in_type, t)

            | (TopDeclaration.Variant) as td_v =>
              def fixup_option (x) {
                | ClassMember.EnumOption (None) =>
                  def d = TopDeclaration.VariantOption (loc = x.loc, 
                                             name = x.name, 
                                             modifiers = x.modifiers,
                                             decls = []);
                  ClassMember.TypeDeclaration (x.loc, x.name, x.modifiers, d)
                | _ => x
              }

              td_v.decls = List.Map (td_v.decls, fixup_option);

              foreach (x in td_v.decls) {
                match (x) {
                  | ClassMember.TypeDeclaration (TopDeclaration.VariantOption as d) =>
                    handle_type (me, me, env_in_type, d)

                  | ClassMember.EnumOption =>
                    Message.error ("variant options cannot have value, they are not enums")
                  | _ => ()
                }
              }

            | TopDeclaration.Enum => ()
            | TopDeclaration.Alias => ()
            | TopDeclaration.Macro => assert (false)
            | TopDeclaration.Delegate => assert (false)
            | TopDeclaration.Namespace => Message.fatal_error ("namespace nesting inside type is not allowed")
            | TopDeclaration.Using => Message.fatal_error ("namespace import inside type is not allowed") 
            | TopDeclaration.UsingAlias => Message.fatal_error ("namespace alias inside type is not allowed") 
            | TopDeclaration.Attribute => Message.fatal_error ("assembly attribute inside type is not allowed") 
          };
          when (ti != null)
            ti.ReverseChildren ();
      }
    }

    /** This function does the very first pass, after parsing.  It changes 
        open/namespace declaration into appropriate entries in [GlobalEnv] class.
        It also creates [TypeBuilder] object for each type and registers it
        with global name environment.  */
    public ProcessDeclaration (decl : TopDeclaration, env : GlobalEnv) : GlobalEnv 
    {
      match (decl) {
        | TopDeclaration.Namespace (d) =>
          def env' = env.EnterIntoNamespace (decl.name.GetIdList ());
          _ = List.FoldLeft (d, env', ProcessDeclaration);
          env

        | TopDeclaration.Using =>
          env.AddOpenNamespace (decl.name.GetIdList (), decl.loc);

        | TopDeclaration.UsingAlias (s) =>
          env.AddNamespaceAlias (s, decl.name.GetIdList (), decl.loc);

        | TopDeclaration.Attribute (body) =>
          AttributeCompiler.AddAssemblyAttribute (env, body);
          env

        | d =>
          handle_type (None (), None (), env, d);
          env
      }
    }
  } // module ScanTypeHierarchy
} // N.C
