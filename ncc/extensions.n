(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler.Extensions;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Extensions {

  public implicit_ctor (par : Tyinfo) : Class_member
    {
      def collect (acc : list (PT.Expr) * list (Fun_parm), decl : Class_member) 
                  : list (PT.Expr) * list (Fun_parm)
        {
          match (decl) {
            | M_field (t, _) =>
              def n = decl.name;
              def fp = Fun_parm (loc = par.loc, name = n, ty = t, decl = null);
              def ex = PT.E_assign (PT.E_member (PT.E_this (), PT.SS_string (n)), 
                                    PT.E_ref (n));
              def (es, ps) = acc;
              (ex :: es, fp :: ps)
            | _ => acc
          }
        };
      def (assigns, parms) = List.fold_left (collect, ([], []), par.member_list);
      def fh = Fun_header (loc = par.loc, 
                           name = ".ctor", 
                           id = Util.next_id (),
                           ret_type = T_void (), 
                           parms = List.rev (parms),
                           typarms = [],
                           tenv = par.tenv,
                           closure_vars = []);
      def body = PT.E_sequence (assigns);
      body.loc <- par.loc;
      def f = M_function (fh, FK_ctor (), FB_parsed_expr (body));
      f.modifiers <- [Mod_public ()];
      f.name <- fh.name;
      f.loc <- fh.loc;
      f.id <- fh.id;
      f
    }
        
  private class WhileMacro implements IMacro {
    
    Run (args : list (PT.Parm)) : PT.Expr 
      implements IMacro.Run
    {
      match (args) {
        | [ {is_ref = false; name = ""; expr = cond }; 
            {is_ref = false; name = ""; expr = body } ] =>
            
            <[ { def _N_whileloop () : void {
                    if ($cond) { $body; _N_whileloop() } 
                    else () 
                  }; 
                  _N_whileloop (); 
               } ]>

        | _ => 
          Message.fatal_error ("while macro expects two arguments")
      }
    }

    GetName () : string 
      implements IMacro.GetName 
    { "while" }
    
    public this () {}
  }

  private class PrintfMacro implements IMacro {

    get_params (pa : list (PT.Parm)) : list (PT.Expr)
    {
      def get_parm (p : PT.Parm) : PT.Expr { p.expr };
      List.map (get_parm, pa)
    }
    
    variant Token {
      | Text { body : string; }
      | TextNewline { body : string; }
      | Number
      | Str
    }

    parse_format (form : string) : list(Token)
    {
      mutable i <- 0;
      mutable escape <- false;
      mutable buf <- System.Text.StringBuilder ();
      mutable result <- [];
      def n = form.Length;
      
      while (i < n, { 
        if (!escape) {
          match (form[i]) {
            | '%' =>
              // % occured, first dump text from buffer
              if ( buf.Length > 0 ) {
                result <- Text (buf.ToString ()) :: result;
                buf <- buf.Remove (0, buf.Length);
              }
              else ();
              // now analyze next character
              i <- i + 1;
              if ( i < n ) {
                match (form[i]) {
                  | 'd' => result <- Number () :: result
                  | 's' => result <- Str () :: result
                  | _ => 
                    Message.error ("Unsupported formatting sequence after % character")
                }
              }
              else
                Message.error ("Unexpected end of format after % character")
            | '\\' =>
              escape <- true
            | c =>
              buf <- buf.Append (c)
          }
        }
        else {
          match (form[i]) {
            | 'n' => 
              result <- TextNewline (buf.ToString ()) :: result;
              buf <- buf.Remove (0, buf.Length)
            | c =>
              buf <- buf.Append (c);
          };

          escape <- false;
        };

        i <- i + 1;
      });

      // the result is reversed, but our next function will reverse it again
      result
    }

    Run (args : list (PT.Parm)) : PT.Expr 
      implements IMacro.Run
    {
      def arguments = this.get_params (args);

      match (arguments) {
        | PT.E_literal (L_string (format)) :: parms =>
          def tokens = this.parse_format (format);
          def make_expressions (toks : list(Token), parms : list(PT.Expr), 
                                acc : list(PT.Expr)) : list(PT.Expr) {
            match ((toks, parms)) {
              | ([], []) => acc
              | (Text (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.Write ($(PT.E_literal (L_string (t)))) ]> :: acc)
              | (TextNewline (t) :: xs, _) => 
                make_expressions (xs, parms, 
                  <[ System.Console.WriteLine ($(PT.E_literal (L_string (t)))) ]> :: acc)
              | (Number :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : int)) ]> :: acc)
              | (Str :: xs, p :: ps) =>
                make_expressions (xs, ps, <[ System.Console.Write (($p : string)) ]> :: acc)
              | (_, _ :: _) =>
                Message.error ("too many arguments for printf macro");
                acc
              | (_ :: _, _) =>
                Message.error ("not enough arguments for printf macro");
                acc
            }
          };
          
          def seq = make_expressions (this.parse_format (format), List.rev (parms), []);
          <[ {.. $seq } ]>
        | _ => 
          Message.fatal_error ("printf macro expects formating string as first argument")
      }
    }
    GetName () : string 
      implements IMacro.GetName 
    { "printf" }
    
    public this () {}
  }
 
  static this () {
    MacroRegistry.register_macro (WhileMacro ());
    MacroRegistry.register_macro (PrintfMacro ())
  }
  
} // end module Extensions
} // end ns
