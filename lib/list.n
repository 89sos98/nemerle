/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/* TYPE DEFINITION */

public variant list <'a> 
{
  | Cons { hd : 'a; tl : list <'a>; }
  | Nil {}
}

  
namespace Nemerle.Collections 
{
  public module List
  {
    /* -- ENUMERATION SUPPORT   -------------------------------------------- */

    /**
     * Creates enumerator for elements of list.
     */
    public GetEnumerator<'a> (l : list<'a>) : IEnumerator<'a>
    {
      ListEnumerator(l)
    }


    /* -- CONVERSION OPERATIONS -------------------------------------------- */
  
    /**
     * Converts an array into a list.
     */  
    public FromArray<'a> (x : array <'a>) : list <'a> {
      def array_length = (x : System.Array).Length;
        
      def loop (index : int) : list <'a> {        
        if (index < array_length)
          x [index] :: loop (index + 1)
        else
          []
      };
    
      loop (0)
    }
    
    

    /* -- BASIC LIST OPERATIONS -------------------------------------------- */

    /**
     * Returns true if the given list is empty.
     */
    public IsEmpty<'a> (l : list <'a>) : bool {
      match (l) {
        | Nil => true
        | _ => false
      }
    }
    
    /**
     * Returns length of given list. Time O(n), Mem O(1).
     */
    public Length<'a> (x : list <'a>) : int {
      def loop (acc : int, x : list <'a>) : int {
        match (x) {
          | _ :: xs => loop (acc + 1, xs)
          | _ => acc
        }
      };
      loop (0, x)
    }
    
    
    /**
     * Returns head (first element) of list.
     * Given empty list throws System.ArgumentException.
     */
    public Head<'a> (l : list <'a>) : 'a {
      match (l) {
        | x :: _ => x
        | [] => throw System.ArgumentException ("List.Head called with empty list");
      }
    }
    
    /**
     * Alias for Head(l).
     */
    public Hd<'a> (l : list <'a>) : 'a {
      Head (l)
    }
    
    /**
     * Returns tail (all elements except first one) of list.
     */
    public Tail<'a> (l : list <'a>) : list <'a> {
      match (l) {
        | _ :: tl => tl
        | [] => throw System.ArgumentException ("List.Tail called for empty list")
      }
    }
    
    /**
     * Alias for Tail(l).
     */
    public Tl<'a> (l : list <'a>) : list <'a> {
      Tail (l)
    }
    
    /**
     * Returns n-th element of list, where 0-th is head.
     * Throws InvalidArgument exception when given too short list.
     * Works in time O(n) and memory O(1).
     */
    public Nth<'a> (l : list <'a>, n : int) : 'a {
      match (l) {
        | h :: t => 
          if ( n == 0 )
            h
          else
            Nth(t, n-1)
        | [] => throw System.ArgumentOutOfRangeException ("List.Nth")
      }
    }

    /**
     * Returns last element of list.
     * Given empty list throws InvalidArgument exception.
     * Works in time O(n) and memory O(1).
     */
    public Last<'a> (l : list <'a>) : 'a {
      match (l) {
        | [x] => x
        | _ :: xs => Last (xs)
        | [] => throw System.ArgumentException ("List.Last called for empty list")
      }
    }


    /**
     * Returns reversed list, i.e. Rev([1;2;3]) = [3;2;1].
     * Works in time and memory O(n).
     */
    public Rev<'a> (l : list <'a>) : list <'a> {
      def loop (acc : list <'a>, l : list <'a>) : list <'a> {
        match (l) {
          | x :: xs => loop (x :: acc, xs)
          | [] => acc
        }
      };
      loop ([], l)
    }
    
    /**
     * Returns list made from appending list y at end of list x.
     * Original list are not modified.
     * Works in time and memory O(length(x)).
     */
    public Append<'a> (x : list <'a>, y : list <'a>) : list <'a> {
      match (x) {
        | [] => y
        | x :: xs => x :: Append (xs, y)
      }
    }
    
    /**
     * Equivalent to Append(Rev(x),y).
     */
    public RevAppend<'a> (x : list <'a>, y : list <'a>) : list <'a> {
      match (x) {
        | h :: t => RevAppend(t, h :: y)
        | [] => y
      }
    }
    
    /**
     * Makes list one level more flat, i.e. Concat([[1;2];[3;4]]) = [1;2;3;4].
     * Does not work deeper, i.e. Concat([[[1;2];[3]];[[4]]]) = [[1;2];[3];[4]].
     */
    public Concat<'a> (l : list <list <'a>>) : list <'a> {
      FoldLeft(Append, [], l)
    }    

    /**
     * Alias for Concat(l).
     */
    public Flatten<'a> (l : list <list <'a>>) : list <'a> {
      Concat(l)
    }

    /**
     * Returns list l without elements equal to x.
     */
    public Remove<'a> (x : 'a,l : list<'a>) : list<'a> {
      def loop (acc : list <'a>,from : list<'a>) : list<'a> {
        match (from) {
          | [] => List.Rev(acc)
          | y :: ys  => loop( if ( y == x ) acc else y::acc ,ys)
        }
      };
      loop ([], l)
    }
    
    
    /* -- ITERATORS -------------------------------------------------------- */
    
    public Iter<'a> (f : 'a -> void, l : list <'a>) : void {
      match (l) {
        | x :: xs => f (x); Iter (f, xs)
        | [] => ()
      }
    }

    public Map<'a, 'b> (f : 'a -> 'b, x : list <'a>) : list <'b> {
      match (x) {
        | [] => []
        | x :: xs => f (x) :: Map (f, xs)
      }
    }

    public RevMap<'a, 'b> (f : 'a -> 'b, x : list <'a>) : list <'b> {
      def loop (acc : list <'b>, x : list <'a>) : list <'b> {
        match (x) {
          | h :: t => loop (f (h) :: acc, t)
          | [] => acc
        }
      };
      loop ([], x)
    }

    public FoldLeft<'a, 'b> (f : 'b * 'a -> 'b, acc : 'b, l : list <'a>) : 'b {
      match (l) {
        | [] => acc
        | x :: xs => FoldLeft (f, f (acc, x), xs)
      }
    }

    public FoldRight<'a, 'b> (f : 'a * 'b -> 'b, l : list <'a>, b : 'b) : 'b {
      match (l) {
        | [] => b
        | x :: xs => f (x, FoldRight (f, xs, b))
      }
    }
    

    /* -- ITERATORS ON TWO LISTS ------------------------------------------- */
    
    public Iter2<'a, 'b> (f : 'a  * 'b -> void, a : list <'a>, b : list <'b>) : void {
      match ((a, b)) {
        | ([], []) => ()
        | (x :: xs, y :: ys) => f (x, y); Iter2 (f, xs, ys)
        | _ => throw System.ArgumentException ("List.Iter2")
      }
    }

    public Map2<'a, 'b, 'c> (f : 'a * 'b -> 'c, x : list <'a>, y : list <'b>) : list <'c> {
      match ((x, y)) {
        | ([], []) => []
        | (x :: xs, y :: ys) => f (x, y) :: Map2 (f, xs, ys)
        | _ => throw System.ArgumentException ("List.Map2")
      }
    }

    public RevMap2<'a,'b,'c> (f : 'a * 'b -> 'c, x : list <'a>, y : list <'b>) 
    : list <'c> 
    {
      def loop (acc : list <'c>, x : list <'a>, y : list <'b>) : list <'c> {
        match ((x, y)) {
          | ([], []) => []
          | (x :: xs, y :: ys) => loop (f (x, y) :: acc, xs, ys)
          | _ => throw System.ArgumentException ("List.RevMap2")
        }
      };
      loop([], x, y)
    }

    public FoldLeft2<'a, 'b, 'c> (f : 'c * 'a  * 'b -> 'c, acc : 'c, a : list <'a>, b : list <'b>) : 'c {
      match ((a, b)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => FoldLeft2 (f, f (acc, x, y), xs, ys)
        | _ => throw System.ArgumentException ("List.FoldLeft2")
      }
    }

    public FoldRight2<'a, 'b, 'c> (f : 'a * 'b  * 'c -> 'c, a : list <'a>, b : list <'b>, c : 'c) : 'c {
      match ((a, b)) {
        | ([], []) => c
        | (x :: xs, y :: ys) => f (x, y, FoldRight2 (f, xs, ys, c))
        | _ => throw System.ArgumentException ("List.FoldRight2")
      }
    }


    /* LIST SCANNING */


    public ForAll<'a> (f : 'a -> bool, l : list <'a>) : bool {
      match (l) {
        | x :: xs => f (x) && ForAll (f, xs)
        | [] => true
      }
    }

    public Exists<'a> (f : 'a -> bool, l : list <'a>) : bool {
      match (l) {
        | [] => false
        | h :: t => f (h) || Exists (f, t)
      }
    }

    public ForAll2<'a, 'b> (f : 'a * 'b -> bool, a : list <'a>, b : list <'b>) : bool {
      match ((a, b)) {
        | ([], []) => true
        | (x :: xs, y :: ys) => f (x, y) && ForAll2 (f, xs, ys)
        | _ => throw System.ArgumentException ("List.ForAll2")
      }
    }

    public Exists2<'a, 'b> (f : 'a * 'b -> bool, a : list <'a>, b : list <'b>) : bool {
      match ((a,b)) {
        | ([], []) => false
        | (x :: xs, y :: ys) => f(x,y) || Exists2(f,xs,ys)
        | _ => throw System.ArgumentException ("List.Exists2")
      }
    }

    // FIXME: we don't have mem, as == is physical equality
    public Memq<'a> (a : 'a, l : list <'a>) : bool {
      match (l) {
        | h :: t  => h == a || Memq (a,t)
        | [] => false
      }
    }

    
    /* -- LIST SEARCHING --------------------------------------------------- */
    
    
    public Find<'a> (pred : 'a -> bool, l : list <'a>) : option <'a> {
      match (l) {
        | h :: t => if ( pred(h) ) Some (h) else Find (pred, t)
        | [] => None ()
      }
    }

    public Filter<'a> (f : 'a -> bool, l : list <'a>) : list <'a> {
      match (l) {
        | x :: xs =>
          if (f (x)) x :: Filter (f, xs)
          else Filter (f, xs)
        | [] => []
      }
    }

    public FindAll<'a> (f : 'a -> bool, l : list <'a>) : list <'a> {
      Filter(f, l)
    }

    public Partition<'a> ( pred : 'a -> bool, l : list <'a>) : list <'a> * list <'a> {
      def loop (l : list <'a>, sat : list <'a>, notsat : list <'a>) 
            : list <'a> * list <'a> 
      {
        match (l) {
          | h :: t => 
            if (pred (h)) 
              loop (t, h :: sat, notsat)
            else 
              loop (t, sat, h :: notsat)
          | [] => (Rev (sat), Rev (notsat))
        }
      };
      loop (l, [], [])  
    }

    /**
     * Groups equal element into lists
     */
    public Group<'a> (cmp : 'a * 'a -> int, l : list <'a>) : list <list <'a>>
    {
      def walk (l : list <'a>, acc : list <'a>) : list <list <'a>> {      

        def h = List.Head (acc);
      
        match (l) {
          | e :: rest =>
            if (cmp (e, h) == 0)
              walk (rest, e :: acc)
            else
              acc :: walk (rest, [e])
          | [] => [acc]
        }
      };

      if (List.IsEmpty (l)) []
      else {
        def sorted = List.Sort (cmp, l);
      
        walk (List.Tail (sorted), [List.Head (sorted)])
      }
    }


    /* -- ASSOCIATION LISTS ------------------------------------------------ */
    
    // FIXME: == is physical equality
    public Assoc<'a, 'b> (key : 'a, l : list <'a * 'b>) : option <'b> {
      match (l) {
        | (k, v) :: t =>
          if (key == k)
            Some (v)
          else
            Assoc (key, t)
        | [] => None ()
      }
    }

    public MemAssoc<'a, 'b> (key : 'a, l : list <'a * 'b>) : bool {
      match (l) {
        | (k, _) :: t =>
          if (key == k)
            true
          else
            MemAssoc (key, t)
        | [] => false
      }
    }

    public RemoveAssoc<'a, 'b> (key : 'a, l : list <'a * 'b>) : list <'a * 'b> {
      def loop (acc : list <'a * 'b>, l : list <'a * 'b>) : list <'a * 'b>
      {
        match (l) {
          | (k, v) :: t => 
              if (key == k)
                loop (acc, t)
              else
                loop ((k, v) :: acc, t)
          | [] => Rev (acc)
        }
      };
      loop ([], l)  
    }


    /* -- LISTS OF PAIRS --------------------------------------------------- */

    
    public Split<'a, 'b> (l : list <'a * 'b>) : list <'a> * list <'b> {
      def loop (acc1 : list <'a>, acc2 : list <'b>, l : list <'a * 'b>) : list <'a> * list <'b> 
      {
        match (l) {
          | (a, b) :: t => loop (a :: acc1, b :: acc2, t)
          | [] => (Rev (acc1), Rev (acc2))
        }
      };
      loop([], [], l)
    }

    public Combine<'a, 'b> (a : list <'a>, b : list <'b>) : list <'a * 'b> {
      def loop (acc : list <'a * 'b>, a : list <'a>, b : list <'b>) : list <'a * 'b> 
      {
        match ((a, b)) {
          | (x :: xs, y :: ys) => loop((x, y) :: acc, xs, ys)
          | ([], []) => Rev (acc)
          | _ => throw System.ArgumentException ("List.Combine")
        }
      };
      loop ([],a,b)
    }

    /* -- SORTING ---------------------------------------------------------- */
  
    MergeSort<'a> (cmp : ('a * 'a) -> int, l : list <'a>) : list <'a> {
      def split (l : list <'a>) : (list <'a> * list <'a>) {
        def aux (l : list <'a>, acc : list <'a>, n : int) : (list <'a> * list <'a>) {
          if (n == 0) 
            (List.Rev (acc), l)
          else 
            match (l) {
              | Nil => aux (l, acc, 0)
              | Cons(x, xs) => aux (xs, Cons (x, acc), (n - 1))
            }
        };
        aux (l, Nil(), (List.Length (l) / 2))
      };
      def merge (cmp : ('a * 'a) -> int, l1 : list <'a>, l2 : list <'a>) : list <'a> {
        def aux (l1 : list <'a>, l2 : list <'a>, acc : list <'a>) : list <'a> {
          match ((l1,l2)) {
            | (Nil, _) => List.Append (List.Rev (acc), l2)
            | (_, Nil) => List.Append (List.Rev (acc), l1)
            | (Cons (x, xs), Cons (y, ys)) => 
              if (cmp(x, y) > 0)
                aux (xs, Cons (y, ys), Cons (x, acc))
              else
                aux (Cons (x, xs), ys, Cons (y, acc))
          }
        };
        aux (l1, l2, Nil ())
      };

      match (l) {
        | Nil => l
        | Cons (_, Nil) => l
        | _ =>
          match (split (l)) {
            | (l1, l2) => merge (cmp, MergeSort (cmp, l1), MergeSort (cmp, l2))
        }
      }
    }

    public Sort<'a> (cmp : ('a * 'a) -> int, l : list <'a>) : list <'a> 
    {
      MergeSort (cmp, l)
    }

    public Copy<'a> (l : list <'a>) : list <'a> 
    {
      def loop (acc : list<'a>,what : list<'a>) {
        match (what) {
          | x::xs => loop (x::acc,xs)
          | [] => Rev (acc)
        }
      };
      loop ([],l)
    }

  } /* end of module List */



  class ListEnumerator<'a>
    : IEnumerator<'a>
    {
      private variant enuState {
        | BeforeFirst
        | Correct
        | AfterLast
      }

      mutable l       : list<'a>;
      mutable current : 'a;
      mutable rest    : list<'a>;
      mutable state   : enuState;

      public this (l : list<'a>) 
      {
        this.l     <- l;
        this.rest  <- l;
        this.state <- BeforeFirst ();
      }
      
      MoveNext () : bool 
      {
        def doMove() : bool 
        {
          match (rest) {
            | hd::tl => 
              {
                this.current <- hd;
                this.rest    <- tl;
                true
              }
            | _ => 
              {
                this.state <- AfterLast ();
                false
              }
          }       
        };

        match ( state ) {
          | BeforeFirst =>
              this.state <- Correct ();
              doMove ()
          | Correct     =>
              doMove ()
          | AfterLast =>
              throw System.InvalidOperationException ()
        }
      }

      Reset () : void
      {
        this.rest  <- this.l;
        this.state <- BeforeFirst ();
      }

      Current () : 'a 
      {
        match ( state ) {
          | Correct =>
              this.current
          | BeforeFirst 
          | AfterLast   => 
              throw System.InvalidOperationException ()
        }
      }
    } // end of class ListEnumertor



} /* end of namespace Nemerle.Collections */

