/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Text;
using Nemerle.Collections;

namespace Nemerle.Compiler {

public variant Token
{
  | Tok_identifier { name : string; }
  | Tok_keyword { name : string; }
  | Tok_tyvar { name : string; }
  | Tok_operator { name : string; priority : int; }

  | Tok_string_literal { value : string; }
  | Tok_number_literal { value : int; }
  | Tok_char_literal { value : char; }

  | Tok_EOF
}

public interface ILexer
{
  get_token () : Token;
  get_location () : Location;
}

public class Lexer implements ILexer
{
  file : System.IO.FileStream;
  file_name : string;
  mutable line : int;
  mutable col : int;
  mutable putback : bool;
  mutable putbackVal : char;
  
  mutable last_line : int;
  mutable last_col : int;
  
  static mutable keywords : Hashtable (string, bool);

  public class Error extends System.Exception
  {
    public name : string;
    public this (name : string) { this.name <- name; }
  }


  private check_last_line_for_lf () : void
  {
    def _ = file.Seek ((-1 :> System.Int64), System.IO.SeekOrigin.End);
    
    def inp = file.ReadByte ();
    
    if (inp >= 0) {
      def ch = System.Convert.ToChar (inp);
      when (ch != '\n') Message.warning (Location (file_name, line, col), "no new line at the end of the file");
    } else 
      throw Error ("unexpected end of file");
      
    def _ = file.Seek ((0 :> System.Int64), System.IO.SeekOrigin.Begin);
    
    ()
  }


  public this (fn : string)
  {
    file_name <- fn;
    file <- System.IO.FileStream (fn, System.IO.FileMode.Open, System.IO.FileAccess.Read);
    when (Flags.pedantic_lexer)
      check_last_line_for_lf ();
    line <- 1;
    col <- 1;
    putback <- false;
  }

  do_read () : char
  {
    def inp = file.ReadByte ();
    if (inp >= 0) {
      def ch = System.Convert.ToChar (inp);
      match (ch) {
        | '\n' =>
          line <- line + 1;
          col <- 1
        | '\r' =>
          when (Flags.pedantic_lexer)
            Message.warning (Location (file_name, line, col), "CR character found in input stream")
        | '\t' =>
          when (Flags.pedantic_lexer)
            Message.warning (Location (file_name, line, col), "tab character found in input stream")
        | _ =>
          col <- col + 1
      };
      ch
    } else 
      throw Error ("unexpected end of file")
  }
        
  read () : char
  {
    if (!putback)
      do_read ()
    else {
      def c = putbackVal;
      putback <- false;
      c
    }
  }

  peek () : char
  {
    unless (putback)
      putbackVal <- do_read ();
    putback <- true;
    putbackVal
  }

  is_id_beg (ch : char) : bool
  {
    System.Char.IsLetter (ch) || ch == '_'
  }

  static is_opchar (ch : char) : bool
  {
    match (ch) {
      | '=' | '<' | '>' | '@' | '^' | '|' | '&' | '+'
      | '-' | '*' | '/' | '$' | '%' | '!' | '?' | '~'
      | '.' | ':' | '#' | '[' | ']' => true
      | _ => false
    }
  }

  skip_comment () : void
  {
    mutable ch <- ' ';
    mutable seen_star <- false;

    while ({ch <- read (); !seen_star || ch != ')'}) {
      if (ch == '*')
        seen_star <- true
      else
        seen_star <- false
    }
  }

  skip_comment_new () : void
  {
    def loop (seen_star) {
      match (read ()) {
        | '*' => loop (true)
        | '/' when seen_star => ()
        | _ => loop (false)
      }
    };

    loop (false)
  }

  get_op (priority : int, first_ch : char) : Token
  {
    def buf = System.Text.StringBuilder ();
    
    ignore (buf.Append (first_ch));

    while (is_opchar (peek ())) { 
      ignore (buf.Append (read ()))
    };

    def s = buf.ToString ();
    match (s) {
      | "<-" => 
        // force low priority
        Tok_operator ("<-", 9)

      | "|" | ":" | ":>" | "=>" | "=" =>
        // cannot use this as regular operator
        Tok_operator (s, 0)
        
      | _ => 
        Tok_operator (s, priority)
    }
  }

  get_number (first_ch : char) : Token
  {
    def buf = System.Text.StringBuilder ();
    
    ignore (buf.Append (first_ch));

    while (System.Char.IsDigit (peek ())) {
      ignore (buf.Append (read ()))
    };

    Tok_number_literal (System.Int32.Parse (buf.ToString ()))
  }

  get_id (first_ch : char) : Token
  {
    if (first_ch == '\'' && !is_id_beg (peek ())) {
      get_char ()
    } else {
      def buf = System.Text.StringBuilder ();
      when (first_ch != '\'')
        ignore (buf.Append (first_ch));

      while (is_id_beg (peek ()) || 
             System.Char.IsDigit (peek ()) || 
             peek () == '\'') {
        ignore (buf.Append (read ()))
      };
          
      def str = buf.ToString ();
      
      if (first_ch == '\'' && str.Length == 2 && str[1] == '\'')
        Tok_char_literal (str[0])
      else if (first_ch == '\'')
        Tok_tyvar (str)
      else if (keywords.Contains (str))
        Tok_keyword (str)
      else
        Tok_identifier (str)
    }
  }

  escape_value (ch : char) : char
  {
    match (ch) {
      | 'n' => '\n'
      | 't' => '\t'
      | 'r' => '\r'
      | 'b' => '\b'
      | '"' => '"'
      | '\'' => '\''
      | '\\' => '\\'
      | '0' => (0 :> char)
      | _ => throw Error ("bad escape character")
    }
  }
    
  get_char () : Token
  {
    match (get_string ('\'')) {
      | Tok_string_literal (v) =>
        if (v.Length == 0)
          throw Error ("empty character literal")
        else {
          if (v.Length != 1)
            throw Error ("character literal too long")
          else
            Tok_char_literal (v[0])
        }
      | _ => Util.ice ("Value is not string in get_char")
    }
  }

  get_string (end_ch : char) : Token
  {
    def buf = StringBuilder ();
    mutable ch <- ' ';
              
    while (ch != end_ch) {
      ch <- read ();
      match (ch) {
        | '\\' =>
          ch <- read ();
          def esc = escape_value (ch);
          ignore (buf.Append (esc));
          ch <- ' ';
        | '\n' =>
          throw Error ("newline before end of string")
        | _ when ch != end_ch => ignore (buf.Append (ch))
        | _ => ()
      }
    };
     
    Tok_string_literal (buf.ToString ())
  }

  get_monkey_string () : Token
  {
    def buf = StringBuilder ();

    def loop () {
      match (read ()) {
        | '"' => Tok_string_literal (buf.ToString ())
        | ch => ignore (buf.Append (ch)); loop ()
      }
    };

    loop ()
  }

  do_get_token (ch : char) : Token
  {
    match (ch) {
      | ' ' | '\t' | '\r' | '\n' => get_token ()
      
      | '"' => get_string ('"')

      | '\'' => get_id ('\'')

      | '{' | '}' 
      | '[' | ']' 
      | ',' | ';' 
      | '.' 
      | '(' | ')' => Tok_operator (System.String (ch, 1), 0)

      | '@' =>
        def next = read ();
        if (is_opchar (next))
          match (get_op (0, next)) {
            | Tok_operator (s, _) => Tok_identifier (s)
            | _ => Util.ice ()
          }
        else if (is_id_beg (next))
          match (get_id (next)) {
            | Tok_identifier (x)
            | Tok_keyword (x) => Tok_identifier (x)
            | _ => Util.ice ()
          }
        else if (next == '"')
          get_monkey_string ()
        else
          throw Error ("expecting operator, identifier or string literal after '@'")
      
      | '*' =>
        if (peek () == '*')
          get_op (1, ch)
        else
          get_op (2, ch)

      | '/' =>
        if (peek () == '/') {
          while (read () != '\n') {};
          get_token ()
        } else if (peek () == '*') {
          ignore (read ());
          skip_comment_new ();
          get_token ()
        } else
          get_op (2, ch)
                              
      | '%' | '\\'
        => get_op (2, ch)
      
      | '+' | '-' 
        => get_op (3, ch)
      
      | '^' | '$' | '~' | '?' | '#'
        => get_op (4, ch)
        
      | '=' | '<' | '>' | '!' 
        => get_op (5, ch)
        
      | '&' => get_op (6, ch)
      | '|' => get_op (7, ch)
      | ':' => get_op (8, ch)

      | _ =>
        if (System.Char.IsDigit (ch))
          get_number (ch)
        else
          if (is_id_beg (ch))
            get_id (ch)
          else
            throw Error ("invalid character")
    }      
  }

  get_token () : Token
    implements ILexer.get_token
  {
    last_line <- line;
    last_col <- col;
    
    def ch = try Some (read ()) catch { _ : Error => None () };
   
    def ret =
      match (ch) {
        | Some (c) => do_get_token (c)
        | None => Tok_EOF ()
      };

    // Message.debug (Parser.token_name (ret));

    ret
  }

  get_location () : Location
    implements ILexer.get_location
  {
    Location (file_name, last_line, last_col)
  }

  get_current_location () : Location
  {
    Location (file_name, line, col)
  }

  public static this () 
  {
    def tab = array [
        "_", "abstract", "and", "array", "as", "base", "catch",
        "class", "def", "extends", "extern", "false", "finally", "fun",
        "implements", "interface", "internal", "macro", "match", "module",
        "mutable", "namespace", "new", "null", "out", "override",
        "params", "private", "protected", "public", "ref", "sealed",
        "static", "struct", "syntax", "this", "throw", "true", "try",
        "type", "typeof", "using", "variant", "virtual", "void", "when",
        "where"
    ];
    keywords <- Hashtable ();
    for (mutable i <- 0; i < (tab : System.Array).Length; i <- i + 1) {
      keywords.Add (tab[i], true)
    };
  }

  public static AddKeyword (str : string) : void 
  {
    keywords.Set (str, true);
  }

  public static IsOperator (str : string) : bool
  {
    def len = str.Length;
    mutable is <- true;
    for (mutable i <- 0; i < len && is; i <- i + 1) {
      def c = str[i];
      is <- is_opchar (c) || c == '(' || c == ')' || c == ';';
    };
    is
  }

  public static IsKeyword (str : string) : bool
  {
    def len = str.Length;
    mutable is <- true;
    for (mutable i <- 0; i < len && is; i <- i + 1)
      is <- System.Char.IsLetter (str[i]);
    is
  }
} // end class Lexer
} // end ns
