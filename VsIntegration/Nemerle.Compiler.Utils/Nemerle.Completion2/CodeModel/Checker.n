using System;
using System.Reflection;
using System.Diagnostics;

using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.Utils;

using Nemerle.Assertions;
using Nemerle.Imperative;
using Nemerle.Utility;

using SCG = System.Collections.Generic;

namespace Nemerle.Completion2
{
  internal class RegionsHelper
  {
    public static Collect(source : ISource, sourceVersion : int) : SCG.List[RegionInfo]
    {
      def compUnit    = source.CompileUnit;
      def regionsInfo = SCG.List();
      _ = RegionsHelper(source, regionsInfo, compUnit.TopNamespace.Decls, compUnit.Regions, sourceVersion);
      regionsInfo
    }
    
    private this(
      source        : ISource,
      regionsInfo   : SCG.List[RegionInfo],
      decls         : list[Decl],
      regions       : list[Region],
      sourceVersion : int
    )
    {
      _source         = source;
      _regions        = regionsInfo;
      _lineCount      = -1;
      _lastLineIndex  = -1;
      _afterUsingLine = int.MaxValue;
      _fileIndex      = source.FileIndex;
      _sourceVersion  = sourceVersion;

      foreach (r in regions)
      {
        //def col = GetLine(r.Location.Line).IndexOf('#') + 1;
        def text = if (r.Text.IsNullOrEmpty()) "#region" else r.Text;
        AddHiddenRegion(
          Location(_fileIndex, r.Location.Line, r.Location.Column,//col, 
            r.Location.EndLine, r.Location.EndColumn),
          text,
          false);
      }

      ProcessDecls(decls);
    }

    private AddHiddenRegion(location : Location, isExpanded : bool) : void
    {
      AddHiddenRegion(location, null, isExpanded);
    }

    private AddHiddenRegion(location : Location, text : string, isExpanded : bool) : void
    {
      when (location.Line <= 0)
      {
        Debug.WriteLine(location.ToString());
      }
      when (location.Line < location.EndLine)
        _regions.Add(RegionInfo(location, text, isExpanded));
    }

    _source          : ISource;
    _regions         : SCG.List[RegionInfo];

    mutable _lastLine       : string;
    mutable _lastLineIndex  : int;
    mutable _lineCount      : int;
    mutable _afterUsingLine : int;
            _fileIndex      : int;
            _sourceVersion  : int;
    
    

    //GetLine(lineIndex : int) : string 
    //{
    //  when (_lastLineIndex != lineIndex)
    //  {
    //    _lastLineIndex = lineIndex;

    //    _source.LockWrite();
    //    try
    //    {
    //      when (_sourceVersion != _source.CurrentVersion)
    //        throw CompilationAbortedException("collect regions");

    //      _lastLine      = _source.GetLine(lineIndex);
    //    }
    //    finally { _source.UnlockWrite(); }
    //  }

    //  _lastLine
    //}

    //GetLineCount() : int 
    //{
    //  when (_lineCount < 0)
    //    _lineCount = _source.LineCount;

    //  _lineCount
    //}

    //IsNext(line : int, col : int, ch : char) : bool 
    //{
    //  def str = GetLine(line);
    //  col > 0 && str.Length >= col && str[col - 1] == ch
    //}

    ////VladD2: А не лучше ли воспользоваться лексером? И ошибок меньше, и точность выше.
    //FindNext(lineIndex : int, col : int, text : string, eatComments : bool) : int * int 
    //{
    //  def endLine = Math.Max(GetLineCount(), lineIndex + 10);

    //  mutable c = col - 1;

    //  for (mutable l = lineIndex; l < endLine; l++)
    //  {
    //    mutable line = GetLine(l);

    //    def peek ()  { if (c < line.Length) line[c] else '\0' }
    //    def skip ()  { c++; }
    //    def peekn(i) { if (c + i < line.Length) line[c + i] else '\0' }
    //    def eol  ()  { c >= line.Length }

    //    while (!eol())
    //    {
    //      match (peek())
    //      {
    //      | '/' when l == lineIndex || eatComments => 

    //        match (peekn(+1))
    //        {
    //        | '/' 
    //        | '*' when line.IndexOf("*/", c) > 0 => c = int.MaxValue - 1;
    //        | '*' when eatComments =>

    //          for (l++; l < endLine; l++)
    //          {
    //            line = GetLine(l);
    //            c    = line.IndexOf("*/");

    //            when (c >= 0)
    //            {
    //              skip();
    //              break;
    //            }
    //          }

    //        | _ => ()
    //        }

    //      | '/'                     => 

    //        match (peekn(+1)) { | '/' | '*' => return (l, c + 1); | _ => () }

    //      | ch  when text[0] == ch  => 

    //        when (text.Length == 1 || line.Substring(c) == text)
    //          return (l, c + 1);

    //      | _ => ()
    //      }

    //      skip();
    //    }

    //    c = 0;
    //  }

    //  (lineIndex, col)
    //}

    CheckLine(line : int) : void
    {
      when (_afterUsingLine > line)
        _afterUsingLine = line;
    }

    AddRegion(loc : Location, isExpanded : bool) : void
    {
      when (!loc.IsEmpty)
      {
        def regLoc =  //if (IsNext(loc.Line, loc.Column, ' '))
                      //  Location(_fileIndex, loc.Line, loc.Column + 1, loc.EndLine, loc.EndColumn)
                      //else 
                        loc;
        AddHiddenRegion(regLoc, null, isExpanded);
        CheckLine(loc.Line);
      }
    }

    ProcessMatchCases(cases : list[MatchCase]) : void
    {
      //def nextCaseLocList =  cases.Map(c => c.PatternsLocation)

      foreach (case in cases)
        AddHiddenRegion(case.ArrowLocation.FromEnd() + case.BodyLocation, false);

        //AddHiddenRegion(
        //  Location(case.ArrowLocation.FileIndex, case.ArrowLocation.EndLine, case.ArrowLocation.EndColumn,
        //                                         case.BodyLocation.EndLine + 2, 1), false);

      //def walker = ExprWalker();
      //def locs   = cases.Map(c =>
      //  {
      //    mutable ploc = walker.GetLocation(c.patterns.Head);

      //    foreach (p in c.patterns.Tail)
      //      ploc = ploc.Combine(walker.GetLocation(p));

      //    (ploc, walker.GetLocation(c.body))
      //  });

      //def startLoc(ploc, bloc) 
      //{
      //  mutable line = bloc.Line;
      //  mutable col  = bloc.Column;

      //  //def str = GetLine(ploc.EndLine);
      //  //VladD2: Следующая строчка все время приводит к вылету (неверный индекс)
      //  // на файле Engine-main.n. IT, разберись, плиз. Пока что просто убрал
      //  // указание стартового индекса.
      //  def idx = -1;//str.IndexOf("=>"); //, ploc.EndColumn - 1

      //  when (idx >= 0)
      //  {
      //    line = ploc.EndLine;
      //    col  = idx + 3;
      //  }

      //  (line, col)
      //}

      //def loop(locs) 
      //{
      //  | (p1, b1) :: (p2, b2) :: t => 

      //    when (p1.EndLine + 1 < p2.Line)
      //    {
      //      def (line, col) = startLoc(p1, b1);
      //      def endLine     = p2.Line - 1;

      //      AddRegion(
      //        Location(_fileIndex, line, col, endLine, p2.EndColumn),//GetLine(endLine).Length + 1),
      //        false);
      //    }

      //    loop((p2, b2) :: t)

      //  | [(p, b)] =>

      //    _debug((p, b));

      //    //def     (line, col) = startLoc(p, b);
      //    //mutable eLine;
      //    //mutable eCol;

      //    //(eLine, eCol) = FindNext(b.EndLine, b.EndColumn, "}", false);

      //    //if (eLine == b.EndLine)
      //    //{
      //    //  when (eCol > 1 && eCol != b.EndColumn)
      //    //  {
      //    //    def line = GetLine(eLine);

      //    //    when (line[eCol - 2] == ' ' || line[eCol - 2] == '\t')
      //    //      eCol--;
      //    //  }
      //    //}
      //    //else
      //    //{
      //    //  def line = GetLine(eLine).Substring(0, eCol - 1);

      //    //  when (line.Trim(' ', '\t').Length == 0)
      //    //  {
      //    //    eLine--;
      //    //    eCol = GetLine(eLine).Length + 1
      //    //  }
      //    //}

      //    //AddRegion(Location(_fileIndex, line, col, eLine, eCol), false);

      //  | [] => ()
      //}

      //loop(locs);
    }

    ProcessExpr(pExpr : PExpr) : void
    {
      ExprWalker().Walk(pExpr, fun(info : ExprWalkInfo)
      {
        match (info.Node)
        {
        | PExpr.DefFunctions(funs) => // { funs : list [Function_decl]; }

          funs.Iter(f =>
          {
            mutable loc = f.header.Location.Combine(f.body.Location).TrimStart(f.header.Location, false);

            //when (IsNext(loc.Line, loc.Column, ' ') && IsNext(loc.Line, loc.Column + 1, ')'))
            //  loc = Location(loc.FileIndex, loc.Line, loc.Column + 1, loc.EndLine, loc.EndColumn);

            //when (IsNext(loc.Line, loc.Column, ')'))
            //  loc = Location(loc.FileIndex, loc.Line, loc.Column + 1, loc.EndLine, loc.EndColumn);

            AddRegion(loc, false);
          });

        | PExpr.Match(expr, cases, _) as m =>
          when (expr != null)
          {
            def loc  = expr.Location;
            def loc2 = Location(loc, loc.EndLine, loc.EndColumn + 1, m.Location.EndLine, m.Location.EndColumn);
            AddRegion(loc2, true);
          }
          ProcessMatchCases(cases);
        | <[ if ($_) $trueExpr else $faleExpr ]> =>
            AddRegion(trueExpr.Location, true);
            AddRegion(faleExpr.Location, true);
            
        | <[ when ($_) $expr ]> | <[ unless ($_) $expr ]> => AddRegion(expr.Location, true);
        | _ => ()
        }
      });
    }

    ProcessCustomAttributes(declarationBase : DeclarationBase) : void
    {
      AddHiddenRegion(declarationBase.modifiers.CustomAttributesLocation, "[custom attributes]",  false);
    }

    ProcessTopDeclaration(topDeclaration : TopDeclaration) : void
    {
      ProcessCustomAttributes(topDeclaration);
      
      when (topDeclaration is TopDeclaration.Delegate || topDeclaration is TopDeclaration.Alias)
        return;
				
      // TODO: Collapse all attributes to their own region.
      AddHiddenRegion(
        Location(_fileIndex,
                 topDeclaration.HeaderLocation.EndLine,
                 topDeclaration.HeaderLocation.EndColumn,
                 topDeclaration.Location.EndLine,
                 topDeclaration.Location.EndColumn),
        null,
        true);

      CheckLine(topDeclaration.Location.Line);

      // Get regions for members.

      def isProcessed(m)
      {
        m.modifiers == null 
        || !(m.Attributes %&& (NemerleAttributes.SpecialName | NemerleAttributes.Abstract))
      }
      
      match (topDeclaration)
      {
				| TopDeclaration.Interface     (methods = decls)
				| TopDeclaration.Class         (decls   = decls) 
				| Enum                         (decls   = decls)
				| TopDeclaration.VariantOption (decls   = decls)
				| TopDeclaration.Variant       (decls   = decls) =>
					foreach (member in decls.Filter(isProcessed))
					{
						| TypeDeclaration(td) => ProcessTopDeclaration(td)
						| Field 
						| Event 
						| EnumOption => 
							ProcessCustomAttributes(member);
							AddRegion(member.BodyLocation, true);
						| Property as p => ProcessProperty(p)
						| Function as f => ProcessFunction(f)
					}
				| _ => ()
      }
    }

    ProcessFunction(func : ClassMember.Function) : void
    {
		  ProcessCustomAttributes(func);
		  def headerLoc = func.header.Location;
		  if (headerLoc == Location.Default)
			  AddRegion(func.BodyLocation, true);
			else
			  AddRegion(headerLoc.FromEnd() + func.Location.FromEnd(), true);
			  
			when (func.body is FunBody.Parsed(expr))
			  ProcessExpr(expr);
    }

    ProcessProperty(prop : ClassMember.Property) : void
    {
		  ProcessCustomAttributes(prop);
		  if (prop.ty == null)
			  AddRegion(prop.BodyLocation, true);
			else
			  AddRegion(prop.ty.Location.FromEnd() + prop.Location.FromEnd(), true);
			  
			when (prop.get is Some(ClassMember.Function as f))
			  ProcessFunction(f);

			when (prop.set is Some(ClassMember.Function as f))
			  ProcessFunction(f);
    }

    ProcessDecls(decls : list[Decl]) : void
    {
      def usings = SCG.List();

      foreach (decl in decls)
      {
				| Decl.Type(ast) => ProcessTopDeclaration(ast)
				| Using as us => usings.Add(us); //when us.NameLocations.Exists(l => l.FileIndex == _fileIndex) 
				| Namespace(decls, _, locations, _, _, nsloc, _) => ProcessDecls(decls);
					match (locations.Find(l => l.FileIndex == _fileIndex))
					{
						| Some(loc) =>

							mutable lineStart = loc.EndLine;
							mutable colStart  = loc.EndColumn;
							mutable lineEnd   = nsloc.EndLine;
							mutable colEnd    = nsloc.EndColumn;

							//when (IsNext(lineStart, colStart, ' ')) colStart++;
							//when (IsNext(lineEnd,   colEnd,   '}')) colEnd++;

							AddHiddenRegion(Location(_fileIndex, lineStart, colStart, lineEnd, colEnd), null, true);
							CheckLine(lineStart);

						| None => ()
					}
				| _ => ()
      }

      when (usings.Count > 1)
      {
        mutable usingLoc;

        foreach (us in usings)
        {
          match (us.NameLocations.Find(l => l.FileIndex == _fileIndex))
          {
          | Some(loc) => 

            usingLoc = if (usingLoc.IsEmpty) loc else usingLoc.Combine(us.Location);

          | None      => ()
          }
        }

        when (!usingLoc.IsEmpty)
        {
          mutable lineStart = usingLoc.Line;
          mutable colStart  = usingLoc.Column;
          mutable lineEnd   = usingLoc.EndLine;
          mutable colEnd    = usingLoc.EndColumn;

          //when (_afterUsingLine != int.MaxValue)
          //{
          //  for (mutable i = lineEnd; i < _afterUsingLine; i++)
          //  {
          //    def str = GetLine(i);
          //    def idx = str.IndexOf(";");

          //    when (idx >= 0)
          //    {
          //      lineEnd = i;
          //      colEnd  = idx + 2;
          //      break;
          //    }
          //  }
          //}

          AddHiddenRegion(Location(_fileIndex, lineStart, colStart, lineEnd, colEnd), null, true);
        }
      }
    }

    _debug(obj : object) : void
    {
      when (obj != null)
        ignore(obj.ToString());
    }
  }
}
