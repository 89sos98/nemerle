(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(*
 * This is the main compiler file. But all it does it running parser
 * (parser.n) and transferring control to Passes.run function (from
 * passes.n).
 *
 * Main file also catches some exceptions.
 *)

open Nemerle.Collections;
open Nemerle.Utility;

namespace Nemerle.Compiler 
{
  module MainClass
  {
    public Main () : void
    {
      try
        do_main ()
      with {
        | e : System.IO.FileNotFoundException =>
          Message.error (e.Message)
        | e : Recovery =>
          bomb (e, "got Recovery exception")
        | e : Nemerle.Core.Invalid_argument =>
          bomb (e, "got Invalid_argument (" + e.msg + ")")
        | e : Nemerle.Core.Match_failure =>
          bomb (e, "got Match_failure exception")
        | e : ICE =>
          bomb (e, e.msg)
      };

      Message.maybe_bailout();
    }
    
    bomb (e : System.Exception, msg : string) : void
    {
      Message.maybe_bailout (true);
      print_string ("internal compiler error: " + msg + "\n" + e.StackTrace);
      System.Environment.Exit (1);
    }

    do_main () : void {
      mutable referenced_libs <- [];
      mutable files <- [];
      mutable do_xml <- false;

      def opts = [
        Getopt.Flag      (name = "-xml", 
                          aliases = ["-x"], 
                          help = "Output XML representation of AST (for documentation)",
                          handler = fun () { do_xml <- true; });
        Getopt.String    (name = "-reference",
                          aliases = ["-r"; "-ref"],
                          help = "Link specified assembly",
                          handler = fun (s) { referenced_libs <- s :: referenced_libs });
        Getopt.NonOption (name = "",
                          help = "Specify file to compile",
                          handler = fun (s) { files <- s :: files });
      ];

      Getopt.Parse (opts);

      match (files) {
        | [] =>
          Getopt.Error ("need at least one file to compile\n" + Getopt.Usage (opts))
        | _ =>
          def trees = List.fold_left (fun (acc, f) { Parser.parse (Lexer (f)) :: acc }, 
                                      [], List.rev (files));
          Passes.run (do_xml, trees, List.rev (referenced_libs))
      }
    }
  }
}
