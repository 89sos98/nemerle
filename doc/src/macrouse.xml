<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003, 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>Most interesting features we implemented using macros</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        This page is dedicated to features of Nemerle and its library, which
        was implemented using our <a ref="macros.html">meta-programming facilities</a>.
      </p>
      <p>
        Understanding how macros work is not necessary for using any of
        them. It would be useful only for knowing that those examples
        are only tip of iceberg called meta-programming and that you can easily
        implement even nicer things.
      </p>
    </body>
  </section>
  <section id="designbycontract">
    <title>Design by Contract</title>
      <body>
        <p>
          Languages like 
          <a ref="http://en.wikipedia.org/wiki/Eiffel_programming_language">Eiffel</a> 
          or 
          <a ref="http://research.microsoft.com/~leino/papers/krml136.pdf">Spec#</a> 
          incorporate methodology called 
          <a ref="http://en.wikipedia.org/wiki/Design_by_contract">Design by Contract</a>
          to reason about programs, libraries, methods. It helps people write more
          secure and correct software and specify its behavior.
        </p>
        <p>
          Language following this design must support writing explicit requirements 
          about values on which program operates. It contains:
        </p>
        <ul>
          <li>preconditions - some fact (boolean condition) that must be 
            satisfied in order to call a method, it mostly concerns passed
            parameters, but necessary
          </li>
          <li>postconditions - fact that must be satisfied after calling a method,
            for example about its return value
          </li>
          <li>invariants - property of program, which doesn't change in time (like
            nondecreasing order of elements in list, etc.)
          </li>
          <li>other restrictions in behavior of some part of program (like for example
            fact that method do not change state of class)
          </li>
        </ul>
        <p>
          We are currently on the way to add ability to define most of those features
          to Nemerle. In following subsections we present their current state, design
          and plans for future.
        </p>
        <subsection id="requires">
          <title>Preconditions - Requires attribute</title>
            <body>
              <p>
                If we want to state some condition, which must be satisfied when 
                calling a method, we write a special <tt>Requires</tt> attribute
                before it. It takes as a parameter an expression, which define
                the precondition.
              </p>
<code>
<![CDATA[
class String {
  [Requires (startIdx >= 0 && startIdx <= this.Length)]
  public Substring (startIdx : int) : string 
  { ... }
}
]]></code>
              <p>
                Using this attribute we can add arbitrary assertion, keeping
                body of method clean and verbose. Compiler automatically adds
                runtime checks at the beginning of method. If condition is
                violated, then <tt>AssertionException</tt> is being thrown with 
                an appropriate message containing this expression.
              </p>
              <p>
                Requires and other attributes can occur many times before a single
                method. They can be also defined directly on parameters.
              </p>
<code>
ConnectTrees ([Requires (!tree1.Cyclic ())] tree1 : Graph,
              [Requires (!tree2.Cyclic ())] tree2 : Graph, 
              e : Edge) : Graph 
{ ... }
</code>
            </body>
        </subsection>
        <subsection id="ensures">
          <title>Postconditions - Ensures attribute</title>
            <body>
              <p>
                Following the same design we can define postconditions which
                method must satisfy. This is an assertion, that must be true
                after execution of method. If method returns a value, then
                symbol <tt>value</tt> is available inside the expression
                stating an assertion.
              </p>
<code>
class LinkedList {
  [Ensures (IsEmpty ())]
  public Clear () : void
  { ... }

  [Ensures (value >= 0)]
  public Length () : int
  { ... }
}
</code>
            </body>
        </subsection>
        <subsection id="invariants">
          <title>Class invariants - Invariant attribute</title>
            <body>
              <p>
                Even more powerful feature is to give a conditions, which
                must be true all the time during execution of program.
                We can attach invariant to any class by writing <tt>Invariant</tt>
                attribute before its definition.
              </p>
<code>
<![CDATA[
[Invariant (position >= 0 && position <= arr.Length)]
class Vector <T> {
  private mutable position : int = 0;
  private arr : array <T> = array [];

  public push_back (x : T) : void 
  { ... }
]]></code>
              <p>
                This way we can control that our object it in some set of valid
                states.
              </p>
              <p>
                This naturally brings the problem with changing variables,
                which are dependent on each other in invariant. Suppose we have 
                an assertion <tt>x == y + 5</tt>, we cannot change any of the variables.
                Thus we need some mechanism for making transactions, within which
                invariants are temporarily ''turned off''.
              </p>
              <p>
                We follow the design of Spec# and add special construct to expose 
                the object to changes.
              </p>
<code>
expose (this) {
  x += 3;
  y += 3;
}
</code>
              <p>
                <tt>expose</tt> takes reference to the object to be exposed and
                executes given code.
              </p>
              <p>
                In the matter of fact invariants are not checked all the time during
                execution. It would be too expensive to validate them at any assignment
                or call to external function. We again follow design of Spec# and 
                run assertions at the end of <tt>expose</tt> blocks and after execution
                of all public methods.
              </p>
            </body>
        </subsection>
        <subsection id="dsc-future">
          <title>Future work</title>
            <body>        
              <p>
                There are few more things which we want to implement in more or
                less distant future:
              </p>
              <ul>
                <li> 
                  better syntax for those attributes 
<code>
class V { 
  invariant pos > 0; 

  Add (x : int) : void 
  requires x &lt; 0; 
  { ... } 
}
</code>
                </li>
                <li> 
                  Make these attributes inherited in classes deriving from those decorated
                  with assertions. For example we define an interface with preconditions
                  and postconditions and we can be sure, that every class implementing this
                  interface will comply to them.
                </li>
                <li>
                  Plug theorem prover designed for Spec# into Nemerle, so we can check
                  assertions not only in the runtime, but also statically at compile-time.
                </li>
                <li>
                  Invariant attribute needs much work to follow all functionality of
                  its Spec# counterpart.
                </li>
              </ul>
            </body>
        </subsection>
    </body>
  </section>
  <section id="checkedsql">
    <title>Compile-time validation of embedded SQL queries</title>
      <body>
        <p>
          As for now see 
          <a ref="http://nemerle.org/svn/nemerle/trunk/snippets/sql.n">this</a>.
	</p>
      </body>
  </section>
  <section id="aspects">
    <title>Aspects-Oriented programming</title>
      <body>
        <p>
          As for now see 
          <a ref="http://nemerle.org/svn/nemerle/trunk/ncc/testsuite/trace.n">this</a>.
	</p>
      </body>
  </section>
</document>
