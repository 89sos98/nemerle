open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Bind_types;

namespace Nemerle.Compiler {
(*
pass 2:
  Given a list of Type_decls resolve all Type_decl and Type variable
  references within it.
*)
  class Bind_types
    {
      type CTX = String_map(int);

      fun bind_type(env : Env, ctx : CTX, t : Type) : void =
        letfun self(t : Type) : void = bind_type(env, ctx, t) in
        match t with [
          | T_ref (?t) => self(t)
          | T_out (?t) => self(t)
          | T_fun (?ts, ?t) => { List.iter(self, ts); self(t) }
          | T_void => ()
          | T_prod (?ts) => List.iter(self, ts)
          | T_var ?v =>
            match ctx#find(v#name) with [
              | Some (?n) => v#ref_to <- n
              | None =>
                Message.error("unbound type variable " + v#name)
            ]
          | T_app ?a =>
            {
              a#ref_to <- (env#lookup_type(a#tycon))#id;
              List.iter(self, a#args)
            }
        ];
        
      fun add_tyvars(env : Env, ctx : CTX, tp : Typarms) : CTX =
        // this mess with two environments is here to detect possible error:
        // type ('a) foo { type ('b) where 'a :> t }
        letfun add (ctx : CTX * CTX, name : string) : CTX * CTX =
          let id = Tyvars.add(name) in
          let (?local, ?global) = ctx in
          (local#add(name, id), global#add(name, id))
        in 
        let (?local, ?global) = 
          List.fold_left(add, (Map.string_map(), ctx), tp#tyvars) 
        in
        letfun addc (c : Constraint) : void =
          match local#find(c#tyvar) with [
            | Some (?id) =>
              {
                Tyvars.add_constraint(id, c#ty);
                bind_type(env, global, c#ty)
              }
            | None =>
              Message.error("unbound type variable " + c#tyvar + " in constraint")
          ]
        in {
          List.iter(addc, tp#constraints);
          global
        };

      fun run(decls : list (Type_decl)) : void =
        letfun do_tydecl(ctx : CTX, decl : Type_decl) : CTX =
          let ctx' = add_tyvars(decl#env, ctx, decl#typarms) in
          let types =
            match decl#t_extends with [
              | Some (?t) => Cons (t, decl#t_implements)
              | None => decl#t_implements
            ]
          in letfun do_type(t : Type) : void = bind_type(decl#env, ctx', t) in {
            List.iter(do_type, types);
            match decl with [
              | TD_alias (?t) => do_type(t)
              | _ => ()
            ];
            ctx'
          }

        and do_expr(env : Env, ctx : CTX, expr : Expr) : void =
          letfun f(env : Env, expr : Expr) : Env = 
            let _ = expr#env <- env in
            match expr with [
              | E_letfun (?fs, ?b) =>
                  {
                    letfun add_fun (env : Env, d : Function_decl) : Env =
                      env#add_local(d#fun_header#name, Local_fun()) // FIXME set type?
                    in
                    let env' = List.fold_left(add_fun, env, fs) in
                    letfun do_fun (d : Function_decl) : void =
                      do_function(env', ctx, d#fun_header, FB_expr(d#body))
                    in {
                      List.iter (do_fun, fs); 
                      do_expr(env', ctx, b);
                      raise Treeutil.Skip_recursion();
                    }
                  }
              | E_lambda (?d) =>
                  {
                    do_function(env, ctx, d#fun_header, FB_expr(d#body));
                    env
                  }
              | E_try_with ?x =>
                  { 
                     bind_type(env, ctx, x#exn_ty);
                     do_expr(env, ctx, x#body);
                     let env' = env#add_local(x#exn, Local_exn(), x#exn_ty) in
                     do_expr(env', ctx, x#handler);
                     raise Treeutil.Skip_recursion();
                  }
              | E_let ?x =>
                  { 
                     do_expr(env, ctx, x#val);
                     let env' = env#add_local(x#name, Local_value(x#is_ref)) in
                     do_expr(env', ctx, x#body);
                     raise Treeutil.Skip_recursion();
                  }
              | E_type_conversion ?x => { bind_type(env, ctx, x#ty); env }
              | E_type_enforcement ?x => { bind_type(env, ctx, x#ty); env }
              | E_match (?ex, ?mcs) =>
                  {
                     do_expr(env, ctx, ex);
                     letfun do_case (c : Match_case) : void =
                       Util.locate(c#loc, fun () : void =>
                         letfun f(env : Env, p : Pattern) : Env =
                           match p with [
                             | P_variable (?n) =>
                               env#add_local(n, Local_pattern())
                             | _ => env
                           ]
                         in
                         let env' = Treeutil.pattern_fold(f, env, c#pattern) in
                         do_expr(env', ctx, c#body)
                       )
                     in List.iter(do_case, mcs);
                     raise Treeutil.Skip_recursion();
                  }
              | _ => env
            ]
          in Treeutil.expr_walk(f, env, expr)

        and do_header(env : Env, ctx : CTX, h : Fun_header) : CTX =
          //if env == null then Util.ice() else
          let ctx' = add_tyvars(env, ctx, h#typarms) in {
            bind_type(env, ctx', h#ret_type);
            letfun doparm(p : Fun_parm) : void = 
              bind_type(env, ctx', p#ty) 
            in List.iter(doparm, h#parms);
            ctx'
          }

        and do_function(env : Env, ctx : CTX, h : Fun_header, b : Fun_body) : void =
          let ctx' = do_header(env, ctx, h) in
          match b with [
            | FB_expr (?e) => do_expr(env, ctx', e)
            | FB_extern => ()
          ]
        
        and do_decl(ctx : CTX, decl : Class_member) : void =
          match decl with [
            | M_value (?t, _) => bind_type(decl#env, ctx, t)
            | M_field (?t, _) => bind_type(decl#env, ctx, t)
            | M_function (?h, _, ?b) => do_function (decl#env, ctx, h, b)
            | M_iface_method (_, ?h) =>
              let _ = do_header(decl#env, ctx, h) in ()
            | M_type => ()
          ]
        in 
        Treeutil.decl_walk(do_tydecl, do_decl, Map.string_map(), decls);
    }
  
} // end ns
