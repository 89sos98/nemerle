/*
 * Copyright (c) 2004 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler
{
  using Nemerle.Compiler;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Collections;
  using Nemerle.Utility;

  /**
   * Executed between cgexpr and cgil
   */
  internal class CGpost
  {
    internal Run (expr : CExpr) : CExpr
    {
      transform_try_blocks (true, expr);
      walk (expr, CgExprFlags.None)
    }
    
    internal static Postprocess (cgm : CG_method) : void
    {
      def th = CGpost ();
      def res = th.Run (cgm.body);
      unless (res == null)
        cgm.body = res;
    }


    /** 
        Walk given expression, requiring [flags]. If the expression cuts
        control flow, a new expression is returned (and the surrounding
        tree is rebuild accordingly, for example CExpr.CE_call(...) is
        transformed into cut down CExpr.CE_sequence). Otherwise (the normal
        case) null is returned.
     */
    walk (expr : CExpr, flags : CgExprFlags) : CExpr
    {
      //Message.debug ($ "walk ($expr)");
      def simple_walk (e) {
        walk (e, CgExprFlags.None)
      }

      def cannot_addr () {
        if (flags %&& CgExprFlags.NeedAddress &&
            CGexpr.type_of (expr).IsValueType)
          Message.error (expr.loc, "cannot load value type address for this expression")
        else if (flags %&& CgExprFlags.NeedLValue)
          Message.error (expr.loc, "this expression is not a proper lvalue")
        else ()
      }
      
      expr.flags = flags;

      def transform (e) {
        def e' = walk (e, CgExprFlags.None);
        if (e' == null) e
        else e'
      }

      def res =
        match (expr) {
          | CExpr.CE_this
          | CExpr.CE_ref
          | CExpr.CE_global_ref
          | CExpr.CE_volatile_global_ref =>
            null

          | CExpr.CE_loop (e, _)
          | CExpr.CE_cast (e, _, _)
          | CExpr.CE_has_type (e, _) 
          | CExpr.CE_not_null (e)
          | CExpr.CE_method_ref (e, _, _)
          | CExpr.CE_ignore (e) =>
            cannot_addr ();
            simple_walk (e)

          | CExpr.CE_init_obj 
          | CExpr.CE_literal =>
            cannot_addr (); // ??
            null

          | CExpr.CE_none
          | CExpr.CE_base_ctor_ref
          | CExpr.CE_typeof
          | CExpr.CE_ctor_ref
          | CExpr.CE_method_addr
          | CExpr.CE_opcode =>
            cannot_addr ();
            null
          
          | CExpr.CE_call (x, xs)
          | CExpr.CE_tail_call (x, xs) =>
            cannot_addr ();
            walk_seq (expr, x :: xs, "call")

          | CExpr.CE_volatile_field_ref (e, _)
          | CExpr.CE_field_ref (e, _) =>
            // can take address
            def flags' = flags %& ~CgExprFlags.NeedLValue;
            if (CGexpr.type_of (e).IsValueType)
              if (flags %&& CgExprFlags.NeedLValue)
                walk (e, flags' %| CgExprFlags.NeedAddress)
              else
                walk (e, flags' %| CgExprFlags.WishAddress)
            else
              walk (e, flags')

          | CExpr.CE_array_indexer (x, xs) =>
            // can take address
            walk_seq (expr, x :: xs, "array indexer")
          
          | CExpr.CE_mkarray (_, xs, _) =>
            cannot_addr ();
            walk_seq (expr, xs, "array [...] constructor")

          | CExpr.CE_self_tail_call (xs) =>
            cannot_addr ();
            walk_seq (expr, xs, "self tail call")
          
          | CExpr.CE_assign (target, source) =>
            cannot_addr ();
            def target = walk (target, flags %| CgExprFlags.NeedLValue);
            if (target != null) {
              Message.warning (target.loc, "`throw' in assignment target");
              target.flags = CgExprFlags.None;
              target
            } else {
              def source = walk (source, CgExprFlags.None);
              if (source != null) {
                Message.warning (source.loc, "`throw' in assignment source");
                target.flags = CgExprFlags.None;
                CExpr.CE_sequence ([side_effect_run (target), source]).WithCtx (expr)
              } else
                null
            }
            
          | CExpr.CE_let (name, body) =>
            def val = walk (name.val, CgExprFlags.None);
            if (val != null) {
              Message.warning (val.loc, "`throw' in initial `def' value");
              val
            } else {
              def body = walk (body, flags);
              if (body == null)
                null
              else {
                //Message.debug ($ "body: $body");
                CExpr.CE_let (name, body).WithCtx (expr)
              }
            }
            
          | CExpr.CE_raise (e) =>
            // we can take address of throw... 
            def e' = walk (e, CgExprFlags.None);
            if (e' == null) {
              expr // cutoff here
            } else {
              Message.warning (e'.loc, "`throw' in `throw'");
              e'
            }
            
          | (CExpr.CE_if (e, e1, e2)) as rec =>
            cannot_addr (); // maybe we can, but I guess it would be risky
            def e' = walk (e, CgExprFlags.None);
            if (e' != null) {
              Message.warning (e'.loc, "`throw' in `if' condition");
              e'
            } else {
              def e1 = walk (e1, flags);
              def e2 = walk (e2, flags);
              when (e1 != null)
                rec.e_then = e1;
              when (e2 != null)
                rec.e_else = e2;
              if (e1 != null && e2 != null)
                expr
              else
                null
            }
            
          | (CExpr.CE_try_with) as rec =>
            cannot_addr ();
            def body = walk (rec.body, CgExprFlags.None);
            def handler = walk (rec.handler, CgExprFlags.None);
            when (body != null)
              rec.body = body;
            when (handler != null)
              rec.handler = handler;
            if (body != null && handler != null)
              expr
            else
              null
            
          | (CExpr.CE_try_finally) as rec =>
            cannot_addr ();
            rec.body = transform (rec.body);
            def handler = walk (rec.handler, CgExprFlags.None);
            if (handler == null) {
              null
            } else {
              rec.handler = handler;
              rec
            }
            
          | CExpr.CE_sequence (lst) =>
            walk_seq (expr, lst, null)
          
          | CExpr.CE_addr (e) =>
            cannot_addr ();
            walk (e, flags %| CgExprFlags.NeedAddress)
            
          | CExpr.CE_indirect (e) =>
            // can take address
            simple_walk (e)
            
          | CExpr.CE_continue_loop =>
            expr

          | CExpr.CE_multiple_assign (lst) =>
            cannot_addr ();
            def loop (acc, lst) {
              match (lst) {
                | (((v, e)) as x) :: xs  =>
                  def e' = walk (e, CgExprFlags.None);
                  if (e' == null)
                    loop (x :: acc, xs)
                  else {
                    Message.warning (e.loc, "`throw' in self tail call");
                    CExpr.CE_multiple_assign (List.Rev ((v, e') :: acc))
                      .WithCtx (expr)
                  }
                | [] => null
              }
            }
            loop ([], lst)
            
          | (CExpr.CE_switch (idx, default, cases)) as rec =>
            // optimize switch here?
            cannot_addr (); // maybe we can, but I guess it would be risky
            def idx' = walk (idx, CgExprFlags.None);
            if (idx' != null) {
              Message.warning (idx'.loc, "`throw' in `switch' condition");
              idx'
            } else {
              mutable seen_normal = false;
              match (default) {
                | Some (expr) =>
                  def expr = walk (expr, flags);
                  if (expr == null) seen_normal = true;
                  else rec.default = Some (expr)
                | None => ()
              }
              rec.cases =
                List.Map (cases, fun (id, e) {
                  def e' = walk (e, flags);
                  if (e' == null) {
                    seen_normal = true;
                    (id, e)
                  } else {
                    (id, e')
                  }
                });
              if (seen_normal)
                null
              else
                expr
            }
        };
      when (res != null)
        res.flags |= CgExprFlags.Throws;
      res
    }

    /** Helper for walk(). */
    walk_seq (parent_expr : CExpr,
              exprs : list <CExpr>, 
              warning_object : string) : CExpr
    {
      mutable len = 0;
      
      def loop (lst) {
        | e :: es =>
          def res =
            if (warning_object == null && es.IsEmpty ()) walk (e, parent_expr.flags)
            else walk (e, CgExprFlags.None);
          if (res != null) {
            def blah = "has been skipped in code emission, due to `throw' "
                       "usage";
            match (es) {
              | [] =>
                when (warning_object != null)
                  Message.warning (parent_expr.loc, 
                                   $ "this $warning_object $blah");
              | e :: _ =>
                def middle =
                  if (warning_object == null)
                    ""
                  else
                    $" (an argument of the $warning_object)";
                Message.warning (e.loc, $ "this expression$middle $blah");
            }
            
            def exprs' = 
              if (warning_object == null)
                exprs.FirstN (len) // sequence
              else
                List.Map (exprs.FirstN (len), side_effect_run);
            CExpr.CE_sequence (exprs' + [res]).WithCtx (parent_expr)
          } else {
            ++len;
            loop (es)
          }
        | [] => null
      }

      loop (exprs)
    }

    /** Run given expression for side effects only. */
    side_effect_run (expr : CExpr) : CExpr
    {
      def res =
        match (expr) {
          | CExpr.CE_base_ctor_ref
          | CExpr.CE_literal
          | CExpr.CE_this
          | CExpr.CE_none
          | CExpr.CE_ref 
          | CExpr.CE_global_ref 
          | CExpr.CE_ctor_ref
          | CExpr.CE_init_obj
          | CExpr.CE_method_addr
          | CExpr.CE_typeof
          | CExpr.CE_opcode =>
            CExpr.CE_sequence ([]).WithCtx (expr)
          
          | CExpr.CE_continue_loop => assert (false)
          | CExpr.CE_self_tail_call => assert (false)
          
          | CExpr.CE_addr
          | CExpr.CE_indirect
          | CExpr.CE_has_type
          | CExpr.CE_not_null
          | CExpr.CE_if
          | CExpr.CE_try_with
          | CExpr.CE_try_finally
          | CExpr.CE_sequence
          | CExpr.CE_mkarray
          | CExpr.CE_loop
          | CExpr.CE_switch
          | CExpr.CE_volatile_global_ref 
          | CExpr.CE_field_ref
          | CExpr.CE_volatile_field_ref
          | CExpr.CE_method_ref 
          | CExpr.CE_array_indexer
          | CExpr.CE_call
          | CExpr.CE_tail_call 
          | CExpr.CE_let
          | CExpr.CE_cast => CExpr.CE_ignore (expr)

          | CExpr.CE_raise
          | CExpr.CE_multiple_assign
          | CExpr.CE_ignore
          | CExpr.CE_assign => expr
        };
      res.WithCtx (expr)
    }


    // marge with walk()
    transform_try_blocks (allow_try : bool, expr : CExpr) : void
    {
      def false_iter (lst : list <CExpr>) {
        foreach (x in lst)
          transform_try_blocks (false, x)
      }
      def same_iter (lst : list <CExpr>) {
        foreach (x in lst)
          transform_try_blocks (allow_try, x)
      }

      //Message.debug ($"walk $expr [$allow_try]");
      
      match (expr) {
        | CExpr.CE_base_ctor_ref
        | CExpr.CE_literal
        | CExpr.CE_this
        | CExpr.CE_none
        | CExpr.CE_ref 
        | CExpr.CE_global_ref 
        | CExpr.CE_volatile_global_ref 
        | CExpr.CE_ctor_ref
        | CExpr.CE_init_obj
        | CExpr.CE_method_addr
        | CExpr.CE_typeof
        | CExpr.CE_continue_loop 
        | CExpr.CE_opcode => ()

        | CExpr.CE_field_ref (o, _)
        | CExpr.CE_volatile_field_ref (o, _)
        | CExpr.CE_method_ref (o, _, _)
        | CExpr.CE_ignore (o) => transform_try_blocks (allow_try, o)

        | CExpr.CE_array_indexer (o, os)
        | CExpr.CE_call (o, os)
        | CExpr.CE_tail_call (o, os) => false_iter (o :: os)
        
        | CExpr.CE_self_tail_call (os) => false_iter (os)
            
        | CExpr.CE_assign (CExpr.CE_ref, o) => transform_try_blocks (allow_try, o)
        
        | CExpr.CE_assign (o1, o2) => false_iter ([o1, o2])
        
        | CExpr.CE_let (v, b) =>
          transform_try_blocks (allow_try, v.val);
          transform_try_blocks (allow_try, b)
          
        | CExpr.CE_cast (e, _, _) =>
          transform_try_blocks (allow_try, e)

        | CExpr.CE_addr (e)
        | CExpr.CE_indirect (e)
        | CExpr.CE_has_type (e, _)
        | CExpr.CE_not_null (e)
        | CExpr.CE_raise (e) =>
          // are we a bit too conservative here?
          transform_try_blocks (false, e)

        | CExpr.CE_if (e1, e2, e3) =>
          transform_try_blocks (allow_try, e1);
          transform_try_blocks (allow_try, e2);
          transform_try_blocks (allow_try, e3)
        
        | CExpr.CE_try_with (b, _, h)
        | CExpr.CE_try_finally (b, h) =>
          unless (allow_try)
            Message.error (expr.loc, "try block is not allowed inside expressions");
          transform_try_blocks (true, b);
          transform_try_blocks (true, h)
        
        | CExpr.CE_sequence (body) => same_iter (body)

        | CExpr.CE_mkarray (_, initializers, _) => false_iter (initializers)
        
        | CExpr.CE_loop (body, _) => transform_try_blocks (allow_try, body)
        
        | CExpr.CE_multiple_assign (assigns) =>
          List.Iter (assigns, fun (_, e) { transform_try_blocks (allow_try, e) })

        | CExpr.CE_switch (idx, default, cases) =>
          transform_try_blocks (allow_try, idx);
          match (default) {
            | Some (e) => transform_try_blocks (allow_try, e)
            | None => ()
          }
          List.Iter (cases, fun (_, e) { transform_try_blocks (allow_try, e) })
      }
    }
  } /* end of the class */

} /* end of the namespace */
