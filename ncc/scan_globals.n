(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Parsetree;
open Nemerle.Compiler;

namespace Nemerle.Compiler {

module Scan_globals {

  private handle_type (par : option (Tyinfo), env : Env, t : Type_decl) : Tyinfo 
    {
      def env = env.copy ();
      env.add_open (env.current_namespace + t.name);
      def ti = Tyinfo (par, env, t, false);
      def decl = Env.add_type (ti);

      match (t) {
        | TD_variant_option =>
          def n = CSglue.strip_last_part (env.current_namespace) + t.name;
          Env.add_global_symbol (n, decl)
        | _ => ()
      };
      
      def env' = env.in_prefix (t.name);
      def recurse (acc : list (Tyinfo), m : Class_member) : list (Tyinfo) {
        match (m) {
          | M_type (t) =>
            handle_type (Some (ti), env', t) :: acc
          | _ => acc
        }
      };
      def decls =
        match (t) {
          | TD_class (d) => d
          | TD_interface (d) => d
          | TD_variant (ds) =>
            List.map (fun (t : Type_decl) : Class_member { M_type (t) }, ds)
          | TD_variant_option (d) => d
          | _ => []
        };
      ti.contained_types <- List.fold_left (recurse, [], decls);
      ti
    }

  (** This function does the very first pass, after parsing.  It changes 
      open/namespace declaration into appropriate entries in [Env] class.
      It also creates [Tyinfo] object for each type and registers it
      with global name environment.  *)
  public run (decls : list (Top_decl)) : void
    {
      def loop (env : Env, decl : Top_decl) : Env
        {
          match (decl) {
            | TD_namespace (n, d) =>
              def env' = env.in_prefix (n);
              def _ = List.fold_left (loop, env', d);
              env
              
            | TD_open (n) =>
              def env' = env.copy();
              env'.add_open(n);
              env'
              
            | TD_namespace_alias (s, l) =>
              def env' = env.copy();
              env'.add_namespace_alias(s, l);
              env'

            | TD_type (d) =>
              def _ = handle_type (None (), env, d);
              env
          }
        };
      def env = Env ();
      env.add_open ("Nemerle.Core");
      def _ = List.fold_left (loop, env, decls);
      ()
    }
      
} // module Scan_globals

} // N.C
