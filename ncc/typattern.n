/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Typattern {
  
  variant Range {
    | R_omega        // _, x, everything
    | R_none         // nothing
    | R_any_except { lits : list (Literal); }
    | R_literal { l : Literal; }
    | R_variant_option { ti : Tycon; range : Range; }
    | R_tuple { ranges : list (Range); }
    | R_record { ranges : list (IField * Range); }
    
    | R_or { ranges : list (Range); }
  }

  range_of_pattern (p : Pattern) : Range {
    match (p) {
      | P_underscore => R_omega ()
      | P_as (p, _) => range_of_pattern (p)
      | P_tuple (args) => R_tuple (List.Map (range_of_pattern, args))
      | P_record (args) =>
        R_record (List.Map (fun (n, p) { (n, range_of_pattern (p)) }, args))
      | P_cons (ti, pat) =>
        R_variant_option (ti, range_of_pattern (pat))
      | P_literal (l) => R_literal (l)
    }
  }

  // debug routine
  string_of_range (r : Range) : string {
    match (r) {
      | R_omega => "_"
      | R_any_except ([L_bool (true)]) => "false"
      | R_any_except ([L_bool (false)]) => "true"
      | R_any_except (_) => "X" // FIXME
      | R_variant_option (ti, r) =>
        ti.GetFullName () + " (" + string_of_range (r) + ")"
      | R_tuple (ranges) =>
        def concat (acc, r) {
          if (acc == "") string_of_range (r)
          else
            acc + ", " + string_of_range (r)
        };
        "(" + List.FoldLeft (concat, "", ranges) + ")"
        
      | R_record (ranges) =>
        def concat (acc, x) {
          def (f, r) = x;
          def r' = (f : IField).GetName () + " = " + string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.FoldLeft (concat, "", ranges) + " }"
        
      | R_none => "[[None]]"
      | R_literal => "[[Literal]]"
      
      | R_or (ranges) =>
        def concat (acc : string, r : Range) : string {
          if (acc == "") string_of_range (r)
          else
            acc + " | " + string_of_range (r)
        };
        "[ " + List.FoldLeft (concat, "", ranges) + " ]"
    }
  }

  // for user error messages, we just present first branch of R_or
  user_string_of_range (r : Range) : string {
    match (r) {
      | R_omega => "_"
      | R_any_except ([L_bool (true)]) => "false"
      | R_any_except ([L_bool (false)]) => "true"
      | R_any_except (_) => "X" // FIXME
      | R_variant_option (ti, r) =>
        ti.GetFullName () + " (" + user_string_of_range (r) + ")"
      | R_tuple (ranges) =>
        def concat (acc, r) {
          if (acc == "") user_string_of_range (r)
          else
            acc + ", " + user_string_of_range (r)
        };
        "(" + List.FoldLeft (concat, "", ranges) + ")"
        
      | R_record (ranges) =>
        def concat (acc, x) {
          def (f, r) = x;
          def r' = (f : IField).GetName () + " = " + user_string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.FoldLeft (concat, "", ranges) + " }"
        
      | R_none => Util.ice ()
      | R_literal => Util.ice ()
      | R_or ([]) => Util.ice ()
      
      | R_or (x :: _) => user_string_of_range (x)
    }
  }

  simplify_range (r : Range) : Range {
  //  Message.debug ("simpl: " + string_of_range (r) );
    def aint_none (r : Range) : bool {
      match (r) {
        | R_none => false
        | _ => true
      }
    };
    match (r) {
      | R_or ([]) => R_none ()
      | R_or (lst) =>
        match (List.Filter (aint_none, lst)) {
          | [] => R_none ()
          | [x] => x
          | l => R_or (l)
        }
      | R_any_except ([L_bool (true); L_bool (false)]) => R_none ()
      | R_any_except ([L_bool (false); L_bool (true)]) => R_none ()
      | R_variant_option (_, R_none) => R_none ()
      | R_tuple (ranges) =>
        if (List.ForAll (aint_none, ranges)) 
          r
        else
          R_none ()
      | R_record (ranges) =>
        def is_named_none (_, x) {
          match (x) {
            | R_none => true
            | _ => false
          }
        };
        if (List.Exists (is_named_none, ranges))
          R_none ()
        else
          r
      | x => x 
    }
  }
    
  subtract (r1 : Range, r2 : Range) : bool * Range {
    mutable did_something <- false;

    // subtract new_r from cur_r
    def do_sub (cur_r : Range, new_r : Range) : Range {
//    Message.debug ("subx: " + string_of_range (cur_r) + "     " + string_of_range (new_r) );
      match ((cur_r, new_r)) {
        | (R_none, _) => R_none ()
        
        | (_, R_omega) => 
          did_something <- true; 
          R_none ()
          
        | (R_omega, R_literal (l)) =>
          did_something <- true;
          R_any_except ([l])

        | (R_or (ranges), _) =>
          R_or (List.Map (fun (r : Range) : Range { sub (r, new_r) }, ranges))

        | (R_any_except (lits), R_literal (l)) =>
          // FIXME: check if l is in lits
          did_something <- true;
          R_any_except (l :: lits)

        | (R_any_except, _) => Util.ice ()

        | (R_variant_option (ti1, r1), R_variant_option (ti2, r2)) =>
          if (ti1.SameAs (ti2))
            R_variant_option (ti1, sub (r1, r2))
          else
            cur_r
          
        | (cur, R_variant_option (ti, _)) =>
          def make_range (ti : Tycon) : Range {
            R_variant_option (ti, cur)
          };
          match (Option.unsome (ti.SuperClass ()).GetTydecl ()) {
            | TD_variant (opts) =>
              sub (R_or (List.Map (make_range, opts)), new_r)
            | _ =>
              Util.ice ("not variant")
          }

        | (R_variant_option, R_record) => Util.ice ("FIXME")
       
        | (R_omega, R_tuple (ranges)) =>
          def args = List.Map (fun (_ : Range) : Range { R_omega () }, ranges);
          sub (R_tuple (args), new_r)
          
        | (R_tuple (r1), R_tuple (r2)) =>
          mutable did <- true;
          def make_sub (r1 : Range, r2 : Range) : Range {
            def (d, r) = subtract (r1, r2);
            if (d) () else did <- false;
            r
          };
          def results = List.Map2 (make_sub, r1, r2);
          if (did) {
            did_something <- true;

            mutable output <- [];
            // r1 - r2 = r3
            def dosub (pref : list (Range), 
                       cur : list (Range), 
                       after_sub : list (Range)) : void {
              match ((cur, after_sub)) {
                | (x :: xs, y :: ys) => 
                  def args = List.RevAppend (pref, (y :: xs));
                  output <- simplify_range (R_tuple (args)) :: output;
                  dosub (x :: pref, xs, ys)
                | ([], []) => ()
                | _ => Util.ice ()
              }
            };
            dosub ([], r1, results);
            R_or (output)
          } else cur_r
        
        | (R_omega, R_record) =>
          sub (R_record ([]), new_r)

        | (R_record (r1), R_record (r2)) =>
//          Message.debug ("ransub: " + string_of_range (cur_r) + "   " + string_of_range (new_r));
          mutable all_did <- true;

          def loop (acc, r2) {
            def (name, range) = r2;
            
            def loop2 (acc, l) {
              match (l) {
                | (f, r) :: xs =>
                  if (name == f) {
                    def (did, res) = subtract (r, range);
                    if (did) () else all_did <- false;
                    List.RevAppend (xs, (f, res) :: acc)
                  } else
                    loop2 ((f, r) :: acc, xs)
                | [] =>
                  (name, sub (R_omega (), range)) :: acc
              }
            };

            simplify_range (R_record (loop2 ([], r1))) :: acc
          };

          def r = R_or (List.FoldLeft (loop, [], r2));

          if (all_did) {
            did_something <- true;
            r
          } else cur_r

        | (R_variant_option, R_tuple) => Util.ice ()
        | (R_variant_option, R_literal) => Util.ice ()
        | (R_tuple, R_literal) => Util.ice ()
        | (R_record, R_literal) => Util.ice ()
        | (R_record, R_tuple) => Util.ice ()
        | (R_tuple, R_record) => Util.ice ()
        | (R_literal, _) => Util.ice ()
        | (_, R_any_except) => Util.ice ()
        | (_, R_or) => Util.ice ()
        | (_, R_none) => Util.ice ()
      }
    }

    and sub (r1 : Range, r2 : Range) : Range {
      simplify_range (do_sub (r1, r2))
    };

    def ret = sub (r1, r2);
//    Message.debug ("sub: " + string_of_range (r1) + " - " + string_of_range (r2) + " = " + string_of_range (ret));

    (did_something, ret)
  }

  /** Give warnings about ``pattern matching not exhaustive'' and 
      ``unused match clause''. */
  public check_matching (cases : list (Match_case)) : void {
    def loop (acc : Range, m : Match_case) : Range {
      def loop2 (acc : Range, patex : Pattern * Expr) : Range {
        def (pat, ex) = patex;
        def (did_something, ret) = subtract (acc, range_of_pattern (pat));
        if (did_something)
          ()
        else
          Message.warning (pat.loc, "this match clause is unused");
        match (ex) {
          | E_literal (L_bool (true)) => ret
          | _ => acc
        }
      };
      List.FoldLeft (loop2, acc, m.patterns)
    };
    def remaining = List.FoldLeft (loop, R_omega (), cases);
    match (remaining) {
      | R_none => ()
      | r =>
        Message.warning ("this matching is not exhaustive, example unmatched value:");
        Message.warning (user_string_of_range (r))
    }
  }

  public ty_patterns (ctx : TypingContext, 
                      matched_value_type : Type, 
                      patterns : list (PT.Pattern * option (PT.Expr))) 
                    : list (Pattern * Expr) * TypingContext {
                    
    mutable vars <- Map.string_map ();
    mutable common_vars <- None ();
    
    def do_walk (t : Type, p : PT.Pattern) : Pattern {
      match (p) {
        | PT.P_variable (n) =>
          if (n == "true")
            walk (t, PT.P_literal (L_bool (true)))
          else if (n == "false")
            walk (t, PT.P_literal (L_bool (false)))
          else 
            walk (t, PT.P_as (PT.P_underscore (), PT.SS_string (n)))

        | PT.P_as (pat, PT.SS_string (n)) =>
          def pat' = walk (t, pat);
          def t' =
            match (pat') {
              | P_cons (ti, _) =>
                def t' = ti.GetMemType () /- ti.FreshSubst ();
                if (t' >> t) t'
                else Util.ice ()
              | _ => t
            };
          when (vars.mem (n))
            Message.error ("pattern variable `" + n + "' already seen in this pattern");
          def decl =
            match (common_vars) {
              | None =>
                LocalValue (n, D_pattern_variable (), t', ctx.current_fun);
              | Some (cv) =>
                match ((cv : String_map (LocalValue)).find (n)) {
                  | Some (decl) => 
                    if (t' >> decl.ty) ()
                    else {
                      Message.error ("pattern variable `" + decl.name + "' used to have type " +
                                     decl.ty.as_string () + " but now it has type " + t'.as_string ());
                      Message.hint ("rename variable if they have no connection")
                    };
                    decl
                  | None =>
                    LocalValue (n, D_pattern_variable (), t', ctx.current_fun);
                }
            };
          vars <- vars.add (n, decl);
          P_as (pat', decl)
          
        | PT.P_as (_, _) =>
          Message.fatal_error ("$ operator used outside of quotation <[ ... ]> context")

        | PT.P_underscore => P_underscore ()

        | PT.P_literal (lit) =>
          def t' = Tyexpr.ty_literal (ctx, lit);
          match (Tyutil.unify (t, t', false)) {
            | Some (s) => 
              Tyvar.global_store (s);
              P_literal (lit)
            | None =>
              Message.fatal_error ("literal has type " + t'.as_string () + 
                                   " while matched value has type " + t.as_string ())
          }

        | PT.P_tuple (pats) =>
          match (Tyutil.top_expand (t)) {
            | T_app (ti, _) =>
              def collect_fields (acc, m : IMember) {
                match (m.GetKind ()) {
                  | MK_field (f) when ti.SameAs (f.GetDeclaringTycon ()) => f.GetName () :: acc
                  | _ => acc
                }
              };
              def names = List.Rev (List.FoldLeft (collect_fields, [], ti.GetMembers ()));
              match (names) {
                | _ :: _ =>
                  if (List.Length (names) == List.Length (pats)) {
                    def mk (n : string, p : PT.Pattern) : string * PT.Pattern {
                      (n, p)
                    };
                    walk (t, PT.P_record (List.Map2 (mk, names, pats)))
                  } else
                    Message.fatal_error 
                    (sprintf ("pattern matches %d values, while type %s has %d fields", 
                              List.Length (pats), ti.GetFullName (), List.Length (names)))
                | [] =>
                    Message.fatal_error ("pattern matches " + 
                                         (List.Length (pats)).ToString () + 
                                         " values, while type " + ti.GetFullName () + 
                                         " has no fields")
              }
              
            | T_prod (ts) =>
              if (List.Length (ts) == List.Length (pats))
                P_tuple (List.Map2 (walk, ts, pats))
              else
                Message.fatal_error ("pattern matches " + 
                                     (List.Length (pats)).ToString () + 
                                     "-tuples, while " + 
                                     (List.Length (ts)).ToString () + 
                                     "-tuple is required")
            | vart =>
              def free_vars (acc, n) {
                if (n <= 0) acc
                else free_vars (Tyvar.free_variable () :: acc, n - 1)
              };
              def ts = free_vars ([], List.Length (pats));
              if (vart >> T_prod (ts))
                P_tuple (List.Map2 (walk, ts, pats))
              else
                Message.fatal_error ("pattern matches " + (List.Length (pats)).ToString () + 
                                     "-tuples, not values of type " + t.as_string ())
          }
          
        | PT.P_record (l) =>
          def fn (name, pat) {
            // just a placeholder with correct type
            def bogus_expr = E_type_enforcement (null, t);
            def loc = Location_stack.top ();
            bogus_expr.loc <- loc;
            bogus_expr.expr_ty <- t;
            match (Tyexpr.lookup_member (ctx, loc, bogus_expr, name)) {
              | [(E_field_ref (_, fieldname)) as fieldref] =>
                (fieldname, walk (Tyexpr.type_of (fieldref), pat))
              | _ =>
                Message.fatal_error ("name `" + name + "' was expected to be field")
            }
          };
          P_record (List.Map (fn, l))
          
        | PT.P_cons (PT.SS_string (n), p) =>
          if (Util.is_capitalized (n)) {
            def ti = ctx.env.GetType (n);
            match (ti.GetTydecl ()) {
              | TD_variant_option =>
                def parent_tycon = Option.unsome (ti.SuperClass ());
                def parent_type = parent_tycon.GetMemType () /- parent_tycon.FreshSubst ();
                def option_type = ti.GetMemType () /- ti.FreshSubst ();
                if (option_type >> parent_type) () else Util.ice ();
                // we use parent_type for subtyping in case matched value
                // has yet undefined type
                if (parent_type >> t)
                  // but option_type inside subpattern
                  P_cons (ti, walk (option_type, p))
                else
                  Message.fatal_error ("variant option " + option_type.as_string () + 
                                       " doesn't subtype " + t.as_string ())
              | _ =>
                Message.error ("`" + n + "' isn't variant case");
                P_underscore ()
            }
          } else
            match (p) {
              | PT.P_underscore => walk (t, PT.P_variable (n))
              | _ =>
                Message.fatal_error ("`" + n + "' cannot be variant option, " +
                                     "since it starts with lowercase letter")
            }

        | PT.P_cons (_, _) =>
          Message.fatal_error ("$ operator may appear only within <[ ... ]> quotation")

        | PT.P_quoted (parse_element) =>
          // we use Macros functions to translate quoted element
          def lifted = 
            match (parse_element) {
              | PT.SyntaxExpr (e) => 
                Macros.quoted_expr (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxType (e) => 
                Macros.quoted_type (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxPattern (e) => 
                Macros.quoted_pattern (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxParm (e) => 
                Macros.quoted_param (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxCase (e) => 
                Macros.quoted_case (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxCaseGuard (a, b) => 
                Macros.quoted_case_guard (ctx, Macros.QuotationContext (), (a, b))
              | PT.SyntaxFunDecl (e) => 
                Macros.quoted_fundecl (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxFunParm (e) => 
                Macros.quoted_fparam (ctx, Macros.QuotationContext (), e)
              | PT.SyntaxTType => 
                Message.fatal_error ("matching over typed types not supported")
            };
          walk (t, Macros.expr_to_pattern (lifted))

        | PT.P_spliced | PT.P_spliced_special =>
          Message.fatal_error ("$ operator may appear only within <[ ... ]> quotation")

        | PT.P_patt_list =>
          Message.fatal_error (".. arguments list may appear only within <[ ... ]> quotation")
      }
    }
    and walk (t : Type, p : PT.Pattern) : Pattern {
      def r = Util.locate (p.loc, fun () : Pattern { do_walk (t, p) });
      r.loc <- p.loc;
      r.ty <- t; 
      r
    };


    def ty_pats (acc, patterns) {
      match (patterns) {
        | (pat, expr) :: rest =>
          vars <- Map.string_map ();
          def typed_pattern = walk (matched_value_type, pat);
          
          def filter (m : String_map (LocalValue), n, d) {
            if (vars.mem (n))
              m.add (n, d)
            else
              m
          };
          
          common_vars <-
            match (common_vars) {
              | None => Some (vars)
              | Some (x) => Some (x.fold (filter, Map.string_map ()))
            };

          def ctx' = ctx.WithLocals (vars.fold (fun (acc, _, d) { d :: acc }, []));

          def expr =
            match (expr) {
              | None => 
                def ex = E_literal (L_bool (true));
                ex.loc <- Location_stack.top ();
                ex
              | Some (x) => 
                def ex = Tyexpr.ty_expr (ctx', x);
                def bool_ty = Tyutil.make_tapp ("System.Boolean");
                Tyexpr.expect_type ("when guard", ex, bool_ty);
                ex
            };

          ty_pats ((typed_pattern, expr) :: acc, rest)
          
        | [] =>
          def addvar (acc, _, d : LocalValue) { 
            d.is_pattern_outcome <- true; 
            d :: acc
          };
          (List.Rev (acc), ctx.WithLocals ((Option.unsome (common_vars)).fold (addvar, [])))
      }
      
    };

    ty_pats ([], patterns)
  }
  

}
}
