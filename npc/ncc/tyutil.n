open Nemerle.Compiler;
open Nemerle.Compiler.Tyutil;
open Nemerle.Compiler.Tyops;
open Nemerle.Collections;

namespace Nemerle.Compiler {

class Tyops
  {
    fun `/-` (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
    fun `>>` (x : Type, y : Type) : bool = extern "Nemerle.Compiler.Tyutil.subtypes";
  }
  
type Subst = Int_map(Type);

class Tyutil
  {
    fun subst (t : Type, s : Subst) : Type =
      letfun self (t : Type) : Type = subst (t, s) in
      match t with [
        | T_ref (?t) => T_ref (self (t))
        | T_out (?t) => T_out (self (t))
        | T_fun (?tl, ?t) => T_fun (List.map (self, tl), t)
        | T_void => t
        | T_prod (?tl) => T_prod (List.map (self, tl))
        | T_app (?tc, ?args, ?ref_to) =>
          T_app (tc, List.map (self, args), ref_to)
        | T_var (_, ?id) =>
          match s#find(id) with [
            | Some (?t') => t'
            | None => t
          ]
      ];
    
    fun make_subst (ini : Subst, parms : list (int), args : list (Type)) : Subst =
      match (parms, args) with [
        | (Cons (?p, ?ps), Cons (?a, ?args)) =>
          make_subst (ini#add (p, a), ps, args)
        | (Nil, Nil) => ini
        | _ => Util.ice ()
      ];
      
    fun make_subst (parms : list (int), args : list (Type)) : Subst =
       make_subst (Map.int_map (), parms, args);
    
    fun make_subst (td : Type_decl, args : list (Type)) : Subst =
       make_subst (Map.int_map (), Tyvars.get_parms(td#id), args);

    fun fresh_vars (parms : list (int), t : Type) : Type =
      letfun mk_free (id : int) : Type = Tyvars.free_variable (id) in
      t /- make_subst (parms, List.map (mk_free, parms));
      
    fun fresh_vars (td : Type_decl, t : Type) : Type =
      fresh_vars (Tyvars.get_parms(td#id), t);

    fun subst_of_app (t : Type) : Subst * Tyinfo =
      match t with [
        | T_app (_, ?args, ?ref_to) =>
          let ti = Tyinfo.lookup(ref_to) in
          (make_subst (ti#tydecl, args), ti)
        | _ =>
          Message.fatal_error ("type " + t#as_string () + " was expected to be class")
      ];

    fun top_expand (t : Type) : Type =
      letfun f (t : Type) : Type =
        match t with [
          | T_app  =>
            let (?sub, ?ti) = subst_of_app (t) in
            match ti#tydecl with [
              | TD_alias (?t) =>
                f (t /- sub)  // fixpoint iteration
              | _ => t
            ]
          | _ => t
        ] in f (Tyvars.global_expand (t));

    // t1 :> t2 (or t1 =? t2)
    fun unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      letfun sub1 (t : Type) : Type =
        let t = top_expand (t) in
        match t with [
          | T_var (_, ?id) =>
            match s#find(id) with [
              | Some (?t') => sub1 (t')
              | None => t
            ]
          | _ => t
        ]
      in
      //let sign = if allow_subtyping then " :> " else " =? " in
      //let _ = Message.debug ("unify " + string_of_type (t1) + sign + string_of_type (t2)) in
      let t1 = sub1 (t1) in
      let t2 = sub1 (t2) in
      //let _ = Message.debug ("  --> " + string_of_type (t1) + sign + string_of_type (t2)) in
      letfun unify_lists (s : Subst, t1 : list (Type), t2 : list (Type), 
                          allow_subtyping : bool) : option (Subst) =
        match (t1, t2) with [
          | (Cons (?t1, ?ts1), Cons (?t2, ?ts2)) =>
            match unify (s, t1, t2, allow_subtyping) with [
              | Some (?s') => unify_lists (s', ts1, ts2, allow_subtyping)
              | None => None ()
            ]
          | (Nil, Nil) => Some (s)
          | _ => None ()
        ]
      in
      letfun unify_with_tyvar (t1 : Type, t2 : Type) : option (Subst) =
        match t1 with [
          | T_var (_, ?id1) =>
            if Tyvars.is_free (id1) then 
              letfun check_constraint (s : option (Subst), c : Type) : option (Subst) =
                match s with [
                  | None => None ()
                  | Some (?s) => unify (s, t2, c, true)
                ]
              in List.fold_left (check_constraint, Some (s#add (id1, t2)), Tyvars.constraints (id1))
            else None ()
          | _ => None ()
        ]
      in
      match (t1, t2) with [
        | (T_ref (?t1), T_ref (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_out (?t1), T_out (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_prod (?l1), T_prod (?l2)) => 
          unify_lists (s, l1, l2, allow_subtyping)
        | (T_void, T_void) => Some (s)
        
        | (T_fun (?a1, ?r1), T_fun (?a2, ?r2)) =>
          match unify (s, r1, r2, allow_subtyping) with [
            | Some (?s) => unify_lists (s, a2, a1, allow_subtyping)
            | None => None ()
          ]

        | (T_app (_, ?a1, ?tc1), T_app (?tn, ?a2, ?tc2)) =>
          if tc1 == tc2 then 
            unify_lists (s, a1, a2, false)
          else
            if allow_subtyping then
              let (?s1, ?ti1) = subst_of_app (t1) in
              let ti2 = Tyinfo.lookup (tc2) in
              match ti1#how_subtypes (ti2#tydecl) with [
                | Some (?l) =>
                  letfun f (t : option (Type)) : Type =
                    match t with [
                      | None => Tyvars.free_variable ()
                      | Some (?t) => t /- s1
                    ]
                  in let a1' = List.map (f, l) in
                  unify (s, T_app (tn, a1', tc2), t2, true)
                | None => None ()
              ]
            else 
              None ()
            
        | (T_var (_, ?id1), T_var (_, ?id2)) =>
          if id1 == id2 then Some (s)
          else
          match unify_with_tyvar (t1, t2) with [
            | Some (?s) => Some (s)
            | None => unify_with_tyvar (t2, t1)
          ]
        
        | _ =>
          match unify_with_tyvar (t1, t2) with [
            | Some (?s) => Some (s)
            | None => 
              match unify_with_tyvar (t2, t1) with [
                | Some (?s) => Some (s)
                | None =>
                  if allow_subtyping then
                    match t1 with [
                      // check to see if any of our constraints is enough
                      | T_var (_, ?id) =>
                        letfun check_constraints (cs : list (Type)) : option (Subst) =
                          match cs with [
                            | Nil => None ()
                            | Cons (?c, ?cs) =>
                              match unify (s, c, t2, true) with [
                                | Some (?r) => Some (r)
                                | None => check_constraints (cs)
                              ]
                          ]
                        in check_constraints (Tyvars.constraints (id))
                      | _ => None ()
                    ]
                  else None ()
              ]
          ]
      ];

    fun unify (t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      unify (Map.int_map (), t1, t2, allow_subtyping);
    
    fun unify (t1 : Type, t2 : Type) : option (Subst) =
      unify (Map.int_map (), t1, t2, false);
   
    // FIXME: this might be broken (if there are free variables in types to
    // begin with)
    fun types_eq (a : Type, b : Type) : bool =
      match unify (a, b) with [
        | Some => true
        | None => false
      ];

    // check if a :> b and if so, incorporate substitution into
    // global context
    fun subtypes (a : Type, b : Type) : bool =
      match unify (a, b, true) with [
        | Some (?s) => { Tyvars.global_store (s); true }
        | None => false
      ];

    fun string_of_type (t : Type) : string =
      letfun map (sep : string, args : list (Type)) : string =
        Util.concat_strings(sep, List.map (string_of_type, args))
      in
      match t with [
        | T_app (?tc, ?args, ?ref_to) =>
          let name =
            if ref_to == 0 then tc
            else
              // be as fault tolerant as possible, this is for debug
              // and error messages.
              try (Tyinfo.lookup(ref_to))#fullname() 
              with ?x : ICE => tc
          in
          name + " (" + map (", ", args) + ")"
        | T_var (?n, ?id) => 
          "'" + n + "_" + string_of_int (id) + if Tyvars.is_free (id) then "*" else ""
        | T_ref (?t) => "ref " + string_of_type (t)
        | T_out (?t) => "out " + string_of_type (t)
        | T_void => "void"
        | T_prod (?args) => 
          "(" + map (" * ", args) + ")"
        | T_fun (?from, ?to) =>
          "(" + map (", ", from) + ") -> " + string_of_type (to)
      ];
    
    // Given function declaration, construct its type.
    fun fun_type (h : Fun_header) : Type = 
      let args = List.map (fun (p : Fun_parm) : Type => p#ty, h#parms) in
      T_fun (args, h#ret_type);

    fun make_tapp (env : Env, n : string) : Type =
      let td = env#lookup_type (n) in
      T_app (n, Nil (), td#id);
  }

} // ns
