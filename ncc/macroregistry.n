/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;
using Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 */
public interface IMacro {
  GetName () : string;
  GetNamespace () : string;  
  Run (ctx : CTX, args : list <PT.SyntaxElement>) : PT.Expr;
  CallTransform (_ : list <PT.Parm>) : list <PT.SyntaxElement>;
  SyntaxExtension () : string * list <Parser.GrammarElement> * list <int>;
} 

public module MacroRegistry {

  class MacroNS {
    public mutable Value : option <IMacro>;
    mutable children : Hashtable <string, MacroNS>;

    public this (v : option <IMacro>) {
      Value <- v;
    }

    /// Walks down the tree begining at current node, spliting given
    /// name to `.' separated parts. The path is created if at some
    /// point it doesn't exist in tree.
    public Path (n : string) : MacroNS {
      mutable cur_node <- this;
      mutable last <- 0;
      for (mutable i <- 0; i < n.Length; ++i) {
        when (n[i] == '.') {
          cur_node <- cur_node.Child (n.Substring (last, i - last));
          last <- i + 1;
        }
      };
      when (n.Length > 0 && !n.EndsWith ("."))
        cur_node <- cur_node.Child (n.Substring (last, n.Length - last));
      cur_node
    }

    public Path (n : list <string>) : MacroNS {
      mutable cur_node <- this;
      def loop (l) {
        | x :: xs =>
          cur_node <- cur_node.Child (x);
          loop (xs)
        | _ => cur_node
      };
      loop (n)
    }

    public TryPath (n : list <string>) : option <IMacro> {
      def loop (l, cur_node : MacroNS) {
        match (l) {
          | [x] =>
            when (cur_node.children == null)
              cur_node.children <- Hashtable (10, 1.0f);

            match (cur_node.children.Get (x)) {
              | Some (nd) => nd.Value
              | _ => None ()
            }

          | x :: xs =>
            when (cur_node.children == null)
              cur_node.children <- Hashtable (10, 1.0f);

            match (cur_node.children.Get (x)) {
              | Some (nd) => loop (xs, nd)
              | _ => None ()
            }
          // we are at good namespace, so return our own Value
          | _ => Value
        }
      };
      loop (n, this)
    }


    /// Performs one step down the tree through given edge (name).
    /// String in this edge isn't splited to `.' separated parts.
    /// In case there is no such child in current node, it is created.
    public Child (name : string) : MacroNS {
      when (children == null) children <- Hashtable (10, 1.0f);
      match (children.Get (name)) {
        | None =>
          def result = MacroNS (None ());
          children.Add (name, result);
          result

        | Some (r) => r
      }
    }
  }
  
//  public macros : Hashtable <string, IMacro>;
  macros : MacroNS;
  extensions : Hashtable <string, list <string * list<string>
               * Parser.KeywordCallback>>;
  mutable loaded : list<string>;

  this () {
    macros <- MacroNS (None ());
    extensions <- Hashtable (50);
    loaded <- [];
  }

  public LoadSyntaxExtensions (from_namespace : string) : void
  {
    def load (key, keywords, callback) {
      Parser.ctx.keywords.Set (key, callback);
      List.Iter (keywords, fun (x) { Lexer.AddKeyword (x) })
    };
    match (extensions.Get (from_namespace)) {
      | Some (l) =>
        List.Iter (l, load);
        loaded <- from_namespace :: loaded;
      | _ => ()
    }
  }

  internal RemoveSyntaxExtensions () : void
  {
    loaded <- List.Filter (loaded, fun (ns) {
      if (ns != "Nemerle.Core")
        match (extensions.Get (ns)) {
          | Some (val) =>
            List.Iter (val, fun (tup) {
              def (key, keywords, _) = tup;
              List.Iter (keywords, fun (x) { Lexer.RemoveKeyword (x) });
              Parser.ctx.keywords.Remove (key)
            });
            false
          | None =>
            Util.ice ("cannot find loaded namespace in extensions")
        }
      else
        true
    })
  }
  
  public register_macro (m : IMacro) : void {
    def ns = m.GetNamespace ();
    // full qualified name of macro call
    def fullname = ns + m.GetName ();
    // crop last symbol (`.') of namespace
    def ns =
      if (ns == "") 
        "Nemerle.Core" 
      else 
        ns.Substring (0, ns.Length - 1);
    def nslist = NString.Split (array ['.'], fullname);

    match (macros.TryPath (nslist)) {
      | Some =>
        Message.error ("macro `" + fullname + "' already defined")
      | None =>
        // store syntax extension in MacroRegistry
        match (m.SyntaxExtension ()) {
          | ("", [], []) => ()
          | (key, rules, positions) =>
            mutable keywords <- [key];
            List.Iter (rules, fun (x) { 
              | Parser.GE_keyword (k) => keywords <- k :: keywords;
              | _ => () 
            });

            def permute = Macros.CreatePermutingFunction (List.Rev (positions));
            def callback =
              Parser.KeywordCallback (key, Parser.make_parsing_function
                                             (fullname, rules, permute));

            // store extensions for this namespace
            match (extensions.Get (ns)) {
              | Some (l) =>
                extensions.Set (ns, (key, keywords, callback) :: l)
              | None =>
                extensions.Set (ns, [(key, keywords, callback)])
            }
        };
        macros.Path (nslist).Value <- Some (m);
    }
  }

  public expand_macro (ctx : CTX, expr : PT.Expr) : PT.Expr {
    match (expr) {
      | PT.E_call (name, args) =>
        match (Util.qidl_name_of_expr (name)) {
          | Some ((namepath, name)) =>
            def names = name.GetEnv (ctx.env).ExpandName (namepath);
            def res =
              List.FoldLeft (names, None (), 
                fun (fullname, acc) {
                  match ((acc, macros.TryPath (fullname))) {
                    | (Some (m1), Some (m2)) when m1 != m2 =>
                      Message.error ("macro name `" +
                                     NString.Concat (".", namepath) + 
                                     "' is ambiguous (expanded to " +
                                     m1.GetNamespace () + m1.GetName () +
                                     " and " +
                                     m2.GetNamespace () + m2.GetName () + ")");
                      acc
                    | (_, (Some) as r) => r
                    | (r, _) => r
                  }
                });
            match (res) {
              | Some (x) =>
                TypingContext.PushNewColor (name.color, name.GetEnv (null));
                def expanded = x.Run (ctx, x.CallTransform (args));
                TypingContext.PopColor ();
                expand_macro (ctx, expanded);
              | None => expr
            }
          | None => expr
        }
        
      | PT.E_macrocall (name, parms) =>
        match (macros.Path (name.id).Value) {
          | Some (m) =>
            TypingContext.PushNewColor (name.color, name.GetEnv (null));
            def expanded = m.Run (ctx, parms);
            TypingContext.PopColor ();        
            expand_macro (ctx, expanded)
          | None =>
            Util.ice ("failed to resolve macro name `" + name.id + "'")
        }

      | _ => expr
    }
  }

}
} // end ns
