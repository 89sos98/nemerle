using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using SCG = System.Collections.Generic;

namespace LRPEGCC
{
  partial internal class RuleCompiler
  {
    public CompileRule(ruleToCompile : Rule) : PExpr
    {
      mutable recursionLevel = 0;
      def tokenVars : SCG.List[PExpr] = SCG.List();
      mutable subruleNestingLevel = -1;
      mutable nestingLevel = -1;
      def makeVarRef(rule : Rule) : PExpr.Ref
      {
        def varName = $"token_L$(subruleNestingLevel)_$(rule.Index)";
        def varRef = <[ $(varName : dyn) ]>;
        varRef
      }
      def prepandExprs(exprs : list[PExpr], mainExpr : PExpr.Sequence) : PExpr
      {
        match (mainExpr)
        {
          | <[ { ..$nestedExprs } ]> => <[ { ..$(exprs + nestedExprs) } ]>
        }
      }
      def compile(currentRule : Rule, isTrminalCapture : bool) : PExpr
      {
        recursionLevel++;
        when (recursionLevel > 500)
        {
          assert2(false);
        }
        nestingLevel++;
        def prevSubruleNestingLevel = subruleNestingLevel;
        def debugString = $"$(currentRule.GetType().Name) (sl:$subruleNestingLevel): $currentRule";
        def debugExpr = <[ _ = $(debugString : string); ]>;
        def makeVariableNames(subrule : Rule) : list[string]
        {
          def varCount   = match (subrule) { | Sequence(rules) => rules.Length | _ => 1 };
          def upperBound = varCount - 1;
          def varNames   = $[$"token_L$(subruleNestingLevel)_$i" | i in [0 .. upperBound]]; // Generate variables
          varNames
        }
        def makeSubruleCode(rule : Rule, subrule : Rule, isTrminalCapture : bool, 
                            makeInitExpr    : PExpr               -> PExpr, 
                            makeSetExpr     : PExpr * list[PExpr] -> PExpr,
                            makeSetNoneExpr : PExpr               -> PExpr) 
          : list[PExpr] * PExpr * PExpr * PExpr
        {
          def varRef          = makeVarRef(rule); // this line must precede to subruleNestingLevel++
          subruleNestingLevel++; // it will be automatically restored after return from compile().
          def varNames        = makeVariableNames(subrule);
          // Add variables (by one for each subrule)
          def variables       = if (isTrminalCapture) []
                                else $[<[ mutable $(name : dyn); ]> | name in varNames];
          def variableRefs    = $[<[ $(name : dyn) ]> | name in varNames];
            
          def initList        = if (isTrminalCapture) <[ () ]> else makeInitExpr(varRef);
          def setExpr         = if (isTrminalCapture) <[ () ]> else makeSetExpr(varRef, variableRefs);
          def setNoneExpr     = makeSetNoneExpr(varRef);
          def initialising    = debugExpr :: initList :: variables;
          def ruleCode        = compile(subrule, isTrminalCapture);
          (initialising, setExpr, setNoneExpr, ruleCode)
        }
        def makeListCode(rule : Rule, subrule : Rule, isTrminalCapture : bool) : list[PExpr] * PExpr * PExpr
        {
          def (initialising, setExpr, _setNoneExpr, rule) = 
            makeSubruleCode(rule, subrule, isTrminalCapture, 
                          varRef                 => <[ $varRef = SCG.List(); ]>, 
                          (varRef, variableRefs) => <[ $varRef.Add(..$variableRefs); ]>,
                          _                      => <[ () ]>);
          (initialising, setExpr, rule)
        }
        
        def result = match (currentRule)
        {
          | And(rule)              =>
            def rule = compile(rule, true);
            <[
              {
                $debugExpr;
                
                def newPos = $rule;
                
                if (newPos >= 0) pos else -1;
              }
            ]>

          | Not(rule)              =>
            def rule = compile(rule, true);
            <[
              {
                $debugExpr;
                
                def newPos = $rule;
                
                if (newPos < 0) pos else -1;
              }
            ]>

          | Call(name) as rule     => <[ { $debugExpr; $(DecorateRuleName(name) : dyn)(pos, ref $(makeVarRef(rule))); } ]>
          | Chars(chars)           =>
            def len = chars.Length;
            
            def testChar(rset)
            {
              def cmp(range)
              {
                if (range.from == range.to)
                  <[ c == ($(range.from : char)) ]>
                else
                  <[ ($(range.from : char) <= c && c <= $(range.to : char)) ]>
              }
              def gen(ranges)
              {
                | [range]         => cmp(range);
                | range :: ranges => <[ $(cmp(range)) || $(gen(ranges))]>
                | []              => throw ArgumentException();
              }
              
              gen(rset.Ranges);
            }
            def generate(_)
            {
              | [ch] =>
                <[
                  def c = GetChar(pos);
                  if ($(testChar(ch))) pos + 1 else -1;
                ]>
                
              | ch :: chars =>
                <[
                  {
                    def c = GetChar(pos);
                    
                    if ($(testChar(ch)))
                    {
                      def pos = pos + 1;
                      $(generate(chars));
                    }
                    else
                      -1;
                  }
                ]>
                
              | [] => throw ArgumentException();
            }
            
            def check = if (len > 1) <[pos + $((len - 1) : int)]> else <[pos]>;
              
            <[ 
              $debugExpr;
              
              if (CheckTextLength($check)) $(generate(chars)) else -1 ]>

          | Choice(rules)          =>
            def generate(_)
            {
              | [rule]        => rule;
              | rule :: rules =>
                <[
                  {
                    def newPos = $rule;
                    
                    if (newPos < 0) $(generate(rules)) else newPos;
                  }
                ]>
                
              | []            => throw ArgumentException();
            }
            
            def result = generate(rules.Map(compile(_, isTrminalCapture)));
            def exprs = [<[ $debugExpr; ]>, result];
            <[ { ..$exprs } ]>

          | RepeatMinMax(0, 1, subrule)    =>
            def (initialising, setExpr, setNoneExpr, ruleCode) = 
              makeSubruleCode(currentRule, subrule, isTrminalCapture, 
                              _                      => <[ () ]>, 
                              (varRef, variableRefs) => <[ $varRef = Some(..$variableRefs); ]>,
                              varRef                 => <[ $varRef = None(); ]>);
            prepandExprs(initialising, <[
              {
                def newPos = $ruleCode;
                
                if (newPos >= 0)
                {
                  $setExpr;
                  newPos
                }
                else
                {
                  $setNoneExpr;
                  pos
                }
              }
            ]>)

          | RepeatMinMax(minCount, maxCount, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(currentRule, subrule, isTrminalCapture);
            prepandExprs(initialising, <[
              {
                def rep(count, pos)
                {
                  if (count == $(maxCount : int))
                    pos
                  else
                  {
                    def newPos = $ruleCode;
                    
                    if (newPos >= 0)
                    {
                      $addTokensToList;
                      rep(count + 1, newPos)
                    }
                    else if (count >= $(minCount : int))
                      pos
                    else
                      -1
                   }
                }
                
                rep(0, pos);
              }
            ]>);

          | RepeatMin(0, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(currentRule, subrule, isTrminalCapture);
            
            prepandExprs(initialising, <[
              {
                def rep(pos : int)
                {
                  def newPos = $ruleCode;
                  
                  if (newPos >= 0)
                  {
                    $addTokensToList;
                    rep(newPos)
                  }
                  else
                    pos
                }
                
                rep(pos)
              }
            ]>)

          | RepeatMin(minCount, subrule)    =>
            def (initialising, addTokensToList, ruleCode) = makeListCode(currentRule, subrule, isTrminalCapture);
            
            prepandExprs(initialising, <[
              {
                def rep(count, pos)
                {
                  def newPos = $ruleCode;
                  
                  if (newPos >= 0)
                  {
                    $addTokensToList;
                    
                    rep(count + 1, newPos)
                  }
                  else if (count >= $(minCount : int))
                    pos
                  else
                    -1
                }
                
                rep(0, pos)
              }
            ]>)

          | Sequence(subrules)        =>
            def generate(_rules : list[PExpr]) : PExpr
            {
              | [ruleCode]        => ruleCode
              | ruleCode :: rules =>
                <[
                  {
                    def pos = $ruleCode;
                    
                    if (pos >= 0) $(generate(rules)) else -1
                  }
                ]>
                
              | []                =>  <[ pos ]>;
            }
            
            def code   = generate(subrules.Map(compile(_, isTrminalCapture)));
            def result = [<[ $debugExpr; ]>, code];
            <[ { ..$result } ]>

          | Capture(name, _, _, subrule)              with isTrminalCapture = false =>
            def varRef       =  if (nestingLevel > 0) makeVarRef(currentRule);
                                else                  <[ $("result" : dyn) ]>;
            subruleNestingLevel++; // it will be automatically restored after return from compile().
            def varNames     = makeVariableNames(subrule);
            // Add variables (by one for each subrule)
            def variables    = $[<[ mutable $(name : dyn); ]> | name in varNames];
            def variableRefs = $[<[ $(name : dyn) ]> | name in varNames];
            def initialising = debugExpr :: variables;
            def subRuesCode  = compile(subrule, isTrminalCapture);
            // TODO: Надо сделат так, чтобы переменные генерируемые в Sequence не попадали в блок
            prepandExprs(initialising, <[
              {
                def newPos = $subRuesCode;
              
                when (newPos >= 0)
                {
                  $varRef = LRPEGCC.NonTerminalToken(pos, newPos, _text, $(name : string), $(name : dyn)(..$variableRefs));
                }
                
                newPos
              }
            ]>)
          
          | CaptureNamedTerminalSymbol(name, subrule) with isTrminalCapture = true =>
            def varRef     =  if (nestingLevel > 0) makeVarRef(currentRule);
                              else                  <[ $("result" : dyn) ]>;
            def subRuesCode = compile(subrule, isTrminalCapture);
            <[
              {
                $debugExpr;
                def newPos = $subRuesCode;
              
                when (newPos >= 0)
                  $varRef = LRPEGCC.TerminalToken(pos, newPos, _text, $(name : string));
                
                newPos
              }
            ]>
            
          | ExtensionPoint         => throw NotImplementedException();
        }
        
        recursionLevel--;
        subruleNestingLevel = prevSubruleNestingLevel;
        nestingLevel--;
        result
      } // end of compile()
      
      def code = compile(ruleToCompile, false);
      tokenVars.Add(code);
      <[ { ..$(tokenVars.NToList()) } ]>
    }
  }
}
