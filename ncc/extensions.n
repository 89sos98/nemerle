/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Extensions {

  public implicit_ctor (par : Tyinfo) : list (IMember) {
    def collect (acc, mem : IMember) {
      match (mem.GetKind ()) {
        | MK_field =>
          def n = mem.GetName ();
          def fp = Fun_parm (loc = par.GetLocation (), name = n, 
                             ty = mem.GetMemType (), decl = null);
          def ex = PT.E_assign (PT.E_member (PT.E_this (), PT.SS_string (n)), 
                                PT.E_ref (n));
          def (es, ps) = acc;
          (ex :: es, fp :: ps)
        | _ => acc
      }
    };

    def make_ctor (base_ctor : IMember) : IMember {
      def base_ctor = (base_ctor :> IMethod);
      def (ctor_parms, base_call) =
        if (base_ctor == null) ([], PT.E_literal (L_void ()))
        else {
          def pp = base_ctor.GetHeader ().parms;
          def callparms = List.map (fun (fp : Fun_parm) { PT.Parm (PT.E_ref (fp.name)) }, pp);
          (List.map (fun (fp : Fun_parm) {
                       Fun_parm (loc = par.GetLocation (), name = fp.name, 
                                 ty = fp.ty, decl = null)
                     }, pp),
           PT.E_call (PT.E_base (), callparms))
        };

      def (assigns, parms) = List.fold_left (collect, ([], []), par.GetDirectMembers ());
      def fh = Fun_header (loc = par.GetLocation (), 
                           name = ".ctor", 
                           id = Util.next_id (),
                           ret_type = T_void (), 
                           parms = List.append (ctor_parms, List.rev (parms)),
                           typarms = [],
                           tenv = par.tenv,
                           closure_vars = [],
                           all_locals = [],
                           decl = null,
                           cg_method = null);
      def bogus_fh = PT.Fun_header (loc = par.GetLocation (), name = PT.SS_string (".ctor"),
                                    ret_type = PT.T_void (), parms = []);
      def body = PT.E_sequence (base_call :: assigns);
      body.loc <- par.GetLocation ();
      def f = PT.M_function (modifiers = [Mod_public ()], loc = fh.loc, 
                             name = fh.name, header = bogus_fh, 
                             kind = FK_ctor (), body = FB_parsed_expr (body));
      def memb = NemerleMethod (par, (f :> PT.M_function));
      memb.SetHeader (fh);
      memb
    };
      
    match (par.SuperClass ()) {
      | Some (baseti) =>
        def decls = baseti.LookupMember (".ctor", LF_instance ());
        def is_ctor (m : IMember) {
          match (m.GetKind ()) {
            | MK_method (m) => 
              match (m.GetFunKind ()) {
                | FK_ctor => true
                | _ => false
              }
            | _ => false
          }
        };
        match (List.filter (is_ctor, decls)) {
          | [] => 
            match (baseti.GetTydecl ()) {
              | TD_variant => [make_ctor (null)]
              | _ =>
                Message.fatal_error ("type `" + baseti.GetFullName () + "' (base of `" + 
                                     par.GetFullName () + "') has no constructors, cannot " +
                                     "generate default constructor")
            }
          | decls =>
            List.map (make_ctor, decls)
        }
      | None =>
        [make_ctor (null)]
    }
  }


  
} // end module Extensions
} // end ns

