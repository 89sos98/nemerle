using System.Globalization;

using Nemerle.Compiler;
using Nemerle.IO;

class LexerDumper : LexerFile {
  mutable last_dump_loc : Location = Location.Default;
  mutable last_dump_length : int = 0;

  public this (file : string) {
    base (file);
    store_comments = true;
  }

  private Escape (str : string) : string {
    str.Replace ("&", "&amp;").Replace ("<", "&lt;").Replace (">", "&gt;")
  }
  
  public override GetToken () : Token {
    def tok = base.GetToken ();
    def (token_len, token_str) = 
      match (tok) {
        | Token.Identifier (name) => (name.Length, name)

        | Token.Keyword (name) =>
          (name.Length, $"<span class='key'>$name</span>")

        | Token.Operator (name, _) =>
          (name.Length, $"<span class='op'>$(Escape (name))</span>")

        | Token.StringLiteral (value) =>
          def value = Escape (value.Replace ("\n", "\\n"));
          (value.Length + 2, $"<span class='str'>\"$value\"</span>")

        | Token.CharLiteral (value) =>
          (3, $"<span class='char'>'$(value)'</span>")

        | Token.SByteLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 2, $"<span class='num'>$(value)SB</span>")

        | Token.ByteLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)B</span>")

        | Token.ShortLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)S</span>")

        | Token.UShortLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 2, $"<span class='num'>$(value)US</span>")

        | Token.IntLiteral (value) =>
          def str = value.ToString ();
          (str.Length, $"<span class='num'>$(value)</span>")

        | Token.UIntLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)U</span>")

        | Token.LongLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 1, $"<span class='num'>$(value)L</span>")

        | Token.ULongLiteral (value) =>
          def str = value.ToString ();
          (str.Length + 2, $"<span class='num'>$(value)UL</span>")

        | Token.FloatLiteral (value) =>
          def str = value.ToString (CultureInfo.InvariantCulture);
          (str.Length + 1, $"<span class='num'>$(value)f</span>")

        | Token.DoubleLiteral (value) =>
          def str = value.ToString (CultureInfo.InvariantCulture);
          (str.Length, $"<span class='num'>$(value)</span>")

        | Token.DecimalLiteral (value) =>
          def str = value.ToString (CultureInfo.InvariantCulture);
          (str.Length + 1, $"<span class='num'>$(value)M</span>")

        | Token.Comment (value) => 
          (value.Length + 6, $"<span class='comment'>/* $(value) */</span>")

        | Token.EndOfFile => (0, "")
      }
    def cur_loc = this.Location;
    if (cur_loc.Line != last_dump_loc.Line && cur_loc != Location.Default) {
      repeat (cur_loc.Line - last_dump_loc.Line) print ("<br/>");
      repeat (cur_loc.Column) print ("&#160;");
    }
    else
      repeat (cur_loc.Column - last_dump_loc.Column - last_dump_length)
        Nemerle.IO.print ("&#160;");
    last_dump_loc = cur_loc;
    last_dump_length = token_len;
    print (token_str);
    tok
  }
}

module Dumper {
  Main (args : array <string>) : void {
    if (args.Length < 1) printf ("usage: dumper.exe filename.n\n");
    else {
      def filename = args [0];
      LibraryReferenceManager.LoadMacrosFrom ("Nemerle.Macros");
      MacroRegistry.LoadSyntaxExtensions ("Nemerle.Core");
      Location.AddFiles ([filename]);                

      def lex = LexerDumper (filename);
      print ("<p class='code'>\n");
      _ = Parser.parse (lex);
      print ("\n</p>\n");
    }
  }
}

