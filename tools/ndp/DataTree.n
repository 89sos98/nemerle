

namespace NemerleDoc
{

  using System;
  using Nemerle.Collections;
  using System.Reflection;

  /// <summary>
  /// Generates and writes to a file a html page.
  /// </summary>  
  internal module HtmlGenerator
  {
    /// <summary>
    /// Writes a html file. f is a function returns a body string.
    /// </summary>
    public Page (f : void -> string, fname : string) : void
    {
    
        def body = f();
        
        def buf = System.Text.StringBuilder();
        _ = buf.Append("<?xml version=\"1.0\"?>\n");
        _ = buf.Append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n");
        _ = buf.Append("  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n");
        _ = buf.Append("<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n");
        _ = buf.Append("<head>\n");
        _ = buf.Append("<title>Nemerle Documentation Project</title>\n");
        _ = buf.Append("<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n");
        _ = buf.Append("<link rel=\"stylesheet\" type=\"text/css\" href=\"nemerle-doc.css\" />\n");
        _ = buf.Append("</head>\n");
        _ = buf.Append("<body>\n");
        _ = buf.Append(body);
        _ = buf.Append("<div class=\"footer\">Nemerle Documentation Project</div>");
        _ = buf.Append("</body>\n");
        _ = buf.Append("</html>\n");
        
        // some refinements
        _ = buf.Replace("&", "&amp;");

        def outf = IO.StreamWriter(fname);
        outf.Write(buf);
        outf.Close();
        // Console.WriteLine("---> zapis do {0}", fname);
    }

    /// <summary>
    /// Generates a header of a page.
    /// </summary>
    public Title (title : string, subtitle : string) : string
    {
      mutable content = "";
      content += "<div class=\"title\">";
      content += "<span class=\"title\">" + title + "</span><br />";
      content += "<span class=\"subtitle\">";
      content += subtitle;
      content += "</span>";
      content += "</div>\n\n";
      content;  
    }
  } // module htmlgenerator

  /// <summary>
  /// Type of the element. This attribute is set by XML parser.
  /// </summary>
  public variant ElementType
  {
    | Unknown
    | Property
    | Method
    | Field
    | Type
  }

  [Record]
  sealed class ReflAttribs
  {
    internal is_interface : bool;
    internal is_abstract : bool;
    internal is_class : bool;
    internal is_array : bool;
    internal attr : System.Reflection.TypeAttributes;
    internal Private : bool
    {
      // get { (attr & TypeAttributes.NotPublic != 0) || (attr & TypeAttributes.NestedPrivate != 0) }
      get { (attr & TypeAttributes.Public == 0)  }
    }
  }  // Atributes

  /// <summary>
  /// Top node of the tree representing a 'top' namespace, even if it is
  /// empty (how's it called, by the way?)
  /// </summary>
  public class TopNode
  {
    // it is a list of elements
    internal mutable elements : list [ Node ] = [];
    
    /// <summary>An anchor ref</summary>
    public href : string = this.ToString() + this.GetHashCode().ToString();
  
    internal mutable attribute : ReflAttribs;
    internal mutable parent : TopNode;

    // attributes dragged out from XML file  
    internal mutable comment : string = "";
    internal mutable remark  : string = "";
    internal mutable return  : string = "";
    internal mutable param   : string = "";
    internal mutable example : string = "";
    internal mutable exception : string = "";
    internal mutable permission : string = "";
  
    /// <summary>
    /// For the current node (which represent a namespace) creates a list of elements
    /// </summary>
    internal namespace2html (elements : list [ Node ], ns : string, publicOnly : bool) : string
    {
      // def page_ref = "<a href=\"" + ns + "\">";
      mutable res = "";
      res += "<div class=\"ns-index\">\n";
      res += "<span class=\"ns-index\" id=\"" + this.href + "\">Namespace " + (if (ns.Length == 0) "&lt;top&gt;" else ns) +"</span>\n";
      foreach (e in elements)
        when (!publicOnly || (e.attribute == null  || !e.attribute.Private))
          when (e.XMLattrib.Equals(ElementType.Type()) || e.XMLattrib.Equals(ElementType.Unknown()))
          {
            def ahref = match (e.XMLattrib) { | Unknown => "#" + e.href | _ => e.html_file + "#" + e.href };
            res += "<div title=\"" + e.full_name + "\" class=\"index-element\">";
            res += match (e.XMLattrib) { | Type => "class" | Unknown => "namespace" | _ => e.XMLattrib.ToString() };
            res += " ";
            res += "<a href=\"" + ahref + "\">" + e.name + "</a>";
            res += if (comment.Length > 0) "<div class=\"komentarz\">Comment: " + comment + "</div>" else "";
            res += if (remark.Length > 0) "<div class=\"uwaga\">Remark: " + remark + "</div>" else "";
            res += "</div>\n";
          }
      res += "</div>\n";
      res
    }
  
    /// <summary>
    /// Creates Table of Content for the current namespace. The current node is
    /// always a namespace.
    /// </summary>
    public virtual ToIndex (content : ref string, publicOnly : bool) : void
    {
      // first group types in 'anonymous' namespace
      mutable is_anonymous_ns = false;
      foreach (e in elements)      
        when (e.XMLattrib.Equals(ElementType.Type())) is_anonymous_ns = true;
    
      // add elements in anonymous
      when (is_anonymous_ns)
      {
        content += namespace2html(this.elements, "", publicOnly);
        foreach (e in this.elements)
            unless (e.XMLattrib.Equals(ElementType.Unknown()))
            when (!publicOnly || (e.attribute == null || !e.attribute.Private))
              content += e.ToHtml()
      }
        
      foreach (e in elements)
         when (e.XMLattrib.Equals(ElementType.Unknown()))
             e.ToIndex(ref content, publicOnly)
   }
  
    /// <summary>
    /// Creates description of the current node. Since it represents a namespace,
    /// it iterates over namespace's elements.
    /// </summary>
    public virtual infoPages (publicOnly : bool) : void
    {       
      foreach (e in elements)
          when (e.XMLattrib.Equals(ElementType.Unknown())) e.infoPages(publicOnly);    
    }
  
    /// <summary>Add comment to the current element</summary>
    public Comment(str : string) : void { 
      this.comment += str;
    }
  
    /// <summary>Add remark to the current element</summary>
    public Remark(str : string) : void { 
      this.remark += str;
    }
  
    /// <summary>Add return info to the current element</summary>
    public Return(str : string) : void { 
      this.return += str;
    }
  
    /// <summary>Add param info to the current element</summary>
    public Param(str : string) : void { 
      this.param += str;
    }   
  
    /// <summary>Add example to the current element</summary>
    public Example(str : string) : void { 
      this.example += str;
    }   
    
    /// <summary>Add exception description to the current element</summary>
    public Exception(str : string) : void { 
      this.exception += str;
    }   
    
    /// <summary>Add permission description to the current element</summary>
    public Permission(str : string) : void { 
      this.permission += str;
    }   
    
  } // class TopNode

  
  /// <summary>
  /// Represents a 'concrete' (i.e. classes, fields, methods etc.) elements.
  /// </summary>
  public class Node : TopNode
  {
    /// <summary>A type of of a node.
    /// This field is set by XML analyzer</summary>
    public mutable XMLattrib : ElementType = ElementType.Unknown();
    
    /// <summary>Name of the element</summary>
    public mutable name : string;
    
    /// <summary>Full name of the element (with namespaces path)</summary>
    public mutable full_name : string = "";
  
    /// <summary>Returns the name of a file including description of the current node</summary>
    public html_file : string {
      get { if (parent is Node) (parent :> Node).full_name + ".html" else "index.html"}
    }
  
    /// <summary>If the current node is a namespace, it creates a table of content.</summary>
    public override ToIndex (content : ref string, publicOnly : bool) : void
    {
      when (this.XMLattrib.Equals(ElementType.Unknown()))
      {
        // Console.WriteLine("Podstrona typu {0}, nazwa {1}", this.elemType, this.full_name);
        // self-explanation
        content += namespace2html(this.elements, this.full_name, publicOnly);
    
        foreach (e in elements)
          when (e.XMLattrib.Equals(ElementType.Unknown())) e.ToIndex(ref content, publicOnly : bool);
      }
    }

    /// <summary>Creates a html page for the current namespace</summary>
    public override infoPages (publicOnly : bool) : void
    {    
      // Console.WriteLine("Zapis pliku {0}", this);
      // crreates a html page for the current namespace
      when (this.XMLattrib.Equals(ElementType.Unknown()))
      {
        def fname = this.full_name;
        mutable content = "";
        content += HtmlGenerator.Title("Nemerle Library", "Namespace " + fname);
        foreach (e in elements) {
          mutable priv = false;
          when (e.attribute != null)
              priv = e.attribute.Private;
          // Console.WriteLine("--> Element={0}, publicOnly={1}, priv={2}, cond={3}", e.name, publicOnly, priv, !publicOnly || !priv);
          when (!publicOnly || !priv)
            content += e.ToHtml();
          }
        HtmlGenerator.Page ( fun () { content }, fname + ".html");
      }
   
      // crreates a html page for each sub namespace
      foreach (e in elements)
        when (e.XMLattrib.Equals(ElementType.Unknown()))
          e.infoPages(publicOnly);
    }
  

    public this(name : string, prefiks : string, parent : TopNode)
    {
      this.name = name;
      this.full_name = prefiks;
      this.parent = parent;
      // Console.WriteLine("Nowy element Name " + prefiks);
    }
  
  
  
    filteredIter (l : list [ Node ], cond : Node -> bool, iter : Node -> string) : string
    {
      mutable res = "";
      foreach (e in l) when (cond(e)) res += iter(e);
      res;
    }
  
    /// <summary>Create full html description of the current node.</summary>
    public ToHtml () : string
    {
      mutable res = "";
      mutable com = if (comment.Length > 0) "<div class=\"komentarz\">" + comment + "</div>\n" else "";
      com += if (remark.Length > 0) "<div class=\"uwaga\">Remark: " + remark + "</div>\n" else "";
      com += if (return.Length > 0) "<div class=\"return\">Return: " + return + "</div>\n" else "";
      com += if (param.Length > 0) "<div class=\"param\">Parameter: " + param + "</div>\n" else "";
      com += if (example.Length > 0) "<div class=\"example\">Example:<br />" + example + "</div>\n" else "";
      com += if (exception.Length > 0) "<div class=\"exception\">Exception:<br />" + exception + "</div>\n" else "";
      com += if (permission.Length > 0) "<div class=\"permission\">Permission:<br />" + permission + "</div>\n" else "";
    
      mutable att = "";
      when (attribute != null) {
        when ( (attribute.attr & TypeAttributes.Public) != 0) att += " public ";
        when ( (attribute.attr & TypeAttributes.NotPublic) != 0) att += " notpublic ";
        when ( (attribute.attr & TypeAttributes.NestedPublic) != 0) att += " nested public class ";
        when ( (attribute.attr & TypeAttributes.Sealed) != 0) att += " sealed ";
        // when ( attribute.Private) att += " PRIVATE ";
        when (attribute.is_abstract) att += " abstract ";
        when (attribute.is_class) att += " class ";
        when (attribute.is_array) att += " array ";
        when (attribute.is_interface) att += " interface ";
        // last chance
        when (att.Length == 0) att = attribute.attr.ToString();
      }
    
      match (XMLattrib) {
        | Unknown => 
            res += "<div>Unknown element " + this.full_name + "</div>";
        | Property => res += "<span title=\"" + this.full_name + "\">" + att + name + "</span>" + com;
        | Method => res += "<span title=\"" + this.full_name + "\">" + att + name + "</span>" + com;
        | Field => res += att + name + com;
        | Type =>
            res += "<div class=\"ns-index\"" + ("id=\"" + this.href + "\"") + ">" + att;
            res += "<span class=\"ns-index\" title=\"" + this.full_name + "\">" + name + "</span>\n";
            res += com;
          
            def methods = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Method()) },   fun (e) { "<div class=\"element\">" + e.ToHtml() + "</div>\n"});
            when (methods.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Methods:</span>" + methods + "</div>";
          
            def props = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Property()) }, fun (e) { "<div class=\"element\">" + e.ToHtml() + "</div>\n"});
            when (props.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Properties:</span>" + props + "</div>";
          
            def fields = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Field()) },    fun (e) { "<div class=\"element\">" + e.ToHtml() + "</div>\n"});
            when (fields.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Fields:</span>" + fields + "</div>";
          
            def types = filteredIter(elements, fun (e) { e.XMLattrib.Equals(ElementType.Type()) },     fun (e) { "<div class=\"element\">" + e.ToHtml() + "</div>\n"});
            when (types.Length > 0) res += "<div class=\"elements-group\"><span class=\"elements-group\">Types:</span>" + types + "</div>";
          
            res += "</div>\n";
      }
      res  
    } // method ToHtml
  } // class Node

  /// <summary>
  /// The class DataTree is a front-end for other modules which analyse input files.
  /// </summary>
  class DataTree
  {
    split (str : string) : char*string { (str[0], str.Substring(2)) }
    
    // top node of the tree
    mutable tree : TopNode = TopNode();
    
    // recently added or processed node.
    mutable currentNode : Node;
    
    // list of the sources
    mutable sources : list [ string ] = [];

    ///<summary>Creates a string (html) representation of the sources of the program</summary>
    public sourcesToString () : string
    {
      mutable res = "";
      res += 
          match (sources.Length) {
                | 0 => "No sources?"
                | 1 => "Source: "
                | _ => "Sources:<br /> "
          }
      when (sources.Length > 0)
      {
        res += List.Head(sources);
        def r = List.Tail(sources);
        foreach (e in r) res += ", " + e;
      }
      res
    }
  
    /// <summary> Adds info about a file name being the current input</summary>
    public AddSource(src : string) : void
    {
      sources += [ src ]
    }     
  
    smart_strip1(path : string) : list [ string ]
    {
      smart_strip(path, '(')
    }
  
    /// <summary>Strip, but avoid stripping '[' char</summary>
    smart_strip2(path : string) : list [ string ]
    {
      smart_strip(path, '[')
    }
  
    smart_strip(path : string, sep : char) : list [ string ]
    {
      // first split into name and parameters
      def par_pos = path.IndexOf(sep);
      def path_name = if (par_pos != -1) path.Substring(0, par_pos) else path;
      def param = if (par_pos != -1) path.Substring(par_pos) else "";
     
      // Console.WriteLine("{0} = ({1},{2})", path, path_name, param);
    
      mutable token_list = Nemerle.Collections.List.FromArray(path_name.Split(array ['.', '+']));
      mutable res = [];
      // analyze name
      while (token_list.Length > 1)
      {
        mutable r = List.Hd(token_list);
  
        // when not .., i.e. ctor
        when (r.Length != 0)
        {
          res += [ r ];
          // Console.WriteLine("<-- " + r);
        }
        when (token_list.Length > 0) token_list = List.Tl(token_list)
      } // while ()
      def last = List.Hd(token_list);
      def last_token = if (par_pos > -1) (last + param) else last;
      res += [ last_token ];
      res
    }
  
    memb (set : TopNode, name : string) : Node
    {
      mutable res = null;
      foreach (e in set.elements) when (name.Equals(e.name)) res = e;
      res;
    }
  
    /// <summary>
    /// Adds a new element (typically a class) to the tree. Used by assembly analyzer.
    /// </summary>
    public AddItem(str : string, ty : ElementType, attr : ReflAttribs) : void
    {
      def path = smart_strip2(str);
      // Console.WriteLine("Ścieżka {0}", str);
      mutable pointer = tree;
      mutable next;
      foreach (edge in path)
      {    
        // Console.WriteLine("--> podścieżka " + edge);
        next = memb(pointer, edge);
        when (next == null)
        {
          def pref = if (pointer is Node) ((pointer :> Node).full_name + "." + edge) else edge;
          next = Node(edge, pref, pointer);
          pointer.elements = pointer.elements + [ next ];
        }
        pointer = next;
      }
      pointer.attribute = attr;
      next.XMLattrib = ty
    } // AddItem
  
    /// <summary>
    /// Adds a new element (a member of a class) to the tree. Used by assembly analyzer.
    /// </summary>
    public AddItem(ns_path : string, typename : string, ty : ElementType) : void
    {
      def path = smart_strip2(ns_path) + [ typename ];
      // Console.WriteLine("Ścieżka {0}", str);
      mutable pointer = tree;
      mutable next;
      foreach (edge in path)
      {    
        // Console.WriteLine("--> podścieżka " + edge);
        next = memb(pointer, edge);
        when (next == null)
        {
          def pref = if (pointer is Node) ((pointer :> Node).full_name + "." + edge) else edge;
          next = Node(edge, pref, pointer);
          pointer.elements = pointer.elements + [ next ];
        }
        pointer = next;
      }
      next.XMLattrib = ty
    }
  
    /// <summary>
    /// Add a new element to the tree. An argument is a string consisting of
    /// a stringified declaration of an element. Used by the XML analyzer.
    /// </summary>
    public AddItem (str : string) : void
    {
      // System.Console.WriteLine("---> " + str);
      def (tySy, path) = split(str);
      // System.Console.WriteLine("---> split({0}) = ({1}, {2})", str, tySy, path);
      def ty = 
        match (tySy) {
          | 'T' => ElementType.Type();
          | 'F' => ElementType.Field();
          | 'M' => ElementType.Method();
          | 'P' => ElementType.Property()
          |  _  => ElementType.Unknown()
        }
    
      def pathList = smart_strip1(path);
      // Console.WriteLine("Path to strip: {0}", path);
      // foreach (n in pathList) Console.WriteLine("--> {0}", n);
      mutable pointer = tree;
      mutable next;
      foreach (edge in pathList)
      {    
        next = memb(pointer, edge);
        when (next == null)
        {
          def pref = if (pointer is Node) ((pointer :> Node).full_name + "." + edge) else edge;
          next = Node(edge, pref, pointer);
          pointer.elements = pointer.elements + [ next ];
        }
        pointer = next;
      }
      currentNode = next;
      currentNode.XMLattrib = ty;
      // Console.WriteLine("Added {0} {1}", tree.current.full_name, tree.current.elemType);
    }
    
    public AddComment (str : string) : void 
    {
      currentNode.Comment(str);
    }
  
    public AddRemark (str : string) : void 
    {
      currentNode.Remark(str);
    }
  
    public AddReturn (str : string) : void 
    {
      currentNode.Return(str);
    }
  
    public AddParam (str : string) : void 
    {
      currentNode.Param(str);
    }
  
  
    public AddExample (str : string) : void 
    {
      currentNode.Example(str);
    }
  
    public AddException (str : string) : void 
    {
      currentNode.Exception(str);
    }
    
    public AddPermission (str : string) : void 
    {
      currentNode.Permission(str);
    }
    
    index_content (publicOnly : bool) : string
    {
      mutable content = "";
      content += HtmlGenerator.Title("Nemerle Library", this.sourcesToString());
      // teraz zawartość
     
      tree.ToIndex(ref content, publicOnly);
      content;
    }
  
  
    public indexPage(publicOnly : bool) : void
    {
      HtmlGenerator.Page(fun () { index_content(publicOnly) }, "index.html");
    }
  
    public infoPages (publicOnly : bool) : void
    {
      tree.infoPages(publicOnly);
    }
  
  } // class DataTree

} // namespace NemerleDoc
