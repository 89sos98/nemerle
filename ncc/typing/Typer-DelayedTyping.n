/*
 * Copyright (c) 2005-2008 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler
{
  public partial class Typer
  {
    public abstract class DelayedAction
    {
      public abstract Resolve (fail_loudly : bool) : option [TExpr];

      public override ToString () : string
      {
        "delayed macro"
      }
    }

    public class DelayedLambdaAction : DelayedAction
    {
      desc : string;
      fn : bool -> option [TExpr];

      public override ToString () : string
      { 
        desc
      }

      public override Resolve (fail_loudly : bool) : option [TExpr]
      {
        fn (fail_loudly)
      }

      public this (fn : bool -> option [TExpr], desc = "delayed typing action")
      {
        this.fn = fn;
        this.desc = desc;
      }
    }

    
    // TODO: object model seems to fit better here, upgrade most kinds to use DelayedAction
    [ManagerAccess (typer.Manager)]
    public class DelayedTyping : Located, System.IComparable [DelayedTyping]
    {
      id : int;
      typer : Typer;
      local_context : LocalContext;
      expected : TyVar;
      mutable pexpr : PT.PExpr;
      mutable generic_specifier : list [TyVar];

      [Record]
      public variant Kind
      {
        | MemberAccess { expr : TExpr; name : PT.Name; }
        | Overloaded { overloads : list [OverloadPossibility]; }
        | OverloadedOperator { overloads : list [OverloadPossibility]; 
                               t1 : TyVar; t2 : TyVar; name : string; env : GlobalEnv; 
                               seen : list [OverloadPossibility];
                             }
        | Operator { t1 : TyVar; t2 : TyVar; name : string; env : GlobalEnv; }
        | Resolved { expr : TExpr; }
        | Macro { action : DelayedAction }
        | Error

        public mutable filtering_expression : TExpr.Call;
        public mutable need_ref : bool;
        public mutable need_write : bool;

        public this () {}
      }


      public CompareTo (o : DelayedTyping) : int
      {
        id - o.id
      }


      public DtKind : Kind
      {
        get {
          typer.solver.dt_store.Get (this)
        }
      }


      public ApplyGenericSpecifier (tyvars : list [TyVar]) : void
      {
        assert (generic_specifier == null);
        generic_specifier = tyvars;
        // apply it (possibly)
        SetKind (DtKind);
      }


      SetKind (k : Kind) : void
      {
        match (k) {
          | Kind.Resolved (expr) =>
            when (PExpr != null)
              PExpr.typed_object = expr;
            _ = typer.Expect (expected, expr.Type, "resolved overload");
          | _ => {}
        }

        def k =
          match (k) {
            | Kind.Resolved ((TExpr.StaticRef (_, meth is IMethod, _)) as expr) =>
              match (meth.BuiltinKind) {
                | BuiltinMethodKind.OpCode (ch, unch) =>
                  def opcode = if (local_context.IsChecked) ch else unch;
                  Kind.Resolved (TExpr.OpCode (expr.Location, expr.ty, opcode))
                | _ => k
              }
            | Kind.Overloaded (lst) =>
              when (expected.Hint.IsNone && List.ForAll (lst, x => x.Type is MType.Fun))
                _ = expected.Unify (MType.Fun (typer.FreshTyVar (), typer.FreshTyVar ()));
              Kind.Overloaded (OverloadPossibility.Unique (lst))
            | Kind.OverloadedOperator (lst, t1, t2, n, e, s) =>
              Kind.OverloadedOperator (OverloadPossibility.Unique (lst), t1, t2, n, e, s)
            | _ => k
          }

        when (generic_specifier != null)
          match (k) {
            | Kind.OverloadedOperator (lst, _, _, _, _, _) 
            | Kind.Overloaded (lst) =>
              foreach (o in lst)
                o.SetGenericSpecifier (generic_specifier);
              generic_specifier = null;
              
            | Kind.Resolved (expr) =>
              typer.ApplyGenericSpecifier (expr, generic_specifier);
              generic_specifier = null;
              
            | _ => {}
          }
          
        def solver = Manager.Solver;

        match (solver.dt_store.Find (this)) {
          | Some (k') =>
            when (k.filtering_expression == null)
              k.filtering_expression = k'.filtering_expression;
            k.need_ref = k'.need_ref;
            k.need_write = k'.need_write;
          | None => {}
        }

        solver.dt_store = solver.dt_store.Replace (this, k);

        match (k) {
          | Kind.Resolved (expr) =>
            when (k.need_write)
              typer.CheckLValue (expr, k.need_ref, 
                 if (k.need_ref) "ref/out parameter"
                 else "assignment target");
          | _ => {}
        }
      }


      public this (t : Typer, k : Kind, e : TyVar)
      {
        typer = t;
        local_context = t.local_context;
        Manager.Typer_DT_Id++;
        id = Manager.Typer_DT_Id;
        expected = e;
        SetKind (k)
      }


      public IsMutableIndexer : bool
      { 
        get {
          match (DtKind) {
            | Kind.OverloadedOperator (lst, _, _, _, _, _) 
            | Kind.Overloaded (lst) =>
              List.ForAll (lst, fun (op : OverloadPossibility) {
                match (op.Member) {
                  | p is IProperty => p.IsMutable && p.IsIndexer
                  | _ => false
                }
              })

            | Kind.Resolved (TExpr.PropertyMember (_, p))
            | Kind.Resolved (TExpr.StaticPropertyRef (_, p)) =>
              p.IsIndexer && p.IsMutable

            | _ => false
          }
        }
      }

      public IsFunctional : bool
      {
        get {
          match (DtKind) {
            | Kind.OverloadedOperator (lst, _, _, _, _, _) 
            | Kind.Overloaded (lst) =>
              lst.ForAll (fun (op) { op.Member is IMethod })

            | Kind.Resolved (TExpr.StaticRef (_, _ is IMethod, _)) => true

            | _ => false
          }
        }
      }

      public ExpectLValue (need_ref : bool) : bool
      {
        def kind = DtKind;
        kind.need_write = true;
        when (need_ref)
          kind.need_ref = true;

        match (kind) {
          | Kind.Overloaded (lst) =>
            !need_ref &&
            match (List.RevFilter (lst, fun (o : OverloadPossibility) {
              match (o.Member) {
                | p is IProperty => p.IsMutable && !need_ref
                | f is IField    => f.IsMutable 
                  || typer.is_instance_ctor && f.DeclaringType.Equals(typer.current_type)
                  
                | _              => false
              }
            })) {
              | [] => false
              | newlst =>
                SetKind (Kind.Overloaded (newlst));
                true
            }
 
          | Kind.Resolved (r) => typer.IsLValue (r, need_ref)

          | Kind.MemberAccess
          | Kind.Macro
          | Kind.Error => true

          | Kind.OverloadedOperator 
          | Kind.Operator => false
        }
      }

      public ExpectMember (name : string) : void
      {
        def can_have (_ : MType) {
          | Class (tc, _) => ! (tc.LookupMember (name) is [])
          | Array (_, n) => ! (InternalType.GetArrayType (n).LookupMember (name) is [])
          | TyVarRef (tv) => tv.Constraints.Exists (can_have)
          | Intersection (lst) => lst.Exists (can_have)
          | Tuple | Fun | Void | Ref | Out => false
        }

        match (DtKind) {
          | Kind.OverloadedOperator (lst, t1, t2, n, e, s) => 
            when (InternalType.Object_tc.LookupMember (name) is []) {
              // otherwise it's pointless
              def newlst = List.RevFilter (lst, fun (o : OverloadPossibility) {
                match (o.Type.Hint) {
                  | Some (mt) => can_have (mt)
                  | None => true // we don't yet know
                }
              });

              if (newlst is []) {}
              else SetKind (Kind.OverloadedOperator (newlst, t1, t2, n, e, s));
            }

          | Kind.Overloaded (lst) =>
            when (InternalType.Object_tc.LookupMember (name) is []) {
              // otherwise it's pointless
              def newlst = List.RevFilter (lst, fun (o : OverloadPossibility) {
                match (o.Type.Hint) {
                  | Some (mt) => can_have (mt)
                  | None => true // we don't yet know
                }
              });

              if (newlst is []) {}
              else SetKind (Kind.Overloaded (newlst));
            }

          | _ => {}
        }
      }

      public IsResolved : bool
      {
        get {
          match (typer.solver.dt_store.Find (this)) { //DtKind
            | Some (Kind.Resolved)
            | Some (Kind.Error) => true
            | _ => false
          }
        }
      }


      public ResolutionResult : TExpr
      {
        get {
          match (DtKind) {
            | Kind.Resolved (e) => e
            | Kind.Error => TExpr.Error ()
            | _ => assert (false)
          }
        }
      }


      public override ToString () : string
      {
        match (DtKind) {
          | Resolved (a) => "resolved expression " + a.ToString ()
          | Error => "an error"
          | Overloaded (overloads) =>
            "ambiguity between overloads:\n  " + overloads.ToString ("\n  ")
          | MemberAccess (expr, name) =>
            $ "accessing member `$(name)' in `$(expr)' : $(expr.Type)"
          | Operator (t1, t2, name, _) =>
            $ "operator `$(name)' on $(t1)"
            + (if (t2 == null) "" else $ " and $(t2)")
          | OverloadedOperator (lst, t1, t2, name, _, _) => 
            $ "overloaded operator `$(name)' on $(t1)"
            + (if (t2 == null) "" else $ " and $(t2)") + "\n" 
            + lst.ToString ("\n ")
          | Macro (action) => action.ToString ()
        }
      }

      public GetDescriptionForError () : list [Location * string]
      {
        def loc = this.Location;
        def used(o) { o.UsedLastTime }
        def makeOverloads(overloads, msg)
        {
          def makeLoc(x) 
          {
            def memLoc  = x.Member.Location;
            if (memLoc.Line == 0 || !System.IO.File.Exists(memLoc.File)) loc
            else memLoc
          }
          def overloads1 = if (overloads.Exists(used)) overloads.Filter(used) 
                           else                        overloads;
          (loc, msg) :: overloads1.Map(x => (makeLoc(x), $"Posible overload: $x"))
        }
        
        match (DtKind) 
        {
          | OverloadedOperator ([], t1, t2, name, _env, _seen) =>
            def msg = $"finding the operator $name($t1" + (if (t2 != null) $", $t2" else "") + ")";
            (loc, msg) :: []

          | OverloadedOperator (overloads, t1, t2, name, _env, _seen) =>
            def msg = $"ambiguity between operator $name($t1" 
                       + (if (t2 != null) $", $t2" else "") + ")" + " overloads:";
            makeOverloads(overloads, msg)
            
          | Overloaded (overloads) => makeOverloads(overloads, "ambiguity between overloads:")
          | Macro (action) =>
            // the Resolve function should dump the error message
            Util.locate (Location, {
              def res = action.Resolve (true);
              when (res.IsSome)
                Message.Error ($ "the macro resolution function unexpectedly succeeded "
                                 "when run for the second time, the result is "
                                 "$(Option.UnSome (res))");
            });
            [(loc, ToString())]
            
          | _  => [(loc,ToString ())]
        }
      }


      public IsOverloaded : bool
      {
        get { DtKind is Kind.Overloaded || DtKind is Kind.OverloadedOperator }
      }


      public Context : LocalContext
      {
        get { local_context }
      }


      public PExpr : PT.PExpr
      {
        get { pexpr }
        set { pexpr = value }
      }


      public CanSetCallExpr : bool
      {
        get {
          match (DtKind) {
            | MemberAccess
            | Overloaded
            | OverloadedOperator
            | Error
            | Operator => true
            | Resolved
            | Macro => false
          }
        }
      }


      public SetCallExpr (e : TExpr.Call) : void
      {
        def kind = DtKind;
        Util.cassert (CanSetCallExpr);
        if (kind.filtering_expression == null)
          kind.filtering_expression = e;
        else
          Util.cassert (kind.filtering_expression : object == e : object)
      }


      ResolveOverload (overloads : list [OverloadPossibility], 
                       parms : list [Parm], expected : TyVar)
                       : list [OverloadPossibility]
      {
        def solver = typer.solver;
        def messenger = solver.CurrentMessenger;

        foreach (overload in overloads)
          overload.UsedLastTime = false;

        def has_untyped_parm = parms.Exists (p => p.expr.Type.Hint.IsNone);

        def try_type (overload : OverloadPossibility, final) {
          def parms =
            if (overload.ExtensionMethodObject == null) parms
            else Parm (overload.ExtensionMethodObject) :: parms;
          def ct = CallTyper (typer, overload.Compile (), parms, expected);
          ct.overload_possibility = overload;
          ct.is_final = final;
          ct.is_var_args = overload.VarArgs;
          overload.ResetOverloadSelectionStuff ();
          ct.Run ();
          if (ct.result == null || (overload.VarArgs && !ct.used_var_args))
            TExpr.Error ()
          else {
            unless (ct.result is TExpr.Error) {
              overload.PermutationArray = ct.GetPermutationArray ();
              overload.UsedDefaultParms = ct.used_default_parms;
            }
            ct.result
          }
        }

        def print_error_message (overload : OverloadPossibility) {
          solver.PushState ();
          messenger.NeedMessage = true;
          _ = try_type (overload, final = false);
          solver.PopState ();
        }

        match (OverloadPossibility.OnlyPossible (overloads, null)) {
          | [] => []

          | overloads =>
            mutable ok = [];

            // Message.Debug ($ "try type: $overloads");
            foreach (overload in overloads)
            {
              try { solver.PushState ();
              unless (IsError (try_type (overload, final = false)))
                ok = overload :: ok;
              } finally { solver.PopState (); }
            }
            // Message.Debug ($ "res: $ok");
            
            def makeArgsTypes() { parms.Map(p => p.expr.Type) }
            
            match (typer.GetBestOverloads(ok, makeArgsTypes()))
            {
              | [] =>
                when (messenger.NeedMessage) 
                {
                  match (overloads) 
                  {
                    | [o] =>
                      print_error_message (o);
                    | _ =>
                      ReportError (messenger, "each overload has an error during call:");
                      mutable cnt = 1;
                      foreach (o in overloads) 
                      {
                        ReportError (messenger, $ "overload #$cnt, $o");
                        print_error_message (o);
                        ++cnt;
                      }
                  }
                }
                []

              /*
                In general we do not commit to a single, best overload when we still
                have some parameters that have no Hint (which means they are of a totally
                unknown type), except:
                  - when it is the only possible overload, 
                  - we're in a special second pass of delayed typings or 
                  - it is == or !=. 

                The last part is a hack, it might be a good idea to
                commit to a single overload also in some other cases
                but the comparison operators seem to be crucial.

                Bug #770.
              */

              | [one] when 
                ok is [_] || 
                !has_untyped_parm ||
                typer.BadnessAllowed > 0 || 
                one.Member.Name == "op_Equality" ||
                one.Member.Name == "op_Inequality" =>

                match (try_type (one, final = true)) {
                  | TExpr.Call (_func, parms, _) =>
                    def expr = DtKind.filtering_expression;
                    // XXX this shouldn't be needed
                    // expr.func = _func;
                    expr.parms = parms;
                  | _ => assert (false)
                }
                one.UsedLastTime = true;
                [one]

              // This is important -- we only drop the clearly evil
              // solutions. We leave the less general ones (dropped by 
              // GetBestOverloads), as it is possible we will need them 
              // later.
              //
              // However we still mark only the best overloads in case we want
              // an error message later.
              | lst => 
                foreach (o in lst)
                  o.UsedLastTime = true;
                ok 
            }
        }
      }


      LookupOperatorIn (bound : MType, name : string) : list [OverloadPossibility]
      {
        mutable res = [];
        
        def loop (ti : TypeInfo) {
          foreach (meth is IMethod in ti.LookupMember (name))
            when (meth.IsStatic)
              res = typer.ConstructMethodOverload (ti, meth) + res;
          match (ti.GetTydecl ()) {
            | TypeDeclaration.Interface =>
              loop (InternalType.Object_tc)
            | _ =>
              Option.Iter (ti.SuperClass (), loop)
          }
        }

        match (bound) {
          | MType.Class (ti, _) =>
            loop (ti);
            res
          | _ => assert (false)
        }
      }


      LookupOperator (t : TyVar, name : string) : option [list [OverloadPossibility]]
      {
        assert (name != null);
        if (t == null)
          None ()
        else {
          match (t.AnyHint) {
            // This is kind of ugly special case, we sometimes claim, the
            // lower bound is System.Object in cases we don't really 
            // think this will be the final type. 
            // Therefore, for operators, that cannot be found in System.Object,
            // don't even try. The ugly part, is that it won't work for ==/!=
            | Some (Class (tc, []))
              when tc.Equals (InternalType.Object_tc) && 
                   name != "op_Equality" && name != "op_Inequality" => 
              None ()

            | Some (MType.Class as bound) =>
              Some (LookupOperatorIn (bound, name))

            | Some (MType.Array) =>
              Some (LookupOperatorIn (InternalType.Array, name))

            | Some (MType.TyVarRef (a)) =>
              LookupOperator (a.LowerBound, name)

            | Some (MType.Intersection (lst)) =>
              mutable res = [];
              foreach (MType.Class as t in lst) {
                res = LookupOperatorIn (t, name) + res
              }
              Some (res)

            | Some (MType.Fun (from, to)) =>
              // Ugly thing, class representing function depends on parameters voidness
              match (from.AnyHint) {
                | None when typer.BadnessAllowed > 2 with args = [MType.Void ()] //seem to work somehow
                | Some (MType.Tuple (args))
                | Some (MType.Void) with args = []
                | Some (x) with args = [x] =>
                  def inst = InternalType.GetFunctionType (args.Length);
                  Some (
                    LookupOperatorIn (
                      match (to.AnyHint) {
                        | Some (MType.Void) =>
                          MType.Class (inst.VoidTyCon, args)
                        | None when typer.BadnessAllowed > 2 //seem to work somehow
                        | Some => 
                          MType.Class (inst.TyCon, (args + [to]))
                        | None => 
                          InternalType.Object
                      },
                      name
                    )
                  )
                | _ => Some (LookupOperatorIn (InternalType.Object, name))
              }

            | _ => None ()
          }
        }
      }

      DoResolve () : void
      {
        def solver = typer.solver;
        def messenger = solver.CurrentMessenger;
        match (DtKind) {
          | Kind.MemberAccess (e, name) =>
            match (typer.TypeMember (e, name, expected)) {
              | Some ([]) =>
                ReportError (messenger,
                             $ "there is no member named `$(name)' "
                               "in $(typer.TypeOf (e)) with type $expected");
                SetKind (Kind.Error ())

              | Some (lst) =>
                SetKind (Kind.Overloaded (lst));
                when (DtKind.need_write && !ExpectLValue (false))
                  ReportError (messenger, $"needed writable value, got $lst");

                // restart with more information
                Resolve ()

              | None => {}
            }

          | Kind.Overloaded (overloads) =>
            def expr = DtKind.filtering_expression;
            def o' =
              if (expr == null) 
              {
                def res1 = OverloadPossibility.OnlyPossible (overloads, expected);
                def isAllOverloadsHaveSameArgCnt (overloads)
                {
                  assert (overloads.Length > 1);

                  def cntArgsForEachOverload = overloads.Map (arg =>
                    match (arg.Type.Fix ().FixedValue)
                    {
                      | MType.Fun (from, _) =>
                        match (from)
                        {
                          | MType.Tuple (lst) => lst.Length
                          | MType.Void => 0
                          | _ => 1
                        }
                      | _ => 0
                    });

                  def argsCnt = cntArgsForEachOverload.Tail.Fold (
                    cntArgsForEachOverload.Head, (arg, prev) => if (arg == prev) arg else -1);

                  argsCnt >= 0
                }

                def res2 = if (res1.Length > 1 && isAllOverloadsHaveSameArgCnt (res1))
                    typer.GetBestOverloads (res1);
                  else if (res1.Length > 1)
                    RemoveExtensionMethods (res1)
                  else
                    res1;

                res2

              }
              else
              {
                if (typer.Expect (expected, expr.func.Type, 
                                  "overloaded function call"))
                  ResolveOverload (overloads, expr.parms, expr.Type)
                else
                  []
              }

            when (o'.Length != overloads.Length || o'.Length == 1)
              match (o') {
                | [] =>
                  SetKind (Kind.Error ())

                | [one] =>
                  SetKind (Kind.Resolved (one.Compile ()))

                | lst =>
                  SetKind (Kind.Overloaded (lst))
              }
          | Kind.OverloadedOperator (overloads, t1, t2, name, env, seen) =>
            def not_seen (l) { 
              | None with l = []
              | Some (l) =>
                l.Filter ( fun (x) { !seen.Contains (x) } );
            }
            def new_operators = not_seen (LookupOperator (t1, name)) + not_seen (LookupOperator (t2, name));
            def seen = new_operators + seen;
            def added = 
              match (new_operators) {
                | lst when lst != [] =>
                  def lst = OverloadPossibility.Unique (overloads + lst);
                  if (lst == overloads)
                    false
                  else
                  {
                    SetKind (Kind.OverloadedOperator (lst, t1, t2, name, env, seen));
                    Resolve ();
                    true
                  }
                | _ => false
              }
            unless (added)
            {
                def args = if (t2 == null) 1 else 2;
                def hints = (if (t1.Hint.IsSome) 1 else 0) + (if (t2 != null && t2.Hint.IsSome) 1 else 0);

                def expr = DtKind.filtering_expression;
                def o' =
                  if (expr == null) {
                    RemoveExtensionMethods (OverloadPossibility.OnlyPossible (overloads, expected))
                  } else {
                    if (typer.Expect (expected, expr.func.Type, 
                                        "overloaded function call"))
                      match (overloads) {
                        | [one] when hints == 0 && typer.BadnessAllowed < 1 =>
                          [one] //don't call ResolveOverload early, as it can add wrong hints
                        | _ => ResolveOverload (overloads, expr.parms, expr.Type)
                      }
                    else
                      []
                  }

                when (o'.Length != overloads.Length || o'.Length == 1)
                  match (o') {
                    | [one] when hints == args
                              || hints > 0 && typer.BadnessAllowed > 0
                              || typer.BadnessAllowed > 1 =>
                      when (expr != null) //ResolveOverload maybe wasn't called, but it should be to set stuff in expr
                        _ = ResolveOverload (overloads, expr.parms, expr.Type);
                      SetKind (Kind.Resolved (one.Compile ()))

                    | lst =>
                      SetKind (Kind.OverloadedOperator (lst, t1, t2, name, env, seen));
                  }
              }

          | Kind.Operator (t1, t2, name, env) =>
            def operators = {
              def globals = env.LookupSymbolExt ([name], typer.current_type);
              mutable res = [];
              foreach ((ti, meth) in globals)
                when (meth.IsStatic)
                  res = typer.ConstructMethodOverload (ti, meth :> IMethod) + res;
              when (LookupOperator (t1, name) is Some (lst))
                res = lst + res;
              when (LookupOperator (t2, name) is Some (lst))
                res = lst + res;
              res = OverloadPossibility.Unique (res);
              res
            }
            SetKind (Kind.OverloadedOperator (operators, t1, t2, name, env, operators));
            Resolve ()
            
          | Kind.Resolved (expr) =>
            unless (typer.Expect (expected, expr.Type, "already resolved overload"))
              SetKind (Kind.Error ())

          | Kind.Macro (action) =>
            Util.locate (Location,
              match (action.Resolve (false)) {
                | Some (expr) =>
                  if (typer.Expect (expected, expr.Type, $ "result of $action execution"))
                    SetKind (Kind.Resolved (expr))
                  else
                    SetKind (Kind.Error ())

                | None => {}
              })

          | Kind.Error => {}
        }
      }

      public Resolve () : void
      {
        Util.locate (Location, {
          def tmp = typer.local_context;
          try {
            typer.local_context = local_context;
            DoResolve ();
          } finally {
            typer.local_context = tmp;
          }
        })
      }
    }
  }
}
