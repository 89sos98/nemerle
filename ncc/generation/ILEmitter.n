/*
 * Copyright (c) 2003, 2004 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler
{
  using Nemerle.Compiler;
  using Nemerle.Collections;
  using Nemerle.Utility;

  using System.IO;
  using System.Reflection;
  using System.Reflection.Emit;
  using System.Diagnostics.SymbolStore;

  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  class CodeGenerator
  {
    private _module_builder : ModuleBuilder;
    private _ilg : ILGenerator;    

    private _this_is_value_type : bool;
    private _type_of_this : System.Type;

    private  _method_name : string;
    private _method_is_static : bool;
    private _cg_method : CG_method;
    private mutable _method_start_label : Label;
    private mutable _debug_doc : ISymbolDocumentWriter;        

    /**
     * Creates and executes a code generator for a method
     */
    internal this (method_builder : MethodBuilder, module_builder : ModuleBuilder, 
                   cg_method : CG_method)
    {
      _cg_method = cg_method;

      _ilg = method_builder.GetILGenerator ();
      _module_builder = module_builder;

      _method_name = method_builder.DeclaringType.FullName + "::" + method_builder.Name;
      _method_is_static = method_builder.IsStatic;
      _this_is_value_type = method_builder.DeclaringType.IsValueType;
      _type_of_this = method_builder.DeclaringType;
    }


    /**
     * Creates and executes a code generator for a method
     */
    internal this (constructor_builder : ConstructorBuilder,
                   module_builder : ModuleBuilder, cg_method : CG_method)
    {
      _cg_method = cg_method;

      _ilg = constructor_builder.GetILGenerator ();
      _module_builder = module_builder;

      _method_name = constructor_builder.DeclaringType.FullName + "::"
                      + constructor_builder.Name;
      _method_is_static = constructor_builder.IsStatic;
      _this_is_value_type = constructor_builder.DeclaringType.IsValueType;
      _type_of_this = constructor_builder.DeclaringType;
    }

    public Run () : void {
      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);
    
      emit (_cg_method.body);
      unless (throws (_cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }

    private is_always_true (expr : CExpr) : bool
    {
      | CExpr.Literal (Literal.Bool (true)) => true

      | CExpr.If (cond_expr, then_expr, else_expr) =>
        def cond_always_true = is_always_true (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_true = is_always_true (then_expr);
        def else_always_true = is_always_true (else_expr);
        
        cond_always_true && then_always_true ||
        cond_always_false && else_always_true ||
        then_always_true && else_always_true

      | _ => false
    }

    public SetDocument (loc : Location) : void
    {
      if (loc != Location.Default)
        _debug_doc = _module_builder.DefineDocument (Path.GetFullPath (loc.File), 
          SymDocumentType.Text, SymLanguageType.ILAssembly, SymLanguageVendor.Microsoft);
      else
        assert (false, "missing location");
    }

    private is_always_false (expr : CExpr) : bool
    {
      | CExpr.Literal (Literal.Bool (false)) => true

      | CExpr.If (cond_expr, then_expr, else_expr) =>
        def cond_always_true = is_always_true (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_false = is_always_false (then_expr);
        def else_always_false = is_always_false (else_expr);

        cond_always_true && then_always_false ||
        cond_always_false && else_always_false ||
        then_always_false && else_always_false
        
      | _ => false
    }

    private throws (expr : CExpr) : bool
    {
      expr.flags %&& CgExprFlags.Throws
    }

    private wish_address (expr : CExpr) : bool
    {
      expr.flags %&& CgExprFlags.WishAddress || 
      expr.flags %&& CgExprFlags.NeedAddress
    }

    /** Emit volatile prefix if needed. */
    private maybe_volatile (expr : CExpr) : void
    {
      | CExpr.VolatileGlobalRef
      | CExpr.VolatileFieldRef => _ilg.Emit (OpCodes.Volatile)
      | _ => ()
    }

    /** Marks the point in source file for currently emmited opcode */
    Mark (loc : Location) : void
    {
      // Message.debug (loc, $"loc: $(loc.Line):$(loc.Column) $(loc.EndLine):$(loc.EndColumn)");  
      when (Options.EmitDebug && loc.Line != 0) 
        _ilg.MarkSequencePoint (_debug_doc, loc.Line, loc.Column, loc.EndLine, loc.EndColumn);
    } 

    /**
     * Emits an expression.
     */
    private emit (expr : CExpr) : void
    {
      // Message.debug (expr.loc, "emit: " + pretty_print (expr));
      match (expr) {

        /* -- SEQUENCING --------------------------------------------------- */

        /* emits a sequence of expressions */
        | CExpr.Sequence (expr_seq) => 
          foreach (e in expr_seq) emit (e);

        /* emits a local value definition */
        | CExpr.Define (let_val, let_in) =>
          def newscope = 
          match (let_val.val) {
            | CExpr.Nop => 
              if (SystemType.Void.Equals (let_val.ty))
                false
              else {
                _ = declare_val_local_slot (let_val);
                true
              }

            | CExpr.InitValueType (t) =>
              def slot = declare_val_local_slot (let_val);
              Mark (let_val.loc);
              _ilg.Emit (OpCodes.Ldloca, slot);
              _ilg.Emit (OpCodes.Initobj, t);
              true
                            
            | _ =>
              emit (let_val.val);
              if (SystemType.Void.Equals (let_val.ty)) 
                false
              else {
                def local_slot = declare_val_local_slot (let_val);
                Mark (let_val.loc);
                _ilg.Emit (OpCodes.Stloc, local_slot);
                true
              };
          };
          emit (let_in);
          when (Options.EmitDebug && newscope) _ilg.EndScope ();


        /* ignores the results of a computation */
        | CExpr.Ignore (ignored) =>
          // a little trickery, so emit can be tail called sometimes
          if (SystemType.Void.Equals (ignored.SystemType))
            emit (ignored)
          else {
            emit (ignored);
            Mark (expr.loc);
            _ilg.Emit (OpCodes.Pop);
          }

        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction, special case for constants */
        | CExpr.If (cond_expr, then_expr, _) when is_always_true (cond_expr) =>
          emit (then_expr)

        /* emits the if/then/else construction, special case for constants */
        | CExpr.If (cond_expr, _, else_expr) when is_always_false (cond_expr) =>
          emit (else_expr)

        /* emits the if/then/else construction */
        | CExpr.If (cond_expr, then_expr, else_expr) =>
          def emit_branch (expr, else_label : Label) {
            match (expr) {
              | CExpr.Call (CExpr.Opcode (opcode), parms) =>
                List.Iter (parms, emit);

                /* NOTE: the opcodes are swapped so that the 'then' expression
                         can be emitted before the 'else' expression */
                def opcode =
                  match (opcode) {
                    | "==" => OpCodes.Bne_Un
                    | "!=" => OpCodes.Beq
                    | "<.s" | "<.f" => OpCodes.Bge
                    | "<.u" => OpCodes.Bge_Un
                    | ">.s" | ">.f" => OpCodes.Ble
                    | ">.u" => OpCodes.Ble_Un
                    | "<=.s" | "<=.f" => OpCodes.Bgt
                    | "<=.u" => OpCodes.Bgt_Un
                    | ">=.s" | ">=.f" => OpCodes.Blt
                    | ">=.u" => OpCodes.Blt_Un
                    | "bool.!" => OpCodes.Brtrue_S                    
                    | _ => Util.ice ("invalid opcode '" + opcode +
                                     "' in optimized CExpr.If pattern")
                  };
                Mark (expr.loc);
                _ilg.Emit (opcode, else_label);

              | CExpr.HasType (val, ty) =>
                emit (val);
                Mark (expr.loc);
                _ilg.Emit (OpCodes.Isinst, ty);
                _ilg.Emit (OpCodes.Brfalse, else_label);

              | CExpr.If (new_cond, new_then, new_else) =>
                def my_label_else = _ilg.DefineLabel ();
                def my_label_fi = _ilg.DefineLabel ();
                emit_branch (new_cond, my_label_else);
                emit_branch (new_then, else_label);
                unless (throws (new_then))
                  _ilg.Emit (OpCodes.Br, my_label_fi);
                _ilg.MarkLabel (my_label_else);                  
                emit_branch (new_else, else_label);              
                _ilg.MarkLabel (my_label_fi);                                                 

              | e when is_always_true (e) => ()
              | e when is_always_false (e) =>
                Mark (e.loc);
                _ilg.Emit (OpCodes.Br, else_label);                

              | _ =>
                //Message.debug (e.loc, pretty_print (e));
                // most of other expressions here are CExpr.Ref
                emit (expr);
                Mark (cond_expr.loc);
                _ilg.Emit (OpCodes.Brfalse, else_label);                
            }
          }

          def label_condition_else = _ilg.DefineLabel ();
          def label_condition_fi = _ilg.DefineLabel ();
          emit_branch (cond_expr, label_condition_else);

          emit (then_expr);
          unless (throws (then_expr))
            _ilg.Emit (OpCodes.Br, label_condition_fi);

          _ilg.MarkLabel (label_condition_else);
          emit (else_expr);

          _ilg.MarkLabel (label_condition_fi);
        
        /* emit a type check construction */
        | CExpr.HasType (expr, ty) =>
          emit (expr);
          def label_condition_not_null = _ilg.DefineLabel ();
          def label_condition_has_type = _ilg.DefineLabel ();
          def label_condition_continue = _ilg.DefineLabel ();

          _ilg.Emit (OpCodes.Dup);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);

          _ilg.ThrowException (SystemType.NullMatchException);

          _ilg.MarkLabel (label_condition_not_null);

          _ilg.Emit (OpCodes.Isinst, ty);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_0);
          _ilg.Emit (OpCodes.Br_S, label_condition_continue);
          _ilg.MarkLabel (label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_1);
          _ilg.MarkLabel (label_condition_continue);


        /* emit a nullness check construction */
        | CExpr.NotNull (val) =>
          emit (val);
          def label_condition_not_null = _ilg.DefineLabel ();

          Mark (expr.loc);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);

          _ilg.ThrowException (SystemType.NullMatchException);

          _ilg.MarkLabel (label_condition_not_null);


        /* load runtime representation of given type */
        | CExpr.TypeOf (t) =>
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Ldtoken, t);
          _ilg.Emit (OpCodes.Call, SystemType.Type_GetTypeFromHandle);


        /* emits the CExpr.Switch instruction */
        | CExpr.Switch (indexing_expr, default_expr, cases) =>
          match (cases) {
            | [] =>
              Message.warning ("empty CExpr.Switch instruction");
            | _ =>
              emit (indexing_expr);
              emit_switch (default_expr, cases)
          }


        /* insert label so CExpr.ContinueLoop can work */
        | (CExpr.Loop (expr, _)) as loop =>
          def label = _ilg.DefineLabel ();
          loop.label = Some (label);
          _ilg.MarkLabel (label);
          emit (expr)


        /* branch to loop beginning. */
        | CExpr.ContinueLoop (which) =>
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Br, Option.UnSome (which.label));


        /* -- TYPE CONVERSIONS --------------------------------------------- */

        /* do not perform casts between same types */
        | CExpr.Cast (expr, cast_to_type, _) when expr.SystemType.Equals (cast_to_type) =>
          emit (expr)

        /* to nonvalue type */
        | CExpr.Cast (expr, cast_to_type, _) when !cast_to_type.IsValueType =>
          emit (expr);        
          if (SystemType.Void.Equals (expr.SystemType))
            /* special case casts from void */
            _ilg.Emit (OpCodes.Ldnull);
          else 
          if (expr.SystemType.IsValueType)
            /* box value types casted to non value types */          
            _ilg.Emit (OpCodes.Box, expr.SystemType);
          else {
            /* upcast / downcast non-value types */
            Mark (expr.loc);
            _ilg.Emit (OpCodes.Castclass, cast_to_type);
          }

        /* unbox value types or perform value type conversion */
        | CExpr.Cast (val, cast_to_type, is_checked) =>
          emit (val);
          Mark (expr.loc);
          def type_of_expr = val.SystemType;

          if (type_of_expr.IsValueType) {
            /* perform conversion of value types */
            emit_value_type_conversion (type_of_expr, cast_to_type, is_checked)
          }
          else if (SystemType.Object.Equals (type_of_expr) || type_of_expr.IsInterface) {
            /* unboxing returns a pointer to a value */
            _ilg.Emit (OpCodes.Unbox, cast_to_type);

            maybe_volatile (val);

            emit_ldind_for_value_type (cast_to_type)
          }
          else {
            Util.ice (_method_name + ": failed to convert non-value type "
                      + type_of_expr.FullName + " to a value type "
                      + cast_to_type.FullName)
          };


        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | CExpr.Ref (decl) =>
          emit_ce_ref (decl, 
                       get_address_for_value_types = wish_address (expr))

        /* load the value of a field */
        | CExpr.FieldRef (base_object, field) 
        | CExpr.VolatileFieldRef (base_object, field) =>
          emit (base_object);
          maybe_volatile (expr);
          if (wish_address (expr))
            _ilg.Emit (OpCodes.Ldflda, field);
          else
            _ilg.Emit (OpCodes.Ldfld, field);

        /* load the value of a static field */
        | CExpr.VolatileGlobalRef (mi) when member_is_field (mi)
        | CExpr.GlobalRef (mi) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "GlobalRef to a non-static field");

          when (field_info.IsLiteral)
            // should not happen
            Message.warning ("loading literal as field `" + field_info.ToString () + "'");

          maybe_volatile (expr);
          if (wish_address (expr))
            _ilg.Emit (OpCodes.Ldsflda, field_info);
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);

        /* load an array element */
        | CExpr.ArrayAccess (array_obj, [index]) =>
          emit (array_obj);
          emit (index);
          def element_type = array_obj.SystemType.GetElementType ();
          assert (element_type != null, "non-array in CExpr.ArrayAccess");

          Mark (expr.loc);
          if (wish_address (expr))
            _ilg.Emit (OpCodes.Ldelema, element_type)
          else
            emit_array_load_opcode (element_type);
          

        | CExpr.ArrayAccess (array_obj, indexes) =>
          emit (array_obj);
          List.Iter (indexes, emit);
          Mark (expr.loc);
          def method =
            if (wish_address (expr)) array_addr_method (array_obj)
            else array_get_method (array_obj);
          emit_method_call (expr, true, method);


        /* -- ASSIGNMENTS -------------------------------------------------- */

        // FIXME? move it a bit down and see no redundant warning?
        /* special case these assignments for performance */
        | CExpr.Assign (CExpr.Ref (decl), CExpr.InitValueType (t)) =>
          Mark (expr.loc);
          emit_ce_ref (decl, get_address_for_value_types = true);
          _ilg.Emit (OpCodes.Initobj, t);

     
        /* assignment to a local variable */
        | CExpr.Assign (CExpr.Ref (local_var), val) =>
          emit (val);
          Mark (expr.loc);          
          match (local_var.local_slot) {
            | Some (local_slot) =>
              _ilg.Emit (OpCodes.Stloc, local_slot);
            | _ when SystemType.Void.Equals (val.SystemType) =>
              // simply skip assignment here
              ()
            | _ =>
              store_argument (local_var.parm_index)
          };

        /* assignment to ref/out parameter */
        | CExpr.Assign (CExpr.Indirect (CExpr.Ref ({ parm_index = Some (parm_index) })), val) =>
          emit_ldarg (parm_index);
          emit (val);
          Mark (expr.loc);
          def ty = val.SystemType;
          if (ty.IsValueType)
            _ilg.Emit (OpCodes.Stobj, ty)
          else
            _ilg.Emit (OpCodes.Stind_Ref);


        /* assignment to a field */
        | CExpr.Assign (CExpr.VolatileFieldRef (base_object, field), val)
        | CExpr.Assign (CExpr.FieldRef (base_object, field), val) =>
          emit (base_object);
          emit (val);
          Mark (expr.loc);
          maybe_volatile ((expr :> CExpr.Assign).target);
          _ilg.Emit (OpCodes.Stfld, field);


        /* assignment to a static field */
        | CExpr.Assign (CExpr.VolatileGlobalRef (mi), val) when member_is_field (mi)
        | CExpr.Assign (CExpr.GlobalRef (mi), val) when member_is_field (mi) =>
          emit (val);
          Mark (expr.loc);
          maybe_volatile ((expr :> CExpr.Assign).target);
          _ilg.Emit (OpCodes.Stsfld, (mi :> FieldInfo));


        /* assignment to an array element */
        | CExpr.Assign (CExpr.ArrayAccess (array_obj, [index]), val) =>
          def type_of_val = val.SystemType;

          emit (array_obj);
          emit (index);
          Mark (expr.loc);
          when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
            _ilg.Emit (OpCodes.Ldelema, type_of_val);

          emit (val);
          emit_array_store_opcode (type_of_val);

        | CExpr.Assign (CExpr.ArrayAccess (array_obj, indexes), val) =>
          emit (array_obj);
          List.Iter (indexes, emit);
          emit (val);
          Mark (expr.loc);
          def method = array_set_method (array_obj);
          emit_method_call (expr, true, method);

        | CExpr.MultipleAssign (assigns) =>
          def emit_store (local_var : CG_val, _) {
            Mark (local_var.loc);
            match (local_var.local_slot) {
              | Some (local_slot) =>
                _ilg.Emit (OpCodes.Stloc, local_slot);
              | _ =>
                Util.ice (_method_name + ": null local slot in CExpr.MultipleAssign")
            }
          };
          foreach ((_, e) in assigns) emit (e);
          List.Iter (List.Rev (assigns), emit_store);


        /* -- CALLS -------------------------------------------------------- */

        /* call the base constructor */
        | CExpr.TailCall (CExpr.BaseCtorRef (base_ctor), ctor_params)
        | CExpr.Call (CExpr.BaseCtorRef (base_ctor), ctor_params) =>
          _ilg.Emit (OpCodes.Ldarg_0);
          foreach (parm in ctor_params) emit (parm);
          Mark (expr.loc);          
          _ilg.Emit (OpCodes.Call, base_ctor);

        /* create a new object */
        | CExpr.TailCall (CExpr.ConstructorRef (ctor), ctor_params)
        | CExpr.Call (CExpr.ConstructorRef (ctor), ctor_params) =>
          foreach (parm in ctor_params) emit (parm);
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Newobj, ctor);


        /* emit a call to an instance method, basing on the 'this' pointer for value types */
        | CExpr.TailCall (CExpr.MethodRef (CExpr.This, method, _), method_params)
                                                      when _this_is_value_type
        | CExpr.Call (CExpr.MethodRef (CExpr.This, method, _), method_params)
                                                      when _this_is_value_type =>
          if (method.DeclaringType.Equals (_type_of_this)) {
            // it actually IS the proper way to do it --
            // this is our method and we may call it this way
            _ilg.Emit (OpCodes.Ldarg_0);
            foreach (parm in method_params) emit (parm);
            Mark (expr.loc);
            emit_method_call (expr, true, method)
          } 
          else {
            _ilg.Emit (OpCodes.Ldarg_0);
            _ilg.Emit (OpCodes.Ldobj, _type_of_this);
            _ilg.Emit (OpCodes.Box, _type_of_this);
            foreach (parm in method_params) emit (parm);
            Mark (expr.loc);            
            emit_method_call (expr, false, method)
          }


        /* emit a call to an instance method */
        | CExpr.TailCall (CExpr.MethodRef (base_object, method, notvirt), method_params)
        | CExpr.Call (CExpr.MethodRef (base_object, method, notvirt), method_params) =>
          emit (base_object);
          def is_value_type = base_object.SystemType.IsValueType;
          when (is_value_type && !(base_object.flags %&& CgExprFlags.WishGranted)) {
            def local_slot = _ilg.DeclareLocal (base_object.SystemType);
            _ilg.Emit (OpCodes.Stloc, local_slot);
            _ilg.Emit (OpCodes.Ldloca, local_slot);
          };
          foreach (parm in method_params) emit (parm);
          Mark (expr.loc);
          emit_method_call (expr, is_value_type || notvirt, method)


        /* emit a call to a static method */
        | CExpr.TailCall (CExpr.GlobalRef (mi), method_parms) when member_is_method (mi)
        | CExpr.Call (CExpr.GlobalRef (mi), method_parms) when member_is_method (mi) =>
          def method_info = (mi :> MethodInfo);

          assert (method_info.IsStatic, "Call CExpr.GlobalRef to a non-static field");

          foreach (parm in method_parms) emit (parm);
          Mark (expr.loc);          
          emit_method_call (expr, true, method_info)


        /* emit an operator */
        | CExpr.TailCall (CExpr.Opcode (opcode), parms)
        | CExpr.Call (CExpr.Opcode (opcode), parms) =>
          // FIXME: seperate out
          foreach (parm in parms) emit (parm);
          Mark (expr.loc);
          match (opcode) {
            | "+.s" =>  _ilg.Emit (OpCodes.Add_Ovf)
            | "+.u" => _ilg.Emit (OpCodes.Add_Ovf_Un)
            | "+.f" =>  _ilg.Emit (OpCodes.Add)

            | "<<.s" | "<<.f" | "<<.u" =>  _ilg.Emit (OpCodes.Shl)
            | ">>.s" | ">>.f" =>  _ilg.Emit (OpCodes.Shr)
            | ">>.u" =>  _ilg.Emit (OpCodes.Shr_Un)

            | "unary.+.s" | "unary.+.u" | "unary.+.f" => ()

            | "-.s" =>  _ilg.Emit (OpCodes.Sub_Ovf)
            | "-.u" => _ilg.Emit (OpCodes.Sub_Ovf_Un)
            | "-.f" =>  _ilg.Emit (OpCodes.Sub)

            | "unary.-.s" =>
              _ilg.Emit (OpCodes.Ldc_I4_M1);
              emit_value_type_conversion (SystemType.Int32,
                                          List.Hd (parms).SystemType, true);
              _ilg.Emit (OpCodes.Mul_Ovf)
            | "unary.-.f" =>
              _ilg.Emit (OpCodes.Neg)

            | "unary.~.u"
            | "unary.~.s" =>
              _ilg.Emit (OpCodes.Not);

            | "unary.~.f" =>
              def type_of_parm = List.Head (parms).SystemType;
              when (type_of_parm.FullName == "System.Single" ||
                    type_of_parm.FullName == "System.Double" ||
                    type_of_parm.FullName == "System.Decimal")
                Util.ice ("float, double or decimal as an argument for binary negation in CGIL");
              _ilg.Emit (OpCodes.Not);

            | "*.s" =>  _ilg.Emit (OpCodes.Mul_Ovf)
            | "*.u" => _ilg.Emit (OpCodes.Mul_Ovf_Un)
            | "*.f" =>  _ilg.Emit (OpCodes.Mul)

            | "/.s" | "/.f" =>  _ilg.Emit (OpCodes.Div)
            | "/.u" => _ilg.Emit (OpCodes.Div_Un)
            | "%.s" | "%.f" =>  _ilg.Emit (OpCodes.Rem)
            | "%.u" => _ilg.Emit (OpCodes.Rem_Un)

            | "|.s" | "|.u" | "|.f" => _ilg.Emit (OpCodes.Or);
            | "&.s" | "&.u" | "&.f" => _ilg.Emit (OpCodes.And);
            | "^.s" | "^.u" | "^.f" => _ilg.Emit (OpCodes.Xor);
            | "bool.!" =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Ceq)
            | "==" =>
              _ilg.Emit (OpCodes.Ceq);
            | "!=" =>
              _ilg.Emit (OpCodes.Ceq);
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Ceq);
            | "<.s" | "<.f" => emit_compare (OpCodes.Blt_S)
            | "<.u" => emit_compare (OpCodes.Blt_Un_S)
            | ">.s" | ">.f" => emit_compare (OpCodes.Bgt_S)
            | ">.u" => emit_compare (OpCodes.Bgt_Un_S)
            | "<=.s" | "<=.f" => emit_compare (OpCodes.Ble_S)
            | "<=.u" => emit_compare (OpCodes.Ble_Un_S)
            | ">=.s" | ">=.f" => emit_compare (OpCodes.Bge_S)
            | ">=.u" => emit_compare (OpCodes.Bge_Un_S)
            | _ =>
              Util.ice (_method_name + ": unmatched CExpr.Opcode (" + opcode + ")")
          };

        /* emit self tail call -- that is jump to method start */
        | CExpr.SelfTailCall (method_params) =>
          foreach (v in method_params) emit (v);
          
          def store_arguments (pars : list [CG_val]) {
            | [] => ()
            | p :: ps =>
              store_arguments (ps);
              store_argument (p.parm_index);
          }
          store_arguments (_cg_method.parms);
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Br, _method_start_label);


        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | CExpr.Throw (exc) =>
          emit (exc);
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Throw);


        /* emit the try/with construction */
        | CExpr.TryWith (try_expr, catch_val, catch_expr) =>
          def type_of_try_expr = expr.SystemType;

          def ignore_try_with_result = SystemType.Void.Equals (type_of_try_expr);
          mutable try_result = null;

          unless (ignore_try_with_result)
            try_result = _ilg.DeclareLocal (type_of_try_expr);

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          unless (throws (try_expr) || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);

          _ilg.BeginCatchBlock (catch_val.ty);

          def catch_val_local_slot = declare_val_local_slot (catch_val);
          _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);

          emit (catch_expr);
          // close scope opened by declare_val_local_slot
          when (Options.EmitDebug) _ilg.EndScope ();

          unless (throws (catch_expr) || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);

          _ilg.EndExceptionBlock ();

          unless ((throws (catch_expr) && throws (try_expr)) || ignore_try_with_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        // FIXME: how does finally work? what about storing it's result in
        //        try_result as in CExpr.TryWith?
        | CExpr.TryFinally (try_expr, finally_expr) =>
          def type_of_try_expr = try_expr.SystemType;

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          def ignore_try_result = throws (try_expr) || SystemType.Void.Equals (type_of_try_expr);
          mutable try_result = null;

          unless (ignore_try_result) {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          emit (finally_expr);

          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | CExpr.This =>
          assert (!_method_is_static, "This is a static method");
          _ilg.Emit (OpCodes.Ldarg_0);


        /* loads a literal on the evaluation stack */
        | CExpr.Literal (l) => emit_literal (l);

        /* loads address of given method */
        | CExpr.MethodAddress (meth) =>
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Ldftn, meth);


        /* creates object of value type using implicit ctor */
        | CExpr.InitValueType (t) =>
          Mark (expr.loc);
          when (Options.EmitDebug) _ilg.BeginScope ();
          def local_slot = _ilg.DeclareLocal (t);
          _ilg.Emit (OpCodes.Ldloca, local_slot);
          _ilg.Emit (OpCodes.Initobj, t);
          _ilg.Emit (OpCodes.Ldloc, local_slot);
          when (Options.EmitDebug) _ilg.EndScope ();


        /* creates a new array, given a list of initializers */
        | CExpr.Array (element_type, initializers, [size]) =>
          emit (size);
          Mark (expr.loc);
          _ilg.Emit (OpCodes.Newarr, element_type);

          def load_elements (index : int, elements : list [CExpr]) {
            match (elements) {
              | [] => ()
              | element :: rest =>
                _ilg.Emit (OpCodes.Dup);
                _ilg.Emit (OpCodes.Ldc_I4, index);

                when (element_type.IsValueType && !element_type.IsPrimitive)
                  _ilg.Emit (OpCodes.Ldelema, element_type);

                emit (element);
                emit_array_store_opcode (element_type);
                load_elements (index + 1, rest)
            }
          };
          load_elements (0, initializers);

        | CExpr.Array (_, initializers, dimensions) =>
          mutable size = 0;
          foreach (element in dimensions) {
            ++size;
            emit (element);
          }

          def arg_types = array (size);
          for (mutable i = 0; i < size; ++i) arg_types [i] = SystemType.Int32;
          def method = _module_builder.GetArrayMethod (expr.SystemType, ".ctor", CallingConventions.HasThis,
                                                       null, arg_types);
          Mark (expr.loc);                                                       
          _ilg.Emit (OpCodes.Newobj, method);

          unless (initializers matches []) {
            def method = array_set_method (expr.SystemType);

            def dimensions_array = array (size);
            mutable i = 0;
            foreach (CExpr.Literal (Literal.Int (it)) in dimensions) {
              dimensions_array [i] = it;
              ++i;
            };
            assert (i == size, "dimensions must be literals when initializes are supplied");

            def load_elements (index : array [int], elements : list [CExpr]) {
              match (elements) {
                | [] => ()
                | element :: rest =>
                  _ilg.Emit (OpCodes.Dup);                  
                  for (mutable j = 0; j < index.Length; ++j)
                    emit_literal (Literal.Int (index [j]));
                  emit (element);
                  def next (index : array [int])
                  {
                    ++index [index.Length - 1];
                    for (mutable j = index.Length - 1; index [j] == dimensions_array [j] && j > 0; --j)
                    {
                      index [j] = 0;
                      ++index [j - 1];
                    }
                    index
                  }
                  emit_method_call (expr, true, method);
                  load_elements (next (index), rest)
              }
            }
            load_elements (array (dimensions_array.Length), initializers);
          }

          
        /* takes address of a value */
        | CExpr.Address (CExpr.Indirect (expr)) =>
          emit (expr)

        | CExpr.Address (expr) =>
          assert (wish_address (expr));
          match (expr) {
            | CExpr.Ref
            | CExpr.FieldRef
            | CExpr.VolatileFieldRef
            | CExpr.VolatileGlobalRef
            | CExpr.GlobalRef
            | CExpr.ArrayAccess => ()
            | _ => 
              // should not happen
              Message.error (expr.loc, 
                             "failed to take address of this expression: " + 
                             pretty_print (expr))
          }
          // if wish_address(expr), then emit should handle this
          emit (expr)

        | CExpr.Indirect (CExpr.Address (expr)) =>
          emit (expr)

        /* load value by pointer */
        | CExpr.Indirect (expr) =>
          emit (expr);
          def ty = expr.SystemType;
          def el_ty = ty.GetElementType ();
          assert (ty.IsByRef && el_ty != null);

          maybe_volatile (expr);

          if (el_ty.IsValueType)
            emit_ldind_for_value_type (el_ty)
          else
            _ilg.Emit (OpCodes.Ldind_Ref);


        /* an interrupting NOP instruction */
        | CExpr.Nop => ()

        | _ =>
          Message.warning ("FIXME: unmatched: " + pretty_print (expr));
      }
    }

    private array_set_method (t : System.Type) : MethodInfo
    {
        def rank = t.GetArrayRank ();

        def args = array (rank + 1);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }
        args [rank] = t.GetElementType ();

        _module_builder.GetArrayMethod (t, "Set",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        typeof (void), args);
    }


    /*
     * Emits a local reference instruction
     */
    private emit_ce_ref (decl : CG_val, get_address_for_value_types : bool) : void
    {
      match (decl.local_slot) {
        | Some (local_slot) =>
          // local values
          if (get_address_for_value_types)
            _ilg.Emit (OpCodes.Ldloca, local_slot)
          else
            _ilg.Emit (OpCodes.Ldloc, local_slot)

        | _ =>
          // method parameters
          match (decl.parm_index) {
            | Some (parm_index) =>
              if (get_address_for_value_types)
                emit_ldarga (parm_index)
              else
                emit_ldarg (parm_index)
            | _ when SystemType.Void.Equals (decl.ty) => ()
            | _ =>
              Util.ice (_method_name + ": parameter index / variable local"
                        " slot undefined in CExpr.Ref " + decl.name)
          }
      }
    }


    private array_set_method (arr : CExpr) : MethodInfo
    {
        array_set_method (arr.SystemType);
    }

    private array_get_method (arr : CExpr) : MethodInfo
    {
        def t = arr.SystemType;
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = typeof (System.Int32);
        }

        _module_builder.GetArrayMethod (t, "Get",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        t.GetElementType (), args);
    }

    private array_addr_method (arr : CExpr) : MethodInfo
    {
        def t = arr.SystemType;
        def rank = t.GetArrayRank ();

        def args = array (rank);
        for (mutable i = 0; i < rank; ++i)
        {
            args [i] = SystemType.Int32;
        }

        _module_builder.GetArrayMethod (t, "Address",
                                        CallingConventions.HasThis %| CallingConventions.Standard,
                                        t.GetElementType (), args);
    }

    /**
     * Emits the CExpr.Switch instruction
     *
     * Asserts that the smallest of the case indices is positive. Quietly
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never
     * generate too long switch instructions -- assuring this should belong
     * to a higher level logic.
     */
    private emit_switch (default_expr : option [CExpr],
                         cases : list [int * CExpr]) : void
    {
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr) {
          | Some => label_default
          | None => label_next_instruction
        };

      // step one: sort the cases increasingly
      def compare_cases (l : int * CExpr, r : int * CExpr) : int {
        def (l, _) = l; def (r, _) = r; l - r
      };

      def cases = List.Sort (cases, compare_cases);
      def (first_index, _) = List.Head (cases);

      // step two: rescale, so that the first label has value zero
      when (first_index != 0) {
        // NOTE: see the assumptions in the method description
        emit_literal (Literal.Int (first_index));
        _ilg.Emit (OpCodes.Sub_Ovf)
      };

      // step three: generate the jump labels for the switch cases
      mutable reversed_labels = [];

      def make_labels (index : int, cases : list [int * CExpr])
                                        : list [Label * CExpr] {
        match (cases) {
          | (case_index, case_expr) :: rest =>
            assert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;

              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)
            }
          | [] => []
        }
      };

      def labeled_cases = make_labels (first_index, cases);
      def labels = List.Rev (reversed_labels);

      def labels_array = label_list_to_array (labels);

      // step four: emit the switch instruction and the default expression
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr) {
        | Some (default_expr) =>
          emit (default_expr);
          unless (throws (default_expr))
            _ilg.Emit (OpCodes.Br, label_next_instruction);
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
      };

      // step five: emit the switch cases
      def walk_cases (cases : list [Label * CExpr]) : void {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          emit (expr);
          unless (throws (expr))
            _ilg.Emit (OpCodes.Br, label_next_instruction);
          walk_cases (rest)
        | [] => ()
      };

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      _ilg.MarkLabel (label_next_instruction);
    }


    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (index : int) : void
    {
      | 0 => _ilg.Emit (OpCodes.Ldarg_0)
      | 1 => _ilg.Emit (OpCodes.Ldarg_1)
      | 2 => _ilg.Emit (OpCodes.Ldarg_2)
      | 3 => _ilg.Emit (OpCodes.Ldarg_3)
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarg, index)
    }


    private store_argument (parm_index : option [int]) : void {
      | Some (index) =>
        if (index < 256)
          _ilg.Emit (OpCodes.Starg_S, index :> byte)
        else
          _ilg.Emit (OpCodes.Starg, index);
      | None => Util.ice ("no param_index found")
    }

    
    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (index : int) : void
    {
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarga, index)
    }


    /**
     * Performs value type conversion form l to r
     */
    private emit_value_type_conversion (l : System.Type, r : System.Type,
                                        is_checked : bool) : void
    {
      def is_unsigned (t : System.Type) {
        match (t.Name [0]) {
          // UInt32, UInt64, UInt16
          | 'U'
          // Byte
          | 'B'
          // Char
          | 'C'   => true
          | _ => false
        }
      };
      def fail () {
        Message.warning ("failed to emit value type conversion from " +
                         l.FullName + " to " + r.FullName)
      };

      match (()) {
        | _ when r.Equals (l) => ()
        | _ when l.IsPrimitive || l.IsEnum =>
          if (r.IsPrimitive || r.IsEnum) {
            def rname =
              // FIXME: use true underalying type
              if (r.IsEnum) "Int32" else r.Name;
            def opcode =
              if (is_checked) {
                match (rname) {
                  | "Int64" when is_unsigned (l) => OpCodes.Conv_Ovf_I8_Un
                  | "Int64" => OpCodes.Conv_Ovf_I8
                  | "Int32" when is_unsigned (l) => OpCodes.Conv_Ovf_I4_Un
                  | "Int32" => OpCodes.Conv_Ovf_I4
                  | "Int16" when is_unsigned (l) => OpCodes.Conv_Ovf_I2_Un
                  | "Int16" => OpCodes.Conv_Ovf_I2
                  | "SByte" when is_unsigned (l) => OpCodes.Conv_Ovf_I1_Un
                  | "SByte" => OpCodes.Conv_Ovf_I1
                  | "UInt64" when is_unsigned (l) => OpCodes.Conv_Ovf_U8_Un
                  | "UInt64" => OpCodes.Conv_Ovf_U8
                  | "UInt32" when is_unsigned (l) => OpCodes.Conv_Ovf_U4_Un
                  | "UInt32" => OpCodes.Conv_Ovf_U4
                  | "UInt16" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
                  | "UInt16" => OpCodes.Conv_Ovf_U2
                  | "Boolean" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
                  | "Boolean" => OpCodes.Conv_Ovf_U1
                  | "Byte" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
                  | "Byte" => OpCodes.Conv_Ovf_U1
                  | "Char" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
                  | "Char" => OpCodes.Conv_Ovf_U2

                  | "Single" when is_unsigned (l) => OpCodes.Conv_R_Un
                  | "Single" => OpCodes.Conv_R4
                  // there is no OpCodes.Conv_R8_Un
                  | "Double" when !is_unsigned (l) => OpCodes.Conv_R8

                  | _ => fail (); OpCodes.Nop
                }
              }
              else {
                match (rname) {
                  | "Int64" => OpCodes.Conv_I8
                  | "Int32" => OpCodes.Conv_I4
                  | "Int16" => OpCodes.Conv_I2
                  | "SByte" => OpCodes.Conv_I1
                  | "UInt64" => OpCodes.Conv_U8
                  | "UInt32" => OpCodes.Conv_U4
                  | "UInt16" => OpCodes.Conv_U2
                  | "Byte" => OpCodes.Conv_U1
                  | "Boolean" => OpCodes.Conv_U1
                  | "Char" => OpCodes.Conv_U2

                  | "Single" when is_unsigned (l) => OpCodes.Conv_R_Un
                  | "Single" => OpCodes.Conv_R4
                  | "Double" => OpCodes.Conv_R8

                  | _ => fail (); OpCodes.Nop
                }
              }
            _ilg.Emit (opcode)
          }
          else if (r.Equals (SystemType.Decimal)) {
            // FIXME: use true underalying type
            def lname = if (l.IsEnum) "Int32" else l.Name;
            match (lname) {
              | "Int32" | "UInt32" | "Single" | "Int64" | "UInt64"
              | "Double" =>
                _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemType.Decimal_ctors.Get (lname)))
              | _ => fail ()
            }
          }
          else fail ()

        | _ => fail ()
      }
    }

    /**
     * Checks if a given member info describes a field
     */
    private member_is_field (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Field
    }


    /**
     * Checks if a given member info describes a method
     */
    private member_is_method (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Method
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier.
     */
    private emit_method_call (expr : CExpr,
                              base_is_value_type_or_static : bool,
                              method : MethodInfo) : void
    {
      def is_tail =
        match (expr) {
          | CExpr.TailCall when Options.GeneralTailCallOpt =>
            _ilg.Emit (OpCodes.Tailcall);
            true
          | _ => false
        };

      if (base_is_value_type_or_static)
        _ilg.Emit (OpCodes.Call, method)
      else
        _ilg.Emit (OpCodes.Callvirt, method);

      when (is_tail)
        _ilg.Emit (OpCodes.Ret);
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : CG_val) : LocalBuilder
    {
      when (Options.EmitDebug) _ilg.BeginScope ();              
      def local_slot = _ilg.DeclareLocal (val.ty);
      when (Options.EmitDebug) local_slot.SetLocalSymInfo (val.name);
      val.local_slot = Some (local_slot);
      local_slot
    }

    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     */
    private emit_array_store_opcode (ty : System.Type) : void
    {
      assert (!SystemType.Void.Equals (ty), "tried to store a System.Void in an array");

      if (ty.IsPrimitive) {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"
            | "Byte"                     => OpCodes.Stelem_I1
            | "Char" | "Int16"
            | "UInt16"                   => OpCodes.Stelem_I2
            | "Int32" | "UInt32"         => OpCodes.Stelem_I4
            | "Int64" | "UInt64"         => OpCodes.Stelem_I8
            | "Single"                   => OpCodes.Stelem_R4
            | "Double"                   => OpCodes.Stelem_R8
            | _ => Util.ice ("System.Type IsPrimitive has lied")
          }
          _ilg.Emit (opcode);
        }
        else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
        else _ilg.Emit (OpCodes.Stelem_Ref);
    }


    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : System.Type) : void
    {
      assert (!SystemType.Void.Equals (ty), "tried to load a System.Void from an array");

      if (ty.IsValueType && !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldelema, ty);
        _ilg.Emit (OpCodes.Ldobj, ty);
      } 
      else {
        def opcode =
          if (ty.IsPrimitive)
            match (ty.Name) {
              | "SByte" | "Boolean" => OpCodes.Ldelem_I1
              | "Byte"              => OpCodes.Ldelem_U1
              | "Char" | "Int16"    => OpCodes.Ldelem_I2
              | "UInt16"            => OpCodes.Ldelem_U2
              | "Int32"             => OpCodes.Ldelem_I4
              | "UInt32"            => OpCodes.Ldelem_U4
              | "Int64" | "UInt64"  => OpCodes.Ldelem_I8
              | "Single"            => OpCodes.Ldelem_R4
              | "Double"            => OpCodes.Ldelem_R8
              | _ => Util.ice ("System.Type.IsPrimitive has lied")
            }
          else
            OpCodes.Ldelem_Ref;

        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : System.Type) : void
    {
      if (ty.IsEnum || !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldobj, ty)
      }
      else {
        def opcode =
          match (ty.Name) {
            | "SByte" | "Boolean"     => OpCodes.Ldind_I1
            | "Byte"                  => OpCodes.Ldind_U1
            | "Char" | "Int16"        => OpCodes.Ldind_I2
            | "UInt16"                => OpCodes.Ldind_U2
            | "Int32"                 => OpCodes.Ldind_I4
            | "UInt32"                => OpCodes.Ldind_U4
            | "Int64"                 => OpCodes.Ldind_I8
            | "UInt64"                => OpCodes.Ldind_I8
            | "Single"                => OpCodes.Ldind_R4
            | "Double"                => OpCodes.Ldind_R8
            | _ =>
              Util.ice (_method_name + ": not a recognized value type: " + ty.FullName);
          }

        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a literal
     */
     
    private emit_literal (l : Literal) : void
    {
      def emit_i4 (x) {
        | -1 => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | 0  => _ilg.Emit (OpCodes.Ldc_I4_0)
        | 1  => _ilg.Emit (OpCodes.Ldc_I4_1)
        | 2  => _ilg.Emit (OpCodes.Ldc_I4_2)
        | 3  => _ilg.Emit (OpCodes.Ldc_I4_3)
        | 4  => _ilg.Emit (OpCodes.Ldc_I4_4)
        | 5  => _ilg.Emit (OpCodes.Ldc_I4_5)
        | 6  => _ilg.Emit (OpCodes.Ldc_I4_6)
        | 7  => _ilg.Emit (OpCodes.Ldc_I4_7)
        | 8  => _ilg.Emit (OpCodes.Ldc_I4_8)
        | k when (k >= -128 && k <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, k :> sbyte)
        | k => _ilg.Emit (OpCodes.Ldc_I4, k)
      }

      match (l) {
        | Literal.Void => ()
        | Literal.Null =>
          _ilg.Emit (OpCodes.Ldnull)
        | Literal.Bool (true) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | Literal.Bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)
          
        | Literal.Int (k) => emit_i4 (k)
        | Literal.UInt (k) =>
          unchecked (emit_i4 (k :> int));
          _ilg.Emit (OpCodes.Conv_U4)

        | Literal.Byte (k) => emit_i4 (k :> int)
        | Literal.Char (k) => emit_i4 (k :> int)
        | Literal.Short (k) => emit_i4 (k :> int)          
        | Literal.UShort (k) => emit_i4 (k :> int)
        | Literal.SByte (k) => emit_i4 (k :> int)

        | Literal.Long (k) => _ilg.Emit (OpCodes.Ldc_I8, k)
        | Literal.ULong (k) =>
          unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
          _ilg.Emit (OpCodes.Conv_U8)

        | Literal.String (s) => _ilg.Emit (OpCodes.Ldstr, s)
        | Literal.Float (f) => _ilg.Emit (OpCodes.Ldc_R4, f)
        | Literal.Double (f) => _ilg.Emit (OpCodes.Ldc_R8, f)
        | Literal.Decimal (m) =>
          def decimal_bits = System.Decimal.GetBits (m);

          _ilg.Emit (OpCodes.Ldc_I4_4);

          _ilg.Emit (OpCodes.Newarr, SystemType.Int32);

          when (decimal_bits [0] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [1] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [2] != 0)
            _ilg.Emit (OpCodes.Dup);
          when (decimal_bits [3] != 0)
            _ilg.Emit (OpCodes.Dup);

          when (decimal_bits [0] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [0]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [1] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [1]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [2] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_2);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [2]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }
          when (decimal_bits [3] != 0) {
            _ilg.Emit (OpCodes.Ldc_I4_3);
            _ilg.Emit (OpCodes.Ldc_I4, decimal_bits [3]);
            _ilg.Emit (OpCodes.Stelem_I4)
          }

          _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemType.Decimal_ctors.Get ("Int32[]")))

        | Literal.Enum (l, _) => emit_literal (l)
      }
    }


    /**
     * Emits a comparison operation
     */
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }


    /**
     * Pretty prints a list of expressions
     */
    static pretty_print_list (exs : list [CExpr], acc : string) : string
    {
      acc + NString.Concat (", ", List.Map (exs, pretty_print))
    }


    /**
     * Pretty prints an expression
     */
    public static pretty_print (ex : CExpr) : string
    {
      ex.loc.ToString () + (
      match (ex) {
        | CExpr.Ref (decl) =>
          "Ref (" + decl.name + ")"
        | CExpr.GlobalRef (mi) =>
          "GlobalRef (" + pretty_print_member_info (mi) + ")"
        | CExpr.VolatileGlobalRef (mi) =>
          "VolatileGlobalRef (" + pretty_print_member_info (mi) + ")"
        | CExpr.BaseCtorRef (mi) =>
          "BaseCtorRef (" + pretty_print_member_info (mi) + ")"
        | CExpr.ConstructorRef (mi) =>
          "ConstructorRef (" + pretty_print_member_info (mi) + ")"
        | CExpr.FieldRef (expr, fld) =>
          "FieldRef (" + pretty_print (expr) + " -> " + 
                         pretty_print_member_info (fld) +")"
        | CExpr.VolatileFieldRef (expr, fld) =>
          "FieldRef.volatile (" + pretty_print (expr) + " -> " + 
                         pretty_print_member_info (fld) +")"
        | CExpr.MethodRef (expr, meth, _) =>
          "MethodRef (" + pretty_print (expr) + " -> " + 
                          pretty_print_member_info (meth) + ")"
        | CExpr.MethodAddress (meth) =>
          "MethodAddress (" + pretty_print_member_info (meth) + ")"
        | CExpr.Ignore (expr) =>
          "Ignore (" + pretty_print (expr) + ")"
        | CExpr.Opcode (name) =>
          "Opcode (" + name + ")"
        | CExpr.SelfTailCall (parms) =>
          "SelfTailCall (" + pretty_print_list (parms, "") + ")"
        | CExpr.Call (func, parms) =>
          "Call (" + pretty_print (func) + " (" + pretty_print_list (parms, "") + "))"
        | CExpr.TailCall (func, parms) =>
          "TailCall (" + pretty_print (func) + " (" + pretty_print_list (parms, "") + "))"
        | CExpr.Assign (target, source) =>
          "(" + pretty_print (target) + " = " + pretty_print (source) + ")"
        | CExpr.Address (expr) =>
          "Address (" + pretty_print (expr) + ")"
        | CExpr.Indirect (expr) =>
          "Indirect (" + pretty_print (expr) + ")"
        | CExpr.MultipleAssign =>
          "MultipleAssign"
        | CExpr.Loop (expr, _) =>
          "Loop (" + pretty_print (expr) + ")"
        | CExpr.ContinueLoop =>
          "ContinueLoop"
        | CExpr.Define (name, body) =>
          "let " + name.name + " = " + pretty_print (name.val) + " in { "
          + pretty_print (body) + " }"
        | CExpr.HasType (_, ty) => "HasType (" + ty.FullName + ")"
        | CExpr.NotNull => "NotNull"
        | CExpr.TypeOf (ty) => "TypeOf (" + ty.FullName + ")"
        | CExpr.Throw (exn) => "Throw (" + pretty_print (exn) + ")"
        | CExpr.If (cond, e_then, e_else) =>
          "if (" + pretty_print (cond) + ") { " + pretty_print (e_then)
          + "} else {" + pretty_print (e_else) + "}"
        | CExpr.TryWith => "TryWith"
        | CExpr.TryFinally => "TryFinally"
        | CExpr.Literal (l) => $ "Literal ($l)"
        | CExpr.This => "This"
        | CExpr.Cast (expr, ty, _) =>
          "Cast (" + pretty_print (expr)
          + " :> " + ty.FullName + ")"
        | CExpr.InitValueType (ty) =>
          "InitValueType (" + ty.FullName + ")"
        | CExpr.Sequence (body) => "Sequence { " + pretty_print_list (body, "") + " }"
        | CExpr.Nop => "Nop"
        | CExpr.Array (_, initializers, dimensions) =>
          "Array { " + pretty_print_list (initializers, "") + " } dim {" +
            List.FoldLeft (dimensions, "", fun (i, acc) { acc + i.ToString () + "; " }) +"}"
        | CExpr.ArrayAccess (obj, args) =>
          "CE_mindexer " + pretty_print (obj) + "[" +
          pretty_print_list (args, "") + "]"
        | CExpr.Switch (indexer, _, _) =>
          "Switch ( " + pretty_print (indexer) + " )"
      })
    }


    /**
     * Pretty prints a member info name
     */
    private static pretty_print_member_info (mi : MemberInfo) : string
    {
      mi.DeclaringType.FullName + "::" + mi.Name
    }

    /**
     * Converts a list [Label] into a array [Label]
     * FIXME: this should work now?
     */
    private label_list_to_array (x : list [Label]) : array [Label]
    {
      def result = array (List.Length (x));

      def loop (index : int, x : list [Label]) : void {
        match (x) {
          | head :: tail =>
            result [index] = head;
            loop (index + 1, tail)
          | [] => ()
        }
      };

      loop (0, x);

      result
    }

  } /* end of the class */

} /* end of the namespace */
