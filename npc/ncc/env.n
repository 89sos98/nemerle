open Nemerle.Compiler;
open Nemerle.Compiler.Env;
open Nemerle.Collections;


namespace Nemerle.Compiler {

variant Decl_kind =
  [
    | D_local_fun
    | D_fun_parm
    | D_local_value { is_ref : bool; }
    | D_exn
    | D_pattern_variable
    | D_class_member { mem : Class_member; }
  ]
  
class Decl 
  {
    field loc : Location;
    field name : string;
    field ref ty : Type;
    field id : int;
    field kind : Decl_kind;

    method this (n : string, k : Decl_kind, ty : Type)
      {
        this#loc <- Location_stack.top();
        this#name <- n;
        this#ty <- ty;
        this#kind <- k;
        this#id <- Util.next_id();
      }

    method this (mem : Class_member)
      {
        this#loc <- mem#loc;
        this#name <- mem#env#current_namespace + mem#name;
        this#id <- mem#id;
        this#ty <- null;
        this#kind <- D_class_member(mem);
      }
  }

class Env 
  {
    value ref globals : String_map (list (Decl));

    field ref open_namespaces : list (string);
    field ref current_namespace : string;
    field ref namespace_aliases : String_map (string);
    field ref locals : String_map (Decl);
    
    fun strip_last_part (_ : string) : string = 
        extern "CS_glue.strip_last_part";

    fun add_global (pref : string, m : Class_member) : void =
      letfun allow_overload (d : Decl) : bool =
        let n =
          match d with [
            | { kind = D_class_member(?n) } => n
            | _ => Util.ice()
          ]
        in
        match (n, m) with [
          | (M_function {fun_kind = FK_method}, 
             M_function {fun_kind = FK_method}) => true
          | (M_function {fun_kind = FK_function}, 
             M_function {fun_kind = FK_function}) => true
          | (M_iface_method, M_iface_method) => true
          | (M_function {fun_kind = ?k1}, 
             M_function {fun_kind = ?k2}) =>
               match (k1, k2) with [
                 | (FK_ctor, FK_ctor) => true
                 | (FK_ctor, FK_static_ctor) => true
                 | (FK_static_ctor, FK_ctor) => true
                 | (FK_static_ctor, FK_static_ctor) => true
                 | _ => false
               ]
          | (M_type (TD_variant_option), 
             M_type (TD_variant_option)) => true
          | _ => false
        ]
      in
      letfun do_add(fullname : string) : void =
        match globals#find (fullname) with [
          | Some (Cons (?x, ?xs)) =>
            if allow_overload (x) then
              globals <- globals#add(fullname, Cons (Decl(m), Cons (x, xs)))
            else {
              Message.error (m#loc, "redefinition of `" + m#name + "'");
              Message.error (x#loc, "first defined here")
            }
          | Some (Nil) =>
            raise ICE("empty list in env")
          | None =>
            globals <- globals#add(fullname, List.cons(Decl(m)))
        ]
      in
      match m with [
        | M_type (TD_variant_option) =>
          {
            do_add(pref + m#name);
            do_add(strip_last_part(pref) + m#name);
          }
        | _ => do_add(pref + m#name)
      ];

    method bare_lookup(name : string) : list (Decl) =
      letfun append_not_in (acc : list (Decl), d : Decl) : list(Decl) =
        if List.exists(fun (x : Decl) : bool => x#id == d#id, acc) then
          acc
        else
          Cons(d, acc)
      in
      letfun lookup_in (acc : list (Decl), pref : string) : list (Decl) =
        match globals#find(pref + name) with [
          | Some (?lst) => List.fold_left(append_not_in, acc, lst)
          | None => acc
        ]
      in
      match this#locals#find(name) with [
        | Some (?d) => 
          List.cons(d) // locals shadow globals
        | None =>
          let path = Cons("", Cons(this#current_namespace, 
                                   this#open_namespaces)) in
          List.fold_left(lookup_in, Nil(), path)
      ];
          
    method lookup_type(name : string) : Type_decl =
      match this#bare_lookup(name) with [
        | Cons({kind = D_class_member(M_type (?t))}, Nil) => t
        | Cons({kind = D_class_member(M_type)}, _) =>
          {
            Message.error("type name " + name + " is ambiguous:");
            letfun print_one(d : Decl) : void =
               Message.error(d#loc, "  - this")
            in List.iter(print_one, this#bare_lookup(name));
            raise Recovery();
          }
        | Nil =>
          Message.fatal_error("name " + name + " is unbound")
        | _ =>
          Message.fatal_error("name " + name + " was expected to be type")
      ];

    method add_open (ns : string) : void =
      let ns =
        if ns == "" then ns
        else ns + "."
      in
      this#open_namespaces <- List.append (this#open_namespaces, List.cons (ns));

    method add_namespace_alias (short_name : string, long_name : string) : void =
      this#namespace_aliases <- this#namespace_aliases#add(short_name, long_name);
    
    method add_local (name : string, kind : Decl_kind, ty : Type) : Env =
      let c = this#copy() in {
        c#locals <- c#locals#add(name, Decl(name, kind, ty));
        c
      };
      
    method add_local (name : string, kind : Decl_kind) : Env = 
      this#add_local(name, kind, null);
    
    method copy () : Env =
      let c = Env () in {
        c#open_namespaces <- this#open_namespaces;
        c#current_namespace <- this#current_namespace;
        c#namespace_aliases <- this#namespace_aliases;
        c#locals <- this#locals;
        c
      };

    method this () 
      {
        this#current_namespace <- "";
        this#open_namespaces <- Nil();
        this#locals <- Map.string_map();
        this#namespace_aliases <- Map.string_map();
      }
  }


} // ns
