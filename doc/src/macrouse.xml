<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003, 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>The most interesting features we implemented using macros</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        This page is dedicated to the features of Nemerle and its library, which
        have been implemented using our <a ref="macros.html">meta-programming facilities</a>.
      </p>
      <p>
        Understanding how macros work is not necessary for using any of
        them. It would be useful only for knowing that those examples 
        are just a tip of an iceberg called meta-programming and that you can easily
        implement even nicer things.
      </p>
    </body>
  </section>
  <section id="designbycontract">
    <title>Design by Contract</title>
      <body>
        <p>
          Languages like 
          <a ref="http://en.wikipedia.org/wiki/Eiffel_programming_language">Eiffel</a> 
          or 
          <a ref="http://research.microsoft.com/~leino/papers/krml136.pdf">Spec#</a> 
          incorporate a methodology called 
          <a ref="http://en.wikipedia.org/wiki/Design_by_contract">Design by Contract</a>
          to reason about programs, libraries, methods. It allows to write more
          secure and correct software and specify its behavior.
        </p>
        <p>
          The language following this design must support writing explicit requirements 
          about values on which a program operates. It contains:
        </p>
        <ul>
          <li>preconditions - some fact (boolean condition) that must be 
            satisfied in order to call a method; it mostly concerns passed
            parameters, but is necessary
          </li>
          <li>postconditions - a fact that must be satisfied after calling a method,
            for example about its return value
          </li>
          <li>invariants - a property of a program, which does not change in time (like
            a non-decreasing order of elements in list, etc.)
          </li>
          <li>other restrictions in behavior of some part of a program (like, for example,
            the fact that a method does not change the state of a class)
          </li>
        </ul>
        <p>
          We are currently on the way to add an ability to define most of those features
          to Nemerle. In the following subsections we present their current state, design
          and plans for the future.
        </p>
        <subsection id="requires">
          <title>Preconditions - Requires attribute</title>
            <body>
              <p>
                Preconditions of a method (conditions that need to be satisfied 
                before the method is called) can be specified using the 
                <tt>Requires</tt> attribute.
              </p>
<code>
<![CDATA[
class String {
  [Requires (startIdx >= 0 && startIdx <= this.Length)]
  public Substring (startIdx : int) : string 
  { ... }
}
]]></code>
              <p>
                Using this attribute we can add an arbitrary assertion, keeping the
                body of the method clean and verbose. The compiler automatically adds
                runtime checks at the beginning of the method. If the condition is
                violated, then an <tt>AssertionException</tt> is being thrown with 
                an appropriate message containing this expression.
              </p>
              <p>
                <tt>Requires</tt> and other attributes can occur many times before a single
                method. They can be also defined directly on parameters.
              </p>
<code>
ConnectTrees ([Requires (!tree1.Cyclic ())] tree1 : Graph,
              [Requires (!tree2.Cyclic ())] tree2 : Graph, 
              e : Edge) : Graph 
{ ... }
</code>
            </body>
        </subsection>
        <subsection id="ensures">
          <title>Postconditions - Ensures attribute</title>
            <body>
              <p>
                Following the same design, we can define postconditions which the
                method must satisfy. This is an assertion that must be true
                after the execution of the method. If the method returns a value, then a 
                symbol <tt>value</tt> is available inside the expression
                stating an assertion.
              </p>
<code>
class LinkedList {
  [Ensures (IsEmpty ())]
  public Clear () : void
  { ... }

  [Ensures (value >= 0)]
  public Length () : int
  { ... }
}
</code>
            </body>
        </subsection>
        <subsection id="invariants">
          <title>Class invariants - Invariant attribute</title>
            <body>
              <p>
                An even more powerful feature is to give a condition, which
                must be true all the time during the execution of a program.
                We can attach invariant to any class by writing <tt>Invariant</tt>
                attribute before its definition.
              </p>
<code>
<![CDATA[
[Invariant (position >= 0 && position <= arr.Length)]
class Vector <T> {
  private mutable position : int = 0;
  private arr : array <T> = array [];

  public push_back (x : T) : void 
  { ... }
]]></code>
              <p>
                This way we can ensure that the state of our object is valid according to
                defined rule.
              </p>
              <p>
                This naturally brings the problem with changing variables,
                which are dependent on each other in invariant. Suppose we have 
                an assertion <tt>x == y + 5</tt> and we cannot change any of the variables.
                Thus, we need a mechanism for making transactions, within which
                invariants are temporarily ''turned off''.
              </p>
              <p>
                We follow the design of Spec# and add a special construct to expose 
                the object to changes.
              </p>
<code>
expose (this) {
  x += 3;
  y += 3;
}
</code>
              <p>
                <tt>expose</tt> takes reference to the object to be exposed and
                executes the given code.
              </p>
              <p>
                In the matter of fact, invariants are not checked all the time during
                execution. It would be too expensive to validate them at any assignment
                or call to external function. We again follow design of Spec# and 
                run assertions at the end of <tt>expose</tt> blocks and after execution
                of all public methods.
              </p>
            </body>
        </subsection>
        <subsection id="dsc-future">
          <title>Future work</title>
            <body>        
              <p>
                There are few more things which we want to implement in more or
                less distant future:
              </p>
              <ul>
                <li> 
                  a better syntax for those attributes 
<code>
class V { 
  invariant pos > 0; 

  Add (x : int) : void 
  requires x &lt; 0; 
  { ... } 
}
</code>
                </li>
                <li> 
                  Make these attributes inherited in classes deriving from those decorated
                  with assertions. For example, we define an interface with preconditions
                  and postconditions and we can be sure, that every class implementing this
                  interface will comply to them.
                </li>
                <li>
                  Plug a theorem prover designed for Spec# into Nemerle, so we can check
                  assertions not only in the runtime, but also statically at compile-time.
                </li>
                <li>
                  Invariant attribute needs much work to follow all functionality of
                  its Spec# counterpart.
                </li>
              </ul>
            </body>
        </subsection>
    </body>
  </section>
  <section id="embedded-languages">
    <title>Compile-time validation of embedded languages</title>
      <body>
        <p>
          In many programming tasks there is a need for using
          <a ref="http://en.wikipedia.org/wiki/Domain-specific_language">domain-specific languages</a>
          for performing some specialized operations. The examples are
          regular expressions used for searching and matching parts of text, formatting
          strings of <tt>printf</tt> function or SQL for obtaining data from database.
          All those languages have their own syntax and validity rules. 
        </p>
        <p>
          Most of DSLs are used inside a general-purpose language by embedding programs written in them
          into strings. For example, to query a database about elements in some table, one writes an SQL
          statement and sends it to the database provider as a string. The common problem with this approach
          is verifying correctness of embedded programs - if the syntax is valid, if  types of the 
          variables used match, etc. Unfortunately, in most cases all those checks are performed at runtime,
          when a particular program is expected to execute, but fails with a syntax or invalid cast error.
        </p>
        <p>
          All this happen, because the compiler of our general-purpose language treats DSL programs just
          as common strings. It is not surprising though - it was not designed to verify any
          particular domain-specific language - but it would be nice to do it before runtime. 
          In Nemerle we can use macros to
          handle some of the strings in a special way - for example run a verification function against
          them.
        </p>
        <p>
          This mechanism is very general and it is used in some parts of Nemerle standard library
          (like regular expression matching, printf-like functions). We will focus here on the
          design of our SQL checker.
        </p>
        <subsection id="checking-sql">
          <title>Checking SQL queries</title>
            <body>        
              <p>
	        Our library provides special functions (macros) for executing SQL queries. They
                have similar functionality to methods of System.Data.SqlClient.SqlCommand class, but
                all the strings passed to them are verified at compile-time. They are being sent
                to database by compiler, so the database provider is used here as a verification
                program. If it returns an error, the compilation is stopped with a message pointing to
                an invalid SQL statement.
              </p>
              <subsubsection id="sql-modify">
                <title>Avoiding modification of database</title>
                  <body>        
<code>
ExecuteNonQuery ("INSERT INTO employee VALUES ('John', 'Boo')", conn));
</code>
                    <p>
					<!-- ponizszy akapit niejasny; staralam sie poprawic, 
					ale nie wiem, czy czegos nie pokrecilam - E. -->
                      When the compiler executes any query, it adds a transaction 
                      around it and makes a rollback after the execution to avoid 
                      modification of the database. So, an SQL statement
                      is executed here to verify if it is correct and then it is reverted.
                    </p>
                  </body>
              </subsubsection>
              <subsubsection id="sql-params">
                <title>Safe passing values of variables to queries</title>
                  <body>        
                    <p>
                      Most of the queries in application are parametrized with 
                      program variables. For example, we read an employee name from
                      a form and then search for corresponding entries in the database.
                      In such case we want to use some variable inside the query.
                      We can obtain it in Nemerle functions by writing the <tt>$</tt>
                      character followed by the name of variable. 
                    </p>
<code>
def myparm = "John";
def count = ExecuteScalar ("SELECT COUNT FROM employee WHERE firstname = $myparm", 
                           dbcon);
</code>
                    <p>
                      Note that passing the value of <tt>myparm</tt> is done safely 
                      using .NET database provider <tt>SqlParameter</tt> class. 
                      This prevents an often used technique of exploiting database 
                      applications using SQL code insertion (if a parameter is inserted
                      as a string, one could set its value to some malicious SQL code)
                    </p>
                  </body>
              </subsubsection>
              <subsubsection id="sql-loop">
                <title>Automatic loop and result variables creation</title>
                  <body>        
                    <p>
                      Because we run queries at compile-time, we can obtain 
                      additional information useful for compilation. For example, 
                      we know which columns of the table were returned by the query 
                      and what are their types. This way the compiler can automatically
                      declare local variables and assign to them corresponding 
                      values from the result. <!-- niejasne, bylo: and populate them with... -->
                    </p>
<code>
ExecuteReaderLoop ("SELECT * FROM employee WHERE firstname = $myparm", 
                   dbcon, {
  Nemerle.IO.printf ("Name: %s %s\n", firstname, lastname)
});
</code>
                    <p>
                      The example above shows even more features. It creates a loop reading
                      rows returned from selection one by one. For each of them, it declares
                      variables containing values from all columns as mentioned before. 
                      Additionally, the entire query is created using 
                      a <tt>myparm</tt> variable from program scope.
                    </p>
                  </body>
              </subsubsection>
          </body>
        </subsection>
        <p>
          For the full code of the above examples see 
          <a ref="http://nemerle.org/svn/nemerle/trunk/snippets/sql.n">this</a>.
	</p>
      </body>
  </section>
  <section id="aspects">
    <title>Aspects-Oriented programming</title>
      <body>
        <p>
          As for now see 
          <a ref="http://nemerle.org/svn/nemerle/trunk/ncc/testsuite/positive/trace.n">this</a>.
	</p>
      </body>
  </section>
</document>
