/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Transformations of quoted expressions into syntax trees
 */

using Nemerle.Collections;

using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public module Macros
{
  /// PUBLIC API FOR USAGE IN MACROS

  /** generates new unique symbol, which can be safely used
      as name of quoted variables, functions, etc.
   */
  public NewSymbol () : string 
  {
    Util.tmpname ("")
  }


  /// DATA STRUCTURES USED IN QUOTATION AND MACROS
 variant MacroParm 
  {
    | MP_expr
    | MP_parm
    | MP_exprs
    | MP_parms
  }
  
  public class QuotationContext 
  {
    public bound : Hashtable (string, string);

    public this () { }
  }

  type QCTX = QuotationContext;
  type CTX = TypingContext;

  // some tool methods
  public unsstring (x : Splicable_string) : string {
    | SS_string (x) => x
    | _ => throw Invalid_argument ("Macros.unsstring")
  }

  // QUOTATION HANDLING SECTION

  /** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   */
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
   {
     match (li) {
       | [] => <[ [] ]>
       | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
     }
   }

  /** this method treats expression as syntax tree of list containing 
      expressions, which are arguments of variable argument constructs
      (sequence, tuple, etc.)
      it also apply given function to each argument
   */
  decompose_list (f : Expr -> Expr, ex : Expr) : Expr
  {
    match (ex) {
      | <[ $h :: $t ]> =>
        <[ $(f (h)) :: $(decompose_list (f, t)) ]>
      | <[ [] ]> => ex
      | E_spliced (e) => e
      | E_spliced_patt => ex
      | _ => 
        Message.fatal_error ("Bad expression in quoted variable arguments list: ")
    }
  }

  decompose_pattern_list (f : Pattern -> Expr, pa : Pattern) : Expr
  {
    match (pa) {
      | <[ pattern: Cons ($h, $t) ]> => 
        <[ $(f (h)) :: $(decompose_pattern_list (f, t)) ]>
      | <[ pattern: [] ]> => <[ [] ]>
      | P_spliced (e) => e
      | _ => 
        Message.fatal_error ("Bad pattern in quoted variable arguments list"); 
    }
  }

  decompose_type_list (f : Type -> Expr, ty : Type) : Expr
  {
    match (ty) {
      | T_prod (types) => 
        make_quoted_list (f, types)
      | T_spliced (e) => e
      | _ => Message.error ("Bad type in quoted variable arguments list: "); 
        f (ty)
    }
  }

  quoted_sstring (st : Splicable_string) : Expr
  { 
    | SS_string (str) => 
      <[ Nemerle.Compiler.Parsetree.SS_string ($(str : string)) ]>
    | SS_spliced_expr (E_spliced_special ("var", e)) => 
      <[ Nemerle.Compiler.Parsetree.SS_string ($e) ]>
    | SS_spliced_expr (e) => e
  }

  quoted_location (loc : Location) : Expr
  {
    <[ Nemerle.Compiler.Location ($(loc.file : string), $(loc.line : int),
                                  $(loc.column : int)) ]>
  }

  public quoted_ttype (ctx : CTX, qctx : QCTX, t : Type) : Expr
  {
    def quotedc_ttype (x) { quoted_ttype (ctx, qctx, x) };

    match (t) {
      | <[ type: $tycon (.. $args) ]> =>
        def tyco = match (tycon) { 
          | SS_string (s) => <[ $(s : string) ]>
          | SS_spliced_expr (e) => e
        };
        def findtyco = <[
          match (_N_ctx.env.LookupType ($tyco)) {
            | Some (x) => x
            | None => Message.fatal_error ("unbound type " + $tyco)
          }
        ]>;
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Typedtree.T_app 
                 ($findtyco, $(decompose_type_list (quotedc_ttype, ar))) ]>
          | _ =>
            <[ Nemerle.Compiler.Typedtree.T_app 
                 ($findtyco, $(make_quoted_list (quotedc_ttype, args))) ]>
        }

      | <[ type: $(name : var) ]> =>
        <[ Nemerle.Compiler.Typedtree.T_var (Nemerle.Compiler.Tyvar.T ($(name : string))) ]>
        
      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Typedtree.T_ref ($(quoted_ttype (ctx, qctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Typedtree.T_out ($(quoted_ttype (ctx, qctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Typedtree.T_fun ($(quoted_ttype (ctx, qctx, from)),
                                             $(quoted_ttype (ctx, qctx, to))) ]>
  
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Typedtree.T_void () ]>
  
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Typedtree.T_prod ($(make_quoted_list (quotedc_ttype, args))) ]>

      | <[ type: array ($ty) ]> =>
        <[ Nemerle.Compiler.Typedtree.T_array ($(quotedc_ttype (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Tyvar.T ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer =>
        <[ Nemerle.Compiler.Typedtree.T_infer () ]>

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Typedtree.T_prod ($(decompose_type_list (quotedc_ttype, ar))) ]>
    } 
  }

  /** transforms syntax tree of quoted type to its construction tree 
   */
  public quoted_type (ctx : CTX, qctx : QCTX, t : Type) : Expr
  {
    def quotedc_type (x) { quoted_type (ctx, qctx, x) };

    match (t) {
      | <[ type: $tycon (.. $args) ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)),
               $(decompose_type_list (quotedc_type, ar))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)), 
               $(make_quoted_list (quotedc_type, args))) ]>
        }

      | <[ type: $(name : var) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_var ($(name : string)) ]>
        
      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ctx, qctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ctx, qctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (ctx, qctx, from)),
                                             $(quoted_type (ctx, qctx, to))) ]>
  
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Parsetree.T_void () ]>
  
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quotedc_type, args))) ]>

      | <[ type: array ($ty) ]> =>
        <[ Nemerle.Compiler.Parsetree.T_array ($(quotedc_type (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.T_var ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer =>
        <[ Nemerle.Compiler.Parsetree.T_infer () ]>

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(decompose_type_list (quotedc_type, ar))) ]>
    } 
  }

  /// create construction tree of given call parameter
  public quoted_param (ctx : CTX, qctx : QCTX, p : Parm) : Expr
  {
    match (p) {
      | <[ parameter: $name = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Parm (false, 
                                            $(quoted_expr (ctx, qctx, expr)), 
                                            $(quoted_sstring (name))) ]>
      | <[ parameter: ref $name = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Parm (true, 
                                            $(quoted_expr (ctx, qctx, expr)), 
                                            $(quoted_sstring (name))) ]>
    }
  }

  public quoted_case_guard (ctx : CTX, qctx : QCTX, pair : Pattern * option (Expr)) : Expr
  {
    match (pair) {
      | <[ caseguard: $pat when $gu ]> => 
        <[ ($(quoted_pattern (ctx, qctx, pat)), 
            Nemerle.Core.Some ($(quoted_expr (ctx, qctx, gu)))) ]>
      | <[ caseguard: $pat ]> =>
        <[ ($(quoted_pattern (ctx, qctx, pat)), Nemerle.Core.None ()) ]>
    }
  }

  public quoted_case (ctx : CTX, qctx : QCTX, cas : Match_case) : Expr
  {
    def <[ case: | ..$guards => $expr ]> = cas;
    def quotedc_pattern (x) { quoted_pattern (ctx, qctx, x) };
    def quotedc_case_guard (x) { quoted_case_guard (ctx, qctx, x) };
    
    match (guards) {
      | [(P_patt_list (args), None)] =>
        <[ Nemerle.Compiler.Parsetree.Match_case ($(decompose_pattern_list (quotedc_pattern,
             args)), $(quoted_expr (ctx, qctx, expr))) ]>
      | _ =>
        <[ Nemerle.Compiler.Parsetree.Match_case ($(make_quoted_list (quotedc_case_guard, 
             guards)), $(quoted_expr (ctx, qctx, expr))) ]>
    }
  }

  public quoted_fparam (ctx : CTX, qctx : QCTX, p : Fun_parm) : Expr
  {
    match (p) {
      | <[ funparm: $name : $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ctx, qctx, ty)),
                                                Nemerle.Compiler.Parsetree.FP_normal ()) ]>
      | <[ funparm: params $name : $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ctx, qctx, ty)),
                                                Nemerle.Compiler.Parsetree.FP_params ()) ]>
      | <[ funparm: $name : $ty = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
             $(quoted_type (ctx, qctx, ty)),
             Nemerle.Compiler.Parsetree.FP_default ($(quoted_expr (ctx, qctx, expr)))) ]>
    }
  }

  public quoted_fundecl (ctx : CTX, qctx : QCTX, d : Function_decl) : Expr
  {
    def quoted_tparms (t : Typarms) : Expr {
      def quoted_constraint (c : Constraint) {
        <[ Nemerle.Compiler.Parsetree.Constraint ($(c.tyvar : string),
                                                  $(quoted_type (ctx, qctx, c.ty))) ]>
      };
      def quoted_string (s) { <[ $(s : string) ]> };

      <[ Nemerle.Compiler.Parsetree.Typarms ($(make_quoted_list (quoted_string, t.tyvars)),
           $(make_quoted_list (quoted_constraint, t.constraints))) ]>
    };

    def quotedc_expr (x) { quoted_expr (ctx, qctx, x) };
    def quotedc_fparam (x) { quoted_fparam (ctx, qctx, x) };

    match (d) {
      | <[ fundecl: $name (..$fparms) : $ty { ..$bodyseq } ]> =>
        def body = quoted_expr (ctx, qctx, <[ {..$bodyseq} ]>);
        match (fparms) {
          | [{ name = SS_string (""); ty = <[ type: void ]>; attr = FP_default (e); }] =>
            <[ Nemerle.Compiler.Parsetree.Function_decl 
                (Nemerle.Compiler.Parsetree.Fun_header ($(quoted_tparms (d.header.typarms)),
                 $(quoted_sstring (name)), $(quoted_type (ctx, qctx, ty)),
                 $(decompose_list (quotedc_expr, e))),
                 $body) ]>
          | _ =>
              <[ Nemerle.Compiler.Parsetree.Function_decl 
                 (Nemerle.Compiler.Parsetree.Fun_header ($(quoted_tparms (d.header.typarms)),
                    $(quoted_sstring (name)), $(quoted_type (ctx, qctx, ty)),
                    $(make_quoted_list (quotedc_fparam, fparms))),
                  $body) ]>
        }
      | _ => Message.fatal_error ("such quoted function declaration is not supported")
    }
  }

  public quoted_expr (ctx : CTX, qctx : QCTX, expr : Expr) : Expr 
  {
    def quotedc_expr (x) { quoted_expr (ctx, qctx, x) };

    match (expr) {
      | <[ $(id : var) ]> => 
        <[ Nemerle.Compiler.Parsetree.E_ref ($(id : string)) ]>

      | <[ $obj . $mem ]> => 
        <[ Nemerle.Compiler.Parsetree.E_member ($(quotedc_expr (obj)),
                                                $(quoted_sstring (mem))) ]>

      | <[ $func (.. $parms) ]> =>
        match (parms) {
          | [ { expr = E_expr_list (args) }] =>
            <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (ctx, qctx, func)),
                                                  $(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_call ($(quotedc_expr (func)), 
               $(make_quoted_list (fun (x) { quoted_param (ctx, qctx, x) }, parms))) ]>
        }

      | <[ $target <- $source ]> =>
        <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (ctx, qctx, target)), 
                                                $(quoted_expr (ctx, qctx, source))) ]>

      | <[ def $name = $val ]> =>
        <[ Nemerle.Compiler.Parsetree.E_let ($(false : bool), 
                                             $(quoted_sstring (name)), 
                                             $(quoted_expr (ctx, qctx, val))) ]>

      | <[ mutable $name <- $val ]> =>
        <[ Nemerle.Compiler.Parsetree.E_let ($(true : bool),
                                             $(quoted_sstring (name)),
                                             $(quoted_expr (ctx, qctx, val))) ]>

      | <[ def (.. $elems) = $val ]> =>
        <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (ctx, qctx, 
                                                                  P_tuple (elems))), 
                                                $(quoted_expr (ctx, qctx, val))) ]>

      | <[ def .. $funs ]> =>
        match (funs) {
          | [(_, E_expr_list (args))] =>
            <[ Nemerle.Compiler.Parsetree.E_letfun ($(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_letfun (
                $(make_quoted_list (fun (x) { quoted_fundecl (ctx, qctx, x) }, funs))) ]>
        }

      | <[ fun (..$args) : $ty { ..$bodyseq } ]> =>
        // we have to rebuild sequence, which is here decomposed
        def body = quoted_expr (ctx, qctx, <[ {..$bodyseq} ]>);
        match (args) {
          | [{ name = SS_string (""); ty = <[ type: void ]>; attr = FP_default (e); }] =>
            <[ Nemerle.Compiler.Parsetree.E_lambda (Nemerle.Compiler.Parsetree.Function_decl 
            (Nemerle.Compiler.Parsetree.Fun_header (Nemerle.Compiler.Parsetree.Typarms([],[]),
                Nemerle.Compiler.Parsetree.SS_string (""), $(quoted_type (ctx, qctx, ty)),
                  $(decompose_list (quotedc_expr, e))),
                 $body)) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_lambda (Nemerle.Compiler.Parsetree.Function_decl 
               (Nemerle.Compiler.Parsetree.Fun_header (Nemerle.Compiler.Parsetree.Typarms([],[]),
                  Nemerle.Compiler.Parsetree.SS_string (""), $(quoted_type (ctx, qctx, ty)),
                  $(make_quoted_list (fun (x) { quoted_fparam (ctx, qctx, x) }, args))),
                $body)) ]>
        };

      | <[ match ($expr) {.. $cases } ]> =>
        match (cases) {
          | [cas] when match (cas.patterns) { | [] => true | _ => false } =>
            match (cas.body) {
              | E_expr_list (e) =>
                <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (ctx, qctx, expr)), 
                     $(decompose_list (quotedc_expr, e))) ]>
              | _ =>
                Util.ice ("parser generated strange match_case")
            }
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (ctx, qctx, expr)), 
                 $(make_quoted_list (fun (x) { quoted_case (ctx, qctx, x) }, 
                                     cases))) ]>
        }

      | <[ throw $exc ]> =>
        <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (ctx, qctx, exc))) ]>

      | <[ try $body catch { $exn : $exn_ty => $handler } ]> => 
        <[ Nemerle.Compiler.Parsetree.E_try_with ($(quoted_expr (ctx, qctx, body)), 
                                                  $(quoted_sstring (exn)),
                                                  $(quoted_type (ctx, qctx, exn_ty)), 
                                                  $(quoted_expr (ctx, qctx, handler))) ]>

      | <[ try $body finally $handler ]> =>
        <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (ctx, qctx, body)), 
             $(quoted_expr (ctx, qctx, handler))) ]>

      | <[ () ]> => 
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_void ()) ]>

      | <[ null ]> => 
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_null ()) ]>

      | <[ $(val : int) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

      | <[ $(val : string) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

      | <[ $(_val : float) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float (0 /* $(val : float) */)) ]> // FIXME

      | <[ $(val : bool) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

      | <[ $(val : char) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

      | <[ this ]> =>
        <[ Nemerle.Compiler.Parsetree.E_this () ]>

      | <[ base ]> => 
        <[ Nemerle.Compiler.Parsetree.E_base () ]>

      | <[ typeof ($t) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_typeof ($(quoted_type (ctx, qctx, t))) ]>

      | <[ ( $expr :> $ty ) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (ctx, qctx, expr)),
                 $(quoted_type (ctx, qctx, ty))) ]>

      | <[ ( $expr : $ty ) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (ctx, qctx, expr)),
            $(quoted_type (ctx, qctx, ty))) ]>

      | <[ {.. $seq } ]> =>
        match (seq) {
          | [E_expr_list (seq)] =>
            <[ Nemerle.Compiler.Parsetree.E_sequence ($(decompose_list (quotedc_expr, seq))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_sequence ($(make_quoted_list (quotedc_expr, seq))) ]>
        }

      | <[ (.. $args) ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_tuple ($(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quotedc_expr, args))) ]>
        }

      | <[ array [.. $args] ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_mkarray ($(decompose_list (quotedc_expr, 
                                                                       args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_mkarray ($(make_quoted_list (quotedc_expr, 
                                                                         args))) ]>
        }

      | <[ array (.. $sizes) ]> =>
        match (sizes) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_empty_array ($(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_empty_array ($(make_quoted_list (quotedc_expr, sizes))) ]>
        }

      | <[ $obj [.. $args] ]> =>  
        match (args) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_indexer ($(quotedc_expr (obj)),
                                                     $(decompose_list (quotedc_expr, 
                                                                       args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_indexer ($(quotedc_expr (obj)),
                                                     $(make_quoted_list (quotedc_expr, 
                                                                         args))) ]>
        }

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | E_macrocall (name, parms) =>
        def quoted_syntax (s) {
          | SyntaxExpr (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxExpr ($(quoted_expr (ctx, qctx, body))) ]>
          | SyntaxPattern (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxPattern ($(quoted_pattern (ctx, qctx, 
                                                                           body))) ]>
          | SyntaxType (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxType ($(quoted_type (ctx, qctx, body))) ]>
          | SyntaxParm (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxParm ($(quoted_param (ctx, qctx, body))) ]>
          | SyntaxCase (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxCase ($(quoted_case (ctx, qctx, body))) ]>
          | SyntaxCaseGuard (body, guard) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxCaseGuard 
                 ($(quoted_case_guard (ctx, qctx, (body, guard)))) ]>
          | SyntaxFunDecl (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxFunDecl 
                 ($(quoted_fundecl (ctx, qctx, body))) ]>
          | SyntaxFunParm (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxFunParm 
                  ($(quoted_fparam (ctx, qctx, body))) ]>  
          | SyntaxTType (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxTType ($(quoted_type (ctx, qctx, body))) ]>
        };

        <[ Nemerle.Compiler.Parsetree.E_macrocall ($(name : string),
                                                   $(make_quoted_list (quoted_syntax, 
                                                                       parms))) ]>

      | E_spliced (e) => e

      | E_spliced_patt => expr

      | E_spliced_special (ty, val) =>
        match (ty) {
          | "var" => <[ Nemerle.Compiler.Parsetree.E_ref ($val) ]>
          | "int" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($val)) ]>
          | "string" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($val)) ]>
          | "bool" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($val)) ]>
          | "char" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($val)) ]>
          | "float" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($val)) ]>
          | "typed" => 
            <[ Nemerle.Compiler.Parsetree.E_typed_expr ($val) ]>
          | _ =>
            Util.ice ("unsupported type of spliced literal in expression")
        }

      | E_quoted => 
        Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
      | E_typed_expr => 
        Util.ice ("You've got beer from me for generating such a code...");
      | E_expr_list =>
        // print location
        Message.debug ("list of expression parameters outside of any construct");
        Util.ice ("List of expression parameters outside of any construct")
      | E_letpat => Util.ice ("Bad construction of E_letpat")
      | E_lambda => Util.ice ("Bad construction of E_lambda")
    };
  } // end quoted_expr

  /** transforms syntax tree of quoted pattern to its construction
      tree 
   */   
  public quoted_pattern (ctx : CTX, qctx : QCTX, pat : Pattern) : Expr 
    {
      def quotedc_pattern (x) { quoted_pattern (ctx, qctx, x) };

      match (pat) {
        | <[ pattern: _ ]> => <[ Nemerle.Compiler.Parsetree.P_underscore () ]>

        | <[ pattern: $(name : var) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_variable ($(name : string)) ]>

        | <[ pattern: ($pat) as $name ]> => 
          <[ Nemerle.Compiler.Parsetree.P_as ($(quoted_pattern (ctx, qctx, pat)), 
                                              $(quoted_sstring (name))) ]>

/* it seems to be impossible to be done, because we would have to write pattern, 
   which matches terms like Cons(x, Cons(y, Cons(z, xs))) into [x;y;z; ?]
        | <[ pattern: [..$elems] ]> =>
          match (elems) {
            | [P_patt_list (args)] => decompose_pattern_list (quoted_pattern, args)
            | _ =>
              make_quoted_list (quoted_pattern, elems)
          }
        | <[ pattern: [$elems] ]> =>
          match (elems) {
            | P_patt_list (args) => quoted_pattern (args)
            | _ =>
              def nl = <[ pattern : [] ]>;
              <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (SS_string ("Cons"))), 
                 $(quoted_pattern (P_tuple ([elems; nl])))) ]>
          }
 <[ pattern: Cons ($elems, Nil) ]>
*/

        | <[ pattern: (.. $args) ]> =>
          match (args) {
            | [P_patt_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(decompose_pattern_list (quotedc_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(make_quoted_list (quotedc_pattern, args))) ]>
          }
        
        | <[ pattern: {.. $args } ]> =>
          def quoted_named_pattern (patt : string * Pattern) : Expr
            {
              def (name, pat) = patt;
              <[ ($(name : string), $(quoted_pattern (ctx, qctx, pat))) ]>
            };
             
          match (args) {
            | [(_, P_patt_list (args))] =>
              <[ Nemerle.Compiler.Parsetree.P_record 
                   ($(decompose_pattern_list (quotedc_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_record
                   ($(make_quoted_list (quoted_named_pattern, args))) ]>
          }

        | <[ pattern: $name (.. []) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                         Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        | <[ pattern: $name (.. $args) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (ctx, qctx, 
                                                           P_tuple (args)))) ]>

        | <[ pattern: $name {.. $args} ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (ctx, qctx, 
                                                          P_record (args)))) ]>

        | <[ pattern: $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ pattern: $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ pattern: $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ pattern: $(val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

        | <[ pattern: $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ pattern: () ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ pattern: null ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_null ()) ]>

        | <[ pattern: $name _ ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
             Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        // rest of constructs must be in not quoted form, because they define
        // internal data structures
  | P_spliced (e) => e

        | P_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.P_variable ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($val)) ]>
            | "name" => 
              <[ Nemerle.Compiler.Parsetree.SS_string ($val) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in pattern")
          }

        | P_quoted =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
  | P_patt_list =>
          Message.fatal_error 
            ("Variable pattern arguments list appears outside of proper construct")
        | P_cons (_, _) =>
          Util.ice ("Bad constructed P_cons")
      } 
    }

  /** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   */    
  public expr_to_pattern (exp : Expr) : Pattern 
  {
    def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
      match (pars) {
        | [] => 
          match (acc) {
            | [] => P_underscore ()
            | _ => P_tuple (List.Rev (acc))
          }
        | <[ parameter: $expr ]> :: xs => 
          convert_params (xs, expr_to_pattern (expr) :: acc)
        | _ => Util.ice ("strange parameters generated from quoting")
      }
    };

    def flat_member (obj) {
      def collect_member (obj : Expr, acc) {
        match (obj) {
          | <[ $(id : var) ]> => id :: acc
          | <[ $head.$(id : var) ]> => collect_member (head, id :: acc)
          | _ => Util.ice ("Corrupted member while flatting member expr -> pattern")
        }
      };
      match (collect_member (obj, [])) {
        | x :: xs =>
          def inter = List.FoldLeft (
            fun (sb : System.Text.StringBuilder, s : string) : System.Text.StringBuilder 
              { sb.Append ("." + s) }, 
            System.Text.StringBuilder (x), xs);
          inter.ToString ()
        | _ =>
          Util.ice ("collect_member returned empty list")
      }
    };

    match (exp) {
      | <[ $(id : var) ]> => <[ pattern: $(id : var) _ ]>
      | <[ $constr (.. $pars) ]> =>
        def con = flat_member (constr);
        match (GlobalEnv.LookupExactType (con)) {
          | Some (tcon) =>
            match (tcon.GetTydecl ()) {
              | Typedtree.TD_variant_option =>
                P_cons (SS_string (con), convert_params (pars, []))                  
              | Typedtree.TD_class  =>
                // we lose informations about constructor here, but as it's 
                // compiler internal computation we can ignore it
                convert_params (pars, [])
              | _ =>
                Util.ice ("expression generated from quotation has nor variant"
                          + " neither class constructor")
            }
          | None =>
            Util.ice ("expression generated from quotation has broken constructor")
        }

      | <[ (..$elems) ]> => <[ pattern: (..$(List.Map (expr_to_pattern, elems))) ]>

      | E_literal (lit) => P_literal (lit)

      | E_spliced_patt (p) => p

      | _ => 
        Util.ice ("Bad constructed quoted expression in pattern matching")
    }
  }

  // GENERATION OF MACRO CLASSES SECTION

  /** Generate class implementing interface [MacroRegistry.IMacro], which
      encapsulates execution of macro. Created methods are:
      [Run] for running macro,
      [GetName] for retrieving its name, 
      [SyntaxExtension] for retrieving syntax extension it defines,
      [CallTransform] for transforming supported call parameters to
        description taken by [Run] method
   */
  public GenerateMacroClass (attrs : list(Modifier), header : Fun_header, 
                             synt : list(Expr), expr : Expr) : Type_decl
  {
    def name = 
      match (header.name) {
        | SS_string (n) => n
        | _ => Message.fatal_error ("spliced name in macro name is not allowed")
      };

    // walk through parameters given to macro, extract their names,
    // note type names, control if they correspond to Nemerle grammar,
    // handle variable amount of parameters and default values
    // create code decomposing passed parameters if needed
    def analyze_params (pars : list (Fun_parm), acc, accs, accmp, defaults,
                        types : System.Text.StringBuilder) 
                        : list (Pattern) * list (Expr) * list(MacroParm)
    {
      // build pattern for list from list of patterns
      def roll (li, bu) {
        match (li) {
          | [] => bu
          | x::xs => roll (xs, <[ pattern: $x :: $bu ]>)
        }
      };
      // build expression for list from list of expressions
      def roll_expr (li, bu) {
        match (li) {
          | [] => bu
          | (va, d)::xs => roll_expr (xs, <[ { def $(va : var) = $d; $bu } ]>)
        }
      };

      // handle case of standard (not params or with default value) parameter
      // decompose handled types, note them and build pattern matching
      // parameter's expression
      def normal_parm (t, va) {
        match (t) {
          | T_infer 
          | <[ type: expr ]> => 
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr ($(va : var)) ]>, 
             types.Append (" expr"), MP_expr ())
          | <[ type: parm ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxParm ($(va : var)) ]>, 
             types.Append (" parm"), MP_parm ())
          | <[ type: funparm ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxFunParm ($(va : var)) ]>, 
             types.Append (" funparm"), MP_parm ())
          | <[ type: string ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr (Nemerle.Compiler.
             Parsetree.E_literal (Nemerle.Compiler.L_string ($(va : var)))) ]>,
             types.Append (" string"), MP_expr ())
          | <[ type: int ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr (Nemerle.Compiler.
             Parsetree.E_literal (Nemerle.Compiler.L_int ($(va : var)))) ]>,
             types.Append (" string"), MP_expr ())
          | <[ type: bool ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr (Nemerle.Compiler.
             Parsetree.E_literal (Nemerle.Compiler.L_bool ($(va : var)))) ]>,
             types.Append (" bool"), MP_expr ())
          | _ =>
            Message.fatal_error ("type not supported")
        }
      };

      // create list of match cases (patterns and expressions) containing
      // cases for default values of parameters, add expressions defining
      // missed parameters according to those default values
      def traverse_patterns (pattss, defaults, defsrest, accpat, accexp) {
        match ((pattss, defaults)) {
          | ([], _) => (accpat, accexp)
          | (patts :: xss, []) =>
            traverse_patterns (xss, [], [], roll (patts, <[ pattern: [] ]>) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
          | (patts :: xss, d :: ds) =>
            def newdrest = d :: defsrest;
            traverse_patterns (xss, ds, newdrest, 
                               roll (patts, <[ pattern: [] ]>) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
        }
      };

      // iterate through parameters
      match (pars) {
        | [] => 
          // we have fixed amount of parameters, so there is always
          // case, which triggers error, handle it
          def warn = <[ Nemerle.Compiler.Message.fatal_error ("macro `" 
            + $(name : string) + "' expects following list of arguments: " + 
            $(types.ToString () : string)) ]>;
          def (pats, exps) =
            traverse_patterns (acc :: accs, defaults, [], 
                               [ <[ pattern: _ ]> ], [warn]);
          (pats, exps, List.Rev (accmp))

        | { name = SS_string (va); ty = t; attr = at } :: xs =>
          match (at) {
            // variable amount of parameters is handled here
            | FP_params =>
              def (initpat, initex) =
                match (acc) {
                  // if there are some elemnts other than out 'va', then this
                  // pattern won't be exchaustive, and we must supply error msg
                  | _ :: _ => 
                    def types = types.Append (" params array");
                    def warn = <[ Nemerle.Compiler.Message.fatal_error ("macro `"
                      + $(name : string) + "' expects following list of arguments: "
                      + $(types.ToString () : string)) ]>;
                    ([ <[ pattern: _ ]> ], [warn])
                  | _ =>
                    ([], [])
                };
              match (t) {
                | <[ type: array (parm) ]> =>
                  def (pats, exps) =
                    traverse_patterns (accs, defaults, [], 
                      roll (acc, <[ pattern: $("_N_" + va : var) ]>) :: initpat,
                      <[ def $(va : var) = 
                           List.Map (fun (p : Nemerle.Compiler.Parsetree.SyntaxElement) 
                             { match (p) { | Nemerle.Compiler.Parsetree.SyntaxParm (e) => e
                                           | _ => Message.fatal_error ("ice") } }, 
                             $("_N_" + va : var));
                         $expr
                      ]> :: initex);
                  (pats, exps, List.Rev (MP_parms () :: accmp))

                | <[ type: array (expr) ]> =>
                  def tmpvar = NewSymbol ();
                  def (pats, exps) =
                    traverse_patterns (accs, defaults, [], 
                      roll (acc, <[ pattern: $(tmpvar : var) ]>) :: initpat,
                      <[ 
                        def $(va : var) = 
                          List.Map (fun (p : Nemerle.Compiler.Parsetree.SyntaxElement) 
                              { match (p) { 
                                | Nemerle.Compiler.Parsetree.SyntaxExpr (e) => e
                                | _ => Message.fatal_error ("ice") 
                              } 
                            }, $(tmpvar : var));
                        $expr
                      ]> :: initex);
                  (pats, exps, List.Rev (MP_exprs () :: accmp))
 
                | _ =>
                  Message.fatal_error ("only array of expr or parm are " +
                                       "supported in params")
              }

            // parameter with default value
            | FP_default (e) =>
              def (p, str, mp) = normal_parm (t, va);
              analyze_params (xs, p :: acc, acc :: accs, mp :: accmp, 
                               (va, e) :: defaults, str.Append ("(opt)"))
          
            | FP_normal =>
              match (defaults) {
                | [] =>
                  def (p, str, mp) = normal_parm (t, va);
                  analyze_params (xs, p :: acc, accs, mp :: accmp, defaults, str)
                | _ =>
                  Message.fatal_error ("parameters with default values must not"
                                       + " be mixed with normal")
              }
          }
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro parameters")
      }    
    };

    // creates match caces from pairs of pattern and expression
    def consolide_cases (pats, exps, acc) {
      match ((pats, exps)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => 
          consolide_cases (xs, ys, <[ case: $x => $y ]> :: acc)
        | _ => Util.ice ()
      }
    };


    // store positions and types of all parameters accessed by their names
    def mapparams (pars : list (Fun_parm), n, hash : Hashtable (string, int * Type)) {
      match (pars) {
        | [] => hash
        | { name = SS_string (x); ty = t } :: xs => 
          if (hash.Contains (x)) 
            Message.fatal_error ("parameter names cannot repeat")
          else
            hash.Add (x, (n, t)); mapparams (xs, n + 1, hash)
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro params")
      }
    };
    def paramsmap = mapparams (header.parms, 0, Hashtable ());

    // if syntax extending section of macro exists, analyze all tokens and
    // permutation of parameters in its definition
    def analyze_syntax (toks, acc, positacc) {
      match (toks) {
        | [] => 
          // we have reached end of syntax definition, reverse accumulator
          // and return stored tokens and parameters' positions
          match (List.Rev (acc)) {
            | Parser.GE_keyword (key) :: rules =>
              ("_N_" + name + "_call", key, rules, positacc)

            // if there was no syntax definition
            | [] => (name, "", [], [])
            | _ => Message.fatal_error 
                     ("first token of syntax definition must be keyword")
          }
        | <[ $(x : string) ]> :: xs when Lexer.IsKeyword (x) =>
          analyze_syntax (xs, Parser.GE_keyword (x) :: acc, positacc)

        | <[ $(x : string) ]> :: xs when Lexer.IsOperator (x) =>
          analyze_syntax (xs, Parser.GE_operator (x) :: acc, positacc)

        | <[ $(x : var) ]> :: xs =>
          match (paramsmap.Get (x)) {
            | Some ((pos, ty)) =>
              paramsmap.Remove (x);
              def grammar_token =
                match (ty) {
                  | <[ type: parm ]> => Parser.GE_parm ()
                  | <[ type: funparm ]> => Parser.GE_funparm ()
                  | <[ type: array (parm) ]> => Parser.GE_parm_list (",")
                  | <[ type: array (expr) ]> => Parser.GE_expression_list (",")
                  | _ => Parser.GE_expression ()
                };
              analyze_syntax (xs, grammar_token :: acc, pos :: positacc)
            | None =>
              Message.fatal_error ("parameters from syntax description doesn't"
                                   + " match macro's")
          }
        | _ => Message.fatal_error ("unsupported syntax token")
      }
    };

    // lifted list of grammar elements
    def roll_gramm_els (l) {
      match (l) {
        | x :: xs =>
          def exp = roll_gramm_els (xs);
          match (x) {
            | Parser.GE_operator (name) =>
              <[ Nemerle.Compiler.Parser.GE_operator ($(name : string)) :: $exp ]>
            | Parser.GE_keyword (name) =>
              <[ Nemerle.Compiler.Parser.GE_keyword ($(name : string)) :: $exp ]>
            | Parser.GE_expression =>
              <[ Nemerle.Compiler.Parser.GE_expression () :: $exp ]>
            | Parser.GE_block =>
              <[ Nemerle.Compiler.Parser.GE_block () :: $exp ]>
            | Parser.GE_expression_list (sep) =>
              <[ Nemerle.Compiler.Parser.GE_expression_list ($(sep : string)) :: $exp ]>
            | Parser.GE_parm_list (sep) =>
              <[ Nemerle.Compiler.Parser.GE_parm_list ($(sep : string)) :: $exp ]>
            | Parser.GE_parm  =>
              <[ Nemerle.Compiler.Parser.GE_parm () :: $exp ]>
            | Parser.GE_funparm =>
              <[ Nemerle.Compiler.Parser.GE_funparm () :: $exp ]>
          }
        | [] => <[ [] ]>
      }
    };
    def roll_ints (l) {
      match (l) {
        | x :: xs =>
          <[ $(x : int) :: $(roll_ints (xs)) ]>
        | [] => <[ [] ]>
      }
    };

    // build SyntaxExtension method
    def (callname, key, rules, positions) = analyze_syntax (synt, [], []);
    def syntHeader =
      Fun_header (header.loc, SS_string ("SyntaxExtension"), 
                  <[ type: string * list (Nemerle.Compiler.Parser.GrammarElement) 
                           * list (int) ]>,
                  []);
    def syntBody = <[ ($(key : string), $(roll_gramm_els (rules)), 
                       $(roll_ints (positions))) ]>;
    def syntFunc = 
      M_function (header = syntHeader, 
                  name = "SyntaxExtension",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.SyntaxExtension"]), 
                  body = FB_parsed_expr (syntBody));

    def (macro_patts, macro_exprs, macro_parms) = 
      analyze_params (header.parms, [], [], [], [], System.Text.StringBuilder ());
    def macro_cases = List.Rev (consolide_cases (macro_patts, macro_exprs, []));

    // build method Run running macro's body
    def runHeader =
      Fun_header (header.loc, SS_string ("Run"), 
                  <[ type: Nemerle.Compiler.Parsetree.Expr ]>,
                  [Fun_parm (header.loc, SS_string ("_N_ctx"), 
                             <[ type: Nemerle.Compiler.Tyexpr.CTX ]>,
                             FP_normal ()),
                   Fun_parm (header.loc, SS_string ("_N_parms"), 
                             <[ type: list (Nemerle.Compiler.Parsetree.SyntaxElement) ]>,
                             FP_normal ())]);
    def runBody = <[ match (_N_parms) { ..$macro_cases } ]>;
    def runFunc = M_function (header = runHeader, 
                              name = "Run",
                              modifiers = [],
                              loc = header.loc,
                              kind = FK_method (["Nemerle.Compiler.IMacro.Run"]), 
                              body = FB_parsed_expr (runBody));
   
    // create decision tree for transformation of supported call
    // parameters to our SyntaxElement description
    def (trans_p, trans_r) = (NewSymbol (), NewSymbol ());
    def create_transform_tree (parms) {
      | MP_parm :: xs =>
        <[ match ($(trans_p : var)) {
             | x :: $(trans_p : var) =>
               $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxParm (x) 
                 :: $(trans_r : var);
               $(create_transform_tree (xs))
             | [] => ()
           }
        ]>
      | MP_expr :: xs =>
        <[ match ($(trans_p : var)) {
             | { expr = x } :: $(trans_p : var) =>
               $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxExpr (x) 
                 :: $(trans_r : var);
               $(create_transform_tree (xs))
             | [] => ()
           }
        ]>
      | [MP_exprs] =>
        <[ def app_expr (l : list (Nemerle.Compiler.Parsetree.Parm)) {
             match (l) {
               | { expr = x } :: xs => 
                 $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxExpr (x) 
                   :: $(trans_r : var);
                 app_expr (xs)
               | [] => ()
             }
           };
           app_expr ($(trans_p : var))
        ]>
      | [MP_parms] =>
        <[ def app_par (l) {
             match (l) {
               | x :: xs => 
                 $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxParm (x) 
                   :: $(trans_r : var);
                 app_par (xs)
               | [] => ()
             }
           };
           app_par ($(trans_p : var))
        ]>

      | [] => <[ () ]>
      | _ => Util.ice ("corrupted macro parameters")
    };
    // build CallTransform method
    def calltrans_body = <[ 
      mutable $(trans_r : var) <- [];
      $(create_transform_tree (macro_parms));
      List.Rev ($(trans_r : var));
    ]>;
    def calltrans_header =
      Fun_header (header.loc, SS_string ("CallTransform"), 
                  <[ type: list (Nemerle.Compiler.Parsetree.SyntaxElement) ]>,
                  [Fun_parm (header.loc, SS_string (trans_p), 
                             <[ type: list (Nemerle.Compiler.Parsetree.Parm) ]>,
                             FP_normal ())]);
    def calltransFunc = 
      M_function (header = calltrans_header, 
                  name = "CallTransform",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.CallTransform"]), 
                  body = FB_parsed_expr (calltrans_body));

    // build GetName fuction for macro class
    def getnameFunc = 
      M_function (header = Fun_header (header.loc, SS_string ("GetName"), 
                                       <[ type: string ]>, []),
                  name = "GetName",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.GetName"]),
                  body = FB_parsed_expr (<[ $(callname : string) ]>));

    def thisFunc =
      M_function (header = Fun_header (header.loc, SS_string (".ctor"), 
                                       <[ type: void ]>, []), 
                  name = ".ctor",
                  modifiers = [Mod_public ()],
                  loc = header.loc,
                  kind = FK_ctor (), 
                  body = FB_parsed_expr (<[ () ]>));

    // build macro class
    def td = TD_class ([syntFunc, calltransFunc, runFunc, thisFunc, getnameFunc]);
    td.modifiers <- Mod_macro () :: Mod_public () :: attrs;
    td.name <- NewSymbol ();
    td.t_implements <- [ <[ type: Nemerle.Compiler.IMacro ]> ];
    td.typarms <- Typarms ([],[]);
    td.t_extends <- None ();
    td
  }

  public CreatePermutingFunction (positions : list (int)) 
  : list (SyntaxElement) -> list (SyntaxElement)
  {
    def len = List.Length (positions);
    fun (li) {
      def take_first (n, l, acc) {
        match ((n, l)) {
          | (0, _) => (List.Rev (acc), l)
          | (_, []) => Util.ice ("too few parameters")
          | (n, x :: xs) =>
            take_first (n - 1, xs, x :: acc)
        }
      };
      def pararr = (System.Array.CreateInstance (typeof (SyntaxElement), len) 
                    :> array (SyntaxElement));
      mutable m <- 0;
      def loop (l, ps) {
        match ((l, ps)) {
          | (x :: xs, [p]) =>
            pararr[p] <- x;
            loop (xs, [])
          | (x :: xs, p :: pp) =>
            if (p == len - 1) {
              def (rtail, rfront) = take_first (len - m - 1, 
                                                List.Rev (xs), []);
              pararr[p] <- x;
              loop (List.Append (List.Rev (rtail), List.Rev (rfront)), pp)
            }
            else {
              pararr[p] <- x;
              m <- m + 1;
              loop (xs, pp)
            }
          | (xs, []) => List.Append (List.FromArray (pararr), xs)
          | ([], _) => Util.ice ("too few parameters")
        }
      };
      loop (li, positions)
    }
  }

  // PRETTY PRINTING TOOLS SECTION

  public PrintExpr (ctx : CTX, expr : Expr, empty : string, expand : bool) : void 
  {
    def expr = 
      if (expand) MacroRegistry.expand_macro (ctx, expr)
      else expr;

    match (expr) {
      | <[ $(id : var) ]> => 
        printf ("%s", id)

      | <[ $obj . $(mem : var) ]> => 
        PrintExpr (ctx, obj, empty, expand); printf (".%s", mem)

      | <[ [] ]> => printf ("[]")

      | <[ $x :: $xs ]> =>
        PrintExpr (ctx, x, empty, expand);  
        printf (" :: "); PrintExpr (ctx, xs, empty, expand)

      | <[ $func (.. $parms) ]> =>
        def print_params (pars) {
          def print_parm (p : Parm) {
            match (p) {
              | <[ parameter: $(name : var) = $expr ]> =>
                unless (name == "") printf ("%s = ", name);
                PrintExpr (ctx, expr, empty + "  ", expand)
              | <[ parameter: ref $(name : var) = $expr ]> =>
                unless (name == "") printf ("%s = ", name);
                PrintExpr (ctx, expr, empty + "  ", expand)
              | _ => Message.error ("spliced in PrintExpr")
            }
          };
          match (pars) {
            | [] => ()
            | [x] => print_parm (x)
            | x :: xs =>
              print_parm (x); printf (", "); print_params (xs)
          }
        };

        PrintExpr (ctx, func, empty, expand); printf (" (");
        print_params (parms); printf (")");

      | <[ $target <- $source ]> =>
        PrintExpr (ctx, target, empty, expand); printf (" <- ");
        PrintExpr (ctx, source, empty, expand);

      | <[ def $(name : var) = $val ]> =>
        printf ("def %s = ", name);
        PrintExpr (ctx, val, empty, expand)

      | <[ mutable $(name : var) <- $val ]> =>
        printf ("mutable %s = ", name); PrintExpr (ctx, val, empty, expand)

      | <[ def (.. $elems) = $val ]> =>
        printf ("def ("); 
        List.Iter (fun (x) { PrintPattern (x); printf ("; ") }, elems);
        printf (") = ");
        PrintExpr (ctx, val, empty, expand);

      | <[ match ($expr) {.. $cases } ]> =>
        def print_case (c : Match_case) {
          def print_guard (g : Pattern * option (Expr)) {
            match (g) {
              | <[ caseguard: $pat when $e ]> =>
                printf ("\n%s| ", empty + "  ");
                PrintPattern (pat);
                printf (" when ");
                PrintExpr (ctx, e, empty + "    ", expand)
              | <[ caseguard: $pat ]> =>
                printf ("\n%s| ", empty + "  "); 
                PrintPattern (pat);
            }
          };

          def <[ case: | ..$guards => $expr ]> = c;
          List.Iter (print_guard, guards);
          printf (" => \n%s", empty + "    ");
          PrintExpr (ctx, expr, empty + "    ", expand)
        };

        printf ("match ("); 
        PrintExpr (ctx, expr, empty, expand); printf (") {");
        List.Iter (print_case, cases);
        printf ("\n%s}", empty)

      | <[ throw $exc ]> =>
        printf ("throw "); PrintExpr (ctx, exc, empty, expand);

      | <[ try $body catch { $(exn : var) : $exn_ty => $handler } ]> => 
        printf ("try\n%s  ", empty);
        PrintExpr (ctx, body, empty + "  ", expand);
        printf ("\n%swith {\n%s", empty, empty + "  ");
        printf ("%s : ", exn);
        PrintType (exn_ty); printf ("=>\n%s", empty + "    ");
        PrintExpr (ctx, handler, empty + "    ", expand)

      | <[ try $body finally $handler ]> =>
        printf ("try\n%s  ", empty);
        PrintExpr (ctx, body, empty + "  ", expand);
        printf ("\n%sfinally\n%s  ", empty, empty);
        PrintExpr (ctx, handler, empty + "  ", expand)

      | <[ () ]> => 
        printf ("()")

      | <[ null ]> => 
        printf ("null")

      | <[ $(val : int) ]> =>
        printf ("%d", val)

      | <[ $(val : string) ]> =>
        printf ("\"%s\"", val)

/*
      | <[ $(val : float) ]> =>
        printf ("%f", val)
*/

      | <[ $(val : bool) ]> =>
        if (val) printf ("true") else printf ("false")

      | <[ $(val : char) ]> =>
        printf ("%c", val);

      | <[ this ]> =>
        printf ("this")

      | <[ base ]> => 
        printf ("base")

      | <[ typeof ($t) ]> =>
        printf ("typeof ("); PrintType (t); printf (")")

      | <[ ( $expr :> $ty ) ]> =>
        printf ("("); PrintExpr (ctx, expr, empty, expand); printf (" :> ");
        PrintType (ty); printf (")")

      | <[ ( $expr : $ty ) ]> =>
        printf ("("); PrintExpr (ctx, expr, empty, expand); 
        printf (" : "); PrintType (ty); printf (")")

      | <[ {.. $seq } ]> =>
        printf ("{");
        List.Iter (fun (x) { printf ("\n%s", empty + "  "); 
                             PrintExpr (ctx, x, empty + "  ", expand); 
                             printf (";"); }, seq);
        printf ("\n%s}", empty)

      | <[ (.. $args) ]> =>
        printf ("(");
        List.Iter (fun (x) { printf (", "); 
                             PrintExpr (ctx, x, empty, expand) }, 
                   args);
        printf (")")

      | <[ array [.. $args] ]> =>
        printf ("array [");
        List.Iter (fun (x) { printf ("; "); 
                             PrintExpr (ctx, x, empty, expand) }, args);
        printf ("]")

      | <[ $obj [.. $args] ]> =>
        PrintExpr (ctx, obj, empty, expand);
        printf ("[");
        List.Iter (fun (x) { printf ("; "); PrintExpr (ctx, x, empty, expand) }, 
                   args);
        printf ("]")

//      | <[ 
      // FIXME: lambda, funs

      | _ => printf ("other")
    }
  }

  public PrintPattern (patt : Pattern) : void
  {
    match (patt) {
      | <[ pattern: _ ]> =>
        printf ("_")

      | <[ pattern: $(name : var) ]> =>
        printf ("%s", name)

      | <[ pattern: ($pat) as $(name : var) ]> => 
        printf ("("); PrintPattern (pat); 
        printf (") as %s", name)

      | <[ pattern: [] ]> => printf ("[]")

      | <[ pattern: $x :: $xs ]> => 
        PrintPattern (x); printf (" :: "); PrintPattern (xs)

      | <[ pattern: (.. $args) ]> =>
        printf ("(");
        List.Iter (fun (x) { PrintPattern (x); printf (", ") }, args);
        printf (")")

      | <[ pattern: {.. $args } ]> =>
        def print_named_pattern (patt : string * Pattern) : void
          {
            def (name, pat) = patt;
            printf ("%s = ", name); PrintPattern (pat);
            printf ("; ")
          };
        printf ("{");
        List.Iter (print_named_pattern, args);
        printf ("}")

      | <[ pattern: $(name : var) (.. []) ]> =>
        printf ("%s", name)

      | <[ pattern: $(name : var) (.. $args) ]> =>
        printf ("%s (", name);
        List.Iter (fun (x) { PrintPattern (x); printf (", ") }, args);
        printf (")");

      | <[ pattern: $(name : var) {.. $args} ]> =>
        printf ("%s {", name);
        def print_named_pattern (patt : string * Pattern) : void
          {
            def (name, pat) = patt;
            printf ("%s = ", name); PrintPattern (pat);
            printf ("; ")
          };
        List.Iter (print_named_pattern, args);
        printf ("}")

      | <[ pattern: $(val : int) ]> =>
        printf ("%d", val)

      | <[ pattern: $(val : string) ]> =>
        printf ("\"%s\"", val)

      | <[ pattern: $(val : bool) ]> =>
        if (val) printf ("true") else printf ("false")

/*
      | <[ pattern: $(val : float) ]> =>
        printf ("%f", val)
*/

      | <[ pattern: $(val : char) ]> =>
        printf ("%c", val)

      | <[ pattern: () ]> =>
        printf ("()")

      | <[ pattern: null ]> =>
        printf ("null")

      | <[ pattern: $(name : var) _ ]> =>
        printf ("%s", name)

      | _ => printf("other");
    }
  }

  public PrintType (ty : Type) : void 
  {
    match (ty) {
      | <[ type: $(tycon : var) (.. $args) ]> =>
        printf ("%s", tycon);
        def loop (l) {
          match (l) {
            | [x] => PrintType (x)
            | x::xs => PrintType (x); printf (" * "); loop (xs)
            | [] => Util.ice()
          }
        };
        match (args) {
          | [] => ()
          | _ => printf (" ("); loop (args); printf (")");
        }

      | <[ type: $(name : var) ]> =>
        printf ("%s", name);

      | <[ type: ref $ty ]> =>
        printf ("ref "); PrintType (ty);

      | <[ type: out $ty ]> =>
        printf ("out "); PrintType (ty);

      | <[ type: $from -> $to ]> =>
        PrintType (from); printf (" -> "); PrintType (to);

      | <[ type: void ]> =>
        printf ("void");

      | <[ type: .. $args ]> =>
        List.Iter (fun (x) { PrintType (x); printf (" * ") }, args)

      | <[ type: array ($ty) ]> =>
        printf ("array ("); PrintType (ty); printf (")")

      | _ => printf ("other")
    }
  }
}
} // end ns
