/*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace Nemerle.Compiler 
{
  using Nemerle.Compiler;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;
  using Nemerle.Collections;
  using Nemerle.Utility;
  
  using System.Reflection;
  using System.Reflection.Emit;

  namespace NC = Nemerle.Compiler;

  /**
   * An IL code generator
   */
  public class CGIL
  {
    /* -- PUBLIC CONSTRUCTORS ---------------------------------------------- */

    public this (target_exe : bool, output_file_name : string)
    {
      def basename (s : string) {
        def dot = s.LastIndexOf ('.');
        def s = if (dot == -1) s else s.Substring (0, dot);
        strip_directory (s)
      };
      
      _output_file_name = output_file_name;
    
      /* create a weak assembly name and define a dynamic assembly */
      this._assembly_name = System.Reflection.AssemblyName ();
      this._assembly_name.Version = System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name = basename (output_file_name);

      this._assembly_builder = 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      def attr = make_string_attribute (SystemType.Reflection_AssemblyConfigurationAttribute,
                                        "ContainsNemerleTypes");
      this._assembly_builder.SetCustomAttribute (attr);

      /* create a dynamic module */
      this._module_builder = 
        this._assembly_builder.DefineDynamicModule ("Module_" + basename (output_file_name), 
                                                    strip_directory (output_file_name), 
                                                    true); // FIXME

      when (target_exe) {
        _need_entry_point = true;
        _entry_point = None ();
      };

      _aux_types = [];
    }


    /**
     *
     */
    public EmitAuxDecls () : void
    {
      compile_all_tyinfos (true)
    }


    /**
     *
     */    
    public EmitDecls () : void
    {
      compile_all_tyinfos (false)
    }


    /**
     * Saves the constructed assembly to a file
     */
    public SaveAssembly () : void 
    {
      // set the entry point
      match ((_need_entry_point, _entry_point)) {
        | (true, Some (entry_point_method_info)) =>
          _assembly_builder.SetEntryPoint (entry_point_method_info,
                                           PEFileKinds.ConsoleApplication)
        | (true, None) =>
          Message.error ("no suitable entry point (Main function) found")
        | _ => ()
      };

      // save the assembly
      // we cannot save file with directory (see Save description)
      _assembly_builder.Save (strip_directory (_output_file_name));
      when (strip_directory (_output_file_name) != _output_file_name) {
        when (System.IO.File.Exists (_output_file_name))
          System.IO.File.Delete (_output_file_name);
          
        System.IO.File.Move (strip_directory (_output_file_name), _output_file_name)
      }
    }

    /**
     * Tell IL generator that we have created type instance elsewhere, and
     * it needs to get finalized before saving an assembly.
     */
    public RegisterAuxType (tb : Emit.TypeBuilder) : void
    {
      _aux_types = tb :: _aux_types;
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    private strip_directory (s : string) : string
    {
      def slash =
        if (s.LastIndexOf ('/') > s.LastIndexOf ('\\')) 
          s.LastIndexOf ('/')
        else
          s.LastIndexOf ('\\');
      s.Substring (slash + 1)
    }
    
    /**
     *
     */
    emit_implementation (ti : NC.TypeBuilder) : void
    {
      def emit_member (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod))
          | MK_property (p) =>
            compile_property (p)
          | MK_event (p) =>
            compile_event (p)
          | _ => ()
        }
      };
      List.Iter (ti.GetDirectMembers (), emit_member);
      //Message.debug ("finalizing " + ti.GetFullName ());
      unless (Message.seen_error ())
        ti.FinalizeType ();
      //Message.debug ("finalized " + ti.GetFullName ());
    }


    compile_property (prop : IProperty) : void
    {
      def builder = (prop.GetPropertyInfo () :> PropertyBuilder);
      when (prop.GetGetter () != null)
        builder.SetGetMethod ((prop.GetGetter ().GetMethodInfo () :> MethodBuilder));
      when (prop.GetSetter () != null)
        builder.SetSetMethod ((prop.GetSetter ().GetMethodInfo () :> MethodBuilder));
    }


    compile_event (prop : IEvent) : void
    {
      def builder = (prop :> NemerleEvent).event_builder;
      builder.SetAddOnMethod ((prop.GetAdder ().GetMethodInfo () :> MethodBuilder));
      builder.SetRemoveOnMethod ((prop.GetRemover ().GetMethodInfo () :> MethodBuilder));
    }


    finalize_aux_types () : void
    {
      unless (Message.seen_error ())
        List.Iter (_aux_types, fun (x : Emit.TypeBuilder) { 
          ignore (x.CreateType ()) 
        });
      _aux_types = [];
    }
    

    /**
     *
     */
    compile_all_tyinfos (aux_phase : bool) : void
    {
      def allow_it (ti : NC.TypeBuilder) {
        is_aux_decl (ti) == aux_phase 
      };
      def set_type_builder (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("make type builder for " + ti.GetFullName ());
          ti.ConstructTypeBuilder ();
          when (ti.Attributes %&& NemerleAttributes.Macro) {
            def attr = make_string_attribute (SystemType.ContainsMacroAttribute,
                                              ti.GetTypeBuilder ().FullName);
            _assembly_builder.SetCustomAttribute (attr);
          }
        }
      };
      def emit_decls (ti : NC.TypeBuilder) {
        when (allow_it (ti)) {
          //Message.debug ("generating declarations " + ti.GetFullName ());
          add_declarations (ti)
        }
      };
      def emit_impl_vt (ti : NC.TypeBuilder) {
        when (ti.IsValueType && allow_it (ti)) {
          //Message.debug ("generating code for " + ti.GetFullName ());
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };
      def emit_impl (ti : NC.TypeBuilder) {
        when (!ti.IsValueType && allow_it (ti)) {
          //Message.debug ("generating code for " + ti.GetFullName ());
          Passes.MarkTypeBuilderCompiled ();
          emit_implementation (ti)
        }
      };

      this._emit_nemerle_attributes = !aux_phase;

      when (!aux_phase) _cgil_phase = 1;
      NC.TypeBuilder.Iter (set_type_builder);
      
      when (!aux_phase) _cgil_phase = 2;
      NC.TypeBuilder.Iter (emit_decls);
      
      when (!aux_phase) _cgil_phase = 3;
      NC.TypeBuilder.Iter (emit_impl_vt);

      when (!aux_phase) _cgil_phase = 3;
      NC.TypeBuilder.Iter (emit_impl);

      Message.maybe_bailout ();
      
      when (!aux_phase) _cgil_phase = 4;
      finalize_aux_types ();
    }
    

    internal MemberAdded (ti : NC.TypeBuilder, mem : IMember) : void
    {
      when (_cgil_phase >= 1)
        ti.ConstructTypeBuilder ();

      when (_cgil_phase >= 2)
        add_declaration (ti, mem);

      when (_cgil_phase >= 3)
        match (mem.GetKind ()) {
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod));
          | _ => ()
        };

      when (_cgil_phase >= 4)
        finalize_aux_types ();
    }
    

    /**
     * Check if declaration is auxiliary, used internally etc.
     */
    private is_aux_decl (ti : NC.TypeBuilder) : bool
    {
      def tn = ti.GetFullName ();

      tn.StartsWith ("Nemerle.Internal.") ||
      tn == "Nemerle.Core.NullMatchException"
    }

    
    private make_string_attribute (attr_type : System.Type, value : string) : CustomAttributeBuilder
    {
      def constructor_param_types = array [SystemType.String];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      assert (constructor_info != null);
      def constructor_params = array [(value : object)];
      CustomAttributeBuilder (constructor_info, constructor_params)
    }


    private make_void_attribute (attr_type : System.Type) : CustomAttributeBuilder
    {
      def constructor_info = attr_type.GetConstructor (System.Type.EmptyTypes);
      CustomAttributeBuilder (constructor_info, array [])
    }
    
    
    /**
     * Builds a Nemerle type attribute
     */
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      make_string_attribute (SystemType.TypeAttribute, encoded_type)
    }


    /**
     * Builds a Nemerle variant attribute
     */
    private make_nemerle_variant_attribute (decls : list <Tycon>) : CustomAttributeBuilder
    {
      def names = List.Map (decls, Tyutil.FrameworkTypeName);
      make_string_attribute (SystemType.VariantAttribute,
                             NString.Concat (",", names))
    }
    

    /**
     * Builds a Nemerle type alias
     */
    private make_nemerle_type_alias_attribute (t : Type) : CustomAttributeBuilder
    {
      make_string_attribute (SystemType.TypeAliasAttribute, TyCodec.EncodeType (t))
    }
    

    /**
     * Builds a Nemerle variant option attribute
     */
    private make_nemerle_variant_option_attribute (is_const : bool) : CustomAttributeBuilder
    {
      make_void_attribute (if (is_const) 
                             SystemType.ConstantVariantOptionAttribute
                           else 
                             SystemType.VariantOptionAttribute)
    }


    private add_custom_attributes (ti : NC.TypeBuilder,
                                   attrs : list <Parsetree.Expr>,
                                   _macro_attrs : list <string * Parsetree.Expr>,   
                                   adder : CustomAttributeBuilder -> void) : void
    {
      List.Iter (attrs, fun (expr) {
        try {
          adder (AttributeCompiler.CompileAttribute (ti, expr))
        } catch {
          | _ : Recovery => ()
        }
      });
/*      
      List.Iter (macro_attrs, fun (mattribute) {
        def (suff, expr) = mattribute;
        try {
          def (m, parms) = 
            match (MacroRegistry.lookup_macro (ti.env, expr, suff)) {
              | Some ((_, m, parms)) => (m, parms)
              | _ => Util.ice ("macro is not a macro?" +
                               Macros.SprintExpr (None (), expr))
            };
          def sparms = List.Map (parms, fun (x) { Macros.SprintExpr (None (), x) });
          def concatenated = NString.Concat ("@", sparms);
          def serialized = <[ Nemerle.Internal.MacroAttribute ($(m.GetNamespace ()
                                                                 + m.GetName () : string),
                          $(concatenated : string)) ]>;
          adder (AttributeCompiler.CompileAttribute (ti, serialized))
        } catch {
          | _ : Recovery => ()
        }
      });
*/      
    }


    /**
     * Converts Nemerle property modifiers to the CLI property attributes.
     */
    private make_property_attributes (attrs : NemerleAttributes) : PropertyAttributes
    {
      when (attrs %&& (NemerleAttributes.Mutable %| 
                       NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro))
        Util.ice ("given modifier is not supported for properties");
      PropertyAttributes.None
    }


    /**
     * Converts Nemerle field modifiers to the CLI field attributes.
     */
    private make_field_attributes (attrs : NemerleAttributes) : FieldAttributes
    {
      mutable result = FieldAttributes.PrivateScope;
      when (attrs %&& NemerleAttributes.Public) result |= FieldAttributes.Public;
      when (attrs %&& NemerleAttributes.Private) result |= FieldAttributes.Private;
      when (attrs %&& NemerleAttributes.Protected) result |= FieldAttributes.Family;
      when (attrs %&& NemerleAttributes.Internal) result |= FieldAttributes.FamORAssem;
      when (attrs %&& NemerleAttributes.Static) result |= FieldAttributes.Static;
      when (attrs %&& (NemerleAttributes.Abstract %|
                       NemerleAttributes.Virtual %|
                       NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro %|
                       NemerleAttributes.Override))
        Util.ice ("given attribute is not supported for fields");
      result
    }


    /**
     * Converts Nemerle method modifiers to the CLI method attributes.
     */
    private make_method_attributes (attrs : NemerleAttributes) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;
      when (attrs %&& NemerleAttributes.Public) result |= MethodAttributes.Public;
      when (attrs %&& NemerleAttributes.Private) result |= MethodAttributes.Private;
      when (attrs %&& NemerleAttributes.Protected) result |= MethodAttributes.Family;
      when (attrs %&& NemerleAttributes.Internal) result |= MethodAttributes.FamORAssem;
      when (attrs %&& NemerleAttributes.Static) result |= MethodAttributes.Static;
      when (attrs %&& NemerleAttributes.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;
      when (attrs %&& NemerleAttributes.New) result |= MethodAttributes.NewSlot;
      when (attrs %&& NemerleAttributes.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;
      when (attrs %&& NemerleAttributes.Virtual) result |= MethodAttributes.Virtual;
      when (attrs %&& (NemerleAttributes.Sealed %|
                       NemerleAttributes.Struct %|
                       NemerleAttributes.Module %|
                       NemerleAttributes.Macro))
        Util.ice ("given attribute is not supported for methods");
      result
    }


    /**
     * Converts Nemerle method modifiers to the Framework type attributes.
     */
    private make_type_attributes (attrs : NemerleAttributes, is_nested : bool) : TypeAttributes
    {
      mutable result = TypeAttributes.AutoLayout;
      when (attrs %&& NemerleAttributes.Public)
        if (is_nested) result |= TypeAttributes.NestedPublic
        else result |= TypeAttributes.Public;
      when (attrs %&& NemerleAttributes.Private)
        if (is_nested) result |= TypeAttributes.NestedPrivate 
        else Message.error ("Private is not allowed for top level types");
      when (attrs %&& NemerleAttributes.Protected)
        if (is_nested) result |= TypeAttributes.NestedFamily 
        else Message.error ("Protected is not allowed for top level types");
      when (attrs %&& NemerleAttributes.Internal && is_nested)
        result |= TypeAttributes.NestedFamORAssem;
      when (attrs %&& NemerleAttributes.Abstract) result |= TypeAttributes.Abstract;
      when (attrs %&& NemerleAttributes.Sealed) result |= TypeAttributes.Sealed;
      when (attrs %&& (NemerleAttributes.Struct %|
                       NemerleAttributes.New %|
                       NemerleAttributes.Virtual %|
                       NemerleAttributes.Mutable %|                       
// FIXME: some bug in attributes produces this modifier
//                       NemerleAttributes.Static %|                 
                       NemerleAttributes.Override))
        Util.ice ("given attribute is not supported for methods");
      result
    }


    /**
     * Converts a System.Type list to a System.Type array.
     * FIXME: array <x> won't work here as the list's length is not know.
     */  
    internal type_list_to_type_array (x : list <System.Type>) : array <System.Type> 
    {
      Nemerle.Utility.NArray.FromList (typeof (System.Type), x)
    }


    /**
     * Reads the inheritance list of a class and retrieves the base
     * type and builds the array of interfaces implemented by the class.
     */
    private determine_inheritance (ti : NC.TypeBuilder) : (System.Type * array <System.Type>)
    {
      def is_interface (t : Tycon) {
        match (t.GetTydecl ()) {
          | TD_interface | TD_alias => true
          | _ => false
        }
      };
      
      match (ti.GetTydecl ()) {
        | TD_enum => (SystemType.Enum, array [])
        | _ => 
          def base_class_type =
            match (ti.GetDirectSuperTypes ()) {
              | T_app (base_class, _) :: _ when !is_interface (base_class) =>
                base_class.GetSystemType ()
              | _ when is_interface (ti) => null
              | _ => SystemType.Object
            };

          def ifaces_types = List.Map (ti.InterfacesToImplement (), 
                                       fun (tc : Tycon) { tc.GetSystemType () });
          
          (base_class_type, type_list_to_type_array (ifaces_types))
      }
    }
  
      
    /**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     */
    public ConstructTypeBuilder (tyinfo : NC.TypeBuilder) : Emit.TypeBuilder
    {      
      /* create optional custom attributes for this type */
      def custom_attribute =
        match (tyinfo.GetTydecl ()) {          
          | TD_variant (decls) => 
            make_nemerle_variant_attribute (decls)
          | TD_variant_option =>
            def has_co_ctor = Option.IsSome (tyinfo.GetConstantObject ());
            make_nemerle_variant_option_attribute (has_co_ctor)
          | TD_alias (t) =>
            make_nemerle_type_alias_attribute (t)
          | _ => null
        };

      /* decide the new type attributes */
      def is_nested = tyinfo.DeclaringType != null;
      mutable is_interface = false;
      
      def type_kind_attrs = 
        match (tyinfo.GetTydecl ()) { 
          | TD_class => TypeAttributes.Class
          | TD_alias // we pretend type alias is an interface
          | TD_interface => 
            is_interface = true;
            TypeAttributes.Interface %| TypeAttributes.Abstract
          | TD_variant => TypeAttributes.Class
          | TD_variant_option => TypeAttributes.Class
          | TD_enum =>
            TypeAttributes.Sealed %| TypeAttributes.Class
        };
        
      def attrs = make_type_attributes (tyinfo.Attributes, is_nested) %| type_kind_attrs;

      /* determine the inheritance relation for this type */
      def (extends_class, implements_interfaces) = determine_inheritance (tyinfo);

      /* create the type builder for a top-level or nested class declaration */
      def new_type_builder = 
        if (!is_nested)
          this._module_builder.DefineType (tyinfo.GetFullName (), attrs, 
                                           extends_class, implements_interfaces)
        else {
          def type_builder = (tyinfo.DeclaringType :> NC.TypeBuilder).GetTypeBuilder ();
          type_builder.DefineNestedType (tyinfo.Name, attrs, extends_class, 
                                         implements_interfaces)
        };

      when (custom_attribute != null && _emit_nemerle_attributes) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      new_type_builder
    }


    /**
     * Adds a an implicit parameterless constructor to a type builder
     */
    internal AddImplicitCtor (tb : Emit.TypeBuilder) : ConstructorBuilder
    {
      def constructor_builder = 
        tb.DefineDefaultConstructor (MethodAttributes.FamORAssem);

      constructor_builder
    }
    

    /**
     * Adds a constructor builder to a type builder
     */
    internal AddConstructorBuilder (cgm : CG_method, tb : Emit.TypeBuilder) : void
    {
      // Message.debug ("-- AddConstructorBuilder: " + tb.FullName + "." + cgm.name);

      /* build the parameter types array */      
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.Map (cgm.parms, mkparm);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      /* create the constructor builder */
      def constructor_builder =
        tb.DefineConstructor (make_method_attributes (cgm.modifiers),
                              CallingConventions.Standard, parm_types_array);
                              
      def name_parms (pos, parms) {
        match (parms) {
          | [] => ()
          | p :: ps =>
            ignore (constructor_builder.DefineParameter 
                        (pos, ParameterAttributes.None, (p : CG_val).name));
            name_parms (pos + 1, ps)
        }
      };
      name_parms (1, cgm.parms);

      cgm.constructor_builder = constructor_builder;
    }


    /**
     * Emits a constructor's body
     */
    internal EmitConstructor (cgm : CG_method) : void
    {
      def cb = cgm.constructor_builder;
      assign_parameter_indexes (cb.IsStatic, cgm);

      CGopt.Optimize (cgm);
      
      /* emit the constructor's body */
      def _ = CodeGenerator (cb, cgm);
      
      ()
    }


    /**
     * Adds a method builder to a type builder
     */
    internal AddMethodBuilder (cgm : CG_method, tb : Emit.TypeBuilder) : void
    {
      // Message.debug ("-- AddMethodBuilder: " + tb.FullName + "." + cgm.name);
      
      /* build the parameter types array */      
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.Map (cgm.parms, mkparm);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      /* update the modifiers list */
      def modifiers =
        if (cgm.implemented_methods == null) cgm.modifiers
        else
          match (cgm.implemented_methods) {
            | [] => cgm.modifiers
            | _ => NemerleAttributes.Virtual %| cgm.modifiers
          };

      def attrs = make_method_attributes (modifiers);
      def attrs =
        if (cgm.name == ".cctor")
          attrs %| MethodAttributes.RTSpecialName %| MethodAttributes.SpecialName
        else attrs;

      /* add the method to the type builder */
      def method_builder =
        tb.DefineMethod (cgm.name, attrs,
                         cgm.ret_type, parm_types_array);
                         
      def name_parms (pos, parms) {
        match (parms) {
          | [] => ()
          | p :: ps =>
            ignore (method_builder.DefineParameter 
                          (pos, ParameterAttributes.None, (p : CG_val).name));
            name_parms (pos + 1, ps)
        }
      };
      name_parms (1, cgm.parms);

      cgm.method_builder = method_builder;
    }


    /**
     * Emits a method's body
     */
    internal EmitMethod (cgm : CG_method) : void
    {
      def mb = cgm.method_builder;
      assign_parameter_indexes (mb.IsStatic, cgm);
      
      CGopt.Optimize (cgm);
      
      /* update the entry point settings, if necessary */
      when (_need_entry_point && cgm.name == "Main" && mb.IsStatic) {
        match (_entry_point) {
          | Some =>
            Message.error ("ambiguous match for entry point candidate in type " + 
                           mb.DeclaringType.FullName);
          | None =>
            _entry_point = Some ((mb : MethodInfo))
        }
      };
      
      /* update the overriding relationships */
      def type_builder = (mb.DeclaringType :> Emit.TypeBuilder);
      def method_info = (mb :> MethodInfo);
            
      def update_override (overridden : IMethod) : void {
        def overridden_info = overridden.GetMethodInfo ();
        
        //Message.debug ("override " + method_info.Name + " " + overridden_info.Name + " in " +
        //                type_builder.FullName);
        type_builder.DefineMethodOverride (method_info, overridden_info)
      };
      
      List.Iter (cgm.implemented_methods, update_override);
      
      /* emit the method body */
      def _ = CodeGenerator (mb, cgm);
      
      ()
    }


    /**
     * Adds a method and immediately emits it's body
     */
    internal AddMethod (cgm : CG_method, tb : Emit.TypeBuilder) : void
    {
      AddMethodBuilder (cgm, tb);
      EmitMethod (cgm);
    }


    /**
     * Adds a field builder
     */
    internal AddFieldBuilder (field : IField, tb : Emit.TypeBuilder) : FieldBuilder
    {
      def attrs = make_field_attributes (field.Attributes);
      def nemerle_field = (field :> NemerleField);
      def attrs =
        if (nemerle_field.enum_value != null)
          attrs %| FieldAttributes.Literal
        else
          attrs;
      def field_builder = 
        tb.DefineField (field.Name, 
                        CGexpr.cg_type (tb, field.GetMemType ()),
                        attrs);

      add_custom_attributes ((field.DeclaringType :> NC.TypeBuilder), 
                             field.GetCustomAttributes (),
                             field.GetMacroAttributes (),                             
                             fun (a) { field_builder.SetCustomAttribute (a) });
      
      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (field));
        field_builder.SetCustomAttribute (attr);
      };

      when (nemerle_field.enum_value != null) {
        //Message.debug ("setting value to " + nemerle_field.enum_value.ToString ());
        field_builder.SetConstant (nemerle_field.enum_value);
      };

      nemerle_field.field_builder = field_builder;
      field_builder
    }

    /**
     * Adds a property builder
     */
    internal AddPropertyBuilder (prop : IProperty, tb : Emit.TypeBuilder) : PropertyBuilder
    {
      def prop = (prop :> NemerleProperty);
      def parms = List.Map (prop.parms, fun (t) { CGexpr.cg_type (tb, t) });
      def parms = type_list_to_type_array (parms);
      def attrs = make_property_attributes (prop.Attributes);
      def ty = CGexpr.cg_type (tb, prop.GetMemType ());
      
      def prop_builder = tb.DefineProperty (prop.Name, attrs, ty, parms);

      add_custom_attributes ((prop.DeclaringType :> NC.TypeBuilder), 
                             prop.GetCustomAttributes (),
                             prop.GetMacroAttributes (),                             
                             fun (a) { prop_builder.SetCustomAttribute (a) });
      
      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (prop));
        prop_builder.SetCustomAttribute (attr);
      };

      prop.property_builder = prop_builder;
      prop_builder
    }

    /**
     * Adds an event builder
     */
    internal AddEventBuilder (the_event : IEvent, tb : Emit.TypeBuilder) : EventBuilder
    {
      def ty = CGexpr.cg_type (tb, the_event.GetMemType ());
      def event_builder =
        tb.DefineEvent (the_event.Name, EventAttributes.None, ty);

      add_custom_attributes ((the_event.DeclaringType :> NC.TypeBuilder), 
                             the_event.GetCustomAttributes (),
                             the_event.GetMacroAttributes (),
                             fun (a) { event_builder.SetCustomAttribute (a) });
      
      when (_emit_nemerle_attributes) {
        def attr = make_nemerle_type_attr (TyCodec.EncodeMemberType (the_event));
        event_builder.SetCustomAttribute (attr);
      };

      (the_event :> NemerleEvent).event_builder = event_builder;
      event_builder
    }

    add_declaration (ti : NC.TypeBuilder, m : IMember) : void
    {
      def type_builder = ti.GetTypeBuilder ();
      match (m.GetKind ()) {
        | MK_field (field) =>
          ignore (AddFieldBuilder (field, type_builder))
          
        | MK_event (ev) =>
          ignore (AddEventBuilder (ev, type_builder))
          
        | MK_property (p) =>
          ignore (AddPropertyBuilder (p, type_builder))
          
        | MK_method (m) when m.GetExternName () != null => () // skip extern methods
        
        | MK_method (m) =>
          def attr = 
            if (_emit_nemerle_attributes)
              make_nemerle_type_attr (TyCodec.EncodeMemberType (m))
            else
              null;
          match (m.GetFunKind ()) {
            | FK_ctor =>
              def cgm = CGexpr.GetCgMethod (m);
              AddConstructorBuilder (cgm, type_builder);
              def builder = cgm.constructor_builder;
              add_custom_attributes ((m.DeclaringType :> NC.TypeBuilder), 
                                     m.GetCustomAttributes (),
                                     m.GetMacroAttributes (),   
                                     fun (a) { builder.SetCustomAttribute (a) });
              when (_emit_nemerle_attributes)
                builder.SetCustomAttribute (attr);
              (m :> NemerleMethod).ctor_builder = builder
            | _ =>
              def cgm = CGexpr.GetCgMethod (m);
              AddMethodBuilder (cgm, type_builder);
              def builder = cgm.method_builder;
              when (_emit_nemerle_attributes)
                builder.SetCustomAttribute (attr);
              add_custom_attributes ((m.DeclaringType :> NC.TypeBuilder), 
                                     m.GetCustomAttributes (),
                                     m.GetMacroAttributes (),
                                     fun (a) { builder.SetCustomAttribute (a) });
              (m :> NemerleMethod).method_builder = builder
          }
          
        | MK_type => () // skip
      }
    }


    /**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     */    
    add_declarations (ti : NC.TypeBuilder) : void
    {    
      def type_builder = ti.GetTypeBuilder ();

      when (_emit_nemerle_attributes) {
        def tyattr = make_nemerle_type_attr (TyCodec.EncodeMemberType (ti));
        type_builder.SetCustomAttribute (tyattr);
      };
      add_custom_attributes (ti, ti.GetCustomAttributes (),
                             ti.GetMacroAttributes (),
                             fun (a) { type_builder.SetCustomAttribute (a) });

      def add_member (m) { add_declaration (ti, m) };
      
      List.Iter (ti.GetDirectMembers (), add_member)
    }


    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    private assign_parameter_indexes (is_static : bool, cgm : CG_method) : void
    {
      def walk_parms (index : int, parms : list <CG_val>) : void {        
        match (parms) {
          | parm :: rest => 
            parm.parm_index = Some (index);
            walk_parms (index + 1, rest)
          | [] => ()
        }
      };
      
      walk_parms (if (is_static) 0 else 1, cgm.parms)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _emit_nemerle_attributes : bool;
    private mutable _need_entry_point : bool;
    private mutable _entry_point : option <MethodInfo>;
    private mutable _output_file_name : string;
    private mutable _aux_types : list <Emit.TypeBuilder>;
    private mutable _cgil_phase : int;
  }



  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  internal class CodeGenerator
  {
    private mutable _cg_method : CG_method;
    private mutable _ilg : ILGenerator;

    private mutable _method_name : string;
    private mutable _method_is_static : bool;
    
    private mutable _method_start_label : Label;


    /**
     * Initialize some commonly used values
     */
    private init () : void
    {
    }


    /**
     * Creates and executes a code generator for a method
     */
    internal this (method_builder : MethodBuilder, cg_method : CG_method)
    {
      init ();
      
      _cg_method = cg_method;
      
      _ilg = method_builder.GetILGenerator ();
      
      _method_name = method_builder.DeclaringType.FullName + "::" + method_builder.Name;
      _method_is_static = method_builder.IsStatic;
      
      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      unless (emit (_cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }


    /**
     * Creates and executes a code generator for a method
     */
    internal this (constructor_builder : ConstructorBuilder, cg_method : CG_method)
    {
      init ();

      _cg_method = cg_method;
      
      _ilg = constructor_builder.GetILGenerator ();
      
      _method_name = constructor_builder.DeclaringType.FullName + "::"
                      + constructor_builder.Name;
      _method_is_static = constructor_builder.IsStatic;

      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      // -- HACK HACK HACK REMOVE ME REMOVE ME REMOVE ME HACK HACK HACK -- //
      unless (CodeGenerator.has_base_ctor_call (_cg_method.body) || _method_is_static) {
        def base_type = constructor_builder.DeclaringType.BaseType;
        assert (base_type != null);

        // Message.debug ("Adding base ctor implicit call: " + constructor_builder.DeclaringType.FullName + 
        //               ", base class: " + base_type.FullName);

        def base_ctor_info = 
          base_type.GetConstructor (BindingFlags.NonPublic %| BindingFlags.Public %| 
                                    BindingFlags.Instance, null, System.Type.EmptyTypes, null);

        when (base_ctor_info == null) {
          // FIXME -- this should be detected earlier
          Message.fatal_error ("cannot find default constructor in `" + base_type.FullName + 
                               "', please add explicit base(...) call")
//                    " ex " + pretty_print (_cg_method.body));
        };

        _ilg.Emit (OpCodes.Ldarg_0);
        _ilg.Emit (OpCodes.Call, base_ctor_info)
      };
      
      unless (emit (_cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }


    /**
     * This method checks if a given expression contains 
     * a call to a class' base constructor.
     */     
    private static has_base_ctor_call (expr : CG_expr) : bool 
    {        
      // -- HACK HACK HACK REMOVE ME REMOVE ME REMOVE ME HACK HACK HACK -- //
      | CE_sequence ([]) => false
      | CE_sequence (body) => List.Exists (body, has_base_ctor_call)
      | CE_tail_call (CE_base_ctor_ref (_), _)
      | CE_call (CE_base_ctor_ref (_), _) => true
      | CE_let (_, expr)
      | CE_cast (expr, _) => has_base_ctor_call (expr)
      | _ => false
    }

    private is_always_true (expr : CG_expr) : bool
    {
      match (expr) {
        | CE_literal (L_bool (true)) => true

        | CE_if (cond_expr, then_expr, else_expr) =>
          def cond_always_true = is_always_true (cond_expr);
          def cond_always_false = is_always_false (cond_expr);
          def then_always_true = is_always_true (then_expr);
          def else_always_true = is_always_true (else_expr);
          
          cond_always_true && then_always_true || 
          cond_always_false && else_always_true ||
          then_always_true && else_always_true

        | _ => false
      }
    }


    private is_always_false (expr : CG_expr) : bool
    {
      match (expr) {
        | CE_literal (L_bool (false)) => true

        | CE_if (cond_expr, then_expr, else_expr) =>
          def cond_always_true = is_always_true (cond_expr);
          def cond_always_false = is_always_false (cond_expr);
          def then_always_false = is_always_false (then_expr);
          def else_always_false = is_always_false (else_expr);
          
          cond_always_true && then_always_false || 
          cond_always_false && else_always_false ||
          then_always_false && else_always_false
        
        | _ => false
      }
    }


    /**
     * Check if named operator is defined in the class of the first parameter.
     */
    // FIXME: this shouldn't be needed anymore?
    private can_emit_operator (name : string, parms : list <CG_expr>) : bool
    {
      def parm_type = type_of (List.Head (parms));
      def ns = NString.Split (parm_type.FullName, array ['+', '.']);
      def tc = GlobalEnv.LookupInternalType (ns);
      match (tc.LookupMember (name)) {
        | [symbol] =>
          match (symbol.GetKind ()) {
            | MK_method (_) => true
            | _ => false
          }
        | _ => false
      }
    }



    underlaying_enum_type (t : System.Type) : System.Type
    {
      def res =
        NArray.Fold (t.GetFields (), null, fun (elt : System.Reflection.FieldInfo, acc) {
          if (!elt.IsStatic) {
            assert (acc == null);
            elt.FieldType
          } else
            acc
        });
      assert (res != null);
      res
    }


    /**
     * Emits an expression.
     */
    private emit (expr : CG_expr) : bool 
    {      
      //Message.debug ("emit: " + pretty_print (expr));

      match (expr) {
      
        /* -- SEQUENCING --------------------------------------------------- */

        /* emits a sequence of expressions */
        | CE_sequence (expr_seq) =>
          def emit_sequence (expr_seq : list <CG_expr>) : bool {
            match (expr_seq) {
              | [] => false
              | expr :: rest =>
                if (emit (expr)) true
                else emit_sequence (rest)
            }
          };

          emit_sequence (expr_seq)


        /* emits a local value definition */
        | CE_let (let_val, let_in) =>
          match (let_val.val) {
            | CE_none =>
              unless (is_system_void (let_val.ty)) {
                def _ = declare_val_local_slot (let_val); ()
              };

              emit (let_in)

            | _ =>
              if (emit (let_val.val)) true
              else {
                unless (is_system_void (let_val.ty)) {
                  def local_slot = declare_val_local_slot (let_val);
                  _ilg.Emit (OpCodes.Stloc, local_slot)
                };

                emit (let_in)
              }
          };


        /* ignores the results of a computation */
        | CE_ignore (expr) =>
          def cutoff = emit (expr);
          unless (cutoff)
            _ilg.Emit (OpCodes.Pop);            
          cutoff



        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction: special case for comparison ops */
        | CE_if (cond_expr, then_expr, else_expr) when
          is_comparison_opcode_call (cond_expr) =>
          match (cond_expr) {
            | CE_call (CE_opcode (opcode), parms) =>
              if (emit_call_parameters (parms)) true
              else {
                /* NOTE: the opcodes are swapped so that the 'then' expression
                         can be emitted before the 'else' expression */
                def opcode =
                  match (opcode) {
                    | "==" => OpCodes.Bne_Un
                    | "!=" => OpCodes.Beq
                    | "<.s" | "<.f" => OpCodes.Bge
                    | "<.u" => OpCodes.Bge_Un
                    | ">.s" | ">.f" => OpCodes.Ble
                    | ">.u" => OpCodes.Ble_Un
                    | "<=.s" | "<=.f" => OpCodes.Bgt
                    | "<=.u" => OpCodes.Bgt_Un
                    | ">=.s" | ">=.f" => OpCodes.Blt
                    | ">=.u" => OpCodes.Blt_Un
                    | _ => Util.ice ("invalid opcode '" + opcode +
                                     "' in optimized CE_if pattern")
                  };

                def label_condition_else = _ilg.DefineLabel ();
                def label_condition_fi = _ilg.DefineLabel ();

                _ilg.Emit (opcode, label_condition_else);
                
                def cutoff_then = emit (then_expr);
                unless (cutoff_then) { _ilg.Emit (OpCodes.Br, label_condition_fi) };

                _ilg.MarkLabel (label_condition_else);
                def cutoff_else = emit (else_expr);

                _ilg.MarkLabel (label_condition_fi);
                cutoff_then && cutoff_else
              }
                            
            | _ => Util.ice ("invalid instruction in optimized CE_if pattern: "
                             + pretty_print (expr))
          }

        /* emits the if/then/else construction, special case for constants */
        | CE_if (cond_expr, then_expr, _) when is_always_true (cond_expr) =>
          emit (then_expr)
          
        /* emits the if/then/else construction, special case for constants */
        | CE_if (cond_expr, _, else_expr) when is_always_false (cond_expr) =>
          emit (else_expr)

        /* emits the if/then/else construction */
        | CE_if (cond_expr, then_expr, else_expr) =>
          if (emit (cond_expr)) true
          else {
            def label_condition_else = _ilg.DefineLabel ();
            def label_condition_fi = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Brfalse, label_condition_else);
            
            def cutoff_then = emit (then_expr);
            unless (cutoff_then) { _ilg.Emit (OpCodes.Br, label_condition_fi) };

            _ilg.MarkLabel (label_condition_else);
            def cutoff_else = emit (else_expr);

            _ilg.MarkLabel (label_condition_fi);
            cutoff_then && cutoff_else
          }


        /* emit a type check construction */
        | CE_has_type (expr, ty) =>
          if (emit (expr)) true
          else {
            def label_condition_not_null = _ilg.DefineLabel ();
            def label_condition_has_type = _ilg.DefineLabel ();
            def label_condition_continue = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Dup);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);
            
            _ilg.ThrowException (SystemType.NullMatchException);

            _ilg.MarkLabel (label_condition_not_null);

            _ilg.Emit (OpCodes.Isinst, ty);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Br_S, label_condition_continue);
            _ilg.MarkLabel (label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.MarkLabel (label_condition_continue);
            false
          }


        /* emit a nullness check construction */
        | CE_not_null (expr) =>
          if (emit (expr)) true
          else {
            def label_condition_not_null = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);
            
            _ilg.ThrowException (SystemType.NullMatchException);

            _ilg.MarkLabel (label_condition_not_null);
            false
          }


        /* load runtime representation of given type */
        | CE_typeof (t) =>
          _ilg.Emit (OpCodes.Ldtoken, t);
          _ilg.Emit (OpCodes.Call, 
                     // FIXME: put in SystemType
                     SystemType.Type.GetMethod ("GetTypeFromHandle"));
          false

  
        /* emits the CE_switch instruction */
        | CE_switch (indexing_expr, default_expr, cases) =>
          match (cases) {
            | [] => 
              Message.warning ("empty CE_switch instruction");
              false
            | _ => 
              if (emit (indexing_expr)) true
              else emit_switch (default_expr, cases)
          }


        /* insert label so CE_continue_loop can work */
        | (CE_loop (expr, _)) as loop =>
          def label = _ilg.DefineLabel ();
          loop.label = Some (label);
          _ilg.MarkLabel (label);
          emit (expr)
          

        /* branch to loop beginning. */
        | CE_continue_loop (which) =>
          _ilg.Emit (OpCodes.Br, Option.UnSome (which.label));
          true


        /* -- TYPE CONVERSIONS --------------------------------------------- */

        /* do not perform casts between same types */
        | CE_cast (expr, cast_to_type) when type_eq (type_of (expr), cast_to_type) =>
          emit (expr)

        
        /* special case casts from void */
        | CE_cast (expr, cast_to_type) when type_of (expr).FullName == "System.Void" && 
                                            !cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            _ilg.Emit (OpCodes.Ldnull);
            false
          }
          
        
        /* box value types casted to non value types */
        | CE_cast (expr, cast_to_type) when type_of (expr).IsValueType
          && ! cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            _ilg.Emit (OpCodes.Box, type_of (expr));
            false            
          }


        /* unbox value types or perform value type conversion */          
        | CE_cast (expr, cast_to_type) when cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            def type_of_expr = type_of (expr);

            if (type_of_expr.IsValueType) {
              /* perform conversion of value types */
              emit_value_type_conversion (type_of_expr, cast_to_type)
            }
            else if (is_system_object (type_of_expr) || type_of_expr.IsInterface) {
              /* unboxing returns a pointer to a value */
              _ilg.Emit (OpCodes.Unbox, cast_to_type);
              emit_ldind_for_value_type (cast_to_type)
            }
            else {
              Util.ice (_method_name + ": failed to convert non-value type "
                        + type_of_expr.FullName + " to a value type "
                        + cast_to_type.FullName)
            };
            
            false
          }
          

        /* upcast / downcast non-value types */
        | CE_cast (expr, cast_to_type) =>
          if (emit (expr)) true
          else {
            /* upcasting / downcasting */
            _ilg.Emit (OpCodes.Castclass, cast_to_type);
            false
          }



        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | CE_ref (decl) => 
          match (decl.local_slot) {
            | Some (local_slot) => _ilg.Emit (OpCodes.Ldloc, local_slot)
            | _ => 
              match (decl.parm_index) {
                | Some (parm_index) => emit_ldarg (parm_index)
                | _ when decl.ty.FullName == "System.Void" => ()
                | _ =>
                  Util.ice (_method_name + ": parameter index / variable local"
                            " slot undefined in CE_ref " + decl.name)
              }
          };
          false
        

        /* load the value of a field */
        | CE_field_ref (base_object, field) =>
          if (emit (base_object)) true
          else {
            _ilg.Emit (OpCodes.Ldfld, field);
            false
          }


        /* load the value of a static field */
        | CE_global_ref (mi) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");
            
          if (field_info.IsLiteral) {
            // should not happen
            Message.warning ("loading literal as field `" + field_info.ToString () + "'");
          }
          else _ilg.Emit (OpCodes.Ldsfld, field_info);
          false


        /* load an array element */
        | CE_array_indexer (array_obj, [index]) =>
          if (emit (array_obj)) true
          else {          
            if (emit (index)) true
            else {
              def element_type = type_of (array_obj).GetElementType ();
              assert (element_type != null, "non-array in CE_array_indexer");
              
              emit_array_load_opcode (element_type);
              false
            }
          }
        
        | CE_array_indexer => 
          Util.ice (_method_name + ": multidimensional arrays should be"
                    " accessed by means of properties")


        /* -- ASSIGNMENTS -------------------------------------------------- */

        /* FIXME */
        | CE_assign (CE_cast (expr, _), val) =>
          // Message.debug ("FIXME: warning, working around the CE_cast () = val bug");
          emit (CE_assign (expr, val))


        /* assignment to a local variable */
        | CE_assign (CE_ref (local_var), val) =>
          match (local_var.local_slot) {
            | Some (local_slot) =>
              if (emit (val)) true
              else {
                _ilg.Emit (OpCodes.Stloc, local_slot);
                false
              }
            | _ =>
              Util.ice (_method_name + ": null local slot in CE_assign (CE_ref + "
                        + local_var.name + ")")
          };


        /* assignment to a field */
        | CE_assign (CE_field_ref (base_object, field), val) =>
          if (emit (base_object)) true
          else if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stfld, field);
            false
          }


        /* assignment to a static field */
        | CE_assign (CE_global_ref (mi), val) when member_is_field (mi) =>
          if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stsfld, (mi :> FieldInfo));
            false
          }


        /* assignment to an array element */
        | CE_assign (CE_array_indexer (array_obj, [index]), val) =>
          def type_of_val = type_of (val);
          
          if (emit (array_obj)) true
          else if (emit (index)) true
          else {
            when (type_of_val.IsValueType && !is_known_primitive_value_type (type_of_val))
              _ilg.Emit (OpCodes.Ldelema, type_of_val);
          
            if (emit (val)) true
            else {
              emit_array_store_opcode (type_of_val);
              false
            }
          }
                  
        | CE_assign (CE_array_indexer, _) => 
          Util.ice (_method_name + ": multidimensional arrays should be"
                    " accessed by means of properties")

          
        | CE_multiple_assign (assigns) =>
          def emit_values (lst) {
            | (_, v) :: xs =>
              if (emit (v)) {
                Message.warning ("argument broke control flow");
                true
              } else
                emit_values (xs)
            | [] => false
          };
          def emit_store (local_var : CG_val, _) {
            match (local_var.local_slot) {
              | Some (local_slot) =>
                _ilg.Emit (OpCodes.Stloc, local_slot);
              | _ =>
                Util.ice (_method_name + ": null local slot in CE_multiple_assign")
            }
          };
          if (emit_values (assigns))
            true
          else {
            List.Iter (List.Rev (assigns), emit_store);
            false
          }
            


        /* -- CALLS -------------------------------------------------------- */

        /* call the base constructor */
        | CE_tail_call (CE_base_ctor_ref (base_ctor), ctor_params)
        | CE_call (CE_base_ctor_ref (base_ctor), ctor_params) =>          
          _ilg.Emit (OpCodes.Ldarg_0);

          if (emit_call_parameters (ctor_params)) true
          else {
            _ilg.Emit (OpCodes.Call, base_ctor);
            false
          }


        /* create a new object */
        | CE_tail_call (CE_ctor_ref (ctor), ctor_params)
        | CE_call (CE_ctor_ref (ctor), ctor_params) =>
          if (emit_call_parameters (ctor_params)) true
          else {            
            _ilg.Emit (OpCodes.Newobj, ctor);
            false
          }
          

        /* emit a call to an instance method, basing on an instance field's contents */
        | CE_tail_call (CE_method_ref (CE_field_ref (base_object, field),
                                       method), method_params)
        | CE_call (CE_method_ref (CE_field_ref (base_object, field), method),
                   method_params) => 
          if (emit (base_object)) true
          else {
            def base_is_value_type = field.FieldType.IsValueType;
              
            if (base_is_value_type)
              _ilg.Emit (OpCodes.Ldflda, field)
            else
              _ilg.Emit (OpCodes.Ldfld, field);

            if (emit_call_parameters (method_params)) true
            else
              emit_method_call (expr, base_is_value_type, method)
          }


        /* emit a call to an instance method, basing on a static field's contents */
        | CE_tail_call (CE_method_ref (CE_global_ref (mi), method),
                        method_params) when member_is_field (mi)
        | CE_call (CE_method_ref (CE_global_ref (mi), method),
                   method_params) when member_is_field (mi) => 
          def field_info = (mi :> FieldInfo);          

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");
                    
          def base_is_value_type = field_info.FieldType.IsValueType;
              
          if (base_is_value_type)
            _ilg.Emit (OpCodes.Ldsflda, field_info)
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, base_is_value_type, method);



        /* emit a call to an instance method, basing on a local variable */
        | CE_tail_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method), method_params)
        | CE_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method), method_params) =>
          def base_is_value_type = decl.ty.IsValueType;
          
          if (base_is_value_type) {
            match (decl.local_slot) {
              | Some (local_slot) => _ilg.Emit (OpCodes.Ldloca, local_slot)
              | _ => 
                match (decl.parm_index) {
                  | Some (parm_index) => emit_ldarga (parm_index)
                  | _ => Util.ice (_method_name +
                                   ": null local slot or no parameter index " +
                                   "in CE_call (CE_method_ref (CE_ref + " +
                                   decl.name + "))")
                }
            }
          }
          else {
            def _ = emit (decl_ref); ()
          };
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, base_is_value_type, method)


        /* emit a call to an instance method */
        | CE_tail_call (CE_method_ref (base_object, method), method_params)
        | CE_call (CE_method_ref (base_object, method), method_params) => 
          if (emit (base_object)) true
          else {
            def is_value_type = type_of (base_object).IsValueType;
            when (is_value_type) {
              def local_slot = _ilg.DeclareLocal (type_of (base_object));
              _ilg.Emit (OpCodes.Stloc, local_slot);
              _ilg.Emit (OpCodes.Ldloca, local_slot);
            };
            if (emit_call_parameters (method_params)) true
            else
              emit_method_call (expr, is_value_type, method)
          }


        /* emit a call to a static method */
        | CE_tail_call (CE_global_ref (mi), method_parms) when member_is_method (mi)
        | CE_call (CE_global_ref (mi), method_parms) when member_is_method (mi) =>
          def method_info = (mi :> MethodInfo);

          assert (method_info.IsStatic, "CE_call CE_global_ref to a non-static field");
                              
          if (emit_call_parameters (method_parms)) true
          else
            emit_method_call (expr, true, method_info)


        /* emit an operator */
        | CE_tail_call (CE_opcode (opcode), parms)
        | CE_call (CE_opcode (opcode), parms) =>
          if (emit_call_parameters (parms)) true
          else {
            match (opcode) {
              // FIXME: add the checked/unchecked flags
              // FIXME: handle the overloaded operators properly
              //        (see == and != for System.String)
              | "+.s" =>  _ilg.Emit (OpCodes.Add_Ovf)
              | "+.u" => _ilg.Emit (OpCodes.Add_Ovf_Un)
              | "+.f" =>  _ilg.Emit (OpCodes.Add)
              
              | "<<.s" | "<<.u" =>  _ilg.Emit (OpCodes.Shl)
              | ">>.s" =>  _ilg.Emit (OpCodes.Shr)
              | ">>.u" =>  _ilg.Emit (OpCodes.Shr_Un)
              
              | "unary.+.s" | "unary.+.u" | "unary.+.f" => ()

              | "-.s" =>  _ilg.Emit (OpCodes.Sub_Ovf)
              | "-.u" => _ilg.Emit (OpCodes.Sub_Ovf_Un)
              | "-.f" =>  _ilg.Emit (OpCodes.Sub)
              
              | "unary.-.s" =>
                _ilg.Emit (OpCodes.Ldc_I4_M1);
                emit_value_type_conversion (SystemType.Int32,
                                            type_of (List.Hd (parms)));
                _ilg.Emit (OpCodes.Mul_Ovf)
              | "unary.-.f" =>
                _ilg.Emit (OpCodes.Neg)

              | "*.s" =>  _ilg.Emit (OpCodes.Mul_Ovf)
              | "*.u" => _ilg.Emit (OpCodes.Mul_Ovf_Un)
              | "*.f" =>  _ilg.Emit (OpCodes.Mul)
              
              | "/.s" | "/.f" =>  _ilg.Emit (OpCodes.Div)
              | "/.u" => _ilg.Emit (OpCodes.Div_Un)
              | "%.s" | "%.f" =>  _ilg.Emit (OpCodes.Rem)
              | "%.u" => _ilg.Emit (OpCodes.Rem_Un)
              
              | "|.s" | "|.u" => _ilg.Emit (OpCodes.Or);
              | "&.s" | "&.u" => _ilg.Emit (OpCodes.And);
              | "^.s" | "^.u" => _ilg.Emit (OpCodes.Xor);
              | "bool.!" =>
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq)
              | "==" =>
                _ilg.Emit (OpCodes.Ceq);
              | "!=" => 
                _ilg.Emit (OpCodes.Ceq);
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq);
              | "<.s" | "<.f" => emit_compare (OpCodes.Blt_S)
              | "<.u" => emit_compare (OpCodes.Blt_Un_S)
              | ">.s" | ">.f" => emit_compare (OpCodes.Bgt_S)
              | ">.u" => emit_compare (OpCodes.Bgt_Un_S)
              | "<=.s" | "<=.f" => emit_compare (OpCodes.Ble_S)
              | "<=.u" => emit_compare (OpCodes.Ble_Un_S)
              | ">=.s" | ">=.f" => emit_compare (OpCodes.Bge_S)
              | ">=.u" => emit_compare (OpCodes.Bge_Un_S)
              | _ =>
                Util.ice (_method_name + ": unmatched CE_opcode (" + opcode + ")")
            };
            false
          }

        /* emit self tail call -- that is jump to method start */
        | CE_self_tail_call (method_params) =>
          if (emit_call_parameters (method_params)) true
          else {
            def store_argument (cgv : CG_val) {
              match (cgv.parm_index) {
                | Some (index) =>
                  if (index < 256)
                    _ilg.Emit (OpCodes.Starg_S, (index :> System.Byte))
                  else
                    _ilg.Emit (OpCodes.Starg, index);
                | None => Util.ice ()
              }
            };
            List.Iter (List.Rev (_cg_method.parms), store_argument);
            _ilg.Emit (OpCodes.Br, _method_start_label);
            true
          }


        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | CE_raise (exc) =>
          if (emit (exc)) true
          else {
            _ilg.Emit (OpCodes.Throw);
            true
          }


        /* emit the try/with construction */
        | CE_try_with (try_expr, catch_val, catch_expr) =>
          def type_of_try_expr = type_of (expr);
               
          def ignore_try_with_result = is_system_void (type_of_try_expr);
          mutable try_result = null;
                             
          unless (ignore_try_with_result)
            try_result = _ilg.DeclareLocal (type_of_try_expr);

          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff_on_try = emit (try_expr);
          
          unless (cutoff_on_try || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);
          
          _ilg.BeginCatchBlock (catch_val.ty);

          def catch_val_local_slot = declare_val_local_slot (catch_val);
          _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);
          
          def cutoff_on_catch = emit (catch_expr);
          
          unless (cutoff_on_catch || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);
                    
          _ilg.EndExceptionBlock ();
          
          def cutoff = cutoff_on_try && cutoff_on_catch;
          
          unless (cutoff || ignore_try_with_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        // FIXME: how does finally work? what about storing it's result in
        //        try_result as in CE_try_with?
        | CE_try_finally (try_expr, finally_expr) =>
          def type_of_try_expr = type_of (try_expr);

          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff = emit (try_expr);

          def ignore_try_result = cutoff || is_system_void (type_of_try_expr);
          mutable try_result = null;

          unless (ignore_try_result) {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          def _ = emit (finally_expr);

          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | CE_this =>
          assert (!_method_is_static, "CE_this is a static method");

          _ilg.Emit (OpCodes.Ldarg_0);
          false


        /* loads a literal on the evaluation stack */
        | CE_literal (l) =>
          emit_literal (l);
          false


        /* loads address of given method */
        | CE_method_addr (meth) =>
          _ilg.Emit (OpCodes.Ldftn, meth);
          false


        /* creates a new array, given a list of initializers */
        | CE_mkarray (element_type, initializers) =>
          def local_slot = _ilg.DeclareLocal (type_of (expr));
                    
          _ilg.Emit (OpCodes.Ldc_I4, List.Length (initializers));
          _ilg.Emit (OpCodes.Newarr, element_type);

          _ilg.Emit (OpCodes.Stloc, local_slot);

          def load_elements (index : int, elements : list <CG_expr>) : bool {
            match (elements) {
              | [] => false
              | element :: rest =>
                _ilg.Emit (OpCodes.Ldloc, local_slot);
                _ilg.Emit (OpCodes.Ldc_I4, index);
                
                when (element_type.IsValueType &&
                      !is_known_primitive_value_type (element_type))
                  _ilg.Emit (OpCodes.Ldelema, element_type);
                  
                if (emit (element)) true
                else {
                  emit_array_store_opcode (element_type);
                  load_elements (index + 1, rest)
                }
            }
          };

          def cutoff = load_elements (0, initializers);          
          unless (cutoff) _ilg.Emit (OpCodes.Ldloc, local_slot);          
          cutoff
        
        
        /* an interrupting NOP instruction */
        | CE_none => false

        | _ =>
          Message.warning ("FIXME: unmatched: " + pretty_print (expr));
          false
      }
    }

    
    /**
     * Emits the CE_switch instruction
     * 
     * Asserts that the smallest of the case indices is positive. Quietly 
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never 
     * generate too long switch instructions -- assuring this should belong 
     * to a higher level logic.
     */
    private emit_switch (default_expr : option <CG_expr>, 
                         cases : list <int * CG_expr>) : bool
    { 
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr) {
          | Some => label_default
          | None => label_next_instruction
        };
               
      // step one: sort the cases increasingly
      def compare_cases (l : int * CG_expr, r : int * CG_expr) : int {
        def (l, _) = l; def (r, _) = r; r - l
      };
      
      def cases = List.Sort (cases, compare_cases);
      def (first_index, _) = List.Head (cases);

      // step two: rescale, so that the first label has value zero
      when (first_index != 0) {
        // NOTE: see the assumptions in the method description
        emit_literal (L_int (first_index));
        _ilg.Emit (OpCodes.Sub_Ovf)
      };

      // step three: generate the jump labels for the switch cases      
      mutable reversed_labels = [];
      
      def make_labels (index : int, cases : list <int * CG_expr>) 
                                        : list <Label * CG_expr> {
        match (cases) {
          | (case_index, case_expr) :: rest =>
            assert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;
            
              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)            
            }            
          | [] => []
        }
      };
            
      def labeled_cases = make_labels (first_index, cases);
      def labels = List.Rev (reversed_labels);

      def labels_array = label_list_to_array (labels);
     
      // step four: emit the switch instruction and the default expression
      mutable switch_cutoff = true;
                        
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr) {
        | Some (default_expr) =>
          unless (emit (default_expr)) {
            _ilg.Emit (OpCodes.Br, label_next_instruction);
            switch_cutoff = false
          }
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
          switch_cutoff = false
      };

      // step five: emit the switch cases
      def walk_cases (cases : list <Label * CG_expr>) : void {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          unless (emit (expr)) {
            switch_cutoff = false;
            _ilg.Emit (OpCodes.Br, label_next_instruction)
          };
          walk_cases (rest)
        | [] => ()
      };

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      unless (switch_cutoff)
        _ilg.MarkLabel (label_next_instruction);
      switch_cutoff
    }
     

    /**
     * Check if a given expression is a call to an opcode
     */
    private is_comparison_opcode_call (expr : CG_expr) : bool
    {
      def is_comparison_opcode (opcode : string) : bool {
        | ">.s" | ">.f" | ">.u"
        | "<.s" | "<.f" | "<.u"
        | ">=.s" | ">=.f" | ">=.u"
        | "<=.s" | "<=.f" | "<=.u" => true
        | _ => false
      };
      match (expr) {
        | CE_call (CE_opcode ("=="), parms) 
          when !can_emit_operator ("op_Equality", parms) => true
        | CE_call (CE_opcode ("!="), parms) 
          when !can_emit_operator ("op_Inequality", parms) => true
        | CE_call (CE_opcode (opcode), _)
          when is_comparison_opcode (opcode) => true
        | _ => false
      }      
    }


    /**
     * Checks two types for equality
     */
    private type_eq (l : System.Type, r : System.Type) : bool
    {
      l.Equals (r)
    }


    /**
     * Checks if a type is the System.Object type
     */
    private is_system_object (ty : System.Type) : bool
    {
      SystemType.Object.Equals (ty)
    }


    /**
     * Checks if a type is the System.Void type
     */
    private is_system_void (ty : System.Type) : bool
    {
      SystemType.Void.Equals (ty)
    }


    /**
     * Checks if a type is an enumeration type
     */
    private is_subclass_of_system_enum (ty : System.Type) : bool
    {
      ty.IsEnum
    }


    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (index : int) : void
    {
      | 0 => _ilg.Emit (OpCodes.Ldarg_0)
      | 1 => _ilg.Emit (OpCodes.Ldarg_1)
      | 2 => _ilg.Emit (OpCodes.Ldarg_2)
      | 3 => _ilg.Emit (OpCodes.Ldarg_3)
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarg, index)
    }


    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (index : int) : void
    {
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarga, index)
    }


    /**
     * Performs value type conversion
     */
    private emit_value_type_conversion (l : System.Type, r : System.Type) : void
    {
      def is_unsigned (t : System.Type) {
        match (t.FullName) {
          | "System.UInt32"
          | "System.UInt64"
          | "System.UInt16"
          | "System.Byte" 
          | "System.Char" => true
          | _ => false
        }
      };
      def is_number (t : System.Type) {
        match (t.FullName) {
          | _ when is_unsigned (t) => true
          | "System.Int32"
          | "System.Int64"
          | "System.Int16"
          | "System.SByte" 
          | "System.Single"
          | "System.Double" => true
          | _ => false
        }
      };
      def fail () {
        Message.warning ("failed to emit value type conversion from " + 
                         l.FullName + " to " + r.FullName)
      };

      if (r.FullName == l.FullName)
        ()
      else if (is_number (l) || is_subclass_of_system_enum (l)) {
        def rname =
          if (is_subclass_of_system_enum (r)) "System.Int32"
          else r.FullName;
        def opcode =
          match (rname) {
            | "System.Int64" when is_unsigned (l) => OpCodes.Conv_Ovf_I8_Un
            | "System.Int64" => OpCodes.Conv_I8 // Conv_Ovf_I8 is broken in mono
            | "System.Int32" when is_unsigned (l) => OpCodes.Conv_Ovf_I4_Un
            | "System.Int32" => OpCodes.Conv_Ovf_I4
            | "System.Int16" when is_unsigned (l) => OpCodes.Conv_Ovf_I2_Un
            | "System.Int16" => OpCodes.Conv_Ovf_I2
            | "System.SByte" when is_unsigned (l) => OpCodes.Conv_Ovf_I1_Un
            | "System.SByte" => OpCodes.Conv_Ovf_I1
            | "System.UInt64" when is_unsigned (l) => OpCodes.Conv_Ovf_U8_Un
            | "System.UInt64" => OpCodes.Conv_Ovf_U8
            | "System.UInt32" when is_unsigned (l) => OpCodes.Conv_Ovf_U4_Un
            | "System.UInt32" => OpCodes.Conv_Ovf_U4
            | "System.UInt16" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
            | "System.UInt16" => OpCodes.Conv_Ovf_U2
            | "System.Byte" when is_unsigned (l) => OpCodes.Conv_Ovf_U1_Un
            | "System.Byte" => OpCodes.Conv_Ovf_U1
            | "System.Char" when is_unsigned (l) => OpCodes.Conv_Ovf_U2_Un
            | "System.Char" => OpCodes.Conv_Ovf_U2
            
            | "System.Single" when is_unsigned (l) => OpCodes.Conv_R_Un
            | "System.Single" => OpCodes.Conv_R4
            // there is no OpCodes.Conv_R8_Un
            | "System.Double" when !is_unsigned (l) => OpCodes.Conv_R8

            | _ => fail (); OpCodes.Nop
          };
        _ilg.Emit (opcode)
      } else {
        fail ()
      }
    }
    
    
    /**
     * Checks if a given member info describes a field
     */
    private member_is_field (mi : MemberInfo) : bool
    {
      mi.MemberType == System.Reflection.MemberTypes.Field    
    }


    /**
     * Checks if a given member info describes a method
     */
    private member_is_method (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Method
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier and return true (cutoff).
     */
    private emit_method_call (expr : CG_expr, 
                              base_is_value_type_or_static : bool, 
                              method : MethodInfo) : bool
    {
      def is_tail =
        match (expr) {
          | CE_tail_call when Flags.general_tail_call_opt =>
            _ilg.Emit (OpCodes.Tailcall); 
            true
          | _ => false
        };
        
      if (base_is_value_type_or_static)
        _ilg.Emit (OpCodes.Call, method)
      else
        _ilg.Emit (OpCodes.Callvirt, method);

      if (is_tail) {
        _ilg.Emit (OpCodes.Ret);
        true
      } else false
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : CG_val) : LocalBuilder 
    {    
      def local_slot = _ilg.DeclareLocal (val.ty);
      local_slot.SetLocalSymInfo (val.name);
      val.local_slot = Some (local_slot);
      local_slot
    }


    /**
     * Checks if a given value type is a known primitive
     */
    private is_known_primitive_value_type (ty : System.Type) : bool
    {
      def tn = ty.FullName;

      tn == "System.SByte" || tn == "System.Boolean" || tn == "System.Byte" ||
      tn == "System.Char" || tn == "System.Int16" || tn == "System.UInt16" ||
      tn == "System.Int32" || tn == "System.UInt32" || tn == "System.Int64" || 
      tn == "System.UInt64" || tn == "System.Single" || tn == "System.Double"
    }


    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     */
    private emit_array_store_opcode (ty : System.Type) : void
    {
      assert (!is_system_void (ty), "tried to store a System.Void in an array");

      def tn = ty.FullName;

      if (tn == "System.SByte" || tn == "System.Boolean")
        _ilg.Emit (OpCodes.Stelem_I1)
      else if (tn == "System.Byte") _ilg.Emit (OpCodes.Stelem_I1)
      else if (tn == "System.Char" || tn == "System.Int16")
        _ilg.Emit (OpCodes.Stelem_I2)
      else if (tn == "System.UInt16") _ilg.Emit (OpCodes.Stelem_I2)
      else if (tn == "System.Int32") _ilg.Emit (OpCodes.Stelem_I4)
      else if (tn == "System.UInt32") _ilg.Emit (OpCodes.Stelem_I4)
      else if (tn == "System.Int64" || tn == "System.UInt64")
        _ilg.Emit (OpCodes.Stelem_I8)
      else if (tn == "System.Single") _ilg.Emit (OpCodes.Stelem_R4)
      else if (tn == "System.Double") _ilg.Emit (OpCodes.Stelem_R8)
      else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
      else _ilg.Emit (OpCodes.Stelem_Ref);
    }


    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : System.Type) : void
    {
      assert (!is_system_void (ty), "tried to load a System.Void from an array");
      
      def tn = ty.FullName;
      
      def opcode =
        if (tn == "System.SByte" || tn == "System.Boolean") OpCodes.Ldelem_I1
        else if (tn == "System.Byte") OpCodes.Ldelem_U1
        else if (tn == "System.Char" || tn == "System.Int16") OpCodes.Ldelem_I2
        else if (tn == "System.UInt16") OpCodes.Ldelem_U2
        else if (tn == "System.Int32") OpCodes.Ldelem_I4
        else if (tn == "System.UInt32") OpCodes.Ldelem_U4
        else if (tn == "System.Int64" || tn == "System.UInt64") OpCodes.Ldelem_I8
        else if (tn == "System.Single") OpCodes.Ldelem_R4
        else if (tn == "System.Double") OpCodes.Ldelem_R8
        else OpCodes.Ldelem_Ref;
        
      _ilg.Emit (opcode)          
    }
    
   

    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : System.Type) : void
    {
      if (ty.IsEnum || !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldobj, ty)
      }
      else {
        def tn = ty.FullName;
      
        def opcode =
          if (tn == "System.SByte" || tn == "System.Boolean")
            OpCodes.Ldind_I1
          else if (tn == "System.Byte")
            OpCodes.Ldind_U1
          else if (tn == "System.Char" || tn == "System.Int16")
            OpCodes.Ldind_I2
          else if (tn == "System.UInt16")
            OpCodes.Ldind_U2
          else if (tn == "System.Int32")
            OpCodes.Ldind_I4
          else if (tn == "System.UInt32")
            OpCodes.Ldind_U4
          else if (tn == "System.Int64")
            OpCodes.Ldind_I8
          else if (tn == "System.UInt64")
            OpCodes.Ldind_I8            
          else if (tn == "System.Single")
            OpCodes.Ldind_R4
          else if (tn == "System.Double")
            OpCodes.Ldind_R8
          else
            Util.ice (_method_name + ": not a recognized value type: " + tn);
            
        _ilg.Emit (opcode)
      }
    }


    /**
     * Emits a literal
     */
    private emit_literal (l : Literal) : void
    {
      match (l) {
        | L_void => ()
        | L_null => 
          _ilg.Emit (OpCodes.Ldnull)

        | L_int (-1) => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | L_int (0) => _ilg.Emit (OpCodes.Ldc_I4_0)
        | L_int (1) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_int (2) => _ilg.Emit (OpCodes.Ldc_I4_2)
        | L_int (3) => _ilg.Emit (OpCodes.Ldc_I4_3)
        | L_int (4) => _ilg.Emit (OpCodes.Ldc_I4_4)
        | L_int (5) => _ilg.Emit (OpCodes.Ldc_I4_5)
        | L_int (6) => _ilg.Emit (OpCodes.Ldc_I4_6)
        | L_int (7) => _ilg.Emit (OpCodes.Ldc_I4_7)
        | L_int (8) => _ilg.Emit (OpCodes.Ldc_I4_8)
        | L_int (k) when (k >= -128 && k <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, (k :> System.SByte))

        | L_byte (k) => _ilg.Emit (OpCodes.Ldc_I4_S, k)

        | L_int (k) => _ilg.Emit (OpCodes.Ldc_I4, k)

        | L_uint (k) => 
          // FIXME: need the checked/unchecked to implement this correctly
          _ilg.Emit (OpCodes.Ldc_I8, (k :> long));
          _ilg.Emit (OpCodes.Conv_U4)
          
        | L_short (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
        | L_ushort (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int)) 
        | L_sbyte (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int)) 
                    
        | L_long (k) => _ilg.Emit (OpCodes.Ldc_I8, k)
        | L_ulong (k) =>
          // FIXME: need the checked/unchecked to implement this correctly
          if (k <= 9223372036854775807ul) {
            _ilg.Emit (OpCodes.Ldc_I8, (k :> long));
            _ilg.Emit (OpCodes.Conv_U8)
          }
          else {            
            def k' = k - 9223372036854775807ul;
            
            _ilg.Emit (OpCodes.Ldc_I8, 9223372036854775807l);
            _ilg.Emit (OpCodes.Conv_U8);
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.Emit (OpCodes.Conv_U8);
            _ilg.Emit (OpCodes.Add);            
            _ilg.Emit (OpCodes.Ldc_I8, ((k' - 1ul) :> long));
            _ilg.Emit (OpCodes.Conv_U8);
            _ilg.Emit (OpCodes.Add)
          }
            
        | L_char (k) when ((k :> int) <= 127) =>
          _ilg.Emit (OpCodes.Ldc_I4_S, (k :> System.Byte))
          
        | L_char (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
        
        | L_bool (true) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)

        | L_string (s) => _ilg.Emit (OpCodes.Ldstr, s)
        | L_float (f) => _ilg.Emit (OpCodes.Ldc_R4, f)
        | L_double (f) => _ilg.Emit (OpCodes.Ldc_R8, f)
        | L_decimal (f) => _ilg.Emit (OpCodes.Ldc_R8, System.Convert.ToDouble (f)) // FIXME

        | L_enum (l, _) => emit_literal (l)
      }
    }


    /**
     * Emits a list of expressions. This is used to emit call parameters,
     * specialization allows better error messages here.
     */
    private emit_call_parameters (parms : list <CG_expr>) : bool
    {
      match (parms) {
        | [] => false
        | parm :: rest =>
          if (emit (parm)) {
            Message.warning ("a control-flow terminating call parameter in "
                             + _method_name);
            true
          }
          else emit_call_parameters (rest)
      }
    }


    /**
     * Emits a comparison operation
     */
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }


    /**
     * Converts parameter list to it's System.Type list
     */
    private make_call_parms (parms : list <CG_val>) : list <System.Type>
    {
      List.Map (parms, fun (parm : CG_val) { parm.ty })
    }


    /**
     * Converts parameter list to it's System.Type list
     */
    private make_expr_call_parms (parms : list <CG_expr>) : list <System.Type>
    {
      List.Map (parms, type_of)
    }


    /**
     * Computes the type of an expression
     */
    type_of (ex : CG_expr) : System.Type
    {
      CGexpr.type_of (ex)
    }


    /**
     * Pretty prints a list of expressions
     */
    pretty_print_list (exs : list <CG_expr>, acc : string) : string 
    {
      match (exs) {
        | [] => acc
        | ex :: rest => pretty_print_list (rest, acc + pretty_print (ex))
      }
    }


    /**
     * Pretty prints an expression
     */
    pretty_print (ex : CG_expr) : string 
    {
      match (ex) {
        | CE_ref (decl) =>
          "CE_ref (" + decl.name + "); "
        | CE_global_ref (mi) =>
          "CE_global_ref (" + pretty_print_member_info (mi) + "); "
        | CE_base_ctor_ref (mi) =>
          "CE_base_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_ctor_ref (mi) =>
          "CE_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_field_ref (_, fld) =>
          "CE_field_ref (" + pretty_print_member_info (fld) +"); "
        | CE_method_ref (_, meth) =>
          "CE_method_ref (" + pretty_print_member_info (meth) + "); "
        | CE_method_addr (meth) =>
          "CE_method_addr (" + pretty_print_member_info (meth) + "); "
        | CE_ignore (expr) =>
          "CE_ignore (" + pretty_print (expr) + "); "
        | CE_opcode (name) =>
          "CE_opcode (" + name + "); "
        | CE_self_tail_call (parms) =>
          "CE_self_tail_call (" + pretty_print_list (parms, "") + "); "
        | CE_call (func, parms) =>
          "CE_call " + pretty_print (func) + " (" + pretty_print_list (parms, "") + "); "
        | CE_tail_call (func, parms) =>
          "CE_tail_call " + pretty_print (func) + " (" +
          pretty_print_list (parms, "") + "); "
        | CE_assign (target, source) => 
          pretty_print (target) + " = " + pretty_print (source) + "; "
        | CE_multiple_assign => 
          "CE_multiple_assign; "
        | CE_loop (expr, _) =>
          "CE_loop (" + pretty_print (expr) + "); "
        | CE_continue_loop =>
          "CE_continue_loop; "
        | CE_let (name, body) => 
          "let " + name.name + " = " + pretty_print (name.val) + " in "
          + pretty_print (body) + "; "
        | CE_has_type (_, ty) => "CE_has_type (" + pretty_print_type (ty) + "); "
        | CE_not_null => "CE_not_null; "
        | CE_typeof (ty) => "CE_typeof (" + pretty_print_type (ty) + "); "
        | CE_raise (exn) => "CE_raise (" + pretty_print (exn) + "); "
        | CE_if (cond, e_then, e_else) => 
          "if (" + pretty_print (cond) + ") " + pretty_print (e_then)
          + " else " + pretty_print (e_else) + "; "
        | CE_try_with => "CE_try_with; "
        | CE_try_finally => "CE_try_finally; "
        | CE_literal => "CE_literal; "
        | CE_this => "CE_this; "
        | CE_skip => "CE_skip; "
        | CE_cast (expr, ty) =>
          "CE_cast < " + pretty_print (expr)
          + " to " + pretty_print_type (ty) + "> "
        | CE_sequence (body) => "{ " + pretty_print_list (body, "") + " }; "
        | CE_none => "CE_none"
        | CE_mkarray (_, initializers) =>
          "CE_mkarray { " + pretty_print_list (initializers, "") + " }; "
        | CE_array_indexer (obj, args) =>
          "CE_indexer " + pretty_print (obj) + "[" +
          pretty_print_list (args, "") + "]" + "; "
        | CE_switch (indexer, _, _) =>
          "CE_switch ( " + pretty_print (indexer) + " ); "
      }
    }


    /**
     * Pretty prints a type
     */
    private pretty_print_type (ty : System.Type) : string
    {
      ty.FullName
    }


    /**
     * Pretty prints a member info name
     */
    private pretty_print_member_info (mi : MemberInfo) : string
    {
      mi.DeclaringType.FullName + "::" + mi.Name
    }

    /**
     * Converts a list <Label> into a array <Label>
     * FIXME: this should work now?
     */
    private label_list_to_array (x : list <Label>) : array <Label> 
    {
      def result = array (List.Length (x));
      
      def loop (index : int, x : list <Label>) : void {        
        match (x) {
          | head :: tail =>
            result [index] = head;
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }

  } /* end of the class */
  
} /* end of the namespace */
