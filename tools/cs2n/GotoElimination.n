// Copyright (c) 2003-2005 The University of Wroclaw.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. The name of the University may not be used to endorse or promote
//       products derived from this software without specific prior
//       written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
// NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

using Nemerle.Collections;

namespace Nemerle.CSharp
{
    public module Gotos
    {
	private mutable gotos : list [antlr.Token] = [];
	private mutable labels : list [antlr.Token] = [];
	
	public AddGoto ( label : antlr.Token ) : void
	{
	    gotos = label :: gotos;
	}

	public AddLabel ( label : antlr.Token ) : void
	{
	    labels = label :: labels;
	}

	public ClearGotos () : void
	{
	    gotos = [];
	}

	public ClearLabels () : void
	{
	    labels = [];
	}

	public Clear () : void
	{
	    ClearLabels ();
	    ClearGotos ();
	}

	public GetGotos : list [antlr.Token]
	{
	    get
	    {
		gotos
	    }
	}

	public GetLabels : list [antlr.Token]
	{
	    get
	    {
		labels
	    }
	}
	
    }
    
    public partial variant STree
    {	
	protected transform_gotos_to_conditionals () : STree
	{
	    match(this)
	    {
		| Statement ("WHEN",[when_,lp,cond,rp,maybe_goto]) as when_st=>
		    if(maybe_goto matches Statement ("GOTO",_))
			when_st
		    else
			Statement ("WHEN",[when_,lp,cond,rp,maybe_goto.transform_gotos_to_conditionals ()])
			
		| Statement ("GOTO", goto :: _ ) as goto_st=>
		    
		    def ws = get_first_whitespace (goto);

		    Statement("WHEN", [ make_token (ws,"when"), TokS(" ("), make_token("", " true ") , TokS (")"), goto_st])

		| Statement ( name , children) =>
    
		    Statement (name , List.Map ( children , fun (x) { x.transform_gotos_to_conditionals () } ) )

		| x => x
		    
	    }
	}
	
	private eliminate_siblings (sts : list [STree],label : string) : option [list [STree]]
	{	    	
	    def negate_cond (cond)
	    {
		| TokS (c) => TokS ("!" + c);
		| Tok (t) => make_token (ExtendedToken.getWhitespaces (t), "!" + ExtendedToken.getTextOnly (t))
		| c => c
	    }
	    
	    def eliminate_siblings_aux (statements, crossed, begin)
	    {
		match (statements)
		{
		    | [] => ( None () )
		
		    | Statement ( "WHEN", [ Tok(when_tok) , _ , cond , _ , Statement ("GOTO" , [ _ , Tok(id) , _]) ] ) as goto_st :: tail =>
			def ws = ExtendedToken.getWhitespaces (when_tok);
			match (crossed)
			{
			    | None =>				
				if ( ExtendedToken.getTextOnly (id) == label)			    
				    eliminate_siblings_aux (tail , Some ([cond]) , begin )
				else
				    eliminate_siblings_aux (tail , None (), goto_st :: begin )

			    | Some (lst) =>
				if ( ExtendedToken.getTextOnly (id) == label)
				{
				    def block = Statement ("BLOCK" , make_token (ws , "{") :: List.Rev(lst)  + [make_token (ws , "}")]);	
				    def do_st = Statement("DO",[Tok (ExtendedToken (ws , "do")) , block , 
					Tok ( ExtendedToken (ws , "while")) , TokS("(") , cond , TokS(")") , TokS(";")]);
			    
				    Some (List.Rev (begin) + [ do_st ] + tail)
				}
				else
				{
				    eliminate_siblings_aux (tail , Some(goto_st :: lst) , begin)
				}
			}
		    
		    | Statement ( "LABEL", [Tok(id), _ , _ ] ) as label_st :: tail =>
			def ws = ExtendedToken.getWhitespaces (id);
			match (crossed)
			{
			    | None =>
				if ( ExtendedToken.getTextOnly (id) == label)
				    eliminate_siblings_aux (tail , Some ([label_st]) , begin )
				else
				    eliminate_siblings_aux (tail , None (), label_st :: begin )

			    | Some (lst) =>
				if ( ExtendedToken.getTextOnly (id) == label)
				{
				    match(List.Rev(lst))
				    {
					| cond :: rest =>
					    def block = Statement ("BLOCK" , make_token (ws , "{") :: rest  + [make_token (ws , "}")]);
					    def new_when = Statement("WHEN", [ make_token (ws,"when") , TokS("(") , 
						    negate_cond(cond) , TokS(")") , block ]);

					    Some (List.Rev (begin) + [ new_when ] + [label_st] + tail)
					| [] => assert (false)
				    }
				}
				else				
				    eliminate_siblings_aux (tail , Some(label_st :: lst) , begin )
			    
			}			
		    | head :: tail =>
			match (crossed)
			{
			    | None => 
				eliminate_siblings_aux (tail , None (), head :: begin )
			    | Some (lst) =>
				eliminate_siblings_aux (tail , Some(head :: lst) , begin )
			}
		}
	    }

	    eliminate_siblings_aux (sts , None () , []);
	}	

	private go_inside () : list [STree]
	{
	    match(this)
	    {
		| Statement ("BLOCK", xs) =>
		    def (_, statements , _) = cut_off_braces (xs);
		    
		    statements

		| Statement ("WHILE", [_ , _ , _ , _ , block]) 
		| Statement ("WHEN", [_ , _ , _ , _ , block]) 
		| Statement ("DO", _ :: block :: _ ) =>

		    block.go_inside ()

		| _ => []
	    }
	}
	
	private do_the_stuff (statements : list[STree] , label : string) : list [STree]
	{
	    mutable new_statements = 
	    match (lift_goto (statements, label))
	    {
		| None => statements
		| Some (sts) => sts
	    };
	    
	    new_statements = 
	    match( eliminate_siblings (new_statements , label) )
	    {
		| None => statements
		| Some (sts) => sts
	    };

	    new_statements
	}
	
	private lift_goto (statements : list[STree],  label : string) : option [list [STree]]
	{
	    def lift_goto_aux (sts , acc , found)
	    {
		match ( sts )
		{
		    | [] => None ()
		
		    | Statement ( "WHEN", [ _ , _ , _ , _ , Statement ("GOTO" , [ _ , Tok(id) , _]) ] ) as goto_st :: tail =>
			if (ExtendedToken.getTextOnly (id) == label)
			    None ()
			else
    			    lift_goto_aux (tail, goto_st :: acc , found) 
			    
		    | Statement ( "LABEL", [Tok(id), _ , _ ] ) as label_st :: tail =>			

			if (ExtendedToken.getTextOnly (id) == label)
			{
			    if ( found)
				Some (List.Rev (acc) + (label_st :: tail))
			    else
				lift_goto_aux (tail, label_st :: acc , true) 
			}
			else
    			    lift_goto_aux (tail, label_st :: acc , found) 

		    | head :: tail =>
			if ( head.jump_inside (Jump.Goto (label)) )
			{
			    def head_el = head.eliminate_jump_2 (Jump.Goto (label));
			    if (found)
				Some (List.Rev (acc) + head_el + tail)
			    else
				lift_goto_aux (tail, head_el + acc , true) 
			}
			else
			    lift_goto_aux (tail, head :: acc , found) 		    
		}
	    }

	    lift_goto_aux (statements , [] , false)
	}
	
	private eliminate_goto () : STree
	{
	    label_symbols.Clear ();
	    
	    mutable gotos_list = Gotos.GetGotos;
	    mutable labels_list = Gotos.GetLabels;	    

	    Gotos.Clear ();

	    def s_labels_list = List.Map ( labels_list , ExtendedToken.getTextOnly );	    
	    
	    def check_gotos (x)
	    {
		def text = ExtendedToken.getTextOnly (x);
		when (! List.Member (s_labels_list , text ))
		    Message.Error ("goto to non-existing label" , x);
	    }
	    List.Iter ( gotos_list , check_gotos );

	    def add_temp (x)
	    {
		def gs = new_goto_symbol ();
		label_symbols.Add ( x, gs );
	    }
	    List.Iter (List.Map (labels_list , ExtendedToken.getTextOnly ), add_temp);

	    def (lb, statements , rb) = cut_off_braces (this);

	    def loop (lst , statements)
	    {
		match (lst)
		{
		    | head :: tail =>
			loop (tail , do_the_stuff (statements , head));
		    | _ => statements
		}
	    }	    

	    def new_statements = loop (List.Map (gotos_list , ExtendedToken.getTextOnly ), 
		    List.Map ( statements , fun (x) {x.transform_gotos_to_conditionals ()} ));

	    def fw = get_first_whitespace ( statements );

	    mutable inits = [];
	    def add ( _ , i )
	    {
		inits = make_token (fw , "mutable " +  i + " = false;") :: inits;
	    }

	    label_symbols.Iter ( add );

	    Statement ("BLOCK" , lb :: inits + new_statements + [rb]);	    
	}

	private label_inside (label : string) : bool
	{
	    def loop(xs : list [STree]) : bool
            {
		| head :: tail =>
		    if(head.label_inside (label))
			true
                    else
                        loop(tail)
                | _ => false
            }

	    match(this)
	    {
		| Statement ("LABEL", [Tok(id), _ , _ ] )  =>
		    ExtendedToken.getTextOnly (id) == label

                | Statement("BLOCK",xs) =>  loop(xs);
                | Statement("IF",[_,_,_,_,st1,_,st2]) =>
		    st1.label_inside (label) || st2.label_inside (label)
                    
                | Statement("WHEN",[_,_,_,_,st]) => st.label_inside (label)

		| Statement("SWITCH",[_,_,_,_,Statement("SWITCH_BLOCK",xs)]) =>
			loop(xs)

		| Statement("SWITCH_SECTION",[_,Statement("SWITCH_SECTION_STATEMENTS",xs)]) =>
		    loop(xs)		
		
		| Statement("TRY",_ :: block :: _) 
		| Statement("USING_STATEMENT",[_,_,_,_,block])
		| Statement("LOCK",[_,_,_,_,block])
		| Statement("CHECKED",[_,block]) 
		| Statement("UNCHECKED",[_,block]) =>
		    block.label_inside (label)
		
		| Statement("DO", _ :: block :: _) =>
			block.label_inside (label)
		
                | _ => false
            }	    
	}

	private make_token (ws : string, text : string) : STree
	{
	    STree.Tok (ExtendedToken(ws,text));
	}

	private new_goto_symbol () : string
        {
            new_symbol ("_goto_")
        }


	/* -- PRIVATE FIELDS ---------------------------------------------------- */ 

	private static label_symbols : Nemerle.Collections.Hashtable [string , string] = Nemerle.Collections.Hashtable ();
    }
}

