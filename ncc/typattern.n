/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module PatternTyping {
  
  variant Range {
    | Omega        // _, x, everything
    | Non         // nothing
    | AnyExcept { lits : list <Nemerle.Compiler.Literal>; }
    | Liter { l : Nemerle.Compiler.Literal; }
    | Variant_option { ti : TypeInfo; range : Range; }
    | Enum { fld : IField; }
    | Tuple { ranges : list <Range>; }
    | Record { ranges : list <IField * Range>; }
    
    | Or { ranges : list <Range>; }
  }

  range_of_pattern (p : Pattern) : Range {
    match (p) {
      | Pattern.P_underscore => Range.Omega ()
      | Pattern.P_as (p, _) => range_of_pattern (p)
      | Pattern.P_tuple (args) => Range.Tuple (List.Map (args, range_of_pattern))
      | Pattern.P_record (args) =>
        Range.Record (List.Map (args, fun (n, p) { (n, range_of_pattern (p)) }))
      | Pattern.P_cons (ti, pat) =>
        Range.Variant_option (ti, range_of_pattern (pat))
      | Pattern.P_enum (f, _) => Range.Enum (f)
      | Pattern.P_literal (l) => Range.Liter (l)
      | Pattern.P_has_type => Range.Non ()
    }
  }

  // debug routine
  string_of_range (r : Range) : string {
    match (r) {
      | Range.Omega => "_"
      | Range.AnyExcept ([Literal.L_bool (true)]) => "false"
      | Range.AnyExcept ([Literal.L_bool (false)]) => "true"
      | Range.AnyExcept (lst) => "(anything except " + lst.ToString () + ")"
      | Range.Variant_option (ti, r) =>
        ti.FullName + " (" + string_of_range (r) + ")"
      | Range.Enum (f) =>
        f.Name
      | Range.Tuple (ranges) =>
        def concat (r, acc) {
          if (acc == "") string_of_range (r)
          else
            acc + ", " + string_of_range (r)
        };
        "(" + List.FoldLeft (ranges, "", concat) + ")"
        
      | Range.Record (ranges) =>
        def concat (x, acc) {
          def (f, r) = x;
          def r' = (f : IField).Name + " = " + string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.FoldLeft (ranges, "", concat) + " }"
        
      | Range.Non => "[[None]]"
      | Range.Liter => "[[Literal]]"
      
      | Range.Or (ranges) =>
        def concat (r : Range, acc : string) : string {
          if (acc == "") string_of_range (r)
          else
            acc + " | " + string_of_range (r)
        };
        "[ " + List.FoldLeft (ranges, "", concat) + " ]"
    }
  }

  // for user error messages, we just present first branch of Range.Or
  user_string_of_range (r : Range) : string {
    match (r) {
      | Range.Omega => "_"
      | Range.AnyExcept ([Literal.L_bool (true)]) => "false"
      | Range.AnyExcept ([Literal.L_bool (false)]) => "true"
      | Range.AnyExcept (lst) => "(anything except " + lst.ToString () + ")"
      | Range.Variant_option (ti, r) =>
        ti.FullName + " (" + user_string_of_range (r) + ")"
      | Range.Enum (f) =>
        f.Name
      | Range.Tuple (ranges) =>
        def concat (r, acc) {
          if (acc == "") user_string_of_range (r)
          else
            acc + ", " + user_string_of_range (r)
        };
        "(" + List.FoldLeft (ranges, "", concat) + ")"
        
      | Range.Record (ranges) =>
        def concat (x, acc) {
          def (f, r) = x;
          def r' = (f : IField).Name + " = " + user_string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.FoldLeft (ranges, "", concat) + " }"
        
      | Range.Non => Util.ice ()
      | Range.Liter => Util.ice ()
      | Range.Or ([]) => Util.ice ()
      
      | Range.Or (x :: _) => user_string_of_range (x)
    }
  }

  simplify_range (r : Range) : Range {
  //  Message.debug ("simpl: " + string_of_range (r) );
    def aint_none (r : Range) : bool {
      match (r) {
        | Range.Non => false
        | _ => true
      }
    };
    match (r) {
      | Range.Or ([]) => Range.Non ()
      | Range.Or (lst) =>
        match (List.Filter (lst, aint_none)) {
          | [] => Range.Non ()
          | [x] => x
          | l => Range.Or (l)
        }
      | Range.AnyExcept (lst) =>
        if (List.Exists (lst, fun (x) { x matches Literal.L_bool (true) }) &&
            List.Exists (lst, fun (x) { x matches Literal.L_bool (false) }))
          Range.Non ()
        else
          r
      | Range.Variant_option (_, Range.Non) => Range.Non ()
      | Range.Tuple (ranges) =>
        if (List.ForAll (ranges, aint_none)) 
          r
        else
          Range.Non ()
      | Range.Record (ranges) =>
        def is_named_none (_, x) {
          match (x) {
            | Range.Non => true
            | _ => false
          }
        };
        if (List.Exists (ranges, is_named_none))
          Range.Non ()
        else
          r
      | x => x 
    }
  }
    
  subtract (r1 : Range, r2 : Range) : bool * Range {
    mutable did_something = false;

    // subtract new_r from cur_r
    def do_sub (cur_r : Range, new_r : Range) : Range {
//    Message.debug ("subx: " + string_of_range (cur_r) + "     " + string_of_range (new_r) );
      match ((cur_r, new_r)) {
        | (Range.Non, _) => Range.Non ()

        // Range.Non is generated from (x : foo), so ...
        | (x, Range.Non) =>
          did_something = true;
          x

        | (_, Range.Omega) => 
          did_something = true; 
          Range.Non ()
          
        | (Range.Omega, Range.Liter (l)) =>
          did_something = true;
          Range.AnyExcept ([l])

        | (Range.Or (ranges), _) =>
          Range.Or (List.Map (ranges, fun (r : Range) : Range { sub (r, new_r) }))

        | (Range.AnyExcept (lits), Range.Liter (l)) =>
          // FIXME: check if l is in lits
          did_something = true;
          Range.AnyExcept (l :: lits)

        | (Range.AnyExcept, _) => Util.ice ()

        | (Range.Variant_option (ti1, r1), Range.Variant_option (ti2, r2)) =>
          if (ti1.SameAs (ti2))
            Range.Variant_option (ti1, sub (r1, r2))
          else
            cur_r

        | (Range.Enum (f1), Range.Enum (f2)) =>
          //Message.debug ($ "$f1 equals $f2");
          if (f1.Equals (f2)) {
            //Message.debug ("yes");
            did_something = true;
            Range.Non ()
          } else cur_r

        | (Range.Omega, Range.Enum (f)) =>
          def t = f.DeclaringType;
          //Message.debug ($ "_ - enum $f ($t)");
          if (t.HasAttribute (InternalType.FlagsAttribute_tc)) {
            //Message.debug ("did");
            did_something = true;
            Range.Omega ()
          } else {
            def ranges =
              List.FoldLeft (t.GetMembers (), [], fun (mem : IMember, acc) {
                match (mem) {
                  | fld : IField when fld.IsLiteral && fld.DeclaringType.SameAs (t) =>
                    Range.Enum (fld) :: acc
                  | _ => acc
                }
              });
            sub (Range.Or (ranges), new_r)
          }
          
        | (cur, Range.Variant_option (ti, _)) =>
          def make_range (ti : TypeInfo) : Range {
            Range.Variant_option (ti, cur)
          };
          match (Option.UnSome (ti.SuperClass ()).GetTydecl ()) {
            | Type_decl.TD_variant (opts) =>
              sub (Range.Or (List.Map (opts, make_range)), new_r)
            | _ =>
              Util.ice ("not variant")
          }

        | (Range.Variant_option, Range.Record) => Util.ice ("FIXME")
       
        | (Range.Omega, Range.Tuple (ranges)) =>
          def args = List.Map (ranges, fun (_ : Range) : Range { Range.Omega () });
          sub (Range.Tuple (args), new_r)
          
        | (Range.Tuple (r1), Range.Tuple (r2)) =>
          mutable did = true;
          def make_sub (r1 : Range, r2 : Range) : Range {
            def (d, r) = subtract (r1, r2);
            if (d) () else did = false;
            r
          };
          def results = List.Map2 (r1, r2, make_sub);
          if (did) {
            did_something = true;

            mutable output = [];
            // r1 - r2 = r3
            def dosub (pref : list <Range>, 
                       cur : list <Range>, 
                       after_sub : list <Range>) : void {
              match ((cur, after_sub)) {
                | (x :: xs, y :: ys) => 
                  def args = List.RevAppend (pref, (y :: xs));
                  output = simplify_range (Range.Tuple (args)) :: output;
                  dosub (x :: pref, xs, ys)
                | ([], []) => ()
                | _ => Util.ice ()
              }
            };
            dosub ([], r1, results);
            Range.Or (output)
          } else cur_r
        
        | (Range.Omega, Range.Record) =>
          sub (Range.Record ([]), new_r)

        | (Range.Record (r1), Range.Record (r2)) =>
//          Message.debug ("ransub: " + string_of_range (cur_r) + "   " + string_of_range (new_r));
          mutable all_did = true;

          def loop (r2, acc) {
            def (name : IField, range) = r2;
            
            def loop2 (acc, l) {
              match (l) {
                | (f : IField, r) :: xs =>
                  if (name.GetId () == f.GetId ()) {
                    def (did, res) = subtract (r, range);
                    if (did) () else all_did = false;
                    List.RevAppend (xs, (f, res) :: acc)
                  } else
                    loop2 ((f, r) :: acc, xs)
                | [] =>
                  (name, sub (Range.Omega (), range)) :: acc
              }
            };

            simplify_range (Range.Record (loop2 ([], r1))) :: acc
          };

          def r = Range.Or (List.FoldLeft (r2, [], loop));

          if (all_did) {
            did_something = true;
            r
          } else cur_r

        | (Range.Variant_option, Range.Tuple) => assert (false)
        | (Range.Variant_option, Range.Liter) => assert (false)
        | (Range.Tuple, Range.Liter) => assert (false)
        | (Range.Record, Range.Liter) => assert (false)
        | (Range.Record, Range.Tuple) => assert (false)
        | (Range.Tuple, Range.Record) => assert (false)
        | (Range.Liter, _) => assert (false)
        | (_, Range.AnyExcept) => assert (false)
        | (_, Range.Or) => assert (false)
        | (Range.Enum, _) =>
          Message.debug ("enum - " + string_of_range (new_r));
          assert (false)
        | (_, Range.Enum) => assert (false)
      }
    }

    and sub (r1 : Range, r2 : Range) : Range {
      simplify_range (do_sub (r1, r2))
    };

    def ret = sub (r1, r2);
//    Message.debug ("sub: " + string_of_range (r1) + " - " + string_of_range (r2) + " = " + string_of_range (ret));

    (did_something, ret)
  }

  
  /**
   * Give warnings about ``pattern matching not exhaustive'' and 
   * ``unused match clause''.
   */
  public check_matching (cases : list <Match_case>) : void
  {
    def loop (m : Match_case, acc : Range) : Range
    {
      def loop2 (patex : Pattern * Expr, acc : Range) : Range
      {
        def (pat, ex) = patex;
        def (did_something, ret) = subtract (acc, range_of_pattern (pat));

        unless (did_something)
          Message.warning (pat.loc, "this match clause is unused");

        match (ex) {
          | Expr.E_literal (Literal.L_bool (true)) => ret
          | _ => acc
        }
      };

      List.FoldLeft (m.patterns, acc, loop2)
    }

    def remaining = List.FoldLeft (cases, Range.Omega (), loop);
    match (remaining) {
      | Range.Non => ()
      | r =>
        Message.warning ("this matching is not exhaustive, example unmatched value:");
        Message.warning (user_string_of_range (r))
    }
  }


  public strip_enums (p : Pattern) : Pattern
  {
    | Pattern.P_enum (_, l) => 
      Pattern.P_literal (p.loc, p.ty, l)

    | Pattern.P_as (pat, decl) =>
      Pattern.P_as (p.loc, p.ty, strip_enums (pat), decl)
      
    | Pattern.P_tuple (a) =>
      Pattern.P_tuple (p.loc, p.ty, List.Map (a, strip_enums))
      
    | Pattern.P_record (a) =>
      Pattern.P_record (p.loc, p.ty, List.Map (a, fun (f, p) { (f, strip_enums (p)) }))
      
    | Pattern.P_cons (name, arg) =>
      Pattern.P_cons (p.loc, p.ty, name, strip_enums (arg))
      
    | Pattern.P_has_type
    | Pattern.P_underscore
    | Pattern.P_literal => p
  }

  
  public TypePatterns (ctx : TypingContext, 
                      matched_value_type : Type, 
                      patterns : list <PT.Expr * option <PT.Expr>>) 
                    : list <Pattern * Expr> * TypingContext {
                    
    mutable vars = NemerleMap ();
    mutable common_vars = option.None ();
    
    def fold_mems (e) {
      match (Util.qidl_of_expr (e)) {
        | Some ((li, name)) =>
          PT.Expr.E_ref (PT.Name (li, name.color, name.context))

        | None =>
          Message.fatal_error (e.loc, "expected qualified identifier in pattern")
      }
    }
    
    def do_walk (t : Type, p : PT.Expr) : Pattern {
      def walk_application (n, p : PT.Expr) {
        def n = match (n) {
          | PT.Expr.E_ref (n) => n
          | _ => Util.ice ()
        }
      
        if (System.Char.IsUpper (List.Last (n.idl) [0])) {
          def env = n.GetEnv (ctx.env);
          match (env.LookupSymbol (n.idl)) {
            // FIXME: if there is type and enum field under the same name,
            // the type wins, but there should be an error message
            | [Symbol.Sym_type_member (fld : IField)] 
              when fld.IsLiteral && 
                   (fld.DeclaringType.GetTydecl () matches Type_decl.TD_enum) =>
              unless (p matches PT.Expr.E_Underscore)
                Message.error ("a pattern was supplied after enum field name");
              def val = Option.UnSome (ConstantFolder.FieldValueAsLiteral (fld));
              Pattern.P_enum (fld, val)

            | _ =>
              def lookup (ti : TypeInfo) {
                match (ti.GetTydecl ()) {
                  | Type_decl.TD_variant_option =>
                    def parent_tycon = Option.UnSome (ti.SuperClass ());
                    def parent_type = parent_tycon.GetMemType () /- parent_tycon.FreshSubst ();
                    def option_type = ti.GetMemType () /- ti.FreshSubst ();
                    if (option_type >:> parent_type) () else Util.ice ();
                    // we use parent_type for subtyping in case matched value
                    // has yet undefined type
                    if (parent_type >:> t)
                      // but option_type inside subpattern
                      Pattern.P_cons (ti, walk (option_type, p))
                    else if (option_type >:> t) {
                      Message.warning ($ "matching of $t with $option_type is redundant");
                      Message.hint_once ("refer to fields of this variant option without matching");
                      Pattern.P_cons (ti, walk (option_type, p))
                    } else
                      Message.fatal_error ($ "variant option $option_type "
                                             "doesn't subtype $t")

                  | Type_decl.TD_alias (Type.T_app (tc, _)) =>
                    lookup (tc)

                  | _ =>
                    Message.error ("`" + Util.qid_of_list (n.idl) + "' is not a variant option");
                    Pattern.P_underscore ()
                }
              }

              lookup (env.GetType (n.idl, ctx.parent_type))
          }
        } else
          match (p) {
            | PT.Expr.E_Underscore => walk (t, PT.Expr.E_As (PT.Expr.E_Underscore (), PT.Splicable_string.SS_string (n)))
            | _ =>
              Message.fatal_error ("`" + n.FullId + "' cannot be variant option, "
                                   "since it starts with lowercase letter")
          }
      }    
    
//      match (ConstantFolder.FoldConstants (ctx.env, p)) {
      match (p) {
        | PT.Expr.E_As (pat, PT.Splicable_string.SS_string ({ idl = n; color = c })) =>
          def pat' = walk (t, pat);
          def t' =
            match (pat') {
              | Pattern.P_cons (ti, _) =>
                def t' = ti.GetMemType () /- ti.FreshSubst ();
                if (t' >:> t) t'
                else Util.ice ()
              | _ => t
            };
          def pt_name = PT.Name (n, c, null);
          when (vars.Member (pt_name))
            Message.error ("pattern variable `" + List.Head (n) + 
                           "' already seen in this pattern");
          def decl =
            match (common_vars) {
              | None =>
                ctx.DefineLocal (List.Head (n), c, LocalValueKind.D_pattern_variable (), t');
              | Some (cv) =>
                match ((cv : NemerleMap <PT.Name, LocalValue>).Find (pt_name)) {
                  | Some (decl) => 
                    unless (t' >:> decl.ty) {
                      Message.error ($ "pattern variable `$(decl.name)' used "
                                       "to have type $(decl.ty) but now it "
                                       "has type $t'");
                      Message.hint ("rename variable if they have no connection")
                    };
                    decl
                  | None =>
                    ctx.DefineLocal (List.Head (n), c, LocalValueKind.D_pattern_variable (), t');
                }
            };
          vars = vars.Add (pt_name, decl);
          Pattern.P_as (pat', decl)
          
        | PT.Expr.E_As (_, PT.Splicable_string.SS_spliced_expr) =>
          Message.fatal_error ("$ operator used outside of quotation <[ ... ]> context")

        | PT.Expr.E_type_enforcement (n, needed_type) =>
          def is_iface (t) {
            | Type.T_app (tc, _) =>
              match (tc.GetTydecl ()) {
                | Type_decl.TD_interface => true
                | _ => false
              }
            | _ => false
          };
          def needed_type = ctx.parent_type.BindType (ctx.tenv, needed_type);
          if (t >:> needed_type)
            walk (t, n)
          else
            if (needed_type >:> t || is_iface (needed_type) || is_iface (t)) {
              def ti =
                match (needed_type) {
                  | Type.T_app (ti, _) => ti
                  | _ => 
                    Message.fatal_error ($ "invalid type in (x : type) pattern: $needed_type")
                };
              def pat = Pattern.P_has_type (p.loc, t, ti);
              match (walk (needed_type, n)) {
                | Pattern.P_as (Pattern.P_underscore, decl) =>
                  Pattern.P_as (p.loc, t, pat, decl)
                | Pattern.P_underscore => pat
                | _ =>
                  Message.fatal_error ("only variable patterns are allowed (here : type)")
              }
            } else
              Message.fatal_error ($ "matched value has type $t while the "
                                     "pattern enforces $needed_type")

        | PT.Expr.E_Underscore => Pattern.P_underscore ()

        | PT.Expr.E_literal (lit) =>
          def t' = Tyexpr.ty_literal (ctx, lit);
          match (Tyutil.unify (t, t', false)) {
            | Some (s) => 
              Tyvar.global_store (s);
              Pattern.P_literal (lit)
            | None =>
              Message.fatal_error ($ "literal has type $t' while matched "
                                     "value has type $t")
          }

        | PT.Expr.E_tuple (pats) =>
          match (Tyutil.top_expand (t)) {
            | Type.T_app (ti, _) =>
              def mems = ti.GetFields (BindingFlags.DeclaredOnly %|
                                       BindingFlags.Public %|
                                       BindingFlags.Instance);
              def names = List.Map (mems, fun (x : IField) { x.Name });
              match (names) {
                | _ :: _ =>
                  if (List.Length (names) == List.Length (pats)) {
                    def mk (n : string, p : PT.Expr) : PT.Expr {
                      PT.Expr.E_assign (PT.Expr.E_ref (PT.Name ([n])), p)
                    };
                    walk (t, PT.Expr.E_sequence (List.Map2 (names, pats, mk)))
                  } else
                    Message.fatal_error 
                    (sprintf ("pattern matches %d values, while type %s has %d fields", 
                              List.Length (pats), ti.FullName, List.Length (names)))
                | [] =>
                    Message.fatal_error ("pattern matches " + 
                                         (List.Length (pats)).ToString () + 
                                         " values, while type " + ti.FullName + 
                                         " has no fields")
              }
              
            | Type.T_prod (ts) =>
              if (List.Length (ts) == List.Length (pats))
                Pattern.P_tuple (List.Map2 (ts, pats, walk))
              else
                Message.fatal_error ("pattern matches " + 
                                     (List.Length (pats)).ToString () + 
                                     "-tuples, while " + 
                                     (List.Length (ts)).ToString () + 
                                     "-tuple is required")
            | vart =>
              def free_vars (acc, n) {
                if (n <= 0) acc
                else free_vars (Tyvar.free_variable () :: acc, n - 1)
              };
              def ts = free_vars ([], List.Length (pats));
              if (vart >:> Type.T_prod (ts))
                Pattern.P_tuple (List.Map2 (ts, pats, walk))
              else
                Message.fatal_error ($ "pattern matches "
                                       "$(List.Length (pats))-tuples, "
                                       "not values of type $t")
          }
          
        | PT.Expr.E_sequence (l) =>
          def fn (_) {
            | PT.Expr.E_assign (PT.Expr.E_ref (name), pat) =>
              def name = name.Id;
              // just a placeholder with correct type
              def bogus_expr = Expr.E_type_enforcement (null, t);
              def loc = Location_stack.top ();
              bogus_expr.loc = loc;
              bogus_expr.ty = t;
              match (Tyexpr.lookup_member (ctx, loc, bogus_expr, name)) {
                | [(Expr.E_field_ref (_, fieldname)) as fieldref] =>
                  (fieldname, walk (Tyexpr.type_of (fieldref), pat))
                | _ =>
                  Message.fatal_error ("name `" + name + "' was expected to be field")
              }
            | _ =>
              Message.fatal_error ("record pattern must be a sequence of `id = pattern;'") 
          };
          Pattern.P_record (List.Map (l, fn))

        | PT.Expr.E_member => 
          walk_application (fold_mems (p), PT.Expr.E_Underscore ())
           
        | PT.Expr.E_ref => walk_application (p, PT.Expr.E_Underscore ())

        | PT.Expr.E_call (PT.Expr.E_ref (n), _) when ConstantFolder.is_known_operator (n.Id) => 
          walk (t, ConstantFolder.FoldConstants (ctx.env, p))

        | PT.Expr.E_call (f, []) => walk_application (fold_mems (f), PT.Expr.E_Underscore ())         
        | PT.Expr.E_call (f, args) => walk_application (fold_mems (f), PT.Expr.E_tuple (args))
           
        | PT.Expr.E_Application (f, pa) => 
          match (pa) {
            | PT.Expr.E_Underscore | PT.Expr.E_sequence =>
              walk_application (fold_mems (f), pa)
            | _ =>
              walk_application (fold_mems (f), PT.Expr.E_tuple ([pa]))
          }              

        | PT.Expr.E_typed_pattern (body) => body
            
        | PT.Expr.E_quoted (parse_element) =>
          // we use Macros functions to translate quoted element
          Macros.in_pattern = true;          
          def lifted = 
            match (parse_element) {
              | PT.SyntaxElement.SyntaxExpr (e) => Macros.quoted_expr (ctx, e)
              | PT.SyntaxElement.SyntaxType (e) => Macros.quoted_type (ctx, e)
              | PT.SyntaxElement.SyntaxCase (e) => Macros.QuotedMatchCase (ctx, e)
              | PT.SyntaxElement.SyntaxCaseGuard (a, b) => Macros.QuotedCaseGuard (ctx, (a, b))
              | PT.SyntaxElement.SyntaxFunDecl (e) => Macros.quoted_fundecl (ctx, e)
              | PT.SyntaxElement.SyntaxFunParm (e) => Macros.quoted_fparam (ctx, e)
              | PT.SyntaxElement.SyntaxDeclaration (e) => Macros.quoted_member (ctx, e)                
              | PT.SyntaxElement.SyntaxTType =>
                Message.fatal_error ("matching over typed types not supported")
              | PT.SyntaxElement.SyntaxTTypeBuilder
              | PT.SyntaxElement.SyntaxTMethod
              | PT.SyntaxElement.SyntaxTEvent
              | PT.SyntaxElement.SyntaxTField
              | PT.SyntaxElement.SyntaxTProperty
              | PT.SyntaxElement.SyntaxTFunParm => 
                Util.ice ("strange syntax element appeared in quotation")
            };
          Macros.in_pattern = false;            
          walk (t, Macros.patternize_quotation (lifted))

        | PT.Expr.E_spliced =>
          Message.fatal_error ("$ operator may appear only within <[ ... ]> quotation")

        | PT.Expr.E_expr_list =>
          Message.fatal_error (".. arguments list may appear only within <[ ... ]> quotation")
          
        | _ => Message.fatal_error ("wrong pattern")
      }
    }
    and walk (t : Type, p : PT.Expr) : Pattern {
      def r = Util.locate (p.loc, do_walk (t, p));
      r.loc = p.loc;
      when (r.ty == null) r.ty = t; 
      r
    };


    def ty_pats (acc, patterns) {
      match (patterns) {
        | (pat, expr) :: rest =>
          vars = NemerleMap ();
          def typed_pattern = walk (matched_value_type, pat);
          
          def filter (n, d, m : NemerleMap <PT.Name, LocalValue>) {
            if (vars.Member (n))
              m.Add (n, d)
            else
              m
          };
          
          common_vars =
            match (common_vars) {
              | None => Some (vars)
              | Some (x) => Some (x.Fold (filter, NemerleMap ()))
            };

          def ctx' = ctx.WithLocals (vars.Fold (fun (_, d, acc) { d :: acc }, []));

          def expr =
            match (expr) {
              | None => 
                def ex = Expr.E_literal (Literal.L_bool (true));
                ex.loc = Location_stack.top ();
                ex
              | Some (x) => 
                def ex = Tyexpr.ty_expr (ctx', x);
                def bool_ty = InternalType.Boolean;
                Tyexpr.expect_type ("when guard", ex, bool_ty);
                ex
            };

          ty_pats ((typed_pattern, expr) :: acc, rest)
          
        | [] =>
          def addvar (_, d : LocalValue, acc) { 
            d.is_pattern_outcome = true; 
            d :: acc
          };
          (List.Rev (acc), ctx.WithLocals ((Option.UnSome (common_vars)).Fold (addvar, [])))
      }
      
    };

    ty_pats ([], patterns)
  }
  

}
}
