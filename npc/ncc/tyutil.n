open Nemerle.Compiler;
open Nemerle.Compiler.Tyutil;
open Nemerle.Compiler.Tyops;
open Nemerle.Collections;

namespace Nemerle.Compiler {

class Tyops
  {
    fun `/-` (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
  }
  
type Subst = Int_map(Type);

class Tyutil
  {
    fun subst (t : Type, s : Subst) : Type =
      letfun self (t : Type) : Type = subst (t, s) in
      match t with [
        | T_ref (?t) => T_ref (self (t))
        | T_out (?t) => T_out (self (t))
        | T_fun (?tl, ?t) => T_fun (List.map (self, tl), t)
        | T_void => t
        | T_prod (?tl) => T_prod (List.map (self, tl))
        | T_app (?tc, ?args, ?ref_to) =>
          T_app (tc, List.map (self, args), ref_to)
        | T_var (_, ?id) =>
          match s#find(id) with [
            | Some (?t') => t'
            | None => t
          ]
      ];
    
    fun make_subst (ini : Subst, parms : list (int), args : list (Type)) : Subst =
      match (parms, args) with [
        | (Cons (?p, ?ps), Cons (?a, ?args)) =>
          make_subst (ini#add (p, a), ps, args)
        | (Nil, Nil) => ini
        | _ => Util.ice ()
      ];
      
    fun make_subst (parms : list (int), args : list (Type)) : Subst =
       make_subst (Map.int_map (), parms, args);
    
    fun top_expand (t : Type) : Type =
      match t with [
        | T_app (_, ?args, ?ref_to) =>
          let td = (Tyinfo.lookup(ref_to))#tydecl in
          match td with [
            | TD_alias (?t) =>
              let sub = make_subst (Tyvars.get_parms (td#id), args) in
              top_expand (t /- sub)  // fixpoint iteration
            | _ => t
          ]
        | _ => t
      ];

    fun unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      letfun sub1 (t : Type) : Type =
        match t with [
          | T_var (_, ?id) =>
            match s#find(id) with [
              | Some (?t') => t'
              | None => t
            ]
          | _ => t
        ]
      in
      let t1 = sub1 (t1) in
      let t2 = sub1 (t2) in
      letfun unify_lists (s : Subst, t1 : list (Type), t2 : list (Type), 
                          allow_subtyping : bool) : option (Subst) =
        match (t1, t2) with [
          | (Cons (?t1, ?ts1), Cons (?t2, ?ts2)) =>
            match unify (s, t1, t2, allow_subtyping) with [
              | Some (?s') => unify_lists (s', ts1, ts2, allow_subtyping)
              | None => None ()
            ]
          | (Nil, Nil) => Some (s)
          | _ => None ()
        ]
      in
      match (t1, t2) with [
        | (T_ref (?t1), T_ref (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_out (?t1), T_out (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_prod (?l1), T_prod (?l2)) => 
          unify_lists (s, l1, l2, allow_subtyping)
        | (T_void, T_void) => Some (s)
        
        | (T_fun (?a1, ?r1), T_fun (?a2, ?r2)) =>
          match unify (s, r1, r2, allow_subtyping) with [
            | Some (?s) => unify_lists (s, a2, a1, allow_subtyping)
            | None => None ()
          ]

        | (T_app (_, ?a1, ?tc1), T_app (?tn, ?a2, ?tc2)) =>
          if tc1 == tc2 then 
            unify_lists (s, a1, a2, false)
          else
            if allow_subtyping then
              let ti1 = Tyinfo.lookup (tc1) in
              let ti2 = Tyinfo.lookup (tc2) in
              match ti1#how_subtypes (ti2#tydecl) with [
                | Some (?l) =>
                  let s = make_subst (s, Tyvars.get_parms (ti1#tydecl#id), a1) in
                  letfun f (t : option (Type)) : Type =
                    match t with [
                      | None => Tyvars.free_variable ()
                      | Some (?t) => t
                    ]
                  in let a1' = List.map (f, l) in
                  unify (s, T_app (tn, a1', tc2), t2, true)
                | None => None ()
              ]
            else 
              None ()
            
        | _ =>
          letfun unify_with_tyvar (t1 : Type, t2 : Type) : option (Subst) =
            match t1 with [
              | T_var (_, ?id1) =>
                if Tyvars.is_free (id1) then
                  match t2 with [
                    | T_var (_, ?id2) =>
                      if id1 == id2 then Some (s)
                      else Some (s#add (id1, t2))
                    | _ => Some (s#add (id1, t2))
                  ]
                else
                  None ()
              | _ => None ()
            ]
          in
          match unify_with_tyvar (t1, t2) with [
            | Some (?s) => Some (s)
            | None => unify_with_tyvar (t2, t1)
          ]
      ];
  }

} // ns
