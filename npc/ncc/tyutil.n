open Nemerle.Compiler;
open Nemerle.Compiler.Tyutil;
open Nemerle.Compiler.Tyops;
open Nemerle.Collections;

namespace Nemerle.Compiler {

class Tyops
  {
    fun `/-` (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
  }
  
type Subst = Int_map(Type);

class Tyutil
  {
    fun subst (t : Type, s : Subst) : Type =
      letfun self (t : Type) : Type = subst (t, s) in
      match t with [
        | T_ref (?t) => T_ref (self (t))
        | T_out (?t) => T_out (self (t))
        | T_fun (?tl, ?t) => T_fun (List.map (self, tl), t)
        | T_void => t
        | T_prod (?tl) => T_prod (List.map (self, tl))
        | T_app (?tc, ?args, ?ref_to) =>
          T_app (tc, List.map (self, args), ref_to)
        | T_var (_, ?id) =>
          match s#find(id) with [
            | Some (?t') => t'
            | None => t
          ]
      ];
    
    fun make_subst (ini : Subst, parms : list (int), args : list (Type)) : Subst =
      match (parms, args) with [
        | (Cons (?p, ?ps), Cons (?a, ?args)) =>
          make_subst (ini#add (p, a), ps, args)
        | (Nil, Nil) => ini
        | _ => Util.ice ()
      ];
      
    fun make_subst (parms : list (int), args : list (Type)) : Subst =
       make_subst (Map.int_map (), parms, args);
    
    fun make_subst (td : Type_decl, args : list (Type)) : Subst =
       make_subst (Map.int_map (), Tyvars.get_parms(td#id), args);

    fun fresh_vars (parms : list (int), t : Type) : Type =
      letfun mk_free (_ : int) : Type = Tyvars.free_variable () in
      t /- make_subst (parms, List.map (mk_free, parms));
      
    fun fresh_vars (td : Type_decl, t : Type) : Type =
      fresh_vars (Tyvars.get_parms(td#id), t);

    fun subst_of_app (t : Type) : Subst * Tyinfo =
      match t with [
        | T_app (_, ?args, ?ref_to) =>
          let ti = Tyinfo.lookup(ref_to) in
          (make_subst (ti#tydecl, args), ti)
        | _ => Util.ice()
      ];

    fun top_expand (t : Type) : Type =
      match t with [
        | T_app  =>
          let (?sub, ?ti) = subst_of_app (t) in
          match ti#tydecl with [
            | TD_alias (?t) =>
              top_expand (t /- sub)  // fixpoint iteration
            | _ => t
          ]
        | _ => t
      ];

    fun unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      letfun sub1 (t : Type) : Type =
        match t with [
          | T_var (_, ?id) =>
            match s#find(id) with [
              | Some (?t') => t'
              | None => t
            ]
          | _ => t
        ]
      in
      let t1 = sub1 (t1) in
      let t2 = sub1 (t2) in
      letfun unify_lists (s : Subst, t1 : list (Type), t2 : list (Type), 
                          allow_subtyping : bool) : option (Subst) =
        match (t1, t2) with [
          | (Cons (?t1, ?ts1), Cons (?t2, ?ts2)) =>
            match unify (s, t1, t2, allow_subtyping) with [
              | Some (?s') => unify_lists (s', ts1, ts2, allow_subtyping)
              | None => None ()
            ]
          | (Nil, Nil) => Some (s)
          | _ => None ()
        ]
      in
      match (t1, t2) with [
        | (T_ref (?t1), T_ref (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_out (?t1), T_out (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_prod (?l1), T_prod (?l2)) => 
          unify_lists (s, l1, l2, allow_subtyping)
        | (T_void, T_void) => Some (s)
        
        | (T_fun (?a1, ?r1), T_fun (?a2, ?r2)) =>
          match unify (s, r1, r2, allow_subtyping) with [
            | Some (?s) => unify_lists (s, a2, a1, allow_subtyping)
            | None => None ()
          ]

        | (T_app (_, ?a1, ?tc1), T_app (?tn, ?a2, ?tc2)) =>
          if tc1 == tc2 then 
            unify_lists (s, a1, a2, false)
          else
            if allow_subtyping then
              let ti1 = Tyinfo.lookup (tc1) in
              let ti2 = Tyinfo.lookup (tc2) in
              match ti1#how_subtypes (ti2#tydecl) with [
                | Some (?l) =>
                  let s = make_subst (s, Tyvars.get_parms (ti1#tydecl#id), a1) in
                  letfun f (t : option (Type)) : Type =
                    match t with [
                      | None => Tyvars.free_variable ()
                      | Some (?t) => t
                    ]
                  in let a1' = List.map (f, l) in
                  unify (s, T_app (tn, a1', tc2), t2, true)
                | None => None ()
              ]
            else 
              None ()
            
        | (T_var (_, ?id1), T_var (_, ?id2)) =>
          if id1 == id2 then Some (s)
          else
            if Tyvars.is_free (id1) then Some (s#add (id1, t2))
            else if Tyvars.is_free (id2) then Some (s#add (id2, t1))
            else None ()
        
        | _ =>
          letfun unify_with_tyvar (t1 : Type, t2 : Type) : option (Subst) =
            match t1 with [
              | T_var (_, ?id1) =>
                if Tyvars.is_free (id1) then Some (s#add (id1, t2))
                else None ()
              | _ => None ()
            ]
          in
          match unify_with_tyvar (t1, t2) with [
            | Some (?s) => Some (s)
            | None => unify_with_tyvar (t2, t1)
          ]
      ];

    fun unify (t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      unify (Map.int_map (), t1, t2, allow_subtyping);
    
    fun unify (t1 : Type, t2 : Type) : option (Subst) =
      unify (Map.int_map (), t1, t2, false);
   
    // FIXME: this might be broken (if there are free variables in types to
    // begin with)
    fun types_eq (a : Type, b : Type) : bool =
      match unify (a, b) with [
        | Some => true
        | None => false
      ];

    fun string_of_type (t : Type) : string =
      letfun map (sep : string, args : list (Type)) : string =
        Util.concat_strings(sep, List.map (string_of_type, args))
      in
      match t with [
        | T_app (?tc, ?args, ?ref_to) =>
          let name =
            if ref_to == 0 then tc
            else
              // be as fault tolerant as possible, this is for debug
              // and error messages.
              try (Tyinfo.lookup(ref_to))#fullname() 
              with ?x : ICE => tc
          in
          name + " (" + map (", ", args) + ")"
        | T_var (?n, ?id) => "'" + n + "_" + string_of_int (id)
        | T_ref (?t) => "ref " + string_of_type (t)
        | T_out (?t) => "out " + string_of_type (t)
        | T_void => "void"
        | T_prod (?args) => 
          "(" + map (" * ", args) + ")"
        | T_fun (?from, ?to) =>
          "(" + map (", ", from) + ") -> " + string_of_type (to)
      ];
    
    // Given function declaration, construct its type.
    fun fun_type (f : M_function) : Type = 
      let h = f#fun_header in
      let args = List.map (fun (p : Fun_parm) : Type => p#ty, h#parms) in
      T_fun (args, h#ret_type);
  }

} // ns
