using System;
using System.Text;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using Nemerle.Compiler;
using Nemerle.Collections.List;
using Nemerle.Utility;

public class Evaluator
{
 cmplr: ICodeCompiler;

 public this () {
  cmplr = NemerleCodeProvider ().CreateCompiler ();
 }

 public Eval (ret: Type, refr: list [string], 
              ns: list [string], code: string): object {
  def cp = CompilerParameters ();
  cp.GenerateInMemory = true;
  def re = NArray.FromList (typeof (string), refr);
  foreach (r in re)
   cp.ReferencedAssemblies.Add (r);
  def prog =
   FoldLeft (ns, "", fun (x: string, acc) { acc + "using " + x + ";\n" }) +
   "public module Exec {\n"
   " public static Foo(): " + ret.Name + " {\n"
   "  " + code + "\n"
   " }\n"
   "}\n";
  def cr = cmplr.CompileAssemblyFromSource (cp, prog);

  if (cr.Errors.HasErrors) {
   def error = StringBuilder ();
   foreach (err: CompilerError in cr.Errors)  
    error.Append (err.ErrorText + "\n");
   
   throw Exception (error.ToString ());
  }
  else {
   def a = Assembly.LoadFrom (cp.OutputAssembly);
   def mi = a.GetTypes ()[0].GetMethod ("Foo");
   mi.Invoke (null, null);
  }
 }
}
