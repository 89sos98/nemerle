(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

(** This pass operates on [Tyinfo] objects created for
    each type declaration found in source files.  These objects are
    already created, but most fields are empty.  The main function of
    this pass is [Tyinfo.run].  *)

public class Tyinfo implements Tycon {

  enclosing_type : option (Tyinfo);
  is_external : bool;
  id : int;

  public mutable pt_tydecl : PT.Type_decl; // xmldump

  mutable tydecl : Type_decl;
  mutable t_extends : option (Type);
  mutable t_implements : list (Type);
  mutable is_module : bool;
  name : string;
  public env : GlobalEnv;
  loc : Location;
  mutable modifiers : list (Modifier);
  mutable contained_types : list (Tyinfo);
  mutable typarms : list (Tyvar.T);
  public mutable tenv : Tyvar.TEnv;

  mutable subtypes : Int_map (Tycon * list (Type));
  mutable member_map : String_map (list (IMember));
  mutable member_list : list (IMember);
  mutable phase : int; // used by iter function
  // FIXME methods to implement

  mutable is_protected : bool;
  mutable is_public : bool;
  mutable is_internal : bool;

  static mutable infos : list (Tyinfo);

  (**
   * Return list of type parameters under which we subtype given type.
   *
   * <remarks>
   *   For example if [A ('a) :> B (int)], then ["A".SuperType ("B")]
   *   returns [[int]].
   *
   *   This information can be also fetched from [GetDirectSuperTypes()]
   *   method but this function is transitive.
   * </remarks>
   *)
  public SuperType (ti : Tycon) : option (list (Type))
  {
    Option.map (fun (_, x) { x }, this.subtypes.find (ti.GetId ()))
  }

  (** Return qualified type name. *)
  public GetFullName () : string
  {
    env.GetCurrentNamespace () + name
  }

  public GetId () : int
  {
    id
  }

  (** Return type we were defined in (null for toplevel types). *)
  public GetDeclaringTycon () : Tycon
  {
    match (enclosing_type) {
      | Some (ti) => ti
      | None => null
    }
  }

  (** Return name without any dots. *)
  public GetName () : string
  {
    name
  }

  public GetHandle () : System.Reflection.MemberInfo
  {
    null
  }

  public GetKind () : MemberKind
  {
    MK_type (this)
  }

  (**
   * Return list of types that we directly subtype.
   *
   * <remarks>
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   *)
  public GetDirectSuperTypes () : list (Type)
  {
    match (t_extends) {
      | Some (t) => t :: t_implements
      | None => t_implements
    }
  }

  (** Return type we extend if any. *)
  public SuperClass () : option (Tycon)
  {
    match (t_extends) {
      | Some (T_app (ti, _)) => Some (ti)
      | _ => None ()
    }
  }

  public SetContainedTypes (ct : list (Tyinfo)) : void
  {
    contained_types <- ct;
  }

  (**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * <remarks>
   *   Used mainly with [FreshSubst ()] or [MakeSubst ()].
   * </remarks>
   *)
  public GetMemType () : Type
  {
    def make_tv (tv : Tyvar.T) : Type { T_var (tv) };
    T_app (this, List.map (make_tv, this.typarms))
  }


  (**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   *)
  public FreshSubst () : Subst
  {
    Tyvar.fresh_subst (this.typarms)
  }

  (**
   * Construct substitution resulting from applying this type constructor
   * to specified arguments.
   *
   * <remarks>
   *   For example assuming our type parameters are are ('a, 'b), then
   *   [MakeSubst ([t1, t2])] produces substitution { 'a := t1; 'b := t2 }.
   * </remarks>
   *)
  public MakeSubst (args : list (Type)) : Subst
  {
    def loop (ini : Subst, parms : list (Tyvar.T), args : list (Type)) : Subst {
      match ((parms, args)) {
        | (p :: ps, a :: args) =>
          match (a) {
            | T_var (p') =>
              if (p.id == p'.id) ini
              else loop (ini.add (p.id, a), ps, args)
            | _ => loop (ini.add (p.id, a), ps, args)
          }
        | ([], []) => ini
        | _ => Util.ice ()
      }
    };

    def len_tp = List.length (this.typarms);
    def len_ac = List.length (args);

    if (len_tp == len_ac) {
      def sub = loop (Map.int_map (), this.typarms, args);

      def check_constraints (tv : Tyvar.T, t : Type) : void {
        def check_constraint (c : Type) : void {
          unless (t >> (c /- sub)) {
              Message.error ("typing constraint '" + tv.name +
                             " :> " + c.as_string () + " is not satisfied");
              Message.error ("by " + t.as_string () + " :> " + (c /- sub).as_string ());
              Message.error (loc, "upon instantiation of " + GetFullName ())
          }
        };
        List.iter (check_constraint, Tyvar.constraints (tv))
      };
      List.iter2 (check_constraints, typarms, args);

      sub
    } else {
      Message.error ("type `" + GetFullName () + "' takes " +
                     string_of_int (len_tp) + " argument(s) while " +
                     string_of_int (len_ac) + " were supplied");
      Map.int_map ()
    }
  }

  type Subinfo = Int_map (Tycon * list (Type));

  public GetTyconKind () : TyconKind
  {
    TK_NemerleType (this)
  }

  public GetTydecl () : Type_decl
  {
    tydecl
  }

  public SameAs (tc : Tycon) : bool
  {
    tc.GetId () == GetId ()
  }

  public GetModifiers () : list (Modifier)
  {
    modifiers
  }

  public IsStatic () : bool
  {
    true
  }

  public LookupMember (name : string, lf : LookupFlag) : list (IMember)
  {
    match (member_map.find (name)) {
      | None => []
      | Some (mems) => Tyutil.FilterMembers (mems, lf)
    }
  }

  (**
   * Iterate over all types defined in source code.
   *
   * <remarks>
   *   Supertypes are always processed before subtypes otherwise
   *   source code order is retained.
   * </remarks>
   *)
  public static Iter (f : Tyinfo -> void) : void
  {
    def working_on = Util.next_id ();
    def done = Util.next_id ();
    def sub_do (t : Type) : void {
      match (t) {
        | T_app (ti, _) =>
          match (ti.GetTyconKind ()) {
            | TK_NemerleType (exact) => maybe_f (exact)
            | _ => ()
          }
        | _ => ()
      }
    }
    and maybe_f (ti : Tyinfo) : void {
      if (ti.is_external || ti.phase == done) ()
      else if (ti.phase == working_on)
        Message.error(ti.loc, "type definition for `" + ti.GetFullName () + "' is cyclic")
      else {
        ti.phase <- working_on;
        Util.locate (ti.loc, fun () : void {
          List.iter (sub_do, ti.GetDirectSuperTypes ());
          f (ti)
        });
        ti.phase <- done
      }
    };

    List.iter (maybe_f, infos);
  }

  (**
   * Return substitution to apply to types of members of our supertype [ti]
   * to get types of members in [this].
   *
   * <remarks>
   *    For example consider:
   *    [[[
   *      class A ('a) { f : 'a; }
   *      class B extends A (int) { }
   *    ]]]
   *    Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
   *    it can be applied to type of [A.f] which is ['a], to obtain type
   *    of [B.f] which is [int].
   * </remarks>
   *)
  public SubtypingSubst (tc : Tycon) : Subst
  {
    if (tc.GetId () == GetId ())
      Map.int_map () // current type, no substitution
    else
      tc.MakeSubst (Option.unsome (SuperType (tc)));
  }

  (**
   * Iterate over top level types in source code order.
   *)
  public static top_iter (f : Tyinfo -> void) : void
  {
    def phase = Util.next_id ();

    def wrap (x : Tyinfo) : void {
      if (x.phase == phase) ()
      else {
        x.phase <- phase;
        match (x.enclosing_type) {
          | Some => ()
          | None => Util.locate (x.loc, fun () : void { f (x) })
        };
      }
    };
    List.iter (wrap, infos);
  }

  public this (par : option (Tyinfo), env : GlobalEnv, td : PT.Type_decl)
  {
    this.enclosing_type <- par;
    this.pt_tydecl <- td;
    this.env <- env;
    this.name <- td.name;
    this.modifiers <- td.modifiers;
    this.loc <- td.loc;

    this.id <- Util.next_id ();

    infos <- this :: infos;

    def parse_mod (mod) {
      match (mod) {
        | Mod_public => is_public <- true
        | Mod_internal => is_internal <- true
        | Mod_protected => is_protected <- true
        | _ => ()
      }
    };
    when (Option.is_none (enclosing_type))
      is_internal <- true;
    List.iter (parse_mod, td.modifiers);
  }

  public CanAccess (source : Tycon) : bool
  {
    is_public || 
    (is_internal && 
      match (source.GetTyconKind ()) { 
        | TK_NemerleType => true 
        | _ => false 
      }) || 
    (is_protected &&
        match (enclosing_type) {
          | Some (tc) => Option.is_some (source.SuperType (tc))
          | None => false
        }) ||
    match (enclosing_type) {
      | Some (declaring_type) =>
        def walk_declaring (tc : Tycon) {
          tc.SameAs (source) || 
            (tc.GetDeclaringTycon () != null && walk_declaring (tc.GetDeclaringTycon ()))
        };
        walk_declaring (source)
      | None => false
    }
  }

  (**
   * Construct typing environments for each declaration.
   *
   * <remarks>
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   *)
  make_tyenvs (tenv : Tyvar.TEnv) : void
  {
    assert (this.tenv == null);
    def (tenv, tyvars) = tenv.add_typarms (this.env, this.pt_tydecl.typarms,
                                           check_parms = false);
    this.tenv <- tenv;
    this.typarms <- tyvars;

    def bind_child (x : Tyinfo) : void {
      Util.locate (x.loc, fun () : void { x.make_tyenvs (tenv) });
      match (x.pt_tydecl) {
        | PT.TD_variant_option (members) =>
          unless (Util.is_capitalized (x.pt_tydecl.name)) {
            Message.error (x.loc, "variant options names must start with capital letters")
          };
          x.typarms <- tyvars;
          x.modifiers <- Mod_public () :: Mod_sealed () :: x.modifiers;
          x.is_public <- true;
          def make_public (d : PT.Class_member) : void {
            d.modifiers <- Mod_public () :: d.modifiers
          };
          List.iter (make_public, members)
        | PT.TD_variant =>
          x.modifiers <- Mod_abstract () :: x.modifiers
        | _ => ()
      }
    };
    List.iter (bind_child, this.contained_types);
  }


  (**
   * Bind type expressions occurring in type declarations. This
   * includes [extends] type, [implements] list, and aliased type
   * in case of type alias declaration.
   *
   * <remarks>
   *   Binding type expression refers to rewriting [Parsetree.Type]
   *   into [Typedtree.Type], which involves resolving names of type
   *   constructors (to [Tyinfo] objects) and type variables (to [Tyvar.T]
   *   objects).
   * </remarks>
   *)
  bind_types () : void
  {
    def bind (t : PT.Type) : Type { this.tenv.bind (this.env, t, check_parms = false) };
    def td = this.pt_tydecl;
    def check_module (x : Modifier) : void {
      match (x) {
        | Mod_module => this.is_module <- true
        | _ => ()
      }
    };
    List.iter (check_module, this.modifiers);
    this.tydecl <-
      match (td) {
        | PT.TD_class => TD_class ()
        | PT.TD_alias (t) => TD_alias (bind (t))
        | PT.TD_interface => TD_interface ()
        | PT.TD_external (n) => TD_external (n)
        | PT.TD_variant => TD_variant ()
        | PT.TD_variant_option (decls) => TD_variant_option (Tyutil.encode_variant_option (decls))
        | PT.TD_macro  => TD_class ()
      };
    this.t_extends <-
      match (td) {
        | PT.TD_variant_option => Some (GetDeclaringTycon ().GetMemType ())
        | _ => Option.map (bind, td.t_extends)
      };
    this.t_implements <- List.map (bind, td.t_implements);
  }

  (**
   * Construct datastructures we use to check subtyping relations.
   *
   * <remarks>
   *   This probably the hardest part of processing type declarations.
   *
   *   Each type directly subtypes types it extends or implements.  This
   *   pass computes transitive closure of direct subtyping relation
   *   and stores it [Tyinfo.subtypes] map.  .NET generics doesn't allow
   *   same type to be subtyped under different instantiations, so we
   *   use map from (id of) subtyped Tyinfo object to actual parameters
   *   of subtyped type.
   * </remarks>
   *)
  static determine_subtyping () : void
  {
    def make_srs (ti : Tyinfo) : void {
      def add_srs (s : Subinfo, t : Type) : Subinfo {
        match (t) {
          | T_app (ti', args) => ti.add_subtyping_of (s, ti', args)
          | _ =>
            Message.error("cannot implement nor extend non-class type");
            s
        }
      };
      ti.subtypes <- List.fold_left (add_srs, Map.int_map (), ti.GetDirectSuperTypes ())
    };
    Iter (make_srs);
  }

  add_subtyping_of (subinfo : Subinfo, tc : Tycon, args : list (Type)) : Subinfo
  {
    def add_sr (subinfo : Subinfo, subtyped : Tycon, args : list (Type)) {
      match (subinfo.find (subtyped.GetId ())) {
        | Some ((_, args')) =>
          mutable problem <- "";
          def check_eq (t1 : Type, t2 : Type) : bool {
            if (Tyutil.types_eq (t1, t2)) true
            else {
              problem <- "types " + t1.as_string() + " and " +
                         t2.as_string() + " are not compatible";
              false
            }
          };
          unless (List.forall2 (check_eq, args, args')) {
            Message.error ("type `" + subtyped.GetFullName () +
                           "' is implemented by type `" +
                           GetFullName() +
                           "' twice under different instantiations");
            if (tc.GetId () == subtyped.GetId ())
              Message.error ("second one directly")
            else
              Message.error ("second one through `" + tc.GetFullName () + "'");
            Message.error (problem);
          };
          subinfo
        | None =>
          subinfo.add (subtyped.GetId (), (subtyped, args))
      }
    };

    def sub = tc.MakeSubst (args);

    def add_srt (subinfo : Subinfo, t : Type) {
      match (t) {
        | T_app (tc, args) =>
          add_sr (subinfo, tc, List.map (fun (t) { t /- sub }, args))
        | _ => Util.ice ("extending non-class type")
      }
    };

    def subinfo = List.fold_left (add_srt, subinfo, tc.GetSuperTypes ());
    def subinfo = add_sr (subinfo, tc, args);
    subinfo
  }

  public GetSuperTypes () : list (Type)
  {
    subtypes.fold (fun (acc, _, x) {
                      def (tc, args) = x;
                      T_app (tc, args) :: acc },
                   [])
  }

  begin_adding_members () : void
  {
    member_map <-
      match (t_extends) {
        | Some (T_app (tc, args)) =>
          def inherit_it (mem : IMember) {
            !mem.IsStatic () &&
              match (mem.GetKind ()) {
                | MK_method (mem) =>
                  match (mem.GetFunKind ()) {
                    | FK_ctor => false
                    | _ => true
                  }
                | _ => true
              }
          };
          def add (map : String_map (list (IMember)), mem : IMember) {
            if (inherit_it (mem)) {
              def n = mem.GetName ();
              match (map.find (n)) {
                | Some (l) => map.replace (n, mem :: l)
                | None => map.add (n, [mem])
              }
            } else
              map
          };
          List.fold_left (add, Map.string_map (), tc.GetMembers ())
        | _ => Map.string_map ()
      };
    member_list <- []
  }

  public GetMembers () : list (IMember)
  {
    def maybe_add (acc, m : IMember) {
      if (m.GetDeclaringTycon ().SameAs (this))
        acc
      else
        m :: acc
    };
    def maybe_add_few (acc, _, mems) {
      List.fold_left (maybe_add, acc, mems)
    };

    // retain order of member_list
    member_map.fold (maybe_add_few, member_list)
  }

  public BindType (t : PT.Type) : Type
  {
    tenv.bind (env, t)
  }

  public BindType (other_tenv : Tyvar.TEnv, t : PT.Type) : Type
  {
    other_tenv.bind (env, t)
  }

  public BindTyparms (tp : PT.Typarms) : Tyvar.TEnv * list (Tyvar.T)
  {
    tenv.add_typarms (env, tp)
  }

  (** Check if types that are already bound are correctly applied. *)
  check_bound_types () : void
  {
    def types =
      match (tydecl) {
        | TD_alias (t) => t :: GetDirectSuperTypes ()
        | _ => GetDirectSuperTypes ()
      };
    def check_type (t) {
      match (t) {
        | T_ref (t) => check_type (t)
        | T_out (t) => check_type (t)
        | T_array (t) => check_type (t)
        | T_fun (ts, t) => check_type (ts); check_type (t)
        | T_void => ()
        | T_prod (ts) => List.iter (check_type, ts)
        | T_var => ()
        | T_app (ti, args) =>
          List.iter (check_type, args);
          ignore (ti.MakeSubst (args));
      }
    };
    def check_constraints_in_tv (tv) {
      List.iter (check_type, Tyvar.constraints (tv))
    };
    List.iter (check_type, types);
    List.iter (check_constraints_in_tv, typarms);
  }

  describe_member (m : IMember) : string
  {
    def kind =
      match (m.GetKind ()) {
        | MK_field => "field"
        | MK_method => "method"
        | MK_property => "proprty"
        | MK_type => "type"
      };
    "a " + kind + " `" + m.GetName () + "'"
  }

  public GetLocation () : Location
  {
    loc
  }

  public BindAndAddMember (class_member : PT.Class_member) : void
  {
    Util.locate (class_member.loc, fun () {
      when (is_module)
        class_member.modifiers <- Mod_static () :: class_member.modifiers;
      match (class_member) {
        | PT.M_type => ()
        | PT.M_property => Util.ice ("bind_member on property")
        | (PT.M_field) as f => AddMember (NemerleField (this, f))
        | (PT.M_function) as f => AddMember (NemerleMethod (this, f))
      }
    })
  }

  public AddMember (mem : IMember) : void
  {
    def replace_method (acc, meth : IMethod, mems) {
      match (mems) {
        | [] => mem :: acc
        | x :: xs =>
          match ((x : IMember).GetKind ()) {
            | MK_method (m) =>
              def sub = SubtypingSubst (m.GetDeclaringTycon ());
              if (Tyutil.types_eq (m.GetMemType () /- sub, mem.GetMemType ())) {
                match (m.GetFunKind ()) {
                  | FK_ctor | FK_static_ctor => ()
                  | _ when Util.is_new (mem) => ()
                  | _ =>
                    Message.error (mem.GetLocation (), describe_member (mem) +
                                   " in `" + GetFullName () + "' hides " + describe_member (x) +
                                   " from parent (" + x.GetDeclaringTycon ().GetFullName () +
                                   ") but no `new' specified")
                };
                List.rev_append (xs, mem :: acc)
              } else replace_method (x :: acc, meth, xs)
            | _ => Util.ice ("expecting method, got " + describe_member (x))
          }
      }
    };

    def new_mems =
      match (member_map.find (mem.GetName ())) {
        | Some ([]) => Util.ice ()
        | Some ((x :: _) as old) =>
          if (x.GetDeclaringTycon ().SameAs (this))
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " redefined in `" + GetFullName () + "'");
                Message.error (x.GetLocation (), "  first definition here as " +
                               describe_member (x));
                [mem]
            }
          else
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | _ when Util.is_new (mem) => [mem]
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " in `" + GetFullName () + "' hides " + describe_member (x) +
                               " from parent (" + x.GetDeclaringTycon ().GetFullName () +
                               ") but no `new' specified");
                [mem]
            }

        | None => [mem]
      };

    member_map <- member_map.replace (mem.GetName (), new_mems);
    member_list <- mem :: member_list;
  }

  (** Return list of all members defined in this very type. *)
  public GetDirectMembers () : list (IMember)
  {
    member_list
  }

  (**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [Tyinfo.contained_types]) and store
   * them in [Tyinfo.member_map] and [Tyinfo.member_list].
   *
   * <remarks>
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   *)
  add_members () : void
  {
    begin_adding_members ();
    def decls =
      match (pt_tydecl) {
        | PT.TD_class (ds) => ds
        | PT.TD_interface (ds) => ds
        | PT.TD_variant_option (ds) => ds
        | _ => []
      };
    List.iter (BindAndAddMember, decls);

    contained_types <- List.rev (contained_types);
    member_list <- List.rev (member_list);

    List.iter ((AddMember : Tyinfo -> void), contained_types);

    // we no longer need it, let GC kill it
    pt_tydecl <- null;
  }

  (**
   * Add record-like constructor to some classes.
   *
   * <remarks>
   *   Record like constructor looks like this:
   *
   *   [[[
   *     this (x : int, y : string) {
   *       this.x <- x;
   *       this.y <- y;
   *     }
   *   ]]]
   *
   *   Constructor building function is in extensions.n.
   * </remarks>
   *)
  add_implicit_ctor () : void
  {
    def add_implicit_ctors () {
      List.iter (AddMember, Extensions.implicit_ctor (this))
    };
    match (tydecl) {
      | TD_class =>
        def is_field (m : IMember) {
          if (m.GetDeclaringTycon ().SameAs (this))
            match (m.GetKind ()) {
              | MK_field => true
              | _ => false
            }
          else true
        };
        // FIXME: invent some better rule when to add it..
        match (GetDirectSuperTypes ()) {
          | [] when List.forall (is_field, GetMembers ()) =>
            add_implicit_ctors ()
          | _ => ()
        }

      | TD_variant_option
      | TD_variant => add_implicit_ctors ()

      | _ => ()
    }
  }

  static this ()
  {
    infos <- [];
  }

  (**
   * Main function of type declaration handling pass.
   *
   * <remarks>
   *   - constructing typing environments [Tyinfo.make_tyenvs]
   *   - binding types [Tyinfo.bind_types]
   *   - determining subtyping relations [Tyinfo.determine_subtyping]
   *   - checking subtyping constraints on types that are already bound
   *     [Tyinfo.check_bound_types]
   *   - adding members [Tyinfo.add_members]
   *   - making implicit constructors [Tyinfo.add_implicit_ctor]
   * </remarks>
   *)
  public static Run () : void
  {
    infos <- List.rev (infos);
    top_iter (fun (x : Tyinfo) : void { x.make_tyenvs (Tyvar.TEnv ()) });

    def bind_types (x : Tyinfo) : void {
      Util.locate (x.loc, fun () : void { x.bind_types () })
    };
    List.iter (bind_types, infos);

    determine_subtyping ();
    Iter (fun (x : Tyinfo) { x.check_bound_types () });
    Iter (fun (x : Tyinfo) { x.add_members () });
    Iter (fun (x : Tyinfo) { x.add_implicit_ctor () });
  }

}

} // ns
