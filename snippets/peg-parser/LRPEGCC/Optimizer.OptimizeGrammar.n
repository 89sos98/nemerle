using System;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

namespace LRPEGCC
{
  partial internal class Optimizer
  {
    private static FindActiveRules(start : RuleRef, rules : Grammar) : Set[RuleRef]
    {
      def findActiveRules(rule, activeRulesNames : Set[RuleRef])
      {
        match (rule : Rule)
        {
        | Call(name)=>
          if (activeRulesNames.Contains(name))
            activeRulesNames;
          else
            findActiveRules(rules.GetRule(name), activeRulesNames.Add(name));

        | Choice(rules)
        | Sequence(rules)          => rules.Fold(activeRulesNames, (rule, activeRulesNames) => findActiveRules(rule, activeRulesNames));

        | Capture(_, rule)
        | RepeatMin(_, rule)
        | RepeatMinMax(_, _, rule)
        | Not(rule)
        | And(rule)                => findActiveRules(rule, activeRulesNames);

        | Chars
        | ExtensionPoint           => activeRulesNames;
        }
      }
      findActiveRules(rules.GetRule(start), Set().Add(start));
    }

    public static CalcRulesWeights(grammar : Grammar) : Map[RuleRef, option[int]]
    {
      def getRuleWeight(name : RuleRef, weights : Map[RuleRef, option[int]]) : option[int] * Map[RuleRef, option[int]]
      {
        def calc(weights, rule)
        {
          def add(_, _)
          {
            | (Some(weight1), Some(weight2)) => Some(weight1 + weight2);
            | _ => None();
          }
          def (weight, weights) = match (rule : Rule)
          {
            | Call(name)               =>
              getRuleWeight(name, weights);

            | Choice(rules)
            | Sequence(rules)          =>
              def fn(rule, (weight1, weights))
              {
                def (weight2, weights) = calc(weights, rule);
                (add(weight1, weight2), weights);
              }

              rules.Fold((Some(0), weights), fn);

            | Capture(_, rule)
            | RepeatMin(_, rule)
            | RepeatMinMax(_, _, rule)
            | Not(rule)
            | And(rule)                =>
              calc(weights, rule);

            | Chars
            | ExtensionPoint           =>
              (Some(0), weights);
          }
          (add(weight, Some(1)), weights);
        }

        if (weights.Contains(name))
        {
          (weights.Get(name), weights)
        }
        else
        {
          def weights = weights.Add(name, None());
          def rule = grammar.GetRule(name);
          def (weight, weights) = calc(weights, rule);
          (weight, weights.Replace(name, weight))
        }
      }
      grammar.Names.Fold(Map(), (name, weights) =>
      {
        def (_, weights) = getRuleWeight(name, weights);
        weights;
      });
    }

    public static OptimizeGrammar(grammar : Grammar) : Grammar
    {
      def weights = CalcRulesWeights(grammar);
      def grammar = grammar.Names.Fold(Grammar(grammar.StartRuleName), (name, newGrammar) =>
      {
        newGrammar.Add(name, OptimizeRule(grammar.GetRule(name), grammar, weights));
      });

      def activeRulesNames = FindActiveRules(grammar.StartRuleName, grammar);

      activeRulesNames.Fold(Grammar(grammar.StartRuleName), (name, newGrammar) =>
      {
        newGrammar.Add(name, grammar.GetRule(name));
      });
    }
  }
}
