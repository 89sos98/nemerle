(*
 * Copyright (c) 2003 University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Compiler;
  open Nemerle.Compiler.Tyops;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Collections;
  
  open System.Reflection;
  open System.Reflection.Emit;


  (**
   * An IL code generator
   *)
  public class CGIL
  {
    (* -- PUBLIC CONSTRUCTORS ---------------------------------------------- *)
    
    public this (target_exe : bool, output_file_name : string)
    {
      _output_file_name <- output_file_name;
    
      (* create the type builder queue *)
      this._type_builder_queue <- Queue ();
                  
      (* create a weak assembly name and define a dynamic assembly *)
      this._assembly_name <- System.Reflection.AssemblyName ();
      this._assembly_name.Version <- System.Version (1, 0, 0, 0); // FIXME
      this._assembly_name.Name <- "NemerleGeneratedAssembly"; // FIXME

      this._assembly_builder <- 
        System.AppDomain.CurrentDomain.DefineDynamicAssembly 
          (this._assembly_name, AssemblyBuilderAccess.RunAndSave);

      (* create a dynamic module *)
      this._module_builder <- 
        this._assembly_builder.DefineDynamicModule ("NemerleGeneratedModule", 
                                                    output_file_name, true); // FIXME

      when (target_exe) {
        _need_entry_point <- true;
        _entry_point <- None ();
      };

      _aux_types <- [];
    }


    (**
     *
     *)
    public EmitAuxDecls () : void
    {
      compile_all_tyinfos (true)
    }


    (**
     *
     *)    
    public EmitDecls () : void
    {
      compile_all_tyinfos (false)
    }


    (** 
     * Outputs objects from cgtree.n as IL code. 
     *)
    public ProcessDecls () : void
    {
      (* FIXME: this has to go elsewhere
    
      // select the classes that have to be generated separately
      def (aux_decls, standard_decls) =
        this.select_aux_and_standard_decls (decls);

      // process the declarations
      def add_classes (decl) { this.make_class (decl, null) };
      def add_declarations (tree) { this.add_declarations (tree, null) }; // FIXME: aargh
      def add_implementations (tree) { this.add_implementations (tree) }; // FIXME: aargh

      // emit the auxiliary declarations
      this._emit_nemerle_attributes <- false;

      def aux_classes_tree = List.map (add_classes, aux_decls);
      def aux_declarations_tree = List.map (add_declarations, aux_classes_tree);
      def _ = List.map (add_implementations, aux_declarations_tree);

      // execute the type builder queue
      create_types_in_queue ();

      // emit all the other declarations
      this._emit_nemerle_attributes <- true;

      def classes_tree = List.map (add_classes, standard_decls);
      def declarations_tree = List.map (add_declarations, classes_tree);
      def _ = List.map (add_implementations, declarations_tree);

      // execute the type builder queue
      create_types_in_queue ();
    
      *)
    }


    (**
     * Saves the constructed assembly to a file
     *)
    public SaveAssembly () : void 
    {
      // set the entry point
      match ((_need_entry_point, _entry_point)) {
        | (true, Some (entry_point_method_info)) =>
          _assembly_builder.SetEntryPoint (entry_point_method_info, PEFileKinds.ConsoleApplication)
        | (true, None) =>
          Message.error ("no suitable entry point (Main function) found")
        | _ => ()
      };

      // save the assembly
      _assembly_builder.Save (_output_file_name);
    }

    (**
     * Tell IL generator that we have created type instance elsewhere, and
     * it needs to get finalized before saving an assembly.
     *)
    public RegisterAuxType (tb : TypeBuilder) : void
    {
      _aux_types <- tb :: _aux_types;
    }


    (* -- PRIVATE METHODS -------------------------------------------------- *)

    (**
     *
     *)
    emit_implementation (ti : Tyinfo) : void
    {
      def emit_member (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            CGexpr.CompileMethod ((m :> NemerleMethod))
          | _ => ()
        }
      };
      List.iter (emit_member, ti.GetDirectMembers ());
      //Message.debug ("finalizing " + ti.GetFullName ());
      ti.FinalizeType ();
    }


    finalize_aux_types () : void
    {
      List.iter (fun (x : TypeBuilder) { ignore (x.CreateType ()) }, _aux_types);
      _aux_types <- [];
    }
    

    (**
     *
     *)
    compile_all_tyinfos (aux_phase : bool) : void
    {
      def allow_it (ti : Tyinfo) {
        is_aux_decl (ti) == aux_phase &&
        match (ti.GetTydecl ()) {
          | TD_alias | TD_external => false
          | _ => true
        }
      };
      def set_type_builder (ti : Tyinfo) {
        when (allow_it (ti)) {
          // Message.debug ("make type builder for " + ti.GetFullName ());
          ti.ConstructTypeBuilder ()
        }
      };
      def emit_decls (ti : Tyinfo) {
        when (allow_it (ti)) {
          //Message.debug ("generating declarations " + ti.GetFullName ());
          add_declarations (ti)
        }
      };
      def emit_impl (ti : Tyinfo) {
        when (allow_it (ti)) {
          //Message.debug ("generating code for " + ti.GetFullName ());
          emit_implementation (ti)
        }
      };

      //this._emit_nemerle_attributes <- !aux_phase;
      this._emit_nemerle_attributes <- false;

      Tyinfo.Iter (set_type_builder);
      Tyinfo.Iter (emit_decls);
      Tyinfo.Iter (emit_impl);
      Message.maybe_bailout ();
      finalize_aux_types ();
    }


    (**
     * Calls the CreateType method for all the elements in the queue.
     * The queue is cleared after the types have been created.
     *)
    private create_types_in_queue () : void
    {
      def create_type (tb : TypeBuilder) : void {
        // Message.debug ("CreateType " + tb.FullName);
        def _ = tb.CreateType ();
        ()
      };      
    
      _type_builder_queue.iter (create_type);
      _type_builder_queue.clear ();
    }
    
    
    (**
     * Check if declaration is auxiliary, used internally etc.
     *)
    private is_aux_decl (ti : Tyinfo) : bool
    {
      def tn = ti.GetFullName ();
      
      tn == "Nemerle.Func0" || tn == "Nemerle.Func1" ||
      tn == "Nemerle.Func2" || tn == "Nemerle.Func3" ||
      tn == "Nemerle.Func4" || tn == "Nemerle.Func5" || 
      tn == "Nemerle.Func6" || tn == "Nemerle.Func7" || 
      tn == "Nemerle.VariantOptionAttribute" ||
      tn == "Nemerle.VariantAttribute" || 
      tn == "Nemerle.TypeAttribute" ||
      tn == "Nemerle.Core.Null_match"
    }
    
    
    (**
     * Builds a Nemerle type attribute
     *)
    private make_nemerle_type_attr (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.TypeAttribute");
      def constructor_param_types = mkarray [reflect_type ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      assert (constructor_info != null);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     * Builds a Nemerle variant attribute
     *)
    private make_nemerle_variant_attribute () : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.VariantAttribute");
      def empty_types_array = (System.Array.CreateInstance (typeof(System.Type), 0) :> array (System.Type));
      def constructor_info = attr_type.GetConstructor (empty_types_array);
      def attr_builder = CustomAttributeBuilder (constructor_info, (mkarray [] :> array (System.Object)));
      attr_builder
    }
    

    (**
     * Builds a Nemerle variant option attribute
     *)
    private make_nemerle_variant_option_attribute (encoded_type : string) : CustomAttributeBuilder
    {
      def attr_type = reflect_type ("Nemerle.VariantOptionAttribute");
      def constructor_param_types = mkarray [reflect_type ("System.String")];
      def constructor_info = attr_type.GetConstructor (constructor_param_types);
      def constructor_params = mkarray [encoded_type];
      def attr_builder = CustomAttributeBuilder (constructor_info, (constructor_params :> array (System.Object)));
      attr_builder
    }


    (**
     * Encodes a reflected type name. This allows us to store all types
     * in one hashtable and still have control on where they have been
     * reflected from. 
     *)
    private encode_reflected_type_name (type_name : string, scan_externals : bool, 
                                        scan_system : bool) : string
    {
      type_name + "%%" +
        (if (scan_externals) "" else "-E") +
        (if (scan_system) "" else "-S");
    }
        

    (**
     * Reflects a type using GlobalEnv
     *)
    internal static reflect_type (type_name : string) : System.Type
    {
      match (GlobalEnv.LookupExactType (type_name)) {
        | Some (tc) => tc.GetSystemType ()
        | _ => null
      }
    }


    (**
     * Extracts the part before the last dot and after the last dot in a string.
     *)
    internal split_global_ref (global_ref : string) : string * string
    {
      def last_dot = global_ref.LastIndexOf ('.');
      assert (last_dot != -1);

      (global_ref.Substring (0, last_dot), global_ref.Substring (last_dot + 1))
    }    
    
    
    (**
     * Converts Nemerle field modifiers to the CLI field attributes.
     *)
    private make_field_attributes (attrs : list (Modifier)) : FieldAttributes
    {
      def process_modifier (modifier : Modifier) : FieldAttributes {
        | Mod_public => FieldAttributes.Public
        | Mod_private => FieldAttributes.Private
        | Mod_new => (0 :> FieldAttributes)
        | Mod_protected => FieldAttributes.Family
        | Mod_internal => FieldAttributes.FamORAssem
        | Mod_abstract => Util.ice ("Mod_abstract is not supported for fields")
        | Mod_virtual => Util.ice ("Mod_virtual is not supported for fields")
        | Mod_sealed => Util.ice ("Mod_sealed is not supported for fields")
        | Mod_static => FieldAttributes.Static
        | Mod_struct => Util.ice ("Mod_struct is not supported for fields")
        | Mod_module => Util.ice ("Mod_module is not supported for fields")
        | Mod_macro => Util.ice ("Mod_macro is not supported for fields")
        | Mod_attribute => Util.ice ("Mod_attribute is not yet supported") // FIXME
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) %| this.make_field_attributes (rest)
        | [] =>
          FieldAttributes.PrivateScope
      }
    }


    (**
     * Converts Nemerle method modifiers to the CLI method attributes.
     *)
    private make_method_attributes (attrs : list (Modifier)) : MethodAttributes
    {
      def process_modifier (modifier : Modifier) : MethodAttributes {
        | Mod_public => MethodAttributes.Public
        | Mod_private => MethodAttributes.Private
        | Mod_new => MethodAttributes.NewSlot
        | Mod_protected => MethodAttributes.Family
        | Mod_internal => MethodAttributes.FamORAssem
        | Mod_abstract => MethodAttributes.Abstract
        | Mod_virtual => MethodAttributes.Virtual
        | Mod_sealed => Util.ice ("Mod_sealed is not supported for methods")
        | Mod_static => MethodAttributes.Static
        | Mod_struct => Util.ice ("Mod_struct is not supported for methods")
        | Mod_module => Util.ice ("Mod_module is not supported for methods")
        | Mod_macro => Util.ice ("Mod_macro is not supported for methods")
        | Mod_attribute => Util.ice ("Mod_attribute is not yet supported") // FIXME
      };
        
      match (attrs) {
        | modifier :: rest =>
          process_modifier (modifier) %| this.make_method_attributes (rest)
        | [] =>
          MethodAttributes.HideBySig
      }
    }


    (**
     * Converts a System.Type list to a System.Type array.
     * FIXME: mkarray (x) won't work here as the list's length is not know.
     *)  
    internal type_list_to_type_array (x : list (System.Type)) : array (System.Type) {

      def result = 
        (System.Array.CreateInstance (typeof (System.Type), List.length (x)) :> array (System.Type));
      
      def loop (index : int, x : list (System.Type)) : void {        
        match (x) {
          | head :: tail =>
            result [index] <- (head :> System.Type);
            loop (index + 1, tail)
          | [] => ()
        }
      };
    
      loop (0, x);
      
      result
    }


    (**
     * Reads the inheritance list of a class and retrieves the base
     * type and builds the array of interfaces implemented by the class.
     *)
    private determine_inheritance (ti : Tyinfo) : (System.Type * array (System.Type))
    {
      def is_interface (t : Tycon) {
        match (t.GetTydecl ()) {
          | TD_interface => true
          | _ => false
        }
      };
      
      def base_class_type =
        match (ti.GetDirectSuperTypes ()) {
          | T_app (base_class, _) :: _ when !is_interface (base_class) =>
            base_class.GetSystemType ()
          | _ when is_interface (ti) => null
          | _ => typeof (System.Object)
        };

      def ifaces_types = List.map (fun (tc : Tycon) { tc.GetSystemType () },
                                   ti.InterfacesToImplement ());
      
(*            
      def dump_list (l : list (System.Type)) : string {
        | [] => ""
        | [t] => t.FullName
        | t :: ts => t.FullName + ", " + dump_list (ts)
      };

      // Message.debug ("determine inheritance of " + m.extern_name + ": " + 
      //  dump_list (extends_list) + " / " + dump_list (implements_list)); 
*)
      
      (base_class_type, type_list_to_type_array (ifaces_types))
    }
  
      
    (**
     * This method makes a skeleton of a class -- the class partial type and
     * partial types for the nested classes are created. The parent class and
     * the interfaces being implemented are assumed to have been processed
     * before constructing a dependant class. All the declarations and method
     * implementations will be created successively in subsequent passes.
     *)
    public ConstructTypeBuilder (tyinfo : Tyinfo) : TypeBuilder
    {       
      (* create optional custom attributes for this type *)
      def custom_attribute =
        match (tyinfo.GetTydecl ()) {          
          | TD_variant => 
            this.make_nemerle_variant_attribute ()
          | TD_variant_option (encoded_type) =>
            this.make_nemerle_variant_option_attribute (encoded_type)
          | _ => null
        };

      (* decide the new type attributes *)
      mutable is_interface <- false;
      
      def type_kind_attrs = 
        match (tyinfo.GetTydecl ()) { 
          | TD_class => TypeAttributes.Class
          | TD_alias => Util.ice ("TD_alias")
          | TD_external => Util.ice ("TD_external")
          | TD_interface => 
            is_interface <- true;
            TypeAttributes.Interface %| TypeAttributes.Abstract
          | TD_variant => TypeAttributes.Class
          | TD_variant_option (_) => TypeAttributes.Class
        };
        
      def attrs = type_kind_attrs;

      (* determine the inheritance relation for this type *)
      def (extends_class, implements_interfaces) = this.determine_inheritance (tyinfo);

(*
      {
        def loop (acc, pos) {
          if (pos >= implements_interfaces.Length) acc
          else
            loop (acc + " " + implements_interfaces[pos].FullName, pos + 1)
        };
        Message.debug ("class " + tyinfo.GetFullName () + " extends " + 
          (if (extends_class == null) "(null)" else extends_class.FullName) + " impl " +
          loop ("", 0))
      };
*)

      (* create the type builder for a top-level or nested class declaration *)      
      def new_type_builder = 
        if (tyinfo.GetDeclaringTycon () == null)
          this._module_builder.DefineType (tyinfo.GetFullName (), TypeAttributes.Public %| attrs, 
                                           extends_class, implements_interfaces)
        else {
          def type_builder = (tyinfo.GetDeclaringTycon () :> Tyinfo).GetTypeBuilder ();
          type_builder.DefineNestedType (tyinfo.GetName (), TypeAttributes.NestedPublic %| attrs,
                                         extends_class, implements_interfaces)
        };

      when (custom_attribute != null && this._emit_nemerle_attributes) {
        new_type_builder.SetCustomAttribute (custom_attribute);
      };

      new_type_builder
    }


    (**
     * Adds a an implicit parameterless constructor to a type builder
     *)
    internal AddImplicitCtor (tb : TypeBuilder) : ConstructorBuilder
    {
      def constructor_builder = 
        tb.DefineDefaultConstructor (MethodAttributes.FamORAssem);

      constructor_builder
    }
    

    (**
     * Adds a constructor builder to a type builder
     *)
    internal AddConstructorBuilder (cgm : CG_method, tb : TypeBuilder) : void
    {
      // Message.debug ("-- AddConstructorBuilder: " + tb.FullName + "." + cgm.name);

      (* build the parameter types array *)      
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.map (mkparm, cgm.parms);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      (* create the constructor builder *)
      def constructor_builder =
        tb.DefineConstructor (make_method_attributes (cgm.modifiers),
                              CallingConventions.Standard, parm_types_array);
      cgm.constructor_builder <- constructor_builder;
    }


    (**
     * Emits a constructor's body
     *)
    internal EmitConstructor (cgm : CG_method) : void
    {
      def cb = cgm.constructor_builder;
      assign_parameter_indexes (cb.IsStatic, cgm);

      CGopt.Optimize (cgm);
      
      (* emit the constructor's body *)
      def _ = CodeGenerator (cb, cgm);
      
      ()
    }


    (**
     * Adds a method builder to a type builder
     *)
    internal AddMethodBuilder (cgm : CG_method, tb : TypeBuilder) : void
    {
      // Message.debug ("-- AddMethodBuilder: " + tb.FullName + "." + cgm.name);
      
      (* build the parameter types array *)      
      def mkparm (parm : CG_val) : System.Type {
        parm.ty
      };

      def parm_types_list = List.map (mkparm, cgm.parms);
      def parm_types_array = type_list_to_type_array (parm_types_list);

      (* update the modifiers list *)
      def modifiers =
        if (cgm.implemented_methods == null) cgm.modifiers
        else
          match (cgm.implemented_methods) {
            | [] => cgm.modifiers
            | _ => Mod_virtual () :: cgm.modifiers
          };

      def attrs = make_method_attributes (modifiers);
      def attrs =
        if (cgm.name == ".cctor")
          attrs %| MethodAttributes.RTSpecialName %| MethodAttributes.SpecialName
        else attrs;

      (* add the method to the type builder *)
      def method_builder =
        tb.DefineMethod (cgm.name, attrs,
                         cgm.ret_type, parm_types_array);
      cgm.method_builder <- method_builder;
    }


    (**
     * Emits a method's body
     *)
    internal EmitMethod (cgm : CG_method) : void
    {
      def mb = cgm.method_builder;
      assign_parameter_indexes (mb.IsStatic, cgm);
      
      CGopt.Optimize (cgm);
      
      (* update the entry point settings, if necessary *)
      when (_need_entry_point && cgm.name == "Main" && mb.IsStatic) {
        match (_entry_point) {
          | Some =>
            Message.error ("ambiguous match for entry point candidate in type " + 
                           mb.DeclaringType.FullName);
          | None =>
            _entry_point <- Some ((mb : MethodInfo))
        }
      };
      
      (* update the overriding relationships *)
      def type_builder = (mb.DeclaringType :> TypeBuilder);
      def method_info = (mb :> MethodInfo);
            
      def update_override (overridden : IMethod) : void {
        def overridden_info = overridden.GetMethodInfo ();
        
        //Message.debug ("override " + method_info.Name + " " + overridden_info.Name + " in " +
        //                type_builder.FullName);
        type_builder.DefineMethodOverride (method_info, overridden_info)
      };
      
      List.iter (update_override, cgm.implemented_methods);
      
      (* emit the method body *)
      def _ = CodeGenerator (mb, cgm);
      
      ()
    }


    (**
     * Adds a method and immediately emits it's body
     *)
    internal AddMethod (cgm : CG_method, tb : TypeBuilder) : void
    {
      AddMethodBuilder (cgm, tb);
      EmitMethod (cgm);
    }


    (**
     * Adds a field builder
     *)
    internal AddFieldBuilder (field : IField, tb : TypeBuilder) : FieldBuilder
    {
      def field_builder = 
        tb.DefineField (field.GetName (), 
                        CGexpr.cg_type (tb, field.GetMemType ()),
                        make_field_attributes (field.GetModifiers ()));

      when (_emit_nemerle_attributes) {
        def encoded_type = Tyutil.encode_type_to_string (field.GetMemType ());
        field_builder.SetCustomAttribute (make_nemerle_type_attr (encoded_type));
      };

      (field :> NemerleField).field_builder <- field_builder;
      field_builder
    }


    (**
     * This methods walks the CGIL tree and adds field and method declarations.
     * The method implementation will be filled in a separate pass.
     *)    
    add_declarations (ti : Tyinfo) : void
    {    
      def type_builder = ti.GetTypeBuilder ();

      def add_member (m : IMember) {
        match (m.GetKind ()) {
          | MK_field (field) =>
            def _ = AddFieldBuilder (field, type_builder); ()
            
          | MK_method (m) when m.GetExternName () != null => () // skip extern methods
          
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_ctor =>
                def cgm = CGexpr.GetCgMethod (m);
                AddConstructorBuilder (cgm, type_builder);
                (m :> NemerleMethod).ctor_builder <- cgm.constructor_builder
              | _ =>
                def cgm = CGexpr.GetCgMethod (m);
                AddMethodBuilder (cgm, type_builder);
                (m :> NemerleMethod).method_builder <- cgm.method_builder
            }
            
          | MK_property => Util.ice ()
          | MK_type => () // skip
        }
      };
      
      List.iter (add_member, ti.GetDirectMembers ())
    }


    (**
     * Assigns an ordinal index to each of a method's parameter
     *)
    private assign_parameter_indexes (is_static : bool, cgm : CG_method) : void
    {
      def walk_parms (index : int, parms : list (CG_val)) : void {        
        match (parms) {
          | parm :: rest => 
            parm.parm_index <- Some (index);
            walk_parms (index + 1, rest)
          | [] => ()
        }
      };
      
      walk_parms (if (is_static) 0 else 1, cgm.parms)
    }


    (* -- PRIVATE FIELDS --------------------------------------------------- *)

    private mutable _assembly_name : System.Reflection.AssemblyName;
    private mutable _assembly_builder : AssemblyBuilder;
    private mutable _module_builder : ModuleBuilder;
    private mutable _type_builder_queue : Queue (TypeBuilder);
    private mutable _emit_nemerle_attributes : bool;
    private mutable _need_entry_point : bool;
    private mutable _entry_point : option (MethodInfo);
    private mutable _output_file_name : string;
    private mutable _aux_types : list (TypeBuilder);
  }



  (* ----------------------------------------------------------------------- *)
  (* -- CODE GENERATOR CLASS ----------------------------------------------- *)
  (* ----------------------------------------------------------------------- *)

  (**
   * Generates the IL code for a method or a constructor
   *)
  internal class CodeGenerator
  {
    private mutable _system_object : System.Type;
    private mutable _system_void : System.Type;
    private mutable _system_enum : System.Type;
    
    // private mutable _system_object_guid : System.Guid;
    // private mutable _system_void_guid : System.Guid;
    
    private mutable _cg_method : CG_method;
    private mutable _ilg : ILGenerator;

    private mutable _method_name : string;
    private mutable _method_is_static : bool;
    
    private mutable _method_start_label : Label;


    (**
     * Initialize some commonly used values
     *)
    private init () : void
    {
      _system_object <- reflect_type ("System.Object");
      _system_void <- reflect_type ("System.Void");
      _system_enum <- reflect_type ("System.Enum");

      // _system_object_guid <- _system_object.GUID;
      // _system_void_guid <- _system_void.GUID;
    }


    (**
     * Creates and executes a code generator for a method
     *)
    internal this (method_builder : MethodBuilder, cg_method : CG_method)
    {
      init ();
      
      _cg_method <- cg_method;
      
      _ilg <- method_builder.GetILGenerator ();
      
      _method_name <- method_builder.DeclaringType.FullName + "::" + method_builder.Name;
      _method_is_static <- method_builder.IsStatic;
      
      _method_start_label <- _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      unless (emit (_cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }


    (**
     * Creates and executes a code generator for a method
     *)
    internal this (constructor_builder : ConstructorBuilder, cg_method : CG_method)
    {
      init ();

      _cg_method <- cg_method;
      
      _ilg <- constructor_builder.GetILGenerator ();
      
      _method_name <- constructor_builder.DeclaringType.FullName + "::" + constructor_builder.Name;
      _method_is_static <- constructor_builder.IsStatic;

      _method_start_label <- _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      // -- HACK HACK HACK REMOVE ME REMOVE ME REMOVE ME HACK HACK HACK -- //
      unless (CodeGenerator.has_base_ctor_call (_cg_method.body) || _method_is_static) {
        def base_type = constructor_builder.DeclaringType.BaseType;
        assert (base_type != null);

        // Message.debug ("Adding base ctor implicit call: " + constructor_builder.DeclaringType.FullName + 
        //               ", base class: " + base_type.FullName);

        def base_ctor_info = 
          base_type.GetConstructor (BindingFlags.NonPublic %| BindingFlags.Public %| 
                                    BindingFlags.Instance, null, System.Type.EmptyTypes, null);

        when (base_ctor_info == null) {
          Util.ice ("cannot find default ctor in " + base_type.FullName + 
                    " ex " + pretty_print (_cg_method.body));
        };

        _ilg.Emit (OpCodes.Ldarg_0);
        _ilg.Emit (OpCodes.Call, base_ctor_info)
      };
      
      unless (emit (_cg_method.body))
        _ilg.Emit (OpCodes.Ret)
    }


    (**
     * This method checks if a given expression contains 
     * a call to a class' base constructor.
     *)     
    private static has_base_ctor_call (expr : CG_expr) : bool 
    {        
      // -- HACK HACK HACK REMOVE ME REMOVE ME REMOVE ME HACK HACK HACK -- //
      match (expr) {
        | CE_sequence ([]) => false
        | CE_sequence (body) => List.exists (has_base_ctor_call, body)
        | CE_tail_call (CE_base_ctor_ref (_), _)
        | CE_call (CE_base_ctor_ref (_), _) => true
        | CE_let (_, expr)
        | CE_cast (expr, _) => has_base_ctor_call (expr)
        | _ => false
      }
    }


    (**
     * Check if named operator is defined in the class of the first parameter
     * and if so -- emit call to it and return true. Otherwise return false.
     *)
    private try_emit_operator (name : string, parms : list (CG_expr)) : bool
    {
      def parm_type = type_of (List.hd (parms));
      def tc = GlobalEnv.LookupInternalType (parm_type.FullName.Replace ('+', '.'));
      match (tc.LookupMember (name, LF_all ())) {
        | [symbol] =>
          match (symbol.GetKind ()) {
            | MK_method (meth) =>
              _ilg.Emit (OpCodes.Call, meth.GetMethodInfo ());
              true
            | _ => false
          }
        | _ => false
      }
    }


    (**
     * Emits an expression.
     *)
    private emit (expr : CG_expr) : bool 
    {      
      //Message.debug ("emit: " + pretty_print (expr));

      match (expr) {
      
        (* -- SEQUENCING --------------------------------------------------- *)

        (* emits a sequence of expressions *)
        | CE_sequence (expr_seq) =>
          def emit_sequence (expr_seq : list (CG_expr)) : bool {
            match (expr_seq) {
              | [] => false
              | expr :: rest =>
                if (emit (expr)) true
                else emit_sequence (rest)
            }
          };

          emit_sequence (expr_seq)


        (* emits a local value definition *)
        | CE_let (let_val, let_in) =>
          match (let_val.val) {
            | CE_none =>
              unless (is_system_void (let_val.ty)) {
                def _ = declare_val_local_slot (let_val); ()
              };

              emit (let_in)

            | _ =>
              if (emit (let_val.val)) true
              else {
                unless (is_system_void (let_val.ty)) {
                  def local_slot = declare_val_local_slot (let_val);
                  _ilg.Emit (OpCodes.Stloc, local_slot)
                };

                emit (let_in)
              }
          };


        (* ignores the results of a computation *)
        | CE_ignore (expr) =>
          def cutoff = emit (expr);
          unless (cutoff)
            _ilg.Emit (OpCodes.Pop);            
          cutoff



        (* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ *)

        (* emits the if/then/else construction *)
        | CE_if (cond_expr, then_expr, else_expr) =>
          if (emit (cond_expr)) true
          else {
            def label_condition_else = _ilg.DefineLabel ();
            def label_condition_fi = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Brfalse, label_condition_else);
            
            def cutoff_then = emit (then_expr);
            unless (cutoff_then) { _ilg.Emit (OpCodes.Br, label_condition_fi) };

            _ilg.MarkLabel (label_condition_else);
            def cutoff_else = emit (else_expr);

            _ilg.MarkLabel (label_condition_fi);
            cutoff_then && cutoff_else
          }


        (* emit a type check construction *)
        | CE_has_type (expr, ty) =>
          if (emit (expr)) true
          else {
            def label_condition_not_null = _ilg.DefineLabel ();
            def label_condition_has_type = _ilg.DefineLabel ();
            def label_condition_continue = _ilg.DefineLabel ();

            _ilg.Emit (OpCodes.Dup);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);
            
            _ilg.ThrowException (reflect_type ("Nemerle.Core.Null_match"));

            _ilg.MarkLabel (label_condition_not_null);

            _ilg.Emit (OpCodes.Isinst, ty);
            _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_0);
            _ilg.Emit (OpCodes.Br_S, label_condition_continue);
            _ilg.MarkLabel (label_condition_has_type);
            _ilg.Emit (OpCodes.Ldc_I4_1);
            _ilg.MarkLabel (label_condition_continue);
            false
          }


        (* -- TYPE CONVERSIONS --------------------------------------------- *)

        (* do not perform casts between same types *)
        | CE_cast (expr, cast_to_type) when type_eq (type_of (expr), cast_to_type) =>
          emit (expr)


        (* box value types, cast all the other types to System.Object *)
        | CE_cast (expr, cast_to_type) when is_system_object (cast_to_type) =>
          if (emit (expr)) true
          else {
            def type_of_expr = type_of (expr);

            unless (type_eq (cast_to_type, type_of_expr)) {
              if (type_of_expr.IsValueType)
                _ilg.Emit (OpCodes.Box, type_of_expr)
              else
                _ilg.Emit (OpCodes.Castclass, cast_to_type)
            };

            false            
          }


        (* unbox value types or perform value type conversion *)          
        | CE_cast (expr, cast_to_type) when cast_to_type.IsValueType =>
          if (emit (expr)) true
          else {
            def type_of_expr = type_of (expr);

            if (type_of_expr.IsValueType) {
              (* perform conversion of value types *)
              emit_value_type_conversion (type_of_expr, cast_to_type)
            }
            else if (is_system_object (type_of_expr)) {
              (* unboxing returns a pointer to a value *)
              _ilg.Emit (OpCodes.Unbox, cast_to_type);
              emit_ldind_for_value_type (cast_to_type)
            }
            else {
              Util.ice (_method_name + ": failed to convert non-value type " + type_of_expr.FullName +
                                                         " to a value type " + cast_to_type.FullName)
            };
            
            false
          }
          

        (* upcast / downcast non-value types *)
        | CE_cast (expr, cast_to_type) =>
          if (emit (expr)) true
          else {
            (* upcasting / downcasting *)
            _ilg.Emit (OpCodes.Castclass, cast_to_type);
            false
          }



        (* -- REFERENCES --------------------------------------------------- *)

        (* load the value of a local variable or a method parameter *)
        | CE_ref (decl) => 
          match (decl.local_slot) {
            | Some (local_slot) => _ilg.Emit (OpCodes.Ldloc, local_slot)
            | _ => 
              match (decl.parm_index) {
                | Some (parm_index) => emit_ldarg (parm_index)
                | _ => 
                  Util.ice (_method_name + ": parameter index / variable local slot undefined in CE_ref " + decl.name)
              }
          };
          false
        

        (* load the value of a field *)
        | CE_field_ref (base_object, field) =>
          if (emit (base_object)) true
          else {
            _ilg.Emit (OpCodes.Ldfld, field);
            false
          }


        (* load the value of a static field *)
        | CE_global_ref (mi) when member_is_field (mi) =>
          def field_info = (mi :> FieldInfo);

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");
            
          if (field_info.DeclaringType.IsEnum) {
            (* load the value of an enum directly as an int *)
            emit_literal (L_int ((field_info.GetValue (null) :> int)));
          }
          else _ilg.Emit (OpCodes.Ldsfld, field_info);
          false


        (* load an array element *)
        | CE_array_indexer (array_obj, [index]) =>
          if (emit (array_obj)) true
          else {          
            if (emit (index)) true
            else {
              def element_type = type_of (array_obj).GetElementType ();
              assert (element_type != null, "non-array in CE_array_indexer");
              
              emit_array_load_opcode (element_type);
              false
            }
          }
        
        | CE_array_indexer => 
          Util.ice (_method_name + ": multidimensional arrays should be accessed by means of properties")


        (* -- ASSIGNMENTS -------------------------------------------------- *)

        (* FIXME *)
        | CE_assign (CE_cast (expr, _), val) =>
          // Message.debug ("FIXME: warning, working around the CE_cast () <- val bug");
          emit (CE_assign (expr, val))


        (* assignment to a local variable *)
        | CE_assign (CE_ref (local_var), val) =>
          match (local_var.local_slot) {
            | Some (local_slot) =>
              if (emit (val)) true
              else {
                _ilg.Emit (OpCodes.Stloc, local_slot);
                false
              }
            | _ =>
              Util.ice (_method_name + ": null local slot in CE_assign (CE_ref + " + local_var.name + ")")
          };


        (* assignment to a field *)
        | CE_assign (CE_field_ref (base_object, field), val) =>
          if (emit (base_object)) true
          else if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stfld, field);
            false
          }


        (* assignment to a static field *)
        | CE_assign (CE_global_ref (mi), val) when member_is_field (mi) =>
          if (emit (val)) true
          else {
            _ilg.Emit (OpCodes.Stsfld, (mi :> FieldInfo));
            false
          }


        (* assignment to an array element *)
        | CE_assign (CE_array_indexer (array_obj, [index]), val) =>
          if (emit (array_obj)) true
          else if (emit (index)) true
          else if (emit (val)) true
          else {
            def element_type = type_of (array_obj).GetElementType ();
            assert (element_type != null, "non-array in CE_array_indexer");

            emit_array_store_opcode (element_type);
            false
          }
        
        | CE_assign (CE_array_indexer, _) => 
          Util.ice (_method_name + ": multidimensional arrays should be accessed by means of properties")



        (* -- CALLS -------------------------------------------------------- *)

        (* call the base constructor *)
        | CE_tail_call (CE_base_ctor_ref (base_ctor), ctor_params)
        | CE_call (CE_base_ctor_ref (base_ctor), ctor_params) =>          
          _ilg.Emit (OpCodes.Ldarg_0);

          if (emit_call_parameters (ctor_params)) true
          else {
            _ilg.Emit (OpCodes.Call, base_ctor);
            false
          }


        (* create a new object *)
        | CE_tail_call (CE_ctor_ref (ctor), ctor_params)
        | CE_call (CE_ctor_ref (ctor), ctor_params) =>
          if (emit_call_parameters (ctor_params)) true
          else {            
            _ilg.Emit (OpCodes.Newobj, ctor);
            false
          }
          

        (* emit a call to an instance method, basing on an instance field's contents *)
        | CE_tail_call (CE_method_ref (CE_field_ref (base_object, field), method), method_params)
        | CE_call (CE_method_ref (CE_field_ref (base_object, field), method), method_params) => 
          if (emit (base_object)) true
          else {
            def base_is_value_type = field.FieldType.IsValueType;
              
            if (base_is_value_type)
              _ilg.Emit (OpCodes.Ldflda, field)
            else
              _ilg.Emit (OpCodes.Ldfld, field);

            if (emit_call_parameters (method_params)) true
            else
              emit_method_call (expr, base_is_value_type, method)
          }


        (* emit a call to an instance method, basing on a static field's contents *)
        | CE_tail_call (CE_method_ref (CE_global_ref (mi), method), method_params) when member_is_field (mi)
        | CE_call (CE_method_ref (CE_global_ref (mi), method), method_params) when member_is_field (mi) => 
          def field_info = (mi :> FieldInfo);          

          assert (field_info.IsStatic, "CE_global_ref to a non-static field");
                    
          def base_is_value_type = field_info.FieldType.IsValueType;
              
          if (base_is_value_type)
            _ilg.Emit (OpCodes.Ldsflda, field_info)
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, base_is_value_type, method);



        (* emit a call to an instance method, basing on a local variable *)
        | CE_tail_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method), method_params)
        | CE_call (CE_method_ref ((CE_ref (decl)) as decl_ref, method), method_params) =>
          def base_is_value_type = decl.ty.IsValueType;
          
          if (base_is_value_type) {
            match (decl.local_slot) {
              | Some (local_slot) => _ilg.Emit (OpCodes.Ldloca, local_slot)
              | _ => 
                match (decl.parm_index) {
                  | Some (parm_index) => emit_ldarga (parm_index)
                  | _ => Util.ice (_method_name + ": null local slot or no parameter index " +
                                   "in CE_call (CE_method_ref (CE_ref + " + decl.name + "))")
                }
            }
          }
          else {
            def _ = emit (decl_ref); ()
          };
          
          if (emit_call_parameters (method_params)) true
          else
            emit_method_call (expr, base_is_value_type, method)


        (* emit a call to an instance method *)
        | CE_tail_call (CE_method_ref (base_object, method), method_params)
        | CE_call (CE_method_ref (base_object, method), method_params) => 
          if (emit (base_object)) true
          else {
            if (emit_call_parameters (method_params)) true
            else {
              def base_is_value_type = method.DeclaringType.IsValueType;
              emit_method_call (expr, base_is_value_type, method)
            }
          }


        (* emit a call to a static method *)
        | CE_tail_call (CE_global_ref (mi), method_parms) when member_is_method (mi)
        | CE_call (CE_global_ref (mi), method_parms) when member_is_method (mi) =>
          def method_info = (mi :> MethodInfo);

          assert (method_info.IsStatic, "CE_call CE_global_ref to a non-static field");
                              
          if (emit_call_parameters (method_parms)) true
          else
            emit_method_call (expr, true, method_info)


        (* emit an operator *)
        | CE_tail_call (CE_opcode (opcode), parms)
        | CE_call (CE_opcode (opcode), parms) =>
          if (emit_call_parameters (parms)) true
          else {
            match (opcode) {
              // FIXME: add type information to the %op notation
              // FIXME: add the checked/unchecked flags
              // FIXME: handle the overloaded operators properly (see == and != for System.String)
              | "+" => 
                when (List.length (parms) == 1) _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Add_Ovf);
              | "-" => 
                if (List.length (parms) == 1) {
                  _ilg.Emit (OpCodes.Ldc_I4_M1);
                  _ilg.Emit (OpCodes.Mul_Ovf)
                }
                else _ilg.Emit (OpCodes.Sub_Ovf);
              | "*" => _ilg.Emit (OpCodes.Mul_Ovf);
              | "/" => _ilg.Emit (OpCodes.Div);
              | "%" => _ilg.Emit (OpCodes.Rem);
              | "|" => _ilg.Emit (OpCodes.Or);
              | "&" => _ilg.Emit (OpCodes.And);
              | "!" =>
                _ilg.Emit (OpCodes.Ldc_I4_0);
                _ilg.Emit (OpCodes.Ceq);                
              | "==" =>
                unless (try_emit_operator ("op_Equality", parms))
                  _ilg.Emit (OpCodes.Ceq);
              | "!=" => 
                unless (try_emit_operator ("op_Inequality", parms)) {
                  _ilg.Emit (OpCodes.Ceq);
                  _ilg.Emit (OpCodes.Ldc_I4_0);
                  _ilg.Emit (OpCodes.Ceq);
                }
              | "<" => emit_compare (OpCodes.Blt_S)
              | ">" => emit_compare (OpCodes.Bgt_S)
              | "<=" => emit_compare (OpCodes.Ble_S)
              | ">=" => emit_compare (OpCodes.Bge_S)
              | _ =>
                Util.ice (_method_name + ": unmatched CE_opcode (" + opcode + ")")
            };
            false
          }

        (* emit self tail call -- that is jump to method start *)
        | CE_self_tail_call (method_params) =>
          if (emit_call_parameters (method_params)) true
          else {
            def store_argument (cgv : CG_val) {
              match (cgv.parm_index) {
                | Some (index) =>
                  if (index < 250)
                    _ilg.Emit (OpCodes.Starg_S, index)
                  else
                    _ilg.Emit (OpCodes.Starg, index);
                | None => Util.ice ()
              }
            };
            List.iter (store_argument, List.rev (_cg_method.parms));
            _ilg.Emit (OpCodes.Br, _method_start_label);
            true
          }


        (* -- EXCEPTION HANDLING ------------------------------------------- *)

        (* raise an exception *)
        | CE_raise (exc) =>
          if (emit (exc)) true
          else {
            _ilg.Emit (OpCodes.Throw);
            true
          }


        (* emit the try/with construction *)
        | CE_try_with (try_expr, catch_val, catch_expr) =>
          def type_of_try_expr = type_of (expr);
               
          def ignore_try_with_result = is_system_void (type_of_try_expr);
          mutable try_result <- null;
                             
          unless (ignore_try_with_result)
            try_result <- _ilg.DeclareLocal (type_of_try_expr);

          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff_on_try = emit (try_expr);
          
          unless (cutoff_on_try || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);
          
          _ilg.BeginCatchBlock (catch_val.ty);

          def catch_val_local_slot = declare_val_local_slot (catch_val);
          _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);
          
          def cutoff_on_catch = emit (catch_expr);
          
          unless (cutoff_on_catch || ignore_try_with_result)
            _ilg.Emit (OpCodes.Stloc, try_result);
                    
          _ilg.EndExceptionBlock ();
          
          def cutoff = cutoff_on_try && cutoff_on_catch;
          
          unless (cutoff || ignore_try_with_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        // FIXME: how does finally work? what about storing it's result in try_result as in CE_try_with?
        | CE_try_finally (try_expr, finally_expr) =>
          def type_of_try_expr = type_of (try_expr);

          def _ = _ilg.BeginExceptionBlock ();
          
          def cutoff = emit (try_expr);

          def ignore_try_result = cutoff || is_system_void (type_of_try_expr);
          mutable try_result <- null;

          unless (ignore_try_result) {
            try_result <- _ilg.DeclareLocal (type_of_try_expr);
            _ilg.Emit (OpCodes.Stloc, try_result)
          };

          _ilg.BeginFinallyBlock ();

          def _ = emit (finally_expr);

          _ilg.EndExceptionBlock ();
          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);
          cutoff


        (* -- MISC --------------------------------------------------------- *)

        (* loads the 'this' pointer on the evaluation stack *)
        | CE_this =>
          assert (!_method_is_static, "CE_this is a static method");

          _ilg.Emit (OpCodes.Ldarg_0);
          false


        (* loads a literal on the evaluation stack *)
        | CE_literal (l) =>
          emit_literal (l);
          false


        (* creates a new array, given a list of initializers *)
        | CE_mkarray (element_type, initializers) =>
          def local_slot = _ilg.DeclareLocal (type_of (expr));
                    
          _ilg.Emit (OpCodes.Ldc_I4, List.length (initializers));
          _ilg.Emit (OpCodes.Newarr, element_type);

          _ilg.Emit (OpCodes.Stloc, local_slot);

          def load_elements (index : int, elements : list (CG_expr)) : bool {
            match (elements) {
              | [] => false
              | element :: rest =>
                _ilg.Emit (OpCodes.Ldloc, local_slot);
                _ilg.Emit (OpCodes.Ldc_I4, index);                
                if (emit (element)) true
                else {
                  emit_array_store_opcode (element_type);
                  load_elements (index + 1, rest)
                }
            }
          };

          def cutoff = load_elements (0, initializers);          
          unless (cutoff) _ilg.Emit (OpCodes.Ldloc, local_slot);          
          cutoff
        
        
        (* an interrupting NOP instruction *)
        | CE_none => false

        | _ =>
          Message.warning ("FIXME: unmatched: " + pretty_print (expr));
          false
      }
    }


    (**
     * Reflects a type
     *)
    private reflect_type (type_name : string) : System.Type
    {
      def ty = CGIL.reflect_type (type_name);
            
      when (ty == null) Util.ice (_method_name + ": could not reflect type: " + type_name);
      
      ty
    }
     
     
    (**
     * Checks GUIDs of two types for equality
     *)
    private type_eq (l : System.Type, r : System.Type) : bool
    {
      // l.GUID.Equals (r.GUID)
      l.FullName == r.FullName
    }


    (**
     * Checks if a type is the System.Object type
     *)
    private is_system_object (ty : System.Type) : bool
    {
      // ty.GUID.Equals (_system_object_guid)
      ty.FullName == _system_object.FullName
    }


    (**
     * Checks if a type is the System.Void type
     *)
    private is_system_void (ty : System.Type) : bool
    {
      // ty.GUID.Equals (_system_void_guid)
      ty.FullName == _system_void.FullName
    }


    (**
     * Checks if a type is an enumeration type
     *)
    private is_subclass_of_system_enum (ty : System.Type) : bool
    {
      ty.IsEnum
    }


    (**
     * Emits an LDARG instruction
     *)
    private emit_ldarg (index : int) : void
    {
      match (index) {
        | 0 => _ilg.Emit (OpCodes.Ldarg_0)
        | 1 => _ilg.Emit (OpCodes.Ldarg_1)
        | 2 => _ilg.Emit (OpCodes.Ldarg_2)
        | 3 => _ilg.Emit (OpCodes.Ldarg_3)
        | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, index)
        | _ => _ilg.Emit (OpCodes.Ldarg, index)
      }
    }


    (**
     * Emits an LDARGA instruction
     *)
    private emit_ldarga (index : int) : void
    {
      match (index) {
        | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, index)
        | _ => _ilg.Emit (OpCodes.Ldarga, index)
      }
    }


    (**
     * Performs value type conversion
     *)
    private emit_value_type_conversion (l : System.Type, r : System.Type) : void
    {
      // FIXME: is that all we need?
      def conv_i4 = l.FullName == "System.Char" && r.FullName == "System.Int32";
      def conv_ovf_u2 = l.FullName == "System.Int32" && r.FullName == "System.Char";
      def conv_skip = l.FullName == "System.Int32" && is_subclass_of_system_enum (r);
              
      if (conv_i4) _ilg.Emit (OpCodes.Conv_I4)
      else if (conv_ovf_u2) _ilg.Emit (OpCodes.Conv_Ovf_U2)
      else if (conv_skip) ()
      else {
        Message.warning ("failed to emit value type conversion from " + l.FullName +
                                                               " to " + r.FullName)
      }
    }
    
    
    (**
     * Checks if a given member info describes a field
     *)
    private member_is_field (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Field    
    }


    (**
     * Checks if a given member info describes a method
     *)
    private member_is_method (mi : MemberInfo) : bool
    {
      mi.MemberType == MemberTypes.Method
    }


    (**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier and return true (cutoff).
     *)
    private emit_method_call (expr : CG_expr, 
                              base_is_value_type_or_static : bool, 
                              method : MethodInfo) : bool
    {
      def is_tail =
        Flags.general_tail_call_opt &&
          match (expr) {
            | CE_tail_call =>
              _ilg.Emit (OpCodes.Tailcall); 
              true
            | _ => false
          };
        
      if (base_is_value_type_or_static)
        _ilg.Emit (OpCodes.Call, method)
      else
        _ilg.Emit (OpCodes.Callvirt, method);

      if (is_tail) {
        _ilg.Emit (OpCodes.Ret);
        true
      } else false
    }


    (**
     * Declares a local variable
     *)
    private declare_val_local_slot (val : CG_val) : LocalBuilder 
    {    
      def local_slot = _ilg.DeclareLocal (val.ty);
      local_slot.SetLocalSymInfo (val.name);
      val.local_slot <- Some (local_slot);
      local_slot
    }


    (**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     *)
    private emit_array_store_opcode (ty : System.Type) : void
    {
      assert (!is_system_void (ty), "tried to store a System.Void in an array");
      
      def tn = ty.FullName;

      def opcode =
        if (tn == "System.SByte" || tn == "System.Boolean") OpCodes.Stelem_I1
        else if (tn == "System.Byte") OpCodes.Stelem_I1
        else if (tn == "System.Char" || tn == "System.Int16") OpCodes.Stelem_I2
        else if (tn == "System.UInt16") OpCodes.Stelem_I2
        else if (tn == "System.Int32") OpCodes.Stelem_I4
        else if (tn == "System.UInt32") OpCodes.Stelem_I4
        else if (tn == "System.Int64" || tn == "System.UInt64") OpCodes.Stelem_I8
        else if (tn == "System.Single") OpCodes.Stelem_R4
        else if (tn == "System.Double") OpCodes.Stelem_R8
        else OpCodes.Stelem_Ref;
        
      _ilg.Emit (opcode)          
    }


    (**
     * Emits a LDELEM instruction for a given type
     *)
    private emit_array_load_opcode (ty : System.Type) : void
    {
      assert (!is_system_void (ty), "tried to load a System.Void from an array");
      
      def tn = ty.FullName;
      
      def opcode =
        if (tn == "System.SByte" || tn == "System.Boolean") OpCodes.Ldelem_I1
        else if (tn == "System.Byte") OpCodes.Ldelem_U1
        else if (tn == "System.Char" || tn == "System.Int16") OpCodes.Ldelem_I2
        else if (tn == "System.UInt16") OpCodes.Ldelem_U2
        else if (tn == "System.Int32") OpCodes.Ldelem_I4
        else if (tn == "System.UInt32") OpCodes.Ldelem_U4
        else if (tn == "System.Int64" || tn == "System.UInt64") OpCodes.Ldelem_I8
        else if (tn == "System.Single") OpCodes.Ldelem_R4
        else if (tn == "System.Double") OpCodes.Ldelem_R8
        else OpCodes.Ldelem_Ref;
        
      _ilg.Emit (opcode)          
    }
    
   

    (**
     * Emits a LDIND instruction for a given value type
     *)
    private emit_ldind_for_value_type (ty : System.Type) : void
    {
      if (ty.IsEnum || !ty.IsPrimitive) {
        _ilg.Emit (OpCodes.Ldobj, ty)
      }
      else {
        def tn = ty.FullName;
      
        def opcode =
          if (tn == "System.SByte" || tn == "System.Boolean")
            OpCodes.Ldind_I1
          else if (tn == "System.Byte")
            OpCodes.Ldind_U1
          else if (tn == "System.Char" || tn == "System.Int16")
            OpCodes.Ldind_I2
          else if (tn == "System.UInt16")
            OpCodes.Ldind_U2
          else if (tn == "System.Int32")
            OpCodes.Ldind_I4
          else if (tn == "System.UInt32")
            OpCodes.Ldind_U4
          else if (tn == "System.Int64")
            OpCodes.Ldind_I8
          else if (tn == "System.UInt64")
            Util.ice ("how to ldind System.UInt64?") // FIXME
          else if (tn == "System.Single")
            OpCodes.Ldind_R4
          else if (tn == "System.Double")
            OpCodes.Ldind_R8
          else
            Util.ice (_method_name + ": not a recognized value type: " + tn);
            
        _ilg.Emit (opcode)
      }
    }


    (**
     * Emits a literal
     *)
    private emit_literal (l : Literal) : void
    {
      match (l) {
        | L_void => ()
        | L_null => _ilg.Emit (OpCodes.Ldnull)

        | L_int (-1) => _ilg.Emit (OpCodes.Ldc_I4_M1)
        | L_int (0) => _ilg.Emit (OpCodes.Ldc_I4_0)
        | L_int (1) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_int (2) => _ilg.Emit (OpCodes.Ldc_I4_2)
        | L_int (3) => _ilg.Emit (OpCodes.Ldc_I4_3)
        | L_int (4) => _ilg.Emit (OpCodes.Ldc_I4_4)
        | L_int (5) => _ilg.Emit (OpCodes.Ldc_I4_5)
        | L_int (6) => _ilg.Emit (OpCodes.Ldc_I4_6)
        | L_int (7) => _ilg.Emit (OpCodes.Ldc_I4_7)
        | L_int (8) => _ilg.Emit (OpCodes.Ldc_I4_8)
//        | L_int (k) when k >= -128 && k <= 127 => _ilg.Emit (OpCodes.Ldc_I4_S, k) -- FIXME: this is doing something bad to the MSIL
        | L_int (k) => _ilg.Emit (OpCodes.Ldc_I4, k)

        | L_char (k) when (k :> int) <= 127 => _ilg.Emit (OpCodes.Ldc_I4_S, (k :> int))          
        | L_char (k) => _ilg.Emit (OpCodes.Ldc_I4, (k :> int))
        
        | L_bool (true) => _ilg.Emit (OpCodes.Ldc_I4_1)
        | L_bool (false) => _ilg.Emit (OpCodes.Ldc_I4_0)

        | L_string (s) => _ilg.Emit (OpCodes.Ldstr, s)
        | L_float (f) => 
          _ilg.Emit (OpCodes.Ldc_I4, f);
          _ilg.Emit (OpCodes.Conv_R4)
      }
    }


    (**
     * Emits a list of expressions. This is used to emit call parameters,
     * specialization allows better error messages here.
     *)
    private emit_call_parameters (parms : list (CG_expr)) : bool
    {
      match (parms) {
        | [] => false
        | parm :: rest =>
          if (emit (parm)) {
            Message.warning ("a control-flow terminating call parameter in " + _method_name);
            true
          }
          else emit_call_parameters (rest)
      }
    }


    (**
     * Emits a comparison operation
     *)
    private emit_compare (opcode : OpCode) : void
    {
      def label_condition_met = _ilg.DefineLabel ();
      def label_condition_not_met = _ilg.DefineLabel ();

      _ilg.Emit (opcode, label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_0);
      _ilg.Emit (OpCodes.Br, label_condition_not_met);
      _ilg.MarkLabel (label_condition_met);
      _ilg.Emit (OpCodes.Ldc_I4_1);
      _ilg.MarkLabel (label_condition_not_met)
    }


    (**
     * Converts parameter list to it's System.Type list
     *)
    private make_call_parms (parms : list (CG_val)) : list (System.Type)
    {
      def mk_parm (parm : CG_val) : System.Type {
        parm.ty
      };

      List.map (mk_parm, parms)    
    }


    (**
     * Converts parameter list to it's System.Type list
     *)
    private make_expr_call_parms (parms : list (CG_expr)) : list (System.Type)
    {
      def mk_parm (parm : CG_expr) : System.Type {
        type_of (parm)
      };

      List.map (mk_parm, parms)
    }


    (**
     * Computes the type of an expression
     *)
    type_of (ex : CG_expr) : System.Type
    {
      CGexpr.type_of (ex)
    }


    (**
     * Pretty prints a list of expressions
     *)
    pretty_print_list (exs : list (CG_expr), acc : string) : string 
    {
      match (exs) {
        | [] => acc
        | ex :: rest => pretty_print_list (rest, acc + pretty_print (ex))
      }
    }


    (**
     * Pretty prints an expression
     *)
    pretty_print (ex : CG_expr) : string 
    {
      match (ex) {
        | CE_ref (decl) => "CE_ref (" + decl.name + "); "
        | CE_global_ref (mi) => "CE_global_ref (" + pretty_print_member_info (mi) + "); "
        | CE_base_ctor_ref (mi) => "CE_base_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_ctor_ref (mi) => "CE_ctor_ref (" + pretty_print_member_info (mi) + "); "
        | CE_field_ref (_, fld) => "CE_field_ref (" + pretty_print_member_info (fld) +"); "
        | CE_method_ref (_, meth) => "CE_method_ref (" + pretty_print_member_info (meth) + "); "
        | CE_ignore (expr) => "CE_ignore (" + pretty_print (expr) + "); "
        | CE_opcode (name) => "CE_opcode (" + name + "); "
        | CE_self_tail_call (parms) => "CE_self_tail_call (" + pretty_print_list (parms, "") + "); "
        | CE_call (func, parms) => "CE_call " + pretty_print (func) + " (" + pretty_print_list (parms, "") + "); "
        | CE_tail_call (func, parms) => "CE_tail_call " + pretty_print (func) + " (" + pretty_print_list (parms, "") + "); "
        | CE_assign (target, source) => 
          pretty_print (target) + " <- " + pretty_print (source) + "; "
        | CE_let (name, body) => 
          "let " + name.name + " = " + pretty_print (name.val) + " in " + pretty_print (body) + "; "
        | CE_has_type (_, ty) => "CE_has_type (" + pretty_print_type (ty) + "); "
        | CE_raise (exn) => "CE_raise (" + pretty_print (exn) + "); "
        | CE_if (cond, e_then, e_else) => 
          "if (" + pretty_print (cond) + ") " + pretty_print (e_then) + " else " + pretty_print (e_else) + "; "
        | CE_try_with => "CE_try_with; "
        | CE_try_finally => "CE_try_finally; "
        | CE_literal => "CE_literal; "
        | CE_this => "CE_this; "
        | CE_skip => "CE_skip; "
        | CE_cast (expr, ty) => "CE_cast < " + pretty_print (expr) + " to " + pretty_print_type (ty) + "> "
        | CE_sequence (body) => "{ " + pretty_print_list (body, "") + " }; "
        | CE_none => "CE_none"
        | CE_mkarray (_, initializers) => "CE_mkarray { " + pretty_print_list (initializers, "") + " }; "
        | CE_array_indexer (obj, args) => "CE_indexer " + pretty_print (obj) + "[" + pretty_print_list (args, "") + "]" + "; "
      }
    }


    (**
     * Pretty prints a type
     *)
    private pretty_print_type (ty : System.Type) : string
    {
      ty.FullName
    }


    (**
     * Pretty prints a member info name
     *)
    private pretty_print_member_info (mi : MemberInfo) : string
    {
      mi.DeclaringType.FullName + "::" + mi.Name
    }
  } (* end of the class *)
  
} (* end of the namespace *)
