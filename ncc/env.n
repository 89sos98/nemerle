(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

public variant Decl_kind
  {
    | D_local_fun {
        header : Fun_header; 
        uses_closure_of : list (Decl); 
      }
    | D_fun_parm
    | D_local_value
    | D_exn
    | D_pattern_variable
    | D_class_member { mem : Class_member; }
    | D_type { mem : Tyinfo; }
    | D_closurised_this_ptr
  }
  
public class Decl 
  {
    public loc : Location;
    public name : string;
    public mutable is_ref : bool;
    public mutable ty : Type;
    public id : int;
    public kind : Decl_kind;
    
    public mutable parent_fun : option (Decl);
    public mutable in_closure : bool;
    
    public this (n : string, k : Decl_kind, ty : Type, par : Decl)
      {
        this.loc <- Location_stack.top();
        this.name <- n;
        this.ty <- ty;
        this.kind <- k;
        this.is_ref <- false;
        this.parent_fun <- Some (par);
        this.id <- Util.next_id();
      }

    public this (pref : string, mem : Class_member)
      {
        this.loc <- mem.loc;
        this.name <- pref + mem.name;
        this.id <- mem.id;
        this.kind <- D_class_member (mem);
        this.parent_fun <- None ();
        this.ty <-
          match (mem) {
            | M_value (t, rf, _) => this.is_ref <- rf; t
            | M_field (t, rf) => this.is_ref <- rf; t
            | M_property (t, _, writer, _) => this.is_ref <- Option.is_some (writer); t
            | M_function (h, _, _) => Tyutil.fun_type (h)
          }
      }
      
    public this (t : Tyinfo)
      {
        this.loc <- t.loc;
        this.name <- t.env.current_namespace + t.name;
        this.id <- t.id;
        this.kind <- D_type (t);
        this.ty <- null;
      }
      
    public fun_header () : Fun_header {
      match (this.kind) {
        | D_local_fun x => x.header
        | D_class_member (M_function x) => x.header
        | _ => Util.ice ()
      }
    }
  }

public class Env 
  {
    static public mutable externals : String_map (Decl);
    
    static public mutable globals : String_map (list (Decl)); // FIXME: make non-public
    static mutable globals_by_id : Int_map (Decl);

    public static init () : void {
      if (globals == null) {
        externals <- Map.string_map ();
        globals <- Map.string_map ();
        globals_by_id <- Map.int_map ();
      } else ()
    }

    mutable open_namespaces : list (string);
    public mutable current_namespace : string; // FIXME: make non-public
    mutable namespace_aliases : String_map (string);
    mutable locals : String_map (Decl);
    public mutable parent_fun : option (Decl); //FIXME: public
    
    public static add_global_symbol (name : string, decl : Decl) : void {
      match (globals.find (name)) {
        | Some (decl' :: _) =>
          Message.error (decl.loc, "redefinition of `" + name + "'");
          Message.error (decl'.loc, "first defined here")
        | _ =>
          globals_by_id <- globals_by_id.replace (decl.id, decl);
          globals <- globals.add (name, [decl])
      }
    }

    public static add_type (ti : Tyinfo) : Decl 
    {
      def d = Decl (ti);
      add_global_symbol (ti.env.current_namespace + ti.name, d);
      d
    }
    
    public static add_global (pref : string, m : Class_member) : void
      {
        def allow_overload (d : Decl) : bool {
          match ((d.kind, m)) {
            | (D_class_member (M_function {kind = k1}), M_function {kind = k2}) =>
              // FIXME: is this needed at all?
              match ((k1, k2)) {
                | (FK_method, FK_method) => true
                | (FK_function, FK_function) => true
                | (FK_iface_method, FK_iface_method) => true
                | (FK_ctor, FK_ctor) => true
                | (FK_ctor, FK_static_ctor) => true
                | (FK_static_ctor, FK_ctor) => true
                | (FK_static_ctor, FK_static_ctor) => true
                | _ => false
              }
            | _ => false
          }
        }

        def fullname = pref + m.name;
        def decl = Decl (pref, m);
        match (globals.find (fullname)) {
          | Some (x :: xs) =>
            if (allow_overload (x)) {
              globals <- globals.replace (fullname, decl :: x :: xs);
              globals_by_id <- globals_by_id.add (decl.id, decl)
            } else {
              Message.error (m.loc, "redefinition of `" + m.name + "'");
              Message.error (x.loc, "first defined here")
            }
          | Some ([]) =>
            raise ICE("empty list in env")
          | None =>
            add_global_symbol (fullname, decl)
        }
      }

    public static global_by_id (id : int) : Decl {
      match (globals_by_id.find (id)) {
        | Some (r) => r
        | None => Util.ice ()
      }
    }

    expand_namespace_aliases (sym : string) : string
      {
        def ns = CSglue.get_ns (sym);
        if (ns == "") sym
        else
          match (this.namespace_aliases.find (ns)) {
            | Some (r) => r + "." + CSglue.strip_ns (sym)
            | None => sym
          }
      }

    public static lookup_global (name : string) : Decl {
      match (globals.find (name)) {
        | Some ([x]) => x
        | Some (_ :: _) => Util.ice ("multibound internal symbol " + name)
        | None => Util.ice ("unbound internal symbol " + name)
        | Some ([]) => Util.ice ()
      }
    }


    private build_params (parameters : list (System.Reflection.ParameterInfo)) : list (PT.Fun_parm) {
    
	    def location = Location("[MsCoreLib]", 0, 0);

      match (parameters) {
        | param :: rest =>          
          PT.Fun_parm (location, param.Name, PT.T_app ("System.Object", [])) ::
(*          PT.Fun_parm (location, param.Name, PT.T_app (param.ParameterType.ToString (), [])) :: *)
            this.build_params (rest)
        | [] => []
      } 
    }

    private build_constructors (class_name : string, 
                                type_constructors : list (System.Reflection.ConstructorInfo)) 
                                : list (PT.Class_member) {

    	def location = Location("[mscorlib:" + class_name + "]", 0, 0);
            
      match (type_constructors) {
        | constructor :: rest =>
          def constructor_params = List.from_array (constructor.GetParameters ());
          def parameters = this.build_params (constructor_params);
                       
          ExternalDeclarationsRegistry.make_ctor (this, location, class_name, parameters) ::
            this.build_constructors (class_name, rest)
        | [] => []
      }
    }

    private build_methods (class_name : string,
                           methods : list (System.Reflection.MethodInfo))
                           : list (PT.Class_member) {
     
    	def location = Location("[mscorlib:" + class_name + "]", 0, 0);
            
      match (methods) {
        | method :: rest =>
          
          def method_params = this.build_params (List.from_array (method.GetParameters ()));
          def method_rettype = 
            if (method.ReturnType.ToString () == "System.Void")
              PT.T_void ()
            else
              PT.T_app ("System.Object", []);
          (* def method_rettype = PT.T_app (method.ReturnType.ToString (), []); *)
          def is_static = method.IsStatic;
          
          def member = 
            if (method.IsStatic) 
              ExternalDeclarationsRegistry.make_static_method (this, location, class_name,
                                                               method.Name, method_rettype, method_params)
            else
              ExternalDeclarationsRegistry.make_method (this, location, class_name,
                                                        method.Name, method_rettype, method_params);
                          
          member :: this.build_methods (class_name, rest)
        | [] => []
      }
    }

    private build_properties (class_name : string,
                              properties : list (System.Reflection.PropertyInfo))
                              : list (PT.Class_member)
    {
    	def location = Location("[mscorlib:" + class_name + "]", 0, 0);
            
      match (properties) {
        | property :: rest =>
    
          def property_type = PT.T_app ("System.Object", []);

          def index_parameters = this.build_params (List.from_array (property.GetIndexParameters ()));
          
          def member = ExternalDeclarationsRegistry.make_property (this, location, class_name,
                                                                   property.Name, property_type,
                                                                   property.CanRead, property.CanWrite,
                                                                   index_parameters);
    
          member :: this.build_properties (class_name, rest)
        | [] => []
      }
    }

    public lookup_in_system_dll (name : string) : list (Decl) {
      
      if (externals.mem (name))
        [externals.get (name)]
      else {  
        def type_from_system_dll = ExternalDeclarationsRegistry.SystemDll.GetType (name);
              
        if (type_from_system_dll != null) {
        
          def is_class = type_from_system_dll.IsClass;
          
          def base_type = type_from_system_dll.BaseType;

    	    def location = Location("[mscorlib:" + name + "]", 0, 0);

          def type_constructors = List.from_array (type_from_system_dll.GetConstructors ());
          def type_methods = List.from_array (type_from_system_dll.GetMethods ());
          def type_properties = List.from_array (type_from_system_dll.GetProperties ());

          def constructors = this.build_constructors (name, type_constructors);
          def methods = this.build_methods (name, type_methods);
          def properties = this.build_properties (name, type_properties);
    
    	    def members = List.append (List.append (constructors, methods), properties);
          
  	      def declaration = PT.TD_class (members);
	        declaration.name <- name;
	        declaration.loc <- location;
          declaration.typarms <- PT.Typarms ([], []);
          declaration.t_extends <- None ();
          declaration.t_implements <- []; 
          declaration.modifiers <- [Mod_public ()];

          def type_info = Tyinfo.make_external (this, declaration);

          def decl = Env.add_type (type_info);
      
          externals <- externals.add (name, decl);
        
          [decl]
        }
        else {
        
          []
        }
      }
    }

    public bare_lookup(name : string) : list (Decl)
    {
      def name' = this.expand_namespace_aliases (name);

      def append_not_in (acc : list (Decl), d : Decl) : list(Decl) {
        if (List.exists(fun (x : Decl) : bool {x.id == d.id}, acc))
          acc
        else
          d :: acc
      }

      def lookup_in (acc : list (Decl), pref : string) : list (Decl) {
        match (globals.find(pref + name')) {
          | Some (lst) => 
            List.fold_left(append_not_in, acc, lst)
          | None => acc
        }
      }

      if (name == name')
        match (this.locals.find (name)) {
          | Some (d) => 
            [d] // locals shadow globals
          | None =>
            def path = "" :: this.current_namespace :: this.open_namespaces;
            match (List.fold_left (lookup_in, [], path)) {
              | [] => this.lookup_in_system_dll (name)
              | decls => decls
            }
        }
      else
        match (lookup_in ([], "")) {
          | [] => this.lookup_in_system_dll (name)
          | decls => decls;
        }
    }
          
    public lookup_type (name : string) : Tyinfo {
      match (this.bare_lookup(name)) {
        | [{kind = D_type (t)}] => t
        | {kind = D_type} :: _ =>
          Message.error("type name `" + name + "' is ambiguous:");
          def print_one(d : Decl) : void 
             { Message.error(d.loc, "  - this") }
          List.iter(print_one, this.bare_lookup(name));
          raise Recovery();
        | [] =>
          Message.fatal_error("name `" + name + "' is unbound")
        | _ =>
          Message.fatal_error("name `" + name + "' was expected to be type")
      }
    }

    public add_open (ns : string) : void
      {
        def ns =
          if (ns == "") ns
          else ns + ".";
        this.open_namespaces <- List.append (this.open_namespaces, [ns]);
      }

    public add_namespace_alias (short_name : string, long_name : string) : void {
      this.namespace_aliases <- this.namespace_aliases.add(short_name, long_name)
    }
    
    public add_local (name : string, kind : Decl_kind, ty : Type) : (Env * Decl)
      {
        def c = this.copy();
        def d = Decl(name, kind, ty, Util.unsome (this.parent_fun));
        c.locals <- c.locals.replace(name, d);
        (c, d)
      }
      
    public in_prefix (pref : string) : Env
      {
        def env' = this.copy ();
        env'.current_namespace <- this.current_namespace + pref + ".";
        env'
      }

    public copy () : Env
      {
        def c = Env ();
        c.open_namespaces <- this.open_namespaces;
        c.current_namespace <- this.current_namespace;
        c.namespace_aliases <- this.namespace_aliases;
        c.parent_fun <- this.parent_fun;
        c.locals <- this.locals;
        c
      }

    public this () 
      {
        this.current_namespace <- "";
        this.open_namespaces <- [];
        this.locals <- Map.string_map();
        this.namespace_aliases <- Map.string_map();
      }
  }


} // ns
