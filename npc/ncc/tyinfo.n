open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;

namespace Nemerle.Compiler {

(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

class Tyinfo
  {
    variant Member =
      [
        | Mem_methods { methods : list (M_function); }
        | Mem_field { fld : M_field; }
      ]
      
    record Subtyping_relation
      {
        td : Type_decl;
        args : list (option (Type));
      }
    
    field enclosing_type : option (Type_decl);
    field tydecl : Type_decl;
    field ref subtypes : Int_map (Subtyping_relation);
    field ref members : String_map (Member);
    field ref working_on : bool;
    // FIXME methods to implement
    
    method this (par : option (Type_decl), td : Type_decl) 
      { 
        this#enclosing_type <- par;
        this#tydecl <- td;
      }

    method lookup_method (name : string) : list (M_function) =
      match this#members#find(name) with [
        | Some (Mem_methods (?x)) => x
        | _ => Nil()
      ];
      
    method lookup_field (name : string) : option (M_field) =
      match this#members#find(name) with [
        | Some (Mem_field (?x)) => Some(x)
        | _ => None()
      ];

    method how_subtypes (td : Type_decl) : option (list (option (Type))) =
      match this#subtypes#find(td#id) with [
        | Some (?sr) => Some(sr#args)
        | None => None()
      ];

    method fullname () : string = 
      let td = this#tydecl in td#env#current_namespace + td#name;

    fun td_name (td : Type_decl) : string = (lookup(td#id))#fullname();

    value ref infos : Int_map(Tyinfo);
    
    fun lookup (id : int) : Tyinfo =
      match infos#find(id) with [
        | Some (?ti) => ti
        | None => Util.ice()
      ];

    fun lookup (td : Type_decl) : Tyinfo = lookup(td#id);
    
    fun make (decls : list (Type_decl)) : void =
      letfun tydecl_f (par : option (Type_decl), d : Type_decl) : option (Type_decl) = {
        infos <- infos#add(d#id, Tyinfo(par, d));
        Some (d)
      } and decl_f (_ : option (Type_decl), _ : Class_member) : void = () 
      in {
        infos <- Map.int_map();
        Treeutil.decl_walk(tydecl_f, decl_f, None(), decls);
      };

    type Subinfo = Int_map (Subtyping_relation);


    fun determine_subtyping () : void = 
      letfun add_subtyping_of (ti : Tyinfo, s : Subinfo, t : T_app) : Subinfo =
        let (?sub, ?ti') = Tyutil.subst_of_app (t) in
        letfun add_sr (s : Subinfo, sr : Subtyping_relation) : Subinfo =
          match s#find (sr#td#id) with [
            | Some (?sr') =>
              letfun opt_eq (a : option (Type), b : option (Type)) : bool =
                match (a, b) with [
                  | (Some (?t1), Some (?t2)) => 
                    Tyutil.types_eq (t1, Tyutil.fresh_vars(ti#tydecl, t2))
                  | (None, None) => true
                  | _ => false
                ]
              in
              if List.forall2 (opt_eq, sr#args, sr'#args) then s
              else {
                Message.error ("type `" + td_name(sr#td) + 
                               "' is implemented by type `" +
                               ti#fullname() +
                               "' twice under different instantiations");
                Message.error ("second one through `" + ti'#fullname() + "'");
                s
              }
            | None => 
              s#add (sr#td#id, sr)
          ]
        in
        letfun add_sr_from_parent (s : Subinfo, _ : int, 
                                   sr : Subtyping_relation) : Subinfo =
          letfun apply_sub (t : option (Type)) : option (Type) =
            match t with [ 
              | Some (?x) => Some (x /- sub) 
              | None => None ()
            ]
          in
          let new_sr = Subtyping_relation (sr#td, List.map (apply_sub, sr#args)) in
          add_sr (s, new_sr)
        in {
          make_srs (ti');
          let s = ti'#subtypes#fold(add_sr_from_parent, s) in
          let new_sr = 
            Subtyping_relation (ti'#tydecl, 
                                List.map (fun (x : Type) : option (Type) => Some (x), t#args))
          in add_sr (s, new_sr)
        }

      and make_srs (ti : Tyinfo) : void =
        if ti#subtypes != null then ()
        else
          Util.locate(ti#tydecl#loc, fun () : void =>
            if ti#working_on then {
              Message.error("type definition for `" + ti#fullname() + "' is cyclic");
              ti#subtypes <- Map.int_map ()
            } else 
              letfun add_srs (s : Subinfo, t : Type) : Subinfo =
                match t with [
                  | T_app ?t => add_subtyping_of (ti, s, t)
                  | _ =>
                    {
                      Message.error("cannot implement nor extend non-class type");
                      s
                    }
                ]
              in
              let td = ti#tydecl in
              let types =
                match td#t_extends with [
                  | Some (?t) => Cons (t, td#t_implements)
                  | None => td#t_implements
                ]
              in {
                ti#working_on <- true;
                ti#subtypes <- List.fold_left (add_srs, Map.int_map (), types);
                ti#working_on <- false;
              }
          )
      in infos#iter(fun (_ : int, ti : Tyinfo) : void => make_srs(ti));

    fun run (decls : list (Type_decl)) : void {
      make(decls);
      determine_subtyping();
    }
  }

} // ns
