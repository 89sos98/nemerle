\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\kw}[1]{{\textcolor{kwcolor}{\tt #1}}}
\newcommand{\ra}{\texttt{ -> }}

\definecolor{kwcolor}{rgb}{0.2,0.4,0.0}
\definecolor{lgray}{rgb}{0.8,0.8,0.8}

\title{Rekonstrukcja typów z odraczaniem}
\author{Micha{\l} Moskal}
\institute{Zimowy Obóz Studentów Informatyki \\
Szklarska Porêba}
\date{30 listopada 2004}


\begin{document}

\section{Zaczynamy!}

\frame{\titlepage}

\frame{
\frametitle{Nemerle? A co to takiego?}
\begin{itemize}
  \item jêzyk programowania wysokiego poziomu
  \item ogólnego przeznaczenia
  \item od pocz±tku projektowany z my¶l± o \net
  \item funkcjonalny i obiektowy
  \item potê¿ny system metaprogramowania
\end{itemize}
}

\frame{
\frametitle{Po co to to?}

\begin{itemize}
  \item chcieli¶my po³±czyæ programowanie obiektowe (w sensie C\#) z programowaniem
        funkcjonalnym
\begin{itemize}
 \item podstawowa struktura programu jest obiektowa
 \item metody w ¶rodku zaimplementowane funkcjonalnie
 \item ³atwy dostêp do cech imperatywnych (operator \texttt{!})
\end{itemize}
  \item u¿ywanie ró¿nych funkcjonalno¶ci platformy \net\ jest znacznie ³atwiejsze
        w C\# ni¿ w adaptacjach istniej±cych jêzyków funkcjonalnych
  \item nacisk na ³atwe utrzymanie kodu (makra, rekonstrukcja typów)
  \item makra!
    
\end{itemize}
}
\frame{
\frametitle{Projekty}

\begin{itemize}
  \item serwer HTTP i aplikacji Sioux
  \item system przepisywania termów Speagram
  \item konwerter C\# \texttt{->} Nemerle
  \item kompilator :-)
\end{itemize}
}


\section{Wszyscy lubimy przyk³ady}

\frame[containsverbatim]{
\frametitle{Cze¶æ}

\begin{verbatim}
// typy po prawej i po :
class Hello {
  public static Main () : void
  {
    System.Console.Write ("Hello world!\n");
  }
}
\end{verbatim}
}


\frame[containsverbatim]{
\frametitle{Brak rekonstrukcji}
\begin{verbatim}
// C#
public static void SendMessage (byte[] addr, int port, 
                                string data)
{
  IPEndPoint ip = new IPEndPoint (new IPAddress (addr), port);
  TcpClient client = new TcpClient (ip);
  NetworkStream str = client.GetStream ();
  byte[] data = Encoding.UTF8.GetBytes (data);
  str.Write (data, 0, data.Length);
  client.Close ();
}
\end{verbatim}
}

\frame[containsverbatim]{
\frametitle{Rekonstrukcja}
\begin{verbatim}
// Nemerle
public static SendMessage (addr : array [byte],
                           port : int, data : string) : void
{
  def ip = IPEndPoint (IPAddress (addr), port);
  def client = TcpClient (ip);
  def str = client.GetStream ();
  def data = Encoding.UTF8.GetBytes (data);
  str.Write (data, 0, data.Length);
  client.Close ();
}
\end{verbatim}
}


\frame[containsverbatim]{
\frametitle{Brak rekonstrukcji II}
\begin{verbatim}
public static
Dictionary<string, int> CountEach (string[] args)
{
  Dictionary<string, int> d = new Dictionary<string, int>();
  foreach (string s in args) {
    if (d.ContainsKey (s))
      d[s] += 1;
    else
      d[s] = 1;
  }
  return d;
}
\end{verbatim}
}

\frame[containsverbatim]{
\frametitle{Rekonstrukcja II}
\begin{verbatim}
public static
CountEach (args : array [string]) : Dictionary [string, int]
{
  def d = Dictionary ();
  foreach (s in args) {
    if (d.ContainsKey (s))
      d[s] += 1;
    else
      d[s] = 1;
  }
  d
}
\end{verbatim}
}

\end{document}

% vim: language=polish
