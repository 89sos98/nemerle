/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler
{
  public class Typer3
  {
    current_fun : Fun_header;
    current_type : TypeBuilder;
    messenger : Messenger;
    static_proxies : Hashtable [int, IField] = Hashtable ();


    public this (ty : TypeBuilder, fn : Fun_header)
    {
      current_fun = fn;
      current_type = ty;

      messenger = Passes.Solver.CurrentMessenger;
    }


    IsTopLevelFun : bool
    {
      get { current_fun.decl == null }
    }


    LocalRef (decl : LocalValue) : TExpr
    {
      LocalRef (decl, for_store = false)
    }


    LocalRef (decl : LocalValue, for_store : bool) : TExpr
    {
      def decl = decl.Redirect;
      def is_this = decl.ValKind is LocalValue.Kind.ClosurisedThisPointer;

      def res =
        if (decl.InClosure)
          if (!for_store && is_this && IsTopLevelFun)
            TExpr.This ()
          else {
            assert (decl.ClosureVal != null);
            assert (decl.ClosureField != null);
            def clo = TExpr.LocalRef (decl.ClosureVal.Type, decl.ClosureVal);
            TExpr.FieldMember (clo, decl.ClosureField)
          }
        else if (is_this)
          TExpr.This ()
        else
         TExpr.LocalRef (decl);

      res.ty = decl.Type;
      res
    }


    SingleMemberLookup (tb : TypeInfo, name : string) : IMember
    {
      match (tb.LookupMember (name)) {
        | [mem] => mem
        | _ => assert (false)
      }
    }


    AddTupledMethod (tb : TypeBuilder, parm_cnt : int) : void
    {
      if (parm_cnt == 0)
        tb.Define (<[ decl:
          public apply (_ : object) : object {
            apply ()
          } ]>)
      else if (parm_cnt == 1) {}
      else {
        def objects = List.Repeat (<[ object ]>, parm_cnt);
        tb.Define (<[ decl:
          public apply (o : object) : object
          {
            apply (o :> @* (.. $objects))
          }
        ]>);
      }
    }
    

    EmitStaticProxy (meth : IMethod) : TExpr
    {
      unless (static_proxies.Contains (meth.GetId ())) {
        def parms = meth.GetHeader ().parms;
        def parm_cnt = parms.Length;
        def fnty = InternalType.GetFunctionType (parm_cnt).InternalType;
        
        def name = Util.tmpname ("_N_static_proxy");
        def parm_names =
          parms.Map (fun (_) { Util.tmpname ("_N_sp_parm") });
        def formal_parms =
          parm_names.Map (fun (name) { <[ parameter: $(name : dyn) : object ]> });
        def parm_refs =
          List.Map2 (parm_names, parms, fun (name, parm) {
            <[ $(name : dyn) :> $(parm.ty : typed) ]> 
          });
          
        def builder =
          current_type.DefineNestedType (<[ decl:
            private class $(name : dyn) : $(fnty : typed)
            {
              public single_instance : $(name : dyn);
              static this ()
              {
                single_instance = $(name : dyn) ();
              }

              public apply (.. $formal_parms) : object
              {
                $(TExpr.StaticRef (meth.GetMemType (), meth) : typed)
                (.. $parm_refs)
              }
            }
          ]>);

        AddTupledMethod (builder, parm_cnt);
        
        builder.MarkWithSpecialName ();
        builder.Compile ();

        static_proxies [meth.GetId ()] =
          SingleMemberLookup (builder, "single_instance") :> IField;
      }

      def field = static_proxies [meth.GetId ()];
      TExpr.StaticRef (field.GetMemType (), field)
    }
    

    [Nemerle.NotImplemented]
    HandleLocalFunction (fn : Fun_header) : void
    {
    }
    

    // expects reversed list
    BuildSequence (exprs : list [TExpr]) : TExpr
    {
      match (exprs) {
        | [] =>
          TExpr.Literal (InternalType.Void, Literal.Void ())
        | x :: xs =>
          def loop (acc, l) {
            match (l) {
              | [] => acc
              | TExpr.DefValIn (name, val, null) :: xs =>
                loop (TExpr.DefValIn (acc.Type, name, val, acc), xs)
              | x :: xs =>
                loop (TExpr.Sequence (acc.Type, x, acc), xs)
            }
          }
          loop (x, xs)
      }
    }


    PrepareClosure () : list [TExpr]
    {
      if (current_fun.closure_vars.IsEmpty) []
      else {
        def clo_type = current_type.DefineNestedType (<[ decl:
          private class $(Util.tmpname ("closure") : dyn)
          { }
        ]>);
        def closure_val =
          LocalValue (current_fun, "_N_closure", clo_type.GetMemType (), 
                      LocalValue.Kind.Plain (), is_mutable = false);
        foreach (decl in current_fun.closure_vars) {
          def ptdecl = <[ decl: 
            internal mutable 
              $(Util.tmpname (decl.Name) : dyn) : $(decl.Type : typed);
          ]>;
          decl.ClosureField = clo_type.DefineAndReturn (ptdecl) :> IField;
          decl.ClosureVal = closure_val;
        }
        def ctor = clo_type.DefineAndReturn (<[ decl: internal this () {} ]>);
        def ctor = Option.UnSome (ctor);
        def ctor_call = 
          TExpr.Call (clo_type.GetMemType (),
                      TExpr.StaticRef (ctor.GetMemType (), ctor), []);
                      
        clo_type.MarkWithSpecialName ();
        clo_type.Compile ();

        [TExpr.DefValIn (InternalType.Void, closure_val, ctor_call, null)]
      }
    }


    LoadParameters () : list [TExpr]
    {
      mutable initializers = [];
      
      foreach (fp in current_fun.parms) {
        def parm = fp.decl;

        if (parm.InClosure) {
          def a = TExpr.Assign (InternalType.Void,
                                LocalRef (parm, for_store = true), 
                                TExpr.LocalRef (parm.Type, parm));
          
          initializers = a :: initializers
        // this should be dead code with generics
        } else if (fp.ty.Fix ().IsSystemObject && ! parm.Type.Fix ().IsSystemObject) {
          def local = LocalValue (current_fun, parm.Name, parm.Type, 
                                  LocalValue.Kind.Plain (), is_mutable = parm.IsMutable);
          parm.Redirect = local;
          def val =
            TExpr.TypeConversion (parm.Type,
                                  TExpr.LocalRef (fp.ty, parm),
                                  parm.Type,
                                  ConversionKind.IL (true));
                                 
          def a = TExpr.DefValIn (InternalType.Void, local, val, null);
          initializers = a :: initializers
        } else {}
      }

      initializers
    }


    GetBaseCall () : option [TExpr]
    {
      // put base () / this () call before storing 'this' in closure inside constructor
      if (current_fun.name == ".ctor" && !current_type.IsValueType)
        match (current_fun.body) {
          | FunBody.Typed (TExpr.Sequence (TExpr.Call as basecall, rest)) =>
            current_fun.body = FunBody.Typed (rest);
            Some (Walk (basecall))

          | FunBody.Typed (TExpr.Call as basecall) =>
            current_fun.body = FunBody.Typed (BuildSequence ([]));
            Some (Walk (basecall))

          | FunBody.Typed (TExpr.TailCall as basecall) =>
            current_fun.body = FunBody.Typed (BuildSequence ([]));
            Some (Walk (basecall))
            
          | FunBody.Typed (body) =>
            Message.Warning (body.loc, body.ToString ());
            assert (false)

          | _ => assert (false)
        }
      else None ()
    }
    

    // the result is reversed!
    PrepareProlog () : list [TExpr]
    {
      // assigments of parameters and 'this' to closure fields
      // interleaved with base (..) call in constructor
      mutable initializers = [];

      // we build the initialization stuff of method:
      // 1. method's closure ctor()
      // 2. store parameters into closure
      // 3. base (..) / this (..) for constructors
      // 4. store 'this' in closure

      initializers = PrepareClosure ();

      initializers = LoadParameters () + initializers;

      match (GetBaseCall ()) {
        | Some (call) =>
          initializers = call :: initializers;
        | None => {}
      }

      // store 'this' into closure object
      foreach (d in current_fun.closure_vars) 
        when (d.InClosure && 
              d.ValKind is LocalValue.Kind.ClosurisedThisPointer) {
          def ini =
            TExpr.Assign (InternalType.Void,
                          LocalRef (d, for_store = true),
                          TExpr.This (current_type.GetMemType ()));
          initializers = ini :: initializers;
        }

      initializers
    }
    

    public Run () : void
    {
      Util.locate (current_fun.loc, {
        def initializers = PrepareProlog ();

        match (current_fun.body) {
          | FunBody.Typed (body) =>
            current_fun.body = FunBody.Typed (BuildSequence (Walk (body) :: initializers))
          | _ => assert (false)
        }
      })
    }


    Walk (expr : TExpr) : TExpr
    {
      expr.Walk (DoWalk)
    }


    [Nemerle.NotImplemented]
    EmitLoop (hd : Fun_header, parms : list [Parm]) : TExpr
    {
    }


    EmitDelegateProxy (expr : TExpr) : TExpr * IMethod
    {
      def decl =
        match (expr.Type.Fix ()) {
          | MType.Fun (from, ret_type) as ty =>
            def parms =
              from.Fix ().GetFunctionArguments ().Map (fun (ty) {
                def name = Util.tmpname ("_N_parm");
                (<[ parameter: $(name : dyn) : $(ty : typed) ]>,
                 <[ $(name : dyn) ]>)
              });
            def (parms, parm_refs) = List.Split (parms);
            
            <[ decl: 
              private class $(Util.tmpname ("_N_delegate_proxy") : dyn)
              {
                funptr : $(ty : typed);
                public this (fp : $(ty : typed))
                {
                  funptr = fp;
                }

                public InvokeDelegate (.. $parms) : $(ret_type : typed)
                {
                  funptr (.. $parm_refs)
                }
              }
            ]>

          | _ => assert (false)
        }

      def tb = current_type.DefineNestedType (decl);
      tb.MarkWithSpecialName ();
      tb.Compile ();

      def ctor = SingleMemberLookup (tb, ".ctor");

      def ctor_call =
        TExpr.Call (tb.GetMemType (),
                    TExpr.StaticRef (ctor),
                    [Parm (expr)]);

      (ctor_call, SingleMemberLookup (tb, "InvokeDelegate") :> IMethod)
    }


    EmitDelegateCtor (ctor : IMethod, parm : TExpr) : TExpr
    {
      def (obj, meth) =
        match (parm) {
          | TExpr.StaticRef (meth is IMethod) =>
            (TExpr.Literal (InternalType.Object, Literal.Null ()),
             meth)
             
          | TExpr.MethodRef (obj, meth, _) =>
            (Walk (obj), meth)
            
          | _ =>
            EmitDelegateProxy (Walk (parm))
        }

      TExpr.Call (ctor.DeclaringType.GetMemType (),
                  TExpr.StaticRef (meth.GetMemType (), ctor),
                  [Parm (obj), Parm (TExpr.MethodAddress (meth))])
    }


    EmitCall (func : TExpr, parms : list [Parm], is_tail : bool) : TExpr
    {
      foreach (p in parms)
        p.expr = Walk (p.expr);

      def just_call (func) {
        if (is_tail)
          TExpr.TailCall (func, parms)
        else
          TExpr.Call (func, parms)
      }

      def plain_call () {
        def meth = InternalType.GetFunctionType (parms.Length).ApplyMethod;
        just_call (TExpr.MethodRef (func.ty, Walk (func), meth, false))
      }

      match (func) {
        // check if it's a base.Foo call
        | TExpr.MethodRef (
           TExpr.LocalRef (ty = ty, 
                           decl = LocalValue where (ValKind = 
                                      LocalValue.Kind.ClosurisedThisPointer) as decl) as obj, 
                         meth, _) when ! ty.Equals (decl.Type) =>
          just_call (TExpr.MethodRef (func.ty, Walk (obj), meth, true))
                           
        | TExpr.MethodRef (obj, meth, notvirt) =>
          just_call (TExpr.MethodRef (func.ty, Walk (obj), meth, notvirt))
          
        | TExpr.StaticRef (_ is IMethod)
        | TExpr.OpCode
        | TExpr.Base =>
          just_call (func)

        | TExpr.LocalRef (LocalValue where 
                          (ValKind = LocalValue.Kind.Function (hd, _)) as decl) =>
          match (hd.usage) {
            | FunctionUsage.UsedJustOnce =>
              EmitLoop (hd, parms)

            | _ =>
              _ = decl;
              // FIXME
              plain_call ()
          }

        | _ => plain_call ()
      }
    }


    DoWalk (expr : TExpr) : TExpr
    {
      // Message.Debug ($ "dowalk: $expr");
      match (expr) {
        | TExpr.LocalRef (decl) =>
          LocalRef (decl)
          
        | TExpr.StaticRef (_ is IField) =>
          null

        | TExpr.StaticRef (meth is IMethod) =>
          EmitStaticProxy (meth)

        // we do not support any other staticrefs here
        // everything should be handled by Typer2 already
        | TExpr.StaticRef => assert (false)
          
        | TExpr.DefFunctionsIn (funs, body) =>
          foreach (fn in funs)
            HandleLocalFunction (fn);
          Walk (body)

        // handled by Typer2.LambdaTransform
        | TExpr.MethodRef => assert (false)

        | TExpr.Call (TExpr.StaticRef (m is IMethod), [parm])
          when
            m.GetFunKind () is FunKind.Constructor && 
            m.DeclaringType.IsDelegate =>
          EmitDelegateCtor (m, parm.expr)

        | TExpr.TailCall (func, parms)
        | TExpr.Call (func, parms) =>
          EmitCall (func, parms, expr is TExpr.TailCall)

        | _ => null
      }
    }
  }
}
