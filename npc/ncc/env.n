open Nemerle.Compiler;
open Nemerle.Compiler.Env;
open Nemerle.Collections;


namespace Nemerle.Compiler {

variant Local_kind =
  [
    | Local_fun
    | Local_parm
    | Local_value { is_ref : bool; }
    | Local_exn
    | Local_pattern
  ]
  
class Local_decl 
  {
    field loc : Location;
    field name : string;
    field ref ty : Type;
    field id : int;
    field kind : Local_kind;

    method this (n : string, k : Local_kind, ty : Type)
      {
         this#loc <- Location_stack.top();
         this#name <- n;
         this#ty <- ty;
         this#kind <- k;
         this#id <- Util.next_id();
      }
  }

class Env 
  {
    value ref globals : String_map (list (Class_member));

    field ref open_namespaces : list (string);
    field ref current_namespace : string;
    field ref namespace_aliases : String_map (string);
    field ref locals : String_map (Local_decl);

    fun add_global (pref : string, m : Class_member) : void =
      let fullname = pref + m#name in
//    let _ =  print_endline ("add " + fullname) in
      letfun allow_overload (n : Class_member) : bool =
        match (n, m) with [
          | (M_function {fun_kind = FK_method}, 
             M_function {fun_kind = FK_method}) => true
          | (M_function {fun_kind = FK_function}, 
             M_function {fun_kind = FK_function}) => true
          | (M_iface_method, M_iface_method) => true
          | (M_function {fun_kind = ?k1}, 
             M_function {fun_kind = ?k2}) =>
               match (k1, k2) with [
                 | (FK_ctor, FK_ctor) => true
                 | (FK_ctor, FK_static_ctor) => true
                 | (FK_static_ctor, FK_ctor) => true
                 | (FK_static_ctor, FK_static_ctor) => true
                 | _ => false
               ]
          | _ => false
        ]
      in
      match globals#find (fullname) with [
        | Some (Cons (?x, ?xs)) =>
          if allow_overload (x) then
            globals <- globals#add(fullname, Cons (m, Cons (x, xs)))
          else {
            Message.error (m#loc, "redefinition of `" + m#name + "'");
            Message.error (x#loc, "first defined here")
          }
        | Some (Nil) =>
          raise ICE("empty list in env")
        | None =>
          globals <- globals#add(fullname, List.cons(m))
      ];

    method bare_lookup(name : string) : list (Class_member) =
      letfun append_not_in (acc : list (Class_member), d : Class_member) : list(Class_member) =
        if List.exists(fun (x : Class_member) : bool => x#id == d#id, acc) then
          acc
        else
          Cons(d, acc)
      in
      letfun lookup_in (acc : list (Class_member), pref : string) : list (Class_member) =
        match globals#find(pref + name) with [
          | Some (?lst) => List.fold_left(append_not_in, acc, lst)
          | None => acc
        ]
      in
      let path = Cons("", Cons(this#current_namespace, 
                               this#open_namespaces)) in
      List.fold_left(lookup_in, Nil(), path);

    method lookup_type(name : string) : Type_decl =
      match this#bare_lookup(name) with [
        | Cons(M_type (?t), Nil) => t
        | Cons(M_type, _) =>
          {
            Message.error("type name " + name + " is ambiguous:");
            letfun print_one(d : Class_member) : void =
               Message.error(d#loc, "  - this")
            in List.iter(print_one, this#bare_lookup(name));
            raise Recovery();
          }
        | Nil =>
          Message.fatal_error("name " + name + " is unbound")
        | _ =>
          Message.fatal_error("name " + name + " was expected to be type")
      ];

    method add_open (ns : string) : void =
      let ns =
        if ns == "" then ns
        else ns + "."
      in
      this#open_namespaces <- List.append (this#open_namespaces, List.cons (ns));

    method add_namespace_alias (short_name : string, long_name : string) : void =
      this#namespace_aliases <- this#namespace_aliases#add(short_name, long_name);
    
    method add_local (name : string, kind : Local_kind, ty : Type) : Env =
      let c = this#copy() in {
        c#locals <- c#locals#add(name, Local_decl(name, kind, ty));
        c
      };
      
    method add_local (name : string, kind : Local_kind) : Env = 
      this#add_local(name, kind, null);
    
    method copy () : Env =
      let c = Env () in {
        c#open_namespaces <- this#open_namespaces;
        c#current_namespace <- this#current_namespace;
        c#namespace_aliases <- this#namespace_aliases;
        c#locals <- this#locals;
        c
      };

    method this () 
      {
        this#current_namespace <- "";
        this#open_namespaces <- Nil();
        this#locals <- Map.string_map();
        this#namespace_aliases <- Map.string_map();
      }
  }


} // ns
