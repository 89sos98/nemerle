/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module XmlDump {

  p (s : string) : void { printf ("%s\n", s) }
  
  xmlescape (s : string) : string {
    def buf = System.Text.StringBuilder();

    for (mutable i = 0; i < s.Length; ++i)
      match (s[i]) {
        | '"' => ignore (buf.Append("&quot;"))
        | '<' => ignore (buf.Append("&lt;"))
        | '&' => ignore (buf.Append("&amp;"))
        | c => ignore (buf.Append(c))
      };

    buf.ToString();
  }

  attr (name : string, val : string) : string {
    " " + name + "=\"" + xmlescape (val) + "\" "
  }

  loc (l : Location) : string {
    attr ("file", l.File) +
    attr ("line", l.Line.ToString ())
/*    
    +
    (if (l.comment != null)
      attr ("comment", l.comment)
     else "")
*/       
  }

  dump_typarms (tp : Typarms) : void {
    def dump_tv (n : string, color : int) : void {
      def dump_constraint (c : Constraint) : void {
        if (c.tyvar.Equals ((n, color))) {
          p ("<constraint>");
          dump_ty (c.ty);
          p ("</constraint>");
        } else ()
      };
      p ("<tvar" + attr("name", n) + attr("color", color.ToString ()) + ">");
      List.Iter (tp.constraints, dump_constraint);
      p ("</tvar>");
    };

    p ("<typarms>");
    List.Iter (tp.tyvars, dump_tv);
    p ("</typarms>");
  }

  dump_ty (t : Type) : void {
    match (t) {
      | Type.T_app (Splicable_string.SS_string ({ idl = n }), a) =>
        p ("<tapp" + attr ("ref", Util.qid_of_list (n)) + ">");
          List.Iter (a, dump_ty);
        p ("</tapp>");
      | Type.T_app (_, _) =>
        Util.ice ("Spliced string in xmldump")
      | Type.T_prod (a) =>
        p ("<tprod>");
          List.Iter (a, dump_ty);
        p ("</tprod>");
      | Type.T_fun (t1, t2) =>
        p ("<tfun>");
          p ("<from>");
            dump_ty (t1);
          p ("</from>");
          p ("<to>");
            dump_ty (t2);
          p ("</to>");
        p ("</tfun>");
      | Type.T_void => p ("<tvoid/>");
      | Type.T_ref (t) =>
        p ("<tref>");
          dump_ty (t);
        p ("</tref>");
      | Type.T_out (t) =>
        p ("<tout>");
          dump_ty (t);
        p ("</tout>");
      | Type.T_array (t, Splicable_int.SI_int (rank)) =>
        p ("<tarray" + attr ("rank", sprintf ("%d", rank)) + ">");
          dump_ty (t);
        p ("</tarray>");
      | Type.T_spliced =>
        p ("<tspliced>");
        p ("</tspliced>");
      | Type.T_type_list =>
        p ("<ttypelist>");
        p ("</ttypelist>");
      | Type.T_infer =>
        p ("<tinfer>");
        p ("</tinfer>");
      | Type.T_typed =>
        p ("<ttyped>");
        p ("</ttyped>");

      | Type.T_array => Util.ice ("Spliced string in xmldump")
    } 
  }
  
  dump_class_member (mem : Class_member) : void {
    match (mem) {
      | Class_member.M_type (t) => dump_tydecl (t)
      | Class_member.M_field (t) =>
        p ("<field " + attr ("name", Macros.StringOfSString (mem.name)) + loc (mem.loc) + ">");
          dump_mods (mem.modifiers.mods);
          p ("<type>");
            dump_ty (t);
          p ("</type>");
        p ("</field>");

      | Class_member.M_enum  =>
        p ("<enum_field " + attr ("name", Macros.StringOfSString (mem.name)) +
           loc (mem.loc) + ">");
        dump_mods (mem.modifiers.mods);
        p ("</enum_field>");

      | Class_member.M_property (t, _, dims, get, set) =>
        p ("<property " + attr ("name", Macros.StringOfSString (mem.name)) + loc (mem.loc) +
           attr ("is_readable",
                 match (get) { None => "no" | _ => "yes" }) +
           attr ("is_writeable",
                 match (set) { None => "no" | _ => "yes" }) +
           ">");
        dump_mods (mem.modifiers.mods);
        p ("<type>");
        dump_ty (t);
        p ("</type>");
        
        when (List.Length (dims) > 0) {          
          def dump_parm (fp : Fun_parm) : void {
            p ("<parm" + attr ("name", Macros.StringOfSString (fp.name)) + ">");
            p ("<type>");
              dump_ty (fp.ty);
              p ("</type>");
              p ("</parm>");
          };

          p ("<parms>");
            List.Iter (dims, dump_parm);
          p ("</parms>");
        };
        p ("</property>");

      | Class_member.M_event (t, add, remove) =>
        p ("<event " + attr ("name", Macros.StringOfSString (mem.name)) + loc (mem.loc) +
           attr ("is_addable",
                 match (add) { None => "no" | _ => "yes" }) +
           attr ("is_removable",
                 match (remove) { None => "no" | _ => "yes" }) +
           ">");
        dump_mods (mem.modifiers.mods);
        p ("<type>");
        dump_ty (t);
        p ("</type>");
        
        p ("</event>");
        
      | Class_member.M_function (h, k, _) =>
        p ("<method " + attr ("name", Macros.StringOfSString (mem.name)) + loc (mem.loc) + ">");
          dump_mods_noend (mem.modifiers.mods);
            match (k) {
              | Fun_kind.FK_ctor => p ("<mod-ctor/>")
              | Fun_kind.FK_static_ctor => p ("<mod-ctor/>")
              | _ => ()
            };
          p ("</modifiers>");
          
          dump_typarms (h.typarms);

          def dump_parm (fp : Fun_parm) : void {
            p ("<parm" + attr ("name", Macros.StringOfSString (fp.name)) + ">");
              p ("<type>");
                dump_ty (fp.ty);
              p ("</type>");
            p ("</parm>");
          };
          
          p ("<parms>");
            List.Iter (h.parms, dump_parm);
          p ("</parms>");
          p ("<ret-type>");
            dump_ty (h.ret_type);
          p ("</ret-type>");
          
        p ("</method>");
    }
  }

  dump_mods_noend (mods : NemerleAttributes) : void {
    p ("<modifiers>");    
    when (mods %&& NemerleAttributes.Public) p ("<mod-public/>");
    when (mods %&& NemerleAttributes.New) p ("<mod-new/>");
    when (mods %&& NemerleAttributes.Protected) p ("<mod-protected/>");
    when (mods %&& NemerleAttributes.Internal) p ("<mod-internal/>");
    when (mods %&& NemerleAttributes.Abstract) p ("<mod-abstract/>");      
    when (mods %&& NemerleAttributes.Virtual) p ("<mod-virtual/>");
    when (mods %&& NemerleAttributes.Sealed) p ("<mod-sealed/>");
    when (mods %&& NemerleAttributes.Static) p ("<mod-static/>");
    when (mods %&& NemerleAttributes.Module) p ("<mod-module/>");      
    when (mods %&& NemerleAttributes.Struct) p ("<mod-struct/>");
    when (mods %&& NemerleAttributes.Macro) p ("<mod-macro/>");
    when (mods %&& NemerleAttributes.Override) p ("<mod-override/>");
    when (mods %&& NemerleAttributes.Mutable) p ("<mod-mutable/>");      
  }

  dump_mods (mods : NemerleAttributes) : void {
    dump_mods_noend (mods);
    p ("</modifiers>");
  }
  
  dump_tydecl (td : TopDeclaration) : void {
    def elt =
      match (td) {
        | TopDeclaration.TD_class => "class"
        | TopDeclaration.TD_alias => "alias"
        | TopDeclaration.TD_interface => "interface"
        | TopDeclaration.TD_variant => "variant"
        | TopDeclaration.TD_variant_option => "variant_option"
        | TopDeclaration.TD_macro => "macro"
        | TopDeclaration.TD_delegate => "delegate"
        | TopDeclaration.TD_enum => "enum"
        | _ => ""          
      };
    p ("<" + elt + 
           attr ("name", Macros.StringOfSString (td.name)) +
           loc (td.loc) +
       ">");
    dump_mods (td.modifiers.mods);
/*    dump_typarms (td.typarms);
    match (td.t_extends) {
      | _ :: _ => 
        p ("<extends>");
        List.Iter (td.t_extends, dump_ty);
        p ("</extends>");
      | [] => ()
    };
*/    
    def members (decls : list <Class_member>) : void {
      p ("<members>");
      List.Iter (decls, dump_class_member);
      p ("</members>");
    };
    
    match (td) {
      | TopDeclaration.TD_macro => p ("<macro/>")
      | TopDeclaration.TD_class (_, _, d) => members (d)
      | TopDeclaration.TD_interface (_, _, d) => members (d)
      | TopDeclaration.TD_variant_option (d) => members (d)
      | TopDeclaration.TD_delegate => p ("<delegate/>")
      | TopDeclaration.TD_enum => p ("<enum/>")        
      | TopDeclaration.TD_variant (_, _, d) => members (d)
      | TopDeclaration.TD_alias (_, t) =>
        p ("<aliased>");
        dump_ty (t);
        p ("</aliased>");
      | _ => ()
    };

    p ("</" + elt + ">");
  }

  public run () : void {
    def ti_run (ti : TypeBuilder) : void { dump_tydecl (ti.pt_tydecl) };
    p ("<unit>");
    TypeBuilder.SourceTopIter (ti_run);
    p ("</unit>");
  }
  
}
} // end ns
