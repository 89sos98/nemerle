/*
 * Copyright (c) 2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler.Typedtree;
using Nemerle.Collections;
using Nemerle.Compiler.SolverMacros;

namespace Nemerle.Compiler 
{
  /** Represents a single possibility in the overloading resulution process.
      It is used in the TExpr.Overloaded node.  */
  public class OverloadPossibility
  {
    /** Tell if this overload is still possible in the current solver.  */
    public StillPossibile : bool
    {
      // FIXME
      get { false }
    }
    

    /** If not [StillPossibile], then return an error message describing why. 
        Warning: It invalidates the current solver, which has to be the
        toplevel one.  */
    public ErrorMessage : string
    {
      // FIXME
      get { "" }
    }
    

    /** Enforce this particular overloading possibility in the current
        solver.  */
    [Nemerle.NotImplemented]
    public Compile () : TExpr
    {
    /*
                | MemberKind.Type (t) =>
                  List.RevAppend (handle_type_construction (t), acc)

                | MemberKind.Method (m) =>
                  match (m.GetExternName ()) {
                    | None =>
                      TExpr.StaticRef (loc = expr.loc, ty = m.GetFreshType (),
                                    mem = x) :: acc
                  }


                | MemberKind.Property (p) =>
                  TExpr.StaticPropertyRef (loc = expr.loc, ty = x.GetMemType (),
                                         prop = p) :: acc

                | MemberKind.Field =>
                  TExpr.StaticRef (loc = expr.loc, ty = x.GetMemType (), mem = x)
                  :: acc

                | MemberKind.Event (e) =>
                  if (e.DeclaringType.SameAs (ctx.parent_type)) {
                    def field = (e :> NemerleEvent).storage_field;
                    if (field == null)
                      acc
                    else {
                      TExpr.StaticRef (loc = expr.loc, ty = field.GetMemType (),
                                    mem = field) :: acc
                    }
                  }
                  else
                    acc
                  */
    }


    public override ToString () : string
    {
      member.ToString ()
    }
    

    public this (solver : Solver, ty : TyVar, expr : TExpr, member : IMember)
    {
      when (expr == null)
        assert (member.IsStatic);

      this.expr = expr;
      this.member = member;
      this.solver = solver;
      this.ty = ty;
    }
  
    expr : TExpr;
    ty : TyVar;
    member : IMember;
    solver : Solver;
    public mutable VarArgs : bool;

    /** Filter out impossible overloads from the list.  If there are no 
        possible overloads and we are in the error reporting mode, present
        an appropriate error message.  */
    static public OnlyPossible (overloads : list [OverloadPossibility]) 
                                          : list [OverloadPossibility]
    {
      assert (!overloads.IsEmpty);

      def res = List.Filter (overloads, 
                                fun (o : OverloadPossibility) { 
                                  o.StillPossibile 
                                });
      
      when (res.IsEmpty) {
        def hd = List.Hd (overloads);
        def messenger = hd.solver.CurrentMessenger;
        ReportError (messenger,
                     $ "none of the overloads of $(hd.member.Name) is "
                       "possible:");
          foreach (overload in overloads)
            ReportError (messenger,
                         $ "  $overload because $(overload.ErrorMessage)");
      }
      
      res
    }

  }
}
