open Nemerle.Compiler;
open Nemerle.Compiler.Util;

namespace Nemerle.Compiler {

  class ICE extends System.Exception
    {
      field msg : string;
      method this (m : string) = this#msg <- m;
    }

  class Recovery extends System.Exception
    {
      method this () {}
    }

  class Util 
    {
      value ref current_id : int;
      fun next_id () : int {
        current_id <- current_id + 1;
        current_id
      }

      fun ('a) ice (msg : string) : 'a = raise ICE(msg);
      fun ('a) ice () : 'a = raise ICE("(see backtrace)");

      fun ('a) locate (l : Location, f : void -> 'a) : 'a
        {
          Location_stack.push(l);
          try f() finally Location_stack.pop()
        }

      // of course this is broken and can be better
      fun concat_strings (sep : string, l : list (string)) : string =
        match l with [
          | Cons (?x, Nil) => x
          | Cons (?x, ?xs) => x + sep + concat_strings (sep, xs)
          | Nil => ""
        ];
      
      fun is_new (d : Class_member) : bool =
        letfun is_mod (m : Modifier) : bool =
          match m with [ Mod_new => true | _ => false ]
        in List.exists (is_mod, d#modifiers);
        
      fun is_private (d : Class_member) : bool =
        letfun is_mod (m : Modifier) : bool =
          match m with [ Mod_private => true | _ => false ]
        in List.exists (is_mod, d#modifiers);

      fun is_protected (d : Class_member) : bool =
        letfun is_mod (m : Modifier) : bool =
          match m with [ Mod_protected => true | _ => false ]
        in List.exists (is_mod, d#modifiers);
      
      fun is_public (d : Class_member) : bool =
        if is_private (d) then false
        else if is_protected (d) then false
        else true;

      fun ('a) unsome (x : option ('a)) : 'a =
        match x with [
          | Some (?x) => x
          | None => ice ("unsome")
        ];
    }
  
  class Message 
    {
      value ref error_cnt : int;
      value ref warning_cnt : int;

      fun location_to_string (l : Location) : string =
        if l == null then
          "(no location)"
        else
          l#file + ":" + string_of_int(l#line) + ":" + 
          string_of_int(l#column);

      fun report (l : Location, m : string) : void =
        let l' =
          if l == null then Location_stack.top()
          else l
        in print_endline (Message.location_to_string(l') + ": " + m);

      fun error (l : Location, m : string) : void {
        Message.error_cnt <- Message.error_cnt + 1;
        Message.report (l, "error: " + m);
      }
        
      fun error (m : string) : void = Message.error (null, m);

      fun warning (l : Location, m : string) : void {
        Message.warning_cnt <- Message.warning_cnt + 1;
        Message.report (l, "warning: " + m);
      }
        
      fun warning (m : string) : void = Message.warning (null, m);

      fun debug (l : Location, m : string) : void {
        Message.report (l, "debug: " + m);
      }
        
      fun debug (m : string) : void = Message.debug (null, m);

      fun ('a) fatal_error (l : Location, m : string) : 'a {
        Message.error(l, m);
        raise Recovery()
      }
      
      fun ('a) fatal_error (m : string) : 'a = Message.fatal_error (null, m);

      fun ('a) exit (ret : int) : 'a = extern "System.Environment.Exit";

      fun maybe_bailout (fscked_up : bool) : void =
        if Message.error_cnt != 0 then {
          if fscked_up then
            print_endline ("confused by earlier errors bailing out")
          else ();
          Message.exit (1)
        } else ();
        
      fun maybe_bailout () : void = Message.maybe_bailout (false);
    }

    class Location_stack
      {
        value ref s : list (Location);
        
        fun push (l : Location) : void =
          if l == null then ice() else
          Location_stack.s <- Cons(l, Location_stack.s);

        fun pop () : void =
          match Location_stack.s with [
            | Nil => Util.ice()
            | Cons(_, ?t) => Location_stack.s <- t
          ];

        fun top () : Location =
          match Location_stack.s with [
            | Nil => Location("?", 0, 0)
            | Cons(?h, _) => h
          ];

        fun this () { Location_stack.s <- Nil(); }
      }
  
}
