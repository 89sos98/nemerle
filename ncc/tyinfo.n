(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

(** This pass operates on [Tyinfo] objects created for
    each type declaration found in source files.  These objects are
    already created, but most fields are empty.  The main function of
    this pass is [Tyinfo.run].  *)

public class Tyinfo
  {
    variant Member
      {
        | Mem_methods { methods : list (M_function); }
        | Mem_field { fld : M_field; }
        | Mem_property { prop : M_property; }
      }
      
    class Subtyping_relation
      {
        public ti : Tyinfo;
        public args : list (option (Type));
      }
    
    enclosing_type : option (Tyinfo);
    public id : int;

    public mutable pt_tydecl : PT.Type_decl; // xmldump
    
    public mutable tydecl : Type_decl;
    mutable t_extends : option (Type);
    mutable t_implements : list (Type);
    mutable is_module : bool;
    public name : string;
    public env : Env;
    public loc : Location;
    public mutable modifiers : list (Modifier);
    public mutable member_list : list (Class_member);
    public mutable contained_types : list (Tyinfo);
    public mutable typarms : list (Tyvar.T);
    public mutable tenv : Tyvar.TEnv;
    
    mutable subtypes : Int_map (Subtyping_relation);
    mutable member_map : String_map (Member);
    mutable phase : int; // used by iter function
    // FIXME methods to implement
    
    static mutable infos : Int_map (Tyinfo);        // FIXME: this can be list
    public static mutable can_check_constraints : bool;

    public lookup_method (name : string) : list (M_function) {
      match (this.member_map.find(name)) {
        | Some (Mem_methods (x)) => x
        | _ => []
      }
    }
      
    public lookup_field (name : string) : option (M_field) {
      match (this.member_map.find(name)) {
        | Some (Mem_field (x)) => Some (x)
        | _ => None()
      }
    }

    public lookup_property (name : string) : option (M_property) {
      match (this.member_map.find (name)) {
        | Some (Mem_property (x)) => Some (x)
        | _ => None()
      }
    }

    public how_subtypes (ti : Tyinfo) : option (list (option (Type))) {
      match (this.subtypes.find (ti.id)) {
        | Some (sr) => Some (sr.args)
        | None => None ()
      }
    }

    (** Return qualified type name. *)
    public fullname () : string { this.env.current_namespace + this.name }

    (** Return name without any dots. *)
    public basename () : string { this.name }
   
    (** Return type we were defined in (exception for toplevel types). *)
    public enclosing_tyinfo () : Tyinfo {
      Util.unsome (this.enclosing_type)
    }

    (**
     * Return list of types that we directly subtype.
     *
     * <remarks>
     *   This includes [extends] and [implements], as well as parent variant
     *   type for variant options.
     * </remarks>
     *)
    public direct_supertypes () : list (Type) {
      match (this.tydecl) {
        | TD_variant_option =>
          [(this.enclosing_tyinfo ()).generic_type ()]
        | _ =>
          match (this.t_extends) {
            | Some (t) => t :: this.t_implements
            | None => this.t_implements
          }
      }
    }

    (**
     * If this type was defined as [class Foo ('a, 'b) { ... }] then return 
     * type expression [Foo ('a, 'b)]. 
     *
     * <remarks>
     *   Use mainly with [fresh_subst ()] or [make_subst ()].
     * </remarks>
     *)
    public generic_type () : Type
      {
        def make_tv (tv : Tyvar.T) : Type { T_var (tv) }
        T_app (this, List.map (make_tv, this.typarms))
      }

    public fresh_generic_type () : Type {
      this.generic_type () /- this.fresh_subst ()
    }

    (**
     * Return substitution replacing each of our type parameters with fresh
     * type variable.
     *)
    public fresh_subst () : Subst {
      Tyvar.fresh_subst (this.typarms)
    }

    (** 
     * Construct substitution resulting from applying this type constructor
     * to specified arguments.
     *
     * <remarks>
     *   For example assuming our type parameters are are ('a, 'b), then 
     *   [make_subst (t1, t2)] produces substitution { 'a := t1; 'b := t2 }.
     * </remarks>
     *)
    public make_subst (args : list (Type)) : Subst
      {
        def loop (ini : Subst, parms : list (Tyvar.T), args : list (Type)) : Subst {
          match ((parms, args)) {
            | (p :: ps, a :: args) =>
              match (a) {
                | T_var (p') =>
                  if (p.id == p'.id) ini
                  else loop (ini.add (p.id, a), ps, args)
                | _ => loop (ini.add (p.id, a), ps, args)
              }
            | ([], []) => ini
            | _ => Util.ice ()
          }
        }
        loop (Map.int_map (), this.typarms, args)
      }
    
    // check if we can access D from THIS
    // FIXME
    can_access (d : Class_member) : bool { true }
    
    can_access_any (ds : list (Class_member)) : bool {
      List.exists (fun (d : Class_member) : bool { this.can_access (d) }, ds)
    }

    type Subinfo = Int_map (Subtyping_relation);

    // iterate over tyinfos, but supertypes are always processed before subtypes
    // otherwise source-code order is retained
    public static iter (f : Tyinfo -> void) : void
      {
        def working_on = Util.next_id ();
        def done = Util.next_id ();
        def sub_do (t : Type) : void {
          match (t) {
            | T_app (ti, _) => maybe_f (ti)
            | _ => ()
          }
        }
        and maybe_f (ti : Tyinfo) : void {
          if (ti.phase == done) ()
          else if (ti.phase == working_on)
            Message.error(ti.loc, "type definition for `" + ti.fullname() + "' is cyclic")
          else {
            ti.phase <- working_on;
            Util.locate (ti.loc, fun () : void {
              List.iter (sub_do, ti.direct_supertypes ());
              f (ti)
            });
            ti.phase <- done
          }
        }
	if (infos == null) 
          ()
        else 
	  infos.iter(fun (_ : int, ti : Tyinfo) : void { maybe_f (ti) });
      }

    static add_subtyping_of (ti : Tyinfo, s : Subinfo, t : T_app) : Subinfo
      {
        def (sub, ti') = Tyutil.subst_of_app (t);
        def add_sr (s : Subinfo, sr : Subtyping_relation) : Subinfo {
          match (s.find (sr.ti.id)) {
            | Some (sr') =>
              mutable problem <- "";
              def opt_eq (a : option (Type), b : option (Type)) : bool {
                match ((a, b)) {
                  | (Some (t1), Some (t2)) =>
                    if (Tyutil.types_eq (t1, t2)) true
                    else {
                      problem <- "types " + t1.as_string() + " and " +
                                 t2.as_string() + " are not compatible";
                      false
                    }
                  | (None, None) => true
                  | _ => false
                }
              }
              if (List.forall2 (opt_eq, sr.args, sr'.args)) s
              else {
                Message.error ("type `" + sr.ti.fullname () + 
                               "' is implemented by type `" +
                               ti.fullname() +
                               "' twice under different instantiations");
                if (ti'.id == sr.ti.id)
                  Message.error ("second one directly")
                else
                  Message.error ("second one through `" + ti'.fullname() + "'");
                Message.error (problem);
                s
              }
            | None => 
              s.add (sr.ti.id, sr)
          }
        }
        def add_sr_from_parent (s : Subinfo, _ : int, 
                                sr : Subtyping_relation) : Subinfo
          {
            def apply_sub (t : option (Type)) : option (Type) {
              match (t) { 
                | Some (x) => Some (x /- sub) 
                | None => None ()
              }
            }
            def new_sr = Subtyping_relation (sr.ti, List.map (apply_sub, sr.args));
            add_sr (s, new_sr)
          }
          
        def s = ti'.subtypes.fold(add_sr_from_parent, s);
        def args = List.map (fun (x : Type) : option (Type) { Some (x) }, t.args);
        def new_sr = Subtyping_relation (ti', args);
        add_sr (s, new_sr)
      }
      
    public subtyping_subst (ti : Tyinfo) : Subst {
      if (ti.id == this.id) 
        Map.int_map () // current type, no substitution
      else
        match (this.how_subtypes (ti)) {
          | None => Util.ice ()
          | Some (args) =>
            def f (t : option (Type)) : Type {
              match (t) {
                | Some (t) => t
                | None => Tyvar.free_variable ()
              }
            }
            ti.make_subst (List.map (f, args))
        }
      }
    
    // Return type of given member in this type (i.e. if type comes from
    // supertype, substitute it). Only works for methods and fields.
    public member_type (m : Class_member) : Type
      {
        def t =
          match (m) {
            | M_field f => f.ty
            | M_property p => p.ty
            | M_function f => Tyutil.fun_type (f.header)
            | M_value => Util.ice ()
          };
        t /- this.subtyping_subst (m.tyinfo);
      }

    add_member (d : Class_member) : void
      {
        Env.add_global (this.fullname () + ".", d);
        d.tyinfo <- this;
        this.member_list <- d :: this.member_list;
      }
      
    public static top_iter (f : Tyinfo -> void) : void
      {
	def phase = Util.next_id ();
        
        def wrap (_ : int, x : Tyinfo) : void {
          if (x.phase == phase) ()
          else {
            x.phase <- phase;
            match (x.enclosing_type) {
              | Some => ()
              | None => Util.locate (x.loc, fun () : void { f (x) })
            };
          }
        }
	if (infos == null)
          ()
        else
	  infos.iter (wrap)
      }

    public this (par : option (Tyinfo), env : Env, td : PT.Type_decl) 
      { 
        this.enclosing_type <- par;
        this.pt_tydecl <- td;
        this.env <- env;
        this.name <- td.name;
        this.modifiers <- td.modifiers;
        this.loc <- td.loc;
        
        this.subtypes <- Map.int_map ();
        this.member_map <- Map.string_map ();

        this.id <- Util.next_id ();

        if (infos == null) 
          infos <- Map.int_map () 
        else ();
        infos <- infos.add (this.id, this);
      }

    (** 
     * Construct typing environments for each declaration.
     *
     * <remarks>
     *   The first thing to do is to create typing environment [Tyvar.TEnv]
     *   for each type declaration.  Then typing environment is populated
     *   with type variables (transformed into [Tyvar.T] objects).  Finally
     *   constraints (type expressions, which are first bound) of each
     *   type variable are stored in [Tyvar.T].
     *
     *   Typing environment maps names of type variables to [Tyvar.T] objects.  
     * </remarks>
     *)
    make_tyenvs (tenv : Tyvar.TEnv) : void 
    {
        if (this.tenv != null) Util.ice () else ();
        def (tenv, tyvars) = tenv.add_typarms (this.env, this.pt_tydecl.typarms);
        this.tenv <- tenv;
        this.typarms <- tyvars;
        
        def bind_child (x : Tyinfo) : void
          {
            Util.locate (x.loc, fun () : void { x.make_tyenvs (tenv) });
            match (x.pt_tydecl) {
              | PT.TD_variant_option (members) => 
                x.typarms <- tyvars;
                x.modifiers <- Mod_public () :: Mod_sealed () :: x.modifiers;
                def make_public (d : PT.Class_member) : void {
                  d.modifiers <- Mod_public () :: d.modifiers
                }
                List.iter (make_public, members)
              | PT.TD_variant =>
                x.modifiers <- Mod_abstract () :: x.modifiers
              | _ => ()
            }
          }
        List.iter (bind_child, this.contained_types);
      }

    
    (** 
     * Bind type expressions occurring in type declarations. This
     * includes [extends] type, [implements] list, and aliased type
     * in case of type alias declaration.
     *
     * <remarks>
     *   Binding type expression refers to rewriting [Parsetree.Type]
     *   into [Typedtree.Type], which involves resolving names of type
     *   constructors (to [Tyinfo] objects) and type variables (to [Tyvar.T]
     *   objects).  
     * </remarks>
     *)
    bind_types () : void
      {
        def tenv = this.tenv;
        def bind (t : PT.Type) : Type { tenv.bind (this.env, t) }
        def td = this.pt_tydecl;
        def check_module (x : Modifier) : void {
          match (x) {
            | Mod_module => this.is_module <- true
            | _ => ()
          }
        }
        List.iter (check_module, this.modifiers);
        this.tydecl <-
          match (td) {
            | PT.TD_class => TD_class ()
            | PT.TD_alias (t) => TD_alias (bind (t))
            | PT.TD_interface => TD_interface ()
            | PT.TD_external (n) => TD_external (n)
            | PT.TD_variant => TD_variant ()
            | PT.TD_variant_option => TD_variant_option ()
            | PT.TD_macro => TD_macro ()
          };
        this.t_extends <- Option.map (bind, td.t_extends);
        this.t_implements <- List.map (bind, td.t_implements);
      }

    (** 
     * Construct datastructures we use to check subtyping relations.
     *
     * <remarks>
     *   This probably the hardest part of processing type declarations.
     *
     *   Each type directly subtypes types it extends or implements.  This
     *   pass computes transitive closure of direct subtyping relation
     *   and stores it [Tyinfo.subtypes] map.  .NET generics doesn't allow
     *   same type to be subtyped under different instantiations, so we
     *   use map from (id of) subtyped Tyinfo object to actual parameters
     *   of subtyped type.
     *
     *   Since this point during type binding we can check if subtyping
     *   constraints are satisfied upon instantiations of types.  This is
     *   reflected by setting [Tyinfo.can_check_constraints] variable.  We
     *   also check it for unsatisfied constraints in already bound types
     *   in the beginning of [Tyinfo.make_member_list] function.
     * </remarks>
     *)
    static determine_subtyping () : void
      {
        def make_srs (ti : Tyinfo) : void
          {
            def add_srs (s : Subinfo, t : Type) : Subinfo {
              match (t) {
                | T_app t => add_subtyping_of (ti, s, t)
                | _ =>
                  Message.error("cannot implement nor extend non-class type");
                  s
              }
            }
            ti.subtypes <- List.fold_left (add_srs, Map.int_map (), ti.direct_supertypes ())
          }
        iter (make_srs)
      }

    (** 
     * Collect type members (fields and methods, but not types, which
     * are already collected in [Tyinfo.contained_types]) and store
     * them in [Tyinfo.member_list] field.
     *
     * <remarks>
     *   Members are first transferred from the [Parsetree] into the
     *   [Typedtree] namespace by binding appropriate types.
     * </remarks> 
     *)      
    static make_member_list (this_ : Tyinfo) : void
      {
        def tenv = this_.tenv;
        can_check_constraints <- true;
        def types =
          match (this_.tydecl) {
            | TD_alias (t) => t :: this_.direct_supertypes ()
            | _ => this_.direct_supertypes ()
          };
        def check_type (t : Type) : void {
          match (t) {
            | T_ref (t) => check_type (t)
            | T_out (t) => check_type (t)
            | T_array (t) => check_type (t)
            | T_fun (ts, t) => check_type (ts); check_type (t)
            | T_void => ()
            | T_prod (ts) => List.iter (check_type, ts)
            | T_var => ()
            | T_app (ti, args) => 
              Tyvar.check_constraints (ti, args)
          }
        }
        def check_constraints_in_tv (tv : Tyvar.T) : void {
          List.iter (check_type, Tyvar.constraints (tv))
        }
        List.iter (check_type, types);
        List.iter (check_constraints_in_tv, this_.typarms);
        
        def bind_member (d : PT.Class_member) : void {
          Util.locate (d.loc, fun () : void
            {
              mutable tenv <- tenv;
              def bind (t : PT.Type) : Type { tenv.bind (this_.env, t) }
              def mkparm (p : PT.Fun_parm) : Fun_parm {
                Fun_parm (loc = p.loc, name = p.name, ty = bind (p.ty), decl = null)
              }
              def is_static (m : Modifier) : bool { 
                match (m) { Mod_static => true | _ => false } 
              }
              def is_static = 
                if (this_.is_module) true
                else List.exists (is_static, d.modifiers);
              def id = Util.next_id ();
              def d' =
                match (d) {
                  | PT.M_type => None ()
                  | PT.M_field (t, r, k) =>
                    if (is_static)
                      Some (M_value (bind (t), r, k))
                    else {
                      match (k) {
                        | Val_normal => ()
                        | Val_extern => 
                          Message.error ("non-static fields cannot be extern")
                      };
                      Some (M_field (bind (t), r))
                    }
                  | PT.M_property (t, r, w) =>
                    Some (M_property (bind (t), r, w))
                  | PT.M_function (h, k, b) =>
                    def k =
                      if (is_static)
                        match (k) {
                          | FK_method ([]) => FK_function ()
                          | FK_method => 
                            Message.error ("static function cannot implement anything");
                            FK_function ()
                          | FK_ctor => FK_static_ctor ()
                          | _ => Util.ice ()
                        }
                      else k;
                    def (tenv', typarms) = tenv.add_typarms (this_.env, h.typarms);
                    tenv <- tenv';
                    def h' = Fun_header (
                      ret_type = bind (h.ret_type),
                      typarms = typarms,
                      name = h.name,
                      parms = List.map (mkparm, h.parms),
                      id = id,
                      closure_vars = [],
                      tenv = tenv',
                      loc = h.loc);
                    Some (M_function (header = h', kind = k, body = b))
                };
              match (d') {
                | Some (d') =>
                  d'.name <- d.name;
                  d'.loc <- d.loc;
                  d'.modifiers <- d.modifiers;
                  d'.id <- id;
                  this_.add_member (d');
                | None => ()
              }
            })
        }

        def decls = 
          match (this_.pt_tydecl) {
            | PT.TD_class (ds) => ds
            | PT.TD_interface (ds) => ds
            | PT.TD_variant_option (ds) => 
              if (CSglue.is_capitalized (this_.name)) ()
              else Message.error (this_.loc, "variant options names must start with capital letters");
              ds
            | _ => []
          };
        
        this_.member_list <- [];
        List.iter (bind_member, decls);
        
        this_.member_list <- List.rev (this_.member_list);
        this_.contained_types <- List.rev (this_.contained_types);

        // we no longer need it, let GC kill it
        this_.pt_tydecl <- null;
      }

    (** 
     * Add record-like constructor to some classes. 
     *
     * <remarks>
     *   Record like constructor looks like this:
     *
     *   [[[
     *     this (x : int, y : string) {
     *       this.x <- x;
     *       this.y <- y;
     *     }
     *   ]]]
     *
     *   Constructor building function is in extensions.n.
     * </remarks>
     *)
    static add_implicit_ctor (ti : Tyinfo) : void {
      match (ti.tydecl) {
        | TD_class cl =>
          def is_field (m : Class_member) : bool {
            match (m) { M_field => true | _ => false }
          }
          if (List.forall (is_field, ti.member_list))
            match (ti.direct_supertypes ()) {
              | [] =>
                ti.add_member (Extensions.implicit_ctor (ti))
              | _ => ()
            }
          else ()

        | TD_variant_option =>
          ti.add_member (Extensions.implicit_ctor (ti))

        | _ => ()
      }
    }
      
    (** 
     * Construct maps from names to non-static fields and methods in
     * given type (including derived ones). 
     *
     * <remarks>
     *   This is used later in typing to lookup type members.
     * </remarks>
     *)
    static make_member_map (ti : Tyinfo) : void
      {
        def parent_members =
          match (ti.t_extends) {
            | Some (T_app (ti, _)) => ti.member_map
            | Some (_) => Util.ice ()
            | None =>
              match (ti.tydecl) {
                | TD_variant_option =>
                  (ti.enclosing_tyinfo ()).member_map
                | _ => Map.string_map ()
              }
          };
        def can_access (m : M_function) : bool { ti.can_access (m) }
        def parent_members =
          {
            def filter_accessible (ms : String_map (Member), n : string, 
                                      m : Member) : String_map (Member) {
              match (m) {
                | Mem_field (f) =>
                  if (ti.can_access (f)) ms.add (n, m)
                  else ms
                | Mem_property (f) =>
                  if (ti.can_access (f)) ms.add (n, m)
                  else ms
                | Mem_methods (meths) =>
                  match (List.filter (can_access, meths)) {
                    | [] => ms
                    | meths => ms.add (n, Mem_methods (meths))
                  }
              }
            }
            parent_members.fold (filter_accessible, Map.string_map ()) 
          };
        def process_decl (mem : String_map (Member), d : Class_member) : String_map (Member) {
          Util.locate (d.loc, fun () : String_map (Member) {
            match (d) {
              | M_field f =>
                  match (parent_members.find (f.name)) {
                    | Some (Mem_field f') =>
                      if (Util.is_new (f)) ()
                      else Message.error ("field `" + f.name + 
                                          "' overrides a field from parent, but no `new'")
                    | Some (Mem_property p') =>
                      Message.error ("name `" + f.name + 
                                     "' used to be a property, it cannot be a field now")
                    | Some (Mem_methods ms) =>
                      Message.error ("name `" + f.name + 
                                     "' used to be a method, it cannot be a field now")
                    | None => ()
                  };
                  mem.add (f.name, Mem_field (f))
              | M_property p =>
                  match (parent_members.find (p.name)) {
                    | Some (Mem_field p') =>
                      Message.error ("name `" + p.name + 
                                     "' used to be a field, it cannot be a property now")
                    | Some (Mem_property p') =>
                      if (Util.is_new (p)) ()
                      else Message.error ("property `" + p.name + 
                                          "' overrides a field from parent, but no `new'")
                    | Some (Mem_methods ms) =>
                      Message.error ("name `" + p.name + 
                                     "' used to be a method, it cannot be a property now")
                    | None => ()
                  };
                  mem.add (p.name, Mem_property (p))
              | M_function f =>
                def fun_ty = Tyutil.fun_type (f.header);
                def put_f_in (meths : list (M_function)) : String_map (Member)
                  {
                    mutable replaced <- false;
                    def replace (acc : list (M_function), old : M_function) : list (M_function) {
                      if (Tyutil.types_eq (ti.member_type (old), fun_ty)) {
                        replaced <- true;
                        f :: acc
                      } else
                        old :: acc
                    }
                    def meths = List.fold_left (replace, [], meths);
                    def meths = 
                      if (replaced) meths
                      else f :: meths;
                     mem.replace (f.name, Mem_methods (meths))
                  }
                  
                def store_f () : String_map (Member) {
                  match (mem.find (f.name)) {
                    | Some (Mem_field) =>
                      {
                        Message.error ("name `" + f.name + 
                                       "' used to be a field, it cannot be a method now");
                        mem.add (f.name, Mem_methods ([f]))
                      }
                    | Some (Mem_property) =>
                      {
                        Message.error ("name `" + f.name + 
                                       "' used to be a property, it cannot be a method now");
                        mem.add (f.name, Mem_methods ([f]))
                      }
                    | Some (Mem_methods (meths)) => put_f_in (meths)
                    | None => mem.add (f.name, Mem_methods ([f]))
                  }
                }

                match (f) {
                  | {kind = FK_method (impl)} => store_f ()
                  | {kind = FK_ctor} => store_f ()
                  // FIXME we don't really want it. We should hide interface members
                  // in classes but not in interfaces
                  | {kind = FK_iface_method} => store_f ()
                  | _ => mem
                }
              | _ => mem
            }})
          }
        ti.member_map <- List.fold_left (process_decl, parent_members, ti.member_list);
      }

    (** 
     * Main function of type declaration handling pass.
     *
     * <remarks>
     *   - constructing typing environments [Tyinfo.make_tyenvs]
     *   - binding types [Tyinfo.bind_types]
     *   - determining subtyping relations [Tyinfo.determine_subtyping]
     *   - constructing lists of members [Tyinfo.make_member_list]
     *   - making implicit constructors [Tyinfo.add_implicit_ctor]
     *   - constructing member maps [Tyinfo.make_member_map] 
     * </remarks>
     *)
    public static run () : void 
      {
        if (infos == null) 
          ()
        else {
	        top_iter (fun (x : Tyinfo) : void { x.make_tyenvs (Tyvar.TEnv ()) });

          def bind_types (_ : int, x : Tyinfo) : void {
            Util.locate (x.loc, fun () : void { x.bind_types () })
          }
          infos.iter (bind_types);

          // FIXME: this is a bootstrapping solution
          ExternalDeclarationsRegistry.add_mscorelib_decls(); 
        
          determine_subtyping ();
          iter (make_member_list);
          iter (add_implicit_ctor);
          iter (make_member_map);
        }
      }

    public static make_external (env : Env, decl : PT.Type_decl) : Tyinfo {
      def type_info = Tyinfo (None (), env, decl);
      type_info.contained_types <- [];
      type_info.make_tyenvs (Tyvar.TEnv ());
      type_info.bind_types ();
      type_info
    }
  }

} // ns
