(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(* Transformations of quoted expressions into syntax trees
 *)

open Nemerle.Collections;

open Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Macros {

  (** create tree, which constructs variant of given name with
      given list of parameters 
   *) 
  make_call (head : string, exprs : list (Expr)) : Expr
    {
      def encaps_parm (e : Expr) : Parm
        { Parm (e); }
	
      E_call (E_ref ("Nemerle.Compiler.Parsetree." + head),
              List.map (encaps_parm, exprs))
    }
    
  (** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   *)
  'a make_quoted_list (f : 'a -> Expr, li : list ('a)) : Expr
    {
      match (li) {
        | [] => E_call (E_ref ("Nil"), [])
        | x::xs => E_call (E_ref ("Cons"), 
                           [Parm (f (x)); Parm (make_quoted_list (f, xs))])
      }
    }

  (** create syntax tree for constructing given string and int *)
  quoted_string (st : string) : Expr
    { E_literal (L_string (st)); }

  quoted_int (i : int) : Expr
    { E_literal (L_int (i)) }

  (** tree of string literal, describing constant of given bool value *)
  quoted_bool (va : bool) : Expr
    { E_literal (L_bool (va)) }

  quoted_literal (lit : Literal) : Expr
    {
      match (lit) {
	| L_void => E_ref ("Nemerle.Compiler.L_void")

    	| L_null => E_ref ("Nemerle.Compiler.L_null")

    	| L_int (val) => 
	  E_call (E_ref ("Nemerle.Compiler.L_int"), [Parm (quoted_int (val))])

    	| L_string (val) =>
	  E_call (E_ref ("Nemerle.Compiler.L_string"), [Parm (quoted_string (val))])

    	| L_float (val) =>
	  E_call (E_ref ("Nemerle.Compiler.L_float"), [Parm (E_literal (L_float (val)))])

    	| L_char (val) =>
  	  E_call (E_ref ("Nemerle.Compiler.L_char"), [Parm (E_literal (L_char (val)))])

    	| L_bool (val) =>
  	  E_call (E_ref ("Nemerle.Compiler.L_bool"), [Parm (quoted_bool (val))])
      }	
    }

  quoted_location (loc : Location) : Expr
    {
      E_call (E_ref ("Nemerle.Compiler.Location"), 
              [Parm (quoted_string (loc.file)); Parm (quoted_int (loc.line));
	       Parm (quoted_int (loc.column))])
    }

  (** transforms syntax tree of quoted type to its construction tree 
   *)
  quoted_type (t : Type) : Expr
  {
    match (t) {
      | T_app (tycon, args) =>
        make_call ("T_app", [quoted_string (tycon); 
                             make_quoted_list (quoted_type, args)])

      | T_var (name) => 
        make_call ("T_var", [quoted_string (name)])
        
      | T_ref (ty) =>
        make_call ("T_ref", [quoted_type (ty)])
	
      | T_out (ty) =>
        make_call ("T_ref", [quoted_type (ty)])
	
      | T_fun (from, to) =>
        make_call ("T_fun", [quoted_type (from); quoted_type (to)])
	
      | T_void =>
        E_ref ("Nemerle.Compiler.Parsetree.T_void")
	
      | T_prod (args) =>
        make_call ("T_prod", [make_quoted_list (quoted_type, args)])
    }	
  }

  quoted_expr (expr : Expr) : Expr 
    {
      def quoted_funheader ( h : Fun_header ) : Expr
        {
          def quoted_param (p : Fun_parm) : Expr
            {
    	      make_call ("Fun_parm", 
	                 [quoted_location (p.loc); quoted_string (p.name);
	                  quoted_type (p.ty)])
  	    }
    
          make_call ("Fun_header", 
                     [quoted_location (h.loc); quoted_string (h.name);
	    	      quoted_type (h.ret_type); 
  		      make_quoted_list (quoted_param, h.parms)])
        }
    
      def quoted_fundecl (d : Function_decl) : Expr
        {
  	  make_call ("Function_decl",
	             [quoted_funheader (d.header); quoted_expr (d.body)])
	}

      // debug information
      //print_tree (expr, "");
      //print_endline ("transforms into");
    
      def ret = match (expr) {
        | E_ref (id) =>
	  make_call ("E_ref", [quoted_string (id)])
//	  <[ E_ref ($(quoted_string (id)))) ]>

	| E_member (obj, member) =>
	  make_call ("E_member", [quoted_expr (obj); quoted_string (member)])
	  
	| E_call (func, params) =>
	  // create construction tree of given call parameter
	  def quoted_param (p : Parm) : Expr
	    {
	      make_call ("Parm", [quoted_bool (p.is_ref); quoted_expr (p.expr);
	                          quoted_string (p.name)])    
	    }
	
	  
	  make_call ("E_call", 
	             [quoted_expr (func); make_quoted_list (quoted_param, params)]);

	| E_assign (target, source) =>
	  make_call ("E_assign", [quoted_expr (target); quoted_expr (source)])

	| E_let (is_ref, name, val) =>
	  make_call ("E_let", [quoted_bool (is_ref); quoted_string (name);
                               quoted_expr (val)])

	| E_letpat (pat, val) =>
          make_call ("E_letpat", [quoted_pattern (pat); quoted_expr (val)])

	| E_letfun (funs) =>
	  make_call ("E_letfun", [make_quoted_list (quoted_fundecl, funs)])

	| E_lambda (decl) =>
	  make_call ("E_lambda", [quoted_fundecl (decl)])

	| E_match (expr, cases) =>
	  def quoted_case (cas : Match_case) : Expr
	    {
	      make_call ("Match_case", [quoted_location (cas.loc); 
	                                quoted_pattern (cas.pattern);
					quoted_expr (cas.body)])
	    }
	    
	  make_call ("E_match", [quoted_expr (expr);
	                         make_quoted_list (quoted_case, cases)])    

	| E_raise (exc) =>
	  make_call ("E_raise", [quoted_expr (exc)])

	| E_if (cond, e_then, e_else) =>
	  make_call ("E_if", [quoted_expr (cond); quoted_expr (e_then);
                              quoted_expr (e_else)])

	| E_try_with (body, exn, exn_ty, handler) => 
	  make_call ("E_try_with", [quoted_expr (body); quoted_string (exn);
	                            quoted_type (exn_ty); quoted_expr (handler)])

	| E_try_finally (body, handler) =>
	  make_call ("E_try_finally", [quoted_expr (body); quoted_expr (handler)])

        | E_require (assertions) =>
	  make_call ("E_require", [quoted_expr (assertions)])
	  
        | E_ensure (assertions) =>
	  make_call ("E_ensure", [quoted_expr (assertions)])

	| E_literal (l) => 
	  make_call ("E_literal", [quoted_literal (l)]);

	| E_this =>
	  E_ref ("Nemerle.Compiler.Parsetree.E_this")

	| E_type_conversion (expr, ty) =>
	  make_call ("E_type_conversion", [quoted_expr (expr); quoted_type (ty)])

	| E_type_enforcement (expr, ty) =>
	  make_call ("E_type_enforcement", [quoted_expr (expr); quoted_type (ty)])

	| E_sequence (seq) =>
	  make_call ("E_sequence", [make_quoted_list (quoted_expr, seq)])

	| E_tuple (args) =>
	  make_call ("E_tuple", [make_quoted_list (quoted_expr, args)])

	| E_quoted (e) => 
	  Message.error ("compound of several <[ ... ]> macro scopes is not allowed");
	  e
	| E_unquoted (e) => e
      };

//      print_tree (ret, "");
      ret

    } // end quoted_expr

  (** transforms syntax tree of quoted pattern to its construction 
      tree 
   *)	  
  quoted_pattern (pat : Pattern) : Expr 
    {
      match (pat) {
        | P_underscore => E_ref ("P_underscore")

        | P_variable (name) => 
          make_call ("P_variable", [quoted_string (name)])

        | P_tuple (args) =>
          make_call ("P_tuple", [make_quoted_list (quoted_pattern, args)])
          
        | P_record (args) => 
          def quoted_named_pattern (patt : Named_pattern) : Expr
            {
              make_call ("Named_pattern", 
	                 [quoted_string (patt.name); quoted_pattern (patt.pat)])
            }
             
           make_call("P_record", [make_quoted_list (quoted_named_pattern, args)])

        | P_cons (name, arg) =>
          make_call ("P_cons", [quoted_string (name); quoted_pattern (arg)])

        | P_literal (lit) =>
  	  make_call ("P_literal", [quoted_literal (lit)])

        | P_quoted_expr (e) =>
          Message.error ("compound of several <[ ... ]> macro scopes is not allowed");
          e

        | P_list (args) =>
          make_call ("P_list", [make_quoted_list (quoted_pattern, args)])

        | P_list_cons (hd, tl) =>
          make_call ("P_list_cons", [quoted_pattern (hd); quoted_pattern (tl)])
      } 
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  expr_to_pattern (exp : Expr) : Pattern 
    {
      def convert_params (pars : list (Parm), acc : list (Pattern)) : Pattern {
        match (pars) {
          | [] => P_tuple (List.rev (acc))
          | x::xs => convert_params (xs, expr_to_pattern (x.expr) :: acc)
        }
      }

      match (exp) {
        | E_ref (id) => P_cons (id, P_underscore ())
        | E_call (E_ref (constr), params) => 
          P_cons (constr, convert_params (params, []))
        | E_literal (lit) => P_literal (lit)
        | _ => 
          Message.fatal_error ("Bad constructed quoted expression in pattern matching (CIE)")
      }
    }

  (** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   *)    
  print_tree (exp : Expr, empty : string) : void
    {
      def convert_params (pars : list (Parm)) : void {
        match (pars) {
          | [] => ()
          | x::xs => print_tree (x.expr, empty + "  "); convert_params (xs )
        }
      }

      print_string (empty);

      match (exp) {
        | E_ref (id) => print_string ("E_ref ("); print_string (id); print_endline (")")
        | E_call (E_ref (constr), params) => 
          print_string ("E_call (E_ref ("); print_string (constr); print_endline ("),");
          convert_params (params);
          print_string (empty);
	  print_endline (")")
        | E_literal (lit) => print_endline ("E_literal")
        | _ => 
	   print_endline ("other")
      }
    }
  
}
} // end ns
