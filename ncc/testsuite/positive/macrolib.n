// REFERENCE: Nemerle.Compiler

using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.IO;
using System;

macro forp (i, n : int, m : int, body)
syntax ("forpermutation", "(", i, "in", n, "to", m, ")", body)
{
  def a = array (m - n + 1);
  for (mutable j = 0; j < m - n + 1; j = j + 1)
    a[j] = j + n;
  mutable p = [];
  def r = System.Random ();
  for (mutable k = m - n; k >= 0; k = k - 1) {
    def rand = r.Next (k + 1);
    p = <[ $(a[rand] : int) ]> :: p;
    a[rand] <-> a[k];
  };
  <[
    def p = array $(Macros.Lift (p));
    for (mutable j = 0; j < $(m - n + 1 : int); j = j + 1) {
      $i = p[j];
      $body
    }
  ]>
}

macro generate_power (n : int) {
  def sqrt (x) { <[ def y = $x; y * y ]> };
  
  def pow (n, x) {
    if (n == 0)
      <[ 1.0 ]>
    else
      if (n % 2 == 0) // even
        sqrt (pow (n / 2, x))
      else
        <[ $x * $(pow (n - 1, x)) ]>
  }
  <[ fun (x) { $(pow (n, <[ x ]>)) } ]>
}

namespace A {
  macro gg (a)
  syntax ("ggg", a) { a }
}

macro ala()
{
  def tb = Nemerle.Macros.ImplicitCTX ().env.Define (<[ decl:
    public class haha {
      x : int;
      public this(){
        Console.WriteLine ("creating haha");
      }
    }
  ]>);
  tb.Compile ();
  <[ Console.WriteLine ("proba") ]>;
}

public interface ISerializable {
  Serialize () : void;
}

[Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance, Nemerle.MacroTargets.Class,
                     Inherited = true)]
macro Serializable (t : TypeBuilder)
{
  t.AddImplementedInterface (<[ ISerializable ]>)
}


[Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers, Nemerle.MacroTargets.Class,
                     Inherited = true)]
macro Serializable (t : TypeBuilder)
{
  def bla = t.DefineNestedType (<[ decl:
    public class Bla {
      public this () { }
      public f () : string { "f()" }

      public static Bla () : void  { Console.WriteLine ("from Bla.Bla") } 
    }
  ]>);
  bla.Compile ();

  /// here we list its fields and choose only those, which are not derived
  /// or static
  def fields = t.GetFields (BindingFlags.Instance %| BindingFlags.Public %|
                            BindingFlags.NonPublic %| BindingFlags.DeclaredOnly);

  /// now create list of expressions which will print object's data  
  mutable serializers = [];

  /// traverse through fields, taking their type constructors  
  foreach (x : IField in fields) {
    def tc = Tyutil.GetTypeTypeInfo (x.GetMemType ());
    def nm = Macros.UseSiteSymbol (x.Name);
    if (tc != null)
      if (tc.IsValueType)
        /// we can safely print value types as strings        
        serializers = <[
                         printf ("<%s>", $(x.Name : string));
                         System.Console.Write ($(nm : name));
                         printf ("</%s>\n", $(x.Name : string));
                       ]>
                       :: serializers
      else
        /// we can try to check, if type of given field also implements ISerializable
        if (Tyutil.subtypes (x.GetMemType (), <[ ttype: ISerializable ]>))
          serializers = <[
                           printf ("<%s>\n", $(x.Name : string));      
                           if ($(nm : name) != null)
                             $(nm : name).Serialize ()
                           else
                             printf ("<null/>\n");
                           printf ("</%s>\n", $(x.Name : string));
                         ]>
                         :: serializers
        else
          /// and finally, we encounter case when there is no easy way to serialize 
          /// given field
          Message.fatal_error ("field `" + x.Name + "' cannot be serialized")
    else
      Message.fatal_error ("field `" + x.Name + "' cannot be serialized")
  };
  // after analyzing fields, we create method in our type, to execute created
  // expressions
  t.Define (<[ decl: public Serialize () : void
                     implements ISerializable.Serialize {
                       .. $serializers
                     }
            ]>);

  t.Define (<[ decl: public foo : int = 5; ]>);
}


