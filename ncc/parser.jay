/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

%{
using System;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

class Parser {
  protected list result;

  class Located_ID {
    public string name;
    public Location loc;
  }

  class Fun_helper {
    public Fun_header header;
    public bool is_ctor;
    public list implements;
    public Fun_helper(Fun_header h, bool c, list i)
    {
    	header = h;
	is_ctor = c;
	implements = i;
    }
  }

  protected Lexer lex;

  string tmp_name()
  {
  	return "_N_" + (Util.next_id()).ToString();
  }

  list cons(object h, list t)
  {
  	return new list.Cons(h, t);
  }

  list nil()
  {
  	return new list.Nil();
  }

  option none()
  {
  	return new option.None();
  }

  option some(object x)
  {
  	return new option.Some(x);
  }

  void fixup_tydecl(object targ, list mods, Type_decl_base source)
  {
	Type_decl_base target = (Type_decl_base)targ;
			
        target.name = source.name;
        target.loc = source.loc;
        target.typarms = source.typarms;
        target.t_extends = source.t_extends;
        target.t_implements = source.t_implements;

	target.modifiers = mods;
  }
  
  void fixup_decl(object targ, list mods, Located_ID source)
  {
	Decl_base target = (Decl_base)targ;
			
        target.name = source.name;
        target.loc = source.loc;

	target.modifiers = mods;
  }

  Expr make_bin(Expr e1, string op, Expr e2)
  {
  	Expr rf = new Expr.E_ref(op);
	Expr cl = new Expr.E_call(rf, cons(new Parm(false, e1, ""), 
			              cons(new Parm(false, e2, ""), nil())));
  	locate(rf);
  	locate(cl);
	return cl;
  }
  
  Expr make_unary(string op, Expr e)
  {
  	Expr rf = new Expr.E_ref(op);
	Expr cl = new Expr.E_call(rf, cons(new Parm(false, e, ""), nil()));
  	locate(rf);
  	locate(cl);
	return cl;
  }

  Expr biseq(Expr e1, Expr e2)
  {
  	locate(e1);
  	return new Expr.E_sequence(cons(e1, cons(e2, nil())));
  }
  
  void locate(object o, Location l)
  {
  	((Located)o).loc = l;
  }

  void locate(object o)
  {
  	locate(o, lex.get_location());
  }
  
  bool is_empty_typarms(Typarms p)
  {
  	return (p.constraints is list.Nil) && (p.tyvars is list.Nil);
  }

  Located_ID make_located_id(string name)
  {
      Located_ID i = new Located_ID();
      i.name = name;
      i.loc = lex.get_location();
      return i;
  }

  public list parse(Lexer l)
  {
      lex = l;
      result = nil();
      yyparse(l);
      return result;
  }


%}

%token <int> NUMBER_LITERAL
%token <int> CHAR_LITERAL
%token <string> ID
%token <string> TYVAR
%token <string> STRING_LITERAL
%token <string> OP1
%token <string> OP2
%token <string> OP3
%token <string> OP4
%token <string> OP5
%token <string> OP6
%token <string> OP7

%token KW_ABSTRACT KW_CONST KW_EXTERN KW_INTERNAL KW_NEW KW_PRIVATE
%token KW_PROTECTED KW_SEALED KW_VOLATILE KW_NAMESPACE KW_BASE
%token KW_CLASS KW_ENUM KW_EXTENDS KW_FINALLY KW_IN KW_NULL KW_OUT
%token KW_PUBLIC KW_RAISE KW_REF KW_STRUCT KW_THIS KW_VARIANT
%token KW_INTERFACE KW_IMPLEMENTS KW_WHERE KW_TYPE KW_LET
%token KW_FUN KW_AND KW_TYMATCH KW_WITH KW_TRY KW_OPEN KW_VOID
%token KW_IF KW_THEN KW_ELSE KW_AS KW_MATCH
%token KW_STATIC KW_MUTABLE KW_DEF KW_MODULE
%token KW_ENSURE KW_REQUIRE

%token COLON_MORE LESS_MINUS MINUS_MORE EQ_MORE COLON_COLON
%token LESS_SQBRAC SQBRAC_MORE

%token ERROR

%nonassoc KW_RAISE LESS_MINUS KW_IF
%right COLON_COLON
%left OP7
%left OP6
%left OP5
%left OP4
%left OP3
%left OP2 '*'
%right OP1
%nonassoc UNARY

%right MINUS_MORE

%type <Located_ID> located_id located_qid located_id_or_dummy
%type <Location> locator
%type <string> qid
%type <Nemerle.Compiler.Parsetree.Type> ty prim_ty prod_ty
%type <bool> maybe_ref maybe_new maybe_mutable
%type <Type_decl> type_decl
%type <Type_decl_base> type_header
%type <Typarms> typarms ftyparms
%type <Expr> expr sequence prim_expr expr_or_sequence prim_expr2
%type <Fun_helper> fun_def_head
%type <Fun_body> fun_body
%type <Fun_header> lambda_head
%type <Class_member.M_function> fun_def
%type <Pattern> nl_pattern pattern maybe_pattern tuple_pattern
%type <Val_kind> maybe_extern
%type <Literal> literal

%type <list> maybe_implements comma_sep_types interface_members variant_options tyvars
%type <list> maybe_where where_constraints type_members attrs maybe_record record
%type <list> record_members non_empty_fun_parms fun_parms maybe_method_implements
%type <list> implemented_methods prod_ty_x expr_list non_empty_parameters parameters
%type <list> fun_defs match_cases namespace_or_type_decls record_patterns 
%type <list> comma_sep_patterns comma_sep_exprs list_exprs list_patterns

%type <option> maybe_extends

%start program

%%

program:
        namespace_or_type_decls		{ result = $1; }

namespace_or_type_decl:
          KW_OPEN located_qid ';'
	  	{
			$$ = new Top_decl.TD_open ($2.name);
			locate($$, $2.loc);
		}
        | KW_NAMESPACE located_id '=' located_qid ';'
		{
			$$ = new Top_decl.TD_namespace_alias ($2.name, $4.name);
			locate($$, $2.loc);
		}
	| KW_NAMESPACE located_qid '{' namespace_or_type_decls '}'
		{
			$$ = new Top_decl.TD_namespace ($2.name, $4);
			locate($$, $2.loc);
		}
	| type_decl
		{
			$$ = new Top_decl.TD_type ($1);
		}

located_id:
        ID      { $$ = make_located_id($1); }
	
located_id_or_dummy:
          located_id
        | '_'		{ $$ = make_located_id(tmp_name()); }

qid:
          ID           	{ $$ = $1; }
        | ID '.' qid   	{ $$ = $1 + "." + $3; }

located_qid:
        qid      { $$ = make_located_id($1); }

namespace_or_type_decls:
          namespace_or_type_decl namespace_or_type_decls
			{ $$ = cons($1, $2); }
        | /* */
			{ $$ = nil(); }

type_header:
          located_id typarms maybe_extends maybe_implements
	  	{
			Type_decl_base p = new Type_decl_base();
			
			p.name = $1.name;
			p.loc = $1.loc;
			p.typarms = $2;
			p.t_extends = $3;
			p.t_implements = $4;

			$$ = p;
	  	}

type_decl:
          attrs KW_TYPE type_header '=' ty ';'
	  	{
			$$ = new Type_decl.TD_alias($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_TYPE type_header '=' KW_EXTERN STRING_LITERAL ';'
		{
			$$ = new Type_decl.TD_external($6);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_INTERFACE type_header '{' interface_members '}'
		{
			$$ = new Type_decl.TD_interface($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_CLASS type_header '{' type_members '}'
		{
			$$ = new Type_decl.TD_class($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_MODULE type_header '{' type_members '}'
		{
			$$ = new Type_decl.TD_module($5);
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_STRUCT type_header '{' type_members '}'
		{
			$$ = new Type_decl.TD_class($5);
			// FIXME: set some attribute, that it's struct
			fixup_tydecl($$, $1, $3);
		}
        | attrs KW_VARIANT type_header '{' maybe_bar variant_options '}'
		{
			$$ = new Type_decl.TD_variant($6);
			fixup_tydecl($$, $1, $3);
		}

maybe_extends:
          /* */                 { $$ = none(); }
        | KW_EXTENDS ty         { $$ = some($2); }

maybe_implements:
          /* */                                 { $$ = nil(); }
        | KW_IMPLEMENTS comma_sep_types         { $$ = $2; }

comma_sep_types:
          ty                                    { $$ = cons($1, nil()); }
        | ty ',' comma_sep_types              { $$ = cons($1, $3); }

interface_members:
          /* */                                   { $$ = nil(); }
        | interface_member interface_members      { $$ = cons($1, $2); }

maybe_new:
          /* */   { $$ = false; }
        | KW_NEW  { $$ = true; }

interface_member:
        maybe_new fun_def_head ';'
		{
			Class_member m = new Class_member.M_function($2.header, 
                                new Fun_kind.FK_iface_method ($1), 
                                new Fun_body.FB_abstract ());
                        
			// FIXME: error message for this and implements
			m.name = $2.header.name;
			m.loc = $2.header.loc;
			m.modifiers = nil();
			$$ = m;
		}

variant_options:
          variant_option                    	{ $$ = cons($1, nil()); }
        | variant_option '|' variant_options    { $$ = cons($1, $3); }

variant_option:
        located_id maybe_record
		{
			Type_decl.TD_variant_option o = 
				new Type_decl.TD_variant_option($2);
			o.loc = $1.loc;
			o.name = $1.name;
			o.modifiers = nil();
			o.t_extends = none();
			o.t_implements = nil();
			o.typarms = new Typarms(nil(), nil());
			$$ = o;
		}

typarms:
          /* */
	  	{
			$$ = new Typarms(nil(), nil());
		}
        | '(' tyvars ')' maybe_where
		{
			$$ = new Typarms($2, $4);
		}

ftyparms:
          /* */
	  	{ $$ = new Typarms(nil(), nil()); }
        | tyvars maybe_where
		{ $$ = new Typarms($1, $2); }

tyvars:
          tyvar                       { $$ = cons($1, nil()); }
        | tyvar ',' tyvars            { $$ = cons($1, $3); }

maybe_where:
          /* */                         { $$ = nil(); }
        | KW_WHERE where_constraints    { $$ = $2; }

maybe_bar:
          /* */
        | '|'

where_constraints:
          where_constraint                              { $$ = cons($1, nil()); }
        | where_constraint ',' where_constraints        { $$ = cons($1, $3); }

where_constraint:
        TYVAR COLON_MORE ty
		{
			$$ = new Constraint($1, $3);
		}

tyvar:
        TYVAR

type_members:
          /* */                              { $$ = nil(); }
        | type_member type_members           { $$ = cons($1, $2); }

attrs:
          /* */                              { $$ = nil(); }
        | attr attrs                         { $$ = cons($1, $2); }

attr:
          KW_NEW          { $$ = new Modifier.Mod_new(); }
        | KW_PUBLIC       { $$ = new Modifier.Mod_public(); }
        | KW_PROTECTED    { $$ = new Modifier.Mod_protected(); }
        | KW_INTERNAL     { $$ = new Modifier.Mod_internal(); }
        | KW_PRIVATE      { $$ = new Modifier.Mod_private(); }
        | KW_ABSTRACT     { $$ = new Modifier.Mod_abstract(); }
        | KW_SEALED       { $$ = new Modifier.Mod_sealed(); }
	| KW_STATIC	  { $$ = new Modifier.Mod_static(); }


maybe_record:
          /* */		{ $$ = nil(); }
        | record

record:
        '{' record_members '}'		{ $$ = $2; }

record_members:
          /* */                              { $$ = nil(); }
        | record_member record_members       { $$ = cons($1, $2); }

record_member:
        attrs maybe_mutable located_id ':' ty ';'
	  	{
			$$ = new Class_member.M_field($5, $2, new Val_kind.Val_normal());
			fixup_decl($$, $1, $3);
		}

maybe_extern:
          '=' KW_EXTERN STRING_LITERAL ';'
	  	{ $$ = new Val_kind.Val_extern($3); }
	| ';'
		{ $$ = new Val_kind.Val_normal(); }

type_as_type_member:
        type_decl
		{
			Type_decl td = $1;
			Class_member.M_type t = new Class_member.M_type(td);
			t.modifiers = td.modifiers;
			t.name = td.name;
			t.loc = td.loc;
			$$ = t;
		}

type_member:
          attrs maybe_mutable ftyparms located_id ':' ty maybe_extern
	  	{
			if (!is_empty_typarms($3))
				Message.error($4.loc, "fields cannot have type parameters");
			$$ = new Class_member.M_field($6, $2, $7);
			fixup_decl($$, $1, $4);
		}
        | attrs maybe_mutable fun_def
	  	{
			if ($2)
				Message.error($3.loc, "methods cannot have 'ref' attribute");
			$$ = $3;
			$3.modifiers = $1;
		}
	| type_as_type_member

fun_def_head:
          ftyparms located_id '(' fun_parms ')' ':' ty maybe_method_implements
	  	{
			Fun_header h = new Fun_header();
			
			h.typarms = $1;
			h.loc = $2.loc;
			h.name = $2.name;
			h.parms = $4;
			h.ret_type = $7;

			$$ = new Fun_helper(h, false, $8);
		}
        | ftyparms KW_THIS '(' fun_parms ')'
		{
			Fun_header h = new Fun_header();
			
			h.typarms = $1;
			h.name = ".ctor";
			h.parms = $4;
			h.ret_type = new Nemerle.Compiler.Parsetree.Type.T_void();
			locate(h);

			$$ = new Fun_helper(h, true, nil());
		}

fun_body:
          sequence				{ $$ = new Fun_body.FB_parsed_expr ($1); }
        | '=' KW_EXTERN STRING_LITERAL ';'	{ $$ = new Fun_body.FB_extern ($3); }

fun_def:
          fun_def_head fun_body
	  	{
			Fun_kind k = new Fun_kind.FK_method($1.implements);
			if ($1.is_ctor)
				k = new Fun_kind.FK_ctor();
			Class_member.M_function f = 
				new Class_member.M_function($1.header, k, $2);
			f.name = $1.header.name;
			f.loc = $1.header.loc;
			f.modifiers = nil();
			$$ = f;
		}

fun_parm:
        located_id_or_dummy ':' ty
		{
			Fun_parm p = new Fun_parm();
			
			p.name = $1.name;
			p.loc = $1.loc;
			p.ty = $3;

			$$ = p;
		}

non_empty_fun_parms:
          fun_parm                    { $$ = cons($1, nil()); }
        | fun_parm ',' fun_parms      { $$ = cons($1, $3); }

fun_parms:
          /* */                       { $$ = nil(); }
        | non_empty_fun_parms

maybe_method_implements:
          /* */           			{ $$ = nil(); }
        | KW_IMPLEMENTS implemented_methods 	{ $$ = $2; }

implemented_methods:
          qid                                   { $$ = cons($1, nil()); }
        | qid ',' implemented_methods          	{ $$ = cons($1, $3); }

maybe_ref:
          /* */         { $$ = false; }
        | KW_REF        { $$ = true; }

maybe_mutable:
          /* */         { $$ = false; }
        | KW_MUTABLE    { $$ = true; }

prim_ty:
          qid				{ $$ = new Nemerle.Compiler.Parsetree.Type.T_app($1, nil()); }
        | qid '(' comma_sep_types ')'	{ $$ = new Nemerle.Compiler.Parsetree.Type.T_app($1, $3); }
        | TYVAR				{ $$ = new Nemerle.Compiler.Parsetree.Type.T_var($1); }
        | '(' ty ')'			{ $$ = $2; }
        | KW_VOID			{ $$ = new Nemerle.Compiler.Parsetree.Type.T_void(); }
        | KW_REF prim_ty	{ $$ = new Nemerle.Compiler.Parsetree.Type.T_ref($2); }
        | KW_OUT prim_ty	{ $$ = new Nemerle.Compiler.Parsetree.Type.T_out($2); }

prod_ty_x:
          prim_ty                              { $$ = cons($1, nil()); }
        | prim_ty '*' prod_ty_x                { $$ = cons($1, $3); }

prod_ty:
        prod_ty_x	
		{
			list.Cons c = (list.Cons)$1;
			if (c.tl is list.Nil)
				$$ = c.hd;
			else
				$$ = new Nemerle.Compiler.Parsetree.Type.T_prod(c);
		}

ty:
          prod_ty
	| ty MINUS_MORE ty 	{ $$ = new Nemerle.Compiler.Parsetree.Type.T_fun($1, $3); }

prim_expr2:
          raw_prim_expr			{ locate($1); $$ = $1; }
        | '(' expr ')' 			{ $$ = $2; }

expr:
          raw_expr			{ locate($1); $$ = $1; }
        | prim_expr

literal:
          KW_NULL		{ $$ = new Literal.L_null(); }
        | '(' ')'		{ $$ = new Literal.L_void(); }
        | STRING_LITERAL	{ $$ = new Literal.L_string($1); }
        | NUMBER_LITERAL	{ $$ = new Literal.L_int($1); }
        | CHAR_LITERAL		{ $$ = new Literal.L_char($1); }

raw_prim_expr:
          KW_THIS		{ $$ = new Expr.E_this(); }
        | literal		{ $$ = new Expr.E_literal($1); }
        | '(' expr COLON_MORE ty ')'
		{ $$ = new Expr.E_type_conversion($2, $4); }
        | '(' expr ':' ty ')'
		{ $$ = new Expr.E_type_enforcement($2, $4); }
        | prim_expr2 '.' ID
		{ $$ = new Expr.E_member($1, $3); }
	| '(' comma_sep_exprs ')'
		{ $$ = new Expr.E_tuple($2); }

prim_expr:
	  prim_expr2
        | qid			{ $$ = new Expr.E_ref($1); locate($$); }
	  
comma_sep_exprs:
	  expr ',' expr			{ $$ = cons($1, cons($3, nil())); }
	| expr ',' comma_sep_exprs	{ $$ = cons($1, $3); }

sequence:
          '{' '}'
	  	{ $$ = new Expr.E_sequence(nil()); locate($$); }
        | '{' expr_or_sequence '}'
		{ $$ = $2; }

maybe_semicolon:
          /* */
        | ';'

raw_expr_decl:
	  KW_DEF fun_defs
		{ $$ = new Expr.E_letfun($2); }
        | KW_DEF ftyparms located_id_or_dummy '=' expr ';'
	        { $$ = new Expr.E_let(false, $3.name, $5); }
	| KW_DEF tuple_pattern '=' expr ';'
		{ $$ = new Expr.E_letpat($2, $4); }
        | KW_MUTABLE located_id LESS_MINUS expr ';'
		{ $$ = new Expr.E_let(true, $2.name, $4); }

expr_decl:
	raw_expr_decl
		{ $$ = $1; locate($$); }

seq_expr:
          expr_decl 
	| expr ';'

expr_list:
          expr_list seq_expr	 { $$ = cons($2, $1); }
	| /* */			 { $$ = nil(); }

expr_or_sequence:
	  expr_list expr maybe_semicolon
	  	{ $$ = new Expr.E_sequence(List.rev(cons($2, $1))); locate($$); }

locator:
	  /* */			  { $$ = lex.get_location(); }

raw_expr:
          prim_expr '(' parameters ')'
	  	{ $$ = new Expr.E_call($1, $3); }
        | prim_expr LESS_MINUS expr
		{ $$ = new Expr.E_assign($1, $3); }
		
        | KW_IF '(' expr ')' expr KW_ELSE expr %prec KW_IF
		{ $$ = new Expr.E_if($3, $5, $7); }
        | KW_MATCH '(' expr ')' '{' maybe_bar match_cases '}'
		{ $$ = new Expr.E_match($3, $7); }
        | KW_RAISE expr
		{ $$ = new Expr.E_raise($2); }
        | KW_TRY expr KW_WITH ID ':' ty EQ_MORE expr %prec KW_IF
		{ $$ = new Expr.E_try_with($2, $4, $6, $8); }
        | KW_TRY expr KW_FINALLY expr %prec KW_IF
		{ $$ = new Expr.E_try_finally($2, $4); }

	| LESS_SQBRAC expr SQBRAC_MORE { $$ = new Expr.E_quoted ($2); }
	| '$' '(' expr ')' { $$ = new Expr.E_unquoted ($3); }

        | KW_REQUIRE '{' expr '}'
                { $$ = new Expr.E_require($3); }
        | KW_ENSURE '{' expr '}'
                { $$ = new Expr.E_ensure($3); }

	| expr COLON_COLON expr 		{ $$ = new Expr.E_list_cons($1, $3); } 
	| '[' list_exprs maybe_semicolon ']'	{ $$ = new Expr.E_list(List.rev($2)); }
	| '[' ']'				{ $$ = new Expr.E_list(nil()); }

        | expr OP1 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP2 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP3 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP4 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP5 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP6 expr	{ $$ = make_bin($1, $2, $3); }
        | expr OP7 expr	{ $$ = make_bin($1, $2, $3); }
        | expr '*' expr	{ $$ = make_bin($1, "*", $3); }

        | OP1 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP2 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP3 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP4 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP5 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP6 expr %prec UNARY	{ $$ = make_unary($1, $2); }
        | OP7 expr %prec UNARY	{ $$ = make_unary($1, $2); }

        | lambda
        | sequence

list_exprs:
	  list_exprs ';' expr	{ $$ = cons($3, $1); }
	| expr			{ $$ = cons($1, nil()); }
	
lambda_head:
           ftyparms KW_FUN '(' fun_parms ')' ':' ty
	  	{
			Fun_header h = new Fun_header();
			locate(h);
			h.name = tmp_name();
			h.parms = $4;
			h.ret_type = $7;
			h.typarms = $1;
			$$ = h;
		}

lambda:
          lambda_head sequence
	  	{
			$$ = new Expr.E_lambda(new Function_decl($1, $2));
		}

local_fun_def:
          fun_def_head sequence
	  	{ 
			if ($1.is_ctor || !($1.implements is list.Nil))
				yyerror("parse error");
			$$ = new Function_decl($1.header, $2); 
		}

non_empty_parameters:
          parameter                       { $$ = cons($1, nil()); }
        | parameter ',' parameters        { $$ = cons($1, $3); }

parameters:
          /* */                           { $$ = nil(); }
        | non_empty_parameters

parameter:
            maybe_ref expr
	    	{ $$ = new Parm($1, $2, ""); }
          | maybe_ref ID '=' expr
	    	{ $$ = new Parm($1, $4, $2); }

fun_defs:
          local_fun_def                         { $$ = cons($1, nil()); }
        | local_fun_def KW_AND fun_defs	        { $$ = cons($1, $3); }

match_cases:
          match_case                        { $$ = cons($1, nil()); }
        | match_case '|' match_cases        { $$ = cons($1, $3); }

maybe_pattern:
          pattern %prec UNARY { $$ = $1; }
        | /* */   %prec UNARY { $$ = new Pattern.P_underscore(); locate($$); }

list_patterns:
	  list_patterns ';' pattern	{ $$ = cons($3, $1); }
	| pattern			{ $$ = cons($1, nil()); }
	
nl_pattern:
          qid maybe_pattern             %prec UNARY
	  	{ $$ = new Pattern.P_cons ($1, $2); }
        | '_'
		{ $$ = new Pattern.P_underscore(); }
        | '{' record_patterns maybe_semicolon '}'
                { $$ = new Pattern.P_record (List.rev ($2)); }
        | tuple_pattern
        | '(' pattern ')'
		{ $$ = new Pattern.P_tuple (cons($2, nil())); }

	| LESS_SQBRAC expr SQBRAC_MORE
		{ $$ = new Pattern.P_quoted_expr ($2); }

	| '[' ']'
		{ $$ = new Pattern.P_list (nil()); }
	| '[' list_patterns maybe_semicolon ']'
		{ $$ = new Pattern.P_list (List.rev($2)); }
	| pattern COLON_COLON pattern
		{ $$ = new Pattern.P_list_cons ($1, $3); }
	| literal
		{ $$ = new Pattern.P_literal ($1); }

tuple_pattern:
	'(' comma_sep_patterns ')'
		{ $$ = new Pattern.P_tuple ($2); }
	
pattern: nl_pattern { locate($1); $$ = $1; }

comma_sep_patterns:
          pattern ',' pattern                 { $$ = cons($1, cons($3, nil())); }
        | pattern ',' comma_sep_patterns      { $$ = cons($1, $3); }

record_patterns:
          record_patterns ';' record_pattern        { $$ = cons($3, $1); }
        | record_pattern                            { $$ = cons($1, nil()); }

record_pattern:
          ID '=' pattern
             { $$ = new Named_pattern($1, $3); }

match_case:
          locator pattern EQ_MORE expr_or_sequence
	  	{ $$ = new Match_case($1, $2, $4); }

%%

}
