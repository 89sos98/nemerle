(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Parsetree;
open Nemerle.Compiler.Bind_types;

namespace Nemerle.Compiler {
(*
pass 2:
  Given a list of Type_decls resolve all Type_decl and type variable
  references within it.
*)
  class Bind_types
    {
      type CTX = String_map(int);

      static bind_type(env : Env, ctx : CTX, t : Type) : void =
        letfun self(t : Type) : void = bind_type(env, ctx, t) in
        match t with [
          | T_ref (?t) => self(t)
          | T_out (?t) => self(t)
          | T_fun ?f => 
            {
              // This is hack for legacy sources, from time where compiler didn't
              // support multi-argument functions (only through tuples).
              // It is to be removed someday.
              match f#from with [
                | Cons (T_prod (?x), Nil) => f#from <- x
                | Cons (T_void, Nil) => f#from <- Nil ()
                | _ => ()
              ];
              List.iter(self, f#from); 
              self(f#to)
            }
          | T_void => ()
          | T_prod (?ts) => List.iter(self, ts)
          | T_var ?v =>
            match ctx#find(v#name) with [
              | Some (?n) => v#ref_to <- n
              | None =>
                Message.error("unbound type variable " + v#name)
            ]
          | T_app ?a =>
            let td = env#lookup_type(a#tycon) in
            {
              a#ref_to <- td#id;
              if List.length (td#typarms#tyvars) == List.length (a#args) then ()
              else
                Message.error ("type `" + td#name + "' takes " + 
                               string_of_int (List.length (td#typarms#tyvars)) +
                               " while " +
                               string_of_int (List.length (a#args)) +
                               " were supplied");
              List.iter(self, a#args)
            }
        ];
        
      static add_tyvars(env : Env, ctx : CTX, tp : Typarms) : CTX * list (int) =
        // this mess with two environments is here to detect possible error:
        // type ('a) foo { type ('b) where 'a :> t }
        letfun add (ctx : CTX * CTX * list (int), name : string) : CTX * CTX * list (int) =
          let id = Tyvars.add(name) in
          let (?local, ?global, ?lst) = ctx in
          (local#add(name, id), global#add(name, id), Cons (id, lst))
        in 
        let (?local, ?global, ?lst) = 
          List.fold_left(add, (Map.string_map(), ctx, Nil()), tp#tyvars) 
        in
        letfun addc (c : Constraint) : void =
          match local#find(c#tyvar) with [
            | Some (?id) =>
              {
                Tyvars.add_constraint(id, c#ty);
                bind_type(env, global, c#ty)
              }
            | None =>
              Message.error("unbound type variable " + c#tyvar + " in constraint")
          ]
        in {
          List.iter(addc, tp#constraints);
          (global, List.rev (lst))
        };

      static run(decls : list (Type_decl)) : void =
        letfun do_tydecl(ctx : CTX, decl : Type_decl) : CTX =
          let (?ctx', ?lst) = add_tyvars(decl#env, ctx, decl#typarms) in
          let _ = 
            match decl with [
              | TD_variant_option =>
                // Variants get their type variables from parents.
                let ti = Tyinfo.lookup (decl) in
                let parms = Tyvars.get_parms ((ti#enclosing_type_td ()) # id) in
                Tyvars.set_parms (decl#id, parms)

              | _ =>
                Tyvars.set_parms (decl#id, lst)
            ] in
          let types =
            match decl#t_extends with [
              | Some (?t) => Cons (t, decl#t_implements)
              | None => decl#t_implements
            ]
          in letfun do_type(t : Type) : void = bind_type(decl#env, ctx', t) in {
            List.iter(do_type, types);
            match decl with [
              | TD_alias (?t) => do_type(t)
              | _ => ()
            ];
            ctx'
          }

        and do_expr(env : Env, ctx : CTX, expr : Expr) : void =
          letfun f(env : Env, expr : Expr) : Env = 
            match expr with [
              | E_letfun (?fs, ?b) =>
                  {
                    letfun do_fun (d : Function_decl) : void =
                      do_function(env, ctx, d#fun_header, FB_expr(d#body))
                    in {
                      List.iter (do_fun, fs); 
                      do_expr(env, ctx, b);
                      raise Treeutil.Skip_recursion();
                    }
                  }
              | E_lambda (?d) =>
                  {
                    do_function(env, ctx, d#fun_header, FB_expr(d#body));
                    raise Treeutil.Skip_recursion();
                  }
              | E_try_with ?x => { bind_type(env, ctx, x#exn_ty); env }
              | E_type_conversion ?x => { bind_type(env, ctx, x#ty); env }
              | E_type_enforcement ?x => { bind_type(env, ctx, x#ty); env }
              | _ => env
            ]
          in Treeutil.expr_walk(f, env, expr)

        and do_header(env : Env, ctx : CTX, h : Fun_header) : CTX =
          Util.locate (h#loc, fun () : CTX =>
            let (?ctx', ?lst) = add_tyvars(env, ctx, h#typarms) in {
              Tyvars.set_parms (h#id, lst);
              bind_type(env, ctx', h#ret_type);
              letfun doparm(p : Fun_parm) : void = 
                bind_type(env, ctx', p#ty) 
              in List.iter(doparm, h#parms);
              ctx'
            })

        and do_function(env : Env, ctx : CTX, h : Fun_header, b : Fun_body) : void =
          let ctx' = do_header(env, ctx, h) in
          match b with [
            | FB_expr (?e) => do_expr(env, ctx', e)
            | _ => ()
          ]
        
        and do_decl(ctx : CTX, decl : Class_member) : void =
          match decl with [
            | M_value (?t, _) => bind_type(decl#env, ctx, t)
            | M_field (?t, _) => bind_type(decl#env, ctx, t)
            | M_function (?h, _, ?b) => do_function (decl#env, ctx, h, b)
            | M_type => ()
          ]
        in 
        Treeutil.decl_walk(do_tydecl, do_decl, Map.string_map(), decls);
    }
  
} // end ns
