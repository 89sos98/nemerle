using Nemerle.IO;
module M {
  f1 (_ : object) : void {}
  
  class X ['a] {
    a : 'a;
    m () : void { f1 (a) }
  }
  
  f () : void {
    def f2 (acc, v) {
      def (x, y) = acc; 
      printf ("%s\n", x);
      printf ("%s\n", y);
      v
    };
    def _ = f2 (("foo", "bar"), 3);
    ()
  }

  public Main () : void {
    def f2[a] (l) {
      def arr =  (System.Array.CreateInstance (typeof (a), 4) :> array [a]);
      Nemerle.Collections.List.Append (l, [arr[0]])
    };
    def bb (b : list[int], c : list[int] -> list[int]) {
      c(b)
    };
    ignore (bb ([1], f2));
    ()
  }
}



using Nemerle.Collections;

    public class STree
    {
        internal transform_gotos_to_conditionals () : STree { null }
    }


public module Some {

        internal divide_block_into_when_sections () : list [STree]
        {
            def walk (statements, acc1 : list[STree], acc2 : list[STree]) : list [STree]
            {
                match(statements)
                {
                    | [] => []
                    | head :: tail =>
                         walk(tail , head :: acc1 , acc2)
                }
            }

            def sts = [] : list[STree];
            def transformed = List.Map(sts, fun(x ) {x.transform_gotos_to_conditionals ();} );

            walk ( transformed , [] , [])
        }
}
