using System;
using System.Text;

using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

namespace LRPEGCC
{
  internal class Grammar
  {
    private _grammar : Map[RuleRef, int * Rule] = Map();
    [Accessor]
    private _startRuleName : RuleRef;

    public this(startRuleName : RuleRef)
    {
      _startRuleName = startRuleName;
    }

    private this(startRuleName : RuleRef, grammar : Map[RuleRef, int * Rule])
    {
      _startRuleName = startRuleName;
      _grammar = grammar;
    }

    public Add(name : RuleRef, rule : Rule) : Grammar
    {
      Grammar(StartRuleName, _grammar.Add(name, (_grammar.Count, rule)));
    }

    public GetRule(name : RuleRef) : Rule
    {
      if (_grammar.Contains(name))
      {
        def (_id, rule) = _grammar.Get(name);
        rule;
      }
      else
      {
        throw GrammarException($"There is no rule \"$name\" in grammar.", name.Location);
      }
    }

    public Count : int
    {
      get { _grammar.Count }
    }

    public Names : list[RuleRef]
    {
      get { _grammar.Map((name, _) => name) }
    }
    
    public override ToString() : string
    {
      def sb = StringBuilder();
      _ = sb.AppendLine($"Count:$Count");
      _ = sb.AppendLine($"_startRuleName:$_startRuleName");
      _ = sb.AppendLine("rules:");
      foreach((name, (id, rule)) in _grammar)
      {            
        _ = sb.AppendLine($"  name:$(name)");
        _ = sb.AppendLine($"  id:$(id)");
        _ = sb.AppendLine($"  rule type:$(rule.GetType().ToString())");
        _ = sb.AppendLine($"  rule:$(rule.ToString())");
        _ = sb.AppendLine(string.Empty);
      }
      
      sb.ToString()
    }
  }
}
