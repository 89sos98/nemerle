using System;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;

using LRPEGCC.GrammarCreator;

namespace LRPEGCC
{
  macro Grammar (_rules : Token)
  syntax ("grammar", _rules)
  {
    <[ () ]>
  }

  [Nemerle.MacroUsage(Nemerle.MacroPhase.BeforeTypedMembers, Nemerle.MacroTargets.Class)]
  macro PegGrammar (tb : TypeBuilder, startRule, rules)
  {
    try
    {
      // TODO: Check is subclass of ParserBase
      GrammarImpl.MakeParser(Macros.ImplicitCTX(), tb, startRule, rules);
    }
    catch
    {
      | e is GrammarException =>
        def loc = if(e.Location != Location.Default) e.Location else tb.Location;
        Message.Error(loc,  e.Message);
      | e is Exception =>
        Message.Error(tb.Location,  $"Exception $e");
    }
  }

  internal module GrammarImpl
  {
    public MakeParser(typer : Typer, tb : TypeBuilder, startRule : PExpr, rules : PExpr) : void
    {
      def grammar = CreateGrammar(typer, tb, startRule, rules);
        
      def compiler = RuleCompiler(typer);
      
      mutable str = "";
      
      def tyParam = 
        match (grammar.GetRule(grammar.StartRuleName))
        {
          | Rule.Capture(argType = RuleType.NType(ty)) => ty
          | _ => 
            Message.Error(tb.Location,  "Start rule must be a capture rule");
            <[ object ]>
        };

      foreach (name in grammar.Names)
      {
        def rule          = grammar.GetRule(name);
        rule.UpdateIndecis();
        def body          = compiler.CompileRule(rule);
        
        def resultType : PExpr = // Make type parametr name
          match (rule)
          {
            | Rule.CaptureNamedTerminalSymbol            => <[ Nemerle.Peg.NToken ]>
            | Rule.Capture(argType = RuleType.NType(ty)) => <[ Nemerle.Peg.VToken[$ty] ]>
            | Rule.Capture(argType = argType) as c => 
              Message.Error($"Wrong return type ($argType) in '$(c.name)' rule");
              <[ Nemerle.Peg.NToken ]>
            | _                                          =>
              Message.Error($"Top level rule must be Capture. ($(rule.GetType().Name) $rule)");
              <[ Nemerle.Peg.NToken ]>
          };
        
        def method = <[decl:
          private $(compiler.DecorateRuleName(name.Id) : dyn)(pos : int, result : ref $resultType, text : string) : int
          {
            mutable c : char;
            _ = c; // eliminate wornint "a local value c was never used"
            $body;
          }
        ]>;
        _ = tb.DefineWithSource(method);
        str = str + method.ToString() + "\n" + body.ToString() + "\n\n";
        
        //create parse method for single capture rule
        unless (name.Equals(grammar.StartRuleName))
        {
          match (rule)
          {
            | Rule.Capture  as r => CreateSimpleParseMethod(r, compiler, tb);
            | _                  => ();
          }
        }
      }

      CreateStartParseMethods(grammar.StartRuleName.Id, tyParam, compiler, tb);
      
      tb.Define(<[decl:
        public override ToString() : string
        {
          $(str : string);
        }
      ]>);

      tb.Define(<[decl:
        private mutable _maxRollbackPos : int;
      ]>);

      tb.Define(<[decl:
        public MaxRollbackPos : int
        {
          get { _maxRollbackPos }
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        private SetMaxRollbackPos(pos : int) : void
        {
          when (pos > _maxRollbackPos)
          {
            _maxRollbackPos = pos;
          }
        }
      ]>);
    }

    private CreateStartParseMethods(startRuleName : string, tyParam : PExpr, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      tb.Define(<[decl: mutable _text : string; ]>);
      tb.Define(<[decl: public GetText() : string { _text } ]>);
      
      _ = tb.DefineWithSource(<[decl:
        public TryParse(text : string) : int * $tyParam
        {
          _text = text;
          mutable result : Nemerle.Peg.VToken[$tyParam];
          def pos = $(compiler.DecorateRuleName(startRuleName) : dyn)(0, ref result, text);
          
          (pos, result.Value)
        }
      ]>);

      _ = tb.DefineWithSource(<[decl:
        public Parse(text : string) : option[$tyParam]
        {
          def (pos, res) = TryParse(text);
          
          if (pos < 0) None() else Some(res)
        }
      ]>);
    }

    private CreateSimpleParseMethod(rule : Rule.Capture, compiler : RuleCompiler, tb : TypeBuilder) : void
    {
      def ruleName = rule.name;
      def methodName = "ParseRule_" + ruleName.Id;
      
      match(rule.argType)
      {
        | RuleType.NType(ty)  =>      
          def parseMethod1 = <[decl:
            public $(methodName : dyn)(startPos : int, text : string) : option[$ty]
            {
              mutable result : Nemerle.Peg.VToken[$ty];
              
              def pos = $(compiler.DecorateRuleName(ruleName.Id) : dyn)(startPos, ref result, text);
              
              if (pos < 0) 
                None() 
              else 
                Some(result.Value)
            }
          ]>;
          def parseMethod2 = <[decl:
            public $(methodName : dyn)(text : string) : option[$ty]
            {
              $(methodName : dyn)(0, text)
            }
          ]>;
        
          _ = tb.DefineWithSource(parseMethod1);
          _ = tb.DefineWithSource(parseMethod2);
          
        | _                   => assert(false);
      };
    }
  }
}
