/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Parsetree;

using Nemerle.Text;

namespace Nemerle.Compiler
{
  public module MacroRegistry
  {
    extensions : Hashtable [list [string], list [SyntaxDefinition]];

    mutable loaded : list[string];

    this () {
      extensions = Hashtable (50);
      loaded = [];
    }

    internal GetSyntaxExtensions (name_space : list [string]) : list [SyntaxDefinition]
    {
      match (extensions [name_space]) {
        | null => []
        | definition => definition
      }
    }

    public register_macro (m : IMacro) : void {
      def ns = m.GetNamespace ();
      def nslist =
        if (ns == "") ["Nemerle", "Core"]
        else NString.Split (ns, array ['.']);

      // full qualified name of macro call    
      def full_list = nslist + [m.GetName ()];

      match (GlobalEnv.LookupExactMacro (full_list)) {
        | Some => Message.error ("macro `" + ns + m.GetName () + "' already defined")
        | None =>
          // store syntax extension in MacroRegistry
          match (m.SyntaxExtension ()) {
            | ("", [], _) => ()
            | (key, rules, permute) =>
              mutable keywords = [key];
              foreach (GrammarElement.Keyword (k) in rules) 
                keywords = k :: keywords;
              
              def macro_ns = GlobalEnv.ExactPath (full_list);
              def syntax_def = SyntaxDefinition (key, keywords, macro_ns, rules, permute);

              // store extensions for this namespace
              match (extensions.Get (nslist)) {
                | Some (l) => extensions.Set (nslist, syntax_def :: l)
                | None => extensions.Set (nslist, [syntax_def])
              }
          };
          GlobalEnv.AddMacro (full_list, m);
      }
    }

    internal expand_macro (orig_ctx : TypingContext, ctx : TypingContext, expr : PExpr) : PExpr {
      match (expr) {
        | PExpr.Call (name, args) =>
          match (Util.qidl_of_expr (name)) {
            | Some ((namepath, name)) =>
              match (name.GetEnv (ctx.env).LookupMacro (namepath)) {
                | Some (x) =>
                  def used_ctx = if (x.IsTailRecursionTransparent) orig_ctx else ctx;
                  TypingContext.PushNewColor (name.color, name.GetEnv (ctx.env));
                  def expanded = Util.locate (expr.loc, x.Run (used_ctx, x.CallTransform (args)));
                  TypingContext.PopColor ();
                  expand_macro (orig_ctx, ctx, expanded);
                | None => expr
              }
            | None => expr
          }

        | PExpr.MacroCall (name, namespc, parms) =>
          match (namespc.Value) {
            | GlobalEnv.TypeInfoCache.MacroCall (m) =>
              def used_ctx = if (m.IsTailRecursionTransparent) orig_ctx else ctx;            
              TypingContext.PushNewColor (name.color, name.GetEnv (ctx.env));
              def expanded = Util.locate (expr.loc, m.Run (used_ctx, parms));
              TypingContext.PopColor ();        
              expand_macro (orig_ctx, ctx, expanded)
            | _ =>
              Util.ice ("failed to resolve macro name `" +
                        NString.Concat (".", namespc.Name) + "'")
          }

        | _ => expr
      }
    }

    internal lookup_macro (env : GlobalEnv, expr : PExpr, suff : string)
    : option [Name * IMacro * list [SyntaxElement]]
    {
      match (expr) {
        | <[ $(_ : name) ]>
        | <[ $_ . $_ ]> => lookup_macro (env, <[ $expr () ]>, suff)
          
        | <[ $name ( .. $parms ) ]> =>
            match (Util.QidOfExpr (name)) {
              | Some ((id, name)) =>
                def ctx = name.GetEnv (env);
                def id =
                  match (List.Rev (id)) {
                    | x :: xs => List.Rev (x + suff :: xs)
                    | [] => assert (false)
                  };
                match (ctx.LookupMacro (id)) {
                  | Some (m) => Some ((name, m, m.CallTransform (parms)))
                  | None => None ()
                };
              | None => None ()
            }

        | PExpr.MacroCall (name, ns, parms) =>
          match (ns.Value) {
            | GlobalEnv.TypeInfoCache.MacroCall (m) =>
              if (m.GetName ().EndsWith (suff))
                Some ((name, m, parms))
              else
                None ()
              
            | _ =>
              Util.ice ("failed to resolve macro name `" +
                        Util.QidOfList (ns.Name) + "'")
          }
            
        | _ => None ()
      }
    }
  }
} // end ns
