
using Nemerle.Collections;
using Nemerle.Compiler;
using System;

macro forp (i, n : int, m : int, body)
syntax ("forpermutation", "(", i, "in", n, "to", m, ")", body)
{
  def a = array (m - n + 1);
  for (mutable j <- 0; j < m - n + 1; j <- j + 1)
    a[j] <- j + n;
  mutable p <- [];
  def r = System.Random ();
  for (mutable k <- m - n; k >= 0; k <- k - 1) {
    def rand = r.Next (k + 1);
    p <- <[ $(a[rand] : int) ]> :: p;
    a[rand] <-> a[k];
  };
  <[
    def p = array [..$p];
    for (mutable j <- 0; j < $(m - n + 1 : int); j <- j + 1) {
      $i <- p[j];
      $body
    }
  ]>
}

namespace A {
  macro gg (a)
  syntax ("ggg", a) { a }
}

macro ala()
{
  def c = Nemerle.Macros.ImplicitCTX ().env.DefineClass([Mod_public ()], "haha", []);
  c.DefineMember(<[ field: x : int; ]>);
  c.DefineMember(<[ method: public this(){}]>);
  <[ Console.WriteLine ("proba") ]>;
}

public interface ISerializable {
  Serialize () : void;
}

postscan macro Serializable (t : TypeDecl)
{
  def t = (t :> Tyinfo);
  t.pt_tydecl.t_extends <- List.Append (t.pt_tydecl.t_extends,
                                        [<[ type: ISerializable ]> ]);
}

postadd macro Serializable (t : TypeDecl)
{
  def t = (t :> Tyinfo);
  def members = t.GetMembers ();
  def fields =
    List.Filter (members, fun (m : IMember) {
      m.GetDeclaringTycon ().SameAs (t) && !m.IsStatic () &&
      match (m.GetKind ()) {
        | MK_field => true
        | _ => false
      }
    });
    
  mutable serializers <- [];
  List.Iter (fields, fun (x : IMember) {
    if (Tyutil.subtypes (x.GetMemType (), <[ ttype: int ]>))
      serializers <- <[ Nemerle.IO.printf ("%d\n", $(x.GetName () : dyn)) ]>
                     :: serializers
    else
      if (Tyutil.subtypes (x.GetMemType (), <[ ttype: ISerializable ]>))
        serializers <- <[
                         if ($(x.GetName () : dyn) != null)
                           $(x.GetName () : dyn).Serialize ()
                         else
                           Nemerle.IO.printf ("null\n")
                       ]> :: serializers
      else
        Message.fatal_error ("field `" + x.GetName () + "' cannot be serialized")
  });
  t.DefineMember (<[ method: public Serialize () : void implements ISerializable.Serialize {
    .. $serializers
  } ]>)
}
