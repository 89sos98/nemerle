(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Compiler;
open Nemerle.Compiler.Tyutil;
open Nemerle.Compiler.Tyops;
open Nemerle.Collections;

namespace Nemerle.Compiler {

class Tyops
  {
    static `/-` (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
    static `>>` (x : Type, y : Type) : bool = extern "Nemerle.Compiler.Tyutil.subtypes";
  }
  
type Subst = Int_map(Type);

class Tyutil
  {
    static subst (t : Type, s : Subst) : Type =
      letfun self (t : Type) : Type = subst (t, s) in
      match t with [
        | T_ref (?t) => T_ref (self (t))
        | T_out (?t) => T_out (self (t))
        | T_fun (?tl, ?t) => T_fun (self (tl), self (t))
        | T_void => t
        | T_prod (?tl) => T_prod (List.map (self, tl))
        | T_app (?tc, ?args, ?ref_to) =>
          T_app (tc, List.map (self, args), ref_to)
        | T_var (_, ?id) =>
          {
             match s#find(id) with [
               | Some (T_var (_, ?id2)) => 
                 if id == id2 then Util.ice ()
                 else ()
               | _ => ()
             ];
             match s#find(id) with [
               | Some (?t') => self (t') // fixpoint
               | None => t
             ] 
          }
      ];
    
    static make_subst (ini : Subst, parms : list (int), args : list (Type)) : Subst =
      match (parms, args) with [
        | (Cons (?p, ?ps), Cons (?a, ?args)) =>
          match a with [
            | T_var (_, ?p') =>
              if p == p' then ini
              else
                make_subst (ini#add (p, a), ps, args)
            | _ =>
              make_subst (ini#add (p, a), ps, args)
          ]
        | (Nil, Nil) => ini
        | _ => Util.ice ()
      ];
      
    static make_subst (parms : list (int), args : list (Type)) : Subst =
       make_subst (Map.int_map (), parms, args);
    
    static make_subst (td : Type_decl, args : list (Type)) : Subst =
       make_subst (Map.int_map (), Tyvars.get_parms(td#id), args);

    static fresh_vars (parms : list (int), t : Type) : Type =
      let sub = Tyvars.fresh_subst (parms) in
      t /- sub;
      
    static fresh_vars (td : Type_decl, t : Type) : Type =
      fresh_vars (Tyvars.get_parms(td#id), t);

    static subst_of_app (t : Type) : Subst * Tyinfo =
      match t with [
        | T_app (_, ?args, ?ref_to) =>
          let ti = Tyinfo.lookup(ref_to) in
          (make_subst (ti#tydecl, args), ti)
        | _ => Util.ice ()
      ];

    static top_expand (t : Type) : Type =
      letfun f (t : Type) : Type =
        match t with [
          | T_app  =>
            let (?sub, ?ti) = subst_of_app (t) in
            match ti#tydecl with [
              | TD_alias (?t) =>
                f (t /- sub)  // fixpoint iteration
              | _ => t
            ]
          | _ => t
        ] in f (Tyvars.global_expand (t));

    // t1 :> t2 (or t1 =? t2)
    static unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      letfun sub1 (t : Type) : Type =
        let t = top_expand (t) in
        match t with [
          | T_var (_, ?id) =>
            match s#find(id) with [
              | Some (?t') => sub1 (t')
              | None => t
            ]
          | _ => t
        ]
      in
      //let sign = if allow_subtyping then " :> " else " =? " in
      //let _ = Message.debug ("unify " + string_of_type (t1) + sign + string_of_type (t2)) in
      let (?t1, ?t2) = 
        match (t1, t2) with [
          | (T_var (_, ?id1), T_var (_, ?id2)) =>
            if id1 == id2 then (t1, t2)
            else (sub1 (t1), sub1 (t2))
          | _ => (sub1 (t1), sub1 (t2))
        ]
      in
      //let _ = Message.debug ("  --> " + string_of_type (t1) + sign + string_of_type (t2)) in
      letfun unify_lists (s : Subst, t1 : list (Type), t2 : list (Type), 
                          allow_subtyping : bool) : option (Subst) =
        match (t1, t2) with [
          | (Cons (?t1, ?ts1), Cons (?t2, ?ts2)) =>
            match unify (s, t1, t2, allow_subtyping) with [
              | Some (?s') => unify_lists (s', ts1, ts2, allow_subtyping)
              | None => None ()
            ]
          | (Nil, Nil) => Some (s)
          | _ => None ()
        ]
      in
      letfun unify_with_tyvar (t1 : Type, t2 : Type) : option (Subst) =
        match t1 with [
          | T_var (_, ?id1) =>
            if Tyvars.is_free (id1) then 
              letfun check_constraint (s : option (Subst), c : Type) : option (Subst) =
                match s with [
                  | None => None ()
                  | Some (?s) => unify (s, t2, c, true)
                ]
              in List.fold_left (check_constraint, Some (s#add (id1, t2)), Tyvars.constraints (id1))
            else None ()
          | _ => None ()
        ]
      in
      letfun fallback (t1 : Type, t2 : Type) : option (Subst) =
        match unify_with_tyvar (t1, t2) with [
          | Some (?s) => Some (s)
          | None => unify_with_tyvar (t2, t1)
        ]
      in
      
      match (t1, t2) with [
        | (T_ref (?t1), T_ref (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_out (?t1), T_out (?t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_prod (?l1), T_prod (?l2)) => 
          unify_lists (s, l1, l2, allow_subtyping)
        | (T_void, T_void) => Some (s)
        
        | (T_fun (?a1, ?r1), T_fun (?a2, ?r2)) =>
          match unify (s, r1, r2, allow_subtyping) with [
            | Some (?s) => unify (s, a2, a1, allow_subtyping)
            | None => None ()
          ]

        | (T_app (_, ?a1, ?tc1), T_app (?tn, ?a2, ?tc2)) =>
          if tc1 == tc2 then 
            unify_lists (s, a1, a2, false)
          else
            if allow_subtyping then
              let (?s1, ?ti1) = subst_of_app (t1) in
              let ti2 = Tyinfo.lookup (tc2) in
              match ti1#how_subtypes (ti2#tydecl) with [
                | Some (?l) =>
                  letfun f (t : option (Type)) : Type =
                    match t with [
                      | None => Tyvars.free_variable ()
                      | Some (?t) => t /- s1
                    ]
                  in let a1' = List.map (f, l) in
                  unify (s, T_app (tn, a1', tc2), t2, true)
                | None => None ()
              ]
            else 
              None ()
            
        | (T_var (_, ?id1), T_var (_, ?id2)) =>
          if id1 == id2 then Some (s)
          else fallback (t1, t2)
        
        | (T_var (_, ?id1), _) =>
          if allow_subtyping then
            // check to see if any of our constraints is enough
            letfun check_constraints (cs : list (Type)) : option (Subst) =
               match cs with [
                 | Nil => fallback (t1, t2)
                 | Cons (?c, ?cs) =>
                   match unify (s, c, t2, true) with [
                     | Some (?r) => Some (r)
                     | None => check_constraints (cs)
                   ]
               ]
             in check_constraints (Tyvars.constraints (id1))
          else fallback (t1, t2)
        
        | _ => 
          fallback (t1, t2)
      ];

    static unify (t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) =
      unify (Map.int_map (), t1, t2, allow_subtyping);
    
    static unify (t1 : Type, t2 : Type) : option (Subst) =
      unify (Map.int_map (), t1, t2, false);
   
    // FIXME: this might be broken (if there are free variables in types to
    // begin with)
    static types_eq (a : Type, b : Type) : bool =
      match unify (a, b) with [
        | Some => true
        | None => false
      ];

    // check if a :> b and if so, incorporate substitution into
    // global context
    static subtypes (a : Type, b : Type) : bool =
      match unify (a, b, true) with [
        | Some (?s) => { Tyvars.global_store (s); true }
        | None => false
      ];

    static string_of_type (t : Type) : string =
      letfun map (sep : string, args : list (Type)) : string =
        Util.concat_strings(sep, List.map (string_of_type, args))
      in
      match t with [
        | T_app (?tc, ?args, ?ref_to) =>
          let name =
            if ref_to == 0 then tc
            else
              // be as fault tolerant as possible, this is for debug
              // and error messages.
              try (Tyinfo.lookup(ref_to))#fullname() 
              with ?x : ICE => tc
          in
          match args with [
            | Nil => name
            | _ =>
              name + " (" + map (", ", args) + ")"
          ]
        | T_var (?n, ?id) => 
          "'" + n + "_" + string_of_int (id) + if Tyvars.is_free (id) then "*" else ""
        | T_ref (?t) => "ref " + string_of_type (t)
        | T_out (?t) => "out " + string_of_type (t)
        | T_void => "void"
        | T_prod (?args) => 
          "(" + map (" * ", args) + ")"
        | T_fun (?from, ?to) =>
          "(" + string_of_type (from) + " -> " + string_of_type (to) + ")"
      ];
    
    // Given function declaration, construct its type.
    static fun_type (h : Fun_header) : Type = 
      match List.map (fun (p : Fun_parm) : Type => p#ty, h#parms) with [
        | Cons (?x, Nil) => T_fun (x, h#ret_type)
        | Nil => T_fun (T_void (), h#ret_type)
        | ?l => T_fun (T_prod (l), h#ret_type)
      ];

    static make_tapp (env : Env, n : string) : Type =
      let td = env#lookup_type (n) in
      T_app (n, Nil (), td#id);

    static fun_args (from : Type) : list (Type) =
      match top_expand (from) with [
        | T_prod (?a) => a
        | T_void => Nil ()
        | ?t => Cons (t, Nil ())
      ];
  }

} // ns
