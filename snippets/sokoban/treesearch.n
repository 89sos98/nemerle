using Nemerle.Collections;

namespace NSokoban
{
    public module TreeSearch
    {
	public BFS (map : Map) : bool * option [Map]
	{
	    mutable found = false;
	    mutable result = None ();
	    
	    def visited = System.Collections.Hashtable (4000000);
	    mutable queue = System.Collections.Queue(4000000);

	    mutable depth = 0;
	    queue.Enqueue (map);

	    def start = System.DateTime.Now;

	    while(!found && !(queue.Count == 0))
	    {				
		def m = queue.Dequeue() :> Map;		    

		when(depth < m.moves_so_far.Length)
		{
		    ++depth;
		    System.Console.WriteLine(depth);
		}

		when(!visited.ContainsKey(m.Id))
		if(m.GoalTest())
		{
		    found = true;
		    result = Some(m);
		}
		else
		{
		    visited.Add(m.Id,"");
		    foreach (x in m.NextStates()) queue.Enqueue(x);
		}
	    }
	    when(found)
		System.Console.WriteLine("Found after "+(start - System.DateTime.Now).ToString ());	
	    
	    (found,result)
	}

	public BlindIDFS (map : Map) : bool * option [Map]
	{
	    mutable i = 1;
	    mutable found = false;
	    mutable mp = null;

	    def start = System.DateTime.Now;
	
	    while(!found)
	    {
		def (f,m) = BlindDFS(map,i);
		mp = m;
		found = f;
		++i;
	    }
	    when(found)
		System.Console.WriteLine("Found after "+(start - System.DateTime.Now).ToString ());	
	    (found,mp)
	}

	public BlindDFS (map : Map, limit : int) : bool * option [Map]
	{
	    mutable found = false;	    
	    mutable result = None ();

	    mutable stack = System.Collections.Stack(1000000);
	    
	    mutable i = 0;	    
	    stack.Push (map);

	    while(!found && !(stack.Count == 0))
	    {		
		++i;
		def m = stack.Pop() :> Map;
		if(m.GoalTest())
		{
		    found = true;
		    result = Some(m);
		}
		else		
		    when(m.moves_so_far.Length <= limit)
			foreach (x in m.NextStates()) stack.Push(x);
		
	    }	    
	    
	    (found,result)
	}

	public IDFS (map : Map) : bool * option [Map]
	{
	    mutable i = 1;
	    mutable found = false;
	    mutable mp = null;

	    def start = System.DateTime.Now;
	
	    while(!found)
	    {
		def (f,m) = DFS(map,i);
		mp = m;
		found = f;
		++i;
		System.Console.WriteLine(i);
	    }
	    when(found)
		System.Console.WriteLine("Found after "+(start - System.DateTime.Now).ToString ());	
	    (found,mp)
	}

	public DFS (map : Map, limit : int) : bool * option [Map]
	{
	    mutable found = false;	    
	    mutable result = None ();
	    
	    def visited = System.Collections.Hashtable (20000);
	    
	    mutable stack = System.Collections.Stack(1000000);
	    
	    mutable i = 0;	    
	    mutable k = 0;
	    stack.Push (map);

	    while(!found && !(stack.Count == 0))
	    {				
		def m = stack.Pop() :> Map;
		//System.Console.WriteLine(m); 
		++k;
		when(!visited.ContainsKey(m.Id))
		if(m.GoalTest())
		{
		    found = true;
		    result = Some(m);
		}
		else		
		    when(m.moves_so_far.Length <= limit)
		    {
		        ++i;			    
		        visited.Add(m.Id,"");
		        foreach (x in m.NextStates()) stack.Push(x)
		    }		
	    }	    
	    
	    (found,result)
	}
    }
}
