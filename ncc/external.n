(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Collections;
  open Nemerle.Compiler;
  open Nemerle.Compiler.Typedtree;
  open Nemerle.Compiler.Tyops;

  open System.Reflection;

  (**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   *)
  public class LibraryReferenceException extends System.Exception 
  {
    public this () {}
  }


  (**
   * Manager for the referenced libraries
   *)
  class LibraryReferenceManager
  {
    (* -- CONSTRUCTORS ----------------------------------------------------- *)
  
    (**
     * Static constructor. Always load the Framework core library.
     *)
    public static this () {

      _libraries <- [];
      _loaded_types <- Hashtable (1000);
      
      AddLibrary (LoadCoreLibrary ())
    }


    (* -- PUBLIC METHODS --------------------------------------------------- *)
  
    (**
     * Stores the referenced library for later lookup by the namespaces.
     *)
    public static AddLibrary (library : LibraryReference) : void {
    
      _libraries <- library :: _libraries;
    }
    
    // used also by LibraryReference class below
    internal static mutable _loaded_types : Hashtable (string, option (Tycon));
  
    (**
     * Searches for a type name in all referenced external libraries.
     *)
    public static LookupType (type_name : string) : option (Tycon)
    {
      def loop (acc, lib : LibraryReference) {
        match ((acc, lib.Lookup (type_name))) {
          | (_, None) => acc
          | (Some, Some) =>
            Message.fatal_error ("type `" + type_name + 
                                 "' is defined in more then one library")
          | (None, (Some) as x) => x
        }
      };
      match (_loaded_types.Get (type_name)) {
        | Some (r) => r
        | None =>
          def res = List.fold_left (loop, None (), _libraries);
          _loaded_types.Set (type_name, res);
          res
      }
    }
    

    (* -- PRIVATE METHODS -------------------------------------------------- *)

    (**
     * Tries to load the core framework library using both 
     * the .NET Framework and Mono naming conventions.
     *)
    private static LoadCoreLibrary () : LibraryReference {

      def mscorelib = try LibraryReference ("mscorlib.dll")
                      with { _ : System.IO.FileNotFoundException => null };
          
      if (mscorelib == null) {
      
        def corlib = try LibraryReference ("corlib.dll")
                     with { 
                       _ : System.IO.FileNotFoundException =>
                         raise LibraryReferenceException ()
                     };
        
        corlib
      }
      else
        mscorelib    
    }
      
    
    (* -- PRIVATE VARIABLES ------------------------------------------------ *)
    
    (**
     * The referenced library list
     *)
    private static mutable _libraries : list (LibraryReference);
  }


  (**
   * This class stores information extracted from a referenced external library.
   *)
  class LibraryReference
  {
    (**
     * The assembly associated with this object
     *)
    private mutable _library : Assembly;

    (**
     * The location of this library
     *)
    private mutable _location : Location;
    
    (**
     * The assembly's custom attributes
     *)
    private mutable _assembly_attributes : list (System.Object);
       
    (**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     *)
    private mutable _is_generated_by_nemerle : bool;
       
       
    (**
     * Loads an assembly given it's file or assembly name. 
     * Extracts and processes the custom attributes array.
     *)
    public this (name : string) 
    {
      try
        _library <- Assembly.Load (name)
      with { _ : System.IO.FileNotFoundException =>
        _library <- Assembly.LoadFrom (name)
      };

      _location <- Location("[library:" + (_library.GetName ()).Name + "]", 0, 0);
      _assembly_attributes <- List.from_array (_library.GetCustomAttributes (true));
      process_assembly_attributes ();
    } 

    (**
     * Scans the assembly custom attributes looking for something interesting...
     *)
    private process_assembly_attributes () : void
    {
      def loop (attributes : list (System.Object)) : void {
        match (attributes) {
          | [] => ()
          | attribute :: rest =>
            def attribute_type = (attribute :> System.Attribute).GetType ();
            match (attribute_type.FullName) {
              | "System.Reflection.AssemblyConfigurationAttribute" =>
                def configuration_attribute = (attribute :> AssemblyConfigurationAttribute);
                
                when (configuration_attribute.Configuration == "ContainsNemerleTypes") {
                  Message.debug ("Loaded assembly " + this._library.FullName + " contains Nemerle types...");
                  this._is_generated_by_nemerle <- true
                }
              | "Nemerle.ContainsMacroAttribute" =>
                 def meth = attribute_type.GetMethod ("GetName");
                 def macro_name = (meth.Invoke (attribute, null) :> string);
                 Message.debug ("register_macro " + macro_name);
                 def macro_type = _library.GetType (macro_name);
                 if (macro_type == null) {
                   Message.warning ("failed to lookup macro `" + macro_name + "' in assembly " + 
                                    _library.FullName);
                 } else {
                   def ctor = macro_type.GetConstructor (System.Type.EmptyTypes);
                   if (ctor == null) {
                     Message.warning ("failed to lookup constructor in macro `" + macro_name + 
                                      "' from assembly " + _library.FullName);
                   } else {
                     def macro_object = ctor.Invoke (null);
                     if (macro_object == null) {
                       Message.warning ("failed to construct instance of macro `" + macro_name + 
                                        "' from assembly " + _library.FullName);
                     } else {
                       def casted_macro =
                         try {
                           (macro_object :> IMacro)
                         } with {
                           | _ : System.InvalidCastException =>
                             Message.warning ("instance of macro `" + macro_name + 
                                              "' from assembly " + _library.FullName + 
                                              " does not implement IMacro interface");
                             null
                         };
                         when (casted_macro != null)
                           MacroRegistry.register_macro (casted_macro);
                     }
                   }
                 }
              | _ => ()
            };
            
            loop (rest)
        }
      };
      
      loop (this._assembly_attributes)
    }


    (**
     * Turns a Framework type into something edible by Nemerle's type system
     *)
    private TypeOfType (framework_type : System.Type) : Type
    {
      def framework_type_as_string = framework_type.FullName;
      
      // FIXME: ref and out types, anyone?
      if (framework_type_as_string == "System.Void")
        T_void ()
      else if (framework_type.IsArray)
        T_array (TypeOfType (framework_type.GetElementType ()))
      else if (framework_type.IsByRef)
        T_ref (TypeOfType (framework_type.GetElementType ()))
      else
        match (LibraryReferenceManager.LookupType (framework_type_as_string)) {
          | Some (tc) => T_app (tc, [])
          | None => Util.ice ("unbound external type " + framework_type_as_string)
        }
    } 

    private TyconOfType (framework_type : System.Type) : Tycon
    {
      match (TypeOfType (framework_type)) {
        | T_app (tc, []) => tc
        | _ => Util.ice ()
      }
    } 

    (**
     * If true, the library seems to have been generated by the Nemerle compiler
     *)
    public IsGeneratedByNemerle () : bool 
    {
      this._is_generated_by_nemerle
    }
    
    (**
     * Looks up a type name in this assembly. The type name is expected
     * to be full, i.e. containing the full namespace qualifier.
     *)
    public Lookup (name : string) : option (Tycon) {

      (* always first check if such a type is defined in the current library *)
      def reflected_type = this._library.GetType (name);

      //  Message.debug ("Lookup in " + _library.FullName + " for '" + name + "' " +
      //    if (reflected_type == null) " failed" else " ok");

      if (reflected_type != null)
        if (_is_generated_by_nemerle)
          if (has_attribute ("Nemerle.TypeAttribute", reflected_type.GetCustomAttributes (false)))
            Some ((ExternalNemerleType (this, reflected_type) : Tycon))
          else
            Some ((NetType (this, reflected_type) : Tycon))
        else
          Some ((NetType (this, reflected_type) : Tycon))
      else None ()
    }

    /* -----------------------------------------------------------------
     * .NET types
     * ----------------------------------------------------------------- 
     */
    private class NetType
      implements Tycon
    {
      protected handle : System.Type;
      protected library : LibraryReference;
      protected id : int;
      protected members : Hashtable (string, list (IMember));

      public this (lib : LibraryReference, h : System.Type)
      {
        // first cache ourself to avoid loops
        LibraryReferenceManager._loaded_types.Set (h.FullName, Some ((this : Tycon)));
        LibraryReferenceManager._loaded_types.Set (h.FullName.Replace ('+', '.'), Some ((this : Tycon)));
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        members <- Hashtable (2);
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        T_app (this, [])
      }

      public GetKind () : MemberKind
      {
        MK_type (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        if (handle.DeclaringType == null)
          null
        else
          library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        [Mod_public ()]
      }

      public IsStatic () : bool
      {
        true
      }

      public GetId () : int
      {
        id
      }

      public GetFullName () : string
      {
        handle.FullName.Replace ('+', '.')
      }

      public GetTyconKind () : TyconKind
      {
        TK_ExternalNetType (handle)
      }

      public GetTydecl () : Type_decl
      {
        if (handle.IsInterface)
          TD_interface ()
        else
          TD_class ()
      }

      public MakeSubst (parms : list (Type)) : Subst
      {
        match (parms) {
          | [] => ()
          | _ =>
            Message.error ("framework type `" + GetFullName () + "' supplied with type arguments")
        };
        Map.int_map ()
      }

      public FreshSubst () : Subst
      {
        Map.int_map ()
      }

      public SuperType (tc : Tycon) : option (list (Type))
      {
        match (tc.GetTyconKind ()) {
          | TK_ExternalNetType (t) when t.IsAssignableFrom (handle)
          | TK_ExternalNemerleType (t) when t.IsAssignableFrom (handle) => Some ([])
          | _ => None ()
        }
      }

      public SubtypingSubst (_ : Tycon) : Subst
      {
        Map.int_map ()
      }

      public SuperClass () : option (Tycon)
      {
        if (handle.BaseType == null)
          None ()
        else
          Some (library.TyconOfType (handle.BaseType))
      }

      public GetSuperTypes () : list (Type)
      {
        def supertypes = Hashtable (30);
        def add_bt (t : Type) {
          match (t) {
            | T_app (tc, []) =>
              if (supertypes.Contains (tc.GetId ())) ()
              else {
                supertypes.Add (tc.GetId (), t);
                match (tc.SuperClass ()) {
                  | Some (tc) => add_bt (T_app (tc, []))
                  | None => ()
                }
              }
            | _ => Util.ice ()
          }
        };
        List.iter (add_bt, GetDirectSuperTypes ());
        supertypes.Fold (fun (_, tc, acc) { tc :: acc }, [])
      }

      public GetDirectSuperTypes () : list (Type)
      {
        def ifaces = List.map (library.TypeOfType, 
                               List.from_array (handle.GetInterfaces ()));
        match (SuperClass ()) {
          | Some (r) => T_app (r, []) :: ifaces
          | None => ifaces
        }
      }

      public SameAs (tc : Tycon) : bool 
      {
        GetId () == tc.GetId ()
      }

      public GetMembers () : list (IMember) 
      {
        LookupMember ("", LF_all ())
      }

      protected virtual imember_of_memberinfo (m : MemberInfo) : option (IMember)
      {
        def is_a (x) {
          m.MemberType %& x != (0 :> MemberTypes)
        };
        def ret (x : IMember) { Some (x) };
        
        if (is_a (MemberTypes.Constructor) || is_a (MemberTypes.Method))
          ret (NetMethod (library, (m :> MethodBase)))
        else if (is_a (MemberTypes.Field))
          ret (NetField (library, (m :> FieldInfo)))
        else if (is_a (MemberTypes.Property))
          ret (NetProperty (library, (m :> PropertyInfo)))
        else if (is_a (MemberTypes.NestedType))
          ret (library.TyconOfType ((m :> System.Type)))
        else
          None ()
      }

      private collect_members (name : string) : list (IMember) 
      {
        def add_member (acc, m : MemberInfo) {
          def tc = library.TyconOfType (m.DeclaringType);
          if (this.SameAs (tc)) {
            match (imember_of_memberinfo (m)) {
              | Some (r) => r :: acc
              | None => acc
            }
          } else {
            def fullname = m.ToString ();
            def proper_name (m : IMember) {
              m.GetHandle ().ToString () == fullname
            };
//            Message.debug ("name " + name + " look for " + fullname + " in " + tc.GetFullName () + " from " + GetFullName ());
            match (List.filter (proper_name, tc.LookupMember (name, LF_all ()))) {
              | [] => Util.ice ("no match for " + name)
              | [x] => x :: acc
              | _ =>  Util.ice ("2+ matches for " + name)
            }
          }
        };
        
        def flags = BindingFlags.Public     %|
                    BindingFlags.NonPublic  %|
                    BindingFlags.Static     %|
                    BindingFlags.Instance   ;
                    
        def member_array = 
          if (name == "")
            handle.GetMembers (flags) 
          else 
            handle.GetMember (name, flags);
            
        List.Rev (List.FoldLeft (add_member, [], List.FromArray (member_array)))
      }

      public LookupMember (name : string, lookup_flag : LookupFlag) : list (IMember) 
      {
        match (members.Get (name)) {
          | Some (r) =>
            Tyutil.FilterMembers (r, lookup_flag)
          | None =>
            def lst = collect_members (name);
            members.Set (name, lst);
            Tyutil.FilterMembers (lst, lookup_flag)
        }
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || handle.IsNestedPublic ||
          (handle.DeclaringType != null &&
           Option.is_some (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsNestedFamily)
      }

      public GetSystemType () : System.Type
      {
        handle
      }
    }
    
    private class NetField 
      implements IField
    {
      protected handle : FieldInfo;
      protected library : LibraryReference;
      protected id : int;

      public this (lib : LibraryReference, h : FieldInfo)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
      }

      public GetFieldInfo () : FieldInfo
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        library.TypeOfType (handle.FieldType);
      }

      public GetKind () : MemberKind
      {
        MK_field (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        if (handle.IsStatic) [Mod_public (); Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        handle.IsStatic
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        ! handle.IsInitOnly
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.is_some (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsFamily)
      }
    }
    
    class NetProperty
      implements IProperty
    {
      protected handle : PropertyInfo;
      protected library : LibraryReference;
      protected id : int;
      protected is_static : bool;
      protected getter : NetMethod;
      protected setter : NetMethod;
      protected mem_type : Type;

      public this (lib : LibraryReference, h : PropertyInfo)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        is_static <- {
          def get_method = handle.GetGetMethod (true);
          def set_method = handle.GetSetMethod (true);
          (get_method != null && get_method.IsStatic) ||
          (set_method != null && set_method.IsStatic);
        };
        
        unless (handle.GetGetMethod () == null)
          getter <- NetMethod (library, handle.GetGetMethod ());
        unless (handle.GetSetMethod () == null)
          setter <- NetMethod (library, handle.GetSetMethod ());

        def ret_type = library.TypeOfType (handle.PropertyType);

        def fun_args (t) {
          match (t) {
            | T_fun (T_void, _) => []
            | T_fun (T_prod (lst), _) => lst
            | T_fun (t, _) => [t]
            | _ => Util.ice ()
          }
        };

        def args =
          if (getter != null)
            fun_args (getter.GetMemType ())
          else if (setter != null)
            List.rev (List.tl (List.rev (fun_args (setter.GetMemType ()))))
          else
            [];
        
        mem_type <-
          match (args) {
            | [] => ret_type
            | [x] => T_fun (x, ret_type)
            | lst => T_fun (T_prod (lst), ret_type)
          };
      }

      public GetGetter () : IMethod
      {
        getter
      }

      public GetSetter () : IMethod
      {
        setter
      }

      public GetPropertyInfo () : PropertyInfo
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public GetKind () : MemberKind
      {
        MK_property (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        if (is_static) [Mod_public (); Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        is_static
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        handle.CanWrite
      }

      public CanAccess (_source : Tycon) : bool
      {
        // FIXME: this is broken... we need to check method attributes
        true
      }
    }
    
    class NetMethod
      implements IMethod
    {
      protected handle : MethodBase;
      protected library : LibraryReference;
      protected id : int;
      protected fun_header : Fun_header;

      public this (lib : LibraryReference, h : MethodBase)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        def mkparm (p : ParameterInfo) {
          Fun_parm (
            loc = library._location,
            name = p.Name,
            ty = library.TypeOfType (p.ParameterType),
            decl = null
          )
        };
        def ret_type =
          if (handle.Name == ".ctor" || handle.Name == ".cctor")
            T_void ()
          else
            library.TypeOfType ((handle :> MethodInfo).ReturnType);
        fun_header <-
          Fun_header (
            loc = library._location,
            name = GetName (),
            id = id,
            ret_type = ret_type,
            parms = List.map (mkparm, List.from_array (handle.GetParameters ())),
            typarms = [],
            tenv = null,
            closure_vars = null, // hm..
            all_locals = null,
            decl = null,
            cg_method = null
          )
      }
      
      public GetExternName () : string
      {
        null
      }

      public GetMethodBase () : MethodBase
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        handle
      }

      public GetMemType () : Type
      {
        Tyutil.fun_type (GetHeader ())
      }

      public GetKind () : MemberKind
      {
        MK_method (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        if (handle.IsStatic) [Mod_public (); Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        handle.IsStatic 
      }

      public GetId () : int
      {
        id
      }

      public GetFreshType () : Type
      {
        GetMemType ()
      }

      public GetFunKind () : Fun_kind
      {
        if (handle.DeclaringType.IsInterface)
          FK_iface_method (false)
        else
          if (handle.IsConstructor)
            if (handle.IsStatic)
              FK_static_ctor ()
            else
              FK_ctor ()
          else
            if (handle.IsStatic)
              FK_function ()
            else
              FK_bound_method ([])
      }

      public GetConstructorInfo () : ConstructorInfo
      {
        assert (handle.IsConstructor);
        (handle :> ConstructorInfo)
      }

      public GetMethodInfo () : MethodInfo
      {
        assert (!handle.IsConstructor);
        (handle :> MethodInfo)
      }

      public GetHeader () : Fun_header
      {
        fun_header
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.is_some (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsFamily)
      }
    }
   
    /* -----------------------------------------------------------------
     * External Nemerle types
     * ----------------------------------------------------------------- 
     */
     
    private static get_string_attribute (attr_name : string, meth_name : string,
                                         attributes : array (object)) : string
    {
      def loop (i) {
        if (i >= attributes.Length) null
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == attr_name) {
            def meth = attr_ty.GetMethod (meth_name);
            (meth.Invoke (attr, null) :> string)
          } else loop (i + 1)
        }
      };
      loop (0)
    }

    private static get_encoded_type (attributes : array (object)) : string
    {
      get_string_attribute ("Nemerle.TypeAttribute", "GetEncodedType", attributes)
    }

    private static get_variant_options (attributes : array (object)) : list (string)
    {
      def str = get_string_attribute ("Nemerle.VariantAttribute", 
                                      "GetVariantOptions", attributes);
      List.from_array (str.Split (mkarray [',']))
    }

    private static has_attribute (name : string, attributes : array (object)) : bool
    {
      def loop (i) {
        if (i >= attributes.Length) false
        else {
          def attr = attributes [i];
          def attr_ty = attr.GetType ();
          if (attr_ty.FullName == name) true
          else loop (i + 1)
        }
      };
      loop (0)
    }
    
    private class ExternalNemerleType extends NetType
    {
      tenv : Int_map (Tyvar.T);
      typarms : list (Tyvar.T);
      direct_supertypes : list (Type);
      supertypes : list (Type);
      supertype_map : Int_map (Type);
      tydecl : Type_decl;
      
      public this (lib : LibraryReference, h : System.Type)
      {
        base (lib, h);
        
        def tenv =
          if (handle.DeclaringType != null)
            (library.TyconOfType (handle.DeclaringType) :> ExternalNemerleType).tenv
          else Map.int_map ();

        def type_attrs = h.GetCustomAttributes (false);

        def attr_str = get_encoded_type (type_attrs); 
        def (typarms, tenv, dst, st) = TyCodec.DecodeTyinfo (tenv, attr_str);

        this.typarms <- typarms;
        this.tenv <- tenv;
        direct_supertypes <- dst;
        supertypes <- st;

        def add (m : Int_map (Type), t) {
          match (t) {
            | T_app (tc, _) => m.add (tc.GetId (), t)
            | _ => Util.ice ("invalid supertype")
          }
        };

        supertype_map <- List.FoldLeft (add, Map.int_map (), supertypes);

        if (has_attribute ("Nemerle.VariantAttribute", type_attrs)) {
          def names = get_variant_options (type_attrs);
          def that = this; // FIXME: hack!
          def get_opt (name) {
            match (that.library.Lookup (name)) {
              | Some (tc) => tc
              | None => Util.ice ("cannot find variant option named " + name)
            }
          };
          tydecl <- TD_variant (List.Map (get_opt, names))
        } else if (has_attribute ("Nemerle.VariantOptionAttribute", type_attrs)) {
          tydecl <- TD_variant_option ()
        } else if (has_attribute ("Nemerle.TypeAliasAttribute", type_attrs)) {
          def type_string = 
            get_string_attribute ("Nemerle.TypeAliasAttribute",
                                  "GetAliasedType", type_attrs);
          tydecl <- TD_alias (TyCodec.DecodeType (tenv, type_string))
        } else if (handle.IsInterface)
          tydecl <- TD_interface ()
        else
          tydecl <- TD_class ()
      }
      
      public override GetMemType () : Type
      {
        T_app (this, List.Map (fun (tv) { T_var (tv) }, typarms))
      }

      public override GetTyconKind () : TyconKind
      {
        TK_ExternalNemerleType (handle)
      }

      public override GetTydecl () : Type_decl
      {
        tydecl
      }

      public override MakeSubst (parms : list (Type)) : Subst
      {
        Tyinfo.ConstructSubst (this, typarms, parms)
      }

      public override FreshSubst () : Subst
      {
        Tyvar.fresh_subst (typarms)
      }

      public override SuperType (tc : Tycon) : option (list (Type))
      {
        match (supertype_map.find (tc.GetId ())) {
          | Some (T_app (_, args)) => Some (args)
          | Some => Util.ice ()
          | None => None ()
        }
      }

      public override SubtypingSubst (tc : Tycon) : Subst
      {
        if (tc.GetId () == GetId ())
          Map.int_map () // current type, no substitution
        else
          tc.MakeSubst (Option.unsome (SuperType (tc)));
      }

      public override GetSuperTypes () : list (Type)
      {
        supertypes
      }

      public override GetDirectSuperTypes () : list (Type)
      {
        direct_supertypes
      }

      protected override imember_of_memberinfo (m : MemberInfo) : option (IMember)
      {
        def is_a (x) {
          m.MemberType %& x != (0 :> MemberTypes)
        };
        def is_nem (x : MemberInfo) {
          has_attribute ("Nemerle.TypeAttribute", x.GetCustomAttributes (false))
        };
        def ret (x : IMember) { Some (x) };
        
        if (is_a (MemberTypes.Constructor) || is_a (MemberTypes.Method)) {
          if (is_nem (m))
            ret (ExternalNemerleMethod (tenv, library, (m :> MethodBase)))
          else
            ret (NetMethod (library, (m :> MethodBase)))
        } else if (is_a (MemberTypes.Field)) {
          if (is_nem (m))
            ret (ExternalNemerleField (tenv, library, (m :> FieldInfo)))
          else
            ret (NetField (library, (m :> FieldInfo)))
        } else if (is_a (MemberTypes.Property))
          Util.ice ("property in external nemerle type")
        else if (is_a (MemberTypes.NestedType))
          ret (library.TyconOfType ((m :> System.Type)))
        else
          Util.ice ("unknown object in nemerle type " + 
                    m.Name + " in " + GetFullName ())
      }
    }
    
    private class ExternalNemerleField extends NetField
    {
      real_type : Type;
      
      public this (tenv : Int_map (Tyvar.T), lib : LibraryReference, h : FieldInfo)
      {
        base (lib, h);
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        real_type <- TyCodec.DecodeType (tenv, attr_str);
      }

      public override GetMemType () : Type
      {
        real_type
      }
    }
    
    class ExternalNemerleMethod extends NetMethod
    {
      public this (tenv : Int_map (Tyvar.T), lib : LibraryReference, h : MethodBase)
      {
        base (lib, h);
        def type_attrs = h.GetCustomAttributes (false);
        def attr_str = get_encoded_type (type_attrs); 
        TyCodec.FixupFunctionHeader (tenv, fun_header, attr_str);
      }
      
      public override GetExternName () : string
      {
        null
      }

      public override GetFreshType () : Type
      {
        GetMemType () /- Tyvar.fresh_subst (fun_header.typarms)
      }
    }
   
  }


  
} (* namespace *)
