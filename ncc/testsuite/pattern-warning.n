using Nemerle.IO;
using Nemerle.Collections;

variant X  {
  | A
  | B
  | C
}

module M {
  f1 (x : X * X) : void {
    match (x) { // W: this matching is not exhaustive
      | (_, A) => () // OK
      | (B, _) => () // OK
      | (A, B) => () // OK
      | (A, A) => () // W: this match clause is unused
      | (A, C) => () // OK
      | (C, C) => () // OK
    } 
  }
  
  f2 (x : X * X) : void {
    match (x) {
      | (_, A) => () // OK
      | (B, _) => () // OK
      | (A, B) => () // OK
      | (A, A) => () // W: this match clause is unused
      | (A, C) => () // OK
      | (C, C) => () // OK
      | (C, B) => () // OK
    } // OK
  }
  
  f3 (x : X * X) : void {
    match (x) {
      | _ => () // OK
      | (A, A) => () // W: this match clause is unused
    } // OK
  }

  f4 (x : X * X) : void {
    | (A,A) => () // OK
    | _ => () // OK
    | (B,B) => () // W: this match clause is unused
  } // OK

  f4 (x : X, y : X, z : X) : void { // W: this matching is not exhaustive
    | (A,B,C) => () // OK
    | (B,C,A) => () // OK
  } 

  Main () : void { 
    def g (a : int, b : int) {
      | (1, 2) => printf ("jea\n")
      | _ => printf ("noa\n")
    };

    def c = (1,2);
    g (c);

    List.Iter ([(2,2), (2,2)],
               fun (x, y) { | (2,2) => printf ("jeaa\n"); | _ => printf ("noaa\n") });
  }
}

/*
BEGIN-OUTPUT
jea
jeaa
jeaa
END-OUTPUT
*/
