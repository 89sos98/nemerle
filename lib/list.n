(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)


(* TYPE DEFINITION *)
variant list ('a) 
  {
    | Cons { hd : 'a; tl : list ('a); }
    | Nil {}
  }
	     
module List
  {
	
    (* BASIC LIST OPERATIONS *)
    
    'a length (x : list ('a)) : int {
      def loop (acc : int, x : list ('a)) : int {
        match (x) {
	  | Cons x => loop (acc + 1, x.tl)
	  | _ => acc
	}
      }
      loop (0, x);
    }
    
    
    'a head (l : list ('a)) : 'a {
      match (l) {
        | Cons (x, _) => x
        | Nil => raise Invalid_argument ("List.head")
      }
    }
    
    'a hd (l : list ('a)) : 'a {
      head (l)
    }
    
    'a tail (l : list ('a)) : list ('a) {
      match (l) {
	| Cons (_, tl) => tl
	| Nil => raise Invalid_argument ("List.tail")
      }
    }
    
    'a tl (l : list ('a)) : list ('a) {
      tail (l)
    }
    
    'a nth (l : list ('a), n : int) : 'a {
      match (l) {
	| Cons(h,t) => 
	    if ( n == 0 )
	      h
	    else
	      nth(t, n-1)
        | Nil => raise Invalid_argument ("List.nth")
      }
    }

    'a last (l : list ('a)) : 'a {
      match (l) {
        | Cons (x, Nil) => x
        | Cons (_, xs) => last (xs)
        | Nil => raise Invalid_argument ("List.last")
      }
    }
    
    'a rev (l : list ('a)) : list ('a) {
      def loop (acc : list ('a), l : list ('a)) : list ('a) {
        match (l) {
          | Cons (x, xs) => loop (Cons (x, acc), xs)
          | Nil => acc
        }
      }
      loop (Nil (), l);
    }
    
    'a append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
        | Nil => y
        | Cons x => Cons (x.hd, append (x.tl, y))
      }
    }
    
    'a rev_append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
      	| Cons(h, t) => rev_append(t, Cons(h,y))
	| Nil => y
      }
    }
    
    'a concat (l : list (list ('a))) : list ('a) {
      fold_left(append, Nil(), rev(l))
    }    

    'a flatten (l : list (list ('a))) : list ('a) {
      concat(l)
    }


    (* ITERATORS *)


    'a iter (f : 'a -> void, l : list ('a)) : void {
      def i (dummy : int, e : 'a) : int { f (e); dummy }
      def _ = fold_left (i, 0, l);
      ();
    }    

    'a, 'b map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      match (x) {
        | Nil => Nil ()
        | Cons x => Cons (f (x.hd), map (f, x.tl))
      }
    }

    'a, 'b rev_map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      def loop (acc : list ('b), x : list ('a)) : list ('b) {
      	match (x) {
	  | Cons(h,t) => loop(Cons(f(h),acc), t)
	  | Nil => acc
	}
      } 
      loop(Nil(), x)
    }

    'a, 'b fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b {
      match (l) {
        | Nil _ => acc
        | Cons l => fold_left (f, f (acc, l.hd), l.tl)
      }
    }

    'a, 'b fold_right (f : 'a * 'b -> 'b, l : list ('a), b : 'b) : 'b {
      match (l) {
	| Nil _ => b
	| Cons l => f(l.hd, fold_right(f,l.tl,b))
      }
    }
    

    (* ITERATORS ON TWO LISTS *)
    

    'a, 'b iter2 (f : 'a  * 'b -> void, a : list ('a), b : list ('b)) : void {
      match ((a, b)) {
        | (Nil, Nil) => ()
        | (Cons (x, xs), Cons (y, ys)) => { f (x, y); iter2 (f, xs, ys) }
        | _ => raise Invalid_argument("List.iter2")
      }
    }

    'a, 'b, 'c map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      match ((x, y)) {
        | (Nil, Nil) => Nil ()
        | (Cons (x, xs), Cons (y, ys)) => Cons (f (x, y), map2 (f, xs, ys))
        | _ => raise Invalid_argument("List.map2")
      }
    }

    'a, 'b, 'c rev_map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      def loop (acc : list ('c), x : list ('a), y : list ('b)) : list ('c) {
      	match ((x, y)) {
          | (Nil, Nil) => Nil ()
          | (Cons (x, xs), Cons (y, ys)) => loop(Cons (f (x, y),acc), xs, ys)
          | _ => raise Invalid_argument("List.rev_map2")
      	}
      }
      loop(Nil(), x, y)
    }

    'a, 'b, 'c fold_left2 (f : 'c * 'a  * 'b -> 'c, acc : 'c, a : list ('a), b : list ('b)) : 'c {
      match ((a, b)) {
        | (Nil, Nil) => acc
        | (Cons (x, xs), Cons (y, ys)) => fold_left2 (f, f (acc, x, y), xs, ys)
        | _ => raise Invalid_argument("List.fold_left2")
      }
    }

    'a, 'b, 'c fold_right2 (f : 'a * 'b  * 'c -> 'c, a : list ('a), b : list ('b), c : 'c) : 'c {
      match ((a, b)) {
        | (Nil, Nil) => c
        | (Cons (x, xs), Cons (y, ys)) => f (x, y, fold_right2(f,xs,ys,c))
        | _ => raise Invalid_argument("List.fold_right2")
      }
    }


    (* LIST SCANNING *)


    'a forall (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | Cons (x, xs) =>
          if (f (x)) forall (f, xs)
          else false
        | Nil => true
      }
    }

    'a for_all (f : 'a -> bool, l : list ('a)) : bool {
      forall(f, l)
    }

    'a exists (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | Nil => false
        | Cons (h, t) => if (f(h)) true else exists(f, t)
      }
    }

    'a, 'b forall2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a, b)) {
        | (Nil, Nil) => true
        | (Cons (x, xs), Cons (y, ys)) =>
          if (f (x, y)) forall2 (f, xs, ys)
          else false
        | _ => raise Invalid_argument("List.forall2")
      }
    }

    'a, 'b for_all2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      forall2(f,a,b)
    }

    'a, 'b exists2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a,b)) {
        | (Nil, Nil) => false
        | (Cons (x, xs), Cons (y, ys)) => if (f(x,y)) true else exists2(f,xs,ys)
      }
    }

    'a mem (a : 'a, l : list ('a)) : bool {
      match (l) {
	| Cons(h,t) => if ( h == a ) true else mem (a,t)
	| Nil => false
      }
    }

    
    (* LIST SEARCHING *)
    
    
    'a find (pred : 'a -> bool, l : list ('a)) : 'a {
      match (l) {
      	| Cons(h,t) => if ( pred(h) ) h else find (pred, t)
	| Nil => raise Not_found ()
      }
    }

    'a filter (f : 'a -> bool, l : list ('a)) : list ('a) {
      match (l) {
        | Cons (x, xs) =>
          if (f (x)) Cons (x, filter (f, xs))
          else filter (f, xs)
        | Nil => Nil ()
      }
    }

    'a find_all (f : 'a -> bool, l : list ('a)) : list ('a) {
      filter(f, l)
    }

    'a partition ( pred : 'a -> bool, l : list ('a)) : list ('a) * list ('a) {
      def loop (l : list ('a), sat : list ('a), notsat : list ('a)) 
            : list ('a) * list ('a) 
	{
      	  match (l) {
	    | Cons(h,t) => 
	        if ( pred (h) ) 
		  loop(t,Cons(h,sat),notsat)
		else 
		  loop(t,sat,Cons(h,notsat))
	    | Nil => (rev(sat),rev(notsat))
	  }
      	}
      loop(l,Nil(),Nil())	
    }


    (* ASSOCIATION LISTS *)
    

    'a, 'b assoc (key : 'a, l : list ('a * 'b)) : 'b {
      match (l) {
      	| Cons((k,v),t) =>
	    if ( key == k )
	      v
	    else
	      assoc (key,t)
	| Nil => raise Not_found ()
      }
    }

    'a, 'b mem_assoc (key : 'a, l : list ('a * 'b)) : bool {
      match (l) {
      	| Cons((k,v),t) =>
	    if ( key == k )
	      true
	    else
	      mem_assoc (key,t)
	| Nil => false
      }
    }

    'a, 'b remove_assoc (key : 'a, l : list ('a * 'b)) : list ('a * 'b) {
      def loop (acc : list ('a * 'b), l : list ('a * 'b)) : list ('a * 'b)
	{
	  match (l) {
	    | Cons((k,v),t) => 
	        if ( key == k )
	          loop (acc,t)
	        else
	          loop (Cons((k,v),acc),t)
	    | Nil => rev(acc)
	  }
      	}
      loop(Nil(),l)	
    }


    (* LISTS OF PAIRS *)

    
    'a, 'b split(l : list ('a * 'b)) : list ('a) * list ('b) {
      def loop (acc1 : list ('a), acc2 : list ('b), l : list ('a * 'b)) : list ('a) * list ('b) 
      	{
	  match (l) {
	    | Cons((a,b),t) => loop(Cons(a,acc1),Cons(b,acc2),t)
	    | Nil => (rev(acc1), rev(acc2))
	  }
      	} 
      loop(Nil(), Nil(), l)
    }

    'a, 'b combine(a : list ('a), b : list ('b)) : list ('a * 'b) {
      def loop (acc : list ('a * 'b), a : list ('a), b : list ('b)) : list ('a * 'b) 
	{
      	  match ((a,b)) {
	    | (Cons(x, xs), Cons(y,ys)) => loop(Cons((x, y), acc), xs, ys)
	    | (Nil,Nil) => rev(acc)
	    | _ => raise Invalid_argument("List.combine")
      	  }
      	}
      loop(Nil(),a,b)
    }


  } (* end of module List *)
