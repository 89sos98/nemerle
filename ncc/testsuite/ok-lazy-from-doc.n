
interface I_Comparable_To ('a)
{ 
  compare_to (_ : 'a) : int;
}   

interface I_Runnable ('a)
{
  run () : 'a;
} 

interface I_Set ('a)
{   
  add (elem : 'a) : void;
  mem (elem : 'a) : bool;
  'b fold (f : 'a * 'b -> 'b, init : 'b) : 'b;
} 

class Lazy ('a)
  implements
    I_Comparable_To(Lazy('a)),
    I_Runnable('a)
{
  (* There is no real-life reason it needs integer key, except
     that will put this stuff into tree. *)
  key : int;
  public fnc : void -> 'a;

  run () : 'a
    implements I_Runnable.run
  { (this . fnc) () }

  compare_to (that : Lazy('a)) : int
    implements I_Comparable_To.compare_to
  { this . key - that . key }
}

class Cached_Lazy ('a)
  extends Lazy ('a)
  implements
    I_Comparable_To(Lazy('a)),
    I_Runnable('a)
{
  (* key and fnc fields are automagically copied. *)
  mutable cache : 'a;

  _run () : 'a implements I_Runnable.run {
    if (this . cache == null) {
      def v = this . fnc ();
      this.cache <- v; 
      v
    } else
      this.cache
  }
}
