(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open System.Core;

namespace System {
  type Exception = extern "System.Exception";
  type Object = extern "System.Object";
}

namespace Nemerle {
  public interface Func0 implements Func1
    {
      apply () : object;
      new apply (_ : object) : object;
    }

  public interface Func1
    {
      apply (_ : object) : object;
    }
  
  public interface Func2 implements Func1
    {
      apply (_ : object, _ : object) : object;
      new apply (_ : object) : object;
    }
  
  public interface Func3 implements Func1
    {
      apply (_ : object, _ : object, _ : object) : object;
      new apply (_ : object) : object;
    }
  
  public interface Func4 implements Func1
    {
      apply (_ : object, _ : object, _ : object, _ : object) : object;
      new apply (_ : object) : object;
    }
  
  public interface Func5 implements Func1
    {
      apply (_ : object, _ : object, _ : object, _ : object, _ : object) : object;
      new apply (_ : object) : object;
    }
  
  public interface Func6 implements Func1
    {
      apply (_ : object, _ : object, _ : object, _ : object, _ : object) : object;
      new apply (_ : object) : object;
    }
  
  public class Tuple2
    {
      public field1 : object;
      public field2 : object;
    }
  
  public class Tuple3
    {
      public field1 : object;
      public field2 : object;
      public field3 : object;
    }
  
  public class Tuple4
    {
      public field1 : object;
      public field2 : object;
      public field3 : object;
      public field4 : object;
    }
  
  public class Tuple5
    {
      public field1 : object;
      public field2 : object;
      public field3 : object;
      public field4 : object;
      public field5 : object;
    }
  
  public class Tuple6
    {
      public field1 : object;
      public field2 : object;
      public field3 : object;
      public field4 : object;
      public field5 : object;
      public field6 : object;
    }
  
  public class Tuple7
    {
      public field1 : object;
      public field2 : object;
      public field3 : object;
      public field4 : object;
      public field5 : object;
      public field6 : object;
      public field7 : object;
    }
  
  public class Core {
    type int = extern "int";
    type float = extern "float";
    type string = extern "string";
    type object = extern "object";
    type bool = extern "bool";
    type char = extern "char";
   
    static true : bool = extern "true";
    static false : bool = extern "false";

    static `+` (x : int, y : int) : int = extern "%op+";
    static `-` (x : int, y : int) : int = extern "%op-";
    static `*` (x : int, y : int) : int = extern "%op*";
    static `%` (x : int, y : int) : int = extern "%op%";
    static `/` (x : int, y : int) : int = extern "%op/";

    static `<` (x : int, y : int) : bool = extern "%op<";
    static `>` (x : int, y : int) : bool = extern "%op>";
    static 'a `==` (x : 'a, y : 'a) : bool = extern "%op==";
    static 'a `!=` (x : 'a, y : 'a) : bool = extern "%op!=";
    static `>=` (x : int, y : int) : bool = extern "%op>=";
    static `<=` (x : int, y : int) : bool = extern "%op<=";
    
    static `-` (x : int) : int = extern "%op-";
    static `!` (x : bool) : bool = extern "%op!";

    static `+` (x : string, y : string) : string = extern "%op+";

    static print_string (s : string) : void = extern "System.Console.Write";
    static print_endline (s : string) : void = extern "System.Console.WriteLine";
    static compare_strings (s1 : string, s2 : string) : int 
        = extern "System.String.CompareOrdinal";
    static string_of_int (_ : int) : string = extern "System.Convert.ToString";

    static read_char () : int = extern "System.Console.Read";
    static read_line () : string = extern "System.Console.ReadLine";

    public class Invalid_argument extends System.Exception 
      {
        public msg : string;
        public this (msg : string) { this.msg <- msg; }
      }
      
    public class Not_found extends System.Exception 
      {
        public this () {}
      }
      
    public class Match_failure extends System.Exception 
      {
        public this () {}
      }

    public class Null_match extends System.Exception
      {
        public this () {}
        public static raise_self () : bool { raise Null_match () }
      }
  }
}
