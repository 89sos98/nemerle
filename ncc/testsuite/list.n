(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

(*
variant list ('a)
  {
    | Cons { hd : 'a; tl : list ('a); }
    | Nil {}
  }
*)
module Listtest
  {
    type t ('a) = list ('a);

    'a append (x : list ('a), y : list ('a)) : list ('a) {
      match (x) {
        | Nil => y
        | Cons x => Cons (x.hd, append (x.tl, y))
      }
    }

    'a, 'b map (f : 'a -> 'b, x : list ('a)) : list ('b) {
      match (x) {
        | Nil => Nil ()
        | Cons x => Cons (f (x.hd), map (f, x.tl))
      }
    }

    'a last (l : list ('a)) : 'a {
      match (l) {
        | Cons (x, Nil) => x
        | Cons (_, xs) => last (xs)
        | Nil => raise Invalid_argument ("List.last")
      }
    }

    'a head (l : list ('a)) : 'a {
      match (l) {
        | Cons (x, _) => x
        | Nil => raise Invalid_argument ("List.head")
      }
    }

    'a, 'b, 'c map2 (f : 'a * 'b -> 'c, x : list ('a), y : list ('b)) : list ('c) {
      match ((x, y)) {
        | (Nil, Nil) => Nil ()
        | (Cons (x, xs), Cons (y, ys)) => Cons (f (x, y), map2 (f, xs, ys))
        | _ => raise Invalid_argument("List.map2")
      }
    }

    'a length (x : list ('a)) : int {
      def loop (acc : int, x : list ('a)) : int {
        match (x) {
          | Cons x => loop (acc + 1, x.tl)
          | _ => acc
        }
      }
      loop (0, x);
    }

    public 'a, 'b fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b {
      match (l) {
        | [] => acc
        | x :: xs => fold_left (f, f (acc, x), xs)
      }
    }

    public 'a iter (f : 'a -> void, l : list ('a)) : void {
      def i (dummy : int, e : 'a) : int { f (e); dummy }
      def _ = fold_left (i, 0, l);
      ();
    }

    'a exists (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | Nil => false
        | Cons (h, t) => if (f(h)) true else exists(f, t)
      }
    }

    'a, 'b, 'c fold_left2 (f : 'c * 'a  * 'b -> 'c, acc : 'c, a : list ('a), b : list ('b)) : 'c {
      match ((a, b)) {
        | (Nil, Nil) => acc
        | (Cons (x, xs), Cons (y, ys)) => fold_left2 (f, f (acc, x, y), xs, ys)
        | _ => raise Invalid_argument("List.fold_left2")
      }
    }
      
    'a, 'b iter2 (f : 'a  * 'b -> void, a : list ('a), b : list ('b)) : void {
      match ((a, b)) {
        | (Nil, Nil) => ()
        | (Cons (x, xs), Cons (y, ys)) => { f (x, y); iter2 (f, xs, ys) }
        | _ => raise Invalid_argument("List.iter2")
      }
    }

    'a, 'b forall2 (f : 'a * 'b -> bool, a : list ('a), b : list ('b)) : bool {
      match ((a, b)) {
        | (Nil, Nil) => true
        | (Cons (x, xs), Cons (y, ys)) =>
          if (f (x, y)) forall2 (f, xs, ys)
          else false
        | _ => raise Invalid_argument("List.forall2")
      }
    }

    'a forall (f : 'a -> bool, l : list ('a)) : bool {
      match (l) {
        | Cons (x, xs) =>
          if (f (x)) forall (f, xs)
          else false
        | Nil => true
      }
    }

    'a filter (f : 'a -> bool, l : list ('a)) : list ('a) {
      match (l) {
        | Cons (x, xs) =>
          if (f (x)) Cons (x, filter (f, xs))
          else filter (f, xs)
        | Nil => Nil ()
      }
    }

    'a cons (e1 : 'a) : list ('a) {
      Cons (e1, Nil ())
    }
      
    'a cons (e1 : 'a, e2 : 'a) : list ('a) {
      Cons (e1, cons (e2))
    }
      
    'a cons (e1 : 'a, e2 : 'a, e3 : 'a) : list ('a) {
      Cons (e1, cons (e2, e3))
    }

    'a rev (l : list ('a)) : list ('a) {
      def loop (acc : list ('a), l : list ('a)) : list ('a) {
        match (l) {
          | Cons (x, xs) => loop (Cons (x, acc), xs)
          | Nil => acc
        }
      }
      loop (Nil (), l);
    }

    'a concat (l : list (list ('a))) : list ('a) {
      fold_left(append, Nil(), rev(l))
    }
  }

open Listtest;

module M {
  Main () : void {
    def l = ["foo"; "bar"; "baz"];
    mutable acc <- ":" ;
    def prt (s : string) : void {
        acc <- acc + ":" + s;
        print_endline(s) 
    }
    iter (prt, l);
    print_endline (acc);
    def concat (acc : string, s : string) : string { acc + "." + s }
    print_endline (fold_left (concat, "", l))
  }
}

(*
BEGIN-OUTPUT
foo
bar
baz
::foo:bar:baz
.foo.bar.baz
END-OUTPUT
*)
