\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\kw}[1]{{\textcolor{kwcolor}{\tt #1}}}
\newcommand{\ra}{\texttt{ -> }}

\definecolor{kwcolor}{rgb}{0.2,0.4,0.0}
\definecolor{lgray}{rgb}{0.8,0.8,0.8}

\title{Rekonstrukcja typów z odraczaniem}
\author{Micha{\l} Moskal}
\institute{Instytut Informatyki, Uniwersytet Wroc³awski}
\date{Forum Informatyki Teoretycznej, \\ Karpacz, 16 kwietnia 2005}



\begin{document}

\section{Problem}

\frame{
\frametitle{Rekonstrukcja typów}
\begin{itemize}
  \item<+-> opuszczanie adnotacji typowych,
  \item<+-> np. zamiast pisaæ 
    \[ \lambda x : \mathtt{int}.\, x + 42 \]
  \item<+-> piszemy 
    \[ \lambda x.\, x + 42 \]
  \item<+-> a kompilator domy¶la siê typu $x$-a
\end{itemize}
}

\frame{
\frametitle{Rekonstrukcja a ¶wiat zewnêtrzny}
\begin{itemize}
  \item<+-> ale czemu nie s³yszeli o niej w przemy¶le?
  \item<+-> polimorfizm parametryczny
  \item<+-> podtypowanie
  \item<+-> przeci±¿anie (\textit{overloading})
  \begin{itemize}
    \item<+-> w tym operator dostêpu do pola
  \end{itemize}
\end{itemize}
}


\frame{
\frametitle{Kropka}
\begin{itemize}
  \item<+-> rozwa¿my term
    \[ \lambda x.\,x . \mathtt{foo} \]
  \item<+-> mo¿emy nadaæ mu typ
    \[ \forall \alpha,\beta.\,
    \alpha\rightarrow\beta \;\mathbf{where}\;
    \alpha <: \{ \mathtt{foo} : \beta \}
    \]
  \item<+-> to dobry typ, ale nie nie nominalny
  \item<+-> mo¿emy:
    \begin{itemize}
      \item zabroniæ pola $\mathtt{foo}$ w kilku klasach,
      \item pracowaæ na typach strukturalnych
    \end{itemize}
\end{itemize}
}



\section{Rozwi±zanie}

\frame{
\frametitle{Funkcje definiuje siê celem pó¼niejszego u¿ycia}
\begin{itemize}
  \item<+-> tak naprawdê nie chcemy znaæ typu wyra¿enia
    \[ \lambda x.\,x . \mathtt{foo} \]
  \item<+-> interesuje nas wyra¿enie
    \[ \mathtt{List.Map}\; (\lambda x.\,x . \mathtt{foo})\; some\_list \]
  \item<+-> lokalna inferencja typów
\end{itemize}
}


\frame{
\frametitle{Co masz zrobiæ dzi¶, zrób pojutrze!}
\begin{itemize}
  \item<+-> mo¿emy odroczyæ typowanie $x . \mathtt{foo}$ a¿ wiêcej dowiemy siê wiêcej o $x$
  \item<+-> podobnie mo¿emy zrobiæ z przeci±¿onymi wywo³aniami
  \item<+-> ale...
  \item<+-> je¶li to takie proste, to czemu nikt tego wcze¶niej nie robi³?
\end{itemize}
}


\frame{
\frametitle{Znowu k³opoty...}
\begin{itemize}
  \item<+-> wymagamy globalnego rozwi±zywania wiêzów na typach
  \begin{itemize}
  \item<+-> co jest ogólnie uznawane za nieefektywne
  \item<+-> ciê¿ko podaæ dobry komunikat b³êdu
  \end{itemize}
  \item<+-> w trakcie typowania mamy niepe³n± informacjê
  \item<+-> algorytm typowania musi byæ odporny na braki informacji
            i zawsze zak³adaæ, ¿e mo¿e kiedy¶ bêdzie co¶ wiadomo
\end{itemize}
}


\section{Wiêzy na typach}

\frame{
\frametitle{Lokalne i globalne wiêzy}
\begin{itemize}
  \item<+-> wiêzy na typach mo¿emy traktowaæ lokalnie lub globalnie
  \item<+-> mo¿emy je próbowaæ rozwi±zaæ od razu w miejscu wywo³ania funkcji,
            w razie problemów zg³aszaj±c b³±d (lokalnie)
  \item<+-> lub pozbieraæ z ca³ego programu (lub fragmentu, który akurat typujemy)
            i próbowaæ rozwi±zaæ na koniec (globalnie)
  \item<+-> globalne podej¶cie pozwala na zebranie wiêkszej ilo¶ci informacji,
            kompilator jest wiêc bardziej domy¶lny,
  \item<+-> tylko, je¶li co¶ siê nie uda, to sk±d wiedzieæ co to by³o?
\end{itemize}
}


\frame{
\frametitle{Wiêzy on--line}
\begin{itemize}
  \item<+-> my jednak zrobimy co¶ po¶redniego,
  \item<+-> próbujemy z ka¿dego dodanego wiêzu wyci±gn±æ maximum informacji
            od razu,
  \item<+-> zostawiaj±c jednak wszelkie niejasno¶ci na pó¼niej
\end{itemize}
}


\frame{
\frametitle{Graf zmiennych}
\begin{itemize}
  \item<+-> na zmienne wraz z ³±cz±cymi je relacjami podtypowania patrzymy jako na graf
  \item<+-> graf jest przechodnio--domkniêty (je¶li $\alpha <: \beta \;\wedge\;
    \beta<:\gamma$ to $\alpha <: \gamma$)
  \item<+-> ka¿dy wierzcho³ek ma górn± i doln± granicê, która nie jest zmienn±
  \item<+-> mo¿emy o te granice zapytaæ solver
\end{itemize}
}

\frame{
\frametitle{Inne problemy}
\begin{itemize}
  \item<+-> stan solvera musi byæ mo¿liwy do zapamiêtania i odtworzenia
  \item<+-> kilka zmiennych typowych na bajt kodu ¼ród³owego -- solver musi
byæ efektywny
\end{itemize}
}


\section{To jest ju¿ koniec}
\frame{
\frametitle{Podsumowanie}
\begin{itemize}
  \item<+-> typowanie z globalnym rozwi±zywaniem wiêzów wcale nie musi byæ
            nieefektywne 
  \item<+-> nie musi te¿ dawaæ dziwnych komunikatów o b³êdach
  \item<+-> rekonstrukcja typów mo¿e dzia³aæ w niesprzyjaj±cych warunkach
\end{itemize}
}



\end{document}

% vim: language=polish
