/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.IO;

using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Tyinfo;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** This pass operates on [Tyinfo] objects created for
    each type declaration found in source files.  These objects are
    already created, but most fields are empty.  The main function of
    this pass is [Tyinfo.run].  */

public class Tyinfo : Tycon, ITypeModifier {

  enclosing_type : option <Tyinfo>;
  variant_option_parent : Tyinfo;
  id : int;

  public mutable pt_tydecl : PT.Type_decl; // xmldump

  mutable tydecl : Type_decl;
  mutable t_extends : option <Type>;
  mutable t_implements : list <Type>;
  mutable is_module : bool;
  mutable cannot_finalize : bool;
  name : string;
  public env : GlobalEnv;
  loc : Location;
  accessibility : Accessibility;
  mutable attributes : NemerleAttributes;
  mutable custom_attrs : list <PT.Expr>;
  mutable macro_attrs : list <PT.Expr>;  
  mutable contained_types : list <Tyinfo>;
  mutable variant_options : list <Tyinfo>;
  mutable typarms : list <Tyvar.T>;
  public mutable tenv : Tyvar.TEnv;
  mutable additional_decls : list <PT.Class_member>;

  mutable subtypes : SystemMap <int, Tycon * list <Type>>;
  mutable member_map : SystemMap <string, list <IMember>>;
  mutable member_list : list <IMember>;

  mutable type_builder : System.Reflection.Emit.TypeBuilder;
  mutable system_type : System.Type;

  mutable constant_object : option <IField>;
  mutable has_fields : bool;
  
  /**
   * Marker for [Tyinfo.Iter].
   */
  mutable phase : int;
  
  /**
   * Transitive closure of inherited types in this type and its nested types.
   *
   * Used by [Tyinfo.Iter] function.
   */
  mutable iterate_first : list <Tyinfo>;

  mutable is_protected : bool;
  mutable is_public : bool;
  mutable is_internal : bool;
  mutable is_private : bool;

  static mutable infos : list <Tyinfo>;

  static mutable run_phase : int;

  
  /**
   * Return list of type parameters under which we subtype given type.
   *
   * <remarks>
   *   For example if [A ('a) :> B (int)], then ["A".SuperType ("B")]
   *   returns [[int]].
   *
   *   This information can be also fetched from [GetDirectSuperTypes()]
   *   method but this function is transitive.
   * </remarks>
   */
  public SuperType (ti : Tycon) : option <list <Type>>
  {
    match (subtypes.Find (ti.GetId ())) {
      | Some ((_, x)) => Some (x)
      | None =>
        if (ti.GetFullName () == "System.Object")
          Some ([])
        else
          None ()
    }
  }

  /** Return qualified type name. */
  public GetFullName () : string
  {
    env.GetCurrentNamespace () + name
  }

  public GetId () : int
  {
    id
  }

  public IsDelegate () : bool
  {
    false
  }

  public IsValueType () : bool
  {
    false
  }

  public GetHandle () : System.Reflection.MemberInfo
  {
    null
  }

  /** Return type we were defined in (null for toplevel types). */
  public DeclaringType : Tycon {
    get {
      match (enclosing_type) {
        | Some (ti) => ti
        | None => null
      }
    }
  }

  /** Return name without any dots. */  
  public Name : string {
    get { name }
  }

  public MemberType : System.Reflection.MemberTypes {
    get { System.Reflection.MemberTypes.NestedType }
  }
  
  public GetKind () : MemberKind
  {
    MK_type (this)
  }

  public GetAccessibility () : Accessibility
  {
    accessibility
  }

  public GetLibraryReference () : LibraryReference { null }
  
  /**
   * Return list of types that we directly subtype.
   *
   * <remarks>
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   */
  public GetDirectSuperTypes () : list <Type>
  {
    match (t_extends) {
      | Some (t) => t :: t_implements
      | None => t_implements
    }
  }

  public GetConstantObject () : option <IField>
  {
    constant_object
  }

  /** Return type we extend if any. */
  public SuperClass () : option <Tycon>
  {
    match (t_extends) {
      | Some (T_app (ti, _)) => Some (ti)
      | _ => None ()
    }
  }

  /**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * <remarks>
   *   Used mainly with [FreshSubst ()] or [MakeSubst ()].
   * </remarks>
   */
  public GetMemType () : Type
  {
    def make_tv (tv : Tyvar.T) : Type { T_var (tv) };
    T_app (this, List.Map (typarms, make_tv))
  }


  /**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   */
  public FreshSubst () : Subst
  {
    Tyvar.fresh_subst (this.typarms)
  }

  /**
   * Helper used also in ExternalNemerleType.
   */
  internal static ConstructSubst (tc : Tycon, typarms : list <Tyvar.T>,
                                  args : list <Type>) : Subst
  {
    def loop (ini : Subst, parms : list <Tyvar.T>, args : list <Type>) : Subst {
      match ((parms, args)) {
        | (p :: ps, a :: args) =>
          match (a) {
            | T_var (p') =>
              if (p.id == p'.id) ini
              else loop (ini.Add (p.id, TV_exactly (a)), ps, args)
            | _ => loop (ini.Add (p.id, TV_exactly (a)), ps, args)
          }
        | ([], []) => ini
        | _ => Util.ice ()
      }
    };

    def len_tp = List.Length (typarms);
    def len_ac = List.Length (args);

    if (len_tp == len_ac) {
      def sub = loop (SystemMap (), typarms, args);

      def check_constraints (tv : Tyvar.T, t : Type) : void {
        def check_constraint (c : Type) : void {
          unless (t >:> (c /- sub)) {
              Message.error ("typing constraint '" + tv.name +
                             " :> " + c.as_string () + " is not satisfied");
              Message.error ("by " + t.as_string () + " :> " + (c /- sub).as_string ());
              Message.error (tc.GetLocation (), "upon instantiation of " + tc.GetFullName ())
          }
        };
        List.Iter (Tyvar.constraints (tv), check_constraint)
      };
      List.Iter2 (typarms, args, check_constraints);

      sub
    } else {
      Message.error (sprintf ("type `%s' takes %d argument(s) while %d were supplied",
                              tc.GetFullName (), len_tp, len_ac));
      SystemMap ()
    }
  }

  /**
   * Construct substitution resulting from applying this type constructor
   * to specified arguments.
   *
   * <remarks>
   *   For example assuming our type parameters are are ('a, 'b), then
   *   [MakeSubst ([t1, t2])] produces substitution { 'a := t1; 'b := t2 }.
   * </remarks>
   */
  public MakeSubst (args : list <Type>) : Subst
  {
    ConstructSubst (this, typarms, args)
  }

  type Subinfo = SystemMap <int, Tycon * list <Type>>;

  public GetTyconKind () : TyconKind
  {
    TK_NemerleType (this)
  }

  public GetTydecl () : Type_decl
  {
    tydecl
  }

  public SameAs (tc : Tycon) : bool
  {
    tc.GetId () == GetId ()
  }

  public Attributes : NemerleAttributes
  {
    get { attributes }
  }

  public GetCustomAttributes () : list <PT.Expr>
  { custom_attrs }

  public GetMacroAttributes () : list <PT.Expr>
  { macro_attrs }

  public SetCustomAttributes (custom : list <PT.Expr>) : void
  {
    custom_attrs <- custom;
  }

  public SetMacroAttributes (macr : list <PT.Expr>) : void
  {
    macro_attrs <- macr;
  }

  public IsStatic () : bool
  {
    true
  }

  public LookupMember (name : string) : list <IMember>
  {
    match (member_map.Find (name)) {
      | None =>
        match (tydecl) {
          | TD_interface =>
            GlobalEnv.LookupInternalType (["System", "Object"]).LookupMember (name)
          | _ => []
        }
      | Some (mems) => mems
    }
  }

  internal ReverseChildren () : void {
    contained_types <- List.Rev (contained_types);
    variant_options <- List.Rev (variant_options);
  }

  
  /**
   * Iterate over all types defined in source code.
   *
   * <remarks>
   *   Supertypes are always processed before subtypes otherwise
   *   source code order is retained.
   * </remarks>
   */
  public static Iter (f : Tyinfo -> void) : void
  {
    def working_on = Util.next_id ();
    def done = Util.next_id ();
    def maybe_f (ti : Tyinfo) : void {
      if (ti.phase == done) ()
      else if (ti.phase == working_on)
        Message.error(ti.loc, "type definition for `" + ti.GetFullName () + "' is cyclic")
      else {
        ti.phase <- working_on;
        Util.locate (ti.loc, {
          List.Iter (ti.iterate_first, maybe_f);
          f (ti)
        });
        ti.phase <- done
      }
    };

    List.Iter (infos, maybe_f);
  }

  /**
   * Return substitution to apply to types of members of our supertype [ti]
   * to get types of members in [this].
   *
   * <remarks>
   *    For example consider:
   *    [[[
   *      class A ('a) { f : 'a; }
   *      class B : A (int) { }
   *    ]]]
   *    Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
   *    it can be applied to type of [A.f] which is ['a], to obtain type
   *    of [B.f] which is [int].
   * </remarks>
   */
  public SubtypingSubst (tc : Tycon) : Subst
  {
    if (tc.GetId () == GetId ())
      SystemMap () // current type, no substitution
    else
      tc.MakeSubst (Option.UnSome (SuperType (tc)));
  }

  /**
   * Iterate over top level types in source code order.
   */
  public static SourceTopIter (f : Tyinfo -> void) : void
  {
    def wrap (x : Tyinfo) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    List.Iter (infos, wrap);
  }

  /**
   * Iterate over top level types in inheritance order.
   */
  public static TopIter (f : Tyinfo -> void) : void
  {
    def wrap (x : Tyinfo) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    Iter (wrap);
  }

  public this (par : option <Tyinfo>, vop : option <Tyinfo>, 
               env : GlobalEnv, td : PT.Type_decl)
  {
    variant_options <- [];
    contained_types <- [];
    this.enclosing_type <- par;
    match (par) {
      | Some (p) => p.contained_types <- this :: p.contained_types;
      | _ => ()
    };
    this.pt_tydecl <- td;
    this.env <- env;
    this.name <- List.Head (Macros.UnSString (td.name));
    this.loc <- td.loc;
    attributes <- td.modifiers.mods;
    custom_attrs <- td.modifiers.attrs;
    macro_attrs <- td.modifiers.macro_attrs;    

    match (td) {
      | PT.TD_variant_option =>
        match (vop) {
          | Some (ti) =>
            ti.variant_options <- this :: ti.variant_options;
            attributes |= NemerleAttributes.Sealed;
            macro_attrs <- <[ Record ]> :: macro_attrs;
            if (ti.is_public)
              attributes |= NemerleAttributes.Public
            else if (ti.is_internal)
              attributes |= NemerleAttributes.Internal
            else if (ti.is_protected)
              attributes |= NemerleAttributes.Protected
            else if (ti.is_private)
              attributes |= NemerleAttributes.Private
            else ()
          | None => assert (false)
        }
      | PT.TD_variant => macro_attrs <- <[ Record ]> :: macro_attrs;
      | _ => ()
    };

    Passes.tyinfo_counter <- Passes.tyinfo_counter + 1;

    this.id <- Util.next_id ();

    infos <- this :: infos;

    is_public <- NemerleAttributes.Public %&& attributes;
    is_internal <- NemerleAttributes.Internal %&& attributes;
    is_protected <- NemerleAttributes.Protected %&& attributes;
    is_private <- NemerleAttributes.Private %&& attributes;

    unless (is_public || is_internal || is_protected || is_private) {
      match (enclosing_type) {
        | Some =>
          attributes |= NemerleAttributes.Private;
          is_private <- true
        | None =>
          attributes |= NemerleAttributes.Internal;
          is_internal <- true
      }
    };

    if (is_private)
      accessibility <- A_private ()
    else if (is_protected && is_internal)
      accessibility <- A_protected_or_internal ()
    else if (is_protected)
      accessibility <- A_protected ()
    else if (is_internal)
      accessibility <- A_internal ()
    else
      accessibility <- A_public ();

    match ((vop, pt_tydecl)) {
      | (Some (x), PT.TD_variant_option) =>
        variant_option_parent <- x
      | (None, PT.TD_variant_option) => Util.ice ()
      | (Some, _) => Util.ice ()
      | (None, _) => ()
    };

    additional_decls <- [];
  }

  public CanAccess (source : Tycon) : bool
  {
    is_public || 
    (is_internal && 
      match (source.GetTyconKind ()) { 
        | TK_NemerleType => true 
        | _ => false 
      }) || 
    (is_protected &&
        match (enclosing_type) {
          | Some (tc) => Option.IsSome (source.SuperType (tc))
          | None => false
        }) ||
    match (enclosing_type) {
      | Some (declaring_type) =>
        def walk_declaring (tc : Tycon) {
          tc.SameAs (declaring_type) || 
            (tc.DeclaringType != null && walk_declaring (tc.DeclaringType))
        };
        walk_declaring (source)
      | None => false
    }
  }

  /**
   * Construct typing environments for each declaration.
   *
   * <remarks>
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   */
  make_tyenvs (tenv : Tyvar.TEnv) : void
  {
    assert (this.tenv == null);
    def (tenv, tyvars) = tenv.add_typarms (this.env, this.pt_tydecl.typarms,
                                           this, check_parms = false);
    this.tenv <- tenv;
    this.typarms <- tyvars;

    match (pt_tydecl) {
      | PT.TD_variant_option (members) =>
        unless (Util.is_capitalized (List.Head (Macros.UnSString (pt_tydecl.name)))) {
          Message.error (loc, "variant options names must start with capital letters")
        };
        assert (variant_option_parent.tenv != null);
        this.tenv <- variant_option_parent.tenv;
        this.typarms <- variant_option_parent.typarms;
        def make_public (d : PT.Class_member) : void {
          d.modifiers.mods |= NemerleAttributes.Public
        };
        List.Iter (members, make_public)
      | PT.TD_variant =>
        attributes |= NemerleAttributes.Abstract
      | _ => ()
    };

    def bind_child (x : Tyinfo) {
      Util.locate (x.loc, x.make_tyenvs (tenv));
    };
    List.Iter (this.contained_types, bind_child);
  }


  /**
   * Bind type expressions occurring in type declarations. This
   * includes [extends] type, [implements] list, and aliased type
   * in case of type alias declaration.
   *
   * <remarks>
   *   Binding type expression refers to rewriting [Parsetree.Type]
   *   into [Typedtree.Type], which involves resolving names of type
   *   constructors (to [Tyinfo] objects) and type variables (to [Tyvar.T]
   *   objects).
   *   
   *   This function depends on nested types being processed *before*
   *   parent type (so it should only operate on reversed infos list).
   * </remarks>
   */
  bind_types () : void
  {
    def bind (t : PT.Type) : Type {
      this.tenv.bind (this.env, this, t, check_parms = false)
    };
    def td = this.pt_tydecl;
    this.is_module <- NemerleAttributes.Module %&& this.attributes;
    this.tydecl <-
      match (td) {
        | PT.TD_class => TD_class ()
        | PT.TD_alias (t) => TD_alias (bind (t))
        | PT.TD_interface => TD_interface ()
        | PT.TD_delegate => // FIXME
          Util.ice ("no delegate support yet")
        | PT.TD_enum => TD_enum ()
        | PT.TD_variant =>
          TD_variant (List.Map (variant_options, fun (x : Tyinfo) : Tycon { x }))
        | PT.TD_variant_option => TD_variant_option ()
        | PT.TD_macro => Util.ice ("macro shouldn't survive to typing")
      };
      
    match (td) {
      | PT.TD_variant_option =>
        this.t_extends <- Some (variant_option_parent.GetMemType ());
        this.t_implements <- [];
      | _ =>
        match (td.t_extends) {
          | hd :: tl =>
            def is_interface (tc : Tycon) {
              if (tc.GetTydecl () == null)
                match ((tc :> Tyinfo).pt_tydecl) {
                  | PT.TD_interface => true
                  | _ => false
                }
              else
                match (tc.GetTydecl ()) {
                  | TD_interface => true
                  | _ => false
                }
            };
            def hd' = bind (hd);
            match (hd') {
              | T_app (tc, _) when !is_interface (tc) =>
                this.t_extends <- Some (hd'); 
                this.t_implements <- List.Map (tl, bind);
              | _ =>
                this.t_implements <- hd' :: List.Map (tl, bind);
                this.t_extends <- None ()
            }
          | [] =>
            this.t_implements <- [];
            this.t_extends <- None ()
        }
    };

    match (pt_tydecl) {
      | PT.TD_enum => handle_underlying_enum_type ()
      | _ => ()
    };

    match (t_extends) {
      | None =>
        match (pt_tydecl) {
          | PT.TD_interface 
          | PT.TD_alias => ()
          | _ =>
            t_extends <- Some (bind (<[ type: System.Object ]>))
        }
      | Some => ()
    };

    // construct this.iterate_first:
    def iterate_first = Hashtable ();
    def add_tycon (tc : Tycon) {
      when (tc != null) {
        match (tc.GetTyconKind ()) {
          | TK_NemerleType (ti) => iterate_first.Set (ti.GetId (), ti)
          | _ => ()
        }
      }
    };
    def add_type (t : Type) {
      match (t) {
        | T_app (tc, _) => add_tycon (tc)
        | _ => ()
      }
    };
    def add_from (ti : Tyinfo) {
      def is_self (ti : Tycon) {
        if (ti == null) false
        else ti == (this : Tycon) || is_self (ti.DeclaringType)
      };
      def add_not_self (ti : Tyinfo) {
        when (! is_self (ti)) {
          iterate_first.Set (ti.GetId (), ti)
        }
      };
      assert (ti.iterate_first != null);
      List.Iter (ti.iterate_first, add_not_self)
    };
    List.Iter (GetDirectSuperTypes (), add_type);
    List.Iter (this.contained_types, add_from);
    this.iterate_first <- iterate_first.Fold ([], fun (_, ti, acc) { ti :: acc });
  }

  /**
   * Construct datastructures we use to check subtyping relations.
   *
   * <remarks>
   *   This probably the hardest part of processing type declarations.
   *
   *   Each type directly subtypes types it extends or implements.  This
   *   pass computes transitive closure of direct subtyping relation
   *   and stores it [Tyinfo.subtypes] map.  .NET generics doesn't allow
   *   same type to be subtyped under different instantiations, so we
   *   use map from (id of) subtyped Tyinfo object to actual parameters
   *   of subtyped type.
   * </remarks>
   */
  static determine_subtyping () : void
  {
    Iter (fun (ti : Tyinfo) { 
            ti.construct_subtyping_map () 
          });
  }

  construct_subtyping_map () : void
  {
    def add_srs (t, s : Subinfo) {
      match (t) {
        | T_app (ti', args) => add_subtyping_of (s, ti', args)
        | _ =>
          Message.error (loc, "cannot implement nor extend non-class type");
          s
      }
    };
    subtypes <- List.FoldLeft (GetDirectSuperTypes (), SystemMap (), add_srs)
  }

  add_subtyping_of (subinfo : Subinfo, tc : Tycon, args : list <Type>) : Subinfo
  {
    def add_sr (subinfo : Subinfo, subtyped : Tycon, args : list <Type>) {
      match (subinfo.Find (subtyped.GetId ())) {
        | Some ((_, args')) =>
          mutable problem <- "";
          def check_eq (t1 : Type, t2 : Type) : bool {
            if (Tyutil.types_eq (t1, t2)) true
            else {
              problem <- "types " + t1.as_string() + " and " +
                         t2.as_string() + " are not compatible";
              false
            }
          };
          unless (List.ForAll2 (args, args', check_eq)) {
            Message.error ("type `" + subtyped.GetFullName () +
                           "' is implemented by type `" +
                           GetFullName() +
                           "' twice under different instantiations");
            if (tc.GetId () == subtyped.GetId ())
              Message.error ("second one directly")
            else
              Message.error ("second one through `" + tc.GetFullName () + "'");
            Message.error (problem);
          };
          subinfo
        | None =>
          subinfo.Add (subtyped.GetId (), (subtyped, args))
      }
    };

    def sub = tc.MakeSubst (args);

    def add_srt (t, subinfo : Subinfo) {
      match (t) {
        | T_app (tc, args) =>
          add_sr (subinfo, tc, List.Map (args, fun (t) { t /- sub }))
        | _ => Util.ice ("extending non-class type")
      }
    };

    def subinfo = List.FoldLeft (tc.GetSuperTypes (), subinfo, add_srt);
    def subinfo = add_sr (subinfo, tc, args);
    subinfo
  }

  public GetSuperTypes () : list <Type>
  {
    if (subtypes == null) []
    else
      subtypes.Fold (fun (_, x, acc) {
                        def (tc, args) = x;
                        T_app (tc, args) :: acc },
                     [])
  }

  begin_adding_members () : void
  {
    def get_members (t) {
      match (t) {
        | T_app (tc, _) => tc.GetMembers ()
        | _ => []
      }
    };
    def members = 
      match (GetTydecl ()) {
        | TD_interface =>
          List.Concat (List.Map (GetDirectSuperTypes (), get_members))
        | _ =>
          match (t_extends) {
            | Some (t) => get_members (t)
            | None => []
          }
      };
      
    def inherit_it (mem : IMember) {
      !mem.IsStatic () &&
        match (mem.GetKind ()) {
          | MK_method (mem) =>
            match (mem.GetFunKind ()) {
              | FK_ctor => false
              | _ => true
            }
          | MK_field =>
            has_fields <- true;
            true
          | _ => true
        }
    };

    def add (mem : IMember, map : SystemMap <string, list <IMember>>) {
      if (inherit_it (mem)) {
        def n = mem.Name;
        match (map.Find (n)) {
          | Some (l) => map.Replace (n, mem :: l)
          | None => map.Add (n, [mem])
        }
      } else
        map
    };

    member_map <- List.FoldLeft (members, SystemMap (), add);
    member_list <- []
  }

  internal static constrain_member (m : IMember, flags : BindingFlags) : bool
  {
    def is_public = m.Attributes %&& NemerleAttributes.Public;
    // if flag is Public then always return all public members
    flags == BindingFlags.Public && is_public ||
    // if flag is NonPublic then always return all nonpublic members
    flags == BindingFlags.NonPublic && !is_public ||
    // masks
    (!m.IsStatic () || flags %&& BindingFlags.Static) &&
    (m.IsStatic () || flags %&& BindingFlags.Instance) &&
    (!is_public || flags %&& BindingFlags.Public) &&
    (is_public || flags %&& BindingFlags.NonPublic)
  }

  /** Note that [bindingAttr] is used only to check the case for DeclaredOnly
      members, so you have to provide filter function to check other flags */
  private get_members (bindingAttr : BindingFlags, filter : IMember -> bool)
  : list <IMember>
  {
    def maybe_add (m : IMember, acc) {
      if (filter(m)) m :: acc else acc
    };
    def add_few (_, mems, acc) {
      List.FoldLeft (mems, acc, maybe_add)
    };
    if (bindingAttr %&& BindingFlags.DeclaredOnly)
      List.Filter (member_list, filter)
    else
      member_map.Fold (add_few, [])
  }
  
  /** Searches for the members defined for the current TypeInfo, using the specified
      binding constraints.
      <remarks>
        Members include properties, methods, fields, events, and so on.

        The following BindingFlags filter flags can be used to define which members to
        include in the search: 
        <ul>
          <li>
            You must specify either BindingFlags.Instance or BindingFlags.Static in order to
            get a return.
          </li>
          <li>
            Specify BindingFlags.Public to include public members in the search.
          </li>
          <li>
            Specify BindingFlags.NonPublic to include non-public members (that is, private
            and protected members) in the search.
          </li>
        </ul>

        The following BindingFlags modifier flags can be used to change how the search
        works: 

        BindingFlags.DeclaredOnly to search only the members declared on the Type,
        not members that were simply inherited.

        Calling this method with only the Public flag or only the NonPublic flag will
        return the specified members and does not require any other flags.

        See Nemerle.Compiler.BindingFlags for more information.
      </remarks>
   */
  public GetMembers (bindingAttr : BindingFlags) : list <IMember>
  {
    get_members (bindingAttr, fun (m : IMember) {
      constrain_member (m, bindingAttr)
    })
  }
  
  public GetMembers () : list <IMember>
  {
    get_members ((0 :> BindingFlags), fun (_) { true })
  }

  public GetFields (bindingAttr : BindingFlags) : list <IField>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_field => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list <IField>)
  }
    
  public GetFields () : list <IField>
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MK_field => true | _ => false }
    });
    (mems :> list <IField>)
  }


  /** Searches for the methods defined for the current TypeInfo, using the
      specified binding constraints.
  */
  public GetMethods (bindingAttr : BindingFlags) : list <IMethod>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_ctor | FK_static_ctor => false
            | _ => constrain_member (m, bindingAttr)
          }
        | _ => false
      }
    });
    (mems :> list <IMethod>)
  }

  public GetMethods () : list <IMethod>
  {
    GetMethods (BindingFlags.Static %| BindingFlags.Instance %|
                BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the constructors defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetConstructors (bindingAttr : BindingFlags) : list <IMethod>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_ctor | FK_static_ctor =>
              constrain_member (m, bindingAttr)
            | _ => false
          }
        | _ => false
      }
    });
    (mems :> list <IMethod>)
  }

  public GetConstructors () : list <IMethod>
  {
    GetConstructors (BindingFlags.Static %| BindingFlags.Instance %|
                     BindingFlags.Public %| BindingFlags.NonPublic)
  }

  /** Searches for the types defined for the current TypeInfo, using the
      specified BindingFlags.
  */
  public GetNestedTypes (bindingAttr : BindingFlags) : list <Tycon>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_type (t) =>
          constrain_member (t, bindingAttr %| BindingFlags.Static %|
                            BindingFlags.Instance)
        | _ => false
      }
    });
    (mems :> list <Tycon>)
  }

  public GetNestedTypes () : list <Tycon>
  {
    GetNestedTypes (BindingFlags.Static %| BindingFlags.Instance %|
                    BindingFlags.Public %| BindingFlags.NonPublic)
  }

  public GetProperties (bindingAttr : BindingFlags) : list <IProperty>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_property => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list <IProperty>)
  }
    
  public GetProperties () : list <IProperty>
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MK_property => true | _ => false }
    });
    (mems :> list <IProperty>)
  }

  public GetEvents (bindingAttr : BindingFlags) : list <IEvent>
  {
    def mems = get_members (bindingAttr, fun (x : IMember) {
      match (x.GetKind ()) {
        | MK_event => constrain_member (x, bindingAttr)
        | _ => false
      }
    });
    (mems :> list <IEvent>)
  }
    
  public GetEvents () : list <IEvent>
  {
    def mems = get_members ((0 :> BindingFlags), fun (x : IMember) {
      match (x.GetKind ()) { | MK_event => true | _ => false }
    });
    (mems :> list <IEvent>)
  }

  public BindType (t : PT.Type) : Type
  {
    BindType (tenv, t)
  }

  public BindType (other_tenv : Tyvar.TEnv, t : PT.Type) : Type
  {
    other_tenv.bind (env, this, t, check_parms = true)
  }

  public BindTyparms (tp : PT.Typarms) : Tyvar.TEnv * list <Tyvar.T>
  {
    BindTyparms (tenv, tp)
  }

  public BindTyparms (other_tenv : Tyvar.TEnv, tp : PT.Typarms)
  : Tyvar.TEnv * list <Tyvar.T>
  {
    other_tenv.add_typarms (env, tp, this, check_parms = true)
  }

  /** Check if types that are already bound are correctly applied. */
  check_bound_types () : void
  {
    def types =
      match (tydecl) {
        | TD_alias (t) => t :: GetDirectSuperTypes ()
        | _ => GetDirectSuperTypes ()
      };
    def check_type (t) {
      match (t) {
        | T_ref (t) => check_type (t)
        | T_out (t) => check_type (t)
        | T_array (t) => check_type (t)
        | T_fun (ts, t) => check_type (ts); check_type (t)
        | T_void => ()
        | T_prod (ts) => List.Iter (ts, check_type)
        | T_var => ()
        | T_app (ti, args) =>
          List.Iter (args, check_type);
          ignore (ti.MakeSubst (args));
      }
    };
    def do_check_type (t) { 
      Tyutil.CheckAccessibility (accessibility, t);
      check_type (t);
    };
    def check_constraints_in_tv (tv) {
      List.Iter (Tyvar.constraints (tv), do_check_type)
    };
    List.Iter (types, check_type); // no access check here!
    List.Iter (typarms, check_constraints_in_tv);
  }

  describe_member (m : IMember) : string
  {
    def kind =
      match (m.GetKind ()) {
        | MK_field => "a field"
        | MK_method => "a method"
        | MK_property => "a proprty"
        | MK_type => "a type"
        | MK_event => "an event"
      };
    // TODO include method signature
    if (m.DeclaringType == null)
      kind + " `" + m.Name + "'"
    else
      kind + " `" + m.DeclaringType.GetFullName () + "." + m.Name + "'"
  }

  public GetLocation () : Location
  {
    loc
  }

  public BindAndAddMember (class_member : PT.Class_member) : void
  {
    try { 
      ignore (bind_and_add_member (class_member))
    } catch {
      | _ : Recovery => ()
    }
  }
  
  bind_and_add_member (class_member : PT.Class_member) : IMember
  {
    Util.locate (class_member.loc, {
      when (is_module)
        class_member.modifiers.mods |= NemerleAttributes.Static;
      match (tydecl) {
        | TD_interface =>
          class_member.modifiers.mods |= NemerleAttributes.Virtual;
          class_member.modifiers.mods |= NemerleAttributes.Abstract;
        | _ => ()
      };
      match (class_member) {
        | PT.M_enum
        | PT.M_type => null
        | (PT.M_field) as f =>
          def r = (NemerleField (this, f) : IMember);
          AddMember (r);
          r
          
        | (PT.M_function) as f =>
          def r = NemerleMethod (this, f);
          AddMember (r);
          r
          
        | (PT.M_property) as p =>
          def r = NemerleProperty (this, p);
          AddMember (r);
          r
          
        | (PT.M_event) as e =>
          def r = NemerleEvent (this, e);
          AddMember (r);
          r
      }
    })
  }

  public AddMember (mem : IMember) : void
  {
    def replace_method (acc, meth : IMethod, mems) {
      match (mems) {
        | [] =>
          mem :: acc
        | x :: xs =>
          match ((x : IMember).GetKind ()) {
            | MK_method (m) =>
              def sub = SubtypingSubst (m.DeclaringType);
              if (Tyutil.types_eq (m.GetMemType () /- sub, mem.GetMemType ())) {
                match (m.GetFunKind ()) {
                  | _ when m.DeclaringType.SameAs (this) =>
                    Message.error (mem.GetLocation (),
                                   "redefinition of " + describe_member (mem))
                  | FK_ctor | FK_static_ctor => ()
                  | _ when mem.Attributes %&& NemerleAttributes.New => ()
                  | _ when mem.Attributes %&& NemerleAttributes.Override =>
                    unless (x.Attributes %&& NemerleAttributes.Virtual)
                      Message.error ("override specified on " + 
                                     describe_member (mem) + 
                                     ", but no virtual on " + 
                                     describe_member (x)) 
                  | _ =>
                    Message.error (mem.GetLocation (), describe_member (mem) +
                                   " hides " + describe_member (x) +
                                   " but no `new' specified")
                };
                List.RevAppend (xs, mem :: acc)
              } else replace_method (x :: acc, meth, xs)
            | _ => Util.ice ("expecting method, got " + describe_member (x))
          }
      }
    };

    def new_mems =
      match (member_map.Find (mem.Name)) {
        | Some ([]) => Util.ice ()
        | Some ((x :: _) as old) =>
          if (x.DeclaringType.SameAs (this))
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " redefined in `" + GetFullName () + "'");
                Message.error (x.GetLocation (), "  first definition here as " +
                               describe_member (x));
                [mem]
            }
          else
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | _ when mem.Attributes %&& NemerleAttributes.New => [mem]
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " hides " + describe_member (x) +
                               " but no `new' specified");
                [mem]
            }

        | None =>
          when (mem.Attributes %&& (NemerleAttributes.New 
                                    %| NemerleAttributes.Override))
            Message.error ("override and/or new specified on " + 
                           describe_member (mem) + 
                           ", but there is no such member "
                           "in parent to override");
          [mem]
      };

    unless (has_fields) {
      match (mem.GetKind ()) {
        | MK_field => has_fields <- true
        | _ => ()
      }
    };

    member_map <- member_map.Replace (mem.Name, new_mems);
    member_list <- mem :: member_list;
  }

  /** Return list of all members defined in this very type. */
  public GetDirectMembers () : list <IMember>
  {
    member_list
  }

  public GetTypeBuilder () : System.Reflection.Emit.TypeBuilder
  {
    assert (type_builder != null);
    type_builder
  }

  public GetSystemType () : System.Type
  {
    assert (system_type != null);
    system_type
  }
  
  
  public GetVariantOptionParent () : Tyinfo
  {
    assert (variant_option_parent != null);
    variant_option_parent
  }
  
  
  public GetVariantOptions () : list <Tyinfo>
  {
    variant_options
  }

  mutable underlying_enum_type_iface : INumericType;
  mutable underlying_enum_type : Type;
  
  handle_underlying_enum_type () : void
  {
    match (t_extends) {
      | Some (t) =>
        underlying_enum_type <- t;
      | None =>
        underlying_enum_type <- InternalType.Int32;
    };
    
    t_extends <- Some (InternalType.Enum);

    match (t_implements) {
      | [] => ()
      | _ => Message.error ("enum cannot implement anything")
    };

    def oops () {
      Message.error ("`" + underlying_enum_type.as_string () + "' is not valid underlying enum type");
    };

    
    match (Tyutil.top_expand (underlying_enum_type)) {
      | T_app (tc, []) =>
        match (NumericType.ByName (tc.GetFullName ())) {
          | Some (t) when t.IsInteger =>
            underlying_enum_type_iface <- t
          | _ => oops ()
        }
      | _ => oops ()
    }
  }


  add_enum_members (decls : list <PT.Class_member>) : void
  {
    def field_type = PT.T_typed (GetMemType ());
    
    def add_field (ef : PT.Class_member, default_value) {
      def t = underlying_enum_type_iface;      
      def current_value =
        match (ef) {
          | PT.M_enum (Some (lit)) =>
            def val = t.FromLiteral (lit);
            if (val == null) {
              Message.error ("underlying type of enum `" + GetFullName () + 
                             "' is `" + underlying_enum_type.as_string () + 
                             "', so enum literal need to have this type");
              default_value
            } else val
          | PT.M_enum (None) => default_value
          | _ =>
            Message.error ("enums can have only simple members like `A' of `A = 1'");
            default_value
        };
      ef.modifiers.mods |= NemerleAttributes.Public %| NemerleAttributes.Static;
      def field = PT.M_field (ef.loc, ef.name, ef.modifiers, field_type);
      def field = bind_and_add_member (field);
      (field :> NemerleField).enum_value <- current_value;
      t.Binary ("+", current_value, t.One)
    };

    BindAndAddMember (<[ field: public value__ : $(PT.T_typed (underlying_enum_type)); ]>);
    ignore (List.FoldLeft (decls, underlying_enum_type_iface.Zero, add_field));
  }
  

  /**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [Tyinfo.contained_types]) and store
   * them in [Tyinfo.member_map] and [Tyinfo.member_list].
   *
   * <remarks>
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   */
  add_members () : void
  {
    begin_adding_members ();
    def decls =
      match (pt_tydecl) {
        | PT.TD_class (ds)
        | PT.TD_interface (ds)
        | PT.TD_variant (ds)
        | PT.TD_variant_option (ds) => ds
        | PT.TD_enum (ds) =>
          add_enum_members (ds); []
        | _ => []
      };
    List.Iter (decls, BindAndAddMember);
    List.Iter (additional_decls, BindAndAddMember);

    contained_types <- List.Rev (contained_types);
    List.Iter (contained_types, AddMember);
    
    member_list <- List.Rev (member_list);

    // we no longer need it, let GC kill it
    pt_tydecl <- null;
    additional_decls <- null;
  }

  add_constant_object_ctor () : void
  {
    match (member_map.Find (".ctor")) {
      | Some ([ctor]) =>
        def ctor = (ctor :> NemerleMethod);
        def field = PT.M_field (loc = loc, 
                                name = PT.SS_string (PT.Name ("_N_constant_object")), 
                                modifiers = Modifiers (NemerleAttributes.Public %|
                                                       NemerleAttributes.Static, [], []),
                                ty = PT.T_void ());
        def typed_field = NemerleField (this, (field :> PT.M_field));
        typed_field.ty <- variant_option_parent.GetMemType ();
        ctor.attributes <- NemerleAttributes.Private;
        AddMember (typed_field);
        constant_object <- Some ((typed_field : IField));
        
        def fh = PT.Fun_header (loc = loc, 
                                name = PT.SS_string (PT.Name ("this")),
                                ret_type = <[ type: void ]>,
                                parms = []);
        def ttf = typed_field.ty;
        // use typed trees here to avoid problems during actual typing
        def tbody = E_assign (loc, T_void (),
                              E_static_ref (loc, ttf, typed_field), 
                              E_call (loc, ttf, E_static_ref (loc, ctor.GetMemType (), ctor), []));
        def body = <[ { $(tbody : typed) } ]>;
        def static_ctor = PT.M_function (loc = loc, 
                                         name = PT.SS_string (PT.Name ("this")),
                                         modifiers = Modifiers (NemerleAttributes.Static,
                                                                [], []),
                                         header = fh,
                                         kind = FK_ctor (),
                                         body = FB_parsed_expr (body));
        BindAndAddMember (static_ctor);

      | _ => Util.ice ()
    }

  }

  /**
   * Add special methods to variants and variant options. These methods
   * are used to accelerate matching over variants, allowing us to use
   * a single CE_switch statement to identify a variant options instead of 
   * a series of CE_if/CE_has_type instructions.
   *
   * Also add constant fields with single instance of parameter-less 
   * variant options.
   */
  add_special_variant_methods () : void
  {
    constant_object <- None ();

    match (tydecl) {
      | TD_variant_option when !has_fields =>
        add_constant_object_ctor ();
        add_special_variant_methods_aux ()

      | TD_variant
      | TD_variant_option => 
        add_special_variant_methods_aux ()
      
      | _ => ()
    }        
  }
  
  add_special_variant_methods_aux () : void
  {
    match (tydecl) {
      | TD_variant =>           
        Define (<[ method: public abstract virtual
                                 _N_GetVariantCode () : int ; ]>);

      | TD_variant_option =>
        mutable my_index <- 0;
                       
        ignore (List.Find (variant_option_parent.GetVariantOptions (), fun (x) {
          if (x == this) true else { ++my_index; false }
        }));

        Define (<[ method: public virtual _N_GetVariantCode () : int {
                                   $(my_index : int)
                                 } ]>);

      | _ => Util.ice ("add_special_variant_methods: not a variant")
    };
  }

  static this ()
  {
    infos <- [];
  }

  public ConstructTypeBuilder () : void
  {
    when (system_type == null) {
      type_builder <- Passes.cgil.ConstructTypeBuilder (this);
      system_type <- type_builder;
    }
  }

  public FinalizeType () : void
  {
    when (!cannot_finalize && type_builder != null) {
      // we cannot use CreateType() result for attribute
      // builders as it crashes mono
      ignore (type_builder.CreateType ());
      type_builder <- null;
    }
  }

  internal GetTyparms () : list <Tyvar.T>
  {
    typarms
  }

  /** Return interfaces [this] needs to implement (that is it says it will
      implement them, but they are not implemented in base class). */
  public InterfacesToImplement () : list <Tycon> 
  {
    def base_class =
      match (SuperClass ()) {
        | Some (tc) => tc
        | None => GlobalEnv.LookupInternalType (["System", "Object"])
      };

    def collect (t, acc) {
      match (t) {
        | T_app (tc, _) =>
          match (tc.GetTydecl ()) {
            | TD_interface =>
              match (base_class.SuperType (tc)) {
                | Some => acc
                | None => tc :: acc
              }
            | _ => acc
          }
        | _ => acc
      }
    };
    
    List.FoldLeft (GetSuperTypes (), [], collect);
  }

  check_ctor_constraints () : void
  {
    def check_ctors (ty : Tycon) {
      def check_ctor (member : IMember, acc) {
        match (member.GetKind ()) {
          | MK_method (meth) when meth.DeclaringType.SameAs (ty) =>
            match (meth.GetFunKind ()) {
              | FK_ctor =>
                def is_default = List.IsEmpty (meth.GetHeader ().parms);
                match (acc) {
                  | (true, _) => (true, true)
                  | _ => (is_default, true)
                }
              | _ => acc
            }
          | _ => acc
        }
      };

      List.FoldLeft (ty.GetMembers (), (false, false), check_ctor)
    };

    match (t_extends) {
      | Some (T_app (par, _)) =>
        def (_, has_ctor) = check_ctors (this);
        def (par_has_default, par_has_ctor) = check_ctors (par);
        when (!has_ctor && !par_has_default && par_has_ctor)
          Message.error ("the type `" + GetFullName () + 
                         "' has no constructors and the parent type `" + 
                         par.GetFullName () + "' has no default constructor")
      | _ => ()
    }
  }

  check_method_implements () : void
  {
    def collect (mem : IMember, acc) {
      match (mem.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_method => (m :> NemerleMethod) :: acc
            | _ => acc
          }
        | _ => acc
      }
    };
    def methods = List.FoldLeft (this.GetDirectMembers (), [], collect);
    
    // FIXME: in fact we should only mark some methods as implemented and scream
    // when signature match is ambigious
    def iface_methods = Hashtable (30);
    
    def add_iface_methods (tc : Tycon) {
      def add_method (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_iface_method when m.DeclaringType.SameAs (tc) =>
                match (iface_methods.Get (m.Name)) {
                  | Some (lst) => iface_methods.Set (m.Name, m :: lst)
                  | None => iface_methods.Add (m.Name, [m])
                }
              | _ => ()
            }
          | _ => ()
        }
      };
      List.Iter (tc.GetMembers (), add_method)
    };
    List.Iter (InterfacesToImplement (), add_iface_methods);

    def bind_explicit_implements (meth : NemerleMethod) {
      def bind_one (name : PT.Splicable_string) {
        def name = Macros.NameOfSString (name);
        def env = name.GetEnv (this.env);
        def (ns, member) = List.DivideLast (name.idl);
        def ty = env.GetType (ns, this);
        match (iface_methods.Get (member)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              iface_meth.DeclaringType.SameAs (ty) &&
                meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] =>
                Message.fatal_error ("interface `" + ty.GetFullName () + 
                                     "' does not contain method named `" + member + 
                                     "' with proper signature")
              | [m] =>
                iface_methods.Set (member, List.Filter (meths, fun (x) { ! is_correct (x) }));
                m
              | _ =>
                Message.fatal_error ("interface `" + ty.GetFullName () + 
                                     "' contains more then one method named `" + member + 
                                     "' with proper signature")
            }
          | None =>
            Message.fatal_error ("no interface implemented by `" + this.GetFullName () + 
                                 "' contains method named `" + member + 
                                 "' (looking for `" +
                                 Util.qid_of_list (name.idl) + "')")
        }
      };
      match (meth.GetFunKind ()) {
        | FK_method (impl) =>
          def impl' =
            try List.Map (impl, bind_one)
            catch { _ : Recovery => [] };
          meth.fun_kind <- FK_bound_method (impl')
        | _ => ()
      }
    };
    List.Iter (methods, bind_explicit_implements);
    
    def bind_implicit_implements (meth : NemerleMethod) {
      def lookup_iface_members () {
        match (iface_methods.Get (meth.Name)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] => []
              | lst =>
                iface_methods.Set (meth.Name, 
                                   List.Filter (meths, fun (x) { ! is_correct (x) }));
                lst
            }
          | None => []
        }
      };
      match (meth.GetFunKind ()) {
        | FK_bound_method (impl) =>
          match (lookup_iface_members ()) {
            | [] => ()
            | impl' => 
              meth.fun_kind <- FK_bound_method (List.Append (impl', impl));
              meth.attributes |= NemerleAttributes.Virtual;
          }
        | _ => ()
      }
    };
    List.Iter (methods, bind_implicit_implements);

    def scream_about_unimplemented (_, meths) {
      def scream_about (meth : IMethod) {
        Message.error ("unimplemented interface method `" + 
                       meth.DeclaringType.GetFullName () + 
                       "." + meth.Name + "' with signature " +
                       Tyutil.fun_type (meth.GetHeader ()).as_string ())
      };
      List.Iter (meths, scream_about)
    };
    iface_methods.Iter (scream_about_unimplemented);
  }


  process_macro_attributes (stage : int) : void
  {
    def lookup_macro (expr, suff) {
      match (expr) {
        | <[ $(_ : name) ]>
        | <[ $_ . $_ ]> =>
          lookup_macro (<[ $expr () ]>, suff)
        | <[ $name ( .. $parms ) ]> =>
            match (Util.qidl_of_expr (name)) {
              | Some ((id, name)) =>
                def ctx = name.GetEnv (this.env);
                def id =
                  match (List.Rev (id)) {
                    | x :: xs => List.Rev (x + suff :: xs)
                    | [] => assert (false)
                  };
                match (ctx.LookupMacro (id)) {
                  | Some (m) => Some ((name, m, parms))
                  | None => None ()
                };
              | None => None ()
            }
        | _ => None ()
      }
    };

    def process_attributes (self_parm, suff, customs, macros, meth : IMethod) {
      mutable macro_attrs <- macros;
      def new_custom =
        List.Filter (customs, fun (expr) {
          match (lookup_macro (expr, suff)) {
            | None => true
            | Some =>
              macro_attrs <- expr :: macro_attrs;
              false
          }
        });
      List.Iter (macro_attrs, fun (expr) {
        match (lookup_macro (expr, suff)) {
          | None => ()
          | Some ((name, imacro, exprs)) =>
            def meth_header =
              if (meth == null) null else meth.GetHeader ();
            def tenv = 
              if (meth_header == null) this.tenv else meth_header.tenv;
            def in_ctor =
              meth != null && 
                match (meth.GetFunKind ()) {
                  | FK_ctor => true 
                  | _ => false
                };
            def ctx =
              TypingContext (in_ctor = in_ctor,
                             this_ptr_decl = None (),
                             env = this.env,
                             tenv = tenv,
                             current_fun = meth_header,
                             locals = null,
                             parent_type = this,
                             in_tail_position = false);

            TypingContext.PushNewColor (name.color, name.GetEnv (null));
            def parms = 
              List.Append (self_parm, imacro.CallTransform (exprs));
            def res = imacro.Run (ctx, parms);
            TypingContext.PopColor ();

            assert (res == null);
            ()
        }
      });
      (new_custom, macro_attrs)
    };
    def process_attributes_parsed (self_parm, suff, mods : Modifiers, meth : IMethod) {
      def (att, macro_att) = process_attributes (self_parm, suff, mods.attrs,
                                                 mods.macro_attrs, meth);
      mods.attrs <- att;
      mods.macro_attrs <- macro_att;
    };
    def process_attributes_typed (self_parm, suff, mem : IMember, meth : IMethod) {
      def (att, macro_att) = process_attributes (self_parm, suff,
                                                 mem.GetCustomAttributes (),
                                                 mem.GetMacroAttributes (), meth);
      mem.SetCustomAttributes (att);
      mem.SetMacroAttributes (macro_att);      
    };

    def process_member (mem, stage_suff) {
      match (mem) {
        | PT.M_field =>
          process_attributes_parsed ([PT.SyntaxTTycon (this), PT.SyntaxField (mem)],
                                     ":field" + stage_suff, mem.modifiers, null)
        | (PT.M_function) as fn =>
          def (was_parsed, body) =
            match (fn.body) {
              | FB_parsed_expr (b) => (true, b)
              | FB_extern
              | FB_abstract => (false, <[ () ]>)
              | _ => assert (false)
            };
          def decl = PT.Function_decl (fn.header, body);
          process_attributes_parsed ([PT.SyntaxTTycon (this), PT.SyntaxFunDecl (decl)],
                                     ":method" + stage_suff, mem.modifiers, null);
          when (was_parsed) {
            fn.body <- FB_parsed_expr (decl.body);
          };

        | PT.M_enum
        | PT.M_type => ()

        | PT.M_property =>
          process_attributes_parsed ([PT.SyntaxTTycon (this), PT.SyntaxProperty (mem)],
                                     ":property" + stage_suff, mem.modifiers, null)

        | PT.M_event => 
          process_attributes_parsed ([PT.SyntaxTTycon (this), PT.SyntaxEvent (mem)],
                                     ":event" + stage_suff, mem.modifiers, null)
      }
    };

    def iter_decls (stage_suff) {
      def decls =
        match (pt_tydecl) {
          | PT.TD_class (ds)
          | PT.TD_interface (ds)
          | PT.TD_variant (ds)
          | PT.TD_variant_option (ds) => ds
          | _ => []
        };
      def f (x) { process_member (x, stage_suff) };
      List.Iter (decls, f);
      List.Iter (additional_decls, f);
    };

    def process_typed_member (mem : IMember) {
      match (mem.GetKind ()) {
        | MK_field (f) =>
          process_attributes_typed ([PT.SyntaxTTycon (this),
                                      PT.SyntaxTField ((f :> NemerleField))],
                                     ":field:postadd", f, null)
        | MK_method (f) =>
          process_attributes_typed ([PT.SyntaxTTycon (this),
                                      PT.SyntaxTMethod ((f :> NemerleMethod))],
                                     ":method:postadd",  f, f)
                              
        | MK_property (f) =>
          process_attributes_typed ([PT.SyntaxTTycon (this),
                                      PT.SyntaxTProperty ((f :> NemerleProperty))],
                                     ":property:postadd",  f, null)

        | MK_event (f) =>
          process_attributes_typed ([PT.SyntaxTTycon (this),
                                      PT.SyntaxTEvent ((f :> NemerleEvent))],
                                     ":event:postadd",  f, null)

        | MK_type => ()
      }
    };

    match (stage) {
      | 1 =>
        process_attributes_typed ([PT.SyntaxTTycon (this)], ":type:postscan", this, null);
        iter_decls (":postscan");

      | 2 =>
        process_attributes_typed ([PT.SyntaxTTycon (this)], ":type:preadd", this, null);
        iter_decls (":preadd");
        
      | 3 =>
        process_attributes_typed ([PT.SyntaxTTycon (this)], ":type:postadd", this, null);
        List.Iter (GetDirectMembers (), process_typed_member);

      | _ => assert (false)
    }
  }


  /**
   * Main function of type declaration handling pass.
   *
   * <remarks>
   *   - constructing typing environments [Tyinfo.make_tyenvs]
   *   - binding types [Tyinfo.bind_types]
   *   - determining subtyping relations [Tyinfo.determine_subtyping]
   *   - checking subtyping constraints on types that are already bound
   *     [Tyinfo.check_bound_types]
   *   - adding members [Tyinfo.add_members]
   *   - adding the variant/variant option special matching methods
   * </remarks>
   */
  public static Run () : void
  {
    infos <- List.Rev (infos);
    run_phase <- 1;

    List.Iter (infos, fun (x : Tyinfo) {
      Util.locate (x.loc, x.process_macro_attributes (1))
    });

    SourceTopIter (fun (x : Tyinfo) { 
                      x.make_tyenvs (Tyvar.TEnv ()) 
                    });
    def bind_types (x : Tyinfo) {
      Util.locate (x.loc, x.bind_types ())
    };
    
    run_phase <- 2;
    List.Iter (List.Rev (infos), bind_types);

    run_phase <- 3;
    determine_subtyping ();
    
    run_phase <- 4;
    Iter (fun (x : Tyinfo) { x.check_bound_types () });

    run_phase <- 5;
    
    Iter (fun (x : Tyinfo) { x.process_macro_attributes (2) });

    Iter (fun (x : Tyinfo) { x.add_members () });

    Iter (fun (x : Tyinfo) { x.process_macro_attributes (3) });
    
    Iter (fun (x : Tyinfo) { x.add_special_variant_methods () });

    def check_method_implements (ti : Tyinfo) {
      match (ti.GetTydecl ()) {
        | TD_interface => ()
        | _ => ti.check_method_implements ()
      }
    };

    Iter (check_method_implements);

    Iter (fun (x : Tyinfo) { x.check_ctor_constraints () });
  }

  internal FixupDefinedClass () : void
  {
    // finalization is blocked until call to Compile
    this.cannot_finalize <- true;
    this.constant_object <- None ();
    when (run_phase >= 1)
      match (enclosing_type) {
        | Some (ti) =>
          make_tyenvs (ti.tenv)
        | None =>
          make_tyenvs (Tyvar.TEnv ())
      };
    when (run_phase >= 2)
      Util.locate (loc, bind_types ());
    when (run_phase >= 3)
      construct_subtyping_map ();
    when (run_phase >= 4)
      check_bound_types ();
    when (run_phase >= 5)
      begin_adding_members ();
  }


  public AddImplementedInterface (t : PT.Type) : void
  {
    pt_tydecl.t_extends <- List.Append (pt_tydecl.t_extends, [t])
  }
  
  public Define (td : PT.Type_decl) : ITypeModifier
  {
    def name = match (Macros.NameOfSString (td.name).idl) {
      | [x] => x;
      | x :: _ => Message.error ("cannot define nested type with long name"); x
      | _ => assert (false, "Empty name")
    };
    def fullns = env.GetCurrentNamespaceND ().Path (name);
    def tyinfo = Tyinfo (Some (this), None (), env.AddOpenNamespace (fullns), td);
    GlobalEnv.AddType (fullns, tyinfo);
    tyinfo.FixupDefinedClass ();
    match (td) {
      | PT.TD_class (decls) =>
        List.Iter (decls, fun (x : PT.Class_member) { tyinfo.Define (x) });
      | _ => ()
    };
    tyinfo
  }

  public Define (f : PT.Class_member) : void
  {
    if (member_map == null)
      additional_decls <- f :: additional_decls
    else {
      try {
        def mem = bind_and_add_member (f);
        Passes.cgil.MemberAdded (this, mem);
      } catch {
        | _ : Recovery => ()
      }
    }
  }

  
  public Compile () : void
  { 
    cannot_finalize <- false;
    when (type_builder != null) {
      this.FinalizeType ();
      Passes.MarkTyinfoCompiled ();
    }
  }


  /** Nemerle.Reflection  interfaces */
  
}

} // ns
