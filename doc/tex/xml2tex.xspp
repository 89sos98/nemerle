output method = "text"
toplevel { <xsl:preserve-space elements="*" /> }

def quote(str = "", pos = "1", all = "1")
{
  
  if "$pos <= string-length($str)" {
    <xsl:variable name="c">
      v{substring($str, $pos, 1)}
    </xsl:variable>

    choose {
      when "$c = '{'" { "\{" }
      when "$c = '}'" { "\}" }
      when "$all = '1' and $c = '<'" { "$&lt;$" }
      when "$all = '1' and $c = '>'" { "$&gt;$" }
      when "$all = '1' and $c = '|'" { "$|$" }
      when "$c = '&'" { "\&amp;" }
      when "$c = '%'" { "\%" }
      when "$c = '_'" { "\_" }
      when "$c = '#'" { "\#" }
      when "$c = '^'" { "\^" }
      when "$c = '\'" { "$\backslash$" }
      when q{$c = '"'} { "''" }
      else { v{$c} }
    }

    quote(str = v{$str}, pos = v{$pos + 1})
  }
}

def cmd(name = "", p1 = "NONE", p2 = "NONE", p3 = "NONE", p4 = "NONE")
{
  "\" v{$name}
  if "$p1 != 'NONE'" {
    "{" quote(str = v{$p1}) "}"
  }
  if "$p2 != 'NONE'" {
    "{" quote(str = v{$p2}) "}"
  }
  if "$p3 != 'NONE'" {
    "{" quote(str = v{$p3}) "}"
  }
  if "$p4 != 'NONE'" {
    "{" quote(str = v{$p4}) "}"
  }
}

template "text()" {
  if "count(ancestor::verbatim)" {
    quote(str = v{.}, all = "0")
  } else {
    quote(str = v{.})
  }
}

template "parm" {
  "{" apply; "}"
}

template "verbatim" {
  t"\begin{alltt}"
  apply;
  t"\end{alltt}
"
}

template "cmd" {
  "\" v{@name}
  apply select = "parm";
}

template "env" {
  cmd(name = "begin", p1 = v{@name})
t"
"
  apply;
  cmd(name = "end", p1 = v{@name})
t"
"
}

template "br" {
t"
"
}

template "label" {
  cmd(name = "label", p1 = v{translate(., "_-", "..")})
}

template "group" {
  "{" apply; "}"
}

template "tt" {
  "{\tt{" apply; "}}"
}

template "bf" {
  "{\bf{" apply; "}}"
}

template "it" {
  "{\it{" apply; "}}"
}

template "large" {
  "{\large{" apply; "}}"
}

template "Large" {
  "{\Large{" apply; "}}"
}

template "copy" {
  v{.}
}

template "document" {
  apply;
}
