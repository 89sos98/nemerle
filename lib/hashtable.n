/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

namespace SC = System.Collections;
 
namespace Nemerle.Collections 
{
  /**
   * A functional type-safe wrapper for the System.Collections.Hashtable class.   
   */
  public class Hashtable <'a,'b> : IDictionary <'a,'b>
  {
    private hashtable : SC.Hashtable;


    /* -- PUBLIC CONSTRUCTORS ---------------------------------------------- */

    /**
     *
     */
    public this () {
      hashtable <- SC.Hashtable ();
    }

    /**
     *
     */
    public this (capacity : int) {
      hashtable <- SC.Hashtable (capacity);
    }

    /**
     *
     */
    public this (capacity : int, loadFactor : float) {
      hashtable <- SC.Hashtable (capacity, loadFactor);
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */
        
    /**
     * 
     */
    public Get (key : ('a)) : option <'b> implements IDictionary.Item {
      def value = (hashtable [key] :> 'b);
      if (value != null)
        Some (value)
      else
        None ()
    }

    /**
     * This is different from add, which can fail if the key is
     * already in the underlying Framework hashtable...
     */
    public Set (key : ('a), val : ('b)) : void {
      this.hashtable [key] <- val
    }

    /**
     *
     */
    public Add (key : ('a), val : ('b)) : void {
      this.hashtable.Add (key, val);
    }

    /**
     *
     */
    public Clear () : void {
      this.hashtable.Clear ();
    }

    /**
     *
     */
    public Clone () : Hashtable <'a,'b> {
      (this.hashtable.Clone () :> Hashtable <'a,'b>)
    }

    /**
     *
     */
    public Contains (key : ('a)) : bool {
      this.hashtable.Contains (key)
    }

    /**
     *
     */
    public Count () : int {
      this.hashtable.Count
    }

    /**
     *
     */
    public ContainsValue (val : ('b)) : bool {
      this.hashtable.ContainsValue (val)
    }

    /**
     *
     */
    public Remove (key : ('a)) : void {
      this.hashtable.Remove (key)
    }

    /**
     *
     */
    public Fold<'c> (s : 'c, f : ('a * 'b * 'c) -> 'c) : 'c 
    {
      mutable acc <- s;
      foreach (x : SC.DictionaryEntry in hashtable)
        acc <- f ((x.Key :> 'a), (x.Value :> 'b), acc);
      acc
    }

    /**
     *
     */
    public Iter (f : 'a * 'b -> void) : void {
      foreach (x : SC.DictionaryEntry in hashtable)
        f ((x.Key :> 'a), (x.Value :> 'b))
    }

    /**
     * Maps a given function defined of key-value pairs to the contents
     * of this hashtable. A new hashtable object is created, containing
     * the results of the application.
     */
    public Map <'c, 'd> (f : 'a * 'b -> 'c * 'd) : Hashtable <'c,'d>
    {
      def ht = Hashtable ();

      foreach (x : SC.DictionaryEntry in hashtable) {
        def (k, v) = f ((x.Key :> 'a), (x.Value :> 'b));
        ht.Add (k, v)
      };
      ht
    }

    /** 
     * Creates enumerator
     */
    public GetEnumerator() : HashtableEnumerator <'a, 'b>
    //IDictionaryEnumerator<'a,'b>
    {
      HashtableEnumerator(this.hashtable)
    }
  } /* end of class Hashtable ('a,'b) */


  public class HashtableEnumerator<'a,'b>
  //  FIXME: no support for properties in interfaces yet
  //  : IDictionaryEnumerator<'a,'b>
  {
    private mutable enumerator : SC.IDictionaryEnumerator;

    public this(hashtable : SC.Hashtable)
    {
      enumerator <- hashtable.GetEnumerator()
    }

    public Key : 'a
    {
      get { (enumerator.Key :> 'a) }
    }

    public Value : 'b
    { 
      get { (enumerator.Value :> 'b) }
    }

    public Entry : DictionaryEntry<'a,'b>
    {
      get {
        def de = this.enumerator.Entry;
        DictionaryEntry((de.Key :> 'a),(de.Value :> 'b))
      }
    }

    public Current : DictionaryEntry<'a,'b>
    {
      get { Entry }
    }

    public Reset () : void
    {
      (enumerator : SC.IEnumerator).Reset()
    }

    public MoveNext () : bool
    {
      (enumerator : SC.IEnumerator).MoveNext()
    }
  }

} /* end of namespace */

