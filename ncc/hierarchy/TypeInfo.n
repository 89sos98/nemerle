/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

using Nemerle.Collections;

namespace Nemerle.Compiler {

public type MemberTypes = System.Reflection.MemberTypes;
public type BindingFlags = System.Reflection.BindingFlags;
  
public variant MemberKind
{
  | Field { field : IField; }
  | Method { method : IMethod; }
  | Property { prop : IProperty; }
  | Type { tycon : TypeInfo; }
  | Event { body : IEvent; }
}

public enum Accessibility
{
  | Public
  | Internal
  | ProtectedOrInternal
  | ProtectedAndInternal
  | Protected
  | Private
}

public variant BuiltinMethodKind
{
  | NotBuiltin
  | OpCode {
      checked_opcode : string;
      unchecked_opcode : string;
    }
  | CallWithCast {
      meth : IMethod;
    }
  | ValueTypeConversion
}

public interface IMember
{
  GetMemType () : MType;
  GetKind () : MemberKind;
  Location : Location { get; }
  GetId () : int;
  GetHandle () : System.Reflection.MemberInfo;
  CanAccess (source : TypeInfo) : bool;

  /* public properties */
  DeclaringType : TypeInfo {get;}
  Name : string {get;}
  MemberType : MemberTypes {get;}
  IsStatic : bool { get; } // types are always static
  HasBeenUsed : bool { get; set; } // for the 'unused' warnings
  
  Attributes : NemerleAttributes { get; }
  
  /* public methods */
  GetModifiers () : Modifiers;

  /* Return name that is unique for given member/overload, that is 
     name for fields, name/argument types for methods etc */
  OverloadName : string { get; }
}

public interface IField : IMember
{
  IsMutable : bool { get; }
  IsVolatile : bool { get; }
  IsLiteral : bool { get; }
  GetValue () : object;
  GetFieldInfo () : System.Reflection.FieldInfo;
}

public interface IEvent : IMember
{
  GetEventInfo () : System.Reflection.EventInfo;
  GetAdder () : IMethod;
  GetRemover () : IMethod;
}

public interface IMethod : IMember
{
  GetFreshType () : MType;
  GetHeader () : Fun_header;
  GetFunKind () : FunKind;
  GetMethodBase () : System.Reflection.MethodBase;
  GetMethodInfo () : System.Reflection.MethodInfo;
  GetConstructorInfo () : System.Reflection.ConstructorInfo;
  IsVarArgs : bool { get; }
  IsFinal : bool { get; }  
  BuiltinKind : BuiltinMethodKind { get; }

  /// Obtains list of parameters of typed method
  GetParameters () : list [Fun_parm];

  /// Obtain return type of typed method. If it is already inferred/fixed
  /// the value is one of MType variant options.
  ReturnType : TyVar { get; }
}

public interface IProperty : IMember
{
  IsIndexer : bool { get; }
  IsMutable : bool { get; }
  GetPropertyInfo () : System.Reflection.PropertyInfo;
  GetGetter () : IMethod;
  GetSetter () : IMethod;
}

public abstract class TypeInfo : IMember, 
                                 Nemerle.IComparable [TypeInfo]
{
  protected mutable system_type : System.Type;
  id : int;
  protected mutable default_indexer : option [string];
  protected internal mutable typarms : list [StaticTyVar] = [];
  protected mutable self_type : MType.Class;  // memoized by GetMemType ()

  protected namespace_nd : GlobalEnv.NamespaceND;
  
  public this (ns_node : GlobalEnv.NamespaceND)
  {
    id = Util.next_id ();
    namespace_nd = ns_node;
  }

  public NamespaceNode : GlobalEnv.NamespaceND
  {
    get { namespace_nd }
  }          
  
  #region Builtins
  protected mutable special_members : Hashtable [string, list [IMember]];
  protected MakeSingleParm (name : string) : void
  {
    match (special_members [name]) {
      | [elem is IMethod] =>
        def hd = elem.GetHeader ();
        hd.parms = List.Tl (hd.parms);
      | _ => assert (false)
    }
  }

  protected FixupCompare (name : string) : void
  {
    match (special_members [name]) {
      | [elem is IMethod] =>
        def hd = elem.GetHeader ();
        assert (InternalType.Boolean != null);
        hd.ret_type = InternalType.Boolean;
      | _ => assert (false)
    }
  }

  protected AddConversion (name : string, target : TypeInfo) : void
  {
    AddConversion (name, target, reverse = false)
  }
  
  protected AddConversion (name : string, target : TypeInfo, reverse : bool) : void
  {
    def sm = BuiltinMethod (this, name, 
                            GetMemType (), 
                            BuiltinMethodKind.ValueTypeConversion ());
    special_members [name] =
      if (special_members.Contains (name))
        sm :: special_members [name]
      else [sm];

    def hd = sm.GetHeader ();
    hd.parms = List.Tl (hd.parms);
    
    if (reverse) {
      List.Hd (hd.parms).ty = MType.Class (target, []);
      hd.ret_type = MType.Class (this, []);
    } else {
      hd.ret_type = MType.Class (target, []);
    }
  }

  protected AddBuiltin (name : string, opcode : string) : void
  {
    def sm = BuiltinMethod (this, name, 
                            GetMemType (), 
                            BuiltinMethodKind.OpCode (opcode, opcode));
    special_members [name] = [sm : IMember];
  }

  protected AddBuiltin (name : string, op1 : string, op2 : string) : void
  {
    def sm = BuiltinMethod (this, name, 
                            GetMemType (), 
                            BuiltinMethodKind.OpCode (op1, op2));
    special_members [name] = [sm : IMember];
  }

  protected AddBuiltin (name : string, meth : IMethod) : void
  {
    def sm = BuiltinMethod (this, name, 
                            GetMemType (), 
                            BuiltinMethodKind.CallWithCast (meth));
    special_members [name] = [sm : IMember];
  }

  protected InitBuiltinMembers () : void
  {
    when (special_members == null) {
      special_members = Hashtable ();
      if (IsValueType)
        match (SuperClass ()) {
          | Some (tc) when 
              // InternalType is not initialized sometimes
              (InternalType.Enum_tc != null && tc.Equals (InternalType.Enum_tc)) ||
              tc.FullName == "System.Enum" =>
            AddBuiltin ("op_BitwiseOr", "|.u");
            AddBuiltin ("op_BitwiseAnd", "&.u");
            AddBuiltin ("op_ExclusiveOr", "^.u");

            AddBuiltin ("op_UnaryBitwiseNot", "unary.~.u");
            MakeSingleParm ("op_UnaryBitwiseNot");

            AddBuiltin ("op_Equality", "==");
            AddBuiltin ("op_Inequality", "!=");
            FixupCompare ("op_Equality");
            FixupCompare ("op_Inequality");
            
            def numeric_types =
              ["SByte", "Int16", "Int32", "Int64", "Byte", "UInt16", "UInt32", 
               "UInt64"];

            foreach (target in numeric_types) {
              def t = GlobalEnv.LookupInternalType (["System", target]);
              AddConversion ("op_Explicit", t, reverse = true);
              AddConversion ("op_Explicit", t, reverse = false);
            }
            
          | _ => {}
        }
      else if (IsDelegate) {
        assert (InternalType.Delegate_Combine != null);
        assert (InternalType.Delegate_Remove != null);
        AddBuiltin ("op_Addition", InternalType.Delegate_Combine);
        AddBuiltin ("op_Subtraction", InternalType.Delegate_Remove);
      } else {}
    }
  }
  #endregion
  
  public GetHandle () : System.Reflection.MemberInfo
  { system_type }

  public GetId () : int
  { id }

  /** Compare types for equality. */
  public Equals (the_other : TypeInfo) : bool
  { id == the_other.id }

  [Nemerle.OverrideObjectEquals]
  public Equals (t : IMember) : bool
  {
    id == t.GetId ()
  }

  public CompareTo (other : TypeInfo) : int
  {
    id - other.id
  }

  public override ToString () : string
  {
    FullName
  }

  /** Returns custom attribute targets valid for this custom attribute.

     Valid only for type representing custom attribute.
   */
  public abstract AttributeTargets : System.AttributeTargets
  {
    get;
  }
  
  public GetKind () : MemberKind
  {
    MemberKind.Type (this)
  }

  public abstract IsSealed : bool
  { get; }
  
  /** Types are always static */
  public IsStatic : bool
  {
    get { true }
  }

  /** Specifies if given type is an interface */
  public abstract IsInterface : bool
  {
    get;
  }
  
  /* Return name that is unique for given member/overload, that is 
     name for fields, name/argument types for methods etc */
  public OverloadName : string
  {
    get { Name }
  }

  internal virtual GetLibraryReference () : LibraryReference { null }

  public DefaultIndexerName : option [string]
  {
    get {
      when (default_indexer == null)
        match (SuperClass ()) {
          | Some (tc) =>
            default_indexer = tc.DefaultIndexerName;

          | None => default_indexer = None ()
        };
      default_indexer        
    }
  }

  public GetSystemType () : System.Type
  {
    system_type
  }
  
  /** Return full qualified type name with namespaces and nesting types,
      all .-separated.
   */
  public abstract FullName : string { get; }
  

  /** Return full qualified type name with namespaces (.-separated) and
      nesting types (+-separated).
   */
  public FrameworkTypeName : string
  {
    get {
      def par = DeclaringType;
      if (par == null)
        FullName
      else
        par.FrameworkTypeName + "+" + Name
    }
  }

  public abstract LookupMemberImpl (name : string) : list [IMember];

  
  /** Look for specified member. 

      Semantics of returning base class member is the same as for 
      [System.Type.GetMember] method.
   */
  public LookupMember (name : string) : list [IMember]
  {
    when (special_members == null)
      InitBuiltinMembers ();

    if (special_members.Contains (name))
      special_members [name]
    else
      LookupMemberImpl (name)
  }

  /** */
  public abstract GetTydecl () : TypeDeclaration;

  /** Construct substitution resulting from applying this type constructor
      to specified arguments.
      
      For example assuming our type parameters are are ('a, 'b), then
      [MakeSubst (t1, t2)] produces substitution { 'a := t1; 'b := t2 }.
   */
  internal MakeSubst (parms : list [TyVar]) : Subst
  {
    TypeBuilder.ConstructSubst (this, typarms, parms, check_parms = true)
  }
  
  internal MakeSubst1 (parms : list [MType]) : Subst
  {
    MakeSubst (Solver.MonoTypes (parms))
  }

  /**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   */
  internal FreshSubst () : Subst
  {
    Subst.Fresh (Passes.Solver, typarms)
  }

  public virtual GetFreshType () : MType
  {
    FreshSubst ().MonoApply (GetMemType ())
  }

  /** If this tycon subtypes [tycon], then return instantiation using
      which we subtype it.
   */
  public abstract SuperType (tycon : TypeInfo) : option [list [MType]];

  /** */
  internal abstract SubtypingSubst (tycon : TypeInfo) : Subst;

  public abstract SuperClass () : option [TypeInfo];

  /** Gets the direct base type of this type. Null if there isn't any
      (e.g. for interfaces) */
  public abstract BaseType : TypeInfo
  { get;  }

  /** Return list of all members defined in this very type and its
      supertypes. */
  public abstract GetMembers () : list [IMember];

  /** Searches for the members defined for the current TypeInfo, using the
      specified binding constraints. */
  public abstract GetMembers (bindingAttr : BindingFlags) : list [IMember];

  /** Searches for the fields defined for the current TypeInfo, using the
      specified binding constraints. */
  public abstract GetFields (bindingAttr : BindingFlags) : list [IField];

  public abstract GetConstructors (bindingAttr : BindingFlags) : list [IMethod];

  /** */
  public abstract GetSuperTypes () : list [MType.Class];

  public abstract GetDirectSuperTypes () : list [MType.Class];

  /** If this is a constant variant option, this method returns static
      class member that shall be used instead of calling constructor.
      Otherwise [null] is returned. */
  public abstract GetConstantObject () : IField;

  public abstract IsDelegate : bool { get; }

  public virtual IsEnum : bool
  {
    get {
      assert (InternalType.Enum_tc != null);

      IsValueType &&
      match (SuperClass ()) {
        | Some (tc) => tc.Equals (InternalType.Enum_tc)
        | None => false
      }
    }
  }

  public abstract Accessibility : Accessibility { get; }

  /**
   * True if the type will be accessible from an external assembly.
   * This depends on this type's and parent types' accessibility.
   */
  public abstract IsExternallyAccessible : bool { get; }
  
  /** If this is constructor of value type (which is allocated on stack not on heap) */
  public abstract IsValueType : bool { get;}
  
  public abstract HasAttribute (attribute : TypeInfo) : bool;

  /**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * Used mainly with [FreshSubst ()] or [MakeSubst ()].
   */
  public GetMemType () : MType.Class
  {
    assert (self_type != null, FullName);
    self_type
  }
  
  public abstract Location : Location { get; }
  public abstract CanAccess (source : TypeInfo) : bool;

  internal virtual IsNemerleSpecific : bool {
    get { throw System.InvalidOperationException ("external types should not be queried about nemerle specifics"); }
    set { 
      ignore (value); 
      throw System.InvalidOperationException ("external types should not be queried about nemerle specifics");
    }
  }

  /* public methods */
  public abstract GetModifiers () : Modifiers;

  /* public properties */
  public abstract DeclaringType : TypeInfo {get;}
  public abstract Name : string {get;}
  public abstract MemberType : MemberTypes {get;}
  public abstract HasBeenUsed : bool { get; set; } // for the 'unused' warnings
  public abstract Attributes : NemerleAttributes { get; }
  public abstract UnderlyingType : TypeInfo { get; }
}

} // ns
