<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Translation from Abstract-Nem to Term Rewriting System</title>
  <section id="motivation">
    <title>Motivation</title>
    <body>
        <p>
	  Writing large and error free programs is a difficult task. High level
	  programming languages eliminate a lot of bugs that appear while 
	  programming in lower level languages, but still do not guarantee
	  that written programs will be correct. Still in certain aspects it
	  is essential to be certain that the program is error free. Such
	  situations appear nowadays more often as human live and health as
	  well as large scale economy depend on computer programs.
	</p>
        <p>
	  The only way to be certain that a given program correctly fulfills
	  ceriain requirements is to specify the requirements in a formal
	  language and give a formal proof of correctnes. To do this we need
	  a language for describing requirements and we need to represent
	  programs and such requirements in a way suitable for constructing
	  proofs.
	</p>
    	<p>
	  Systems of term rewriting rules are a good representation of programs
	  for reasoning about them using mathematical induction.
 	  There are many methds and programs that facilitate automated
	  reasoning about term rewriting systems, one of the most often used is
	  <a ref="http://www.cl.cam.ac.uk/Research/HVG/Isabelle">
	  Isabelle</a>.
	</p>
        <p>
	  We allow programmers to specify program properties, assumtions and
	  hypotheses in Nemerle language. Later we translate programs and such
	  property specifications to systems of term rewriting rules. We make
	  it possible to automated reasoning on these systems and to translate
	  new constructed hypotheses, properties and types back to Nemerle.
	</p>
    </body>
  </section>
  <section id="trs">
    <title>Term Rewriting Systems</title>
    <body>
        <p>
	  A term rewriting system is a set of term rewrite rules, where one
	  term, e.g. +( 5, 7 ) rewrites to another, e.g. 12. Still we can
	  consider a few kinds of term rewriting and there are a few more
	  delicate issues.
	</p>
        <p>
	  First of all, there is a signature, a set of symbols that are used in
	  the terms. It should be clear, that it is enough to use one binary
	  symbol and one constant symbol to express any term rewriting
	  system, but we will allow arbitrary names for function symbols and
	  constants. We will also allow arbitrary arity of function symbols and
	  that will be used to represent arrays together with the operator that
	  selects i'th element from an array.
	</p>
        <p>
	  Another point to consider is the use of variables. Usually term
	  rewriting rules are written as pairs of terms with variables and the
	  rewriting rules are separate from the term that is rewritten. But
	  it is possible to use special constant terms to denote variables
	  and to write rewrite rules with functions. For example, we normally
	  write f( x1 ), but we could write f( var( 1 ), code for f ) and
	  therefore eliminate variables and have function code in the same
	  place as data. In such form the term rewriting systems is often
	  called a system of combinators. We will operate on usuall term
	  rewriting systems, but if it is nicessary we will provide a
	  translation to combinbators using a set of combinators to define
	  rewriting as a basic set of combinators.
	</p>
        <p>
	  One of the problems in translating imperative programming languages
	  to functional programming languages and to term rewriting systems are
	  pointers. When a function takes a pointer as an argument it might
	  change the pointer, so in term rewriting systems it also has to
	  return this argument. This is not a problem, but it has to be
	  considered when computational complexity is taken into acount.
	  Rewriting rule that rewrites f( x, y ) to g( y, x ) takes a constant
	  time to evaluate, since only pointers to x and y are copied, but when
	  rewriting f( x, y ) to g( x, x ) the time necessary to evaluate this
	  rule is equal the size of x plus constant, since x has to be copied.
	  Another problems are compound types with pointers. In fact such
	  objects are graphs and can be represented using any graph
	  representation, for example arrays. The prefered representation
	  depends on the structure used to represent terms. For example it is
	  easy to represent graphs when we use graph representation for terms,
	  it can also be easily represented as acyclic graphs with arrays when
	  cycles appear (when representing terms as directed acyclic graphs, 
	  i.e. dags). Here we will assume the minimal representation of terms
	  as trees and we will reduce all structures with pointers to graphs
	  represented as arrays.
	</p>
        <p>
	  As far as types are concerned we have dynamic typing in tha language
	  and one could think that types should be represented in term
	  rewriting rules. This is indeed possible since we could have types
	  with the functions that are rewritten, e.g. 
	  +( 5( int ), 7( int ), int to int ) instead of +( 5, 7 ). In this way
	  it is also possible to use polymorhic types. But although it is
	  possible to use dynamic typing in Nemerle, the functions that are
	  analyzed have clearly defined static polymorphic types, since it is
	  possible to generate functions for certain given types from functions
	  defined dynamically. Therefore type information is kept separate from
	  the rewriting rules and is not being rewritten.
	</p>
        <p>
	  One can think that the representation we use here for terms and term
	  rewriting systems is the usual one. In some cases it might be better
	  to use another representation, e.g. think about dag combinators
	  over a simple signature instead of term rewriting over an arbitrary
	  signature. Still the representation we use is more easily readable
	  and it is possible to translate it to any other representation when
	  necessary.
	</p>
    </body>
  </section>
  <section id="props">
    <title>Describing Properties of Programs</title>
    <body>
        <p>
	  The main goal of translating Nemerle programs to term rewriting
	  systems is to create proofs of certain properties of programs.
	  Therefore it is necessary to represent program properties in Nemerle.
	  We use the simplest method to represent such properties: we write
	  that certain boolean function is always true in the given place in
	  the program. Although this is similar to writing assertions in C
	  the major difference is that the property will be checked formally
	  and statically, not evaluated at run time.
	</p>
        <p>
	  In general this method of writing properties is simple and efficient,
	  but perhaps we will also use a standard method to write proofs of
	  properties and add some syntactic suggar to make it easier.
	</p>
        <p>
	  The problem that we have to face is that when reasoning about
	  programs, automated reasoning tools will construct new properties of
	  programs, perhaps even new functions and types. Since we want the
	  programmer to work on top of Nemerle without knowing about term
	  rewriting representation, we need a nice method to translate term
	  rewriting rules back to Nemerle code in such a way that will be
	  readable for the programmer. This will certainly be worked on more
	  later.
	</p>
    </body>
  </section>
  <section id="general-issues">
    <title>General Translation Issues</title>
    <body>
        <p>
	  Here we will describe in general the problems that appear when
	  translating Abstract Nemerle to Term Rewriting Systems.
	</p>
        <p>
	  One issue that we have to deal with are pointers. As we already
	  mentioned, functions taking pointers as arguments will have 
	  additional return values and will return the objects after changes.
	  It is important that the time complexity of a rewrite rule depends
	  on the number occurrences of variables on the right side that occur
	  more than on the left side.
	  Structures with pointers will be represented as graphs using array
	  representation.
	</p>
        <p>
	  When dealing with variables we will simply add an array of all
	  varibles declared in current environment to the function. Therefore
	  "let x = y" simply adds a new varaible named "x" to the environment
	  and with value "y".
	</p>
        <p>
	  Sequential operation will be indexed by an integer index. Therefore
	  "f = { A ; B ; C ; }" will be translated to rewrite rules in the form
	  f( x ) to f( x, 0 ) to f( A, 1 ) to f( B, 2 ) to f( C , 3 ).
	</p>
    </body>
  </section>
  <section id="tools">
    <title>Program Analysis and Reasoning Tools</title>
    <body>
      One of the goals of translating programs to Term Rewriting systems is to
      create formal tools to operate on the programs. When a program is viewed
      as a set of term rewriting rules then it is possible to reason about it
      quite easily and it is possible to use statistical and logical methods to
      analyse and optimize it. We have not designed any specific tools yet, but
      we will present a set of methods that operate on terms and that can be
      used to analyse and reason about programs.
    </body>
      <subsection id="startSetting">
      <title>Description of the System we Analyse</title>
        <body>
	 <p>
	  We will work with a system that consists of the following elements:
         </p>
	  <ul>
	  <li>Lists of term rewriting rules that define functions
	  </li>
	  <li>Term signatures that define polymorphic types
	  </li>
	  <li>Properties of functions described as functions returning boolean
	      values. f(x,y) is interpreted as "for all x, y f(x,y) = true".
	  </li>
	  <li>Function search statements described as the previous but with
	      existential variables (denoted upper case). f(x,y,X(y)) is
	      interpreted as "find such X that f(x,y,X(y))".
	  </li>
	  <li>Reasoning rules that are in fact properties of some special
	      functions and that generate new objects in our system or change
	      the status of an object (e.g. from hypothesis to theorem).
	  </li>
	  <li>Heuristics that are a special set of functions used to guide the
	      application of reasoning rules on the system.
	  </li>
	  </ul>
         <p>
	  Function of some of the elements should be clear and some things will
	  be clarified later. This is a very general setting and very often
	  specific elements of this system will be used, but we find it
	  conveniant to define the system in a general way.
	 </p>
	</body>
      </subsection>
      <subsection id="logicMth">
      <title>Logical Methods</title>
        <body>
	 <p>
	  The following operations should be performed by reasoning rules
	  acting on the system:
         </p>
	  <ul>
	  <li>Simplification: x=y and T(x) impiles T(y)
	  </li>
	  <li>Definition of new functions by composition
	  </li>
	  <li>Definition of new property by composition
	  </li>
	  <li>Definition of new type by choosing a set of function symbols and
	      constants with appropriate type
	  </li>
	  <li>Definition of a new reasoning rule from a proved theorem
	  </li>
	  <li>Definition of new search geenralizing from a set of properties
	  </li>
	  <li>Substitution of an existential variable possibly creating new
	      existential variables.
	  </li>
	  <li>Application of a reasoning rule, heuristic or funciton
	  </li>
	  <li>Induction on type structure
	  </li>
	  </ul>
         <p>
	  Of course this is only a simple and general list of what can be done
	  and more complete and accurate for given tasks will be created.
	 </p>
	</body>
      </subsection>
      <subsection id="heuristicMth">
      <title>Statistical Methods and Heuristics</title>
        <body>
	 <p>
	  One of the main problems with reasoning about programs is to create
	  appropriate heuristic to guide the general reasoning rules.
	  In simple cases statistical methods can be used, in more difficult
	  cases it is necessary to use also logical methods.
	  An examples of such combination is randomly testing (statistical) a
	  program on every possible execution path up to some depth (logical),
	  that is a promising method of automated testing similar to things
	  already implemented for Haskell.
	 </p>
	</body>
      </subsection>
  </section>
</document>
