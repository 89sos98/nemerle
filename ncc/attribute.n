/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
using Nemerle.Collections;
using Nemerle.Utility;

namespace PT = Nemerle.Compiler.Parsetree;
namespace SR = System.Reflection;
using Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler 
{
  module AttributeCompiler
  {

    compile_expr (ti : TypeBuilder, allow_rec : bool, expr : PT.Expr) : object * Type
    {
      def expr = ConstantFolder.FoldConstants (ti.env, expr);

      match (expr) {
        | <[ $(x : string) ]> => ((x : object), InternalType.String)
        | <[ $(x : bool) ]> => ((x : object), InternalType.Boolean)
        | <[ $(x : char) ]> => ((x : object), InternalType.Char)
        | PT.E_literal (L_enum (lval, ty)) =>
          def (val, _) = compile_expr (ti, allow_rec, PT.E_literal (lval));
          (val, T_app (ty, []))
        | <[ null ]> => (null, InternalType.Object)
        | PT.E_literal (lit) =>
          match (NumericType.ByLiteral (lit)) {
            | Some (t) => 
              (t.FromLiteral (lit), t.GetNemerleType ())
            | None => assert (false)
          }
        | <[ typeof ($t) ]> =>
          match (ti.BindType (t)) {
            | T_app (tc, []) =>
              (tc.GetSystemType (), InternalType.Type)
            | _ =>
              def bld = System.Text.StringBuilder ("");
              Macros.SprintType (t, bld);
              Message.fatal_error ("complex type expressions are not allowed in"
                                   " attributes: " + bld.ToString ())
          }

        | <[ array [ .. $elems ] ]> when allow_rec =>
          def exprs = List.Map (elems, fun (e) { compile_expr (ti, false, e) });
          def array_tc =
            List.FoldLeft (exprs, InternalType.Object_tc, fun (et, curty) {
              match (et) {
                | (_, T_app (tc, _)) when tc.SameAs (InternalType.Object_tc) => tc
                | _ => curty
              }
            });
          def allow_null = 
            array_tc.SameAs (InternalType.String_tc) ||
            array_tc.SameAs (InternalType.Type_tc);
          def objects =
            List.Map (exprs, fun (_) {
              | (e, T_app (tc, _)) when tc.SameAs (array_tc) => e
              | (x, _) when allow_null && x == null => null
              | (_, t) =>
                Message.fatal_error ("custom attribute array shall have type " + 
                                     array_tc.GetFullName () + 
                                     " while the element has type " +
                                     t.as_string ())
            });
          
          // FIXME: this seems wrong, what if there are two mscorlibs?
          def arr = NArray.FromList (array_tc.GetSystemType (), objects);
          (arr, T_array (T_app (array_tc, []), 1))

        | _ =>
          Message.fatal_error ("complex expressions are not allowed in attributes")
      }
    }


    do_compile (ti : TypeBuilder, attr : Tycon, parms : list <PT.Expr>) 
        : SR.Emit.CustomAttributeBuilder
    {
      when (Option.IsNone (attr.SuperType (InternalType.Attribute_tc)))
        Message.fatal_error ("`" + attr.GetFullName () + 
                             "' is not an attribute class");

      mutable ctor_parm_types = [];
      mutable ctor_parms = [];
      mutable field_infos = [];
      mutable fields = [];
      mutable property_infos = [];
      mutable properties = [];
      
      def compile_parm (parm : PT.Expr) {
        | <[ $(n : name) = $expr ]> =>
          def name = n.GetHead ();
          def (obj, ty) = compile_expr (ti, true, expr);
          def problem () {
            Message.fatal_error ("the type " + attr.GetFullName () + 
                                 " has no field nor property named `" + name + "'")
          };
          def (is_prop, mem) =
            match (attr.LookupMember (name)) {
              | [mem] =>
                match (mem.GetKind ()) {
                  | MK_field => (false, mem)
                  | MK_property => (true, mem)
                  | _ => problem ()
                }
              | _ => problem ()
            };
          def handle = mem.GetHandle ();
          assert (handle != null);
          if (Tyutil.types_eq (mem.GetMemType (), ty))
            if (is_prop) {
              property_infos = (handle :> SR.PropertyInfo) :: property_infos;
              properties = obj :: properties;
            } else {
              field_infos = (handle :> SR.FieldInfo) :: field_infos;
              fields = obj :: fields;
            }
          else
            Message.fatal_error ("the member `" + name + "' has type " +
                                 mem.GetMemType ().as_string () + 
                                 " while the value assigned has type " +
                                 ty.as_string ())
                                 
        | _ =>
          def (obj, ty) = compile_expr (ti, true, parm);
          ctor_parm_types = ty :: ctor_parm_types;
          ctor_parms = obj :: ctor_parms;
      };

      List.Iter (parms, compile_parm);

      def arr<'a> (t, lst : list <'a>) { NArray.FromList (t, List.Rev (lst)) };

      mutable proper_ctor = null;

      ctor_parm_types = List.Rev (ctor_parm_types);

      def check_ctor (mem : IMember) {
        match (mem.GetKind ()) {
          | MK_method (meth) =>
            def parms = meth.GetHeader ().parms;
            def check_parm (ty, parm : Fun_parm) {
              Tyutil.types_eq (parm.ty, ty)
            }
            when (ctor_parm_types.Length () == parms.Length () &&
                  List.ForAll2 (ctor_parm_types, parms, check_parm)) 
            {
              assert (proper_ctor == null);
              proper_ctor = meth.GetConstructorInfo ();
            }
          | _ => ()
        }
      }

      List.Iter (attr.LookupMember (".ctor"), check_ctor);
      
      when (proper_ctor == null) 
        Message.fatal_error ("none of the constructors of `" + attr.GetFullName () + 
                             "' matches positional argument types");
                             
      SR.Emit.CustomAttributeBuilder 
          (proper_ctor, 
           arr (typeof (System.Object), ctor_parms), 
           arr (typeof (SR.PropertyInfo), property_infos), 
           arr (typeof (System.Object), properties), 
           arr (typeof (SR.FieldInfo), field_infos), 
           arr (typeof (System.Object), fields))
    }

    
    internal static CompileAttribute (ti : TypeBuilder, expr : PT.Expr)
        : SR.Emit.CustomAttributeBuilder
    {
      def add_end (l, suff : string) {
        match (l) {
          | [x] => [x + suff]
          | x :: xs => x :: add_end (xs, suff)
          | _ => Util.ice ("empty")
        }
      };

      Util.locate (expr.loc,
        match (expr) {
          | <[ $(_ : name) ]>
          | <[ $_x . $_y ]> =>
            CompileAttribute (ti, <[ $expr () ]>)
            
          | <[ $name ( .. $parms ) ]> =>
            match (Util.qidl_of_expr (name)) {
              | Some ((id, name)) =>
                def ctx = name.GetEnv (ti.env); 
                def tc =
                  match (ctx.LookupType (id)) {
                    | Some (t) => t
                    | None =>
                      match (ctx.LookupType (add_end (id, "Attribute"))) {
                        | Some (t) => t
                        | None =>
                          Message.fatal_error ("the custom attribute type `" + 
                                               Util.qid_of_list (id) +
                                               "' could not be found")
                      }
                  };
                do_compile (ti, tc, parms)
              | None =>
                Message.fatal_error ("this expression is not valid custom"
                                     " attribute name")
            }

          | _ => 
            Message.fatal_error ("this expression is not valid custom attribute")
        })
    }

  }
}
