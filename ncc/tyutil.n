(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree; 

namespace Nemerle.Compiler {

module Tyops {
  public @/- (t : Type, s : Subst) : Type = extern "Nemerle.Compiler.Tyutil.subst";
  public @>> (x : Type, y : Type) : bool = extern "Nemerle.Compiler.Tyutil.subtypes";
}
  
type Subst = Int_map(Type);

module Tyutil {
  public subst (t : Type, s : Subst) : Type
  {
    if (s.is_empty ())
      t
    else {
      def self (t : Type) : Type { subst (t, s) };
      match (t) {
        | T_ref (t) => T_ref (subst (t, s))
        | T_out (t) => T_out (subst (t, s))
        | T_array (t) => T_array (subst (t, s))
        | T_fun (tl, t) => T_fun (subst (tl, s), subst (t, s))
        | T_void => t
        | T_prod (tl) => T_prod (List.map (self, tl))
        | T_app (ti, args) =>
          T_app (ti, List.map (self, args))
        | T_var (tv) =>
          match (s.find (tv.id)) {
            | Some (T_var (tv2)) when tv.id == tv2.id => Util.ice ()
            | Some (t') => self (t') // fixpoint
            | None => t
          }
      }
    }
  }
  
  public subst_of_app (t : Type) : Subst * Tycon 
  {
    match (t) {
      | T_app (ti, args) => (ti.MakeSubst (args), ti)
      | _ => Util.ice ()
    }
  }

  public top_expand (t : Type) : Type 
  {
    match (t) {
      | T_app =>
        def (sub, ti) = subst_of_app (t);
        match (ti.GetTydecl ()) {
          | TD_alias (t) =>
            top_expand (t /- sub)  // fixpoint iteration
          | _ => t
        }
      | T_var (tv) when Tyvar.global_subst != null =>
        match (Tyvar.global_subst.find (tv.id)) {
          | Some (T_var (tv2)) when tv.id == tv2.id => Util.ice ()
          | Some (t') => top_expand (t')
          | None => t
        }
      | _ => t
    }
  }

  // t1 :> t2 (or t1 =? t2)
  public unify (s : Subst, t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst)
    {
      def sub1 (t : Type) : Type
        {
          def t = top_expand (t);
          match (t) {
            | T_var (tv) =>
              match (s.find (tv.id)) {
                | Some (t') => sub1 (t')
                | None => t
              }
            | _ => t
          }
        };
      //def sign = if (allow_subtyping) " :> " else " =? ";
      //Message.debug ("unify " + string_of_type (t1) + sign + string_of_type (t2));
      def (t1, t2) = 
        match ((t1, t2)) {
          | (T_var (tv1), T_var (tv2)) =>
            if (tv1.id == tv2.id) (t1, t2)
            else (sub1 (t1), sub1 (t2))
          | _ => (sub1 (t1), sub1 (t2))
        };
      //Message.debug ("  --> " + string_of_type (t1) + sign + string_of_type (t2));
      def unify_lists (s : Subst, t1 : list (Type), t2 : list (Type), 
                       allow_subtyping : bool) : option (Subst) {
        match ((t1, t2)) {
          | (t1 :: ts1, t2 :: ts2) =>
            match (unify (s, t1, t2, allow_subtyping)) {
              | Some (s') => unify_lists (s', ts1, ts2, allow_subtyping)
              | None => None ()
            }
          | ([], []) => Some (s)
          | _ => None ()
        }
      };
      
      def unify_with_tyvar (t1 : Type, t2 : Type) : option (Subst) {
        match (t1) {
          | T_var (tv) =>
            if (Tyvar.is_free (tv)) {
              def check_constraint (s : option (Subst), c : Type) : option (Subst) {
                match (s) {
                  | None => None ()
                  | Some (s) => unify (s, t2, c, true)
                }
              };
              List.fold_left (check_constraint, Some (s.add (tv.id, t2)),
                              Tyvar.constraints (tv))
            } else None ()
          | _ => None ()
        }
      };
        
      def fallback (t1 : Type, t2 : Type) : option (Subst) {
        match (unify_with_tyvar (t1, t2)) {
          | Some (s) => Some (s)
          | None => unify_with_tyvar (t2, t1)
        }
      };
      
      match ((t1, t2)) {
        | (T_ref (t1), T_ref (t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_out (t1), T_out (t2)) => 
          unify (s, t1, t2, allow_subtyping)
        | (T_array (t1), T_array (t2)) =>
          unify (s, t1, t2, false) // no array covariance
        | (T_array (_), T_app (ti2, [])) when allow_subtyping && 
                                              ti2.GetFullName () == "System.Array" => 
          Some (s)
          
        | (T_prod (l1), T_prod (l2)) => 
          unify_lists (s, l1, l2, allow_subtyping)

        | (T_void, T_void) => Some (s)
                                
        | (T_fun (a1, r1), T_fun (a2, r2)) =>
          match (unify (s, r1, r2, allow_subtyping)) {
            | Some (s) => unify (s, a2, a1, allow_subtyping)
            | None => None ()
          }

        | (T_app (ti1, a1), T_app (ti2, a2)) =>
          if (allow_subtyping && ti2.GetFullName () == "System.Object")
            Some (s)
          else
            if (ti1.SameAs (ti2)) 
              unify_lists (s, a1, a2, false)
            else
              if (allow_subtyping)
                match (ti1.SuperType (ti2)) {
                  | Some (args) => 
//                    Message.debug ("unify <: " + ti1.GetFullName () + " " + ti2.GetFullName ());
                    unify (s, ti2.GetMemType () 
                                /- ti2.MakeSubst (args) 
                                /- ti1.MakeSubst (a1), t2, true)
                  | None => None ()
                }
              else
                None ()
                              
        | (T_var (tv1), T_var (tv2)) =>
          if (tv1.id == tv2.id) Some (s)
          else fallback (t1, t2)
        
        | (T_var (tv), _) =>
          if (allow_subtyping) {
            // check to see if any of our constraints is enough
            def check_constraints (cs : list (Type)) : option (Subst) {
               match (cs) {
                 | [] => fallback (t1, t2)
                 | c :: cs =>
                   match (unify (s, c, t2, true)) {
                     | Some (r) => Some (r)
                     | None => check_constraints (cs)
                   }
               }
             };
             check_constraints (Tyvar.constraints (tv))
          } else fallback (t1, t2)
        
        | (_, T_app (ti2, _)) when allow_subtyping && 
                                    ti2.GetFullName () == "System.Object" => Some (s)
            
        | _ => 
          fallback (t1, t2)
      };
    }

  public unify (t1 : Type, t2 : Type, allow_subtyping : bool) : option (Subst) 
    { unify (Map.int_map (), t1, t2, allow_subtyping) }
  
  public unify (t1 : Type, t2 : Type) : option (Subst)
    { unify (Map.int_map (), t1, t2, false) }
 
  // FIXME: this might be broken (if there are free variables in types to
  // begin with)
  public types_eq (a : Type, b : Type) : bool {
    match (unify (a, b)) {
      | Some => true
      | None => false
    }
  }

  // check if a :> b and if so, incorporate substitution into
  // global context
  public subtypes (a : Type, b : Type) : bool {
    match (unify (a, b, true)) {
      | Some (s) => { Tyvar.global_store (s); true }
      | None => false
    }
  }

  public string_of_type (t : Type) : string
    {
      mutable cnt <- 0;
      
      def f (t) {
        match (t) {
          | T_app (ti, args) =>
            def name = ti.GetFullName ();
            match (args) {
              | [] => name
              | _ => name + " (" + map (", ", args) + ")"
            }
          | T_var (tv) =>
            def tvname (tv : Tyvar.T) {
              "'" + tv.name + "_" + string_of_int (tv.id) + if (Tyvar.is_free (tv)) "*" else ""
            };
            match (Tyvar.global_expand (t)) {
              | T_var (tv) => tvname (tv)
              | _ when cnt > 10 => tvname (tv)
              | t' =>
                cnt <- cnt + 1;
                f (t')
            }
          | T_ref (t) => "ref " + f (t)
          | T_out (t) => "out " + f (t)
          | T_void => "void"
          | T_prod (args) => 
            "(" + map (" * ", args) + ")"
          | T_fun (from, to) =>
            "(" + f (from) + " -> " + f (to) + ")"
          | T_array (t) => "array " + f (t)
        };
      }
      and map (sep, args) {
        Util.concat_strings(sep, List.map (f, args))
      };

      f (t);
    }


  (**
   * Flattens a string list to a comma separated string
   *)
  private string_list_to_comma_separated_string (tokens : list (string)) : string {
    match (tokens) {
      | [] => ""
      | [token] => token
      | token :: rest =>
        token + "," + string_list_to_comma_separated_string (rest)
    }
  }

  (**
   * Used to emit Nemerle types in assembly metadata
   *
   * <remarks>
   *   The type tree is converted to reverse polish notation.
   * </remarks>
   *)
  public encode_type (t : Type) : list (string)
  {
    def concat (header : string, tokens : list (list (string))) : list (string) {    
      match (tokens) {
        | [] => []
        | token :: rest =>
          List.append (header :: token, concat (header, rest))
      }
    };
    
    def walk_type (t : Type) : list (string) {
      match (t) {
        | T_ref (t) => "$T_ref" :: walk_type (t)
        | T_out (t) => "$T_out" :: walk_type (t)
        | T_array (t) => "$T_array" :: walk_type (t)
        | T_var (tv) => ["$T_var"; tv.name]
        | T_void => ["$T_void"]
        | T_fun (args, rt) => 
          "$T_fun" :: "$T_fun_args" :: List.append (walk_type (args),
                                                    "$T_fun_rt" :: walk_type (rt))
        | T_prod ([]) =>
          ["$T_prod"; "$T_prod_no_args"]
        | T_prod (args) =>
          "$T_prod" :: concat ("$T_prod_arg", List.map (walk_type, args))
        | T_app (ti, []) =>
          ["$T_app"; ti.GetFullName (); "$T_app_no_args"]
        | T_app (ti, args) =>
          "$T_app" :: ti.GetFullName () :: 
            concat ("$T_app_arg", List.map (walk_type, args))
      }
    };
    
    List.rev (walk_type (t))
  }


  (**
   * Used to emit Nemerle types in assembly metadata
   *
   * <remarks>
   *   The type tree is converted to reverse polish notation.
   * </remarks>
   *)
  public encode_type (t : PT.Type) : list (string)
  {
    def concat (header : string, tokens : list (list (string))) : list (string) {    
      match (tokens) {
        | [] => []
        | token :: rest =>
          List.append (header :: token, concat (header, rest))
      }
    };
    
    def walk_type (t : PT.Type) : list (string) {
      match (t) {
        | PT.T_ref (t) => "$T_ref" :: walk_type (t)
        | PT.T_out (t) => "$T_out" :: walk_type (t)
        | PT.T_array (t) => "$T_array" :: walk_type (t)
        | PT.T_var (n) => ["$T_var"; n]
        | PT.T_void => ["$T_void"]
        | PT.T_infer => Util.ice ("not inferred type to be flatten")
        | PT.T_fun (args, rt) => 
          "$T_fun" :: "$T_fun_args" :: List.append (walk_type (args),
                                                    "$T_fun_rt" :: walk_type (rt))
        | PT.T_prod ([]) =>
          ["$T_prod"; "$T_prod_no_args"]
        | PT.T_prod (args) =>
          "$T_prod" :: concat ("$T_prod_arg", List.map (walk_type, args))
        | PT.T_app (PT.SS_string (n), []) =>
          ["$T_app"; n; "$T_app_no_args"]
        | PT.T_app (PT.SS_string (n), args) =>
          "$T_app" :: n :: concat ("$T_app_arg", List.map (walk_type, args))
        | PT.T_app (_, _) =>
          Util.ice ("panic, Parsetree.T_app.tycon is not an SS_string instance") 
        | PT.T_spliced | PT.T_spliced_special =>
          Util.ice ("panic, Parsetree.T_spliced is not supported by encode_type")
        | PT.T_type_list =>
          Util.ice ("panic, Parsetree.T_type_list is not supported by encode_type")        
      }
    };
    
    List.rev (walk_type (t))
  }

  (**
   * Used to emit Nemerle types in assembly metadata
   *
   * <remarks>
   *   The type tree is converted to reverse polish notation.
   * </remarks>
   *)
  public encode_type_to_string (t : Type) : string {
  
    string_list_to_comma_separated_string (encode_type (t))
  }

  (**
   * Used to emit Nemerle types in assembly metadata
   *
   * <remarks>
   *   The type tree is converted to reverse polish notation.
   * </remarks>
   *)
  public encode_type_to_string (t : PT.Type) : string {
  
    string_list_to_comma_separated_string (encode_type (t))
  }

  (**
   * Used to decode Nemerle types extracted from assembly metadata
   *)
  public decode_type (env : GlobalEnv, tokens : string) : PT.Type {
  
    def delimiters = ",";
    string_list_to_type (env, List.from_array (tokens.Split (delimiters.ToCharArray ())))
  }
   
   
  (**
   * Same as above, but working on a separated list of strings
   *)
  private string_list_to_type (_env : GlobalEnv, tokens : list (string)) : PT.Type {
    
    def type_stack = Nemerle.Collections.Stack ();
    def token_stack = Nemerle.Collections.Stack ();

    def fail (message : string) : void {
      Message.error ("failed to build type from string list (" + message + ")")
    };
    
    def walk_list (tokens : list (string)) : void {    
      match (tokens) {
        | token :: rest =>          
          def expect_type_stack_length (length : int) : void {
            if (type_stack.length () < length)
              fail ("the type stack was expected to have at least " + string_of_int (length) +
                    " elements when processing symbol '" + token + "'")
            else ()
          };

          def expect_token_stack_length (length : int) : void {          
            if (token_stack.length () < length)
              fail ("the token stack was expected to have at least " + string_of_int (length) +
                    " elements when processing symbol '" + token + "'")
            else ()
          };

          def expect_eq (l : string, r : string) : void {          
            if (l != r) fail ("expected to find '" + r + "' on the stack, got '" + l + 
                              "' while processing token '" + token + "'") else ();
          };
          
          def new_type =
            match (token) {
              | "$T_void" => 
                Some (PT.T_void ())
              | "$T_ref" =>
                expect_type_stack_length (1);
                Some (PT.T_ref (type_stack.pop ()))
              | "$T_out" => 
                expect_type_stack_length (1);
                Some (PT.T_out (type_stack.pop ()))
              | "$T_array" => 
                expect_type_stack_length (1);
                Some (PT.T_array (type_stack.pop ()))
              | "$T_var" => 
                expect_token_stack_length (1);
                Some (PT.T_var (token_stack.pop ()))
              | "$T_fun" =>
                expect_type_stack_length (2);
                expect_token_stack_length (2);
                                                                                
                def ft = type_stack.pop ();
                def fa = token_stack.pop (); 

                expect_eq (fa, "$T_fun_args");

                def rt = type_stack.pop ();
                def fr = token_stack.pop ();

                expect_eq (fr, "$T_fun_rt");
                
                Some (PT.T_fun (ft, rt))
              | "$T_prod" =>
                expect_token_stack_length (1);
                
                if (token_stack.top () == "$T_prod_no_args") {
                  def _ = token_stack.pop ();
                  Some (PT.T_prod ([]))
                }
                else {
                  def loop () : list (PT.Type) {                               
                    if (token_stack.length () > 0 && token_stack.top () == "$T_prod_arg") {                    
                      expect_type_stack_length (1);
                                            
                      def _ = token_stack.pop ();
                      type_stack.pop () :: loop ()
                    }
                    else []
                  };
                                    
                  Some (PT.T_prod (loop ()))  
                }
              | "$T_app" =>
                expect_token_stack_length (2);
                
                def ti_name = token_stack.pop ();
                
                if (token_stack.top () == "$T_app_no_args") {                
                  def _ = token_stack.pop ();
                  Some (PT.T_app (PT.SS_string (ti_name), []))
                }
                else {
                
                  def loop () : list (PT.Type) {                  
                    if (token_stack.length () > 0 && token_stack.top () == "$T_app_arg") {                    
                      expect_type_stack_length (1);
                  
                      def _ = token_stack.pop ();
                      type_stack.pop () :: loop ();
                    }
                    else []
                  };
                                    
                  Some (PT.T_app (PT.SS_string (ti_name), loop ()))  
                }
              | token =>
                token_stack.push (token);
                None ()
            };
                    
          match(new_type) {
            | Some (new_type) => type_stack.push (new_type)
            | _ => ()
          };
          
          walk_list (rest)
          
        | [] =>
          if (type_stack.length () != 1 || token_stack.length () != 0) 
            fail ("stacks are not balanced") else ()
      }
    };
    
    walk_list (tokens);
    type_stack.pop ()
  }


  (**
   * Encodes a variant option
   *)
  public encode_variant_option (decls : list (PT.Class_member)) : string {
    
    def iter (decls : list (PT.Class_member)) : list (string) {    
      match (decls) {
        | [] => []
        | (PT.M_field (ty, _, _)) as decl :: rest =>
          List.append (Tyutil.encode_type (ty), decl.name :: "$T_variant_option_arg" :: iter (rest));
        | _ :: rest => 
          iter (rest)
      }
    };
    
    def processed_decls = 
      match (decls) {
        | [] => ["$T_variant_option_no_args"]
        | decls => List.append (iter (decls), ["$T_variant_option"])
      };
        
    string_list_to_comma_separated_string (processed_decls)    
  }

  
  // Given function declaration, construct its type.
  public fun_type (h : Fun_header) : Type {
    match (List.map (fun (p : Fun_parm) : Type { p.ty }, h.parms)) {
      | [x] => T_fun (x, h.ret_type)
      | [] => T_fun (T_void (), h.ret_type)
      | l => T_fun (T_prod (l), h.ret_type)
    }
  }

  public make_tapp (n : string) : Type {
    T_app (GlobalEnv.LookupInternalType (n), [])
  }

  public fun_args (from : Type) : list (Type) {
    match (top_expand (from)) {
      | T_prod (a) => a
      | T_void => []
      | t => [t]
    }
  }

  (**
   * Return set of maximal types (with respect to the [:>] ordering).
   * Types can have any additional information attached.
   *)
  public 'a maximal_types (types : list (Type * 'a)) : list (Type * 'a) {
    def is_worse (t1 : Type, t2 : Type) : bool {
      match ((unify (t1, t2, true), unify (t2, t1, true))) {
        | (Some, None) => false
        | _ => true
      }
    };

    def loop (did : bool, acc : list (Type * 'a), lst : list (Type * 'a)) : list (Type * 'a) {
      match (lst) {
        | (ty, data) :: xs =>
          def f = fun (t : Type, _ : 'a) : bool { is_worse (ty, t) };
          def acc' = List.filter (f, acc);
          def did = did || List.length (acc') != List.length (acc);
          loop (did, (ty, data) :: acc, List.filter (f, xs))
        | [] =>
          // fixpoint iteration
          if (did) loop (false, [], acc)
          else acc
      }
    };

    loop (false, [], types)
  }

  (**
   * Compute common type of two branches of some expression.
   *
   * If [t = unify_branches (t1, t2)] then [t1 :> t && t2 :> t].
   *
   * In case of [!(t1 :> t2) && !(t2 :> t1)] we unify only options of
   * the same variant.
   *)
  public unify_branches (t1 : Type, t2 : Type) : option (Type) {
    match (unify (t1, t2, true)) {
      | Some (s) => Tyvar.global_store (s); Some (t2)
      | None =>
        match (unify (t2, t1, true)) {
         | Some (s) => Tyvar.global_store (s); Some (t1)
         | None =>
            match ((top_expand (t1), top_expand (t2))) {
              | (T_app (ti1, a1), T_app (ti2, a2)) =>
                match ((ti1.GetTydecl (), ti2.GetTydecl ())) {
                  | (TD_variant_option, TD_variant_option) when 
                    Option.unsome (ti1.SuperClass ()).SameAs (Option.unsome (ti2.SuperClass ())) =>
                    match (unify (T_prod (a1), T_prod (a2))) {
                      | Some (s) =>
                        Tyvar.global_store (s);
                        Some (T_app (Option.unsome (ti1.SuperClass ()), a1))
                      | None => None ()
                    }
                  | _ => None ()
                }
              | _ => None ()
            }
        }
    }
  }

  public TypeOfMemberIn (mem : IMember, tc : Tycon) : Type {
    mem.GetMemType () /- tc.SubtypingSubst (mem.GetDeclaringTycon ())
  }
  
  public TypeOfMethodIn (mem : IMethod, tc : Tycon) : Type {
    mem.GetFreshType () /- tc.SubtypingSubst (mem.GetDeclaringTycon ())
  }
  
  public FilterMembers (mems : list (IMember), lf : LookupFlag) : list (IMember)
  {
    match (lf) {
      | LF_all => mems
      | LF_instance =>
        List.filter (fun (mem : IMember) { !mem.IsStatic () }, mems)
      | LF_static =>
        List.filter (fun (mem : IMember) { mem.IsStatic () }, mems)
    }
  }

}

} // ns
