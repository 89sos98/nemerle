
#if COMMENT || ALL1
#line 0
class SomeClass
{ 
  /// ... some comment ... 
  some_field : int;
  
  /** ... some ...
      ... multiline comment ...  */
  other_field : string;
}
#line default
#endif


#if FOO || ALL1
#line 0
class Foo
{
  public SomeMethod () : void
  {
    /// ...
  }
  private some_other_method (_x : int) : void
  {
    /// ... 
  }
  private Frobnicate (_x : int, _y : string) : int  
  {
    /// we return some int value here
    0
  }
  internal foo_bar () : void
  {
    /// ... 
  }
}
#line default
#endif

#if BAR || ALL1
#line 0
class Bar
{
  public mutable qux : int;
  private quxx : int;
  mutable bar : float;
}
#line default
#endif

#if HELLO || ALL1
#line 0
class Hello
{
  public static Main () : void
  {
    System.Console.WriteLine ("Hello cruel world!")
  }
}
#line default
#endif

#define OMMIT
class Fibonacci1 {
#undef OMMIT
#if FIBONACCI1 || ALL1
#line 0
fib (n : int) : int
{
  if (n < 2)
    1
  else
    fib (n - 1) + fib (n - 2)
}
#line default
#endif
#define OMMIT
}
#undef OMMIT

#define OMMIT
class Fibonacci2 {
#undef OMMIT
#if FIBONACCI2 || ALL1
#line 0
fib (n : int) : int
{
  mutable last1 = 1;
  mutable last2 = 1;
  
  for (mutable cur = 1; cur < n; ++cur) {
    def tmp = last1 + last2;
    last1 = last2;
    last2 = tmp;
  }

  last2
}
#line default
#endif

#if SUMCUBES || ALL1
#line 0
sum_cubes (v1 : int, v2 : int, v3 : int) : int
{
  def cube (x : int) : int {
    x * x * x
  } 
   
  cube (v1) + cube (v2) + cube (v3)
}
#line default
#endif
#define OMMIT
}
#undef OMMIT

#if SUM || ALL2
#line 0
module Sum {
  public Main () : void
  {
    def sum (x : int) : int {
      if (x <= 0) 
        0
      else
        x + sum (x - 1)
    }
    
    System.Console.WriteLine ("Sum of numbers from " +
                              "20 to 0 is: {0}", sum (20))
  }
}
#line default
#endif

#define OMMIT
class Fibonacci3 {
#undef OMMIT
#if FIBONACCI3 || ALL1
#line 0
fib (n : int) : int
{
  def my_loop (last1 : int, last2 : int, cur : int) : int {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  }
  
  my_loop (1, 1, 1)
}
#line default
#endif
#define OMMIT
}
#undef OMMIT

#define OMMIT
class Fibonacci4 {
#undef OMMIT
#if FIBONACCI4 || ALL1
#line 0
fib (n : int) : int
{
  def my_loop (last1 : int, last2, cur) {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  }
  
  my_loop (1, 1, 1)
}
#line default
#endif

#if UNIVERSE || ALL1
#line 0
the_answer_to_the_universe () : int
{
  /// Construct new random number generator.
  def r = System.Random ();
  
  /// Return new random number from [0, 99] range.
  r.Next (100)
}

print_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  System.Console.WriteLine ("The answer to the Ultimate " +
                            "Question of Life, the " +
                            "Universe and Everything " +
                            "is {0}", the_answer)
}

printf_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  Nemerle.IO.printf ("The answer is %d\n", the_answer);
}
#line default
#endif

#define OMMIT
}
#undef OMMIT

#if ARRAYTEST || ALL3
#line 0
class ArraysTest {
  static reverse_array (ar : array [int]) : void
  {
    def loop (left, right) {
      when ((left : int) < right) {
        def tmp = ar[left];
        ar[left] = ar[right];
        ar[right] = tmp;
        loop (left + 1, right - 1)
      }
    }
    loop (0, ar.Length - 1)
  }

  static print_array (ar : array [int]) : void
  {
    for (mutable i = 0; i < ar.Length; ++i)
      Nemerle.IO.printf ("%d\n", ar[i])
  }

  static Main () : void
  {
    def ar = array [1, 42, 3];
    print_array (ar);
    Nemerle.IO.printf ("\n");
    reverse_array (ar);
    print_array (ar);
  }
}
#line default
#endif

#if OPERATORS1 || ALL1
#line 0
class Operand {
  public val : int;
  public this (v : int) { val = v }
  
  public static @<-< (x : Operand, y : Operand) : Operand {
    Operand (x.val + y.val);
  }
}
#line default
#endif

#define OMMIT
module Operators {
  public boo () : void {
#undef OMMIT
#if OPERATORS2 || ALL1
#line 0
def x = Operand (2);
def y = Operand (3);
def z = x <-< y;
assert (z.val == 5);
#line default
#endif
#define OMMIT
  }
}
#undef OMMIT

#if DEEPTHOUGHT1 || ALL1
#line 0
namespace Deep.Thought
{
  class Answer
  {
    public static Get () : int
    {
      42
    }
  }
}

namespace Loonquawl
{
  class Brain
  {
    public static Run () : void
    {
      System.Console.WriteLine ("The answer {0}", 
                                Deep.Thought.Answer.Get ())
    }
  }
}
#line default
#endif

#if DEEPTHOUGHT2 || ALL1
#line 0
namespace LoonquawlUsing
{
  using System.Console;
  using Deep.Thought.Answer;
  
  class Brain
  {
    public static Run () : void
    {
      WriteLine ("The answer is {0}", Get ())
    }
  }
}
#line default
#endif

#if DEEPTHOUGHT3 || ALL1
#line 0
namespace LoonquawlAlias
{
  using SC = System.Console;
  using DTA = Deep.Thought.Answer;
  
  class Brain
  {
    public static Run () : void
    {
      SC.WriteLine ("The answer is {0}", DTA.Get ())
    }
  }
}
#line default
#endif

#if FUNCTIONS1 || ALL1
#line 0
/// Nemerle
class Functions {
  static f (x : int) : int
  {
    x * 2
  }

  static run_funval_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }
  
  public static Run () : void
  {
    System.Console.WriteLine ("{0}", run_funval_twice (f, 3))
  }
}
#line default
#endif

#if FUNCTIONS2 || ALL1
#line 0
class MoreFunctions {
  static run_twice (f : int -> int, v : int) : int
  {
    f (f (v))
  }

  static run_adder (x : int) : void
  {
    def f (y : int) : int { x + y };
    System.Console.WriteLine ("{0}", run_twice (f, 1))
  }

  public static Run () : void
  {
    run_adder (1);
    run_adder (2);
  }
}
#line default
#endif

#define OMMIT
class SomeFoo { }

abstract class FunctionExamples {
#undef OMMIT
#if FUNEXAMPLES1 || ALL1
#line 0
some_function (_arg1 : int, _arg2 : string, _arg3 : SomeFoo) : float
{
   /// ...
   System.Convert.ToSingle (_arg1)
}
#line default
#endif

#if FUNEXAMPLES2 || ALL1
#line 0
other_function () : string { "kaboo" }
#line default
#endif

#define OMMIT
public static Run () : void {
#undef OMMIT
#if FUNEXAMPLES3 || ALL1
#line 0
def x = Nemerle.Collections.List.Map ([1, 2, 3], fun (x) { 2 * x });
def y = Nemerle.Collections.List.FoldLeft (x, 0, fun (val : int, acc) { acc + val });
assert (y == 12);
#line default
#endif
#define OMMIT
}
#undef OMMIT

#if FUNEXAMPLES4 || ALL1
#line 0
string_pow : int * (string -> string) * string -> string;
#line default
#endif

#define OMMIT
}
#undef OMMIT

#if VARIANTS1 || ALL1
#line 0
/// Nemerle
variant Color {
  | Red
  | Yellow
  | Green
}
#line default
#endif

#if VARIANTS2 || ALL1
#line 0
variant RgbColor {
  | Red
  | Yellow
  | Green
  | Different {
      red : float;
      green : float;
      blue : float;
    }
}
#line default
#endif

#define OMMIT
module RgbHandler {
  foo () : void {
#undef OMMIT
#if VARIANTS3 || ALL1
#line 0
    /// ...
    def _blue = RgbColor.Different (0.0f, 0.0f, 1.0f);
    def _red = RgbColor.Red ();
    /// ...
#line default
#endif
#define OMMIT
    ()
  }
}
#undef OMMIT
