/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Compiler;
using Nemerle.IO;

using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Tyinfo;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

/** This pass operates on [Tyinfo] objects created for
    each type declaration found in source files.  These objects are
    already created, but most fields are empty.  The main function of
    this pass is [Tyinfo.run].  */

public class Tyinfo : Tycon, ITypeModifier {

  enclosing_type : option <Tyinfo>;
  variant_option_parent : Tyinfo;
  id : int;

  public mutable pt_tydecl : PT.Type_decl; // xmldump

  mutable tydecl : Type_decl;
  mutable t_extends : option <Type>;
  mutable t_implements : list <Type>;
  mutable is_module : bool;
  mutable cannot_finalize : bool;
  name : string;
  public env : GlobalEnv;
  loc : Location;
  accessibility : Accessibility;
  mutable modifiers : list <Modifier>;
  mutable contained_types : list <Tyinfo>;
  mutable variant_options : list <Tyinfo>;
  mutable typarms : list <Tyvar.T>;
  public mutable tenv : Tyvar.TEnv;
  mutable additional_decls : list <PT.Class_member>;

  mutable subtypes : SystemMap <int, Tycon * list <Type>>;
  mutable member_map : SystemMap <string, list <IMember>>;
  mutable member_list : list <IMember>;

  mutable type_builder : System.Reflection.Emit.TypeBuilder;
  mutable system_type : System.Type;

  mutable constant_object : option <IField>;
  mutable has_fields : bool;
  
  /**
   * Marker for [Tyinfo.Iter].
   */
  mutable phase : int;
  
  /**
   * Transitive closure of inherited types in this type and its nested types.
   *
   * Used by [Tyinfo.Iter] function.
   */
  mutable iterate_first : list <Tyinfo>;

  mutable is_protected : bool;
  mutable is_public : bool;
  mutable is_internal : bool;
  mutable is_private : bool;

  static mutable infos : list <Tyinfo>;

  static mutable run_phase : int;

  
  /**
   * Return list of type parameters under which we subtype given type.
   *
   * <remarks>
   *   For example if [A ('a) :> B (int)], then ["A".SuperType ("B")]
   *   returns [[int]].
   *
   *   This information can be also fetched from [GetDirectSuperTypes()]
   *   method but this function is transitive.
   * </remarks>
   */
  public SuperType (ti : Tycon) : option <list <Type>>
  {
    Option.Map (this.subtypes.Find (ti.GetId ()), fun (_, x) { x })
  }

  /** Return qualified type name. */
  public GetFullName () : string
  {
    env.GetCurrentNamespace () + name
  }

  public GetId () : int
  {
    id
  }

  public IsDelegate () : bool
  {
    false
  }

  public IsValueType () : bool
  {
    false
  }

  public GetHandle () : System.Reflection.MemberInfo
  {
    null
  }

  /** Return type we were defined in (null for toplevel types). */
  public DeclaringType : Tycon {
    get {
      match (enclosing_type) {
        | Some (ti) => ti
        | None => null
      }
    }
  }

  /** Return name without any dots. */  
  public Name : string {
    get { name }
  }

  public MemberType : System.Reflection.MemberTypes {
    get { System.Reflection.MemberTypes.NestedType }
  }
  
  public GetKind () : MemberKind
  {
    MK_type (this)
  }

  public GetAccessibility () : Accessibility
  {
    accessibility
  }

  public GetLibraryReference () : LibraryReference { null }
  
  /**
   * Return list of types that we directly subtype.
   *
   * <remarks>
   *   This includes [extends] and [implements], as well as parent variant
   *   type for variant options.
   * </remarks>
   */
  public GetDirectSuperTypes () : list <Type>
  {
    match (t_extends) {
      | Some (t) => t :: t_implements
      | None => t_implements
    }
  }

  public GetConstantObject () : option <IField>
  {
    constant_object
  }

  /** Return type we extend if any. */
  public SuperClass () : option <Tycon>
  {
    match (t_extends) {
      | Some (T_app (ti, _)) => Some (ti)
      | _ => None ()
    }
  }

  public SetContainedTypes (ct : list <Tyinfo>) : void
  {
    contained_types <- ct;
  }

  public SetVariantOptions (ct : list <Tyinfo>) : void
  {
    variant_options <- ct;
  }

  /**
   * If this type was defined as [class Foo ('a, 'b) { ... }] then return
   * type expression [Foo ('a, 'b)].
   *
   * <remarks>
   *   Used mainly with [FreshSubst ()] or [MakeSubst ()].
   * </remarks>
   */
  public GetMemType () : Type
  {
    def make_tv (tv : Tyvar.T) : Type { T_var (tv) };
    T_app (this, List.Map (typarms, make_tv))
  }


  /**
   * Return substitution replacing each of our type parameters with fresh
   * type variable.
   */
  public FreshSubst () : Subst
  {
    Tyvar.fresh_subst (this.typarms)
  }

  /**
   * Helper used also in ExternalNemerleType.
   */
  internal static ConstructSubst (tc : Tycon, typarms : list <Tyvar.T>,
                                  args : list <Type>) : Subst
  {
    def loop (ini : Subst, parms : list <Tyvar.T>, args : list <Type>) : Subst {
      match ((parms, args)) {
        | (p :: ps, a :: args) =>
          match (a) {
            | T_var (p') =>
              if (p.id == p'.id) ini
              else loop (ini.Add (p.id, TV_exactly (a)), ps, args)
            | _ => loop (ini.Add (p.id, TV_exactly (a)), ps, args)
          }
        | ([], []) => ini
        | _ => Util.ice ()
      }
    };

    def len_tp = List.Length (typarms);
    def len_ac = List.Length (args);

    if (len_tp == len_ac) {
      def sub = loop (SystemMap (), typarms, args);

      def check_constraints (tv : Tyvar.T, t : Type) : void {
        def check_constraint (c : Type) : void {
          unless (t >:> (c /- sub)) {
              Message.error ("typing constraint '" + tv.name +
                             " :> " + c.as_string () + " is not satisfied");
              Message.error ("by " + t.as_string () + " :> " + (c /- sub).as_string ());
              Message.error (tc.GetLocation (), "upon instantiation of " + tc.GetFullName ())
          }
        };
        List.Iter (Tyvar.constraints (tv), check_constraint)
      };
      List.Iter2 (typarms, args, check_constraints);

      sub
    } else {
      Message.error (sprintf ("type `%s' takes %d argument(s) while %d were supplied",
                              tc.GetFullName (), len_tp, len_ac));
      SystemMap ()
    }
  }

  /**
   * Construct substitution resulting from applying this type constructor
   * to specified arguments.
   *
   * <remarks>
   *   For example assuming our type parameters are are ('a, 'b), then
   *   [MakeSubst ([t1, t2])] produces substitution { 'a := t1; 'b := t2 }.
   * </remarks>
   */
  public MakeSubst (args : list <Type>) : Subst
  {
    ConstructSubst (this, typarms, args)
  }

  type Subinfo = SystemMap <int, Tycon * list <Type>>;

  public GetTyconKind () : TyconKind
  {
    TK_NemerleType (this)
  }

  public GetTydecl () : Type_decl
  {
    tydecl
  }

  public SameAs (tc : Tycon) : bool
  {
    tc.GetId () == GetId ()
  }

  public GetModifiers () : list <Modifier>
  {
    modifiers
  }

  public IsStatic () : bool
  {
    true
  }

  public LookupMember (name : string) : list <IMember>
  {
    match (member_map.Find (name)) {
      | None => []
      | Some (mems) => mems
    }
  }

  /**
   * Iterate over all types defined in source code.
   *
   * <remarks>
   *   Supertypes are always processed before subtypes otherwise
   *   source code order is retained.
   * </remarks>
   */
  public static Iter (f : Tyinfo -> void) : void
  {
    def working_on = Util.next_id ();
    def done = Util.next_id ();
    def maybe_f (ti : Tyinfo) : void {
      if (ti.phase == done) ()
      else if (ti.phase == working_on)
        Message.error(ti.loc, "type definition for `" + ti.GetFullName () + "' is cyclic")
      else {
        ti.phase <- working_on;
        Util.locate (ti.loc, {
          List.Iter (ti.iterate_first, maybe_f);
          f (ti)
        });
        ti.phase <- done
      }
    };

    List.Iter (infos, maybe_f);
  }

  /**
   * Return substitution to apply to types of members of our supertype [ti]
   * to get types of members in [this].
   *
   * <remarks>
   *    For example consider:
   *    [[[
   *      class A ('a) { f : 'a; }
   *      class B : A (int) { }
   *    ]]]
   *    Now ["B".SubtypingSubst ("A")] would return { 'a := int }, so
   *    it can be applied to type of [A.f] which is ['a], to obtain type
   *    of [B.f] which is [int].
   * </remarks>
   */
  public SubtypingSubst (tc : Tycon) : Subst
  {
    if (tc.GetId () == GetId ())
      SystemMap () // current type, no substitution
    else
      tc.MakeSubst (Option.UnSome (SuperType (tc)));
  }

  /**
   * Iterate over top level types in source code order.
   */
  public static SourceTopIter (f : Tyinfo -> void) : void
  {
    def wrap (x : Tyinfo) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    List.Iter (infos, wrap);
  }

  /**
   * Iterate over top level types in inheritance order.
   */
  public static TopIter (f : Tyinfo -> void) : void
  {
    def wrap (x : Tyinfo) : void {
      match (x.enclosing_type) {
        | Some => ()
        | None => Util.locate (x.loc, f (x))
      }
    };

    Iter (wrap);
  }

  public this (par : option <Tyinfo>, vop : option <Tyinfo>, 
               env : GlobalEnv, td : PT.Type_decl)
  {
    this.enclosing_type <- par;
    this.pt_tydecl <- td;
    this.env <- env;
    this.name <- List.Head (Macros.UnSString (td.name));
    this.loc <- td.loc;
    modifiers <- td.modifiers;

    match (td) {
      | PT.TD_variant_option =>
        match (vop) {
          | Some (ti) =>
            modifiers <-
              Mod_attribute ([], [ <[ Record ]> ]) :: 
              Mod_sealed () :: 
              modifiers;
            if (ti.is_public)
              modifiers <- Mod_public () :: modifiers
            else if (ti.is_internal)
              modifiers <- Mod_internal () :: modifiers
            else if (ti.is_protected)
              modifiers <- Mod_protected () :: modifiers
            else if (ti.is_private)
              modifiers <- Mod_private () :: modifiers
            else ()
          | None => assert (false)
        }
      | PT.TD_variant =>
        modifiers <-
          Mod_attribute ([], [ <[ Record ]> ]) :: modifiers;
      | _ => ()
    };

    Passes.tyinfo_counter <- Passes.tyinfo_counter + 1;

    this.id <- Util.next_id ();

    infos <- this :: infos;

    def parse_mod (mod) {
      match (mod) {
        | Mod_public => is_public <- true
        | Mod_internal => is_internal <- true
        | Mod_protected => is_protected <- true
        | Mod_private => is_private <- true
        | _ => ()
      }
    };
          
    List.Iter (modifiers, parse_mod);

    unless (is_public || is_internal || is_protected || is_private) {
      match (enclosing_type) {
        | Some =>
          modifiers <- Mod_private () :: modifiers;
          is_private <- true
        | None =>
          modifiers <- Mod_internal () :: modifiers;
          is_internal <- true
      }
    };

    if (is_private)
      accessibility <- A_private ()
    else if (is_protected && is_internal)
      accessibility <- A_protected_or_internal ()
    else if (is_protected)
      accessibility <- A_protected ()
    else if (is_internal)
      accessibility <- A_internal ()
    else
      accessibility <- A_public ();

    match ((vop, pt_tydecl)) {
      | (Some (x), PT.TD_variant_option) =>
        variant_option_parent <- x
      | (None, PT.TD_variant_option) => Util.ice ()
      | (Some, _) => Util.ice ()
      | (None, _) => ()
    };

    additional_decls <- [];
  }

  public CanAccess (source : Tycon) : bool
  {
    is_public || 
    (is_internal && 
      match (source.GetTyconKind ()) { 
        | TK_NemerleType => true 
        | _ => false 
      }) || 
    (is_protected &&
        match (enclosing_type) {
          | Some (tc) => Option.IsSome (source.SuperType (tc))
          | None => false
        }) ||
    match (enclosing_type) {
      | Some (declaring_type) =>
        def walk_declaring (tc : Tycon) {
          tc.SameAs (declaring_type) || 
            (tc.DeclaringType != null && walk_declaring (tc.DeclaringType))
        };
        walk_declaring (source)
      | None => false
    }
  }

  /**
   * Construct typing environments for each declaration.
   *
   * <remarks>
   *   The first thing to do is to create typing environment [Tyvar.TEnv]
   *   for each type declaration.  Then typing environment is populated
   *   with type variables (transformed into [Tyvar.T] objects).  Finally
   *   constraints (type expressions, which are first bound) of each
   *   type variable are stored in [Tyvar.T].
   *
   *   Typing environment maps names of type variables to [Tyvar.T] objects.
   * </remarks>
   */
  make_tyenvs (tenv : Tyvar.TEnv) : void
  {
    assert (this.tenv == null);
    def (tenv, tyvars) = tenv.add_typarms (this.env, this.pt_tydecl.typarms,
                                           this, check_parms = false);
    this.tenv <- tenv;
    this.typarms <- tyvars;

    match (pt_tydecl) {
      | PT.TD_variant_option (members) =>
        unless (Util.is_capitalized (List.Head (Macros.UnSString (pt_tydecl.name)))) {
          Message.error (loc, "variant options names must start with capital letters")
        };
        assert (variant_option_parent.tenv != null);
        this.tenv <- variant_option_parent.tenv;
        this.typarms <- variant_option_parent.typarms;
        def make_public (d : PT.Class_member) : void {
          d.modifiers <- Mod_public () :: d.modifiers
        };
        List.Iter (members, make_public)
      | PT.TD_variant =>
        modifiers <- Mod_abstract () :: modifiers
      | _ => ()
    };

    def bind_child (x : Tyinfo) {
      Util.locate (x.loc, x.make_tyenvs (tenv));
    };
    List.Iter (this.contained_types, bind_child);
  }


  /**
   * Bind type expressions occurring in type declarations. This
   * includes [extends] type, [implements] list, and aliased type
   * in case of type alias declaration.
   *
   * <remarks>
   *   Binding type expression refers to rewriting [Parsetree.Type]
   *   into [Typedtree.Type], which involves resolving names of type
   *   constructors (to [Tyinfo] objects) and type variables (to [Tyvar.T]
   *   objects).
   *   
   *   This function depends on nested types being processed *before*
   *   parent type (so it should only operate on reversed infos list).
   * </remarks>
   */
  bind_types () : void
  {
    def bind (t : PT.Type) : Type {
      this.tenv.bind (this.env, this, t, check_parms = false)
    };
    def td = this.pt_tydecl;
    def check_module (x : Modifier) : void {
      match (x) {
        | Mod_module => this.is_module <- true
        | _ => ()
      }
    };
    List.Iter (this.modifiers, check_module);
    this.tydecl <-
      match (td) {
        | PT.TD_class => TD_class ()
        | PT.TD_alias (t) => TD_alias (bind (t))
        | PT.TD_interface => TD_interface ()
        | PT.TD_delegate => // FIXME
          Util.ice ("no delegate support yet")
        | PT.TD_enum => TD_enum ()
        | PT.TD_variant =>
          TD_variant (List.Map (variant_options, fun (x : Tyinfo) : Tycon { x }))
        | PT.TD_variant_option => TD_variant_option ()
        | PT.TD_macro => Util.ice ("macro shouldn't survive to typing")
      };
      
    match (td) {
      | PT.TD_variant_option =>
        this.t_extends <- Some (variant_option_parent.GetMemType ());
        this.t_implements <- [];
      | _ =>
        match (td.t_extends) {
          | hd :: tl =>
            def is_interface (tc : Tycon) {
              if (tc.GetTydecl () == null)
                match ((tc :> Tyinfo).pt_tydecl) {
                  | PT.TD_interface => true
                  | _ => false
                }
              else
                match (tc.GetTydecl ()) {
                  | TD_interface => true
                  | _ => false
                }
            };
            def hd' = bind (hd);
            match (hd') {
              | T_app (tc, _) when !is_interface (tc) =>
                this.t_extends <- Some (hd'); 
                this.t_implements <- List.Map (tl, bind);
              | _ =>
                this.t_implements <- hd' :: List.Map (tl, bind);
                this.t_extends <- None ()
            }
          | [] =>
            this.t_implements <- [];
            this.t_extends <- None ()
        }
    };

    match (pt_tydecl) {
      | PT.TD_enum => handle_underlying_enum_type ()
      | _ => ()
    };

    match (t_extends) {
      | None =>
        match (pt_tydecl) {
          | PT.TD_interface 
          | PT.TD_alias => ()
          | _ =>
            t_extends <- Some (bind (<[ type: System.Object ]>))
        }
      | Some => ()
    };

    // construct this.iterate_first:
    def iterate_first = Hashtable ();
    def add_tycon (tc : Tycon) {
      when (tc != null) {
        match (tc.GetTyconKind ()) {
          | TK_NemerleType (ti) => iterate_first.Set (ti.GetId (), ti)
          | _ => ()
        }
      }
    };
    def add_type (t : Type) {
      match (t) {
        | T_app (tc, _) => add_tycon (tc)
        | _ => ()
      }
    };
    def add_from (ti : Tyinfo) {
      def is_self (ti : Tycon) {
        if (ti == null) false
        else ti == (this : Tycon) || is_self (ti.DeclaringType)
      };
      def add_not_self (ti : Tyinfo) {
        when (! is_self (ti)) {
          iterate_first.Set (ti.GetId (), ti)
        }
      };
      assert (ti.iterate_first != null);
      List.Iter (ti.iterate_first, add_not_self)
    };
    List.Iter (GetDirectSuperTypes (), add_type);
    List.Iter (this.contained_types, add_from);
    this.iterate_first <- iterate_first.Fold ([], fun (_, ti, acc) { ti :: acc });
  }

  /**
   * Construct datastructures we use to check subtyping relations.
   *
   * <remarks>
   *   This probably the hardest part of processing type declarations.
   *
   *   Each type directly subtypes types it extends or implements.  This
   *   pass computes transitive closure of direct subtyping relation
   *   and stores it [Tyinfo.subtypes] map.  .NET generics doesn't allow
   *   same type to be subtyped under different instantiations, so we
   *   use map from (id of) subtyped Tyinfo object to actual parameters
   *   of subtyped type.
   * </remarks>
   */
  static determine_subtyping () : void
  {
    Iter (fun (ti : Tyinfo) { 
            ti.construct_subtyping_map () 
          });
  }

  construct_subtyping_map () : void
  {
    def add_srs (t, s : Subinfo) {
      match (t) {
        | T_app (ti', args) => add_subtyping_of (s, ti', args)
        | _ =>
          Message.error (loc, "cannot implement nor extend non-class type");
          s
      }
    };
    subtypes <- List.FoldLeft (GetDirectSuperTypes (), SystemMap (), add_srs)
  }

  add_subtyping_of (subinfo : Subinfo, tc : Tycon, args : list <Type>) : Subinfo
  {
    def add_sr (subinfo : Subinfo, subtyped : Tycon, args : list <Type>) {
      match (subinfo.Find (subtyped.GetId ())) {
        | Some ((_, args')) =>
          mutable problem <- "";
          def check_eq (t1 : Type, t2 : Type) : bool {
            if (Tyutil.types_eq (t1, t2)) true
            else {
              problem <- "types " + t1.as_string() + " and " +
                         t2.as_string() + " are not compatible";
              false
            }
          };
          unless (List.ForAll2 (args, args', check_eq)) {
            Message.error ("type `" + subtyped.GetFullName () +
                           "' is implemented by type `" +
                           GetFullName() +
                           "' twice under different instantiations");
            if (tc.GetId () == subtyped.GetId ())
              Message.error ("second one directly")
            else
              Message.error ("second one through `" + tc.GetFullName () + "'");
            Message.error (problem);
          };
          subinfo
        | None =>
          subinfo.Add (subtyped.GetId (), (subtyped, args))
      }
    };

    def sub = tc.MakeSubst (args);

    def add_srt (t, subinfo : Subinfo) {
      match (t) {
        | T_app (tc, args) =>
          add_sr (subinfo, tc, List.Map (args, fun (t) { t /- sub }))
        | _ => Util.ice ("extending non-class type")
      }
    };

    def subinfo = List.FoldLeft (tc.GetSuperTypes (), subinfo, add_srt);
    def subinfo = add_sr (subinfo, tc, args);
    subinfo
  }

  public GetSuperTypes () : list <Type>
  {
    if (subtypes == null) []
    else
      subtypes.Fold (fun (_, x, acc) {
                        def (tc, args) = x;
                        T_app (tc, args) :: acc },
                     [])
  }

  begin_adding_members () : void
  {
    def get_members (t) {
      match (t) {
        | T_app (tc, _) => tc.GetMembers ()
        | _ => []
      }
    };
    def members = 
      match (GetTydecl ()) {
        | TD_interface =>
          List.Concat (List.Map (GetDirectSuperTypes (), get_members))
        | _ =>
          match (t_extends) {
            | Some (t) => get_members (t)
            | None => []
          }
      };
      
    def inherit_it (mem : IMember) {
      !mem.IsStatic () &&
        match (mem.GetKind ()) {
          | MK_method (mem) =>
            match (mem.GetFunKind ()) {
              | FK_ctor => false
              | _ => true
            }
          | MK_field =>
            has_fields <- true;
            true
          | _ => true
        }
    };

    def add (mem : IMember, map : SystemMap <string, list <IMember>>) {
      if (inherit_it (mem)) {
        def n = mem.Name;
        match (map.Find (n)) {
          | Some (l) => map.Replace (n, mem :: l)
          | None => map.Add (n, [mem])
        }
      } else
        map
    };

    member_map <- List.FoldLeft (members, SystemMap (), add);
    member_list <- []
  }

  public GetMembers () : list <IMember>
  {
    def maybe_add (m : IMember, acc) {
      if (m.DeclaringType.SameAs (this))
        acc
      else
        m :: acc
    };
    def maybe_add_few (_, mems, acc) {
      List.FoldLeft (mems, acc, maybe_add)
    };

    // retain order of member_list
    member_map.Fold (maybe_add_few, member_list)
  }

  public GetFields (with_static : bool, with_derived : bool) : list <IField>
  {
    def mems = List.Filter (GetMembers (), fun (x : IMember) {
      x.IsStatic () == with_static &&
      match (x.GetKind ()) {
        | MK_field => true
        | _ => false
      } &&
      x.DeclaringType.SameAs (this) != with_derived
    });
    (mems :> list <IField>)
  }

  public GetFields () : list <IField>
  {
    GetFields (true, true)
  }
  
  public BindType (t : PT.Type) : Type
  {
    BindType (tenv, t)
  }

  public BindType (other_tenv : Tyvar.TEnv, t : PT.Type) : Type
  {
    other_tenv.bind (env, this, t, check_parms = true)
  }

  public BindTyparms (tp : PT.Typarms) : Tyvar.TEnv * list <Tyvar.T>
  {
    BindTyparms (tenv, tp)
  }

  public BindTyparms (other_tenv : Tyvar.TEnv, tp : PT.Typarms) : Tyvar.TEnv * list <Tyvar.T>
  {
    other_tenv.add_typarms (env, tp, this, check_parms = true)
  }

  /** Check if types that are already bound are correctly applied. */
  check_bound_types () : void
  {
    def types =
      match (tydecl) {
        | TD_alias (t) => t :: GetDirectSuperTypes ()
        | _ => GetDirectSuperTypes ()
      };
    def check_type (t) {
      match (t) {
        | T_ref (t) => check_type (t)
        | T_out (t) => check_type (t)
        | T_array (t) => check_type (t)
        | T_fun (ts, t) => check_type (ts); check_type (t)
        | T_void => ()
        | T_prod (ts) => List.Iter (ts, check_type)
        | T_var => ()
        | T_app (ti, args) =>
          List.Iter (args, check_type);
          ignore (ti.MakeSubst (args));
      }
    };
    def do_check_type (t) { 
      Tyutil.CheckAccessibility (accessibility, t);
      check_type (t);
    };
    def check_constraints_in_tv (tv) {
      List.Iter (Tyvar.constraints (tv), do_check_type)
    };
    List.Iter (types, check_type); // no access check here!
    List.Iter (typarms, check_constraints_in_tv);
  }

  describe_member (m : IMember) : string
  {
    def kind =
      match (m.GetKind ()) {
        | MK_field => "a field"
        | MK_method => "a method"
        | MK_property => "a proprty"
        | MK_type => "a type"
        | MK_event => "an event"
      };
    kind + " `" + m.Name + "'"
  }

  public GetLocation () : Location
  {
    loc
  }

  public BindAndAddMember (class_member : PT.Class_member) : void
  {
    try { 
      ignore (bind_and_add_member (class_member))
    } catch {
      | _ : Recovery => ()
    }
  }
  
  bind_and_add_member (class_member : PT.Class_member) : IMember
  {
    Util.locate (class_member.loc, {
      when (is_module)
        class_member.modifiers <- Mod_static () :: class_member.modifiers;
      match (tydecl) {
        | TD_interface =>
          class_member.modifiers <- Mod_virtual () :: Mod_abstract () :: class_member.modifiers
        | _ => ()
      };
      match (class_member) {
        | PT.M_type => null
        | (PT.M_field) as f =>
          def r = (NemerleField (this, f) : IMember);
          AddMember (r);
          r
          
        | (PT.M_function) as f =>
          def r = NemerleMethod (this, f);
          AddMember (r);
          r
          
        | (PT.M_property) as p =>
          def r = NemerleProperty (this, p);
          AddMember (r);
          r
          
        | (PT.M_event) as e =>
          def r = NemerleEvent (this, e);
          AddMember (r);
          r
      }
    })
  }

  public AddMember (mem : IMember) : void
  {
    def replace_method (acc, meth : IMethod, mems) {
      match (mems) {
        | [] => mem :: acc
        | x :: xs =>
          match ((x : IMember).GetKind ()) {
            | MK_method (m) =>
              def sub = SubtypingSubst (m.DeclaringType);
              if (Tyutil.types_eq (m.GetMemType () /- sub, mem.GetMemType ())) {
                match (m.GetFunKind ()) {
                  | _ when m.DeclaringType.SameAs (this) =>
                    Message.error (mem.GetLocation (),
                                   "redefinition of " + describe_member (mem))
                  | FK_ctor | FK_static_ctor => ()
                  | _ when Util.is_new (mem) => ()
                  | _ when Util.is_override (mem) => ()
                  | _ =>
                    Message.error (mem.GetLocation (), describe_member (mem) +
                                   " in `" + GetFullName () + "' hides " + describe_member (x) +
                                   " from parent (" + x.DeclaringType.GetFullName () +
                                   ") but no `new' specified")
                };
                List.RevAppend (xs, mem :: acc)
              } else replace_method (x :: acc, meth, xs)
            | _ => Util.ice ("expecting method, got " + describe_member (x))
          }
      }
    };

    def new_mems =
      match (member_map.Find (mem.Name)) {
        | Some ([]) => Util.ice ()
        | Some ((x :: _) as old) =>
          if (x.DeclaringType.SameAs (this))
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " redefined in `" + GetFullName () + "'");
                Message.error (x.GetLocation (), "  first definition here as " +
                               describe_member (x));
                [mem]
            }
          else
            match ((mem.GetKind (), x.GetKind ())) {
              | (MK_method (m), MK_method) =>
                replace_method ([], m, old)
              | _ when Util.is_new (mem) => [mem]
              | _ =>
                Message.error (mem.GetLocation (), describe_member (mem) +
                               " in `" + GetFullName () + "' hides " + describe_member (x) +
                               " from parent (" + x.DeclaringType.GetFullName () +
                               ") but no `new' specified");
                [mem]
            }

        | None => [mem]
      };

    unless (has_fields) {
      match (mem.GetKind ()) {
        | MK_field => has_fields <- true
        | _ => ()
      }
    };

    member_map <- member_map.Replace (mem.Name, new_mems);
    member_list <- mem :: member_list;
  }

  /** Return list of all members defined in this very type. */
  public GetDirectMembers () : list <IMember>
  {
    member_list
  }

  public GetTypeBuilder () : System.Reflection.Emit.TypeBuilder
  {
    assert (type_builder != null);
    type_builder
  }

  public GetSystemType () : System.Type
  {
    assert (system_type != null);
    system_type
  }
  
  
  public GetVariantOptionParent () : Tyinfo
  {
    assert (variant_option_parent != null);
    variant_option_parent
  }
  
  
  public GetVariantOptions () : list <Tyinfo>
  {
    variant_options
  }

  mutable underlying_enum_type_iface : INumericType;
  mutable underlying_enum_type : Type;
  
  handle_underlying_enum_type () : void
  {
    match (t_extends) {
      | Some (t) =>
        underlying_enum_type <- t;
      | None =>
        underlying_enum_type <- Tyutil.make_tapp ("System.Int32");
    };
    
    t_extends <- Some (Tyutil.make_tapp ("System.Enum"));

    match (t_implements) {
      | [] => ()
      | _ => Message.error ("enum cannot implement anything")
    };

    def oops () {
      Message.error ("`" + underlying_enum_type.as_string () + "' is not valid underlying enum type");
    };

    
    match (Tyutil.top_expand (underlying_enum_type)) {
      | T_app (tc, []) =>
        match (NumericType.ByName (tc.GetFullName ())) {
          | Some (t) when t.IsInteger =>
            underlying_enum_type_iface <- t
          | _ => oops ()
        }
      | _ => oops ()
    }
  }


  add_enum_members (decls : list <PT.Enum_field>) : void
  {
    def mods = [Mod_public (), Mod_static ()];
    def field_type = PT.T_typed (GetMemType ());
    
    def add_field (ef : PT.Enum_field, default_value) {
      def t = underlying_enum_type_iface;
      def current_value =
        match (ef.value) {
          | Some (lit) =>
            def val = t.FromLiteral (lit);
            if (val == null) {
              Message.error ("underlying type of enum `" + GetFullName () + 
                             "' is `" + underlying_enum_type.as_string () + 
                             "', so enum literal need to have this type");
              default_value
            } else val
          | None => default_value
        };
      def field = PT.M_field (ef.loc, ef.name, mods, field_type);
      def field = bind_and_add_member (field);
      (field :> NemerleField).enum_value <- current_value;
      t.Binary ("+", current_value, t.One)
    };

    BindAndAddMember (<[ field: public value__ : $(PT.T_typed (underlying_enum_type)); ]>);
    ignore (List.FoldLeft (decls, underlying_enum_type_iface.Zero, add_field));
  }
  

  /**
   * Collect type members (fields and methods, but not types, which
   * are already collected in [Tyinfo.contained_types]) and store
   * them in [Tyinfo.member_map] and [Tyinfo.member_list].
   *
   * <remarks>
   *   Members are first transferred from the [Parsetree] into the
   *   [Typedtree] namespace by binding appropriate types.
   * </remarks>
   */
  add_members () : void
  {
    begin_adding_members ();
    def decls =
      match (pt_tydecl) {
        | PT.TD_class (ds)
        | PT.TD_interface (ds)
        | PT.TD_variant (ds)
        | PT.TD_variant_option (ds) => ds
        | PT.TD_enum (ds) =>
          add_enum_members (ds); []
        | _ => []
      };
    List.Iter (decls, BindAndAddMember);
    List.Iter (additional_decls, BindAndAddMember);

    contained_types <- List.Rev (contained_types);
    List.Iter (contained_types, AddMember);
    
    member_list <- List.Rev (member_list);

    // we no longer need it, let GC kill it
    pt_tydecl <- null;
    additional_decls <- null;
  }

  add_constant_object_ctor () : void
  {
    match (member_map.Find (".ctor")) {
      | Some ([ctor]) =>
        def ctor = (ctor :> NemerleMethod);
        def field = PT.M_field (loc = loc, 
                                name = PT.SS_string (PT.Name ("_N_constant_object")), 
                                modifiers = [Mod_public (), Mod_static ()],
                                ty = PT.T_void ());
        def typed_field = NemerleField (this, (field :> PT.M_field));
        typed_field.ty <- variant_option_parent.GetMemType ();
        ctor.modifiers <- [Mod_private ()];
        AddMember (typed_field);
        constant_object <- Some ((typed_field : IField));
        
        def fh = PT.Fun_header (loc = loc, 
                                name = PT.SS_string (PT.Name ("this")),
                                ret_type = <[ type: void ]>,
                                parms = []);
        def ttf = typed_field.ty;
        // use typed trees here to avoid problems during actual typing
        def tbody = E_assign (loc, T_void (),
                              E_static_ref (loc, ttf, typed_field), 
                              E_call (loc, ttf, E_static_ref (loc, ctor.GetMemType (), ctor), []));
        def body = <[ { $(tbody : typed) } ]>;
        def static_ctor = PT.M_function (loc = loc, 
                                         name = PT.SS_string (PT.Name ("this")),
                                         modifiers = [Mod_static ()],
                                         header = fh,
                                         kind = FK_ctor (),
                                         body = FB_parsed_expr (body));
        BindAndAddMember (static_ctor);

      | _ => Util.ice ()
    }

  }

  /**
   * Add special methods to variants and variant options. These methods
   * are used to accelerate matching over variants, allowing us to use
   * a single CE_switch statement to identify a variant options instead of 
   * a series of CE_if/CE_has_type instructions.
   *
   * Also add constant fields with single instance of parameter-less 
   * variant options.
   */
  add_special_variant_methods () : void
  {
    constant_object <- None ();

    match (tydecl) {
      | TD_variant_option when !has_fields =>
        add_constant_object_ctor ();
        add_special_variant_methods_aux ()

      | TD_variant
      | TD_variant_option => 
        add_special_variant_methods_aux ()
      
      | _ => ()
    }        
  }
  
  add_special_variant_methods_aux () : void
  {
    match (tydecl) {
      | TD_variant =>           
        DefineMember (<[ method: public abstract virtual
                                 _N_GetVariantCode () : int ; ]>);

      | TD_variant_option =>
        mutable my_index <- 0;
                       
        ignore (List.Find (variant_option_parent.GetVariantOptions (), fun (x) {
          if (x == this) true else { ++my_index; false }
        }));

        DefineMember (<[ method: public virtual _N_GetVariantCode () : int {
                                   $(my_index : int)
                                 } ]>);

      | _ => Util.ice ("add_special_variant_methods: not a variant")
    };
  }

  static this ()
  {
    infos <- [];
  }

  public ConstructTypeBuilder () : void
  {
    when (system_type == null) {
      type_builder <- Passes.cgil.ConstructTypeBuilder (this);
      system_type <- type_builder;
    }
  }

  public FinalizeType () : void
  {
    when (!cannot_finalize && type_builder != null) {
      // we cannot use CreateType() result for attribute
      // builders as it crashes mono
      ignore (type_builder.CreateType ());
      type_builder <- null;
    }
  }

  internal GetTyparms () : list <Tyvar.T>
  {
    typarms
  }

  /** Return interfaces [this] needs to implement (that is it says it will
      implement them, but they are not implemented in base class). */
  public InterfacesToImplement () : list <Tycon> 
  {
    def base_class =
      match (SuperClass ()) {
        | Some (tc) => tc
        | None => GlobalEnv.LookupInternalType (["System", "Object"])
      };

    def collect (t, acc) {
      match (t) {
        | T_app (tc, _) =>
          match (tc.GetTydecl ()) {
            | TD_interface =>
              match (base_class.SuperType (tc)) {
                | Some => acc
                | None => tc :: acc
              }
            | _ => acc
          }
        | _ => acc
      }
    };
    
    List.FoldLeft (GetSuperTypes (), [], collect);
  }

  check_ctor_constraints () : void
  {
    def check_ctors (ty : Tycon) {
      def check_ctor (member : IMember, acc) {
        match (member.GetKind ()) {
          | MK_method (meth) when meth.DeclaringType.SameAs (ty) =>
            match (meth.GetFunKind ()) {
              | FK_ctor =>
                def is_default = List.IsEmpty (meth.GetHeader ().parms);
                match (acc) {
                  | (true, _) => (true, true)
                  | _ => (is_default, true)
                }
              | _ => acc
            }
          | _ => acc
        }
      };

      List.FoldLeft (ty.GetMembers (), (false, false), check_ctor)
    };

    match (t_extends) {
      | Some (T_app (par, _)) =>
        def (_, has_ctor) = check_ctors (this);
        def (par_has_default, par_has_ctor) = check_ctors (par);
        when (!has_ctor && !par_has_default && par_has_ctor)
          Message.error ("the type `" + GetFullName () + 
                         "' has no constructors and the parent type `" + 
                         par.GetFullName () + "' has no default constructor")
      | _ => ()
    }
  }

  check_method_implements () : void
  {
    def collect (mem : IMember, acc) {
      match (mem.GetKind ()) {
        | MK_method (m) =>
          match (m.GetFunKind ()) {
            | FK_method => (m :> NemerleMethod) :: acc
            | _ => acc
          }
        | _ => acc
      }
    };
    def methods = List.FoldLeft (this.GetDirectMembers (), [], collect);
    
    // FIXME: in fact we should only mark some methods as implemented and scream
    // when signature match is ambigious
    def iface_methods = Hashtable (30);
    
    def add_iface_methods (tc : Tycon) {
      def add_method (m : IMember) {
        match (m.GetKind ()) {
          | MK_method (m) =>
            match (m.GetFunKind ()) {
              | FK_iface_method when m.DeclaringType.SameAs (tc) =>
                match (iface_methods.Get (m.Name)) {
                  | Some (lst) => iface_methods.Set (m.Name, m :: lst)
                  | None => iface_methods.Add (m.Name, [m])
                }
              | _ => ()
            }
          | _ => ()
        }
      };
      List.Iter (tc.GetMembers (), add_method)
    };
    List.Iter (InterfacesToImplement (), add_iface_methods);

    def bind_explicit_implements (meth : NemerleMethod) {
      def bind_one (name : PT.Splicable_string) {
        def name = Macros.NameOfSString (name);
        def env = name.GetEnv (this.env);
        def (ns, member) = List.DivideLast (name.idl);
        def ty = env.GetType (ns, this);
        match (iface_methods.Get (member)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              iface_meth.DeclaringType.SameAs (ty) &&
                meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] =>
                Message.fatal_error ("interface `" + ty.GetFullName () + 
                                     "' does not contain method named `" + member + 
                                     "' with proper signature")
              | [m] =>
                iface_methods.Set (member, List.Filter (meths, fun (x) { ! is_correct (x) }));
                m
              | _ =>
                Message.fatal_error ("interface `" + ty.GetFullName () + 
                                     "' contains more then one method named `" + member + 
                                     "' with proper signature")
            }
          | None =>
            Message.fatal_error ("no interface implemented by `" + this.GetFullName () + 
                                 "' contains method named `" + member + 
                                 "' (looking for `" +
                                 Util.qid_of_list (name.idl) + "')")
        }
      };
      match (meth.GetFunKind ()) {
        | FK_method (impl) =>
          def impl' =
            try List.Map (impl, bind_one)
            catch { _ : Recovery => [] };
          meth.fun_kind <- FK_bound_method (impl')
        | _ => ()
      }
    };
    List.Iter (methods, bind_explicit_implements);
    
    def bind_implicit_implements (meth : NemerleMethod) {
      def lookup_iface_members () {
        match (iface_methods.Get (meth.Name)) {
          | Some (meths) =>
            def is_correct (iface_meth : IMethod) {
              meth.GetMemType () >:> Tyutil.TypeOfMethodIn (iface_meth, this)
            };
            match (List.Filter (meths, is_correct)) {
              | [] => []
              | lst =>
                iface_methods.Set (meth.Name, 
                                   List.Filter (meths, fun (x) { ! is_correct (x) }));
                lst
            }
          | None => []
        }
      };
      match (meth.GetFunKind ()) {
        | FK_bound_method (impl) =>
          match (lookup_iface_members ()) {
            | [] => ()
            | impl' => 
              meth.fun_kind <- FK_bound_method (List.Append (impl', impl));
              meth.modifiers <- Mod_virtual () :: meth.modifiers;
          }
        | _ => ()
      }
    };
    List.Iter (methods, bind_implicit_implements);

    def scream_about_unimplemented (_, meths) {
      def scream_about (meth : IMethod) {
        Message.error ("unimplemented interface method `" + 
                       meth.DeclaringType.GetFullName () + 
                       "." + meth.Name + "' with signature " +
                       Tyutil.fun_type (meth.GetHeader ()).as_string ())
      };
      List.Iter (meths, scream_about)
    };
    iface_methods.Iter (scream_about_unimplemented);
  }


  process_macro_attributes (stage : int) : void
  {
    def lookup_macro (expr, suff) {
      match (expr) {
        | <[ $(_ : name) ]>
        | <[ $_ . $_ ]> =>
          lookup_macro (<[ $expr () ]>, suff)
        | <[ $name ( .. $parms ) ]> =>
            match (Util.qidl_of_expr (name)) {
              | Some ((id, name)) =>
                def ctx = name.GetEnv (this.env);
                def id =
                  match (List.Rev (id)) {
                    | x :: xs => List.Rev (x + suff :: xs)
                    | [] => assert (false)
                  };
                match (ctx.LookupMacro (id)) {
                  | Some (m) => Some ((name, m, parms))
                  | None => None ()
                };
              | None => None ()
            }
        | _ => None ()
      }
    };

    def process_attributes (self_parm, suff, attrs, meth : IMethod) {
      List.Iter (attrs, fun (attr) {
        | (Mod_attribute) as attr =>
          attr.attrs <-
            List.Filter (attr.attrs, fun (expr) {
              match (lookup_macro (expr, suff)) {
                | None => true
                | Some =>
                  attr.macro_attrs <- expr :: attr.macro_attrs;
                  false
              }
            });
          List.Iter (attr.macro_attrs, fun (expr) {
            match (lookup_macro (expr, suff)) {
              | None => ()
              | Some ((name, imacro, exprs)) =>
                def meth_header =
                  if (meth == null) null else meth.GetHeader ();
                def tenv = 
                  if (meth_header == null) this.tenv else meth_header.tenv;
                def in_ctor =
                  meth != null && 
                    match (meth.GetFunKind ()) {
                      | FK_ctor => true 
                      | _ => false
                    };
                def ctx =
                  TypingContext (in_ctor = in_ctor,
                                 this_ptr_decl = None (),
                                 env = this.env,
                                 tenv = tenv,
                                 current_fun = meth_header,
                                 locals = null,
                                 parent_type = this,
                                 in_tail_position = false);
                                 
                TypingContext.PushNewColor (name.color, name.GetEnv (null));
                def parms = 
                  List.Append (self_parm, imacro.CallTransform (exprs));
                def res = imacro.Run (ctx, parms);
                TypingContext.PopColor ();
                
                assert (res == null);
                ()
            }
          });
        | _ => ()
      })
    };

    def process_member (mem, stage_suff) {
      match (mem) {
        | PT.M_field =>
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxField (mem)],
                              ":field" + stage_suff, mem.modifiers, null)
        | (PT.M_function) as fn =>
          def (was_parsed, body) =
            match (fn.body) {
              | FB_parsed_expr (b) => (true, b)
              | FB_extern
              | FB_abstract => (false, <[ () ]>)
              | _ => assert (false)
            };
          def decl = PT.Function_decl (fn.header, body);
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxFunDecl (decl)],
                              ":method" + stage_suff, mem.modifiers, null);
          when (was_parsed) {
            fn.body <- FB_parsed_expr (decl.body);
          };
          
        | PT.M_type => ()

        | PT.M_property =>
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxProperty (mem)],
                              ":property" + stage_suff, mem.modifiers, null)

        | PT.M_event => 
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxEvent (mem)],
                              ":event" + stage_suff, mem.modifiers, null)
      }
    };

    def iter_decls (stage_suff) {
      def decls =
        match (pt_tydecl) {
          | PT.TD_class (ds)
          | PT.TD_interface (ds)
          | PT.TD_variant (ds)
          | PT.TD_variant_option (ds) => ds
          | _ => []
        };
      def f (x) { process_member (x, stage_suff) };
      List.Iter (decls, f);
      List.Iter (additional_decls, f);
    };

    def process_typed_member (mem : IMember) {
      match (mem.GetKind ()) {
        | MK_field (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                               PT.SyntaxTField ((f :> NemerleField))],
                              ":field:postadd", f.GetModifiers (), null)
        | MK_method (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                               PT.SyntaxTMethod ((f :> NemerleMethod))],
                              ":method:postadd", f.GetModifiers (), f)
                              
        | MK_property (f) =>
          process_attributes ([PT.SyntaxTTycon (this),
                               PT.SyntaxTProperty ((f :> NemerleProperty))],
                              ":property:postadd", f.GetModifiers (), null)

        | MK_event (f) =>
          process_attributes ([PT.SyntaxTTycon (this), PT.SyntaxTEvent ((f :> NemerleEvent))],
                              ":event:postadd", f.GetModifiers (), null)

        | MK_type => ()
      }
    };

    match (stage) {
      | 1 =>
        process_attributes ([PT.SyntaxTTycon (this)], 
                            ":type:postscan", modifiers, null);
        iter_decls (":postscan");

      | 2 =>
        process_attributes ([PT.SyntaxTTycon (this)], 
                            ":type:preadd", modifiers, null);
        iter_decls (":preadd");
        
      | 3 =>
        process_attributes ([PT.SyntaxTTycon (this)], 
                            ":type:postadd", modifiers, null);
        List.Iter (GetDirectMembers (), process_typed_member);

      | _ => assert (false)
    }
  }


  /**
   * Main function of type declaration handling pass.
   *
   * <remarks>
   *   - constructing typing environments [Tyinfo.make_tyenvs]
   *   - binding types [Tyinfo.bind_types]
   *   - determining subtyping relations [Tyinfo.determine_subtyping]
   *   - checking subtyping constraints on types that are already bound
   *     [Tyinfo.check_bound_types]
   *   - adding members [Tyinfo.add_members]
   *   - adding the variant/variant option special matching methods
   * </remarks>
   */
  public static Run () : void
  {
    infos <- List.Rev (infos);
    run_phase <- 1;

    List.Iter (infos, fun (x : Tyinfo) {
      Util.locate (x.loc, x.process_macro_attributes (1))
    });

    SourceTopIter (fun (x : Tyinfo) { 
                      x.make_tyenvs (Tyvar.TEnv ()) 
                    });
    def bind_types (x : Tyinfo) {
      Util.locate (x.loc, x.bind_types ())
    };
    
    run_phase <- 2;
    List.Iter (List.Rev (infos), bind_types);

    run_phase <- 3;
    determine_subtyping ();
    
    run_phase <- 4;
    Iter (fun (x : Tyinfo) { x.check_bound_types () });

    run_phase <- 5;
    
    Iter (fun (x : Tyinfo) { x.process_macro_attributes (2) });

    Iter (fun (x : Tyinfo) { x.add_members () });

    Iter (fun (x : Tyinfo) { x.process_macro_attributes (3) });
    
    Iter (fun (x : Tyinfo) { x.add_special_variant_methods () });

    def check_method_implements (ti : Tyinfo) {
      match (ti.GetTydecl ()) {
        | TD_interface => ()
        | _ => ti.check_method_implements ()
      }
    };

    Iter (check_method_implements);

    Iter (fun (x : Tyinfo) { x.check_ctor_constraints () });
  }

  internal FixupDefinedClass () : void
  {
    // finalization is blocked until call to Compile
    this.cannot_finalize <- true;
    this.contained_types <- [];
    this.constant_object <- None ();
    when (run_phase >= 1)
      match (enclosing_type) {
        | Some (ti) =>
          make_tyenvs (ti.tenv)
        | None =>
          make_tyenvs (Tyvar.TEnv ())
      };
    when (run_phase >= 2)
      Util.locate (loc, bind_types ());
    when (run_phase >= 3)
      construct_subtyping_map ();
    when (run_phase >= 4)
      check_bound_types ();
    when (run_phase >= 5)
      begin_adding_members ();
  }


  public AddImplementedInterface (t : PT.Type) : void
  {
    pt_tydecl.t_extends <- List.Append (pt_tydecl.t_extends, [t])
  }
  

  public DefineNestedClass (attrs : list <Modifier>,
                            name : list <string>,
                            typarms : PT.Typarms,
                            extends_list : list <PT.Type>) : ITypeModifier
  {
    def ti = env.EnterIntoNamespace (name).DefineClass (Some (this), attrs, 
                                                        name, typarms, extends_list);
    contained_types <- (ti :> Tyinfo) :: contained_types;
    ti
  }

  public DefineMethod (attrs : list <Modifier>,
                       header : PT.Fun_header,
                       body : PT.Expr,
                       implemented_methods : list <list <string>>) : void
  {
    def wear_ss_suit (x : list <string>) { PT.SS_string (PT.Name (x)) };
    def kind =
      if (List.Head (Macros.UnSString (header.name)) == ".ctor")
        FK_ctor ()
      else
        FK_method (List.Map (implemented_methods, wear_ss_suit));
    def f = PT.M_function (header.name, attrs, header, kind, FB_parsed_expr (body));
    if (member_map == null)
      additional_decls <- f :: additional_decls
    else {
      try {
        def mem = bind_and_add_member (f);
        Passes.cgil.MemberAdded (this, mem);
      } catch {
        | _ : Recovery => ()
      }
    }
  }

  public DefineMember (f : PT.Class_member) : void
  {
    if (member_map == null)
      additional_decls <- f :: additional_decls
    else {
      try {
        def mem = bind_and_add_member (f);
        Passes.cgil.MemberAdded (this, mem);
      } catch {
        | _ : Recovery => ()
      }
    }
  }

  
  public Compile () : void
  { 
    cannot_finalize <- false;
    when (type_builder != null) {
      this.FinalizeType ();
      Passes.MarkTyinfoCompiled ();
    }
  }


  /** Nemerle.Reflection  interfaces */
  
}

} // ns
