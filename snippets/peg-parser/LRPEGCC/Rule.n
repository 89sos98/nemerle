using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace LRPEGCC
{
  [Record] 
  internal class RuleRef : Located, IComparable[RuleRef]
  {
    [Accessor] id : string;

    public override ToString() : string
    {
      id
    }

    public override GetHashCode() : int
    {
      id?.GetHashCode()
    }

    public CompareTo(other : RuleRef) : int
    {
      StringComparer.Ordinal.Compare(this.id, other?.id)
    }

    [Nemerle.OverrideObjectEquals]
    public Equals(_ : RuleRef) : bool
    {
      | null => false
      | other => other.id == this.id
    }
  }

  internal variant RuleType
  {
    | List   { ty : RuleType; }
    | Option { ty : RuleType; }
    | Tuple  { types : list[RuleType]; }
    | NType  { ty : PExpr; }
    | Chars
    | None
    | Void

    public override ToString() : string
    {
      match (this)
      {
      | List(ty)     => $<#[$ty]#>
      | Option(ty)   => $<#$ty?#>
      | Tuple(types) => $<#(..$(types, ", "))#>
      | NType(ty)    => $<#{$ty}#>
      | Chars        => "Chars"
      | None         => "None"
      | Void         => "Void"
      }
    }
  }

  internal variant CaptureKind
  {
    | Handler  { name : RuleRef; argType : RuleType; retType : RuleType; }
    | Argument { retType : RuleType; }

    public override ToString() : string
    {
      match (this)
      {
      | Handler(name, at, rt) => $"H#$name : $at -> $rt"
      | Argument(ty)          => $"A#$ty"
      }
    }
  }

  internal variant Rule
  {
    | Choice         { rules : list[Rule]; }
    | Sequence       { rules : list[Rule]; }
    | Call           { name : RuleRef; }
    | RepeatMin      { minCount : int; rule : Rule; }
    | RepeatMinMax   { minCount : int; maxCount : int; rule : Rule; }
    | Chars          {
                         chars : list[RangeSet];
                         public IsString : bool { get { chars.ForAll(_.IsSinglCharCheck) } }
                     }
    | Fsm            { fsm : FSM; }
    | Not            { rule : Rule; }
    | And            { rule : Rule; }
    | Capture        { kind : CaptureKind; rule : Rule; }
    | ExtensionPoint { name : RuleRef; }
    | Scope          { name : RuleRef; rule : Rule; }

    /*public Walk(func : Rule -> Rule) : Rule
    {
      def loop(rule : Rule) : Rule
      {
        def rule2 = func(rule);
        match (rule2)
        {
          | Choice(rules)                 => Choice(rules.Map(loop))
          | Sequence(rules)               => Sequence(rules.Map(loop))
          | RepeatMin(x, rule)            => RepeatMin(x, loop(rule))
          | RepeatMinMax(min, max, rule)  => RepeatMinMax(min, max, loop(rule))
          | Not(rule)                     => Not(loop(rule))
          | And(rule)                     => And(loop(rule))
          | Capture(kind, rule)           => Capture(kind, loop(rule))
          | Scope(name, rule)             => Scope(name, loop(rule))
          | Call | Chars | ExtensionPoint | Fsm => rule2
        }
      }
      loop(this)
    }*/

    public Priority : int
    {
      get
      {
        match (this)
        {
          | Scope                       => 5
          | Chars                       => 5
          | Fsm                         => 5
          | Capture                     => 5
          | ExtensionPoint              => 5
          | Call                        => 5
          | RepeatMin                   => 4
          | RepeatMinMax                => 4
          | Not                         => 3
          | And                         => 3
          | Sequence                    => 2
          | Choice                      => 1
        }
      }
    }

    public override ToString() : string
    {
      def p(rule : Rule)
      {
        if (rule.Priority <= this.Priority)
          $"($rule)"
        else
          rule.ToString()
      }

      match (this)
      {
        | Scope(name, rule)                              => $<#$name { $rule }#>
        | Choice(rules)                                  => $<#..$(rules; " / "; p)#>
        | Sequence(rules)                                => $<#..$(rules; " "; p)#>
        | Call(name)                                     => name.Id
        | RepeatMin(0, rule)                             => $"$(p(rule))*"
        | RepeatMin(1, rule)                             => $"$(p(rule))+"
        | RepeatMin(x, rule)                             => $"$RepeatMin($x, $rule)"
        | RepeatMinMax(0, 1, rule)                       => $"$(p(rule))?"
        | RepeatMinMax(min, max, rule)                   => $"$RepeatMin($min, $max, $rule)"
        | Chars([chars])                                 => $"[$chars]"
        | Chars(chars) as c when c.IsString              => $<#'..$(chars; ""; r => $"$(r.Ranges.Head.from)")'#>
        | Chars(chars)                                   => $<#(..$(chars; ", "; ch => $"[$ch]"))#>
        | Fsm                                            => "FSM"
        | Not(rule)                                      => $"!$(p(rule))"
        | And(rule)                                      => $"&$(p(rule))"
        | Capture(CaptureKind.Argument(ty), rule)        => $"CaptureA[$ty]($rule)"
        | Capture(CaptureKind.Handler(name, _, _), rule) => $"CaptureH[$name]($rule)"
        | ExtensionPoint(name)                           => $"ExtensionPoint($name)"
      }
    }
  }
}
