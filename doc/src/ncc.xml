<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>High-level <tt>ncc</tt> description</title>
  <section id="main">
    <title>The main file</title>
    <body>
      <p>
        The main compiler file is <file>main.cs</file>, but all it does it
        running parser (<file>parser.jay</file>) and transferring control
        to <tt>Passes.run</tt> function (from <file>passes.n</file>).
      </p>
      <p>
        Main file also catches some exceptions, and defines some auxiliary
        functions (class <tt>CS_glue</tt>, these are later referenced from
        <file>csglue.n</file>).
      </p>
      <p>
        <tt>Passes.run</tt> runs several functions, that are described
        (in order of calling) in later sections of this document.
      </p>
    </body>
  </section>
  <section id="scan_globals">
    <title>Scan globals</title>
    <body>
      <p>
        This is done in <file>scan_globals.n</file>. It changes
        <tt>open</tt>/<tt>namespace</tt> declaration into appropriate
        entries in <tt>Env</tt> class.  It also creates <tt>Tyinfo</tt>
        object for each type and registers it with global name
        environment.
      </p>
    </body>
  </section>
  <section id="tyinfo">
    <title>Type processing</title>
    <body>
      <p>
        This pass operates on <tt>Tyinfo</tt> objects created for each
        type declaration found in source files. These objects are already
        created, but most fields are empty. The main function of this pass
        is <tt>Tyinfo.run</tt>. All function described in this section can
        be found in <file>tyinfo.n</file>.
      </p>
    </body>
    <subsection id="bind_tv">
      <title>Binding type variables</title>
      <body>
        <p>
          The first thing to do is to create typing environment
          <tt>Tyvar.TEnv</tt> for each type declaration. Then typing
          environment is populated with type variables (transformed
          into <tt>Tyvar.T</tt> objects).  Finally constraints (type
          expressions, which are first bound) of each type variable are
          stored in <tt>Tyvar.T</tt>.
        </p>
        <p>
          Typing environment maps names of type variables to
          <tt>Tyvar.T</tt> objects.
        </p>
      </body>
    </subsection>
    <subsection id="bind_tyex">
      <title>Binding type expressions</title>
      <body>
        <p>
          Next we need to bind type expressions occurring in
          type declarations.  This includes <tt>extends</tt> type,
          <tt>implements</tt> list, and aliased type in case of type
          alias declaration.
        </p>
        <p>
          Binding type expression refers to rewriting
          <tt>Parsetree.Type</tt> into <tt>Typedtree.Type</tt>,
          which involves resolving names of type constructors (to
          <tt>Tyinfo</tt> objects) and type variables (to <tt>Tyvar.T</tt>
          objects).
        </p>
      </body>
    </subsection>
    <subsection id="det_subt">
      <title>Determining subtyping relations</title>
      <body>
        <p>
          This probably the hardest part of processing type declarations.
        </p>
        <p>
          Each type directly subtypes types it extends or implements.
          This pass computes transitive closure of direct
          subtyping relation and stores it <tt>Tyinfo.subtypes</tt>
          map. <tt>.NET</tt> generics doesn't allow same type to be
          subtyped under different instantiations, so we use map from
          (id of) subtyped <tt>Tyinfo</tt> object to actual parameters
          of subtyped type.
        </p>
        <p>
          Since this point during type binding we can
          check if subtyping constraints are satisfied upon
          instantiations of types.  This is reflected by setting
          <tt>Tyinfo.can_check_constraints</tt> variable.  We also check
          it for unsatisfied constraints in already bound types in the
          beginning of <tt>Tyinfo.make_member_list</tt> function.
        </p>
      </body>
    </subsection>
    <subsection id="make_member_list">
      <title>Constructing lists of members</title>
      <body>
        <p>
          <tt>Tyinfo.make_member_list</tt> function collects type
          members (fields and methods, but not types, which are already
          collected in <tt>Tyinfo.contained_types</tt>) and stores it
          in <tt>Tyinfo.member_list</tt> fields.
        </p>
        <p>
          Members are first transferred from <tt>Parsetree</tt> into
          <tt>Typedtree</tt> namespace by binding appropriate types.
        </p>
      </body>
    </subsection>
    <subsection id="make_impl_ctor">
      <title>Making implicit constructors</title>
      <body>
        <p>
          <tt>Tyinfo.add_implicit_ctor</tt> adds record-like
          constructor (<tt>this (x, y) { this.x &lt;- x; this.y &lt;-
          y }</tt>) to some classes. Constructor building is in
          <file>extensions.n</file>.
        </p>
      </body>
    </subsection>
    <subsection id="make_member_map">
      <title>Constructing member maps</title>
      <body>
        <p>
          <tt>Tyinfo.make_member_map</tt> constructs maps from names
          to non-static fields and methods in given type (including
          derived ones).  This is used later in typing.
        </p>
      </body>
    </subsection>
  </section>
    <!-- 
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
