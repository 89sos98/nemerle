/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree; 

namespace Nemerle.Compiler {

public module Tyops {
  internal @/- (t : TType, s : Subst) : TType = extern "Nemerle.Compiler.Tyutil.subst";
  public @>:> (x : TType, y : TType) : bool = extern "Nemerle.Compiler.Tyutil.subtypes";
}
  
variant TvValue
{
  | Unspecified
  | Free
  | FreeFromNull
  | AtMost { t : TType; }
  | Exactly { t : TType; }
}

#if !NTE
type Subst = SystemMap [int, TvValue];
#endif

public module Tyutil {

  public GetTypeTypeInfo (t : TType) : TypeInfo
  {
    match (top_expand (t)) {
      | TType.Class (tc, _) => tc
      | _ => null
    }
  }
  
  internal subst (t : TType, s : Subst) : TType
  {
    if (s.IsEmpty)
      t
    else {
      def self (t : TType) : TType { subst (t, s) };
      match (t) {
        | TType.ByRef (t) => TType.ByRef (subst (t, s))
        | TType.Out (t) => TType.Out (subst (t, s))
        | TType.Array (t, rank) => TType.Array (subst (t, s), rank)
        | TType.Function (tl, t) => TType.Function (subst (tl, s), subst (t, s))
        | TType.Void => t
        | TType.Product (tl) => TType.Product (List.Map (tl, self))
        | TType.Class (ti, args) =>
          TType.Class (ti, List.Map (args, self))
        | TType.Variable (tv) =>
          def self (_) {
            | TType.Variable (tv2) when tv.id == tv2.id => assert (false)
            | t' => subst (t', s)
          };
          match (s.Find (tv.id)) {
            | Some (TvValue.AtMost (t'))
            | Some (TvValue.Exactly (t')) => t'
            | _ =>
              match (tv.value) {
                | TvValue.AtMost (t') =>
                  tv.value = TvValue.Exactly (t');
                  self (t')
                | TvValue.Exactly (t') =>
                  self (t')
                | _ => t
              }
          }
      }
    }
  }
  
  tv_value (s : Subst, tv : Tyvar.T) : TvValue
  {
    match (s.Find (tv.id)) {
      | Some (r) => r
      | None => tv.value
    }
  }

  public top_expand (t : TType) : TType 
  {
    def (s, t) = top_expand (SystemMap (), t, false);
    Tyvar.global_store (s);
    t
  }

  top_expand (s : Subst, t : TType, stop : bool) : Subst * TType
  {
    match (t) {
      | TType.Class (ti, args) =>
        match (ti.GetTydecl ()) {
          | TypeDeclaration.Alias (t) =>
            top_expand (s, t /- ti.MakeSubst (args), stop)
          | _ => (s, t)
        }
        
      | TType.Variable (tv) =>
        match (tv_value (s, tv)) {
          | TvValue.Exactly (t) => top_expand (s, t, stop)
          | TvValue.AtMost (t) when !stop =>
            top_expand (s.Replace (tv.id, TvValue.Exactly (t)), t, stop)
          | _ => (s, t)
        }
        
      | _ => (s, t)
    }
  }

  common_supertypes (ti1 : TypeInfo, a1 : list [TType], ti2 : TypeInfo,
                     a2 : list [TType]) : list [TType]
  {
    def ht = Hashtable ();

    def s1 = ti1.MakeSubst (a1);
    def s2 = ti1.MakeSubst (a2);

    foreach (t : TType.Class in ti1.GetSuperTypes ())
      unless (t.tycon.Equals (InternalType.Object_tc))
        ht.Add (t.tycon.GetId (), t /- s1);

    List.FoldLeft (ti2.GetSuperTypes (), [], fun (t, acc) {
      match (top_expand (t)) {
        | (TType.Class (ti, _)) as t =>
          match (ht.Get (ti.GetId ())) {
            | Some (t') =>
              match (unify (s2, t, t', false)) {
                | Some (s) => (t /- s) :: acc
                | None => acc
              }
            | None => acc
          }
        | _ => assert (false)
      }
    })
  }

  
  internal maximal_common_supertypes (s : Subst, t1 : TType, t2 : TType) : list [TType]
  {
    //Message.debug ("mcs unify");
    def maximal_types (types)
    {
      List.FoldLeft (types, [], fun (t, max) {
        def is_bigger_then_t (t') {
          Option.IsSome (unify (t', t, true))
        };
        
        if (List.Exists (max, is_bigger_then_t))
          max
        else
          t :: max
      })
    }

    match (unify (s, t1, t2, true)) {
      | Some => [t2]
      | None =>
        match (unify (s, t2, t1, true)) {
         | Some => [t1]
         | None =>
            match ((top_expand (t1 /- s), top_expand (t2 /- s))) {
              | (TType.Class (ti1, a1), TType.Class (ti2, a2)) =>
                maximal_types (common_supertypes (ti1, a1, ti2, a2))
              | _ => []
            }
        }
    }
  }

  try_subst (s : Subst, tv : Tyvar.T, t2 : TType, is_at_most : bool) : option [Subst]
  {
    //Message.debug ("ccs");
    def check_constraint (c : TType, s : option [Subst]) {
      match (s) {
        | None => None ()
        | Some (s) =>
          //Message.debug ("check_constraint unify");
          unify (s, t2, c, true)
      }
    };

    def occur_check (_) {
      | TType.ByRef (t)
      | TType.Out (t)
      | TType.Array (t, _) => 
        occur_check (t)
      | TType.Function (t1, t2) => 
        occur_check (t1) || occur_check (t2)
      | TType.Void => false
      | TType.Product (tl)
      | TType.Class (_, tl) => List.Exists (tl, occur_check)
      | TType.Variable (tv') when tv.id == tv'.id => true
      | TType.Variable (tv) =>
        match (tv_value (s, tv)) {
          | TvValue.AtMost (t)
          | TvValue.Exactly (t) => occur_check (t)
          | _ => false
        };
    };

    match (tv_value (s, tv)) {
      | TvValue.FreeFromNull when t2.IsValueType => None ()
      | TvValue.FreeFromNull
      | TvValue.Free 
      | TvValue.AtMost =>
        if (occur_check (t2))
          None ()
        else {
          def repl =
            if (is_at_most) TvValue.AtMost (t2) 
            else TvValue.Exactly (t2);
          List.FoldLeft (tv.GetConstraints (),
                         Some (s.Replace (tv.id, repl)),
                         check_constraint)
        }
      | TvValue.Exactly => assert (false)
      | TvValue.Unspecified => assert (false)
    }
  }

  unify_tyvars (s : Subst, t1 : TType, t2 : TType, allow_subtyping : bool) : option [Subst]
  {
    def check_at_most_intro () {
      match ((t1, t2)) {
        | (t, TType.Variable (tv)) when allow_subtyping =>
          match (tv_value (s, tv)) {
            | TvValue.Free
            | TvValue.FreeFromNull =>
              try_subst (s, tv, t, true)
              
            | TvValue.AtMost (t') =>
              match (maximal_common_supertypes (s, t, t')) {
                | [] => None ()
                | [max] =>
                  def s = Option.UnSome (unify (s, t, max, true));
                  def s = Option.UnSome (unify (s, t', max, true));
                  match (tv_value (s, tv)) {
                    | TvValue.Exactly => None ()
                    | TvValue.AtMost =>
                      try_subst (s, tv, max, true)
                    | _ => assert (false)
                  }
                | _ => None ()
              }
              
            | TvValue.Exactly => assert (false)
            
            | TvValue.Unspecified => None ()
          }

        | _ => None ()
      }
    };

    def check_simple_unification (t1, t2) {
      match (t1) {
        | TType.Variable (tv) =>
          match (tv_value (s, tv)) {
            | TvValue.Free
            | TvValue.FreeFromNull =>
              try_subst (s, tv, t2, false)
            | _ => None ()
          }
        | _ => None ()
      }
    };

    def check_at_most_kill (t1, t2) {
      match (t1) {
        | TType.Variable (tv) =>
          match (tv_value (s, tv)) {
            | TvValue.AtMost (t) =>
              match (try_subst (s, tv, t, false)) {
                | Some (s) =>
                  unify (s, t, t2, true)
                | None => None ()
              }
            | _ => None ()
          }
        | _ => None ()
      }
    };

    def check_list (_) : option [Subst] {
      | f :: fs =>
        //Message.debug (sprintf("method %d", List.Length (fs)));
        match ((f : void -> option [Subst]) ()) {
          | (Some) as r => r
          | None => check_list (fs)
        }
      | [] => None ()
    };

    //Message.debug ("unify tv");
    
    check_list ([check_at_most_intro, 
                 fun () { check_simple_unification (t1, t2) },
                 fun () { check_simple_unification (t2, t1) },
                 fun () { check_at_most_kill (t1, t2) },
                 fun () { check_at_most_kill (t2, t1) }
                ])
  }


  // t1 :> t2 (or t1 =? t2)
  internal unify (s : Subst, t1 : TType, t2 : TType, allow_subtyping : bool) : option [Subst]
  {
    def unify_lists (s, t1, t2, allow_subtyping) {
      match ((t1, t2)) {
        | (t1 :: ts1, t2 :: ts2) =>
          match (unify (s, t1, t2, allow_subtyping)) {
            | Some (s') => unify_lists (s', ts1, ts2, allow_subtyping)
            | None => None ()
          }
        | ([], []) => Some (s)
        | _ => None ()
      }
    };

    def alterable (tv) {
      match (tv_value (s, tv)) {
        | TvValue.Free
        | TvValue.FreeFromNull
        | TvValue.AtMost => true
        | _ => false
      }
    };
    

    //def sign = if (allow_subtyping) " :> " else " =? ";
    //Message.debug ("(((unify " + string_of_type (t1) + sign + string_of_type (t2));
    def (s, t1) = top_expand (s, t1, true);
    def (s, t2) = top_expand (s, t2, true);
    //Message.debug ("  --> " + string_of_type (t1) + sign + string_of_type (t2));

    def res =

    match ((t1, t2)) {
      | (TType.Array (t1, rank1), TType.Array (t2, rank2)) when rank1 == rank2 =>
        unify (s, t1, t2, false) // no array covariance
      | (TType.Array (_, _), TType.Class (ti2, [])) when allow_subtyping && 
                                            ti2.Equals (InternalType.Array_tc) => 
        Some (s)
        
      | (TType.Product (l1), TType.Product (l2)) => 
        unify_lists (s, l1, l2, allow_subtyping)

      | (TType.Void, TType.Void) => Some (s)
                              
      | (TType.Function (a1, r1), TType.Function (a2, r2)) =>
        match (unify (s, r1, r2, allow_subtyping)) {
          | Some (s) => unify (s, a2, a1, allow_subtyping)
          | None => None ()
        }

      | (_, TType.Class (ti2, [])) when allow_subtyping && 
                                  ti2.Equals (InternalType.Object_tc) =>
        Some (s)

      | (TType.Class (ti1, a1), TType.Class (ti2, a2)) when ti1.Equals (ti2) =>
        unify_lists (s, a1, a2, false)

      | (TType.Class (ti1, a1), TType.Class (ti2, _)) when allow_subtyping =>
        match (ti1.SuperType (ti2)) {
          | Some (args) => 
            //Message.debug ("unify <: " + ti1.FullName + " " + ti2.FullName);
            unify (s, ti2.GetMemType () 
                        /- ti2.MakeSubst (args) 
                        /- ti1.MakeSubst (a1), t2, true)
          | None => None ()
        }

      | (TType.Variable (tv1), TType.Variable (tv2)) when tv1.id == tv2.id => Some (s)
      
      // don't let this case down, we don't want tv1's constraints to
      // mess with tv2
      | (_, TType.Variable (tv2)) when alterable (tv2) =>
        unify_tyvars (s, t1, t2, allow_subtyping)
        
      | (TType.Variable (tv), _) when allow_subtyping =>
        // check to see if any of our constraints is enough
        def check_constraints (cs) {
          match (cs) {
            | [] => unify_tyvars (s, t1, t2, allow_subtyping)
            | c :: cs =>
              //Message.debug ("solved-by-constraint unify");
              match (unify (s, c, t2, true)) {
                | Some (r) => 
                  //Message.debug ("hit scu");
                  Some (r)
                | None => check_constraints (cs)
              }
          }
        };
        check_constraints (tv.GetConstraints ())
      
      | _ => 
        unify_tyvars (s, t1, t2, allow_subtyping)
    };
   
   /*
    match (res) {
      | Some (s) =>
        Message.debug ($ "res = $(t1 /- s) $(t2 /- s) )))");
      | None =>
        Message.debug ("failed )))");
    };
    */

    res
  }

  internal unify (t1 : TType, t2 : TType, allow_subtyping : bool) : option [Subst] 
  {
    unify (SystemMap (), t1, t2, allow_subtyping)
  }
  
  internal unify (t1 : TType, t2 : TType) : option [Subst]
  {
    unify (SystemMap (), t1, t2, false) 
  }
 
  // FIXME: this might be broken (if there are free variables in types to
  // begin with)
  public types_eq (a : TType, b : TType) : bool
  {
    match (unify (a, b)) {
      | Some => true
      | None => false
    }
  }

  public types_eq_store (a : TType, b : TType) : bool
  {
    match (unify (a, b)) {
      | Some (subst) => Tyvar.global_store (subst); true
      | None => false
    }
  }


  // check if a :> b and if so, incorporate substitution into
  // global context
  public subtypes (a : TType, b : TType) : bool 
  {
    match (unify (a, b, true)) {
      | Some (s) => { Tyvar.global_store (s); true }
      | None => false
    }
  }

  public string_of_type (t : TType) : string
  {
    def f (lev, t) {
      match (t) {
        | _ when lev > 20 => "..."
        | TType.Class (ti, args) =>
          def name = ti.FullName;
          match (name) {
            | "Nemerle.Core.string"
            | "System.String" => "string"
            | "Nemerle.Core.int"
            | "System.Int32" => "int"
            | "Nemerle.Core.float"
            | "System.Single" => "float"
            | "Nemerle.Core.char"
            | "System.Char" => "char"
            | "Nemerle.Core.bool"
            | "System.Boolean" => "bool"
            | _ => 
              match (args) {
                | [] => name
                | _ => name + " [" + map (lev + 1, ", ", args) + "]"
              }
          }
        | TType.Variable (tv) =>
          match (tv.value) {
            | TvValue.Unspecified =>
              sprintf ("%s_%d", tv.name, tv.id)
            | TvValue.Free
            | TvValue.FreeFromNull =>
              sprintf ("%s_%d*", tv.name, tv.id)
            | TvValue.AtMost (t) =>
              f (lev + 1, t) + "+"
            | TvValue.Exactly (t) =>
              f (lev + 1, t) + "@"
          }
        | TType.ByRef (t) => "ref " + f (lev + 1, t)
        | TType.Out (t) => "out " + f (lev + 1, t)
        | TType.Void => "void"
        | TType.Product (args) => 
          "(" + map (lev + 1, " * ", args) + ")"
        | TType.Function (from, to) =>
          f (lev + 1, from) + " -> " + f (lev + 1, to)
        | TType.Array (t, 1) => "array [" + f (lev + 1, t) + "]"
        | TType.Array (t, rank) => "array * "+ sprintf ("%d", rank) + " [" + f (lev + 1, t) + "]"
      };
    }
    and map (lev, sep, args) {
      NString.Concat (sep, List.Map (args, fun (x) { f (lev, x) }))
    };

    f (0, t);
  }


  // Given function declaration, construct its type.
  public fun_type (h : Fun_header) : TType
  {
    match (List.Map (h.parms, fun (p : Fun_parm) : TType { p.ty })) {
      | [x] => TType.Function (x, h.ret_type)
      | [] => TType.Function (TType.Void (), h.ret_type)
      | l => TType.Function (TType.Product (l), h.ret_type)
    }
  }

  public fun_args (from : TType) : list [TType]
  {
    match (top_expand (from)) {
      | TType.Product (a) => a
      | TType.Void => []
      | t => [t]
    }
  }

  /**
   * Return set of maximal types (with respect to the [:>] ordering).
   * TTypes can have any additional information attached.
   */
  public maximal_types['a] (types : list [TType * 'a]) : list [TType * 'a]
  {
    def is_worse (t1 : TType, t2 : TType) : bool {
      match ((unify (t1, t2, true), unify (t2, t1, true))) {
        | (Some, None) => false
        | _ => true
      }
    };

    def loop (did : bool, acc : list [TType * 'a], lst : list [TType * 'a]) : list [TType * 'a] {
      match (lst) {
        | (ty, data) :: xs =>
          def f = fun (t : TType, _ : 'a) : bool { is_worse (ty, t) };
          def acc' = List.Filter (acc, f);
          def did = did || List.Length (acc') != List.Length (acc);
          loop (did, (ty, data) :: acc, List.Filter (xs, f))
        | [] =>
          // fixpoint iteration
          if (did) loop (false, [], acc)
          else acc
      }
    };

    loop (false, [], types)
  }

  /*
   * Compute common type of two branches of some expression.
   *
   * If [t = unify_branches (t1, t2)] then [t1 :> t && t2 :> t].
   *
   * In case of [!(t1 :> t2) && !(t2 :> t1)] we unify only options of
   * the same variant.
   */
  public unify_branches (t1 : TType, t2 : TType) : option [TType]
  {
    match (unify (t1, t2, true)) {
      | Some (s) => Tyvar.global_store (s); Some (t2)
      | None =>
        match (unify (t2, t1, true)) {
         | Some (s) => Tyvar.global_store (s); Some (t1)
         | None =>
            match ((top_expand (t1), top_expand (t2))) {
              | (TType.Class (ti1, a1), TType.Class (ti2, a2)) =>
                match ((ti1.GetTydecl (), ti2.GetTydecl ())) {
                  | (TypeDeclaration.VariantOption, TypeDeclaration.VariantOption) when 
                    Option.UnSome (ti1.SuperClass ()).Equals (Option.UnSome (ti2.SuperClass ())) =>
                    match (unify (TType.Product (a1), TType.Product (a2))) {
                      | Some (s) =>
                        Tyvar.global_store (s);
                        Some (TType.Class (Option.UnSome (ti1.SuperClass ()), a1))
                      | None => None ()
                    }
                  | _ => None ()
                }
              | _ => None ()
            }
        }
    }
  }

  public TypeOfMemberIn (mem : IMember, tc : TypeInfo) : TType
  {
    mem.GetMemType () /- tc.SubtypingSubst (mem.DeclaringType)
  }
  
  public TypeOfMethodIn (mem : IMethod, tc : TypeInfo) : TType 
  {
    mem.GetFreshType () /- tc.SubtypingSubst (mem.DeclaringType)
  }
  
  public FrameworkTypeName (tc : TypeInfo) : string
  {
    def par = tc.DeclaringType;
    if (par == null)
      tc.FullName
    else
      FrameworkTypeName (par) + "+" + tc.Name
  }


  public AccessibilityIntersect (a1 : Accessibility, 
                                 a2 : Accessibility) : Accessibility
  {
    match ((a1, a2)) {
      | (Accessibility.Private, _)
      | (_, Accessibility.Private) => Accessibility.Private
      | (Accessibility.Internal, Accessibility.Protected)
      | (Accessibility.Protected, Accessibility.Internal)
      | (_, Accessibility.ProtectedAndInternal)
      | (Accessibility.ProtectedAndInternal, _) => Accessibility.ProtectedAndInternal
      | (_, Accessibility.Protected)
      | (Accessibility.Protected, _) => Accessibility.Protected
      | (_, Accessibility.Internal)
      | (Accessibility.Internal, _) => Accessibility.Internal
      | (_, Accessibility.ProtectedOrInternal)
      | (Accessibility.ProtectedOrInternal, _) => Accessibility.ProtectedOrInternal
      | (Accessibility.Public, Accessibility.Public) => Accessibility.Public
    }
  }

  /// Check if [access] doesn't grant more access than any of tycons in [t].
  public CheckAccessibility (what : IMember, access : Accessibility, t : TType) : void
  {
    match (t) {
      | TType.Class (tc, parms) =>
        if (AccessibilityIntersect (tc.Accessibility, access) != access &&
            !what.DeclaringType.Equals (tc))
          Message.error ($ "$what is more accessible than `$(tc)'")
        else
          foreach (t in parms) CheckAccessibility (what, access, t)
      | TType.Variable | TType.Void => ()
      | TType.ByRef (t) | TType.Out (t) | TType.Array (t, _) =>
        CheckAccessibility (what, access, t)
      | TType.Function (t1, t2) =>
        CheckAccessibility (what, access, t1);
        CheckAccessibility (what, access, t2)
      | TType.Product (parms) =>
        foreach (t in parms) CheckAccessibility (what, access, t)
    }
  }


  public IsDelegate (ty : TType) : bool
  {
    match (Tyutil.top_expand (ty)) {
      | TType.Class (tc, _) =>
        Option.IsSome (tc.SuperType (InternalType.Delegate_tc))
      | _ => false
    }
  }

  /**
   * Remove any level of tyalias indirections from given type.
   */
  internal unalias (ti : TypeInfo) : TypeInfo
  {
    match (ti.GetTydecl ()) {
      | TypeDeclaration.Alias (TType.Class (tc, _)) => unalias (tc)
      | TypeDeclaration.Alias (_) => assert (false)
      | _ => ti
    }
  }
}

} // ns
