%
% Copyright (c) 2003 The University of Wroclaw.
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
%    1. Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%    2. Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%    3. The name of the University may not be used to endorse or promote
%       products derived from this software without specific prior
%       written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
% IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
% OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
% NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
% TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
% PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
% LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%

\documentclass{article}
\usepackage{fancyhdr}
\usepackage{amsfonts}
\usepackage[a4paper, margin=2cm]{geometry}

\title{Abstract-Nem operational semantics}
\date{}

\begin{document}

\newcommand{\q}[1]{{\tt #1}}
\newcommand{\pair}[2]{ \langle #1 , \; #2 \rangle }
\newcommand{\triple}[3]{ \langle #1 , \; #2 , \; #3 \rangle }
\newcommand{\computes}[2]{#1 \; \rightarrow \; #2}
\newcommand{\comprule}[3]{ 
  \begin{displaymath}
  \displaystyle 
  \frac{#1}{#2}
  #3
  \end{displaymath}
}
\newcommand{\conds}[1]{
  \;\;\;\;
  \begin{array}{l}
    #1
  \end{array}
}
\newcommand{\seta}[1]{ \triple{\sigma}{\eta}{#1} }
\newcommand{\ruleand}{\;\;\;\;\;}
\newcommand{\rulewhere}{\;\;\;{\rm where}\;\;\;}
\newcommand{\etastr}[1]{\pair{\q{S}}{#1}}
\newcommand{\etarec}[1]{\pair{\q{R}}{#1}}
\newcommand{\etaclo}[1]{\pair{\q{C}}{#1}}
\newcommand{\etaexn}[1]{\pair{\q{E}}{#1}}
\newcommand{\sigmarec}[1]{\pair{\q{R'}}{#1}}
\newcommand{\sigmaclo}[2]{\pair{\q{C'}}{\pair{#1}{#2}}}
\newcommand{\void}{\etastr{\q{''void''}}}
\newcommand{\nset}{\{ 1, \dots, n \}}

\maketitle

\section{Comments}

We use two kinds of environment. First is naming environment referred to
as $\eta$. It maps names to values. Values fall into one of four categories:

\begin{itemize}
\item character strings: $\etastr{s}$ where $s$ is string itself

\item referenced to record: $\etarec{k}$ where $k \in \mathbb{N}$, 
actual record value is stored in $\sigma(k)$

\item closure references: $\etaclo{l}$ where $l \in \mathbb{N}$, actual
function code and its naming environment is stored in $\sigma(l)$

\item exceptions: $\etaexn{e}$, where $e$ is also an value
\end{itemize}

\noindent
Second environment, called $\sigma$ is used to store records and closures.
It maps natural numbers to:

\begin{itemize}
\item records: $\sigmarec{r}$ where $r : Strings \rightarrow Values$

\item closures: $\sigmaclo{\eta}{\lambda x_1\dots x_n. e}$ where
$\eta$ is naming environment, $x_i$ are formal parameters
and $e$ is function code (an expression)
\end{itemize}

\begin{displaymath}
f [ p / v ] (x) = \left\{
\begin{array}{lll}
v & {\rm if} & x = p \\
f (x) & {\rm if} & x \neq p \\
\end{array}
\right.
\end{displaymath}

\section{Rules}

  \comprule{
  }{
    \computes{
      \seta{\q{''string''}}
    }{
      \pair{\sigma}{\etastr{\q{''string''}}}
    }
  }{}

  \comprule{
  }{
    \computes{
      \seta{\q{()}}
    }{
      \pair{\sigma}{\void}
    }
  }{}
  
  \comprule{
  }{
    \computes{
      \seta{ \{ f_i \q{=} x_i \}^n_{i=1} }
    }{
      \pair{\sigma[k / \sigmarec{g}]}{ \etarec{k} }
    }
  }{
    \conds{
      \sigma(k) = \bot \\
      \forall{i \in \nset}. \; g ( f_i ) = \eta ( x_i ) \\
      \forall{f}.\; ( \neg \exists{i \in \nset}.\; f = f_i ) \Rightarrow
      	g(f) = \bot \\
    }
  }
  
  \comprule{
  }{
    \computes{
      \seta{x}
    }{
      \pair{\sigma}{\eta(x)}
    }
  }{}
  
  \comprule{
  }{
    \computes{
      \seta{x . f}
    }{
      \pair{\sigma}{g(f)}
    }
  }{
    \conds{
      \eta(x) = \etarec{k} \\
      \sigma(k) = \sigmarec{g} \\
    }
  }
  
  \comprule{
  }{
    \computes{
      \seta{x \q{.*} f}
    }{
      \pair{\sigma}{g(s)}
    }
  }{
    \conds{
      \eta(x) = \etarec{k} \\
      \sigma(k) = \sigmarec{g} \\
      \eta(f) = \etastr{s} \\
    }
  }
  
  \comprule{
  }{
    \computes{
      \seta{x . f \leftarrow v}
    }{
      \pair{\sigma[k / \sigmarec{g'}]}{\void}
    }
  }{
    \conds{
      \eta(x) = \etarec{k} \\
      \sigma(k) = \sigmarec{g} \\
      g' = g[f / v] \\
    }
  }
  
  \comprule{
  }{
    \computes{
      \seta{x \q{.*} f \leftarrow v}
    }{
      \pair{\sigma[k / \sigmarec{g'}]}{\void}
    }
  }{
    \conds{
      \eta(x) = \etarec{k} \\
      \eta(f) = \etastr{s} \\
      \sigma(k) = \sigmarec{g} \\
      g' = g[s / v] \\
    }
  }
  
  \comprule{
    \computes{
      \triple{\sigma}{\eta' [ x_i / \eta(p_i) ]_{i=1}^n}{e}
    }{
      \pair{\sigma'}{v}
    }
  }{
    \computes{
      \seta{f (p_1, \dots, p_n)}
    }{
      \pair{\sigma'}{v}
    }
  }{
    \conds{
      \eta(f) = \etaclo{k} \\
      \sigma(k) = \sigmaclo{\eta'}{\lambda x_1 x_2 \dots x_n . e} \\
    }
  }
  
  \comprule{
    \computes{ \seta{e_1} }{ \pair{\sigma'}{v} }
    \ruleand
    \computes{ \triple{\sigma'}{\eta [ x / v ]}{e_2} }{ \pair{\sigma''}{r} }
  }{
    \computes{
      \seta{\q{let}\; x = e_1\; \q{in}\; e_2}
    }{
      \pair{\sigma''}{r}
    }
  }{
    \conds{
      \forall{e}.\; v \neq \etaexn{e} \\
    }
  }

  \comprule{
    \computes{ \seta{e_1} }{ \pair{\sigma'}{v} }
  }{
    \computes{
      \seta{\q{let}\; x = e_1\; \q{in}\; e_2}
    }{
      \pair{\sigma'}{v}
    }
  }{
    \conds{
      \exists{e}.\; v = \etaexn{e} \\
    }
  }
  
  \comprule{
  }{
    \computes{
      \seta{\q{raise}\; v}
    }{
      \pair{\sigma}{\etaexn{v}}
    }
  }{}

  \comprule{
    \computes{
      \seta{e_1} 
    }{ 
      \pair{\sigma'}{v_1} 
    }
    \ruleand
    \computes{ 
      \triple{\sigma'}{\eta[x / e]}{e_2} 
    }{ 
      \pair{\sigma''}{v_2} 
    }
  }{
    \computes{
      \seta{\q{try}\; e_1\; \q{catch}\; (\q{?}x)\; e_2}
    }{
      \pair{\sigma''}{v_2}
    }
  }{
    \conds{
      v_1 = \etaexn{e}
    }
  }

  \comprule{
    \computes{
      \seta{e_1} 
    }{ 
      \pair{\sigma'}{v} 
    }
  }{
    \computes{
      \seta{\q{try}\; e_1\; \q{catch}\; (\q{?}x)\; e_2}
    }{
      \pair{\sigma'}{v}
    }
  }{
    \conds{
      \forall{e} .\; v \neq \etaexn{e}
    }
  }

  \comprule{
    \computes{
      \seta{e} 
    }{ 
      \pair{\sigma'}{v} 
    }
  }{
    \computes{
      \seta{\q{match}\; s\; \q{with}\; [\; s' \rightarrow e \; \Gamma\; ]}
    }{
      \pair{\sigma'}{v}
    }
  }{
    \conds{
      \eta(s) = \etastr{s'} \\
    }
  }

  \comprule{
    \computes{
      \seta{\q{match}\; s\; \q{with}\; [\; \Gamma\; ]}
    }{ 
      \pair{\sigma'}{v} 
    }
  }{
    \computes{
      \seta{\q{match}\; s\; \q{with}\; [\; s' \rightarrow e \; \Gamma\; ]}
    }{
      \pair{\sigma'}{v}
    }
  }{
    \conds{
      \eta(s) \neq \etastr{s'} \\
    }
  }

  \comprule{
    \computes{
      \seta{e} 
    }{ 
      \pair{\sigma'}{v} 
    }
  }{
    \computes{
      \seta{\q{match}\; s\; \q{with}\; [\; \_ \rightarrow e \;]}
    }{
      \pair{\sigma'}{v}
    }
  }{
  }

  \comprule{
    \computes{
      \triple{\eta'}{\sigma'}{e}
    }{ 
      \pair{\sigma''}{v} 
    }
  }{
    \computes{
      \seta{\q{fun}\; \{ f_i (x_1^i, \dots, x_{k_i}^i) = e_i \}_{i=1}^n \; \q{in}\; e}
    }{
      \pair{\sigma''}{v}
    }
  }{
    \conds{
      \forall{i \in \nset}.\; \sigma(p_i) = \bot \\
      \forall{i \in \nset}.\;\forall{j \in \nset}.\; i \neq j \Rightarrow p_i \neq p_j \\
      \eta' = \eta [ f_i / \etaclo{p_i} ]_{i=1}^n \\
      \sigma' = \sigma [ p_i / \sigmaclo{\eta'}{\lambda x_1^i \dots x_{k_i}^i.\; e_i} ]_{i=1}^n \\
    }
  }



\end{document}
