/*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections.Tree;
using Nemerle.Collections;

namespace Nemerle.Collections {

public interface I_comparable_to ('a)
  {
    compare (_ : 'a) : int;
  }

public interface I_comparator ('a)
  {
    compare (_ : 'a, _ : 'a) : int;
  }

class Impossible extends System.Exception
  {
    public this () {}
  }

public module Tree {

  public variant node ('a) where 'a :> I_comparable_to ('a)
    {
      | R { l : node ('a); e : 'a; r : node ('a); }
      | B { l : node ('a); e : 'a; r : node ('a); }
      | T
    }

  'a where 'a :> I_comparable_to ('a) 
    balance (left : node ('a), elem : 'a, right : node ('a)) : node ('a) {
    // this could be or pattern, but it's 10 times better then
    // it used to be anyway :-)
    match ((left, elem, right)) {
      | (R (R (a, x, b), y, c), z, d) =>
        R (B (a, x, b), y, B (c, z, d))
      | (R (R (a, x, b), y, c), z, d) =>
        R (B (a, x, b), y, B (c, z, d))
      | (R (a, x, R (b, y, c)), z, d) =>
        R (B (a, x, b), y, B (c, z, d))
      | (a, x, R (R (b, y, c), z, d)) =>
        R (B (a, x, b), y, B (c, z, d))
      | (a, x, R (b, y, R (c, z, d))) =>
        R (B (a, x, b), y, B (c, z, d))
      | _ => 
        R (left, elem, right)
    }
  }

  public 'a where 'a :> I_comparable_to ('a) 
    insert (t : node ('a), x : 'a, replace : bool) : node ('a)
    {
      def ins (t : node ('a)) : node ('a) {
        match (t) {
          | T => R (T (), x, T ())
          | (B) as y =>
            def res = y.e.compare (x);
            if (res > 0) balance (ins (y.l), y.e, y.r)
            else if (res < 0) balance (y.l, y.e, ins (y.r))
            else if (replace) B (y.l, x, y.r)
            else raise Invalid_argument ("Tree.insert")
          | (R) as  y =>
            def res = y.e.compare (x);
            if (res > 0) R (ins (y.l), y.e, y.r)
            else if (res < 0) R (y.l, y.e, ins (y.r))
            else if (replace) R (y.l, x, y.r)
            else raise Invalid_argument ("Tree.insert")
        }
      };
      def t = ins (t);
      match (t) {
        | B => t
        | (R) as x => B (x.l, x.e, x.r)
        | _ => raise Impossible ()
      };
    }

  public 'a where 'a :> I_comparable_to ('a) 
    find (t : node ('a), x : 'a) : option ('a)
    {
      def f (t : node ('a)) : option ('a) {
        match (t) {
          | (R) as y =>
            def res = y.e.compare (x);
            if (res > 0) f (y.l)
            else if (res < 0) f (y.r)
            else Some (y.e)
          | (B) as y =>
            def res = y.e.compare (x);
            if (res > 0) f (y.l)
            else if (res < 0) f (y.r)
            else Some (y.e)
          | T => None ()
        }
      };
      f (t)
    }
    
  public 'a, 'b where 'a :> I_comparable_to ('a) 
    fold (func : 'b * 'a -> 'b, ini : 'b,  t : node ('a)) : 'b {
    match (t) {
      | R (l, e, r) =>
        fold (func, func (fold (func, ini, l), e), r)
      | B (l, e, r) =>
        fold (func, func (fold (func, ini, l), e), r)
      | T => ini
    }
  }
}

class map_node ('a, 'b) implements I_comparable_to (map_node ('a, 'b))
  {
    public key : 'a;
    public val : 'b;
    public cmp : I_comparator ('a);
    
    compare (x : map_node ('a, 'b)) : int 
      implements I_comparable_to.compare
      { this.cmp.compare (this.key, x.key) }

    public this (c : I_comparator ('a), k : 'a, v : 'b) 
      { 
        this.cmp <- c;
        this.key <- k; 
        this.val <- v;
      }

    public this (c : I_comparator ('a), k : 'a) 
      {
        this.cmp <- c;
        this.key <- k;
      }
  }

class Int_comparator implements I_comparator (int)
  {
    compare (x : int, y : int) : int 
      implements I_comparator.compare
      { x - y }
    public this () {}
  }

class String_comparator implements I_comparator (string)
  {
    compare (x : string, y : string) : int 
      implements I_comparator.compare
      { compare_strings (x, y) }
    public this () {}
  }

public class Map ('a, 'b, 'c) where 'c :> I_comparator ('a)
  {
    root : node (map_node ('a, 'b));
    cmp : I_comparator ('a);
    
    public this (c : I_comparator ('a))
      {
        this.root <- T ();
        this.cmp <- c;
      }

    this (c : I_comparator ('a), r : node (map_node ('a, 'b))) 
      {
        this.cmp <- c;
        this.root <- r;
      }

    public is_empty () : bool
    {
      match (root) {
        | T => true
        | _ => false
      }
    }
    
    public add (k : 'a, v : 'b) : Map ('a, 'b, 'c)
      { Map (this.cmp, Tree.insert (this.root, map_node (this.cmp, k, v), false)) }
      
    public replace (k : 'a, v : 'b) : Map ('a, 'b, 'c)
      { Map (this.cmp, Tree.insert (this.root, map_node (this.cmp, k, v), true)) }
      
    public find (k : 'a) : option ('b) {
      match (Tree.find (this.root, map_node (this.cmp, k))) {
        | (Some) as n => Some (n.val.val) 
        | None => None ()
      }
    }

    public get (k : 'a) : 'b {
      match (Tree.find (this.root, map_node (this.cmp, k))) {
        | (Some) as n => n.val.val 
        | None => raise (Not_found ())
      }
    }

    public mem (k : 'a) : bool {
      match (Tree.find (this.root, map_node (this.cmp, k))) {
        | Some => true
        | None => false
      }
    }

    public 'd fold (func : 'd * 'a * 'b -> 'd, ini : 'd) : 'd
      {
        def wrap (ctx : 'd, n : map_node ('a, 'b)) : 'd {
          func (ctx, n.key, n.val)
        };
        Tree.fold (wrap, ini, this.root)
      }
      
    public 'd iter (func : 'a * 'b -> void) : void
      {
        def wrap (ctx : int, n : map_node ('a, 'b)) : int
          { 
            func (n.key, n.val); 
            ctx 
          };
        def _ = Tree.fold (wrap, 0, this.root);
        ()
      }

    static public 'd int_map () : Int_map ('d)
      { Map (Int_comparator ()) }
    static public 'd string_map () : String_map ('d)
      { Map (String_comparator ()) }
  }

  public type Int_map ('a) = Map (int, 'a, Int_comparator);
  public type String_map ('a) = Map (string, 'a, String_comparator);
}
