/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.Tyvar;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

  public module Tyvar
    {
      mutable tyvars : Int_map (T);

      store_tv (t : T) : void {
        tyvars <- tyvars.add (t.id, t)
      }
      
      public class T
        {
          public name : string;
          public mutable constraints : list (Type);
          public mutable is_free : bool;
          public mutable is_fixed : bool;
          public mutable is_from_null : bool;
          public id : int;

          public this (n : string)
            {
              this.name <- n;
              this.constraints <- [];
              this.is_free <- false;
              this.is_fixed <- false;
              this.is_from_null <- false;
              this.id <- Util.next_id ();
              store_tv (this);
            }

          public this (t : T)
            {
              this.name <- t.name;
              this.constraints <- t.constraints;        // to be is_fixed
              this.is_fixed <- true;       // not sure
              this.is_free <- true;
              this.is_from_null <- false;
              this.id <- Util.next_id ();
              store_tv (this);
            }

          public this ()
            {
              this.id <- Util.next_id ();
              this.name <- "_N_fv" + this.id.ToString ();
              this.constraints <- [];
              this.is_fixed <- true;       // not sure
              this.is_free <- true;
              this.is_from_null <- false;
              store_tv (this);
            }

          public add_constraint (ty : Type) : void
            {
              if (this.is_fixed)
                Message.error ("this type variable cannot get any new constraints here")
              else ();
              this.constraints <- ty :: this.constraints
            }
        }

      public class TEnv
        {
          tyvars : String_map (T);
          
          private this (tv : String_map (T))
            {
              this.tyvars <- tv;
            }

          public this ()
            {
              this.tyvars <- Map.string_map ();
            }
          
          public bind (env : GlobalEnv, t : PT.Type) : Type { bind (env, t, true) }

          public bind (env : GlobalEnv, t : PT.Type, check_parms : bool) : Type
            {
              def f (t : PT.Type) : Type {
                match (t) {
                  | PT.T_ref (t) => T_ref (f (t))
                  | PT.T_out (t) => T_out (f (t))
                  | PT.T_array (t) => T_array (f (t))
                  | PT.T_fun (x, y) => T_fun (f (x), f (y))
                  | PT.T_void => T_void ()
                  | PT.T_prod (a) => T_prod (List.Map (f, a))
                  | PT.T_var (v) =>
                    match (this.tyvars.find (v)) {
                      | Some (tv) => T_var (tv)
                      | None =>
                        Message.fatal_error ("unbound type variable `" + v + "'")
                    }
                  | PT.T_app (PT.SS_string (n), a) =>
                    def ti = env.GetType (n);
                    def args = List.Map (f, a);

                    when (check_parms) {
                      ignore (ti.MakeSubst (args))
                    };
                    
                    T_app (ti, args)

                  | PT.T_infer =>
                    // this is our entire type inference... 
                    free_variable ()

                  | PT.T_app (_, _) =>
                    Util.ice ("Spliced string survived to typing")
                  | PT.T_spliced | PT.T_spliced_special =>
                    Util.ice ("Spliced type survived to typying.")
                  | PT.T_type_list =>
                    Util.ice ("Type arguments list survived to typying.")
                }
              };
              f (t)
            }
          
          public add_typarms (env : GlobalEnv, tp : PT.Typarms) : TEnv * list (T)
            { add_typarms (env, tp, true); }

          public add_typarms (env : GlobalEnv, tp : PT.Typarms, check_parms : bool) : TEnv * list (T)
            {
              def loop (acc : String_map (T) * list (T), tv : string) : String_map (T) * list (T)
                {
                  def (m, l) = acc;
                  def tv = T (tv);
                  (m.replace (tv.name, tv), tv :: l)
                };
              def (m, l) = List.FoldLeft (loop, (this.tyvars, []), tp.tyvars);
              def tenv = TEnv (m);
              def add_constraint (c : PT.Constraint) : void {
                match (m.find (c.tyvar)) {
                  | Some (tv) =>
                    tv.add_constraint (tenv.bind (env, c.ty, check_parms))
                  | None =>
                    Message.error ("unbound type variable `" + c.tyvar + "' in constraint")
                }
              };
              List.Iter (add_constraint, tp.constraints);
              def fixate (tv : T) : void { tv.is_fixed <- true };
              List.Iter (fixate, l);
              (tenv, List.Rev (l))
            }
        }

      public mutable global_subst : Subst;

      private lookup (id : int) : T {
        match (tyvars.find (id)) {
          | Some (x) => x
          | None => Util.ice ()
        }
      }

      public global_store (s : Subst) : void 
        {
          if (global_subst == null)
            global_subst <- Map.int_map () else ();
          def f (s : Subst, id : int, t : Type) : Subst 
            {
              (lookup (id)).is_free <- false;
              s.add (id, t)
            };
          global_subst <- s.fold (f, global_subst)
        }

      public global_expand (t : Type) : Type {
        if (global_subst == null) t
        else t /- global_subst
      }
      
      public fresh_subst (parms : list (T)) : Subst
        {
          def loop (ctx : Subst * list (T), proto : T) : Subst * list (T)
            {
              def (sub, vars) = ctx;
              def tv = Tyvar.T (proto);
              (sub.add (proto.id, T_var (tv)), tv :: vars)
            };
          def (sub, vars) = List.FoldLeft (loop, (Map.int_map (), []), parms);
          def sub_constraints (tv : T) : void {
            tv.constraints <- List.Map (fun (t : Type) : Type { t /- sub }, tv.constraints)
          };
          List.Iter (sub_constraints, vars);
          sub
        }

      public free_variable () : Type { T_var (T ()) }

      public is_free (tv : T) : bool { tv.is_free }

      public constraints (tv : T) : list (Type) { tv.constraints }

     this ()
       {
         tyvars <- Map.int_map ();
       }

   } // module Tyvar

} // end ns
