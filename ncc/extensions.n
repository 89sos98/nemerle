(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;

open Nemerle.Compiler;
open Nemerle.Compiler.Typedtree;
open Nemerle.Compiler.Extensions;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module Extensions {

  implicit_ctor (par : Tyinfo) : Class_member
    {
      def collect (acc : list (PT.Expr) * list (Fun_parm), decl : Class_member) 
                  : list (PT.Expr) * list (Fun_parm)
        {
          match (decl) {
            | M_field (t, _) =>
              def n = decl.name;
              def fp = Fun_parm (loc = par.loc, name = n, ty = t, decl = null);
              def ex = PT.E_assign (PT.E_member (PT.E_this (), n), PT.E_ref (n));
              def (es, ps) = acc;
              (Cons (ex, es), Cons (fp, ps))
            | _ => acc
          }
        }
      def (assigns, parms) = List.fold_left (collect, (Nil (), Nil ()), par.member_list);
      def fh = Fun_header (loc = par.loc, 
                           name = ".ctor", 
                           id = Util.next_id (),
                           ret_type = T_void (), 
                           parms = List.rev (parms),
                           typarms = Nil (),
                           tenv = par.tenv,
                           closure_vars = Nil ());
      def body = PT.E_sequence (assigns);
      body.loc <- par.loc;
      def f = M_function (fh, FK_ctor (), FB_parsed_expr (body));
      f.modifiers <- Nil();
      f.name <- fh.name;
      f.loc <- fh.loc;
      f.id <- fh.id;
      f
    }
        
} // end module Extensions
} // end ns
