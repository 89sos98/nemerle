<?xml version='1.0' encoding='UTF-8' ?>
<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Nemerle description</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        This document is, except this and following section, based on
        cut down version of first try of Nemerle definition, before
        Core-Nem appeared.
      </p>
      <p>
        We don't have full plan how it will look and work yet. Several things
        are yet to be decided.
      </p>
    </body>
  </section>
  <section id="nemerle">
    <title>Core-Nem vs. Nemerle</title>    
    <body>
      <p>
        How will final Nemerle be different from Core-Nem?
      </p>
      <ul>
        <li>
          Namespace support.
        </li>
        <li>
          Type inference with some support to symbol overloading.
        </li>
        <li>
          Access attributes in spirit of C#.
        </li>
        <li>
          <tt>null</tt> value.
        </li>
        <li>
          Several built in syntax extensions to make programming easier
          (for example lambda expressions, member access and other
          short cuts used in Core-Nem semantics description, sequences,
          <tt>for</tt>, <tt>while</tt> loops, methods defined inside
          classes and so on).
        </li>
        <li>
          Syntax for defining user-defined language extensions.
        </li>
      </ul>
      <p>
        Most of things above are described in following sections.
      </p>
    </body>
    <subsection id="syn">
      <title>Language extensions</title>
      <body>
        <p>
          Our language extensions will share concepts with camlp4,
          macro preprocessors (like CPP and M4), C++ templates and
          various source-to-source translators, that can for example
          create XML i/o routines or SQL tables for types described in
          source language.
        </p>
        <p>
          At basic level it shouldn't be difficult to program such
          language extensions. However I personally wouldn't be surprised
          if language extensions were itself Turing-complete.
        </p>
      </body>
    </subsection>
  </section>
  <section id="namespaces">
    <title><tt>use</tt>, <tt>open</tt>, <tt>namespace</tt></title>    
    <body>
      <p>
        Consider example:
      </p>
<code>
namespace Org.Foo 
{
  class Bar 
  {
    method m () {}
    member x = 1
    val v = 2
    fun f () {}
    class Qux { ... }
    Bar operator+ (b1 : Bar, b2 : Bar) { ... }
  }
}
</code>
      <p>
        There is one identifier (<tt>Bar</tt>) in namespace
        <tt>Org.Foo</tt>.
      </p>
      <p>
        There are five identifiers in namespace <tt>Org.Foo.Bar</tt>:
        <tt>m</tt>, <tt>x</tt>, <tt>v</tt>, <tt>f</tt>, <tt>Qux</tt>.
      </p>
    </body>
    <subsection id="use">
      <title><tt>use</tt> declaration</title>
      <body>
        <p>
          Before using class <tt>Org.Foo.Bar</tt> in another class you
          need to say <tt>use Org.Foo.Bar;</tt>. After that you can
          use static members of class using fully qualified names like:
          <tt>Org.Foo.Bar.f()</tt> and <tt>Org.Foo.Bar.v</tt>. You can
          also create instances of <tt>Org.Foo.Bar</tt>: <tt>let p =
          new Org.Foo.Bar in ...</tt>.
        </p>
        <p>
          But what about <tt>m</tt>, <tt>x</tt> and <tt>operator+</tt>
          for <tt>Bar</tt> ? From now on they are considered for
          overloading resolution, so all of <tt>p#m ()</tt>,
          <tt>p#x</tt> and <tt>p + p</tt> are valid. It is
          also possible to say <tt>p#Org.Foo.Bar.m ()</tt> and
          <tt>p#Org.Foo.Bar.x</tt> with the same effect, for example
          when overloading resolution fails.
        </p>
        <p>
          It is also possible to import all types from given namespace
          using syntax <tt>use X.Y.*;</tt>. All source files implicitly
          do <tt>use System.*;</tt> at the beginning.
        </p>
        <p>
          It is checked compile-time error to use type not declared
          this way.
        </p>
      </body>
    </subsection>
    <subsection id="open">
      <title><tt>open</tt> declaration</title>
      <body>
        <p>
          Now about <tt>open <meta>X</meta></tt> declaration. It
          imports all identifiers from namespace <meta>X</meta> into
          current symbol set:
        </p>
        <ul>
          <li>
            After <tt>open Org.Foo;</tt> <tt>Bar</tt> is valid type.
          </li>
          <li>
            After <tt>open Org.Foo.Bar;</tt> <tt>f</tt> and <tt>v</tt>
            are valid expressions, and <tt>Qux</tt> is valid type.
          </li>
        </ul>
        <p>
          Additionally <tt>open <meta>X</meta>;</tt> implicitly does
          <tt>use <meta>X</meta>;</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="namespace">
      <title><tt>namespace</tt> declaration</title>
      <body>
<code>
namespace <meta>X</meta> {
  <meta>declarations</meta>
}
</code>
        <p>
          causes all <meta>declarations</meta> to reside in <meta>X</meta>
          namespace. Namespaces can be nested: 
        </p>
<code>
namespace <meta>X</meta> {
  namespace <meta>Y</meta> { 
    <meta>declarations</meta>
  } 
}
</code>
        <p> 
          which will prefix declarations with
          <tt><meta>X</meta>.<meta>Y</meta></tt>. Alternative form is
          also supported:
        </p>
<code>
namespace <meta>X</meta>.<meta>Y</meta> { 
  <meta>declarations</meta>
}
</code>
        <p>
          <tt>namespace</tt> keyword can be also used to defined short
          names for namespaces, for example after <tt>namespace N =
          Org.Foo.Bar;</tt> <tt>N.f</tt> and <tt>N.v</tt> are valid
          expressions and <tt>N.Qux</tt> is valid type. However these
          aliases are only considered in the first element of namespace
          path, i.e. <tt>Quxx.N.x</tt> does <strong>not</strong> mean
          <tt>Quxx.Org.Foo.Bar.x</tt>, but simply <tt>Quxx.N.x</tt>.
        </p>
      </body>
    </subsection>
  </section>
  <section id="parm-passing">
    <title>Parameter passing conventions</title>
    <subsection id="multi-args">
      <title>Functions with multiple parameters</title>
      <body>
        <p>
          Functions/methods that take multiple parameters are translated to
          functions taking tuple types in Nemerle. For example C# function
          <tt>bool f(int, int)</tt> is represented as value <tt>f</tt> of type
          <tt>int * int -&gt; bool</tt>.
        </p>
      </body>
    </subsection>
    <subsection id="out">
      <title><tt>out</tt> parameters</title>
      <body>
        <p>
          <tt>out</tt> parameters are returned along with result using tuple
          types, for example: <tt>int f(string, out float, out bool)</tt>
          is translated into <tt>f : string -&gt; int * float * bool</tt>.
        </p>
        <p>
          Normal and out parameters can come in any order. This order is
          retained in output tuple.
        </p>
        <p>
          As an exception <tt>void</tt> return type is omitted in return
          tuple.
        </p>
        <p>
          It is possible to declare functions that take <tt>out</tt>
          parameters, but it's discouraged, except for interop reasons.
        </p>
      </body>
    </subsection>
  </section>
</document>

<!-- vim: expandtab sw=2
  -->
