<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Don't Panic! -- Grokking Nemerle</title>

  <motto from="wizard">
    ,,This is as rock; tolk in the True Speech.''
  </motto>



  <section id="base-structure-of-programs">
    <title>Base structure of programs</title>
    <body>
      <p>
        This document contains materials used to teach Nemerle during
        the ,,Nemerle Programming Language'' course taught at our
        institute. It should make a good tutorial.
      </p>
      <p>
        This first lecture took place on Feb 24 2004.
      </p>
      <p>
        There are reference to various languages throughout this document.
        If you don't know much about these languages -- just ignore these
        remarks. As for remarks for the C language -- unless otherwise
        stated they also apply to C# and Java.
      </p>
      <p>
        Some links: <a
        ref="http://en.wikipedia.org/wiki/Grok">grokking?!</a>, <a
        ref="http://en.wikipedia.org/wiki/The_Hitchhiker's_Guide_to_the_Galaxy">don't
        panic</a>.
      </p>
    </body>
    
  
    <subsection id="running-compiler">
      <title>Running the compiler</title>
      <body>
        <p>
          In order to run programs written in Nemerle you first need
          to compile them to .NET bytecode. This is done with the
          <tt>ncc</tt> (Nemerle Compiler Compiler) command. Assuming the 
          Nemerle is installed properly on your system, you need to do
          the following:
        </p>
        <ul>
          <li>
            write the program text with your favorite text editor and
            save it in file with extension <file>.n</file>, for example
            <file>myfile.n</file>
          </li>
          <li>
            run the Nemerle compiler by typing <tt>ncc myfile.n</tt>
          </li>
          <li>
            the output goes to <file>out.exe</file>
          </li>
          <li>
            run it by typing <tt>out</tt> (Windows) or <tt>mono
            out.exe</tt> (Linux)
          </li>
        </ul>
      </body>
    </subsection>

    
    <subsection id="classes">
      <title>Classes and modules</title>
      <body>
        <p>
          You cannot define functions nor values at the top level in
          Nemerle. You need to pack them into classes or modules.
          For C#, Java and C++ programmers: module is a class with
          all members static, there can be no instance of module class.
        </p>
        <p>
          For now you should consider module to be form of packing related
          functions together.
        </p>
<code>
class Foo 
{ 
  // ... some comment ... 
}

module Bar
{
  /* ... some comment ... */
}
</code>
        <p>
          The above example also introduces two kinds of comments used in
          Nemerle. Comments starting with <tt>//</tt> are active until
          end of line, while comments starting with <tt>/*</tt> are
          active until <tt>*/</tt>. This is the same as in C (well, C99).
        </p>
      </body>
    </subsection>
    
    
    <subsection id="methods">
      <title>Methods</title>
      <body>
        <p>
          Modules can contain methods (functions) as well as fields
          (values). Both kind of members can be prefixed with access
          attributes likes <tt>private</tt>, <tt>internal</tt> or
          <tt>public</tt>.
        </p>
        <p>
          <tt>public</tt> defines a method or a field that can be accessed
          from outside the module.
        </p>
        <p>
          <tt>private</tt> defines a member that is local to module.
          This is the default.
        </p>
        <p>
          <tt>internal</tt> defines a member that is local to module a
          given library of executable.
        </p>
        <p>
          In method declaration header you first write modifiers, then
          method's name, them parameters with type specification and
          finally a type of values returned from this function.
        </p>
        <p>
          Typing constraint are in general written after colon
          (<tt>:</tt>).
        </p>
<code>
module Foo
{
  public SomeMethod () : void
  {
    // ...
  }
  private some_other_method (x : int) : int
  {
    // ... 
  }
  private Frobnicate (x : int, y : string) : int
  {
    // ... 
  }
  internal foo_bar () : int
  {
    // ...
  }
}
</code>
      </body>
    </subsection>
    

    <subsection id="fields">
      <title>Fields</title>
      <body>
        <p>
          Fields define global values inside module.
        </p>
        <p>
          Fields accept the same access attributes as methods. However there is
          one additional very important attribute for fields -- <tt>mutable</tt>.
        </p>
        <p>
          By default fields are read only, that is can be assigned values only 
          in the module initializer function (codenamed <tt>this</tt>; we will
          talk about it later). If you want to assign values to fields in other
          places you need to mark field <tt>mutable</tt>.
        </p>
<code>
module Bar
{
  public mutable qux : int;
  private quxx : int;
  mutable bar : float;
}
</code>
      </body>
    </subsection>


    <subsection id="expr">
      <title>Expressions</title>
      <body>
        <p>
          There is no expression versus statement distinction in
          Nemerle. There are only expressions. In particular there
          are no jump statements like <tt>break</tt>, <tt>goto</tt>
          or <tt>continue</tt>.
        </p>
        <p>
          There is also no <tt>return</tt> statement. The value returned
          from function is the last value computed in sequence expression
          defining function. You can think that there is implicit
          <tt>return</tt> at the beginning of each function. This is the
          same as in ML.
        </p>
        <p>
          Despite all that, the most basic example looks almost like in C#.
          The entry point for a program is function called <tt>Main</tt>.
          It is also possible to take command line arguments and/or return
          integer return code from the <tt>Main</tt> method, consult .NET
          reference for details.
        </p>
        <p>
          Note that unlike in ML function call requires <tt>()</tt>.
        </p>
<code>
module Hello
{
  Main () : void
  {
    System.Console.WriteLine ("Hello cruel world!")
  }
}
</code>
      </body>  
    </subsection>


    <subsection id="simple-fib">
      <title>Simple function</title>
      <body>
        <p>
          However the following example (computing <a
          ref="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci
          sequence</a>) looks somewhat different. You can see usage of
          a conditional expression. Note how the value is returned from
          function without any explicit <tt>return</tt> statement.
        </p>
        <p>
          Note that this example (and following) are not full. To be
          compiled they need to be packed into the module, equipped with
          <tt>Main</tt> function and so on.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  if (n < 2)
    1
  else
    fib (n - 1) + fib (n - 2)
}]]>
</code>
      </body>
    </subsection>


    <subsection id="def-mutable">
      <title>Imperative loops and value definitions</title>
      <body>
        <p>
          It is possible to use regular <b>imperative loops</b> like
          <tt>while</tt> and <tt>for</tt>. Both work as in C. As for
          the <tt>for</tt> case -- first expression is put before loop,
          second expression is the condition (loop is executed as long
          as the condition holds), and last expression is put at the
          end of the loop.
        </p>
        <p>
          However the most important thing about this example is variable
          definition used there. <b>Variables</b> (values that can be changed)
          are defined using <tt>mutable</tt> expression. You do not
          specify type, but you do specify initial value. Type of defined
          variable is inferred based on initial value (for example the type
          of <tt>1</tt> is obviously an <tt>int</tt>). Variable introduced
          with <tt>mutable</tt> is visible till the end of the current
          sequence. Lexical scoping rules apply -- definition of next
          value with the same name hides the previous one.
        </p>
        <p>
          <b>Sequence</b> is list of expressions enclosed in
          braces (<tt>{}</tt>) and separated with semicolons
          (<tt>;</tt>). Optional semicolon is allowed at the end of
          the sequence.  Note that function definition also introduces
          a sequence (as the function body is written in <tt>{}</tt>).
        </p>
        <p>
          <tt>mutable</tt> defines <b>variables</b> that can be updated
          using the assignment operator (<tt>&lt;-</tt>). This operator
          works much like <tt>=</tt> in C. In contrast <tt>def</tt>
          defines <b>values</b> that cannot be updated -- in our example
          we use <tt>tmp</tt> as such value.
        </p>
        <p>
          Note the semicolon after <tt>for</tt> expression. As it is
          not the last expression in this sequence, the semicolon is
          required. There is no exception for loops and the semicolon
          rule.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  mutable last1 <- 1;
  mutable last2 <- 1;
  
  for (mutable cur <- 1; cur < n; cur <- cur + 1) {
    def tmp = last1 + last2;
    last1 <- last2;
    last2 <- tmp;
  };

  last2
}]]>
</code>
        <p>
          In this example we see no gain from using <tt>def</tt> instead
          of <tt>int</tt> as you would do in C# (both are 3 characters long :-).
          However in most cases type names are far longer:
        </p>
<code>
FooBarQuxxFactory fact = new FooBarQuxxFactory (); // C#
def fact = FooBarQuxxFactory (); // Nemerle
</code>
      </body>
    </subsection>


    <subsection id="local-fun">
      <title>Local functions</title>
      <body>
        <p>
          You can define functions inside other functions. This is achieved
          using the <tt>def</tt> expression. It introduces new value (in this
          case a local function) until end of current sequence.
          Local function definition looks similar to global one (despite
          lack of access modifiers, leading <tt>def</tt> and trailing
          semicolon).
        </p>
        <p>
          Notice how the local function is used to organize loop. This
          is typical for Nemerle. It is therefore quite important
          for you to grok this concept. Some external links -- <a
          ref="http://en.wikipedia.org/wiki/Tail_recursion">tail
          recursion</a>, <a
          ref="http://en.wikipedia.org/wiki/Recursion">recursion</a>.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  def my_loop (last1 : int, last2 : int, cur : int) : int {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  };
  my_loop (1, 1, 1)
}]]>
</code>
        <p>
          If you are concerned about performance of this form of writing
          loops -- fear you not. When function body ends with call
          to another function -- no new stack frame is created. It is
          called <b>tail call</b>. Thanks to it the example above is as
          efficient as the <tt>for</tt> loop we seen before.
        </p>
      </body>
    </subsection>


    <subsection id="type-inf">
      <title>Type inference</title>
      <body>
        <p>
          You can specify types of parameters as well as return types for
          local functions. However in some (most?) cases compiler can guess
          (infer) the types for you, so you can save your fingers by not
          typing them. This is always safe, that is program shouldn't in
          principle change meaning if type annotations are added.
        </p>
        <p>
          To guarantee this safeness property type inference sometimes
          fail.  Which means that type annotations are required. This
          mostly manifests itself with error message.
        </p>
        <p>
          In the following example we have omitted return type, as well as
          types of <tt>last2</tt> and <tt>cur</tt> parameters. We however
          have given type to the <tt>last1</tt> parameter.
        </p>
        <p>
          If we omit type for the <tt>last1</tt> parameter, then compiler
          would report error in expression <tt>last1 + last2</tt> crying
          about ,,no match for operator +''. This is because the <tt>+</tt>
          operator is defined not only for integers but also for floats,
          chars and so on. It is also possible to add new overloads for
          this operator. Therefore compiler looks for it in class of
          left and right arguments. And if none is found -- it bails out.
          However after you specify explicitly type for <tt>last1</tt>,
          the overloading is resolved in favor of <tt>+</tt> having type
          <tt>int * int -> int</tt> (so <tt>last2</tt> also becomes an
          <tt>int</tt>).
        </p>
        <p>
          Other typical cases when type annotation is required is using the
          dot (<tt>.</tt>) operator to access members of unknown type, as
          well as overloading resolution errors. These manifest themselves
          with error messages like ,,no constrain of _N_fv36_36* provides
          member `Foo''' or ,,overloading resolution ambiguity''.
        </p>
<code>
<![CDATA[fib (n : int) : int
{
  def my_loop (last1 : int, last2, cur) {
    if (cur >= n)
      last2
    else
      my_loop (last2, last1 + last2, cur + 1)
  };
  my_loop (1, 1, 1)
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="ext-fun">
      <title>External functions</title>
      <body>
        <p>
          One of the best things about Nemerle is that you can use rich
          class libraries that come with the Framework as well as the
          third party libraries. Links to documentation about .NET class
          libraries can be found <a ref="#class-docs">here</a>.
        </p>
        <p>
          New objects are constructed by simply naming the type and
          supplying arguments to its constructor. Note that unlike
          in C# or Java you don't use the <tt>new</tt> keyword to
          construct new objects. Later methods of objects can be
          invoked using the dot operator (<tt>some_object.SomeMethod
          (some_argument)</tt>).  Static methods are invoked using the
          <tt>NameSpace.TypeName.MethodName ()</tt> syntax.  We will talk
          more about this object oriented stuff later.
        </p>
        <p>
          We use two methods of formatting output here. One is
          <tt>System.Console.WriteLine</tt> (a function from the .NET
          Framework). When given more then one argument it replaces
          occurrences of <tt>{N}</tt> with (N+2)-th parameter (counting
          from one).
        </p>
        <p>
          Second is <tt>printf</tt> macro, that works much like the
          <tt>printf(3)</tt> C function, or <tt>Printf.printf</tt> in OCaml.
        </p>
        <p>
          For more information about <i>The answer to the Ultimate
          Question of Life, the Universe and Everything</i> please visit <a
          ref="http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything">this
          site</a>. Please note, that this program, run on computer not as powerful as
          Deep Thought, will be right only in 1% of cases.
        </p>
<code>
<![CDATA[the_answer_to_the_universe () : int
{
  // Construct new random number generator.
  def r = System.Random ();
  // Return new random number from [0, 99] range.
  r.Next (100)
}

print_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  System.Console.WriteLine ("The answer to the Ultimate " +
                            "Question of Life, the " +
                            "Universe and Everything " +
                            "is {0}", the_answer)
}

printf_answer () : void
{
  def the_answer = the_answer_to_the_universe ();
  printf ("The answer is %d\n", the_answer);
}]]>
</code>
      </body>
    </subsection>


    <subsection id="array">
      <title>Arrays</title>
      <body>
        <p>
          Type of array of <meta>T</meta> is denoted <tt>array
          &lt;<meta>T</meta>></tt>.  This is one-dimensional, zero-based
          array. There are two special expressions for constructing new
          arrays: <tt>array ["foo", "bar", "baz"]</tt> will construct
          3-element array or strings, while <tt>array (100)</tt> creates
          100-element array of something. The ,,something'' is inferred
          later, based on array usage.  The array is initialized with
          <tt>0</tt>, <tt>0.0</tt> or <tt>null</tt> for reference types.
        </p>
        <p>
          One interesting thing about this example is usage of the type
          enforcement operator -- colon (<tt>:</tt>). We use it to enforce
          <tt>left</tt> type to be int. We could have as well write
          <tt>def loop (left : int, right) {</tt>. There are simply two
          ways to achieve this.
        </p>
        <p>
          Another interesting thing is the <tt>when</tt> expression -- it
          is <tt>if</tt> without <tt>else</tt>.  For symmetry we also have
          <tt>if</tt> without <tt>then</tt> called <tt>unless</tt>. As
          you might have already noted <tt>unless</tt> is equivalent to
          <tt>when</tt> with condition negated.
        </p>
        <p>
          In Nemerle the <tt>if</tt> expression always need to have the
          <tt>else</tt> clause. It's done this way to avoid stupid bugs
          with dangling-else:
        </p>
<code>
// C#, misleading indentation hides real code meaning
if (foo)
   if (bar)
     m1 ();
else
   m2 ();
</code>
        <p>
          If you do not want the <tt>else</tt> clause, use
          <tt>when</tt> expression, as seen in the example. There is
          also <tt>unless</tt> expression, equivalent to <tt>when</tt>
          with condition negated.
        </p>
        <p>
          The assignment operator (<tt>&lt;-</tt>) can be also used to
          assign elements in arrays.
        </p>
        <p>
          Note the <tt>ar.Length</tt> expression -- it gets length of
          array <tt>ar</tt>. It looks like a field reference in array
          object but under the hood it is a method call. This mechanism
          is called ,,property''.
        </p>
        <p>
          Our arrays are subtypes of <tt>System.Array</tt> so all methods
          available for <tt>System.Array</tt> are also available for
          <tt>array &lt;<meta>T</meta>></tt>.
        </p>
<code>
<![CDATA[module M {
  reverse_array (ar : array <int>) : void
  {
    def loop (left, right) {
      when ((left : int) < right) {
        def tmp = ar[left];
        ar[left] <- ar[right];
        ar[right] <- tmp;
        loop (left + 1, right - 1)
      }
    };
    loop (0, ar.Length - 1)
  }

  print_array (ar : array <int>) : void
  {
    for (mutable i <- 0; i < ar.Length; i <- i + 1)
      printf ("%d\n", ar[i])
  }

  Main () : void
  {
    def ar = array [1, 42, 3];
    print_array (ar);
    printf ("\n");
    reverse_array (ar);
    print_array (ar);
  }
}]]>
</code>
      </body>
    </subsection>
    

    <subsection id="misc_1">
      <title>Miscellaneous information</title>
      <body>
        <p>
          The equality predicate is written <tt>==</tt> and the
          inequality is <tt>!=</tt> as in C.
        </p>
        <p>
          The boolean operators (<tt>&amp;&amp;</tt>, <tt>||</tt> and
          <tt>!</tt>) are all available and works the same as in C.
        </p>
      </body>
    </subsection>
    

    <subsection id="exercises_1">
      <title>Exercises -- List 1</title>
      <body>
        <p>
          <b>1.1.</b> Write a program that prints out to the console:
        </p>
<code>
1 bottle of beer.
2 bottles of beer.
3 bottles of beer.
...
99 bottles of beer.
</code>
        <p>
          With appropriate amount of beer instead of <tt>...</tt>. Program source code
          shouldn't exceed 30 lines.
        </p>
        <p>
          <b>1.2.</b> Implement <a
          ref="http://www.catb.org/~esr/jargon/html/B/bogo-sort.html">bogo
          sort</a> algorithm for array of integers. (WARNING: you should not implement
          ,,destroy the universe'' step). Test it by sorting the following array: 
          <tt>[4242, 42, -42, 31415]</tt>.
        </p>
        <p>
          <b>1.3.</b> As 1.2, but don't use the imperative loops -- rewrite them
          with recursion.
        </p>
      </body>
    </subsection>
  </section>
  
  <section id="lecture_2">
    <title>Namespaces, matching and objects</title>
    <body>
      <p>
      </p>
    </body>

    
    <subsection id="namespaces">
      <title>Namespaces</title>
      <body>
        <p>
          Classes and modules can be put in namespaces. Namespaces
          at the conceptual level prepend a string to names of objects
          defined within them.
        </p>
<code>
namespace Deep.Thought
{
  module Answer
  {
    public Get () : int
    {
      42
    }
  }
}

namespace Loonquawl
{
  module Brain
  {
    Main () : void
    {
      System.Console.WriteLine ("The answer {0}", 
                                Deep.Thought.Answer.Get ())
    }
  }
}
</code>
        <p>
          As you can see we the name of the <tt>Get</tt> function
          is first prepended with name of the module (<tt>Answer</tt>)
          and then with current namespace (<tt>Deep.Thought</tt>),
          forming it's full name: <tt>Deep.Thought.Answer.Get</tt>.
        </p>
        <p>
          Another example is the <tt>WriteLine</tt> method of the
          <tt>Console</tt> module, defined in the <tt>System</tt>
          namespace.
        </p>
      </body>
    </subsection>


    <subsection id="using">
      <title>Making long names short</title>
      <body>
        <p>
          In order not to write <tt>System.Console.WriteLine</tt> or
          <tt>Deep.Thought.Answer.Get</tt> all the time one can import
          all declarations from the specified namespace into current
          scope with the <tt>using</tt> directive.
        </p>
        <p>
          So the <tt>Loonquawl.Brain</tt> module from the example
          above could be:
        </p>
<code>
<![CDATA[namespace Loonquawl
{
  using System.Console;
  using Deep.Thought.Answer;
  
  module Brain
  {
    Main () : void
    {
      WriteLine ("The answer {0}", Get ())
    }
  }
}
]]>
</code>
        <p>
          While we see not much gain from the <tt>using</tt>
          directive in this example, it can be handy when you use the
          <tt>WriteLine</tt> method 100 times, and/or your classes are
          in <tt>Some.Very.Long.Namespaces</tt>.
        </p>
        <p>
          Note that unlike in C# one can import all methods of a class
          into current namespace. That is <tt>using</tt> is not limited
          to namespaces, but it also works for classes.
        </p>
      </body>
    </subsection>

  </section>


  
  <section id="class-docs">
    <title>Class library reference</title>
    <body>
      <p>
        Class library reference from Microsoft can be found under
        <link>http://msdn.microsoft.com/library/en-us/cpref/html/cpref_start.asp</link>.
      </p>
    </body>
  </section>

  
  <!--
    <subsection id="">
      <title></title>
      <body>
        <p>
        </p>
      </body>
    </subsection>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>
