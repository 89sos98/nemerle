open funs;

variant list ('a) = [
  | Cons { head : 'a; tail : list ('a); }
  | Nil {}
]

class funs {
  fun ('a, 'b) map (f : 'a -> 'b, x : list ('a)) : list ('b) = 
    match x with [
      | Nil => Nil ()
      | Cons (?h, ?t) => Cons (f (h), map (f, t))
    ];

  fun ('a) length (x : list ('a)) : int =
    letfun loop (acc : int, x : list ('a)) : int =
      match x with [
	| Cons ?x => loop (acc + 1, x#tail)
        | _ => acc
      ] in loop (0, x);

  fun ('a, 'b) fold_left (f : 'b * 'a -> 'b, acc : 'b, l : list ('a)) : 'b =
    match l with [
      | Nil ?_ => acc
      | Cons ?l => fold_left (f, f (acc, l#head), l#tail)
    ];

  fun ('a) iter (f : 'a -> void, l : list ('a)) : void =
    letfun i (dummy : int, e : 'a) : int { f (e); dummy } in
    let _ = fold_left (i, 0, l) in
    ();

  fun ('a) cons (e1 : 'a) : list ('a) =
    Cons (e1, Nil ());
    
  fun ('a) cons (e1 : 'a, e2 : 'a) : list ('a) =
    Cons (e1, cons (e2));
    
  fun ('a) cons (e1 : 'a, e2 : 'a, e3 : 'a) : list ('a) =
    Cons (e1, cons (e2, e3));
    
  fun Main () : void {
    let l = cons ("foo", "bar", "baz") in {
      let ref acc = ":" in
      letfun prt (s : string) : void {
        acc <- acc + ":" + s;
        print_endline(s) 
      } in
      {
        iter (prt, l);
        print_endline (acc)
      };
      letfun concat (acc : string, s : string) : string = acc + "." + s in
      print_endline (fold_left (concat, "", l))
    }
  }
}

(*
BEGIN-OUTPUT
foo
bar
baz
::foo:bar:baz
.foo.bar.baz
END-OUTPUT
*)
