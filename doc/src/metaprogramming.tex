\documentclass[draft,11pt]{article}
\usepackage[latin2]{inputenc}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{hcolor}
\usepackage{color}
\usepackage[a4paper, margin=3cm]{geometry}

\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\netf}[0]{{\tt .NET} framework}
\newcommand{\nem}[0]{Nemerle}
\newcommand{\cs}[0]{C\#}
\newcommand{\oo}[0]{object-oriented}
\newcommand{\kw}[1]{{\tt \bf #1}}

\DefineVerbatimEnvironment
  {Code}{Verbatim}
  {frame=lines,numbers=left,xleftmargin=15mm,%
   xrightmargin=10mm,framesep=2mm,framerule=1mm,%
   rulecolor=\color[rgb]{0.8,0.8,0.8}}

\begin{document}

\title{{\Huge \sc Meta-programming} \\ 
  In new Functional \net\ Language Nemerle \\
  {\large \tt http://nemerle.org/}}
\author{Kamil Skalski \\ {\small University of Wroc³aw}}
\date{\today}

\maketitle

\thispagestyle{empty}

\begin{abstract}
  We present design of meta-programming system embedded in new functional
  language \nem\ incorporated into \net\ platform. It gives wide set of
  operations performed on code at compile time, including program generation,
  transformation and automated analysis. It provides good support for Aspects 
  Oriented Programming, extending code with various features parametrized by
  external data, while still strong typing it during compilation.

  \nem\ and its macros are intended to easily introduce functional methods
  and power of meta-programming to programmers with C\#-like background. 
  Our focus is set on creating simple syntax, while not loosing power of
  its expressiveness.
\end{abstract}

\pagestyle{fancy}
\lhead{Kamil Skalski -- \it Nemerle}
\rhead{\thepage}
\cfoot{}

\section{General concept}
Idea of compile-time meta-programming has been studied for quite a long time.
It was incorporated into several languages, like Common-Lisp macros 
~\cite{CommonLisp}, C preprocessor-based macros, C++ template system and finally 
Haskell Template Meta-programming~\cite{MetaHaskell}. 
They vary on their power and ease of use, but generally involves computations 
made during compile-time and generating code from some definitions.

Programs are becoming \it{object programs}, which are data for meta-programs.
They can be arbitrarily transformed or analyzed and final result is then compiled
as regular program. This process may be repeated or take place in stages.

\it{Meta language} is the language for programming those operations. It 
commonly has its own syntax for describing various constructs of object language.
For example 
\begin{Code}
  <[ 1 + 1 ]>
\end{Code}
is our annotation for syntax tree of expression $1+1$. This idea is called 
\it{quasi-quotation}. 

\subsection{Our contribution}
We add some new ideas about syntax of meta language and usage of new technologies 
to connect great abilities of meta-programming with top industrial standards in
computer technology:
\begin{itemize}
  \item We develop uniform and simple quasi-quotation system, which doesn't require
    learning of any keywords to write quite complicated macros. It also contains easy
    way to write variable argument constructs (like tuples, functions with arbitrary
    amount of parameters)
  \item Using macros is transparent from user's point of view - it is not possible
    to distinguish between calling meta-program and common function, so user
    can use other's work without even knowing idea of meta-programming
  \item Syntax extensions allow even greater embedding of macros into language,
    which provides method to easily customize it to one's needs, without interfering
    with compiler internals
  \item Our system can be used to transform or generate practically any fragment
    of program, which composed with /net/ /oo/ structure gives powerful tools for
    software engineering methodologies
  \item We allow macros to type fragments of code, which they operate on, during
    their execution. It can be very useful to make them more independent of 
    the shape of data they are transforming
\end{itemize}

We combine results of previous works with our accomplishments to create consistent 
system of:
\begin{itemize}
  \item 
\end{itemize}

\section{Characteristics of /nem/'s meta-system} 
Our meta-system has both \it{program generation} and \it{analysis}
capabilities.
\footnote{Tim Sheard ``Accomplishments and Research Challenges in 
Meta-Programming'' 2001}
It can easily walk through abstract syntax tree of program and gather informations
about it as good as changing it (often using gathered data).

System is mainly designed for operating on object programs at compile-time,
but using features of /net/ and its dynamic code loading abilities, it is also
possible to execute macros during run-time. Taking this idea to the extreme, we
can use generated code as generator of another code, leading us to 
\it{multi-stage system}. It never requires to run macros separately from 
compiling target program (in contrast to so-called \it{static} code generators 
like Yacc).

Meta-language is \it{homogeneous}, which means that it's the same as object 
language. We can use common /nem/ functions within macros and the syntax 
of generated programs is no different than one used to write macros.

Quasi-quotation provides clear separation of object program from meta-language.
It's semantically clear which part of code is generated and which generates.
This manual annotation gives us way to separate stages of execution in well
understood fashion. Although we allow only two level quotation, to do not confuse
programmer by multi layered code, it's easy to recurse through structure of
program.

\section{Basic macros}

\section{Advanced usage}

\section{Only Haskell gurus can understand this}

\section{Summary}

\end{document}
