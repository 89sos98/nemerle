using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using System.Text;
using System;
using SCG = System.Collections.Generic;
using Nemerle.Imperative;

namespace LRPEGCC
{
  // TODO: refactoring
  // TODO: recognize unnamed terminal symbols - they can be met in right part of grammar
  
  public variant CaptureNode
  {
  | NonTerminalNode {  ChildCaptures : SCG.List[CaptureNode]; }
  | TerminalNode    { }
  
    public mutable Capture : Capture;
  }   
  
  /// <summary>
  /// 
  /// RetExprType - Type of parsing result (i.e. AST)
  /// </summary>
  public abstract class ParserBase[RetExprType]
  {
    protected _text : string;
    
    // It is unused
    //[Accessor(flags = Protected)]
    //private _cache : System.Collections.Generic.Dictionary[int, int] = System.Collections.Generic.Dictionary();
    
    // TODO: not to store this tree - call handlers immediatly as it is parsed. (probably)
    [Accessor(flags = Protected)]
    public _captureTree: CaptureNode.NonTerminalNode = CaptureNode.NonTerminalNode(SCG.List());    
   
    // it is a hack to build CaptureTree
    protected mutable currentCaptureNode: CaptureNode;    
    // TODO: end todo 
    
    private mutable _result : RetExprType;
    private mutable _parsedSymbolsCount : int;
    private mutable _isParsed : bool = false;    
    
    public Result : RetExprType
    {
      get
      {
        unless(_isParsed)
          Parse();
          
        _result
      }
    }
    
    public ParsedSymbolsCount : int
    {
      get
      {
        unless(_isParsed)
          Parse();
            
        _parsedSymbolsCount
      }
    }
    
    public this(text : string)
    {
      _text = text;
      currentCaptureNode = CaptureTree;
    }
    
    protected GetChar(pos : int) : char
    {
      _text[pos];
    }
    
    protected CheckTextLength(pos : int) : bool
    {
      pos < _text.Length;
    }   
    
    private Parse() : void
    {
      unless(_isParsed)
      {
        // phase1 : generate AST(CaptureTree) of parsed text
        _parsedSymbolsCount = DoParse();
      
        // phase2: generate result (int, binaries, PExpr, etc)
        _result = GenerateResult();
        _isParsed = true;
      }
    }
    
    private GenerateResult() : RetExprType 
    {    
      def generate(cn : CaptureNode.NonTerminalNode) : RetExprType
      {
        mutable tokens = [];
        
        foreach(n in cn.ChildCaptures)
        { 
          def t = match(n)
          {
          | (CaptureNode.TerminalNode) =>          
              Token.TerminalToken(n.Capture, _text)
              
          | (CaptureNode.NonTerminalNode as ntn) =>
              def r = Token.NonTerminalToken(n.Capture, _text);
              r.ComputedValue = generate(ntn);
              r
          }              
          tokens = tokens + [t];    
        }
                
        DoGenerateResult(cn.Capture.Name, tokens);  
      }
      
      //top of the tree doesn't contain handler 
      def l = _captureTree.ChildCaptures.ToList();
      match(l)    
      {
      | [CaptureNode.NonTerminalNode as ntn] =>
          generate(ntn)
      | _ =>
          throw InvalidOperationException("CantGenerate result");
      } 
    }  
        
    protected abstract DoParse() : int;   
    
    // TODO: replace 'ruleName : string' by 'rule : LRPEGCC.Rule'
    protected abstract DoGenerateResult(ruleName : string, tokens : list[Token[RetExprType]]) : RetExprType; 
  }
}
