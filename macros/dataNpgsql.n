/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Data;
using System.Text.RegularExpressions;
using Npgsql;

namespace Nemerle.Data {
module Npgsql {
  mutable connection : NpgsqlConnection;

  macro CreateCompileTimeConnection (con_str : string)
  {
    connection <- NpgsqlConnection (con_str);
    connection.Open ();
    <[ () ]>
  }

  macro SqlLoop (query : string, conn, body)
  {
    // take names after $
    def namesreg = Regex (@"(([^\$]*)\$(\w+))|(.+)", RegexOptions.Singleline);
    mutable m <- namesreg.Match (query);
    def fquery = System.Text.StringBuilder (query);
    mutable pars <- [];

    // extract names and prefix them with Npgsql parameter delimiter `:'
    while (m.Success) {
      when (m.Groups[1].Success) {
        pars <- m.Groups[3].ToString () :: pars;
        fquery[m.Groups[3].Index] <- ':';
      };
      m <- m.NextMatch ();
    };

    // initializers of sql command parameters
    mutable pars_init <- [];
    Nemerle.Collections.List.Iter (pars, fun (x) {
      def varname = Nemerle.Compiler.Macros.UseSiteSymbol (x);
      pars_init <- <[ ignore (querycmd.Parameters.Add($(x : string), 
                                                      $(varname : var))) ]> 
                   :: pars_init;
    });

    // try to execute query chcecking its syntax and aquiring names of columns
    mutable bodyseq <- [body];
    def mycmd = NpgsqlCommand (fquery.ToString (), connection);
    try {
      def myreader = mycmd.ExecuteReader(CommandBehavior.SchemaOnly);
      def table = myreader.GetSchemaTable ();
      foreach(myRow : DataRow in table.Rows){
        def col = myRow["ColumnName"].ToString ();
        def col_type = Nemerle.Compiler.Macros.UseSiteSymbol (myRow["DataType"].ToString ());
        def col_name = Nemerle.Compiler.Macros.UseSiteSymbol (col);
        bodyseq <- <[ def $(col_name : var) = (reader[$(col : string)] 
                                              :> $(col_type : var)) ]> :: bodyseq;
      }
    }
    catch {
      | e : NpgsqlException =>
        Nemerle.Compiler.Message.error ("sql query error: " + e.Message)
    };

    <[
      def querycmd = NpgsqlCommand ($(fquery.ToString () : string), $conn);
      { .. $pars_init };
      def reader = querycmd.ExecuteReader ();
      while (reader.Read ()) { ..$bodyseq };
      reader.Close ();
      querycmd.Dispose ();
    ]>
  }

}
}
