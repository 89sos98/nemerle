(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open System;
open System.IO;
open System.Text;
open System.Collections;

namespace Nemerle.Compiler {

type LexerInterface = extern "yyParser.yyInput";

 class Token {
  public static mutable NUMBER_LITERAL : int;
  public static mutable CHAR_LITERAL : int;
  public static mutable ID : int;
  public static mutable TYVAR : int;
  public static mutable STRING_LITERAL : int;
  public static mutable OP1 : int;
  public static mutable OP2 : int;
  public static mutable OP3 : int;
  public static mutable OP4 : int;
  public static mutable OP5 : int;
  public static mutable OP6 : int;
  public static mutable OP7 : int;
  public static mutable KW_ABSTRACT : int;
  public static mutable KW_CONST : int;
  public static mutable KW_EXTERN : int;
  public static mutable KW_INTERNAL : int;
  public static mutable KW_NEW : int;
  public static mutable KW_PRIVATE : int;
  public static mutable KW_PROTECTED : int;
  public static mutable KW_SEALED : int;
  public static mutable KW_VOLATILE : int;
  public static mutable KW_NAMESPACE : int;
  public static mutable KW_BASE : int;
  public static mutable KW_CLASS : int;
  public static mutable KW_ENUM : int;
  public static mutable KW_EXTENDS : int;
  public static mutable KW_FINALLY : int;
  public static mutable KW_IN : int;
  public static mutable KW_NULL : int;
  public static mutable KW_OUT : int;
  public static mutable KW_PUBLIC : int;
  public static mutable KW_RAISE : int;
  public static mutable KW_REF : int;
  public static mutable KW_STRUCT : int;
  public static mutable KW_THIS : int;
  public static mutable KW_VARIANT : int;
  public static mutable KW_INTERFACE : int;
  public static mutable KW_IMPLEMENTS : int;
  public static mutable KW_WHERE : int;
  public static mutable KW_TYPE : int;
  public static mutable KW_LET : int;
  public static mutable KW_FUN : int;
  public static mutable KW_AND : int;
  public static mutable KW_TYMATCH : int;
  public static mutable KW_WITH : int;
  public static mutable KW_TRY : int;
  public static mutable KW_OPEN : int;
  public static mutable KW_VOID : int;
  public static mutable KW_IF : int;
  public static mutable KW_THEN : int;
  public static mutable KW_ELSE : int;
  public static mutable KW_AS : int;
  public static mutable KW_MATCH : int;
  public static mutable KW_STATIC : int;
  public static mutable KW_MUTABLE : int;
  public static mutable KW_DEF : int;
  public static mutable KW_MODULE : int;
  public static mutable KW_ENSURE : int;
  public static mutable KW_REQUIRE : int;
  public static mutable KW_ARRAY : int;
  public static mutable KW_MKARRAY : int;
  public static mutable COLON_MORE : int;
  public static mutable LESS_MINUS : int;
  public static mutable MINUS_MORE : int;
  public static mutable EQ_MORE : int;
  public static mutable COLON_COLON : int;
  public static mutable LESS_SQBRAC : int;
  public static mutable SQBRAC_MORE : int;
  public static mutable KW_MACRO : int;
  public static mutable KW_PATTERN : int;
  public static mutable LAZY_AND : int;
  public static mutable LAZY_OR : int;
  public static mutable ERROR : int;
  public static mutable UNARY : int;
  public static mutable yyErrorCode : int;

  public static init() : void {
    NUMBER_LITERAL <- 257;
    CHAR_LITERAL <- 258;
    ID <- 259;
    TYVAR <- 260;
    STRING_LITERAL <- 261;
    OP1 <- 262;
    OP2 <- 263;
    OP3 <- 264;
    OP4 <- 265;
    OP5 <- 266;
    OP6 <- 267;
    OP7 <- 268;
    KW_ABSTRACT <- 269;
    KW_CONST <- 270;
    KW_EXTERN <- 271;
    KW_INTERNAL <- 272;
    KW_NEW <- 273;
    KW_PRIVATE <- 274;
    KW_PROTECTED <- 275;
    KW_SEALED <- 276;
    KW_VOLATILE <- 277;
    KW_NAMESPACE <- 278;
    KW_BASE <- 279;
    KW_CLASS <- 280;
    KW_ENUM <- 281;
    KW_EXTENDS <- 282;
    KW_FINALLY <- 283;
    KW_IN <- 284;
    KW_NULL <- 285;
    KW_OUT <- 286;
    KW_PUBLIC <- 287;
    KW_RAISE <- 288;
    KW_REF <- 289;
    KW_STRUCT <- 290;
    KW_THIS <- 291;
    KW_VARIANT <- 292;
    KW_INTERFACE <- 293;
    KW_IMPLEMENTS <- 294;
    KW_WHERE <- 295;
    KW_TYPE <- 296;
    KW_LET <- 297;
    KW_FUN <- 298;
    KW_AND <- 299;
    KW_TYMATCH <- 300;
    KW_WITH <- 301;
    KW_TRY <- 302;
    KW_OPEN <- 303;
    KW_VOID <- 304;
    KW_IF <- 305;
    KW_THEN <- 306;
    KW_ELSE <- 307;
    KW_AS <- 308;
    KW_MATCH <- 309;
    KW_STATIC <- 310;
    KW_MUTABLE <- 311;
    KW_DEF <- 312;
    KW_MODULE <- 313;
    KW_ENSURE <- 314;
    KW_REQUIRE <- 315;
    KW_ARRAY <- 316;
    KW_MKARRAY <- 317;
    COLON_MORE <- 318;
    LESS_MINUS <- 319;
    MINUS_MORE <- 320;
    EQ_MORE <- 321;
    COLON_COLON <- 322;
    LESS_SQBRAC <- 323;
    SQBRAC_MORE <- 324;
    KW_MACRO <- 325;
    KW_PATTERN <- 326;
    LAZY_AND <- 327;
    LAZY_OR <- 328;
    ERROR <- 329;
    UNARY <- 330;
    yyErrorCode <- 256;
  }
 }

class Lexer extends LexerInterface
{
  file : System.IO.FileStream;
  file_name : string;
  mutable val : TokenValue;
  mutable line : int;
  mutable col : int;
  mutable putback : bool;
  mutable putbackVal : char;
  
  last_line : int;
  last_col : int;
  mutable cur_tok : int;
  
  static mutable keywords : System.Collections.Hashtable;

  class Error extends System.Exception {
    public name : string;
    public this (name : string) { this.name <- name; }
  }

  variant TokenValue {
    | Str { body : string; }
    | Numb { body : int; }
  }
  
  public this (fn : string)
    {
      this.file_name <- fn;
      this.file <- System.IO.FileStream (fn, (3 :> System.IO.FileMode));
(* FileMode.Open, but we don't support enums yet*)
      this.line <- 1;
      this.col <- 1;
      this.putback <- false;
      this.cur_tok <- -1;
      Token.init();
    }

  do_read () : char
    {
      def inp = this.file.ReadByte ();
      if (inp >= 0) {
        def ch = System.Convert.ToChar (inp);
        if (ch == '\n') {
	  this.line <- this.line + 1;
	  this.col <- 1;
        } 
        else
          this.col <- this.col + 1;
        ch
      }
      else 
        raise Error ("unexpected end of file")
    }
	
  read () : char
    {
      if (!this.putback)
        this.do_read()
      else {
	def c = this.putbackVal;
	this.putback <- false;
	c
      }
    }

  peek() : char
    {
      if (!this.putback)
        this.putbackVal <- this.do_read()
      else ();
      this.putbackVal
    }

  is_id_beg(ch : char) : bool
    {
      System.Char.IsLetter (ch) || ch == '_'
    }

  is_opchar(ch : char) : bool
    {
      match (ch) {
	| '=' => true
	| '<' => true
	| '>' => true
	| '@' => true
	| '^' => true
	| '|' => true
	| '&' => true
	| '+' => true
	| '-' => true
	| '*' => true
	| '/' => true
	| '$' => true
	| '%' => true
	| '!' => true
	| '?' => true
	| '~' => true
	| '.' => true
	| ':' => true
	| '#' => true
	| '[' => true
	| ']' => true
	| _ => false
      }
    }

  skip_comment () : void
    {
      mutable ch <- ' ';
      mutable seen_star <- false;

      while ({ch <- this.read(); !seen_star || ch != ')'}, {
        if (ch == '*')
          seen_star <- true
        else
          seen_star <- false;
      });
    }

  get_op(tok : int, first_ch : char) : int
    {
      mutable buf <- System.Text.StringBuilder();
      
      buf <- buf.Append (first_ch);

      while (this.is_opchar (this.peek ()), 
        buf <- buf.Append (this.read ()));
	
      def s = buf.ToString();
	
      this.val <- Str (s);
      def first_int = System.Convert.ToInt32 (first_ch);

      match (s) {
	| "*" => first_int
	| "=" => first_int
	| "?" => first_int
	| "|" => first_int
	| "$" => first_int
	| "]" => first_int
	| "<-" => Token.LESS_MINUS
	| "->" => Token.MINUS_MORE
	| "=>" => Token.EQ_MORE
	| "<[" => Token.LESS_SQBRAC
	| "]>" => Token.SQBRAC_MORE
	| "&&" => Token.LAZY_AND
	| "||" => Token.LAZY_OR
	| _ => tok
      }
    }

  get_number (first_ch : char) : int
    {
      mutable buf <- System.Text.StringBuilder();
      buf <- buf.Append (first_ch);

      while (System.Char.IsDigit (this.peek ()), 
        buf <- buf.Append (this.read ()));

      this.val <- Numb (System.Int32.Parse (buf.ToString ()));

      Token.NUMBER_LITERAL
    }

  get_id (first_ch : char) : int
    {
      if (first_ch == '\'' && !this.is_id_beg (this.peek ())) {
	this.get_char()
      } 
      else {
	mutable buf <- System.Text.StringBuilder();
	buf <- buf.Append (first_ch);

	while (this.is_id_beg (this.peek ()) || System.Char.IsDigit (this.peek ()) 
               || this.peek() == '\'', buf <- buf.Append (this.read ()));

	def str = buf.ToString ();
	
	if (first_ch == '\'' && str.Length == 2 && str[1] == '\'') {
	  this.val <- Numb (System.Convert.ToInt32 (str[0]));
	  Token.CHAR_LITERAL
	}
	else {
	  this.val <- Str (str);
	  
	  if (first_ch == '\'')
	    Token.TYVAR
	  else {
	    init_keywords();
	    
	    if (keywords[str] != null)
	      (keywords[str] :> int)
	    else
	      Token.ID
	  }
	}
      }
    }

  escape_value (ch : char) : char
    {
      match (ch) {
	| 'n' => '\n'
	| 't' => '\t'
	| 'r' => '\r'
	| 'b' => '\b'
	| '"' => '"'
	| '\'' => '\''
	| '\\' => '\\'
	| _ => raise Error ("bad escape character")
      }
    }
    
  error(msg : string) : int
    {
      Message.error (this.get_current_location (), msg);
      Token.ERROR
    }

  get_char () : int
    {
      def ret = this.get_string('\'');
      if (ret == Token.ERROR)
        ret
      else {
	match (this.val) {
          | Str(v) =>
  	    if (v.Length == 0)
    	      raise Error ("empty character literal")
	    else {
	      if (v.Length != 1)
	        raise Error("character literal too long")
	      else {
	        this.val <- Numb (System.Convert.ToInt32 (v[0]));
	        Token.CHAR_LITERAL;
	      }
	    }
          | _ => Util.ice ("Value is not string in get_char")
        }
      }
    }

  get_string(end_ch : char) : int
    {
      mutable buf <- StringBuilder();
      mutable ch <- ' ';
		
      while (ch != end_ch, {
        ch <- this.read();
        match (ch) {
          | '\\' =>
            ch <- this.read();
            def esc = this.escape_value(ch);
            buf <- buf.Append (esc);
            ch <- ' ';
          | '\n' =>
            raise Error ("newline before end of string")
          | n =>
            if (ch != end_ch) 
              buf <- buf.Append(ch)
            else 
              ()
        }
      });
       
      this.val <- Str (buf.ToString ());
     
      Token.STRING_LITERAL
    }

  get_quoted_op () : int
    {
      def _ = this.get_op(Token.ID, this.read());
      if (this.peek() != '`') {
	def _ = this.read();
	raise Error ("invalid character in quoted op")
      }
      else {
	def _ = this.read();
	Token.ID
      }
    }

  get_double_quoted_id () : int
    {
      mutable buf <- StringBuilder();
      mutable ch <- ' ';

      while (ch != '`', {
        ch <- this.read();
            
        match (ch) {
          | '`' =>
            if (this.read() != '`')
              raise Error ("invalid character in double quoted id")
            else {
              if (ch != '`') buf <- buf.Append (ch)
              else ();
            }
          | '\n' =>
            raise Error ("newline in double quoted id")
          | _ =>
            raise Error ("EOF in double quoted id")
        }
      });
        
      this.val <- Str (buf.ToString ());
      Token.ID
    }
		
  get_quoted_id () : int
    {
      mutable buf <- StringBuilder ();
      mutable ch <- ' ';
		
      while (ch != '`', {
        ch <- this.read();

        match (ch) {
          | '`' =>
            if (ch != '`')
              buf <- buf.Append ((ch : char))
            else ();
          | '\n' =>
            raise Error ("newline in infix id")
          | _ =>
            raise Error ("EOF in infix id")
        };
      });

      this.val <- Str (buf.ToString ());
      Token.OP4
    }

  get_token () : int
    {
      def last_line = this.line;
      def last_col = this.col;
//      mutable ch <- this.read();
      def ch = this.read();
      def chint = System.Convert.ToInt32 (ch);
		
      match (ch) {
        | ' ' => this.get_token ()
        | '\t' => this.get_token ()
        | '\r' => this.get_token ()
        | '\n' => this.get_token()
        | '"' => this.get_string('"')

        | '`' =>
          if (this.peek () == '`') {
            def _ = this.read();
            this.get_double_quoted_id()
          }
          else if (this.is_opchar (this.peek ())) {
            this.get_quoted_op()
          } else this.get_quoted_id()

        | '\'' => this.get_id('\'')

        | '(' =>
          if (this.peek () == '*') {
            def _ = this.read();
            this.skip_comment();
            this.get_token()
          } else System.Convert.ToInt32 (ch)

        | ':' =>
          if (this.peek () == '>') {
            def _ = this.read();
            Token.COLON_MORE
          } else if (this.peek () == ':') {
            def _ = this.read();
            Token.COLON_COLON
          } else System.Convert.ToInt32 (ch)

        | '{' => chint
        | '}' => chint
        | '[' => chint
        | ',' => chint
        | ';' => chint
        | '.' => chint
        | ')' => chint
        | '#' => chint
        | '\\' => chint

        | '*' =>
          if (this.peek () == '*')
            this.get_op(Token.OP1, ch)
          else
            this.get_op(Token.OP2, ch)

        | '/' =>
          if (this.peek () == '/') {
            mutable ch <- this.read ();

            def loop () : void {
              if (ch != '\n') {
                ch <- this.read();
                loop ()
              }
              else
                ()
            };
            loop ();
            this.get_token()
          } else
            this.get_op(Token.OP2, ch)
				
        | '%' => this.get_op(Token.OP2, ch)
        | '+' => this.get_op(Token.OP3, ch)
        | '-' => this.get_op(Token.OP3, ch)
        | '@' => this.get_op(Token.OP4, ch)
        | '^' => this.get_op(Token.OP4, ch)
        | '$' => this.get_op(Token.OP4, ch)
        | '~' => this.get_op(Token.OP4, ch)
        | '?' => this.get_op(Token.OP4, ch)
        | '=' => this.get_op(Token.OP5, ch)
        | '<' => this.get_op(Token.OP5, ch)
        | '>' => this.get_op(Token.OP5, ch)
        | '!' => this.get_op(Token.OP5, ch)
        | ']' => this.get_op(Token.OP5, ch)
        | '&' => this.get_op(Token.OP6, ch)
	| '|' => this.get_op(Token.OP7, ch)

        | n =>
          if (System.Char.IsDigit (ch))
            this.get_number (ch)
          else
            if (this.is_id_beg (ch))
              this.get_id (ch)
            else
              raise Error ("invalid character")
      }      
    }

  public get_location () : Location
    {
      Location(this.file_name, this.last_line, this.last_col)
    }

  public get_current_location () : Location
    {
      Location(this.file_name, this.line, this.col)
    }

  // yyParser.yyInput
  public advance () : bool
    {
      mutable success <- true;

      try
        this.cur_tok <- this.get_token()
      with x : Error => {
        Message.fatal_error (x.name);
        success <- false;
      };
      success
    }
    
  public token () : int
    {
      if (this.cur_tok == -1)
        Util.ice ("attempt to read beyond end of file")
      else
        this.cur_tok
    }

  public value () : System.Object
    {
      match (this.val) {
        | Str(s) => (s : System.Object)
        | Numb(n) => (n : System.Object)
      }
    }
	
  static init_keywords() : void
    {
      if (keywords != null)
        ()
      else {
        keywords <- Hashtable();
        keywords["_"] <- System.Convert.ToInt32 ('_');
        keywords["abstract"] <- Token.KW_ABSTRACT;
        keywords["const"] <- Token.KW_CONST;
        keywords["extern"] <- Token.KW_EXTERN;
        keywords["internal"] <- Token.KW_INTERNAL;
        keywords["new"] <- Token.KW_NEW;
        keywords["private"] <- Token.KW_PRIVATE;
        keywords["protected"] <- Token.KW_PROTECTED;
        keywords["sealed"] <- Token.KW_SEALED;
        keywords["volatile"] <- Token.KW_VOLATILE;
        keywords["class"] <- Token.KW_CLASS;
        keywords["enum"] <- Token.KW_ENUM;
        keywords["extends"] <- Token.KW_EXTENDS;
        keywords["finally"] <- Token.KW_FINALLY;
        keywords["in"] <- Token.KW_IN;
        keywords["null"] <- Token.KW_NULL;
        keywords["out"] <- Token.KW_OUT;
        keywords["public"] <- Token.KW_PUBLIC;
        keywords["raise"] <- Token.KW_RAISE;
        keywords["ref"] <- Token.KW_REF;
        keywords["struct"] <- Token.KW_STRUCT;
        keywords["this"] <- Token.KW_THIS;
        keywords["variant"] <- Token.KW_VARIANT;
        keywords["interface"] <- Token.KW_INTERFACE;
        keywords["implements"] <- Token.KW_IMPLEMENTS;
        keywords["namespace"] <- Token.KW_NAMESPACE;
        keywords["where"] <- Token.KW_WHERE;
        keywords["type"] <- Token.KW_TYPE;
        keywords["let"] <- Token.KW_LET;
        keywords["fun"] <- Token.KW_FUN;
        keywords["and"] <- Token.KW_AND;
        keywords["tymatch"] <- Token.KW_TYMATCH;
        keywords["with"] <- Token.KW_WITH;
        keywords["try"] <- Token.KW_TRY;
        keywords["open"] <- Token.KW_OPEN;
        keywords["void"] <- Token.KW_VOID;
        keywords["base"] <- Token.KW_BASE;
        keywords["if"] <- Token.KW_IF;
        keywords["then"] <- Token.KW_THEN;
        keywords["else"] <- Token.KW_ELSE;
        keywords["as"] <- Token.KW_AS;
        keywords["match"] <- Token.KW_MATCH;
        keywords["static"] <- Token.KW_STATIC;
        keywords["mutable"] <- Token.KW_MUTABLE;
        keywords["def"] <- Token.KW_DEF;
        keywords["module"] <- Token.KW_MODULE;
        keywords["require"] <- Token.KW_REQUIRE;
        keywords["ensure"] <- Token.KW_ENSURE;
        keywords["array"] <- Token.KW_ARRAY;
        keywords["mkarray"] <- Token.KW_MKARRAY;
        keywords["macro"] <- Token.KW_MACRO;
//                keywords["pattern"] <- Token.KW_PATTERN;
      }
    }
} // end class Lexer
} // end ns
