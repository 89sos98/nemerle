% Meta-programming in Nemerle
%
\documentclass{llncs}
%
\newcommand{\net}[0]{{\tt .NET}}
\newcommand{\netf}[0]{{\tt .NET} framework}
\newcommand{\nem}[0]{Nemerle}
\newcommand{\cs}[0]{C\#}
\newcommand{\oo}[0]{object-oriented}
\newcommand{\kw}[1]{{\tt \bf #1}}
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%
\title{Meta-programming in \nem}
%
\titlerunning{Meta-programming in Nemerle}  
%
\author{Kamil Skalski \and Micha³ Moskal \and Pawe³ Olszta}
%
\authorrunning{Kamil Skalski et al.} 
%
%
\institute{University of Wroc³aw, Poland \\
           \texttt{http://www.nemerle.org}}
%
\maketitle              % typeset the title of the contribution
%
\begin{abstract}
We present design of meta-programming system embedded into the new functional
language \nem for \net\ platform. It introduces support for set of 
operations performed on code at compile-time, allowing generation,
transformation and automated analysis of programs. They consist of
code quotation system, syntax extensions, operating on code like on any
other datatype (e.g. listing, adding or changing members of class'
definition), performing guided by user partial typing of program's syntax tree
(compiler's internal typing procedures are executed by macro's code)
and other interoperability with compilation process, which can be fully
parametrized with any external data (like database, file or web page).

Our system provides good tool for Aspects Oriented Programming, by 
operating on datatypes, traversing program's code and performing algorithmic 
addition of various concerns to its content.
\end{abstract}

\section{Introduction}
Idea of compile-time meta-programming has been studied for quite a long time.
It was incorporated into several languages, like Scheme Lisp hygienic macros 
\cite{Lisp:Scheme}, C preprocessor-based macros, C++ template system and finally 
Haskell Template Meta-programming \cite{Haskell:Meta}. 
They vary on their power and ease of use, but generally involves computations 
made during compilation of program and generating code from some definitions.

During this process programs are becoming \emph{object programs}, which are 
data supplied to meta-programs. Then, they can be arbitrarily transformed or 
analyzed and final result is then compiled as regular program. These operations 
may be repeated or take place in stages. In latter case generated programs can 
generate other programs and so on.

\emph{Meta-language} is the language for programming those operations. It 
commonly has its own syntax for describing various constructs of object language.
For example in our system, \verb,<[ 1 + f (2 * x) ]>, is annotation for syntax 
tree of expression \verb,1 + f (2 * x),. This idea is called 
\emph{quasi-quotation}. The prefix \emph{quasi} comes from possibility
of inserting values of meta-language expressions into quoted context -- 
if \verb,g(y), is such an expression, we can write \verb.<[ 1 + $(g (y)) ]>., %$
which describe syntax tree, whose second part is replaced by evaluation of
\verb,g(y),.

\subsection{Our contribution}
We add some new ideas about syntax of meta-language, its interoperability with
compilation process and usage of new technologies to connect great abilities of 
meta-programming with top industrial standards in computer technology:
\begin{itemize}
  \item We develop uniform and simple quasi-quotation system, which doesn't require
    learning of any keywords to write quite complicated macros. It also contains easy
    way to write variable argument constructs (like tuples, function calls with 
    arbitrary amount of parameters)
  \item Using macros is transparent from user's point of view -- it is not possible
    to distinguish between calling meta-program and common function, so user
    can use other's work without even knowing idea of meta-programming
  \item Syntax extensions allow even greater embedding of macros into language,
    which provides method to easily customize it to one's needs, without interfering
    with compiler internals
  \item Our system can be used to transform or generate practically any fragment
    of program, which composed with \net\ \oo\ structure gives powerful tools for
    software engineering methodologies like aspects-oriented programming
  \item We allow macros to type fragments of code, which they operate on, during
    their execution. This allows to parameterize them not only on syntax of provided
    expressions, but also on entire context of program and type correctness of
    those expressions
\end{itemize}

\subsection{Characteristics of \nem 's meta-system} 
Our meta-system has both \emph{program generation} and \emph{analysis}
capabilities \cite{Meta:Accomplishments}. It can easily walk through the abstract 
syntax tree of object program and gather informations about it as good as change it 
(often using gathered data).

System is mainly designed for operating on object programs at compile-time,
but using features of \net\ and its dynamic code loading abilities, it is also
possible to execute macros during run-time. Taking this idea to the extreme, we
can use generated code as generator of another code, leading us to 
\emph{multi-stage system}. It never requires to run macros separately from 
compiling target program (in contrast to so-called \emph{static} code generators 
like Yacc).

Meta-language is \emph{homogeneous}, which means that it's the same as object 
language. We can use common \nem\ functions within macros and the syntax 
of generated programs is no different than one used to write macros.

Quasi-quotation provides clear separation of object program from meta-language.
This annal annotation gives us way to separate stages of execution in well
understood fashion. It's also semantically clear which part of code is generated 
and which generates. Although we allow only two level quotation, to do not confuse
programmer by multi-layered code, it's easy to recurse through structure of
program. 

\section{First examples}
Let's suppose we want to add some new syntax to our language, like
\kw{for} loop. We could embed it into compiler, but it is rather hard
and inelegant way. This addition is quite short and it shouldn't
involve much effort to complete. And here is the place, where we can
use macro.

\begin{verbatim}
macro for (init, cond, change, body) 
{
  <[ 
    $init;
    def loop () {
      if ($cond) { $body; $change; loop() } 
      else () 
    }; 
    loop ()
  ]>
}
\end{verbatim}

This code creates special meta-function, which, for every place where it's
called, is executed during compile-time. After that, its result is 
inserted into program. Always when we write something like

\begin{verbatim}
  for (i <- 0; i < n; i <- i + 2, a[i] <- i)
\end{verbatim}

appropriate code is created according to the \kw{for} macro, 
which replaces original call.

We can also instruct compiler to extend its syntax, to allow usual (C-like)
usage of \kw{for} loop. Writing

\begin{verbatim}
  macro for (init, cond, change, body) 
  syntax ("for", "(", init, cond, change, ")", body) { ... }
\end{verbatim}

would add new rule to parser, which allows using

\begin{verbatim}
  for (i <- 0; i < n; i <- i + 2) a[i] <- i
\end{verbatim}

as shortcut to call mentioned before.

Macros are very useful for initial checking and processing of code
written as strings in programs. This relates to many simple languages,
like SQL, regular expressions, printf formatting string, which are often
used inside programs directly. 

Let's consider common situation, when we want to parameterize SQL query
with some values from our program. Most database providers in 
\netf\ allows us to write commands with parameters, but neither their
syntax is checked during compilation, nor types are controlled to agree
between database and program.

With well written macro, we could write
\begin{verbatim}
  sql_loop (conn, "SELECT salary, LOWER (name) AS lname"
                  "  FROM employees"
                  "  WHERE salary > $min_salary") {
    print ("$lname : $salary\n")
  }
\end{verbatim} %$

to obtain syntax and type-checked SQL query and code of following form
\begin{verbatim}
  def cmd = SqlCommand ("SELECT salary, LOWER (name)"
                        "  FROM employees"
                        "  WHERE salary > @parm1", conn);

  (cmd.Parameters.Add (SqlParameter ("@parm1", DbType.Int32)))
    .Value <- min_salary;
  def r = cmd.ExecuteReader ();
  while (r.Read ()) {
    def salary = r.GetInt32 (0);
    def lname = r.GetString (1);
    print ("$lname : $salary\n")
  }
\end{verbatim}

In fact \verb,print, function here is another macro, that generates following
code, basing on given string parameter:

\begin{verbatim}
  System.Console.Write (lname.ToString ());
  System.Console.Write (" : ");
  System.Console.Write (salary.ToString ());
  System.Console.Write ("\n")
\end{verbatim}

\section{Variable amount of arguments}
\subsection{Implementation of SQL macro}
We will now show how to implement above macro, showing also some new
features or our meta-system.

\begin{verbatim}
  macro sql_loop (conn, query : string, body) 
  syntax ("sql_loop", conn, query, body)
  {
    def (columns, parameters) = parse_sql (query);
    <[ 
      def cmd = SqlCommand ($(query : string), conn);
      {.. $(create_parameters (parameters, 0, [])) };
      def r = cmd.ExecuteReader ();
      while (r.Read ()) 
        {.. $(create_results (columns, 0, [body])) } 
    ]>
  }
\end{verbatim} %$

First we need to parse query string to check if it is a proper SQL
statement. We do this during execution of macro with function
\begin{verbatim}
  parse_sql : string ->   list (string * string) 
                        * list (string * string)
\end{verbatim}
which returns lists of columns and parameters used in query. This
function returns also their types, which must be obtained by accessing
database (during compile-time) or reading special files describing
it. We do not include definition of this function, because it doesn't
relate to this paper and involves just parsing and database querying.

More interesting things happen later, when we want to include preparation
of query parameters and reading of columns into result of our macro. 
It's done by creating two sequences of expressions from lists returned by local
functions \verb,create_parameters, and \verb,create_results,. 

Special syntax \verb,{.. $args }, is used to build sequence,  %$
which may have variable amount of arguments. Normally we would write
\verb,{ e1; e2; e3; },, but when amount of expressions is not known, special
syntax is used for writing something like \verb,{ e1; e2; ... },. 

Definitions of \verb,create_parameters, and \verb,create_results, functions
are following:

\begin{verbatim}
  def create_parameters (parms, i, acc) {
    match (parms) {
      | [] => List.rev (acc)
      | (name, type_name) :: xs =>
        create_parameters ( xs, i + 1, <[ (cmd.Parameters.Add 
          (SqlParameter ($("@parm" + i.ToString() : string),
          DbType.$(type_name : var)))).Value <- $(name : var); 
        ]> :: acc)
    }
  };

  def create_results (res, i, acc) {
    match (parms) {
      | [] => List.rev (acc)
      | (res_name, type_name) :: xs =>
        create_results ( xs, i + 1,
         <[ def $(res_name : var) = 
             r.$("Get" + type_name : name) ($(i : int)) ]> :: acc)
    }
  };
\end{verbatim}

Those functions use types returned by \verb,parse_sql, to build assignments 
and casts, that are typesafe.

\subsection{Some complex usage of variable arguments syntax}
Quotation gives us full freedom in constructing any kind of expression.
For example we can decompose tuples of any size and print its elements.

\begin{verbatim}
  macro PrintTuple (tup, size : int)
  {
    def symbols = array (size);
    mutable pvars <- [];
    for (mutable i <- size - 1; i >= 0; i <- i - 1) {
      symbols[i] <- NewSymbol ();
      pvars <- <[ pattern: $(symbols[i] : var) ]> :: pvars;
    };
    mutable exps <- [];
    for (mutable i <- size - 1; i >= 0; i <- i - 1)
      exps <- <[ WriteLine ($(symbols[i] : var)) ]> :: exps;

    exps <- <[ def (.. $pvars) = $tup ]> :: exps;
    <[ {.. $exps } ]>
  }
\end{verbatim} %$

Note that here we need number describing size of tuple. Later, we show how
to obtain type of given expression within macro, thus also size of tuple
described by \verb,tup, variable.

\section{Pattern matching on programs}
Quotation can be used to analyze structure of program as easily as generate
it. Standard mechanisms of language, like pattern matching, fit perfect
for such a purpose. 

Let's suppose, we want to check code for occurrences of following buggy
fragments:
\begin{verbatim}
 if ( foo != null && foo.bar || foo.blah ) foo.blah
\end{verbatim}

We write macro, which inspects given program to signal such constructs.
\begin{verbatim}
macro analyze (exp) : void 
{
  def traverse (ex, checked) {
    match (exp) {
      | <[ $(name : var) != null ]> => checked.Add (name)
      | <[ $(name : var).$(_) ]> => 
        if (!checked.Contains (name)) 
          throw MaybeBug() 
        else 
          checked
      | <[ $e1 && $e2 ]> => traverse (e2, traverse (e1, checked))
      | <[ $e1 || $e2 ]> => 
        def chck1 = traverse (e1, checked);
        def chck2 = traverse (e2, checked);
        Intersect (chck1, chck2)
      | <[ if ($cond) $e1 else $e2 ]> =>
        traverse (e1, traverse (cond, checked));
        traverse (e2, checked)
      | _ => Macros.ApplyExpr (fun (x) { traverse (x, checked) }, 
                               exp)
    }
  };
  Macros.ApplyExpr (fun (x) { traverse (x, Set ()) }, exp)
}
\end{verbatim} %$

\section{Macros on declarations} \label{Declarations}
Macros can operate not only on expressions, patterns, types, but on
any part of language, like classes, interfaces, other type declarations,
methods, etc. Syntax for those operations is quite different. We again
treat language constructs as data objects, which we transform, but
it doesn't involve quotation. We use special API provided by those
objects.

With such a tool, we can analyze, generate or change any declaration
in program. For example, dump definition of each data structure 
to XML file, create serialization methods, automatically
generate fields or methods from external description.

Such macros aren't called like ordinary functions, but added as
attributes at the head of declaration, in similar way to \cs attributes.

\begin{verbatim}
  [ToXML ("Company")] public module Company {
    [SerializeBinary ()] public class Employee {
      ...
    }

    [FromXML ("Product"), Comparable ()] public class Product;
  }
\end{verbatim}

FIXME: ADD DETAILED SECTION

\section{Aspects-oriented programming}
AOP has been proposed as technique for separating of different 
\emph{concerns} in software. It's often a problem, when they crosscut 
natural modularity of the rest of implementation and must be written 
together in code, leading to tangled code. 

In contrary to many other systems, which define fixed \emph{join points}
in code (like AspectJ \cite{AspectJ}), macros allow to place user code in 
arbitrary parts of program. One can write a macro, which traverses all classes
and add some behavior to their bodies. Defining these points isn't
restricted to any design, but user can write a program that defines them.

In general it should be possible to implement most Aspects-oriented
and Adaptive-programming systems' design with more or less complex 
macros.

\section{Details of our design}
We provide more formal definition of macro and our meta-system.

FIXME: THIS IS OBSOLETED
Macro is a top-level function, which may have modifiers 
\verb,public,, or \verb,private, and resides in standard \net/\nem namespace. 
Private macro may be accessed only within file, where it's defined. 
It can have standard name, which is considered in program as name of standard
function (but it's treated in special way by compiler).

Its formal parameters' types are restricted to the set of \nem 
grammar elements (including simple literal types). Parameters of 
macro are passed always as their syntax trees, which for some
types are partially decomposed. For example literal types appear
within macro as real values (int, string, etc.), but they are passed
as syntax trees, so they must be given as constant literals (it's
obvious since these values must be known at compile-time).

\subsection{Macro as a function}
Macro is never recursive and can't be passed as first class citizen.
But still, it can use any function from entire program in standard ML
fashion, so we consider this as minor disadvantage. If complex 
computations on syntax trees are needed, one must simply put them 
into some arbitrary functions and run entire computation from within a macro. 
Such design allows to easily distinguish which functions are run at
compile-time without any special annotations.

\subsection{Names binding in quotation}
Much attention is given by researchers to property of meta-system called
``hygienic'' macros. It specifies that each variable or name generated
by macro is bounded to its definition in the scope where it appears
in meta-code, not necessary where it would be bounded in generated code.
Consider following example:

\begin{verbatim}
  macro identity (e) { <[ def f (x) { x }; f($e) ]> }
\end{verbatim} %$

Called it with \verb,identity (f(1)), might generate confusing code like

\begin{verbatim}
  def f (x) { x }; f (f (1))
\enf{verbatim}

To preserve names capture, all variables should be renamed to their
unique counterparts, like in

\begin{verbatim}
  def genf (genx) { genx }; genf (f (1))
\enf{verbatim}

In general all variables and constructor names from object language
should bind to lexical occurrence of their definition. When it's necessary
renaming is done (definition appears within the same quotation).
Sometimes also expansion of full namespace of given class is needed,
e.g.,

\begin{verbatim}
  using System.Text.RegularExpressions;

  public module Finder 
  {
    public static current : string;

    macro finddigit (x : string)
    {
      <[ 
        def x = Regex (@"\d+-\d+");
        def m = x.Match (current);
      ]>
    }
  }
\end{verbatim}

brings some dependency on currently imported namespaces. We would like
generated code to behave the same no matter where it resides, thus 
\verb,Regex, constructor and \verb,current, variable should be prefixed
with their full namespace -- \verb,System.Text.RegularExpressions.Regex,
and \verb,Finder.current, respectively. This operation is automatically
done by quotation system.

Note that there is no possibility to override security permissions this
way. Access rights from lexical scope of macro aren't exported to place
where generated code is placed. \net policies doesn't allow this, thus
programmer must not generate code, which access private fields, etc.

\subsection{Accessing compiler internals}
It's important for meta-functions to be able to use all benefits they have
from running at compile-time. They can retrieve informations from
compiler, use its methods to access, analyze and change data stored
in its internal structures. 

\subsubsection{Retrieving declarations}
For example we can ask compiler to give us \emph{type declaration} of
given \emph{type}. It will be available as syntax tree, just like we
would put special macro attribute \ref{Declarations} before that declaration.
Of course it must not be external type, and be available within compiled 
program as source code.

FIXME: MORE COMPLEX EXAMPLE
\begin{verbatim}
  def decl = Compiler.GetDeclaration (<[ type: Person ]>);
  xmlize (decl);
\end{verbatim}

\subsection{Working on object program datatypes}
Also object programs have some internal data and functionality associated 
with them, like location in source code. When working with type 
declarations wide range of interoperability is available through
special API for macros.

\section{Runtime program generation}
It might be possible, but we didn't think about it yet.

Uses: optimizations for runtime accessible data only,
dynamic profiling of long running code, etc.

\section{Typing during execution of macro}
Some more advanced techniques are also possible. They involve closer
interaction with compiler, using its methods and data structures
or even interweaving with internal compilation stages.

For example we can ask compiler to type some of object programs,
which are passed to macro, retrieve and compare their types or to try 
to find common type, which is subtyped by all elements of set of
object programs. This means, that we can plug between many important 
actions performed by compiler, adding our own code there. It might
be just some nicer bug reporting (especially for macros defining
complex syntax extensions), making code generation dependent on
types of input programs or enrich analysis of code by additional
information.

\subsection{Example}
Let's consider following translation of \kw{if} condition to standard
ML matching:

\begin{verbatim}
  macro ifmacro (cond, e1, e2)
  syntax ("if", "(", cond, ")", e1, "else", e1) 
  {
    <[ 
      match ($cond) {
        | true => $e1
        | false => $e2
      }       
    ]>
  }
\end{verbatim} % $

If somebody wrote \verb,if (x) 1 else "no",, compiler would comply
that types of match cases don't fit each other. Such error message could
be very confusing, because programmer may not know, that his \verb,if,
statement is being transformed to \verb,match, statement. Thus, we would
like to check few thing during execution of macro.

\subsection{Usage}
Instead of directly passing object expressions to the result of macro, we
can first make compiler type them and then find out if they have proper
type. The body of above \kw{if} macro is

\begin{verbatim}
   def tcond = TypedExpr (cond);
   def te1 = TypedExpr (e1);
   def te2 = TypedExpr (e2);
   match ( tcond.Type == <[ ttype: bool ]> ) {
     | true =>
       match ( UnifiesTo (te1.Type, te2.Type) ) {
         | Some =>
           <[ 
             match ($(tcond : typed)) { 
               | true => $(te1 : typed) 
               | false => $(te2 : typed) 
             } 
           ]>
         | None =>
           FailWith ("`if...else' body has type " + te1.Type.ToString() + 
                     " while the `else' clause has type " + te2.Type.ToString())
     | _ =>
       FailWith ("`if' condition must have type bool, while it has " + 
                 tcond.Type.ToString())
   }
\end{verbatim}
%$

Note that typed expressions are again used in quotation, but with special 
splicing tag ``typed''. This means, that compiler need not to perform typing
(indeed, it can't do this from now on) on provided syntax trees. Such notation
introduces some kind of laziness in typing, which is directly guided by
programmer of a macro.

\section{How it works}
We will now describe how our meta-programming system works internally. Each
macro is translated to separate class implementing special interface. 
It provides method to run the macro, which in most cases involves passing
it the list of \nem grammar elements (untyped syntax trees of object 
programs). 

\subsection{Operating on syntax trees}
When we consider object programs passed to \emph{Run} function as datatypes
of compiler's internal representation of syntax trees, then macros are 
simply functions operating on them. In the matter of fact programmer can
directly open compiler's data namespaces and build syntax trees using its
constructors. 

Quotation system is just a shortcut for doing this. For example \verb,f(x),
expression is represented as \verb.E_call ("f", [Parm (E_ref ("x"))]).,
which is equivalent to \verb,<[ f (x) ]>,. Translating the quotation brings
us to one more level of this ``lifting'', when we are given the representation
of some program (syntax tree) and we must create representation of this tree,
just as it would be the program. This implies building syntax tree of given
syntax tree, like:

\begin{verbatim}
E_call ("f", [Parm (E_ref ("x"))] =>
  E_call ("E_call", [Parm (E_litral (L_string ("f")));
    Parm (E_call ("Cons", [Parm (E_call ("Parm", 
      [Parm (E_call ("E_ref", 
         [Parm (E_literal (L_string ("x")))]))]))]))])
\end{verbatim}

or when using quotation

\begin{verbatim}
<[ f (x) ]> =>
  <[ E_call ("f", [Parm (E_ref ("x"))]) ]>
\end{verbatim}

Now splicing means just ``do not lift'', because we want to pass value of 
meta-language expression as object code. Of course it is only valid when this 
expression describes (is type of) syntax tree. Operator \verb,.., inside 
quotation is translated as syntax tree of list containing lifted expressions 
from provided list (which must occur after \verb,..,).

One more thing to consider are the typed trees possibly stored in the result
of executed macro. We need special element in not typed syntax tree, which
holds typed tree inside and which is treated in the special way during real
typing by compiler. It is dereferenced and took as it would be a result of 
recursive typing procedure. 

\subsection{Typing macros}
Key element of meta-programming is execution of meta-programs during compile-time.
To do this we must have them in executable form, and thus compile them before
they are used. 

FIXME: DESCRIBE OUR RESTRICTED APPROACH

Of course this procedure might quickly lead to cycle, when somebody uses
macro, which is just created, then it's impossible to compile such a code.
We forbid this and require that macros are independent (no cycles going 
through any newly declared macro). This is also the good design decision,
which encourage programmers to put macros in libraries.

\subsection{Compiling and loading}
FIXME: WRITE IT DOWN!

\section{Related works}
FIXME: BORING (BUT INSPIRING) WORK WITH COMPARISONS AND GOOGLING


%
% ---- Bibliography ----
%
\begin{thebibliography}{}
%
\bibitem {Lisp:Scheme}
Scheme Lisp

\bibitem {Haskell:Meta}
Sheard, T., Jones, S. P.:
Template Meta-programming for Haskell.
Haskell Workshop, Oct. 2002, Pittsburgh

\bibitem {Meta:Accomplishments}
Sheard, T.:
Accomplishments and Research Challenges in Meta-Programming
2001

\bibitem {AspectJ}
AspectJ

\end{thebibliography}

\end{document}
