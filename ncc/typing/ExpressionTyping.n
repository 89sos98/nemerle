/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Tyexpr;
using Nemerle.Compiler.Tyops;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
public module Tyexpr {
  public type CTX = TypingContext;

  variant CallResult
  {
    | Unspecified_error
    | Error { msg : string; }
    | Ok { call : TExpr; sub : Subst; }
  }

  class Typing_error : System.Exception
  {
    public msg : string;
    public this (s : string) { this.msg = s; }
  }

  public type_of (expr : TExpr) : TType
  {
    if (expr.ty == null) Util.ice ("type of TT.TExpr was not initialized")
    else expr.ty;
  }

  fixup (expr : TExpr, loc : Location, t : TType) : TExpr
  {
    expr.loc = loc;
    expr.ty = t;
    expr
  }

  fixup (expr : TExpr, t : TType) : TExpr
  {
    expr.loc = Location_stack.top ();
    expr.ty = t;
    expr
  }

  public expect_type (name : string, expr : TExpr, t : TType) : void
  {
    def type_of_expr = type_of (expr);
    if (type_of_expr >:> t) ()
    else {
      match (type_of_expr) {
        | TType.Variable ({ value = TvValue.FreeFromNull }) =>
          Message.error (expr.loc, $ "cannot convert from null value to `$(t)' in $name")
        | _ =>
          Message.error (expr.loc, $ "$name was expected to have type $t "
                         "while it has $type_of_expr")
      }
    }
  }


  squash_type_duplicates (lst : list [Symbol]) : list [Symbol]
  {
    def ht = Hashtable ();
    def unalias (ti : TypeInfo) {
      match (ti.GetTydecl ()) {
        | TypeDeclaration.Alias (TType.Class (ti, _)) => unalias (ti)
        | _ => ti
      }
    }
    List.Filter (lst, fun (_) {
      | Symbol.Type (ti) =>
        def ti = unalias (ti);
        if (ht.Contains (ti.GetId ()))
          false
        else {
          ht [ti.GetId ()] = null;
          true
        }
      | _ => true
    })
  }

  // given an expression return list of symbols it can expand to
  make_value_reference (ctx : CTX, expr : PT.PExpr, fallback : bool) : list [TExpr]
  {
    def lookup_type (expr) {
      match (Util.qidl_of_expr (expr)) {
        | Some ((r, name)) =>
          name.GetEnv (ctx.env).LookupType (r, ctx.parent_type)
        | _ => None ()
      }
    };

    def unalias (ti : TypeInfo) {
      match (ti.GetTydecl ()) {
        | TypeDeclaration.Alias (TType.Class (ti, _)) => unalias (ti)
        | _ => ti
      }
    };

    def lookup_ctors (ti : TypeInfo) {
      def ti = unalias (ti);
      def is_ctor (m : IMember) {
        match (m.GetKind ()) {
          | MemberKind.Method (m) =>
            match (m.GetFunKind ()) {
              | FunKind.Constructor when m.CanAccess (ctx.parent_type) => true
              | _ => false
            }
          | _ => false
        }
      };
      match (List.Filter (ti.LookupMember (".ctor"), is_ctor)) {
        | [] when !ti.IsValueType =>
          Message.fatal_error ($"type `$(ti.FullName)' has no accessible constructors")
        | decls => decls
      }
    };

    def convert_symbols (acc, syms) {
      def syms = squash_type_duplicates (syms);

      def handle_type_construction (t : TypeInfo) {
        def mkctor (m : IMember) {
          def ty =
            match (m.GetMemType ()) {
              | TType.Function (arg, TType.Void) =>
                def ret_t =
                  match (t.GetTydecl ()) {
                    | TypeDeclaration.VariantOption =>
                      def t' = Option.UnSome (t.SuperClass ());
                      t'.GetMemType () /- t.SubtypingSubst (t')
                    | _ =>
                      t.GetMemType ()
                  };
                def ret = TType.Function (arg, ret_t) /- t.FreshSubst ();
                // Message.debug ($ "arg $arg ret $ret");
                ret
                
              | t => Util.ice ($ "fscked ctor type $t")
            };
          TExpr.StaticRef (loc = expr.loc, ty = ty, mem = m)
        };

        match (t.GetTydecl ()) {
          | TypeDeclaration.Alias (TType.Class (t, _)) => handle_type_construction (t)
          | _ =>
            if (t.Attributes %&& NemerleAttributes.Abstract)
              Message.fatal_error ($"type `$(t.FullName)' is abstract and cannot be constructed");
            else
              match (t.GetConstantObject ()) {
                | None =>
                  def is_empty_ctor (e) {
                    type_of (e) matches TType.Function (TType.Void, _)
                  }
                  def res = List.RevMap (lookup_ctors (t), mkctor);
                  if (t.IsValueType && !List.Exists (res, is_empty_ctor)) {
                    def ty = TType.Function (TType.Void (), t.GetMemType () /- t.FreshSubst ());
                    TExpr.ImplicitValueTypeCtor (loc = expr.loc,
                                                ty = ty,
                                                tc = t) :: res
                  } else res
                | Some (f) =>
                  [TExpr.ConstantObjectRef (loc = expr.loc,
                                          ty = TType.Function (TType.Void (),
                                                      f.GetMemType () /-
                                                      t.FreshSubst ()),
                                          mem = f)]
              }
          }
      };
      
      def last_chance () {
        match ((acc, syms)) {
         | ([], [_]) => true
         | _ => false
        }
      };
        
      def can_access (sym) {
        | Symbol.TypeMember (x) => x.CanAccess (ctx.parent_type)
        | Symbol.Type (t) => t.CanAccess (ctx.parent_type)
      };

      match (syms) {
        | [] => acc
          
        | (Symbol.TypeMember (x) as sym) :: xs when x.IsStatic =>
          if (can_access (sym)) {
            def acc =
              match (x.GetKind ()) {
                | MemberKind.Type (t) =>
                  List.RevAppend (handle_type_construction (t), acc)
                    
                | MemberKind.Method (m) =>
                  match (m.GetExternName ()) {
                    | None =>
                      TExpr.StaticRef (loc = expr.loc, ty = m.GetFreshType (),
                                    mem = x) :: acc
                                    
                    | Some (name) =>
                      m.HasBeenUsed = true;
                      def split_at_dots (str : string) {
                        def idx = str.LastIndexOf ('.');
                        if (idx == -1) PT.PExpr.Ref (PT.Name (str))
                        else PT.PExpr.Member (split_at_dots (str.Substring (0, idx)),
                                          PT.Splicable.Name (PT.Name (str.Substring
                                          (idx + 1))))
                      };
                      def exprs =
                        make_value_reference (ctx, split_at_dots (name),
                                              fallback = false);
                      def valid (expr) {
                        match (expr) {
                          | TExpr.StaticRef (mem) =>
                            Tyutil.types_eq (mem.GetMemType (), m.GetMemType ())
                          | _ => false
                        }
                      };
                      match (List.Filter (exprs, valid)) {
                        | [x] => x :: acc
                        | [] => Message.fatal_error ("unbound extern symbol `" + name + "'")
                        | _ => Message.fatal_error ("wrong extern symbol `" + name + "'")
                      }
                  }
                    
                | MemberKind.Property (p) =>
                  TExpr.StaticPropertyRef (loc = expr.loc, ty = x.GetMemType (),
                                         prop = p) :: acc
                                           
                | MemberKind.Field =>
                  TExpr.StaticRef (loc = expr.loc, ty = x.GetMemType (), mem = x)
                  :: acc

                | MemberKind.Event (e) =>
                  if (e.DeclaringType.Equals (ctx.parent_type)) {
                    def field = (e :> NemerleEvent).storage_field;
                    if (field == null)
                      acc
                    else {
                      TExpr.StaticRef (loc = expr.loc, ty = field.GetMemType (),
                                    mem = field) :: acc
                    }
                  }
                  else
                    acc
              }
              
            convert_symbols (acc, xs)
          }
          else
          {
            when (last_chance ())
              Message.error ($"cannot access `$(x.DeclaringType.FullName).$(x.Name)'");
            convert_symbols (acc, xs)
          }
          
        | Symbol.TypeMember :: xs => convert_symbols (acc, xs)
          
        | (Symbol.Type (t) as sym) :: xs when can_access (sym) =>
          convert_symbols (List.RevAppend (handle_type_construction (t), acc), xs)
          
        | Symbol.Type (t) :: xs =>
          when (last_chance ())
            Message.error ("cannot access type `" + t.FullName + "'");
          convert_symbols (acc, xs)
      }
    };

    def error_when_empty (lst, msg) {
      match (lst) {
        | [] => Message.fatal_error (msg)
        | _ => lst
      }
    };

    Util.locate (expr.loc, {
      match (expr) {
        | PT.PExpr.Ref (n) =>
          match (ctx.LookupLocal (n)) {
            | Some (d) =>
              ctx.Closurise (d);
              d.ever_used = true;
              def ty =
                match (d.kind) {
                  | LocalValueKind.Function (h, _) =>
                    d.ty /- Tyvar.fresh_subst (h.typarms)
                  | _ => d.ty
                };
              [TExpr.LocalRef (loc = expr.loc, ty = ty, decl = d)]
              
            | None =>
              def from_this =
                match (ctx.this_ptr_decl) {
                  | Some ({ty = TType.Class (ti, _)}) =>
                    def is_instance (m : IMember) { !m.IsStatic };
                    def mem = n.Id;
                    if (List.Exists (ti.LookupMember (mem), is_instance))
                      lookup_member (ctx, expr.loc,
                                     ty_expr (ctx, PT.PExpr.This ()), mem,
                                     error_when_not_found = false)
                    else []
                  | _ => []
                };
                
              // resolve the symbols list
              def env = n.GetEnv (ctx.env);
              def symbols_from_env = env.LookupSymbol (n.idl);
              def res = convert_symbols (from_this, symbols_from_env);

              match (res) {
                | [] =>
                  // take into account static symbols from the current type
                  def ref_name = n.FullId;
                  def from_parent_type = ctx.parent_type.LookupMember (ref_name);
                  
                  def static_and_name_filter (mem : IMember) {
                      mem.Name == ref_name &&
                      (mem.Attributes %&& NemerleAttributes.Static)
                  };
                  def symbol_map (mem : IMember) : Symbol {
                      Symbol.TypeMember (mem)
                  };
                  def symbols_from_type =
                    List.RevMap (List.Filter (from_parent_type,
                                              static_and_name_filter), symbol_map);

                  def res = convert_symbols ([], symbols_from_type);

                  match (res) {
                    | [] =>
                      // if failed to resolve the symbols, check the possible reason
                      def instance_mems =
                        List.Filter (from_parent_type,
                                     fun (mem : IMember) {
                                       mem.Name == ref_name &&
                                       !(mem.Attributes %&&
                                       NemerleAttributes.Static)
                                     });

                      match (instance_mems) {
                        | [] =>
                          error_when_empty (res, "unbound symbol `" +
                          n.FullId + "'")
                      
                        | _ =>
                          Message.fatal_error ("referencing an instance member `" +
                                               ref_name + "' from within a static method");
                          []
                      }
                    | _ => res
                  }
                | _ => res
              }                  
          }

        | PT.PExpr.Member (e1, PT.Splicable.Name (x)) =>
          def x = x.Id;
          match (lookup_type (e1)) {
            | Some (t) =>              
              def err = $"unbound member `$(x)' in type `$(t.FullName)'";
              def t = unalias (t);
              match (t.LookupMember (x)) {
                | [] =>
                  match (lookup_type (expr)) {
                    | Some (t) =>
                      convert_symbols ([], [Symbol.Type (t)])
                    | None =>
                      Message.fatal_error (err)
                  }
                | lst =>
                  def loop (x : IMember, acc) { 
                    if (x.IsStatic)
                      Symbol.TypeMember (x) :: acc
                    else acc
                  };
                  def lst' = List.FoldLeft (lst, [], loop);
                  error_when_empty (convert_symbols ([], lst'), err)
              }
            | None =>
              match (lookup_type (expr)) {
                | Some (t) => convert_symbols ([], [Symbol.Type (t)])
                | None =>                        
                  def typed_base_expr = ty_expr (ctx, e1);

                  if (typed_base_expr matches TExpr.Literal (Literal.Null))
                  {
                    def base_name =
                      match (Util.qidl_of_expr (e1)) {
                        | Some ((r, _)) =>
                          Util.qid_of_list (r)
                        | _ =>
                          Util.ice ("base_name")
                      };
                    
                    def lead_in_msg =
                      "failed to find namespace or type `" +
                      base_name + "' for accessing `" + x +"'";
                        
                    if (base_name == "System" || base_name == "Nemerle") {
                      Message.error (lead_in_msg);
                      Message.hint_once ("  maybe you forgot to reference an external library?");
                      throw Recovery ()
                    }
                    else {
                      if (base_name.LastIndexOf ('.') == -1) {
                        Message.error (lead_in_msg);
                        Message.hint_once ("  maybe you're trying to use a "
                                           "static type member as an instance "
                                           "member or forgot to reference an "
                                           "external library?");
                        throw Recovery ()
                      }
                      else
                        Message.fatal_error (lead_in_msg)
                    }
                  }
                  else
                  {                    
                    lookup_member (ctx, expr.loc, typed_base_expr, x)
                  }
              }
          };

        | PT.PExpr.Member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.PExpr.This =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = TType.Class (ti, _)}); in_ctor = true} =>
              def mkthis (m : IMember) {
                TExpr.Base (loc = expr.loc,
                            ty = m.GetMemType (),
                            base_ctor = (m :> IMethod))
              };
              List.RevMap (lookup_ctors (ti), mkthis)

            | _ =>
              Message.fatal_error ("`this (..)' used outside constructor")
          }

        | PT.PExpr.Base =>
          match (ctx) {
            | {this_ptr_decl = Some ({ty = TType.Class (ti, _)}); in_ctor = true} =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  // FIXME: check access
                  def mkbase (m : IMember) {
                    TExpr.Base (loc = expr.loc,
                            ty = m.GetMemType () /- ti.SubtypingSubst (baseti),
                            base_ctor = (m :> IMethod))
                  };
                  List.RevMap (lookup_ctors (baseti), mkbase)

                | None =>
                  Message.fatal_error ("class " + ti.FullName +
                                       " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base (..)' used outside constructor")
          }

        | PT.PExpr.Literal (l) => 
          [TExpr.Literal (loc = expr.loc, ty = ty_literal (ctx, l), val = l)]

        | _ when fallback => [ty_expr (ctx, expr)]
        | _ => Util.ice ("evil value passed to make_value_reference")
      }
    })
  }

  
  /*
   * Given list of formal parms names and actual parms names, reorder
   * actuals to match formals. The named parameters can be preceded
   * by a series of unnamed parameters:
   *
   *   bar (e_0, e_1, x_2 = e_2, x_3 = e_3, ..., x_k = e_k)
   *
   * where x_i are the named parameter references and e_i are some
   * expressions.
   */
  reorder_named_parms (top_names : list [string],
                       top_parms : list [Parm], 
                       do_throw : bool) : list [Parm]
  {
    // lookup tables for names, named and unnamed parameters
    def valid_names = Hashtable (16);
    def seen_named_parms = Hashtable (16);
    def seen_unnamed_parms = Hashtable (16);

    mutable fscked_formals = false;

    // we will need a way to lookup the valid parameter names
    foreach (name in top_names) {
      assert (name != null);
      when (valid_names.ContainsKey (name))
        fscked_formals = true;
      valid_names [name] = name;
    }

    // failure handler
    def fail (msg : string) : bool
    {
      if (do_throw)
        throw Typing_error (msg)
      else
        false
    }

    // the correctness verifier
    def check_names_and_parms (names : list [string], parms : list [Parm]) : bool
    {
      | ([], []) =>
        true

      | (_, []) =>
        // always throw an error here -- we'll catch it and produce better error
        // for wrong parameters count
        def unresolved_names =
          List.Filter (top_names, fun (name : string) {
            !(seen_named_parms.Contains (name) || seen_unnamed_parms.Contains (name))
          });

        def unresolved_names =
          List.Map (unresolved_names, fun (name : string) { "`" + name + "'" });
          
        throw Typing_error ("unresolved named parameters: " +
                            NString.Concat (", ", unresolved_names))
        
      | (name :: rest_of_names, parm :: rest_of_parms) when parm.name == "" =>
        // the case for an unnamed parameter
        if (seen_named_parms.Count > 0) {
          // seen a named parameter before, error...
          fail ("unnamed parameter found after a named parameter")          
        }
        else {
          // otherwise, this is an element of the leading unnamed parameters
          seen_unnamed_parms.Add (name, parm);
          check_names_and_parms (rest_of_names, rest_of_parms)
        }

      | (_ :: rest_of_names, parm :: rest_of_parms) =>
        // a named parameter, check if no unnamed parameter has covered it before
        if (seen_unnamed_parms.ContainsKey (parm.name)) {
          // this parameter name was covered by an unnamed parameter
          fail ("keyword parameter `" + parm.name + "' already specified as an unnamed parameter")
        }
        else if (seen_named_parms.ContainsKey (parm.name)) {
          // the case for repeating parameters
          fail ("keyword parameter `" + parm.name + "' already specified")
        }
        else if (!valid_names.ContainsKey (parm.name)) {
          // whoops, no such parameter for this method :]
          fail ("no such keyword parameter `" + parm.name + "' among valid parameter names")
        }
        else {
          // OK, this has to be right...
          seen_named_parms.Add (parm.name, parm);
          check_names_and_parms (rest_of_names, rest_of_parms)
        }
      
      | _ =>
        Util.ice ("reorder_named_parms: walk")
    }

    // reordering is a matter of simple names list walk now:
    def reorder_parms (names : list [string], acc : list [Parm]) : list [Parm]
    {
      | (name :: rest_of_names, _) =>
        if (seen_unnamed_parms.Contains (name))
          reorder_parms (rest_of_names,
                         Option.UnSome (seen_unnamed_parms.Get (name)) :: acc)
        else if (seen_named_parms.Contains (name))
          reorder_parms (rest_of_names,
                         Option.UnSome (seen_named_parms.Get (name)) :: acc)
        else
          Util.ice ("reorder_named_parms: reorder")

      | ([], _) =>
        List.Rev (acc)
    }

    if (List.Exists (top_parms, fun (parm : Parm) { parm.name != "" })) {
      if (fscked_formals) {
        Message.warning ($ "tried named parameters, but formals contain "
                           "doublets: $top_names");
        top_parms
      } else
        match (top_names) {
          | [] when do_throw =>
            throw Typing_error ("named parameters given but formals' names cannot"
                                " be inferred")
          | [] =>
            null          
          | _ =>
            if (check_names_and_parms (top_names, top_parms))
              reorder_parms (top_names, [])
            else
              null
        }
    }
    else
      top_parms
  }

  
  // check if FN can be called with PARMS
  check_call_to (ctx : CTX, parms : list [Parm], fn : TExpr, 
                 do_throw : bool, is_var_args : bool) : CallResult
  {
    def check_arg (parm : Parm, ty : TType, arg_no, sub) : int * Subst {
      if (arg_no < 0) (arg_no, sub)
      else {
        def expr_ty = type_of (parm.expr);
        def parm_ty =
          match (ty) {
            | TType.ByRef (t) when parm.kind == ParmKind.Ref => t
            | TType.Out (t) when parm.kind == ParmKind.Out => t
            | TType.Out =>
              if (do_throw)
                throw Typing_error ($ "needed `out' in argument #$arg_no")
              else null
            | TType.ByRef =>
              if (do_throw)
                throw Typing_error ($ "needed `ref' in argument #$arg_no")
              else null
            | _ when parm.kind != ParmKind.Normal =>
              if (do_throw)
                throw Typing_error ($ "argument #$arg_no was passed as ref/out")
              else null
            | _ => ty
          };
        if (parm_ty == null)
          (-1, sub)
        else
          match (Tyutil.unify (sub, expr_ty, parm_ty, true)) {
            | Some (u) =>
              (arg_no + 1, u)
            | None when do_throw =>
              match ((ty /- sub, expr_ty /- sub)) {
                | (TType.Class, TType.Function) =>
                  Message.hint ("maybe you forgot to add `()' after the expression and you "
                                "are referencing constructor functional object instead of object itself?");
                | _ => ()
              }
              throw Typing_error ($ "in arg #$arg_no needed $(ty /- sub) "
                                    "got $(expr_ty /- sub)")
            | None => (-1, sub)
          }
      }
    };

    def formal_names = {
      def from_header (h : Fun_header) : list [string] {
        List.Map (h.parms, fun (p : Fun_parm) : string { p.name })
      };
      match (fn) {
        | TExpr.LocalRef ({kind = LocalValueKind.Function (h, _)}) =>
          from_header (h)
        | TExpr.MethodRef (_, meth, _)
        | TExpr.StaticRef (meth : IMethod) =>
          from_header (meth.GetHeader ())
        | _ => []
      }
    };

    match (Tyutil.top_expand (type_of (fn))) {
      | TType.Function (from, ret) =>
        // check if we are dealing with a delegate constructor
        def delegate_tycon =
          match (fn) {
            | TExpr.StaticRef (meth : IMethod) when (meth.DeclaringType.IsDelegate &&
                                                 (meth.GetFunKind () matches FunKind.Constructor)) =>
              Some (meth.DeclaringType)
            | _ =>
              None ()
          }

        // get the arguments for delegate constructor from the Invoke method
        def args =
          match (delegate_tycon) {
            | Some (delegate_tycon) =>
              match (delegate_tycon.LookupMember ("Invoke")) {
                | [invoke] => 
                  def invoke_ty = (invoke :> IMethod).GetMemType ();
                  [invoke_ty]
                | _ =>
                  Message.fatal_error ("cannot decide upon delegate ctor parameters")
              }
            | _ =>
              Tyutil.fun_args (from)
          }
        
        def wrong_args_cnt (extra_message) {
          if (do_throw)
            throw Typing_error ("needed " + (List.Length (args)).ToString () +
                                " parameters, got " + (List.Length (parms)).ToString () +
                                extra_message)
          else
            null
        };

        try {
          def args =
            match ((parms, args)) {
              | ([parm], _ :: _ :: _) when ! is_var_args =>
                // FIXME: it doesn't work when parm : 'a, where 'a is unconstrained
                match (Tyutil.top_expand (type_of (parm.expr))) {
                  | TType.Product (types) when List.Length (types) == List.Length (args) =>
                    [TType.Product (args)]
                  | _ => wrong_args_cnt ("")
                }
              | _ =>
                if (List.Length (args) == List.Length (parms) ||
                    (is_var_args && List.Length (args) <= List.Length (parms) + 1))
                  args
                else if (List.Length (args) > List.Length (parms) && !is_var_args)
                {
                  def named_parms_message =
                    try {
                      ignore (reorder_named_parms (formal_names, parms, false));
                      ""
                    }
                    catch { e : Typing_error => " (" + e.msg + ")" }
                  
                  wrong_args_cnt (named_parms_message)
                }
                else
                  wrong_args_cnt ("")
            };
          def parms =
            if (args == null) null 
            else reorder_named_parms (formal_names, parms, do_throw);
          def (argno, sub) =
            if (parms == null || args == null) (-1, null)
            else {
              def loop (arg_no, map, parms, args) {
                match ((parms, args)) {
                  | (parm :: parms, [TType.Array (t, 1)]) when is_var_args =>
                    def (arg_no, map) = check_arg (parm, t, arg_no, map);
                    loop (arg_no, map, parms, args) // args doesn't change
                  | ([], [_]) when is_var_args => (arg_no, map)
                  | (parm :: parms, arg :: args) =>
                    def (arg_no, map) = check_arg (parm, arg, arg_no, map);
                    loop (arg_no, map, parms, args)
                  | ([], []) => (arg_no, map)
                  | _ => assert (false)
                }
              }
              loop (1, SystemMap (), parms, args)
            }
          if (argno < 0)
            CallResult.Unspecified_error ()
          else {
            def parms =
              if (is_var_args) {
                def split (_, _, _) {
                  | (acc, [_], lst) =>
                    def get_expr (parm : Parm) {
                      when (parm.kind != ParmKind.Normal)
                        Message.error ("ref/out parameters are not allowed with `parms'");
                      when (parm.name != "")
                        Message.error ("named parameters are not allowed with `parms'");
                      parm.expr
                    }
                    (acc, List.Map (lst, get_expr))
                  | (acc, _ :: args, x :: xs) => 
                    split (x :: acc, args, xs)
                  | _ => assert (false)
                }
                def (regular_parms, for_array) = split ([], args, parms);
                def mkarray = TExpr.Array (fn.loc, List.Last (args), 
                                         for_array, [TExpr.Literal (Literal.Int (List.Length (for_array)))]);
                List.Rev (Parm (mkarray) :: regular_parms)
              } else parms;
            def res_expr =
              match (fn) {
                | TExpr.ConstantObjectRef (mem) =>
                  assert (parms.IsEmpty);
                  TExpr.StaticRef (fn.loc, ret /- sub, mem)
                | TExpr.ImplicitValueTypeCtor =>
                  assert (parms.IsEmpty);
                  fn.ty = ret /- sub;
                  fn
                | _ =>
                  TExpr.Call (fn.loc, ret /- sub, fn, parms)
              };
            CallResult.Ok (res_expr, sub)
          }
        }
        catch { x : Typing_error => CallResult.Error (x.msg) }
        
      | ty when Tyutil.IsDelegate (ty) =>
        match (LookupMembers (ctx, ty, "Invoke")) {
          | [mem] =>
            def fn' = TExpr.MethodRef (fn.loc, mem.GetMemType (), fn, (mem :> IMethod), false);
            check_call_to (ctx, parms, fn', do_throw, is_var_args)
          | _ when do_throw =>
            CallResult.Error ($ "cannot find `Invoke' method in delegate type $(type_of (fn))")
          | _ =>
            CallResult.Unspecified_error ()
        }
        
      | _ when do_throw =>
        CallResult.Error ($ "called value has non-functional type $(type_of (fn))")
                  
      | _ =>
        CallResult.Unspecified_error ()
    }
  }

  transform_tail_call (ctx : CTX, ex : TExpr) : TExpr
  {
    def is_this (expr) {
      match ((expr, ctx.this_ptr_decl)) {
        | (TExpr.This, _) => true
        | (TExpr.LocalRef (x), Some (y)) => x.id == y.id
        | _ => false
      }
    }
    if (ctx.in_tail_position) {
      match (ex) {
        | TExpr.Call ((TExpr.LocalRef ({kind = LocalValueKind.Function (h, _)})) as fn, parms) =>
          if (ctx.current_fun.id == h.id)
            TExpr.SelfTailCall (ex.loc, ex.ty, parms)
          else
            TExpr.TailCall (ex.loc, ex.ty, fn, parms)

        | TExpr.Call ((TExpr.StaticRef (mem)) as fn, parms) =>
          match (mem.GetKind ()) {
            | MemberKind.Method (meth) when meth.GetHeader ().id == ctx.current_fun.id =>
              TExpr.SelfTailCall (ex.loc, ex.ty, parms)
            | _ =>
              TExpr.TailCall (ex.loc, ex.ty, fn, parms)
          }
          
        | TExpr.Call ((TExpr.MethodRef (expr, meth, _)) as fn, parms) when is_this (expr) =>
          if (meth.GetHeader ().id == ctx.current_fun.id)
            TExpr.SelfTailCall (ex.loc, ex.ty, parms)
          else
            TExpr.TailCall (ex.loc, ex.ty, fn, parms)
        
        | TExpr.Call (fn, parms) => TExpr.TailCall (ex.loc, ex.ty, fn, parms)
        | _ => ex
      }
    }
    else ex
  }

  mark_as_used (ctx : CTX, expr : TExpr) : TExpr
  {
    match (expr) {
      | TExpr.Call (TExpr.StaticRef (mem : IMember), _)
      | TExpr.Call (TExpr.MethodRef (_, mem, _), _)
      | TExpr.TailCall (TExpr.StaticRef (mem : IMember), _)
      | TExpr.TailCall (TExpr.MethodRef (_, mem, _), _)
      | TExpr.FieldMember (_, mem)
      | TExpr.ConstantObjectRef (mem)
      | TExpr.PropertyMember (_, mem)
      | TExpr.StaticPropertyRef (mem)
      | TExpr.MethodRef (_, mem, _)
      | TExpr.ImplicitValueTypeCtor (mem) =>
        mem.HasBeenUsed = true

      | TExpr.Call (loca, _) | TExpr.TailCall (loca, _) =>
        match (loca) {
          | TExpr.LocalRef (({kind = LocalValueKind.Function (h, _)}) as decl) =>
            match (h.usage) {
              | FunctionUsage.NotUsed =>
                if (decl.parent_fun.id == ctx.current_fun.id)
                  h.usage = FunctionUsage.UsedJustOnce
                else
                  h.usage = FunctionUsage.Used
              | FunctionUsage.UsedJustOnce =>
                h.usage = FunctionUsage.Used
              | FunctionUsage.Used | FunctionUsage.UsedAsFirstClass => ()
            };
          | _ => ()
        }

      | TExpr.StaticRef (mem) =>
        // mark the constant variant constructor marked if referencing to its const object
        when ((mem is NemerleField) && mem.Name == "_N_constant_object")
        {
          def declaring_type = (mem.DeclaringType :> TypeBuilder);

          foreach (ctor : IMember in declaring_type.LookupMember (".ctor"))
            when ((ctor :> IMethod).GetHeader ().parms matches [])
              ctor.HasBeenUsed = true
        }
        mem.HasBeenUsed = true
      
      | _ => ()
    }
    expr
  }

  
  resolve_overloaded_call (ctx : CTX, in_tail_pos : bool, fncs : list [TExpr],
                           parms : list [Parm]) : TExpr
  {
    def is_var_args (fn) {
      | TExpr.StaticRef (meth : IMethod)
      | TExpr.MethodRef (_, meth, _) 
      | TExpr.Base (meth) =>
        meth.IsVarArgs        
      | _ => false
    };
    
    def check_one (fn, acc) {
      match (check_call_to (ctx, parms, fn, false, false)) {
        | CallResult.Ok (ex, sub) => (ex, sub) :: acc
        | _ => acc
      }
    };

    def check_one_va (fn, acc) {
      if (is_var_args (fn))
        match (check_call_to (ctx, parms, fn, false, true)) {
          | CallResult.Ok (ex, sub) => (ex, sub) :: acc
          | _ => acc
        }
      else acc
    };

    def check_error (fn, acc) {
      match (check_call_to (ctx, parms, fn, true, false)) {
        | CallResult.Error (msg) =>
          def acc = (msg, fn) :: acc;
          if (is_var_args (fn))
            match (check_call_to (ctx, parms, fn, true, true)) {
              | CallResult.Error (msg) =>
                (msg, fn) :: acc
              | _ => assert (false)
            }
          else acc
        | _ => assert (false)
      }
    };

    mutable used_var_args = false;

    def res = List.FoldLeft (fncs, [], check_one);
    def res =
      // varargs version is used *only* if there is no match not using it
      match (res) {
        | [] => 
          used_var_args = true;
          List.FoldLeft (fncs, [], check_one_va)
        | _ => res
      };

    match (res) {
      // special case (simple)
      | [(x, sub)] =>
        Tyvar.global_store (sub);
        def x = transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x);
        mark_as_used (ctx, x);
        
      | [] =>
        match (List.FoldLeft (fncs, [], check_error)) {
          | [(err, fn)] =>
            Message.error (err + " calling " + describe_expression (fn)); 
            throw Recovery ()
          | p =>
            Message.error ("typing error in call:");
            foreach ((err, fn) in p)
              Message.error ("  " + err + " calling " + describe_expression (fn)); 
            throw Recovery ()
        }
        
      // in general we look for set of maximal argument types
      | l =>
        def get_type (ex : TExpr, s : Subst) : TType * (TExpr * Subst) {
          match (ex) {
            | TExpr.Call (fn, _) =>
              match (Tyutil.top_expand (type_of (fn))) {
                | TType.Function (t1, _) =>
                  if (used_var_args)
                    match (List.DivideLast (Tyutil.fun_args (t1))) {
                      | ([], TType.Array (t, 1)) =>
                        (t, (ex, s))
                      | (fun_args, TType.Array (t, 1)) =>
                        (TType.Product (fun_args + [t]), (ex, s))
                      | _ => assert (false)
                    }
                  else
                    (t1, (ex, s))
                | _ => Util.ice ()
              }
            | _ => Util.ice ()
          }
        };

        match (Tyutil.maximal_types (List.Map (l, get_type))) {
          | [(_, (x, sub))] =>
            Tyvar.global_store (sub);
            def x = transform_tail_call (ctx.WithInTailPosition (in_tail_pos), x);
            mark_as_used (ctx, x);
            
          | l =>
            Message.error ("overloading resolution ambiguity between:");
            foreach ((_ : TType, (TExpr.Call (ex, _), _) : TExpr * Subst) in l) {
              def ex_t = type_of (ex);
              Message.error ($ "    functional value of type $ex_t")
            }
            /*
            | (TExpr.Call (TExpr.E_ref (d), _), _) =>
              // FIXME: we could do better
              Message.error (d.loc, $ "    functional value of type $(d.ty)")
            */
            throw Recovery ()
        }
    }
  }

  public LookupMembers (ctx : CTX, t : TType, mem : string) : list [IMember]
  {
    def visited = Hashtable (10);
    def return = Hashtable (10);

    def collect_from (t) {
      match (Tyutil.top_expand (t)) {
        | TType.Class (ti, _) =>
          unless (visited.Contains (ti.GetId ())) {
            visited.Add (ti.GetId (), null);
            def members = ti.LookupMember (mem);
            foreach (mem : IMember in members)
              when (!mem.IsStatic && mem.CanAccess (ctx.parent_type))
                return.Add (mem.GetId (), mem)
          }

        | TType.Variable (tv) =>
          unless (visited.Contains (tv.id)) {
            visited.Add (tv.id, null);
            def constraints =
              match (tv.GetConstraints ()) {
                | [] => [InternalType.Object : TType]
                | lst => lst
              };
            List.Iter (constraints, collect_from)
          }

        | TType.Array => collect_from (InternalType.Array)

        | _ => ()
      }
    };

    collect_from (t);
    return.Fold ([], fun (_, el, acc) { el :: acc })
  }

  public lookup_member (ctx : CTX, loc : Location, o : TExpr, mem : string)
  : list [TExpr]
  {
    lookup_member (ctx, loc, o, mem, true);
  }
  
  // lookup member MEM in type_of (O)
  // return list of how we can call it
  public lookup_member (ctx : CTX, loc : Location, o : TExpr, mem : string, 
                        error_when_not_found : bool) : list [TExpr]
  {
    mutable problem = "???";
    def visited = Hashtable (10);

    def collect_from (t, acc) {
      match (Tyutil.top_expand (t)) {
        | TType.Class (ti, args) =>
          if (visited.Contains (ti.GetId ())) acc
          else {
            visited.Add (ti.GetId (), null);

            def subst = ti.MakeSubst (args);
            def can_access (mem : IMember, acc) {
              if (!mem.IsStatic && mem.CanAccess (ctx.parent_type))
                mem.GetKind () :: acc
              else
                acc
            };
            def members = ti.LookupMember (mem);
            def accessible_members = List.FoldLeft (members, [], can_access);
            def mems =
              match (accessible_members) {
                | [MemberKind.Field (f)] =>
                  [TExpr.FieldMember (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [MemberKind.Event (e)] when 
                    e.DeclaringType.Equals (ctx.parent_type) &&
                    (e :> NemerleEvent).storage_field != null =>
                  def f = (e :> NemerleEvent).storage_field;
                  [TExpr.FieldMember (loc, Tyutil.TypeOfMemberIn (f, ti) /- subst, o, f)]
                | [] =>
                  def is_static (mem : IMember, acc) {
                    if (mem.IsStatic && mem.CanAccess (ctx.parent_type))
                      mem.GetKind () :: acc
                    else
                      acc
                  };
                  def static_members = List.FoldLeft (members, [], is_static);
                  def (prefix, suffix) =
                    match ((members, static_members)) {
                      | ([], _) => ("unbound", "")
                      | (_, []) => ("inaccessible", "")
                      | _ => ("can't access static", " through an instance reference")
                    }
                  
                  problem =
                    prefix + " member `" + mem + "' in type `" +
                    ti.FullName + "'" + suffix;
                  []
                  
                | lst =>
                  mutable was_prop = false;
                  mutable was_meth = false;
                  def make (m) {
                    match (m) {
                      | MemberKind.Property (p) when !was_meth =>
                        was_prop = true;
                        def ty = Tyutil.TypeOfMemberIn (p, ti) /- subst;
                        //Message.debug (loc, $ "prop $(p.Name) : $ty");
                        TExpr.PropertyMember (loc, ty, o, p)
                      | MemberKind.Method (m) when !was_prop =>
                        was_meth = true;
                        TExpr.MethodRef (loc, Tyutil.TypeOfMethodIn (m, ti) /- subst, o, m, false)
                      | _ =>
                        Message.fatal_error ("ambiguous member name `" + mem +
                                             "' in type `" + ti.FullName + "'")
                    }
                  };
                  List.Map (lst, make)
               };
            List.Append (mems, acc)
          }

        | TType.Variable (tv) =>
          if (visited.Contains (tv.id)) acc
          else {
            visited.Add (tv.id, null);
            def constraints =
              match (tv.GetConstraints ()) {
                | [] => [InternalType.Object : TType]
                | lst => lst
              };
            match (List.FoldLeft (constraints, acc, collect_from)) {
              | [] =>
                problem = $ "no constrain of $t provides member `$(mem)'";
                []
              | acc => acc
            }
          }

        | TType.Array => collect_from (InternalType.Array, acc)

        | TType.Product => collect_from (InternalType.Object, acc)

        | _ =>
          problem = $ "type $t was expected to be class";
          acc
      }
    };

    match (collect_from (type_of (o), [])) {
      | [] when error_when_not_found => Message.fatal_error (problem)
      | x => x
    }
  }

  // type given match {} construct
  ty_match (ctx : Tyexpr.CTX, mtch : PT.PExpr.Match) : TExpr * TType
  {
    def itp = ctx.in_tail_position;
    def ctx = ctx.WithInTailPosition (false);
    def matched_value = ty_expr (ctx, mtch.expr);
    mutable disable_warnings = false;

    def do_case (c : PT.MatchCase, acc) {
      when (c.disable_warnings) disable_warnings = true;
      def (pat, ctx') = PatternTyping.TypePatterns (ctx, type_of (matched_value), c.patterns);
      def body = ty_expr (ctx'.WithInTailPosition (itp), c.body);
      match (acc) {
        | (Some (t), l) =>
          match (Tyutil.unify_branches (t, type_of (body))) {
            | Some (t') => (Some (t'), Match_case (pat, body) :: l)
            | None =>
              expect_type ("match case body", body, t);
              Util.ice () // not reached
          }
        | (None, l) =>
          (Some (type_of (body)), Match_case (pat, body) :: l)
      }
    };

    match (List.FoldLeft (mtch.cases, (None (), []), do_case)) {
      | (Some (t), mcs') =>
        def mcs = List.Rev (mcs');
        unless (disable_warnings) PatternTyping.check_matching (mcs);
        foreach (mc : Match_case in mcs) {
          mc.patterns = 
            List.Map (mc.patterns, 
                      fun (p, e) { 
                         (PatternTyping.strip_enums (p), e) 
                      });
          mc.body = TExpr.TypeEnforcement (mc.body, t);
        }
        (TExpr.Match (matched_value, mcs), t)
      | (None, _) =>
        Message.fatal_error ("cannot have empty match construct");
    }
  }

  ty_letfun (ctx : CTX, fs : list [PT.Function_decl]) : list [Function_decl] * CTX
  {
    def make_fun (d : PT.Function_decl) {
      def pars = {
        def h = ctx.current_fun;
        if (h.decl == null) [h]
        else
          match (h.decl.kind) {
            | LocalValueKind.Function (_, pars) => h :: pars
            | _ => Util.ice ()
          }
      };

      def h = d.header;
      def name_obj = h.name.GetName ();
      def (tenv, typarms) = ctx.parent_type.BindTyparms (ctx.tenv, h.typarms);
      def mkparm (p : PT.Fun_parm) : Fun_parm {
        def name = p.name.GetName ();
        Fun_parm (loc = p.loc, name = name.Id, color = name.color,
                  ty = ctx.parent_type.BindType (tenv, p.ty), decl = null,
                  modifiers = p.modifiers)
      };
      def h' = Fun_header (
         ret_type = ctx.parent_type.BindType (tenv, h.ret_type),
         typarms = typarms,
         name = name_obj.Id,
         parms = List.Map (h.parms, mkparm),
         tenv = tenv,
         loc = h.loc);

      def lv = ctx.DefineLocal (name_obj,
                                LocalValueKind.Function (h', pars), 
                                Tyutil.fun_type (h'));
      h'.decl = lv;
      h'
    };

    def headers = List.Map (fs, make_fun);
    def localvals = List.Map (headers, fun (h : Fun_header) { h.decl });
    def ctx = ctx.WithLocals (localvals);
    def do_fun (d : PT.Function_decl, h : Fun_header) : Function_decl {
      Function_decl (h, ty_function (ctx, h, d.body))
    };
    (List.Map2 (fs, headers, do_fun), ctx)
  }

  ty_sequence (ctx : CTX, l : list [PT.PExpr]) : TExpr
  {
    def in_tail_pos = ctx.in_tail_position;
    def orig_ctx = ctx;
    def ctx = ctx.WithInTailPosition (false);

    def go () : TExpr {
      match (l) {
        | [x] =>
          def x = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, x);
          ty_expr (orig_ctx, MacroRegistry.expand_macro (orig_ctx, ctx, x))

        | x :: xs =>
          def x = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, x);          
          match (MacroRegistry.expand_macro (ctx, ctx, x)) {
            | PT.PExpr.DefFunctions (fs) =>
              def (fs', ctx') = ty_letfun (ctx, fs);
              def body = ty_sequence (ctx'.WithInTailPosition (in_tail_pos), xs);
              fixup (TExpr.DefFunctionsIn (fs', body), type_of (body))

            | (PT.PExpr.Define) as x =>
              def val = ty_expr (ctx, x.val);
              def name = match (x.name) {
                | PT.Splicable.Name (n) => n
                | _ =>
                  Message.fatal_error ("$ operator used outside quotation "
                                       "<[ ... ]> context")
              };

              // check for mutable symbol redefinitions
              match (ctx.LookupLocal (name)) {
                | Some (l) when l.name == x.name.GetName ().Id =>
                  def warn =
                    if (x.is_ref && l.is_ref)
                      Some (("mutable", ""))
                    else if (!x.is_ref && l.is_ref)
                      Some (("mutable", " as non-mutable"))
                    else if (x.is_ref && !l.is_ref)
                      Some (("non-mutable", " as mutable"))
                    else
                      None ();

                  match (warn) {                    
                    | Some ((was_of_kind, is_of_kind)) =>                      
                      Message.warning (x.loc, "redefinition of a local " +
                                       was_of_kind + " value `" + l.name +
                                       "'" + is_of_kind);
                      Message.warning (l.loc, "  <-- previously seen here")
                    | _ => ()                      
                  }                      
                | _ => ()
              }
              
              def decl = ctx.DefineLocal (name, LocalValueKind.LocalVariable(), type_of (val));
              decl.is_ref = x.is_ref;
              def body = ty_sequence (ctx.WithLocal (decl).
                                      WithInTailPosition (in_tail_pos), xs);
              fixup (TExpr.DefValIn (decl, val, body), type_of (body))

            | PT.PExpr.DefPattern (p, v) =>
              def body = PT.PExpr.Sequence (xs);
              def mtch = PT.PExpr.Match (p.loc, v, [PT.MatchCase ([(p, None ())], body)]);
              body.loc = (List.Head (xs)).loc;
              ty_expr (orig_ctx, mtch)

            | x =>
              def ex = ty_expr (ctx, x);
              def t = type_of (ex);
              if (t >:> TType.Void ()) {
                def tl = ty_sequence (orig_ctx, xs);
                fixup (TExpr.Sequence (ex, tl), type_of (tl))
              }
              else {
                when (Options.IgnoredValueWarnings) {
                  Message.warning ($ "ignored computed value of type $t");
                  Message.hint_once ("use _ = ...; or -Wno-ignore to avoid the warning");
                }

                def tmp = Util.tmpname ("ign");
                def decl = ctx.DefineLocal (tmp, 1, LocalValueKind.LocalVariable (), type_of (ex));
                def body = ty_sequence (ctx.WithLocal (decl).
                                        WithInTailPosition (in_tail_pos), xs);
                fixup (TExpr.DefValIn (decl, ex, body), type_of (body))
              }
          }
        | [] => Util.ice ("empty sequence")
      }
    };

    Util.locate ((List.Head (l)).loc, go ())
  }

  public ty_literal (_ : CTX, l : Literal) : TType
  {
    match (l) {
      | Literal.Void => TType.Void ()
      | Literal.Null =>
        match (Tyvar.free_variable ()) {
          | (TType.Variable (tv)) as r => tv.value = TvValue.FreeFromNull (); r
          | _ => Util.ice ()
        }
      | Literal.Byte => InternalType.Byte
      | Literal.SByte => InternalType.SByte        
      | Literal.Short => InternalType.Int16
      | Literal.UShort => InternalType.UInt16        
      | Literal.Int => InternalType.Int32
      | Literal.UInt => InternalType.UInt32        
      | Literal.Long => InternalType.Int64
      | Literal.ULong => InternalType.UInt64        
      | Literal.Char => InternalType.Char
      | Literal.String => InternalType.String
      | Literal.Float => InternalType.Single
      | Literal.Double => InternalType.Double
      | Literal.Decimal => InternalType.Decimal        
      | Literal.Bool => InternalType.Boolean
      | Literal.Enum (_, tc) => TType.Class (tc, [])
    }
  }

  describe_expression (expr : TExpr) : string
  {
    match (expr) {
      | TExpr.LocalRef (d) =>
        "a reference to local symbol `" + d.name + "'"
      | TExpr.StaticRef (m) =>
        def tyname =
          if (m.DeclaringType == null)
            ""
          else
            m.DeclaringType.FullName + ".";
        "a reference to global symbol `" + tyname + m.Name + "'"
      | TExpr.FieldMember (_, f) =>
        "a reference to field `" + f.Name + "'"
      | TExpr.ConstantObjectRef (m) =>
        "a reference to constant constructor of `" + 
        m.DeclaringType.FullName + "'"
      | TExpr.ImplicitValueTypeCtor (t) =>
        "a reference to implicit constructor of `" + 
        t.FullName + "'"
      | TExpr.StaticPropertyRef (p)
      | TExpr.PropertyMember (_, p) =>
        "a reference to property `" + p.Name + "'"
      | TExpr.MethodRef (_, m, _) =>
        "a reference to method `" + m.Name + "'"
      | TExpr.TailCall (f, _)
      | TExpr.Call (f, _) =>
        "a function call to " + describe_expression (f)
      | TExpr.SelfTailCall =>
        "self-recursive function call"
      | TExpr.Assign => "an assignment"
      | TExpr.DefValIn => "a value binding"
      | TExpr.DefFunctionsIn => "a function binding"
      | TExpr.Match => "a `match' expression"
      | TExpr.Throw => "a throw expression"
      | TExpr.TryWith => "a try...with expression"
      | TExpr.TryFinally => "a try...finally expression"
      | TExpr.Literal => "a literal value"
      | TExpr.This => "a this pointer reference"
      | TExpr.Base => "a base class reference"
      | TExpr.TypeConversion => "a type conversion (:>)"
      | TExpr.TypeEnforcement => "a type enforcement (:)"
      | TExpr.Sequence => "a sequence"
      | TExpr.Tuple => "a tuple constructor"
      | TExpr.Array => "an array constructor"
      | TExpr.ArrayIndexer => "an array indexer reference"
      | TExpr.TypeOf => "a typeof expression"
      | TExpr.OpCode => "an operator reference"
    }
  }

  is_indexer_property (prop : IProperty) : bool
  {
    def getter = prop.GetGetter ();
    def setter = prop.GetSetter ();
    (getter != null && (getter.GetHeader ().parms matches _ :: _)) ||
    (setter != null && !(setter.GetHeader ().parms matches [_]))
  }

  make_first_class (ctx : CTX, expr : TExpr) : TExpr
  {
    match (expr) {
      | TExpr.MethodRef (obj_ref, mem, _) =>
        match (Tyutil.top_expand (type_of (expr))) {
          | TType.Function (from, _) =>
            def mkparm (_, acc) {
               def t = PT.Name (Util.tmpname ("parm"));
               def (fps, ps) = acc;
               (PT.Fun_parm (expr.loc, PT.Splicable.Name (t), PT.PExpr.Wildcard (), 
                             Modifiers.Empty) :: fps,
                             PT.PExpr.Ref (expr.loc, t) :: ps)
            };
            def (fps, ps) = List.FoldLeft (Tyutil.fun_args (from), ([], []), mkparm);
            def ptr_name = PT.Name (Util.tmpname ("ptr"));
            def header =
              PT.Fun_header (expr.loc, PT.Splicable.Name (PT.Name (Util.tmpname ("ml"))),
                             PT.PExpr.Wildcard (), fps);
            def body = PT.PExpr.Call (PT.PExpr.Member (PT.PExpr.Ref (ptr_name), 
                                  PT.Splicable.Name (PT.Name (mem.Name))), ps);
            //def body = <[ $(ptr_name : name) . $mem_name (.. $ps) ]>;
            def lambda = PT.PExpr.Lambda (expr.loc, PT.Function_decl (header, body));
            ty_expr (ctx, PT.PExpr.Sequence ([
                PT.PExpr.Define (false, PT.Splicable.Name (ptr_name),
                          PT.PExpr.Typed (obj_ref)),
                lambda
                ]))
            //ty_expr (ctx, <[ { def $(ptr_name : name) = $(tye : typed);
            //                   $lambda
            //                 } ]>)
          | _ => Util.ice ()
        }
      | TExpr.LocalRef ({kind = LocalValueKind.Function (h, _)}) =>
        h.usage = FunctionUsage.UsedAsFirstClass;
        expr
      | TExpr.PropertyMember (_, prop) when is_indexer_property (prop) =>
        Message.fatal_error ("indexer property `" + prop.Name + 
                             "' used as first class value")
      | _ => expr
    }
  }

  public ty_expr (ctx : CTX, expr : PT.PExpr) : TExpr
  {
    convert_getter_property (ty_expr_with_no_properties_conversion (ctx, expr));
  }

  convert_getter_property (expr : TExpr) : TExpr
  {
    def make_getter (obj : TExpr, prop : IProperty, args) {
      def meth = prop.GetGetter ();
      if (meth != null)
        TExpr.Call (obj.loc, expr.ty, 
                    TExpr.MethodRef (obj.loc, meth.GetMemType (), obj, meth, false),
                    args)
      else {
        Message.error (obj.loc, $"get accessor is unavailable for $prop");
        null
      }
    };
    def make_static_getter (prop : IProperty, args) {
      def meth = prop.GetGetter ();
      if (meth != null)      
        TExpr.Call (expr.loc, expr.ty, 
                    TExpr.StaticRef (expr.loc, meth.GetMemType (), meth),
                    args)
      else {
        Message.error (expr.loc, $"get accessor is unavailable for $prop");
        null
      }
    };
    
    match (expr) {
      | TExpr.PropertyMember (obj, prop) => make_getter (obj, prop, [])
      | TExpr.Call (TExpr.PropertyMember (obj, prop), args) => make_getter (obj, prop, args)
      | TExpr.StaticPropertyRef (prop) => make_static_getter (prop, [])
      | TExpr.Call (TExpr.StaticPropertyRef (prop), args) => make_static_getter (prop, args)
      | expr => expr
    }
  }
  

  convert_setter_property (_ctx : CTX, expr : TExpr, val : TExpr) : TExpr * TType
  {
    def make_setter (obj, prop : IProperty, args)
    {
      def meth = prop.GetSetter ();
      if (meth != null)      
        TExpr.Call (expr.loc, TType.Void (), 
                    TExpr.MethodRef (expr.loc, meth.GetMemType (), obj, meth, false),
                    List.Append (args, [Parm (val)]))
      else {
        Message.error (expr.loc, $"set accessor is unavailable for $prop");
        null
      }
    }
      
    def make_static_setter (prop : IProperty, args)
    {
      def meth = prop.GetSetter ();
      if (meth != null)            
        TExpr.Call (expr.loc, TType.Void (), 
                    TExpr.StaticRef (expr.loc, meth.GetMemType (), meth),
                    List.Append (args, [Parm (val)]))
      else {
        Message.error (expr.loc, $"set accessor is unavailable for $prop");
        null
      }
    }
    
    expect_type ("assigned value", val, type_of (expr));

    def res =
      match (expr) {
        | TExpr.PropertyMember (obj, prop) =>
          make_setter (obj, prop, [])
        | TExpr.Call (TExpr.PropertyMember (obj, prop), args) =>
          make_setter (obj, prop, args)
        | TExpr.StaticPropertyRef (prop) =>
          make_static_setter (prop, [])
        | TExpr.Call (TExpr.StaticPropertyRef (prop), args) =>
          make_static_setter (prop, args)
        | expr =>
          TExpr.Assign (expr.loc, TType.Void (), expr, val)
      };

    (res, TType.Void ())
  }
  

  ty_call (ctx : CTX, in_tail_pos : bool, fnc : PT.PExpr, parms : list [PT.PExpr]) : TExpr
  {
    def refout (name, expr) {
      match (expr) {
        | PT.PExpr.ParmByRef (ex)
        | PT.PExpr.ParmOut (ex) =>
          def ex = ty_expr (ctx, ex);
          unless (is_lvalue (ctx, ex, need_ref = true))
            Message.error ("ref/out parameters need lvalue but " + 
                           describe_expression (ex) + " was passed");
          def kind =
            match (expr) {
              | PT.PExpr.ParmByRef => ParmKind.Ref 
              | _ => ParmKind.Out
            };
          Parm (kind, ex, name)
        | ex =>
          Parm (ParmKind.Normal, ty_expr (ctx, ex), name)
      }
    };
    def fp (p : PT.PExpr) {
      | <[ $(name : name) = $e ]> => refout (name.Id, e)
      | e => refout ("", e)
    };
    def parms = List.Map (parms, fp);
    def fncs = make_value_reference (ctx, fnc, fallback = true);
    def ex = resolve_overloaded_call (ctx, in_tail_pos, fncs, parms);
    match (ex) {
      | TExpr.Call (TExpr.PropertyMember (_, prop), _) when is_indexer_property (prop) =>
        Message.error ("attempt to call an indexer property `" + 
                       prop.Name + "'");
      | _ => ()
    };

    ex
  }
  

  is_lvalue (ctx : CTX, e : TExpr, need_ref : bool) : bool
  {
    match (e) {
      | TExpr.LocalRef (d) => d.is_ref
      | TExpr.StaticRef (m) =>
        match (m.GetKind ()) {
          | MemberKind.Field (f) =>
            f.IsMutable || (ctx.current_fun.name == ".cctor" && 
                            f.DeclaringType.Equals (ctx.parent_type))
          | MemberKind.Property (p) when !need_ref => p.IsMutable
          | _ => false
        }
      | TExpr.StaticPropertyRef (p) when !need_ref => p.IsMutable
      | TExpr.FieldMember (TExpr.LocalRef ({kind = LocalValueKind.ClosurisedThis}), _)
        when ctx.in_ctor => true
      | TExpr.FieldMember (_, mem) => mem.IsMutable
      | TExpr.PropertyMember (_, p) when !need_ref => p.IsMutable
      | TExpr.Call (TExpr.PropertyMember (_, p), _) when !need_ref => p.IsMutable
      | TExpr.ArrayIndexer => true
      | _ => false
    }
  }

  ty_mkarray (ctx : CTX, rank : int, args : PT.PExpr) : TExpr * TType
  {
    def expr_list_length (e) {
      | <[ [] ]> => 0
      | <[ $_ :: $rest ]> => 1 + expr_list_length (rest)
      | _ => Message.fatal_error ("array initializer must be of form `array [rank] [ [..], .., [..] ]'")
    }

    def expr_list_flatten_and_count (e, remaining) {
      | (<[ [] ]>, 0) => []
      | (_, 0) => Message.fatal_error ("incorrectly structured array initializer");
      | (<[ [] ]>, _) => Message.fatal_error ("incorrectly structured array initializer");
      | (<[ $x :: $xs ]>, n) => x :: expr_list_flatten_and_count (xs, n - 1)
      | _ => Message.fatal_error ("array initializer must be of form `array [rank] [ [..], .., [..] ]'")
    }

    def dimensions (args, remaining_rank)
    {
      | (_, 0) => []
      | (<[ $head :: $_ ]>, n) =>
        expr_list_length (args) :: dimensions (head, n - 1)
      | _ => Message.fatal_error ("array initializer must be of form `array [rank] [ [..], .., [..] ]'")   
    }
    /* Flattens the initializers and checks that there are the correct number of them */
    def flatten (args, dims)
    {
        | (elem, []) => [elem]
        | (l, h::t) => 
          def flat = expr_list_flatten_and_count (l, h);
          List.FoldLeft (flat, [], fun (i, a) {List.Concat ([a, flatten (i, t)])})
    }

    def dimensions = dimensions (args, rank);
    def lst = flatten (args, dimensions);
    def dimensions = List.Map (dimensions, fun (x) { TExpr.Literal (Literal.Int (x)) });

    match (lst) {
      | [] => Util.ice ("empty list of initializers")
      | head :: _ =>
        def typed_head = ty_expr (ctx, head);
        def array_type = type_of (typed_head);
        def type_array_initializers (initializers) {
          match (initializers) {
            | [] => []
            | initializer :: rest =>
              def typed_initializer = ty_expr (ctx, initializer);
              expect_type ("array initializer", typed_initializer, array_type);
              typed_initializer :: type_array_initializers (rest)
          }
        };
        (TExpr.Array (type_array_initializers (lst), dimensions), TType.Array (array_type, rank))
    };
  }

  ty_indexer (ctx : CTX, obj : PT.PExpr, args : list [PT.PExpr]) : TExpr * TType
  {
    def typed_objs =
      match (obj) {
        | <[ base ]> | <[ this ]> => [ty_expr (ctx, obj)]
        | _ =>  make_value_reference (ctx, obj, fallback = true);
      };
    match (typed_objs) {
      | TExpr.PropertyMember (_, prop) :: _ when is_indexer_property (prop) =>
        def typed_parms = List.Map (args, fun (x) {
          Parm (ty_expr (ctx, x))
        });
        def ex = resolve_overloaded_call (ctx, false, typed_objs, typed_parms);
        (ex, type_of (ex))

      | [typed_obj] =>
        match (Tyutil.top_expand (typed_obj.ty)) {
          | TType.Array (indexer_over_type, rank) =>
            /* indexers over arrays */
            def typed_args = List.Map (args, fun (x) { ty_expr (ctx, x) });
            
            mutable args_amount = rank;
            foreach (index in typed_args) {
              expect_type ("indexer type", index, InternalType.Int32);
              --args_amount;
            }
            when (args_amount != 0)
              Message.fatal_error ("wrong number of index parameters");

            def resolved_obj = convert_getter_property (typed_obj);
            (TExpr.ArrayIndexer (indexer_over_type, resolved_obj, typed_args),
             indexer_over_type)

          | TType.Class (tc, _) when Option.IsSome (tc.DefaultIndexerName) =>
            /* user-defined indexers */
            def member_name = Option.UnSome (tc.DefaultIndexerName);
            ty_indexer (ctx, <[ $(typed_obj : typed) . $(member_name : dyn) ]>, args)
            
          | _ =>
            def ty = typed_obj.ty;
            Message.fatal_error ($ "indexer applied to non-indexer type $ty")
        }

      | l =>
        Message.error ("expression is ambiguous:");
        foreach (ex in l) Message.error ("  " + describe_expression (ex));
        throw Recovery ()
    }
  }
  
  
  ty_expr_with_no_properties_conversion (ctx : CTX, expr : PT.PExpr) : TExpr
  {
    def do_typing () : TExpr * TType {
      def restart (e : PT.PExpr) : TExpr * TType {
        def ex = ty_expr (ctx, e);
        (ex, type_of (ex))
      };

      def orig_ctx = ctx;
      // default to non-tail position (good for most expressions)
      def ctx = ctx.WithInTailPosition (false);

      def expr = ConstantFolder.FoldTopConstants (ctx.IsChecked, ctx.env, expr);
      def expr = MacroRegistry.expand_macro (orig_ctx, ctx, expr);
     
      match (expr) {
        // this doesn't make much sense I hope
        | PT.PExpr.Define =>
          Message.fatal_error ("let binding not followed by any expression")

        | PT.PExpr.DefPattern =>
          Message.fatal_error ("def pattern binding not followed by any expression")
        | PT.PExpr.DefFunctions =>
          Message.fatal_error ("letfun binding not followed by any expression")

        | PT.PExpr.ParmByRef
        | PT.PExpr.ParmOut =>
          Message.fatal_error ("ref and out parameters are only allowed in function calls")

        | PT.PExpr.Lambda (d) =>
          def newname = Util.tmpname ("l");
          d.header.name = PT.Splicable.Name (PT.Name (newname));
          def rf = PT.PExpr.Ref (PT.Name (newname));
          def lf = PT.PExpr.DefFunctions ([d]);
          def sq = PT.PExpr.Sequence ([lf, rf]);
          rf.loc = expr.loc;
          lf.loc = expr.loc;
          sq.loc = expr.loc;
          restart (sq)

        | PT.PExpr.Array (<[ $(r : int) ]>, <[ [] ]> ) => 
          def list_of_zeros (r) {
            | 1 => [ <[ 0 ]> ]
            | _ => <[ 0 ]> :: list_of_zeros (r - 1)
          }
          restart (<[ array (..$(list_of_zeros (r))) ]>)

        | PT.PExpr.Array (<[ $(rank : int) ]>, args) =>
          ty_mkarray (ctx, rank, args)

        | PT.PExpr.Array (PT.PExpr.Spliced, _) =>
          Message.fatal_error ("$ splicing outside of <[ quotation ]>")
          
        | PT.PExpr.Array => Util.ice ("wrongly parsed array initializer")

        | PT.PExpr.EmptyArray (sizes) =>
          mutable size = 0;
          def tsizes = List.Map (sizes, fun (x) {
            ++size;            
            def e = ty_expr (ctx, x);
            expect_type ("array size initializer", e, InternalType.Int32);
            e
          });
          def fv = Tyvar.free_variable ();
          (TExpr.Array ([], tsizes), TType.Array (fv, size))

        | PT.PExpr.Indexer (obj, args) => ty_indexer (ctx, obj, args)

        | (PT.PExpr.TryWith) as x =>
          def b = ty_expr (ctx, x.body);
          def exn = match (x.exn) {
            | PT.Splicable.Name (e) => e
            | _ =>
            Message.fatal_error ("$ operator used outside quotation <[ ... ]>"
                                 " context")
          };
          def decl = ctx.DefineLocal (exn, LocalValueKind.Exception (), ctx.BindType (x.exn_ty));
          def h = ty_expr (ctx.WithLocal (decl), x.handler);
          match (Tyutil.unify_branches (type_of (h), type_of (b))) {
            | Some (t) =>
              (TExpr.TryWith (b, decl, h), t)
            | None =>
              Message.fatal_error (h.loc, $ "try...with body has type "
                                            "$(type_of (b)) while the handler "
                                            "has type $(type_of (h))")
          }

        | PT.PExpr.TryFinally (e1, e2) =>
          def e1 = ty_expr (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          expect_type ("try...finally handler", e2, TType.Void ());
          (TExpr.TryFinally (e1, e2), type_of (e1))

        | PT.PExpr.Typeof (t) =>
          (TExpr.TypeOf (ctx.BindType (t)), InternalType.Type)

        | PT.PExpr.TypeConversion (e, t) =>
          def t = Tyutil.top_expand (ctx.BindType (t));
          def val = ty_expr (ctx, e);
          def valt = Tyutil.top_expand (val.ty);
          def conv = match (valt) {
            | TType.Class (tinfo, _) =>
              def loop (mems : list [IMember]) {
                | mem :: xs when mem.IsStatic =>
                  match (mem.GetMemType ()) {
                    | TType.Function (_, to) when Tyutil.types_eq (to, t) =>
                      Some (TExpr.Call (TExpr.StaticRef (mem), [Parm (val)]))
                    | _ => loop (xs)
                  }
                | _ :: xs => loop (xs)
                | _ => None ()
              }
              loop (tinfo.LookupMember ("op_Explicit"))

            | _ => None ()
          }
          match (conv) {
            | Some (x) => (x, t)
            | None =>
              if (t.IsValueType || valt.IsValueType)
                // FIXME: do more conservative checking
                (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
              else
                if (t >:> valt)
                  (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
                else if (valt >:> t)
                  (val, t) /// nothing to be done, warn about redundancy of cast?
                else {
                  // FIXME: unfortunately we use some forbidden casts in compiler
                  // Message.error ($"cannot convert type `$(Tyutil.string_of_type (val.ty))'"
                  //               " to `$(Tyutil.string_of_type (t))'");
                  // (val, val.ty)
                  (TExpr.TypeConversion (val, t, ctx.IsChecked), t)
                }
          }

        | PT.PExpr.TypeEnforcement (e, t) =>
          def ex = ty_expr (ctx, e);
          def t = ctx.BindType (t);
          expect_type ("type-enforced expression", ex, t);
          (TExpr.TypeEnforcement (ex, t), t)

        | PT.PExpr.Ref (n) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              (mark_as_used (ctx, x), type_of (x))

            | l =>
              Message.error ("name `" + n.FullId + "' is ambiguous:");
              foreach (ex in l) Message.error ("  " + describe_expression (ex));
              throw Recovery ()
          }

        | PT.PExpr.Member (_, PT.Splicable.Name (n)) =>
          match (make_value_reference (ctx, expr, fallback = false)) {
            | [x] =>
              def x = make_first_class (ctx, x);
              (mark_as_used (ctx, x), type_of (x))

            | l =>
              Message.error ("reference to member `" + n.FullId + "' is ambiguous:");
              foreach (ex in l) Message.error ("  " + describe_expression (ex));
              throw Recovery ()
          }

        | PT.PExpr.Member (_, _) =>
          Message.fatal_error ("$ operator outside quotation <[ ... ]> context")

        | PT.PExpr.Call (fnc, parms) =>
          def ex = ty_call (ctx, orig_ctx.in_tail_position, fnc, parms);
          (ex, type_of (ex))

        | PT.PExpr.Assign (PT.PExpr.Tuple (vars), e2) =>
          def tempnames = List.Map (vars, fun (_) { <[ $(Macros.NewSymbol () : name) ]> });
          def assigns = List.Map2 (vars, tempnames, fun (x, y) { <[ $x = $y ]> });
          (ty_expr (ctx, <[
            def (..$tempnames) = $e2;
            {..$assigns }
           ]>), TType.Void ())
          
        | PT.PExpr.Assign (PT.PExpr.Wildcard, e2) =>
          def ex = ty_sequence (orig_ctx, [<[ def _ = $e2 ]>, <[ () ]>]);
          (ex, TType.Void ())
          
        | PT.PExpr.Assign (e1, e2) =>
          def e1 = ty_expr_with_no_properties_conversion (ctx, e1);
          def e2 = ty_expr (ctx, e2);
          unless (is_lvalue (ctx, e1, need_ref = false))
            Message.error ("assignment to " + describe_expression (e1) +
                           " (which is read-only)");
          convert_setter_property (ctx, e1, e2)

        | PT.PExpr.Throw (e) =>
          def ex = ty_expr (ctx, e);
          def exn_ty = InternalType.Exception;
          expect_type ("raised value", ex, exn_ty);
          (TExpr.Throw (ex), Tyvar.free_variable ())

        | PT.PExpr.Literal (l) =>
          (TExpr.Literal (l), ty_literal (ctx, l))

        | PT.PExpr.This =>
          match (ctx.this_ptr_decl) {
            | Some (d) =>
              ctx.Closurise (d);
              (TExpr.LocalRef (d), d.ty)
            | None =>
              Message.error ("`this' used outside method");
              (TExpr.Literal (Literal.Null ()), Tyvar.free_variable ())
          }

        | PT.PExpr.Sequence ([]) =>
          (TExpr.Literal (Literal.Void ()), TType.Void ())

        | PT.PExpr.Sequence (l) =>
          def ex = ty_sequence (orig_ctx, l);
          (ex, type_of (ex))

        | PT.PExpr.Application (e1, e2) =>
          def ex = ty_sequence (orig_ctx, [e1, e2]);
          (ex, type_of (ex))
          
        | PT.PExpr.Tuple (l) =>
          def self (e : PT.PExpr) : TExpr { ty_expr (ctx, e) };
          def parms = List.Map (l, self);
          (TExpr.Tuple (parms), TType.Product (List.Map (parms, type_of)))

        | (PT.PExpr.Match) as m => ty_match (orig_ctx, m)        

        | PT.PExpr.Typed (tytree) => (tytree, type_of (tytree))

        | PT.PExpr.Quoted (parse_element) =>
          def lifted =
            match (parse_element) {
              | PT.SyntaxElement.Expression (e) => Macros.quoted_expr (ctx, e)
              | PT.SyntaxElement.MatchCase (e) => Macros.QuotedMatchCase (ctx, e)
              | PT.SyntaxElement.MatchCaseGuard (a, b) => Macros.QuotedCaseGuard (ctx, (a, b))
              | PT.SyntaxElement.Function (e) => Macros.quoted_fundecl (ctx, e)
              | PT.SyntaxElement.Parameter (e) => Macros.quoted_fparam (ctx, e)
              | PT.SyntaxElement.ClassMember (e) => Macros.quoted_member (ctx, e)                
              | PT.SyntaxElement.TType (e) => Macros.quoted_ttype (ctx, e)

              | PT.SyntaxElement.TypeBuilder
              | PT.SyntaxElement.MethodBuilder
              | PT.SyntaxElement.FieldBuilder
              | PT.SyntaxElement.EventBuilder
              | PT.SyntaxElement.PropertyBuilder
              | PT.SyntaxElement.ParameterBuilder => 
                Util.ice ("strange syntax element appeared in quotation")
            };
          def b = ty_expr (ctx, lifted);
          (b, type_of (b))

        | PT.PExpr.Base =>
          match (ctx) {
            | { this_ptr_decl = Some (({ty = TType.Class (ti, _)}) as d); } =>
              match (ti.SuperClass ()) {
                | Some (baseti) =>
                  def ty = TType.Class (baseti, Option.UnSome (ti.SuperType (baseti)));
                  ctx.Closurise (d);
                  (TExpr.LocalRef (d), ty)

                | None =>
                  Message.fatal_error ("class " + ti.FullName +
                                       " has no base class")
              }
            | _ =>
              Message.fatal_error ("`base' reference used inside invalid type")
          }

        | PT.PExpr.Spliced =>
          Message.fatal_error ("$ macro keyword used in regular expression")

        | PT.PExpr.Wildcard =>
          Message.fatal_error ("`_' used in raw expression")
          
        | PT.PExpr.As =>
          Message.fatal_error ("`as' value binding can be used only in pattern")        

        | PT.PExpr.Void =>
          Message.fatal_error ("`void' is a special keyword used in types, use `@void' instead")        

        | PT.PExpr.Ellipsis =>
          Util.ice ("List of expression parameters out of any construct")

        | PT.PExpr.MacroCall  =>
          Util.ice ("Macrocalls should have been expanded already")
          
        | PT.PExpr.TypedPattern => Util.ice ("typed pattern in raw expr")
        | PT.PExpr.TypedType => Util.ice ("typed type in raw expr")
      }
    };

    def (ret, expr_ty) =
      try {
        Util.locate (expr.loc, do_typing ())
      } catch { _ : Recovery =>
        (TExpr.Literal (Literal.Null ()), Tyvar.free_variable ()) };
        
    //Message.debug (expr.loc, "compilied " + describe_expression (ret) + 
    //                    if (ctx.in_tail_position) " [tp]" else "");

    fixup (ret, expr.loc, expr_ty)
  }

  check_unused_values (ctx : CTX) : void
  {
    def warned = Hashtable (50);
    
    def check_value (v : LocalValue) {
      when (!v.ever_used && v.name[0] != '_' && !warned.Contains (v.id)) {
        Message.warning (v.loc, $ "$(v.kind_as_string ()) `$(v.name)' "
                                  "was never used");
        Message.hint_once (v.loc, "replace name with `_' or prefix it like"
                           " `_bar' to avoid the warning");
        warned.Set (v.id, null)
      }
    };

    def mark_broken (v : LocalValue) {
      match (v.kind) {
        | LocalValueKind.Function (h, _) =>
          match (h.closure_vars) {
            | [] => ()
            | _ => 
              //Message.debug ("clovars: " + l.ToString () + " v " + v.name);
              // we cannot yet deal with expanding these to loops
              h.usage = FunctionUsage.UsedAsFirstClass
          }
        | _ => ()
      };
    };

    def closurise (v : LocalValue) {
      def in_clo = v.used_in.Fold (fun (_, h : Fun_header, in_clo) {
        if (in_clo) true
        else {
          // check if all functions from h to current_fun are used_just_once
          def find_defining (header : Fun_header) {
            if (header.id == ctx.current_fun.id) false
            else
              match (header.usage) {
                | FunctionUsage.UsedJustOnce => find_defining (header.decl.parent_fun)
                | _ => true
              }
          }
          find_defining (h)
        }
      }, false);
      //Message.debug ("clos: " + v.name + " " + in_clo.ToString ());
      when (in_clo) {
        // check if we are not closuring some invalid things
        match (v.kind) {
          | LocalValueKind.Parameter (k) when k != ParmKind.Normal =>
            Message.error (v.loc, "cannot store ref/out parameters in" +
                           " closures (parameter `" + v.name + "')");

          | _ => ()
        };
        v.in_closure = true;
        v.parent_fun.closure_vars = v :: v.parent_fun.closure_vars;
      }
    };
    
    def locals = List.Rev (ctx.current_fun.all_locals);
    ctx.current_fun.all_locals = null; // GC it

    unless (ctx.parent_type.IsDelegate)
      List.Iter (locals, check_value);
    List.Iter (locals, mark_broken);
    List.Iter (locals, closurise);
  }

  ty_function (ctx : CTX, h : Fun_header, b : FunBody, toplev : bool) : FunBody
  {
    def ctx = ctx.WithCurrentFunction (h).WithInTailPosition (true);
    
    def make_parm_decl (p : Fun_parm) {
      Util.locate (p.loc, {
        def (t, kind, is_ref) =
          match (p.ty) {
            | TType.ByRef (t) => (t, ParmKind.Ref, true)
            | TType.Out (t) => (t, ParmKind.Out, true)
            | t when p.modifiers.mods %&& NemerleAttributes.Mutable =>
              (t, ParmKind.Normal, true)
            | t => (t, ParmKind.Normal, false)
          };
        when (kind != ParmKind.Normal && !toplev)
          Message.error ("ref/out parameters are not supported in local methods");
        def d = ctx.DefineLocal (p.name, p.color, LocalValueKind.Parameter (kind), t);
        d.is_ref = is_ref;
        p.decl = d;
        d
      })
    };

    def ctx = ctx.WithLocals (List.RevMap (h.parms, make_parm_decl));

    match (b) {
      | FunBody.Parsed (e) =>
        def ctx = ctx.WithTEnv (h.tenv);
        def e' = ty_expr (ctx, e);
        if (type_of (e') >:> h.ret_type) ()
        else
          Message.error (e.loc, $ "function return type was declared to be "
                                  "$(h.ret_type) while it is $(type_of (e'))");
        check_unused_values (ctx);
        FunBody.Typed (e')
      | FunBody.Typed => Util.ice ()
      | FunBody.Compiled => Util.ice ()
      | FunBody.Extern => b
      | FunBody.Abstract => b
    }
  }

  ty_function (ctx : CTX, h : Fun_header, b : PT.PExpr) : TExpr
  {
    match (ty_function (ctx, h, FunBody.Parsed (b), toplev = false)) {
      | FunBody.Typed (e) => e
      | _ => Util.ice ()
    }
  }

  /**
   * Walk through method body typing it.
   *
   * <remarks>
   *   Typing generally involves rewriting from [Parsetree] to [Typedtree]
   *   namespace. Also entry point for expression is changed from
   *   [FunBody.Parsed] to [FunBody.Typed].
   *
   *   During typing we do few things:
   *
   *   <list>
   *     - Infer types and check if they are correct. Store information
   *       about types in resulting [Typedtree.TExpr] objects.
   *     - Define (generate [LocalValue] objects) and later resolve local values.
   *     - Rewrite few redundant source language constructs into
   *       unambiguous equivalents from [Typedtree].
   *     - Bind type expressions occurring in source code.
   *     - Mark which values should go into closures.
   *   </list>
   *
   *   This is however all done in parallel to improve efficiency.
   *
   *   Documentation FIXME: overloading resolution, CTX type, more
   *   about closures, binding method implement list.
   * </remarks>
   */
  internal TypeMethod (m : NemerleMethod) : void
  {
    def ti = (m.DeclaringType :> TypeBuilder);

    def (in_ctor, is_method) =
      match (m.GetFunKind ()) {
        | FunKind.Constructor => (true, true)
        | FunKind.Method | FunKind.BoundMethod => (false, true)
        | _ => (false, false)
      };

    //Message.debug ("type " + m.Name + (if (is_method) " method" else ""));
    
    // we add call to base() inside nonvaluetype constructors
    // if it (or this()) is not present
    when (in_ctor && !m.IsStatic && !m.DeclaringType.IsValueType)
      match (m.fun_body) {
        | FunBody.Parsed (expr) =>
          match (expr) {
            | PT.PExpr.Sequence (<[ base (.. $_) ]> :: _) => ()
            | PT.PExpr.Sequence (<[ this (.. $_) ]> :: _) => ()
            | PT.PExpr.Sequence =>
              Util.locate (expr.loc,
                m.fun_body = FunBody.Parsed (<[ { base (); $expr } ]>)
              )
            | _ => assert (false)
          }
        | _ => Message.debug (m.fun_body.ToString ()); ()
      }

    def ctx = TypingContext 
                  (in_ctor = in_ctor,
                   this_ptr_decl =
                     if (is_method)
                       Some (LocalValue ("_N_this", 0, LocalValueKind.ClosurisedThis (),
                                         ti.GetMemType (), m.GetHeader ()))
                     else None (),
                   env = ti.env,
                   tenv = m.GetHeader ().tenv,
                   current_fun = m.GetHeader (),
                   locals = NemerleMap (),
                   parent_type = ti,
                   in_tail_position = true,
                   is_checked = true);
    match (ctx.this_ptr_decl) {
      | Some (decl) => 
        decl.parent_fun.all_locals = decl :: decl.parent_fun.all_locals
      | None => ()
    };
    try {
      m.fun_body = ty_function (ctx, m.GetHeader (), m.fun_body, toplev = true);
      
      when (Options.DumpTypedTree) {
        match (m.fun_body) {
          | FunBody.Typed (expr) =>
            Message.debug (expr.loc,
                           m.DeclaringType.FullName + "." +
                           m.Name + " -> " +
                           PrettyPrint.SprintTyType (m.GetHeader ().ret_type) + ":" +
                           PrettyPrint.SprintTyExpr (Some (ctx), expr) + "\n");
          | _ => ()
        }
      }
    } catch { _ : Recovery => () }
  }
}

} // end ns
