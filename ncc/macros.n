/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Transformations of quoted expressions into syntax trees
 */

using Nemerle.Collections;
using Nemerle.Utility;
using Nemerle.IO;

using Nemerle.Compiler.Parsetree;
using TT = Nemerle.Compiler.Typedtree;
using System.Text;

namespace Nemerle.Compiler {

public module Macros
{
  /// PUBLIC API FOR USAGE IN MACROS

  /** generates new unique symbol, which can be safely used
      as name of quoted variables, functions, etc.
   */
  public NewSymbol () : Name
  {
    Name ([Util.tmpname ("")], TypingContext.MacroColor, null)
  }

  /** controlled hygiene breaking - generates symbol, which
      placed in generated code would bind to variables
      at macro-use site
   */
  public UseSiteSymbol (id : string) : Name
  {
    Name (NString.Split (id, array ['.']), TypingContext.MacroUseColor, 
          TypingContext.MacroUseContext)
  }

  /** Checks if given expression describes name of a type, like
      [System.Console] (it is a class)
   */
  public IsTypeName (ctx : CTX, e : Expr) : bool
  {
    def collect_member (obj : Expr, acc) {
      match (obj) {
        // name in expressions has always one element in name
        | <[ $(n : name) ]> =>
          def env = n.GetEnv (ctx.env);
          match (env.LookupType (n.Id :: acc)) {
            | Some => true
            | _ => false
          }
        | <[ $head.$(id : dyn) ]> => collect_member (head, id :: acc)
        | _ => false
      }
    };
    collect_member (e, [])
  }

  /** Checks if given expression describes name of a type, like
      [System.Console] (it is a class)
   */
  public GetIfIsType (env : GlobalEnv, e : Expr) : option <TypeInfo>
  {
    def collect_member (obj : Expr, acc) {
      match (obj) {
        // name in expressions has always one element in name
        | <[ $(n : name) ]> =>
          def env = n.GetEnv (env);
          env.LookupType (n.Id :: acc)
        | <[ $head.$(id : dyn) ]> => collect_member (head, id :: acc)
        | _ => None ()
      }
    };
    collect_member (e, [])
  }

  public DefaultValueOfType (ty : TT.Type) : Expr {
    match (Tyutil.top_expand (ty)) {
      | TT.T_app (tc, _) when tc.IsValueType => 
        def ctor = Nemerle.Macros.Symbol (tc.FullName);
        <[ $(ctor : name) () ]>

      | TT.T_void => <[ () ]>

      | _ => <[ null ]>
    }
  }
  
  /** Lifts given list of expressions to syntax tree of list containing
      elements, whose syntax trees are defined by those expressions.
      (expressions on the list are not lifted)
   */
  public Lift (l : list<Expr>) : Expr
  {
    | x :: xs => <[ $x :: $(Lift (xs)) ]>
    | [] => <[ [] ]>
  }

  /** Lifts given list to syntax tree of this list, applying
      supplied function to each of its elements. The function
      is used here to lift elements of list, so we can build
      entire syntax trees from them.
   */
  public Lift<'a> (l : list<'a>, f : 'a -> Expr) : Expr
  {
    match (l) {
      | x :: xs => <[ $(f (x)) :: $(Lift (xs, f)) ]>
      | [] => <[ [] ]>
    }
  }

  public Lift<'a> (o : option <'a>, f : 'a -> Expr) : Expr
  {
    match (o) {
      | Some (v) => <[ Some ($(f (v))) ]>
      | _ => <[ None () ]>
    }
  }
  
  /** Creates syntax tree of given number (expression building it) */
  public Lift (x : int) : Expr { <[ $(x : int) ]> }


  /// DATA STRUCTURES USED IN QUOTATION AND MACROS
 variant MacroParm 
  {
    | MP_expr
    | MP_exprs
    | MP_implicit   // note that parameter isn't given by user
  }
  
  public type CTX = TypingContext;

  implicit_ctx_name : Name;

  public GetImplicitCTXName () : Name { implicit_ctx_name }
  
  public this () { implicit_ctx_name = NewSymbol () }
  
  // some tool methods
  public UnSString (x : Splicable_string) : list <string>
  {
    | SS_string ({ idl = x }) => x
    | _ => throw System.ArgumentException ("Macros.UnSString")
  }

  public StringOfSString (x : Splicable_string) : string
  {
    | SS_string ({ idl = x }) => NString.Concat (".", x)
    | _ => throw System.ArgumentException ("Macros.UnSString")
  }

  public NameOfSString (x : Splicable_string) : Name
  {
    | SS_string (x) => x
    | _ => throw System.ArgumentException ("Macros.NameOfSString")
  }

  // QUOTATION HANDLING SECTION

  /** Lifts up [Splicable_string]. [SS_spliced_expr] is substituted by its
      content and appropriate [SS_string] expression is created.
   */
  quoted_sstring (ctx : CTX, st : Splicable_string) : Expr
  {
    match (st) {
      | SS_string ({ idl = str }) =>
        def c = ctx.env.GetMacroContext ();
        def qidl = Lift (str, quoted_string);
        <[ SS_string (Name.NameInCurrentColor 
                      ($qidl, $("_N_MacroContexts"  : dyn).Get ($(c : int)))) ]>

      | SS_spliced_expr (E_spliced (E_type_enforcement (e, <[ type: $(ty : name) ]>))) =>
        match (ty.Id) {
          | "name"  => <[ SS_string ($e) ]>
          | "dyn" => <[ SS_string (Name ([$e], -1, null)) ]>
          | "usesite" => <[ SS_string (Name (NString.Split ($e, array ['.']), 
                                             TypingContext.MacroUseColor, 
                                             TypingContext.MacroUseContext)) ]>
          | x => Message.fatal_error ("unsupported splicing type `" + x + "' in splicable expression")
        }

      | SS_spliced_expr (e) => e
    }
  }

  quoted_sint (i : Splicable_int) : Expr
  {
    | SI_int (i) => <[ SI_int ($(i : int)) ]>

    | SI_spliced_expr (E_spliced (E_type_enforcement (e, <[ type: $(ty : name) ]>))) =>
      if (ty.Id == "int")
        <[ SI_int ($e) ]>
      else
        Message.fatal_error ("unsupported splicing type in splicable integer")

    | SI_spliced_expr (e) => e
  }

  /** Lifts up [Name] giving it supplied context number. */
  quoted_name (n : Name, context : int) : Expr
  {
    def qidl = Lift (List.Map (n.idl, quoted_string));
    <[ Name.NameInCurrentColor ($qidl, $("_N_MacroContexts" 
                                         : dyn).Get ($(context : int))) ]>
  }

  quoted_string (s : string) : Expr { <[ $(s : string) ]> }

  public QuotedCaseGuard (ctx : CTX, pair : Expr * option <Expr>) : Expr
  {
    match (pair) {
      | (pat, Some (gu)) =>
        <[ ($(quoted_expr (ctx, pat)), Some ($(quoted_expr (ctx, gu)))) ]>
      | (pat, None) =>
        <[ ($(quoted_expr (ctx, pat)), None ()) ]>
    }
  }

  public QuotedMatchCase (ctx : CTX, cas : MatchCase) : Expr
  {
    def ({ patterns = guards; body = expr; }) = cas;
    def quotedc_case_guard (x) { QuotedCaseGuard (ctx, x) };
    
    match (guards) {
      | [(E_expr_list (args), None)] =>
        <[ MatchCase ($(quoted_expr (ctx, args)),
                       $(quoted_expr (ctx, expr))) ]>
      | _ =>
        <[ MatchCase ($(Lift (guards, quotedc_case_guard)),
                       $(quoted_expr (ctx, expr))) ]>
    }
  }

  public quoted_fparam (ctx : CTX, p : Fun_parm) : Expr
  {
    match (p) {
      | <[ funparm: $name : $ty ]> =>
        <[ Fun_parm (name = $(quoted_sstring (ctx, name)),
                     ty = $(quoted_type (ctx, ty)),
                     modifiers = Modifiers (NemerleAttributes.None, [])) ]>
                     
      | <[ funparm: params $name : $ty ]> =>
        def qattr = quoted_expr (ctx, <[ System.ParamArrayAttribute ]>);
        <[ Fun_parm (name = $(quoted_sstring (ctx, name)),
                     ty = $(quoted_type (ctx, ty)),
                     modifiers = Modifiers (NemerleAttributes.None, [$qattr])) ]>

      | <[ funparm: $name : $ty = $expr ]> =>
        def e = quoted_expr (ctx, expr);
        def qattr =
          quoted_expr (ctx, <[ System.ComponentModel.DefaultValueAttribute ($e) ]>);
        <[ Fun_parm (name = $(quoted_sstring (ctx, name)),
                     ty = $(quoted_type (ctx, ty)),
                     modifiers = Modifiers (NemerleAttributes.None, [$qattr])) ]>
      | _ =>
        Util.ice ("no attributes in quoted parameters supported yet")
    }
  }

  quoted_tparms (ctx : CTX, tyvars : list <string * int>, 
                 constraints : list <Constraint>) : Expr 
  {
    def quoted_tvar (name, color) {
      <[ ( $(name : string), $(color : int) ) ]>
    }
    def quoted_constr (c : Constraint) {
      def (name, color) = c.tyvar;
      <[ Constraint ($(name : string), $(color : int), $(quoted_type (ctx, c.ty))) ]>
    }

    match (constraints) {
      | [(("", _), T_prod ([T_void,T_spliced (e)]))] =>
        <[ Typarms ($(Lift (tyvars, quoted_tvar)), $e) ]>

      | [(("", _), T_prod ([T_spliced (e1), T_spliced (e2)]))] =>
        <[ Typarms ($e1, $e2) ]>

      | (("", _), T_prod ([T_spliced (e), T_void])) :: where_cts =>
        <[ Typarms ($e, $(Lift (where_cts, quoted_constr))) ]>

      | _ =>
        <[ Typarms ($(Lift (tyvars, quoted_tvar)),
                    $(Lift (constraints, quoted_constr))) ]>
    }
  }

  make_quoted_funheader (ctx : CTX, parms : list<Fun_parm>, qtparms : Expr,
                         ty : Type, qname : Expr) : Expr
  {
    def qparms =
      match (parms) {
        | [{ name = SS_string ({ idl = [] }); ty = <[ type: void ]>; 
             modifiers = (_, [e], _); }] =>
          quoted_expr (ctx, e)
        | _ =>
          Lift (parms, fun (x) { quoted_fparam (ctx, x) })
      };
    def qtype = quoted_type (ctx, ty);
    <[ Fun_header ($qtparms, $qname, $qtype, $qparms) ]>
  } 
  
  make_quoted_fundecl (ctx : CTX, parms : list<Fun_parm>, qtparms : Expr,
                       ty : Type, qname : Expr, body : Expr) : Expr
  {
    def qheader = make_quoted_funheader (ctx, parms, qtparms, ty, qname);
    def qbody = quoted_expr (ctx, body);
    <[ Function_decl ($qheader, $qbody) ]>
  }
  
  quoted_attributes (ctx : CTX, attrs : Modifiers) : Expr
  {
    match (attrs) {
      | (_, [E_expr_list (e)], _) => quoted_expr (ctx, e)
      | _ =>
        def quotedc_expr (x) { quoted_expr (ctx, x) };
        <[ Modifiers (($((attrs.mods :> int) : int) :> NemerleAttributes),
                      $(Lift (attrs.custom_attrs, quotedc_expr))) ]>
    };
  }

  internal quoted_member (ctx : CTX, mem : Class_member) : Expr {
    def quotedc_expr (x) { quoted_expr (ctx, x) };
    def quotedc_member (x) { quoted_member (ctx, x) };
    def qnm = quoted_sstring (ctx, mem.name);
    def qattrs = quoted_attributes (ctx, mem.modifiers);
    match (mem) {
      | M_type (td) =>
        <[ M_type (name = $qnm, modifiers = $qattrs,
                   td = $(quoted_tydecl (ctx, td))) ]>
        
      | M_field (t) =>
//      | <[ decl: ..$_ $_ : $t; ]> => // field
        <[ M_field (name = $qnm, modifiers = $qattrs,
                    ty = $(quoted_type (ctx, t))) ]>

      /// Example
      ///   <[ decl: ..$attrs $n < ..$tparms> (..$fparms) : $t where ..$cts
      ///              implements ..$impl $body ]> 
      | M_function { header = { typarms = (tparms, cts);
                       ret_type = t; parms = fparms; };
                       kind = kd; body = bd;
                   } =>
        def quoted_funkind (x) {
          | FK_method (impl) =>
            match (impl) {
              | [SS_spliced_expr (E_expr_list (e))] =>
                <[ FK_method ($(quoted_expr (ctx, e))) ]>
              | _ =>
                <[ FK_method ($(Lift (impl, fun (x) {
                     quoted_sstring (ctx, x)
                   }))) ]>
            }
          | FK_bound_method =>
            // quotation of IMethod? noooo!
            <[ FK_bound_method ([]) ]>
          | FK_ctor => <[ FK_ctor () ]>
          | FK_static_ctor => <[ FK_static_ctor () ]>
          | FK_function => <[ FK_function () ]>
        };

        def qtparms = quoted_tparms (ctx, tparms, cts);
        def qhd = make_quoted_funheader (ctx, fparms, qtparms, t, qnm);
        
        <[ M_function (name = $qnm,
                       modifiers = $qattrs,
                       header = $qhd,
                       kind = $(quoted_funkind (kd)),
                       body = $(quoted_funbody (ctx, bd))) ]>
        
      | M_enum (val) =>
        def qval = Lift (val, quotedc_expr);
        <[ M_enum (name = $qnm, modifiers = $qattrs, value = $qval) ]>
        
      | M_event { ty = t; add = a; remove = r; } =>
        <[ M_event (name = $qnm, modifiers = $qattrs, ty = $(quoted_type (ctx, t)),
                    add = $(Lift (a, quotedc_member)),
                    remove = $(Lift (r, quotedc_member))) ]>
        
      | M_property { ty = t; prop_ty = p; dims = fps; set = s; get = g; } =>
        def qfps = Lift (fps, fun (x) { quoted_fparam (ctx, x) });
        <[ M_property (name = $qnm, modifiers = $qattrs,
                       ty = $(quoted_type (ctx, t)),
                       prop_ty = $(quoted_type (ctx, p)),
                       set = $(Lift (s, quotedc_member)),
                       get = $(Lift (g, quotedc_member)), dims = $qfps) ]>
    }
  }
  
  internal quoted_tydecl (ctx : CTX, td : TopDeclaration) : Expr {
    def qn = quoted_sstring (ctx, td.name);
    def qattr = quoted_attributes (ctx, td.modifiers);
    
    match (td) {
      | TD_class { typarms = tprms; t_extends = extend; decls = members; } =>
        def qtparms = quoted_tparms (ctx, tprms.tyvars, tprms.constraints);
        def qexten = Lift (List.Map (extend, fun (x) { quoted_type (ctx, x) }));        
        def qmems = Lift (List.Map (members, fun (x) { quoted_member (ctx, x) }));
                          
        <[ TD_class (name = $qn, modifiers = $qattr, t_extends = $qexten,
                     typarms = $qtparms, decls = $qmems) ]>

      | TD_alias { typarms = tprms; ty = t; }=>
        def qtparms = quoted_tparms (ctx, tprms.tyvars, tprms.constraints);                
        <[ TD_alias (name = $qn, modifiers = $qattr,
                     typarms = $qtparms, ty = $(quoted_type (ctx, t))) ]>
        
      | TD_interface { typarms = tprms; t_extends = extend; methods = members; } =>
        def qtparms = quoted_tparms (ctx, tprms.tyvars, tprms.constraints);
        def qexten = Lift (List.Map (extend, fun (x) { quoted_type (ctx, x) }));        
        def qmems = Lift (List.Map (members, fun (x) { quoted_member (ctx, x) }));
                          
        <[ TD_interface (name = $qn, modifiers = $qattr, t_extends = $qexten,
                     typarms = $qtparms, methods = $qmems) ]>
                     
      | TD_variant { typarms = tprms; t_extends = extend; decls = members; } =>
        def qtparms = quoted_tparms (ctx, tprms.tyvars, tprms.constraints);
        def qexten = Lift (List.Map (extend, fun (x) { quoted_type (ctx, x) }));          
        def qmems = Lift (List.Map (members, fun (x) { quoted_member (ctx, x) }));
                          
        <[ TD_variant (name = $qn, modifiers = $qattr, t_extends = $qexten,
                       typarms = $qtparms, decls = $qmems) ]>

      | TD_variant_option { decls = members; } =>
        def qmems = Lift (List.Map (members, fun (x) { quoted_member (ctx, x) }));
                          
        <[ TD_variant_option (name = $qn, modifiers = $qattr, decls = $qmems) ]>

      | _ =>
        Util.ice ("this quotation is not supported yet")
    }
  }

  quoted_funbody (ctx : CTX, x : Fun_body) : Expr
  {
    match (x) {
      | FB_parsed_expr (expr) =>
        <[ FB_parsed_expr ($(quoted_expr (ctx, expr))) ]>
      | FB_typed_expr (expr) => <[ FB_parsed_expr ($(expr : typed)) ]>
      | FB_compiled_expr => <[ FB_compiled_expr () ]>
      | FB_extern (name) => <[ FB_extern ($(name : string)) ]> 
      | FB_abstract => <[ FB_abstract () ]>
    }
  }

  quoted_literal (lit : Literal) : Expr
  {
    | L_void => <[ L_void () ]>
    | L_null => <[ L_null () ]>
    | L_int (val) => <[ L_int ($(val : int)) ]>
    | L_uint (val) => <[ L_uint ($(val : uint)) ]>
    | L_byte (val) => <[ L_byte ($(val : byte)) ]>
    | L_sbyte (val) => <[ L_sbyte ($(val : sbyte)) ]>
    | L_short (val) => <[ L_short ($(val : short)) ]>
    | L_ushort (val) => <[ L_ushort ($(val : ushort)) ]>
    | L_long (val) => <[ L_long ($(val : long)) ]>
    | L_ulong (val) => <[ L_ulong ($(val : ulong)) ]>
    | L_string (val) => <[ L_string ($(val : string)) ]>
    | L_float (val) => <[ L_float ($(val : float)) ]>
    | L_double (val) => <[ L_double ($(val : double)) ]>
    | L_decimal (val) => <[ L_decimal ($(val : decimal)) ]>
    | L_bool (val) => <[ L_bool ($(val : bool)) ]>
    | L_char (val) => <[ L_char ($(val : char)) ]>
    | L_enum (l, _) => <[ L_enum ($(quoted_literal (l)), null) ]>
  }
  
  public quoted_fundecl (ctx : CTX, d : Function_decl) : Expr
  {
    def <[ fundecl: $name < ..$typarms> (..$args) : $ty
                    where ..$tyconstrs $body ]> = d;
    def qtparms = quoted_tparms (ctx, typarms, tyconstrs);
    def qname = quoted_sstring (ctx, name);
    make_quoted_fundecl (ctx, args, qtparms, ty, qname, body)
  }

  /** Creates parse tree of (expression which builds) given typed type. */
  public quoted_ttype (ctx : CTX, t : Type) : Expr
  {
    def quotedc_ttype (x) { quoted_ttype (ctx, x) };

    match (t) {
      | <[ type: $tycon < .. $args > ]> =>
        def tyco = match (tycon) { 
          | SS_string ({ idl = s }) =>
            <[ $(Lift (List.Map (s, quoted_string))) ]>
          | SS_spliced_expr (e) => e
        };
        def findtyco = <[
          match (Nemerle.Macros.ImplicitCTX ().env.LookupType ($tyco)) {
            | Some (x) => x
            | None =>
              Message.fatal_error ("unbound type " + Util.qid_of_list ($tyco))
          }
        ]>;
        match (args) {
          | [T_type_list(ar)] => 
            <[ TT.T_app ($findtyco, $(quoted_ttype (ctx, ar))) ]>
          | _ =>
            <[ TT.T_app ($findtyco, $(Lift (args, quotedc_ttype))) ]>
        }

      | <[ type: ref $ty ]> =>
        <[ TT.T_ref ($(quoted_ttype (ctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ TT.T_out ($(quoted_ttype (ctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ TT.T_fun ($(quoted_ttype (ctx, from)), $(quoted_ttype (ctx, to))) ]>
  
      | <[ type: void ]> => <[ TT.T_void () ]>
        
      | <[ type: .. $args ]> =>
        <[ TT.T_prod ($(Lift (args, quotedc_ttype))) ]>

      | <[ type: array < $r, $ty> ]> =>
        <[ TT.T_array ($(quotedc_ttype (ty)), $(quoted_sint (r))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (E_type_enforcement (val, <[ type: $(ty : name) ]>)) =>
          match (ty.Id) {
            | "name" => <[ TT.T_var (Tyvar.T ($val)) ]>
            // it doesn't make much sense here, as it is the same as <[ $v ]>,
            // but we put it here for consistency
            | "typed" => val
            | x =>
              Message.fatal_error ("unsupported type of spliced special token `" + x + "' in typed type")
          }

      | T_spliced (e) => e

      | T_infer => <[ TT.T_infer () ]>

      | T_type_list (ar) =>
        <[ TT.T_prod ($(quoted_ttype (ctx, ar))) ]>

      | T_typed => 
        Util.ice ("You've got beer from me for generating such a code...");
    } 
  }

  /** Transforms syntax tree of quoted parsed type to its construction tree
      (expression which builds it). */
  public quoted_type (ctx : CTX, t : Type) : Expr
  {
    def quotedc_type (x) { quoted_type (ctx, x) };

    match (t) {
      | <[ type: $tycon < .. $args> ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ T_app ($(quoted_sstring (ctx, tycon)),
                      $(quoted_type (ctx, ar))) ]>
          | _ =>
            <[ T_app ($(quoted_sstring (ctx, tycon)), 
                      $(Lift (args, quotedc_type))) ]>
        }

      | <[ type: ref $ty ]> =>
        <[ T_ref ($(quoted_type (ctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ T_out ($(quoted_type (ctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ T_fun ($(quoted_type (ctx, from)), $(quoted_type (ctx, to))) ]>
  
      | <[ type: void ]> => <[ T_void () ]>
  
      | <[ type: .. $args ]> =>
        <[ T_prod ($(Lift (args, quotedc_type))) ]>

      | <[ type: array < $r, $ty> ]> =>
        <[ T_array ($(quotedc_type (ty)), $(quoted_sint (r))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (E_type_enforcement (val, <[ type: $(ty : name) ]>)) =>
          match (ty.Id) {
            | "name" => <[ T_app (SS_string ($val), []) ]>
            | "typed" => <[ T_typed ($val) ]>
            | x =>
              Message.fatal_error ("unsupported type of spliced special token `" + x + "' in type")
          }

      | T_spliced (e) => e

      | T_infer => <[ T_infer () ]>

      | T_type_list (ar) => <[ T_prod ($(quoted_type (ctx, ar))) ]>

      | T_typed => 
        Util.ice ("You've got beer from me for generating such a code...");
    } 
  }

  public mutable in_pattern : bool = false;
  
  public quoted_expr (ctx : CTX, expr : Expr) : Expr 
  {
    def quotedc_expr (x) { quoted_expr (ctx, x) };
    
    match (expr) {
      | <[ $(id : name) ]> =>
        <[ E_ref ($(quoted_name (id, ctx.env.GetMacroContext ()))) ]>
      | <[ $obj . $mem ]> => 
        <[ E_member ($(quotedc_expr (obj)), $(quoted_sstring (ctx, mem))) ]>

      | <[ $func (.. $parms) ]> =>
        match (parms) {
          | [ E_expr_list (args) ] =>
            <[ E_call ($(quoted_expr (ctx, func)), $(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_call ($(quotedc_expr (func)), $(Lift (parms, quotedc_expr))) ]>
        }

      | <[ $target = $source ]> =>
        <[ E_assign ($(quoted_expr (ctx, target)), $(quoted_expr (ctx, source))) ]>

      | <[ def $name = $val ]> =>
        <[ E_let ($(false : bool), $(quoted_sstring (ctx, name)), 
                  $(quoted_expr (ctx, val))) ]>

      | <[ mutable $name = $val ]> =>
        <[ E_let ($(true : bool), $(quoted_sstring (ctx, name)),
                  $(quoted_expr (ctx, val))) ]>

      | E_DefPattern (pat, val) =>
        <[ E_DefPattern ($(quoted_expr (ctx, pat)), $(quoted_expr (ctx, val))) ]>;

      | <[ def .. $funs ]> =>
        match (funs) {
          | [(_, E_expr_list (args))] =>
            <[ E_letfun ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_letfun ($(Lift (funs, fun (x) { quoted_fundecl (ctx, x) }))) ]>
        };

      | <[ fun < ..$typarms> (..$args) : $ty where .. $tyconstrs $body ]> =>
        def qtparms = quoted_tparms (ctx, typarms, tyconstrs);
        def qname = <[ SS_string (Name ([])) ]>;
        // lift function declaration from lambda expression
        def fdecl = make_quoted_fundecl (ctx, args, qtparms, ty, qname, body);
        // return syntax tree of lifted lambda
        <[ E_lambda ($fdecl) ]>

      | <[ match ($expr) {.. $cases } ]> =>
        match (cases) {
          | [cas] when match (cas.patterns) { | [] => true | _ => false } =>
            match (cas.body) {
              | E_expr_list (e) =>
                <[ E_Match ($(quoted_expr (ctx, expr)), $(quoted_expr (ctx, e))) ]>
              | _ =>
                Util.ice ("parser generated strange match_case")
            }
          | _ =>
            <[ E_Match ($(quoted_expr (ctx, expr)), 
                        $(Lift (cases, fun (x) { QuotedMatchCase (ctx, x) }))) ]>
        }

      | <[ throw $exc ]> =>
        <[ E_raise ($(quoted_expr (ctx, exc))) ]>

      | <[ ref $e ]> =>
        <[ E_parm_by_ref ($(quoted_expr (ctx, e))) ]>
        
      | <[ out $e ]> =>
        <[ E_parm_out ($(quoted_expr (ctx, e))) ]>

      | <[ try $body catch { $exn : $exn_ty => $handler } ]> => 
        def qbody = quoted_expr (ctx, body);
        <[ E_try_with ($qbody, $(quoted_sstring (ctx, exn)),
                       $(quoted_type (ctx, exn_ty)), 
                       $(quoted_expr (ctx, handler))) ]>

      | <[ try $body finally $handler ]> =>
        <[ E_try_finally ($(quoted_expr (ctx, body)), 
                          $(quoted_expr (ctx, handler))) ]>

      | E_literal (lit) => <[ E_literal ($(quoted_literal (lit))) ]>

      | <[ this ]> => <[ E_this () ]>

      | <[ base ]> => <[ E_base () ]>

      | <[ typeof ($t) ]> => <[ E_typeof ($(quoted_type (ctx, t))) ]>

      | <[ ( $expr :> $ty ) ]> =>
        <[ E_type_conversion ($(quoted_expr (ctx, expr)),
                              $(quoted_type (ctx, ty))) ]>

      | <[ ( $expr : $ty ) ]> =>
        <[ E_type_enforcement ($(quoted_expr (ctx, expr)),
                               $(quoted_type (ctx, ty))) ]>

      | <[ {.. $seq } ]> =>
        match (seq) {
          | [E_expr_list (seq)] =>
            <[ E_sequence ($(quoted_expr (ctx, seq))) ]>
          | _ =>
            <[ E_sequence ($(Lift (seq, quotedc_expr))) ]>
        }

      | <[ (.. $args) ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ E_tuple ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_tuple ($(Lift (args, quotedc_expr))) ]>
        }

      | <[ array < $rank > $value ]> =>
        <[ E_mkarray ($(quoted_expr (ctx, rank)), $(quoted_expr (ctx, value))) ]>

      | <[ array (.. $sizes) ]> =>
        match (sizes) {
          | [E_expr_list (args)] =>
            <[ E_empty_array ($(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_empty_array ($(Lift (sizes, quotedc_expr))) ]>
        }

      | <[ $obj [.. $args] ]> =>  
        match (args) {
          | [E_expr_list (args)] =>
            <[ E_indexer ($(quotedc_expr (obj)), $(quoted_expr (ctx, args))) ]>
          | _ =>
            <[ E_indexer ($(quoted_expr (ctx, obj)), $(Lift (args, quotedc_expr))) ]>
        }

      | E_Underscore => <[ E_Underscore () ]>
      | E_As (pat, name) => 
        <[ E_As ($(quoted_expr (ctx, pat)), $(quoted_sstring (ctx, name))) ]>
         
      | E_Application (func, arg) =>
        <[ E_Application ($(quoted_expr (ctx, func)), $(quoted_expr (ctx, arg))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | E_macrocall (name, namespc, parms) =>
        def quoted_syntax (s) {
          | SyntaxExpr (body) =>
            <[ SyntaxExpr ($(quoted_expr (ctx, body))) ]>
            
          | SyntaxType (body) =>
            <[ SyntaxType ($(quoted_type (ctx, body))) ]>

          | SyntaxCase (body) =>
            <[ SyntaxCase ($(QuotedMatchCase (ctx, body))) ]>
            
          | SyntaxCaseGuard (body, guard) =>
            <[ SyntaxCaseGuard ($(QuotedCaseGuard (ctx, (body, guard)))) ]>
            
          | SyntaxFunDecl (body) =>
            <[ SyntaxFunDecl ($(quoted_fundecl (ctx, body))) ]>
            
          | SyntaxFunParm (body) =>
            <[ SyntaxFunParm ($(quoted_fparam (ctx, body))) ]>
            
          | SyntaxDeclaration (body) =>
            <[ SyntaxDeclaration ($(quoted_member (ctx, body))) ]>
            
          | SyntaxTType (body) =>
            <[ SyntaxTType ($(quoted_type (ctx, body))) ]>

          | SyntaxTTypeBuilder
          | SyntaxTMethod
          | SyntaxTField
          | SyntaxTProperty
          | SyntaxTEvent
          | SyntaxTFunParm =>
            Util.ice ("syntax elements shouldn't appear in quotations")
        };

        <[ E_macrocall ($(quoted_name (name, ctx.env.GetMacroContext ())),
                        GlobalEnv.ExactPath ($(Lift (List.Map (namespc.Name,
                           quoted_string)))),
                        $(Lift (parms, quoted_syntax))) ]>

      | E_spliced (E_type_enforcement (val, <[ type: $(ty : name) ]>)) =>
        match (ty.Id) {
          | "name" => <[ E_ref ($val) ]>
          | "usesite" => <[ E_ref (Name (NString.Split ($val, array ['.']), 
                                         TypingContext.MacroUseColor, 
                                         TypingContext.MacroUseContext)) ]>
          | "dyn" => <[ E_ref (Name ([$val], -1, null)) ]>
          | "byte" => <[ E_literal (L_byte ($val)) ]>
          | "sbyte" => <[ E_literal (L_sbyte ($val)) ]>
          | "short" => <[ E_literal (L_short ($val)) ]>
          | "ushort" => <[ E_literal (L_ushort ($val)) ]>
          | "int" => <[ E_literal (L_int ($val)) ]>
          | "uint" => <[ E_literal (L_uint ($val)) ]>
          | "long" => <[ E_literal (L_long ($val)) ]>
          | "ulong" => <[ E_literal (L_ulong ($val)) ]>
          | "string" => <[ E_literal (L_string ($val)) ]>
          | "bool" => <[ E_literal (L_bool ($val)) ]>
          | "char" => <[ E_literal (L_char ($val)) ]>
          | "float" => <[ E_literal (L_float ($val)) ]>
          | "double" => <[ E_literal (L_double ($val)) ]>
          | "decimal" => <[ E_literal (L_decimal ($val)) ]>

          | "typed" => <[ E_typed_expr ($val) ]>
          | x =>
            Message.fatal_error ("unsupported type `" + x + "' of spliced literal in expression")
        }

      | E_spliced (e) when !in_pattern => e

      | E_spliced => expr

      | E_lambda =>
        Util.ice ("this kind of quoted fun () ... is not supported")
      | E_quoted => 
        Message.fatal_error ("compound of several <[ ... ]> macro scopes is"
                             " not allowed");
      | E_typed_expr | E_typed_pattern => 
        Util.ice ("You've got beer from me for generating such a code (and me to)...");
      | E_expr_list =>
        Message.fatal_error ("List of expression parameters outside of quoted sequence:"
                             " use <[ { .. $x } ]> pattern")
    }
  } // end quoted_expr

  /** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   */    
  public patternize_quotation (exp : Expr) : Expr 
  {
    | E_ref => exp

    | <[ $(_obj : name) . $(_mem : name) ]> =>
//      <[ tern: $(Name (obj.idl + mem.idl, obj.color, obj.context) : name) _ ]>
        /// FIXME: this case is executed for NemerleAttributes.None, but we dont
        ///        have matching for enums yet
        E_Underscore ()
      
    | <[ $constr (.. $pars) ]> =>
      def (con, name) = Option.UnSome (Util.qidl_of_expr (constr));
      def last = List.Last (con);
      match (name.context.LookupType (con)) {        
        | Some (tcon) =>
          def convert_params (pars : list <Expr>, mems : list<IField>,
                              acc : list <Expr>) : Expr {
            match ((pars, mems)) {
              | ([], []) => 
                match (acc) {
                  | [] => E_Underscore ()
                  | _ => E_sequence (List.Rev (acc))
                }

              | (<[ $(n : name) = $expr ]> :: xs, ms)
                when !List.IsEmpty (n.idl) =>
                convert_params (xs, ms, <[ $(n : name) = $(patternize_quotation (expr)) ]> :: acc)

              | (expr :: xs, m :: ms) =>
                convert_params (xs, ms, <[ $(m.Name : dyn) = $(patternize_quotation (expr)) ]> :: acc)

              | ([], _ :: _) => convert_params ([], [], acc)

              | (_ :: _, []) =>
                Message.fatal_error ("Number of supplied parameters is too large")
            }
          };

          def flds = tcon.GetFields (BindingFlags.DeclaredOnly %|
                                     BindingFlags.Public %|
                                     BindingFlags.NonPublic %|
                                     BindingFlags.Instance);
          
          match (tcon.GetTydecl ()) {
            | Typedtree.TD_variant_option =>
              def pars =
                if (last.EndsWith ("M_function"))
                  List.Tail (pars)
                else
                  pars;
              E_Application (<[ $(Name (con, name.color, name.context) : name) ]>,
                             convert_params (pars, flds, []))
            | Typedtree.TD_class  =>
              // we lose informations about constructor here, but as it's 
              // compiler internal computation we can ignore it
              if (last.EndsWith ("Name")) 
                <[ { idl = $(patternize_quotation (List.Head (pars))) } ]>
              else
                convert_params (pars, flds, [])

            | _ =>
              Util.ice ("expression generated from quotation has nor variant"
                        " neither class constructor")
          }

        | None when last.EndsWith ("NameInCurrentColor") =>
          match (pars) {
            | expr :: _ =>
              <[ { idl = $(patternize_quotation (expr)) } ]>
            | _ =>
              Util.ice ("wrong or not enough parameters supplied to "
                        "NameInCurrentColor")
          }

        | None when last.EndsWith ("ExactPath") => E_Underscore ()
          
        | None =>
          Util.ice ("expression generated from quotation has broken constructor")
      }

    | <[ (..$elems) ]> => <[ (..$(List.Map (elems, patternize_quotation))) ]>

    | E_literal => exp 

    | E_Underscore => exp

    | E_spliced (e) => e

    | _ =>
      Message.debug (exp.ToString ()); 
      Message.debug (PrettyPrint.SprintExpr (None (), exp));
      Util.ice ("Bad constructed quoted expression in pattern matching")
  }


  // GENERATION OF MACRO CLASSES SECTION

  /** Generate class implementing interface [MacroRegistry.IMacro], which
      encapsulates execution of macro. Created methods are:
      [Run] for running macro,
      [GetName] for retrieving its name,
      [GetNamespace] for retrieving macro's definition site (namespace)
      [SyntaxExtension] for retrieving syntax extension it defines,
      [CallTransform] for transforming supported call parameters to
        description taken by [Run] method
   */
  internal GenerateMacroClass (env : GlobalEnv, parent_type : option <TypeBuilder>,
                               attrs : Modifiers, header : Fun_header, 
                               synt : list <Expr>, expr : Expr) : void
  {
    def loc = header.loc;
    def name = 
      match (header.name) {
        | SS_string ({ idl = [n] }) => n
        | _ => Message.fatal_error (loc, "spliced name in macro name is not allowed")
      };

    mutable phase = Nemerle.MacroPhase.None;
    mutable tail_transparent = false;
    /// FIXME: we should really operate on typed attributes
    List.Iter (attrs.custom_attrs, fun (_) {
      | <[ MacroUsage (..$(ph :: _)) ]>
      | <[ $_.MacroUsage (..$(ph :: _)) ]> =>
        phase = 
        match (ph) {
          | <[ BeforeInheritance ]> | <[ $_.BeforeInheritance ]> =>
            Nemerle.MacroPhase.BeforeInheritance
          | <[ BeforeTypedMembers ]> | <[ $_.BeforeTypedMembers ]> =>
            Nemerle.MacroPhase.BeforeTypedMembers
          | <[ WithTypedMembers ]> | <[ $_.WithTypedMembers ]> =>
            Nemerle.MacroPhase.WithTypedMembers
          | _ =>
            Nemerle.MacroPhase.None
        }

      | <[ TailRecursionTransparent (true) ]>
      | <[ $_.TailRecursionTransparent (true) ]> =>
        tail_transparent = true;        
      | _ => ()
    });

    // in case of occurance of special type parameters, we change default type
    // on which macro can be executed (macros on methods, fields, types)
    mutable target_type_suff = "";
    def set_target_info (atleast, atmost, suff, name) {
      when (phase == Nemerle.MacroPhase.None)
        Message.error (loc, "macro operating on declaration must have stage attribute");
      when ((atleast :> int) > (phase :> int) || (atmost :> int) < (phase :> int)) 
        Message.error (loc, "macro from this stage cannot have `" + name + "' parameter");
      match (target_type_suff) {
        | "" => target_type_suff = suff
        | ":type" =>
          match (suff) {
            | ":method" | ":field" | ":property" | ":event"
            | ":param" =>
              target_type_suff = suff
            | _ =>
              Message.error (loc, "multiple `TypeBuilder' parameters")              
          }
        | ":method" =>
          if (suff == ":param")
            target_type_suff = suff
          else
            Message.error (loc, "after `Method' theres can be only `Parameter', not " + suff)
          
        | _ =>
          Message.error (loc, "parameter `TypeBuilder' must occure before " + suff)
      }
    };

    // walk through parameters given to macro, extract their names,
    // note type names, control if they correspond to Nemerle grammar,
    // handle variable amount of parameters and default values
    // create code decomposing passed parameters if needed
    def analyze_params (pars : list <Fun_parm>, acc, accs, accmp,
                        defaults : list<Name * Expr>, types : list<string>) 
                        : list <Expr> * list <Expr> * list <MacroParm>
    {
      // build pattern for list from list of patterns
      def roll (li, bu) {
        match (li) {
          | [] => bu
          | x::xs => roll (xs, <[ $x :: $bu ]>)
        }
      };
      // build expression for list from list of expressions
      def roll_expr (li, bu) {
        match (li) {
          | [] => bu
          | (va, d)::xs => roll_expr (xs, <[ { def $(va : name) = $d; $bu } ]>)
        }
      };

      // handle case of standard (not `params' nor with default value) parameter;
      // decompose handled types, note them and build pattern matching
      // parameter's expression
      def normal_parm (t, va) {
        match (t) {
          | T_infer 
          | <[ type: expr ]> => 
            (<[ SyntaxExpr ($(va : name)) ]>, "Expr" :: types, MP_expr ())
            
          | <[ type: funparm ]> =>
            (<[ SyntaxFunParm ($(va : name)) ]>, "funparm" :: types,
             MP_expr ())

          | <[ type: string ]> =>
            (<[ SyntaxExpr (E_literal (L_string ($(va : name)))) ]>,
             "string" :: types, MP_expr ())
             
          | <[ type: int ]> =>
            (<[ SyntaxExpr (E_literal (L_int ($(va : name)))) ]>,
             "int" :: types, MP_expr ())
             
          | <[ type: ParsedField ]> =>
            set_target_info (1, 2, ":field", "ParsedField");            
            (<[ SyntaxDeclaration ((M_field) as $(va : name)) ]>,
             "ParsedField" :: types, MP_implicit ())

          | <[ type: ParsedMethod ]> =>
            set_target_info (1, 2, ":method", "ParsedMethod");            
            (<[ SyntaxDeclaration ((M_function) as $(va : name)) ]>,
             "ParsedMethod" :: types, MP_implicit ())
             
          | <[ type: ParsedProperty ]> =>
            set_target_info (1, 2, ":property", "ParsedProperty");            
            (<[ SyntaxDeclaration ((M_property) as $(va : name)) ]>,
             "ParsedProperty" :: types, MP_implicit ())
             
          | <[ type: ParsedEvent ]> =>
            set_target_info (1, 2, ":event", "ParsedEvent");            
            (<[ SyntaxDeclaration ((M_event) as $(va : name)) ]>,
             "ParsedEvent" :: types, MP_implicit ())
             
          | <[ type: ParsedParameter ]> =>
            set_target_info (1, 2, ":param", "ParsedParameter");            
            (<[ SyntaxFunParm ($(va : name)) ]>, "ParsedParameter" :: types,
             MP_implicit ())

          | <[ type: TypeBuilder ]> =>
            set_target_info (1, 3, ":type", "TypeBuilder");
            target_type_suff = ":type";
            (<[ SyntaxTTypeBuilder ($(va : name)) ]>, "TypeBuilder" :: types,
             MP_implicit ())

          | <[ type: FieldBuilder ]> =>
            set_target_info (3, 3, ":field", "FieldBuilder");            
            (<[ SyntaxTField ($(va : name)) ]>, "FieldBuilder" :: types,
             MP_implicit ())

          | <[ type: MethodBuilder ]> =>
            set_target_info (3, 3, ":method", "MethodBuilder");
            (<[ SyntaxTMethod ($(va : name)) ]>, "MethodBuilder" :: types,
             MP_implicit ())

          | <[ type: PropertyBuilder ]> =>
            set_target_info (3, 3, ":property", "PropertyBuilder");            
            (<[ SyntaxTProperty ($(va : name)) ]>, "PropertyBuilder" :: types,
             MP_implicit ())

          | <[ type: EventBuilder ]> =>
            set_target_info (3, 3, ":event", "EventBuilder");            
            (<[ SyntaxTEvent ($(va : name)) ]>, "EventBuilder" :: types,
             MP_implicit ())

          | <[ type: ParmeterBuilder ]> =>
            set_target_info (3, 3, ":param", "ParameterBuilder");                        
            (<[ SyntaxTFunParm ($(va : name)) ]>, "ParameterBuilder" :: types,
             MP_implicit ())

          | <[ type: uint ]> =>
            (<[ SyntaxExpr (E_literal (L_uint ($(va : name)))) ]>,
             "uint" :: types, MP_expr ())

          | <[ type: long ]> =>
            (<[ SyntaxExpr (E_literal (L_long ($(va : name)))) ]>,
             "long" :: types, MP_expr ())
             
          | <[ type: ulong ]> =>
            (<[ SyntaxExpr (E_literal (L_ulong ($(va : name)))) ]>,
             "ulong" :: types, MP_expr ())

          | <[ type: short ]> =>
            (<[ SyntaxExpr (E_literal (L_short ($(va : name)))) ]>,
             "short" :: types, MP_expr ())
             
          | <[ type: ushort ]> =>
            (<[ SyntaxExpr (E_literal (L_ushort ($(va : name)))) ]>,
             "ushort" :: types, MP_expr ())

          | <[ type: byte ]> =>
            (<[ SyntaxExpr (E_literal (L_byte ($(va : name)))) ]>,
             "byte" :: types, MP_expr ())
             
          | <[ type: sbyte ]> =>
            (<[ SyntaxExpr (E_literal (L_sbyte ($(va : name)))) ]>,
             "sbyte" :: types, MP_expr ())

          | <[ type: float ]> =>
            (<[ SyntaxExpr (E_literal (L_float ($(va : name)))) ]>,
             "float" :: types, MP_expr ())
             
          | <[ type: double ]> =>
            (<[ SyntaxExpr (E_literal (L_double ($(va : name)))) ]>,
             "double" :: types, MP_expr ())

          | <[ type: decimal ]> =>
            (<[ SyntaxExpr (E_literal (L_decimal ($(va : name)))) ]>,
             "decimal" :: types, MP_expr ())

          | <[ type: bool ]> =>
            (<[ SyntaxExpr (E_literal (L_bool ($(va : name)))) ]>,
             "bool" :: types, MP_expr ())
             
          | <[ type: $(n : name) ]> =>
            Message.fatal_error (loc, $"type $(n.Id) not supported for macro parameter")
          | _ =>
            Message.fatal_error (loc, "complex types are not supported for macro parameters")
        }
      };

      // create list of match cases (patterns and expressions) containing
      // cases for default values of parameters, add expressions defining
      // missed parameters according to those default values
      def traverse_patterns (pattss, defaults, defsrest, accpat, accexp) {
        match ((pattss, defaults)) {
          | ([], _) => (accpat, accexp)
          | (patts :: xss, []) =>
            traverse_patterns (xss, [], [], Lift (List.Rev (patts))
                               :: accpat, roll_expr (defsrest, expr) :: accexp)
          | (patts :: xss, d :: ds) =>
            def newdrest = d :: defsrest;
            traverse_patterns (xss, ds, newdrest,
                               Lift (List.Rev (patts)) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
        }
      };

      def message (types) {
        def plist = NString.Concat (", ", List.Rev (types));
        <[
          // runtime variable containing parameters of macro
          def len = List.Length (parms);
          def types = NString.Concat (", ", List.Map (parms, fun (x : object) {
            x.ToString ()
          }));
          Message.fatal_error ("macro `" + $(name : string) +
                               "' expects following list of arguments: (" + 
                               $(plist : string) + ") got some " +
                               len.ToString () + " parameters [" + types + "]")
        ]>
      };
      
      // iterate through parameters
      match (pars) {
        | [] => 
          // we have fixed amount of parameters, so there is always
          // case, which triggers error, handle it
          def warn = message (types);
          def (pats, exps) =
            traverse_patterns (acc :: accs, defaults, [], [ <[ _ ]> ], [warn]);
          (pats, exps, List.Rev (accmp))

        | [ { name = SS_string (va); ty = t;
            modifiers = (_, [<[ System.ParamArrayAttribute ]>], _) } ] =>
          // variable amount of parameters is handled here
          def (initpat, initex) =
            match (acc) {
              // if there are some elemnts other than out 'va', then this
              // pattern won't be exchaustive, and we must supply error msg
              | _ :: _ =>
                def warn = message ("params array" :: types);
                ([ <[ _ ]> ], [warn])
              | _ =>
                ([], [])
            };
          match (t) {
            | <[ type: array <expr> ]> =>
              def (pats, exps) =
                traverse_patterns (accs, defaults, [], 
                                   roll (acc, <[ exprs ]>) :: initpat,
                  <[
                    def $(va : name) = (array (List.Length (exprs))
                                       : array <Expr>);
                    mutable i = 0;
                    foreach (SyntaxExpr (e) in exprs) { 
                      $(va : name)[i] = e;
                      ++i;
                    }
                    $expr
                  ]> :: initex);
              (pats, exps, List.Rev (MP_exprs () :: accmp))

            | _ =>
              Message.fatal_error (loc, "only array of expr or parm are "
                                   "supported in params")
          }

        | ({ name = SS_string (va); ty = t;
            modifiers =
              (_, [<[ System.ComponentModel.DefaultValueAttribute ($e) ]>], _) }) :: xs =>
          // parameter with default value
          match (normal_parm (t, va)) {
            | (p, str :: strs, macroparm) =>
              analyze_params (xs, p :: acc, acc :: accs, macroparm :: accmp, 
                (va, e) :: defaults, str + "(opt)" :: strs)
            | _ => Util.ice ("normal_parm returned empty types list")
          }

        | ({ name = SS_string (va); ty = t; modifiers = _ }) :: xs =>
          match (defaults) {
            | [] =>
              /// [macroparm] is type of parameter supplied by user of macro
              /// or [MP_implicit] if it is not given by him, but implicitly
              /// passed by compiler
              def (p, str, macroparm) = normal_parm (t, va);
              analyze_params (xs, p :: acc, accs, macroparm :: accmp, defaults, str)
            | _ =>
              Message.fatal_error (loc, "parameters with default values must not"
                                   " be mixed with normal")
          }
          
        | ({ name = SS_spliced_expr }) :: _ =>
          Util.ice ("spliced in macro parameters")
      }    
    }; // end analize_parms

    // creates match cases from pairs of pattern and expression
    def consolide_cases (pats, exps, acc) {
      match ((pats, exps)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => 
          consolide_cases (xs, ys, <[ case: $x => $y ]> :: acc)
        | _ => Util.ice ()
      }
    };

    // store positions and types of all parameters accessed by their names
    def mapparams (pars : list <Fun_parm>, n,
                   hash : Hashtable <string, int * Type>)
    {
      match (pars) {
        | [] => hash
        | ({ name = SS_string ({ idl = [x] }); ty = t }) :: xs => 
          if (hash.Contains (x)) 
            Message.fatal_error (loc, "parameter names cannot repeat")
          else
            hash.Add (x, (n, t)); mapparams (xs, n + 1, hash)
        | ({ name = SS_spliced_expr }) :: _ => Util.ice ("spliced in macro params")
        | ({ name = SS_string ({ idl = _}) }) :: _ => Util.ice ("complex name in param name")
      }
    };
    def paramsmap = mapparams (header.parms, 0, Hashtable ());

    // if syntax extending section of macro exists, analyze all tokens and
    // permutation of parameters in its definition
    def analyze_syntax (toks) {
      def analyze_one (tok, acc) {
        def (elements, positions) = acc;
        match (tok) {
          | <[ $(x : string) ]> when LexerBase.IsKeyword (x) =>
            (Parser.GE_keyword (x) :: elements, positions)

          | <[ $(x : string) ]> when LexerBase.IsOperator (x) =>
            (Parser.GE_operator (x) :: elements, positions)

          | <[ Optional ($x) ]> =>
            match (analyze_one (x, acc)) {
              | (Parser.GE_optional :: _, _) =>
                Message.fatal_error (loc, "nested Optional tokens not allowed in"
                                     " syntax definition")
                                     
              | (tok :: rest, pos) => (Parser.GE_optional (tok) :: rest, pos)
                
              | _ => Util.ice ("analyze_one returned empty list")
            }
            
          | <[ $(x : dyn) ]> =>
            match (paramsmap.Get (x)) {
              | Some ((pos, ty)) =>
                paramsmap.Remove (x);
                def grammar_token =
                  match (ty) {
                    | <[ type: funparm ]> => Parser.GE_funparm ()
                    | <[ type: array <expr> ]> => Parser.GE_expression_list (",")
                    | _ => Parser.GE_expression ()
                  };
                (grammar_token :: elements, pos :: positions)
              | None =>
                Message.fatal_error (tok.loc, "parameters from syntax description doesn't"
                                     " match macro's")
            }
          | _ => Message.fatal_error (tok.loc, "unsupported syntax token")
        }
      };
      def (elements, positions) = List.FoldLeft (toks, ([], []), analyze_one);
      // we have reached end of syntax definition, reverse accumulator
      // and return stored tokens and parameters' positions
      match (List.Rev (elements)) {
        | Parser.GE_keyword (key) :: rules => (key, rules, positions)

        // if there was no syntax definition
        | [] => ("", [], [])
        | _ => Message.fatal_error ("first token of syntax definition must be keyword")
      }
    };

    // lift grammar element
    def lift_ge (x) {
      | Parser.GE_operator (name) => <[ Parser.GE_operator ($(name : string)) ]>
      | Parser.GE_keyword (name) => <[ Parser.GE_keyword ($(name : string)) ]>
      | Parser.GE_expression => <[ Parser.GE_expression () ]>
      | Parser.GE_expression_list (sep) =>
        <[ Parser.GE_expression_list ($(sep : string)) ]>
        
      | Parser.GE_funparm => <[ Parser.GE_funparm () ]>
      | Parser.GE_optional (g) => <[ Parser.GE_optional ($(lift_ge (g))) ]>
    };

    // build macro class
    attrs.mods |= NemerleAttributes.Macro %| NemerleAttributes.Public %| 
                  NemerleAttributes.Sealed;
    def td = 
      match (parent_type) {
        | Some (t) =>
          t.DefineNestedType (<[ decl:
            ..$attrs class $(NewSymbol () : name) : IMacro { }
          ]>)

        | None =>
          env.Define (<[ decl:
            ..$attrs class $(NewSymbol () : name) : IMacro { }
          ]>)
      };
    td.MarkWithSpecialName ();
    td.Define (<[ decl: public this () { } ]>);

    def (key, rules, positions) = analyze_syntax (synt);

    // this also checkes parameters to infer target type of macro
    def (macro_patts, macro_exprs, macro_parms) = 
      analyze_params (header.parms, [], [], [], [], []);
    
    def retname =
      if (target_type_suff != "" || phase != Nemerle.MacroPhase.None)
        if (target_type_suff != "") {
          def phase_suf =
            if (phase == Nemerle.MacroPhase.BeforeInheritance) ":postscan"
            else if (phase == Nemerle.MacroPhase.BeforeTypedMembers) ":preadd"
            else if (phase == Nemerle.MacroPhase.WithTypedMembers) ":postadd"
            else
              Message.fatal_error (loc, "macro operating on type declaration parts must"
                                   " have phase modifier");
          name + target_type_suff + phase_suf
        }
        else
          Message.fatal_error (loc, "macro with phase modifier must operate on type"
                               " declaration parts")
      else
        name;
    td.Define (<[ decl:
      GetName () : string implements IMacro.GetName { $(retname : string) }
    ]>);

    td.Define (<[ decl:
      GetNamespace () : string implements IMacro.GetNamespace {
        $(env.GetCurrentNamespace () : string)
      }
    ]>);

    // count notimplicit parameters
    mutable count = List.Length (macro_parms);
    
    // create decision tree for transformation of supported call
    // parameters to our SyntaxElement description
    def create_transform_tree (parms) {
      | MP_expr :: xs =>
        <[
          match (trans_p) {
            | x :: trans_p =>
              trans_res = SyntaxExpr (x) :: trans_res;
              $(create_transform_tree (xs))
            | [] => ()
          }
        ]>
      | [MP_exprs] =>
        <[
          def app_expr (l : list <Expr>) {
            | x :: xs => 
              trans_res = SyntaxExpr (x) :: trans_res;
              app_expr (xs)
            | [] => ()
          };
          app_expr (trans_p)
        ]>

      | [] =>
        <[
          match (trans_p) {
            | x :: _ =>
              trans_res = SyntaxExpr (x) :: trans_res
            | [] => ()
          }
        ]>

      | MP_implicit :: xs =>
        --count;
        create_transform_tree (xs)
        
      | _ => Util.ice ("corrupted macro parameters")
    };
                          
    td.Define (<[ decl:
      CallTransform (trans_p : list<Expr>) : list<SyntaxElement>
      implements IMacro.CallTransform
      {
        mutable trans_res = [];
        $(create_transform_tree (macro_parms));
        List.Rev (trans_res);
      }
    ]>);

    def macro_cases = List.Rev (consolide_cases (macro_patts, macro_exprs, []));

    def run_body = 
      if (phase == Nemerle.MacroPhase.None)
        <[ match (parms) { ..$macro_cases } ]>
      else
        <[ match (parms) { ..$macro_cases }; null ]>;
    
    td.Define (<[ decl:
      Run ($(implicit_ctx_name : name) : Tyexpr.CTX, parms : list<SyntaxElement>) : Expr
      implements IMacro.Run
      {
        $run_body
      }
    ]>);

    td.Define (<[ decl:
      public IsTailRecursionTransparent : bool
      {
        get { $(tail_transparent : bool) }
      }
    ]>);
                                
    td.Define (<[ decl:
      SyntaxExtension () : string * list<Parser.GrammarElement> * list<int>
      implements IMacro.SyntaxExtension
      {
        ($(key : string), $(Lift (rules, lift_ge)),
         $(Lift (positions, fun (x) { <[ $(x : int) ]> } )))
      }
    ]>);

    td.Compile ();                                
  }

  public CreatePermutingFunction (positions : list <int>) 
  : list <SyntaxElement> -> list <SyntaxElement>
  {
    def len = List.Length (positions);
    fun (li) {
      def take_first (n, l, acc) {
        match ((n, l)) {
          | (0, _) => (List.Rev (acc), l)
          | (_, []) => Util.ice ("too few parameters")
          | (n, x :: xs) =>
            take_first (n - 1, xs, x :: acc)
        }
      };
      def pararr = (array (len)) : array <SyntaxElement>;
      mutable m = 0;
      def loop (l, ps) {
        match ((l, ps)) {
          | (x :: xs, [p]) =>
            pararr[p] = x;
            loop (xs, [])
          | (x :: xs, p :: pp) =>
            if (p == len - 1) {
              def (rtail, rfront) =
                take_first (len - m - 1, List.Rev (xs), []);
              pararr[p] = x;
              loop (List.RevAppend (rtail, List.Rev (rfront)), pp)
            }
            else {
              pararr[p] = x;
              m = m + 1;
              loop (xs, pp)
            }
          | (xs, []) => List.Append (List.FromArray (pararr), xs)
          | ([], _) => Util.ice ("too few parameters")
        }
      };
      loop (li, positions)
    }
  }

  public TraverseExpr (ctx : option<CTX>, expr : Expr, call : bool * Expr -> Expr) : Expr
  {
    Util.locate (expr.loc, {
      def expr = 
        match (ctx) {
          | Some (c) => MacroRegistry.expand_macro (c, c, expr)
          | _ => expr
        };

      def trav_funparms (fps) {
        def go_funparm (p : Fun_parm) {
          | <[ funparm: $n : $t = $_e ]> =>
            <[ funparm: $n : $t = $(traverse (_e)) ]>
          | _ => p
        };
        List.Map (fps, go_funparm)
      };
      def traverse (x) { TraverseExpr (ctx, x, call) };

      ignore (call (false, expr));
 
      def recursed =
        match (expr) {
          | <[ $(_ : name) ]> => expr

          | <[ $obj . $mem ]> => 
            <[ $(traverse (obj)) . $mem ]>

          | <[ $func (.. $parms) ]> =>
            def parms = List.Map (parms, traverse);
            <[ $(traverse (func)) (..$parms) ]>

          | <[ $target = $source ]> =>
            <[ $(traverse (target)) = $(traverse (source)) ]>

          | <[ def $n = $val ]> => <[ def $n = $(traverse (val)) ]>

          | <[ mutable $n = $val ]> => <[ mutable $n = $(traverse (val)) ]>

          | <[ def (.. $elems) = $val ]> =>
            <[ def (..$(List.Map (elems, traverse))) = $(traverse (val)) ]>

          | <[ match ($expr) {.. $cases } ]> =>
            def go_case (c : MatchCase) {
              def go_guard (g : Expr * option <Expr>) {
                | <[ caseguard: $pat when $e ]> =>
                  <[ caseguard: $(traverse (pat)) when $(traverse (e)) ]>
                | <[ caseguard: $pat ]> =>
                  <[ caseguard: $(traverse (pat)) ]>
              };

              def <[ case: | ..$guards => $expr ]> = c;
              def guards = List.Map (guards, go_guard);
              <[ case: | ..$guards => $(traverse (expr)) ]>
            };

            def cases = List.Map (cases, go_case);
            <[ match ($(traverse (expr))) {.. $cases } ]>

          | <[ throw $exc ]> =>
            <[ throw $(traverse (exc)) ]>

          | <[ try $body catch { $exn : $exn_ty => $handler } ]> => 
            <[ try $(traverse (body)) catch { 
                 $exn : $exn_ty => $(traverse (handler))
               } ]>

          | <[ try $body finally $handler ]> =>
            <[ try $(traverse (body)) finally $(traverse (handler)) ]>

          | E_literal => expr

          | <[ this ]> => expr

          | <[ base ]> => expr

          | <[ typeof ($_) ]> => expr

          | <[ ( $expr :> $ty ) ]> =>
            <[ ( $(traverse (expr)) :> $ty ) ]>

          | <[ ( $expr : $ty ) ]> =>
            <[ ( $(traverse (expr)) : $ty ) ]>

          | <[ {.. $seq } ]> =>
            <[ { ..$(List.Map (seq, traverse)) } ]>

          | <[ (.. $args) ]> =>
            <[ ( ..$(List.Map (args, traverse)) ) ]>

          | <[ ref $e ]> => <[ ref $(traverse (e)) ]>

          | <[ out $e ]> => <[ out $(traverse (e)) ]>

          | <[ array (..$args) ]> =>
            <[ array ( ..$(List.Map (args, traverse)) ) ]>

          | <[ array $args ]> =>
            <[ array $(traverse (args)) ]>

          | <[ array < $rank > $args ]> =>
            <[ array < $(traverse (rank))> $(traverse (args)) ]>

          | <[ $obj [.. $args] ]> =>
            <[ $(traverse (obj)) [ ..$(List.Map (args, traverse)) ] ]>

          | <[ fun < ..$tparms> (..$args) where ..$tconstrs $body ]> =>
            def args = trav_funparms (args);
            <[ fun < ..$tparms> (..$args) where ..$tconstrs $(traverse (body)) ]>

          | <[ def ..$funs ]> =>
            def go_fun (f : Function_decl) {
              | <[ fundecl: $n < ..$tparms> (..$args)
                   where .. $tconstrs $body ]> =>
                def args = trav_funparms (args);
                <[ fundecl: $n < ..$tparms> (..$args)
                   where .. $tconstrs $(traverse (body)) ]>
              | _ => f
            };
            <[ def ..$(List.Map (funs, go_fun)) ]>

          | E_As (pat, nm) =>
            E_As (traverse (pat), nm) 

          | E_DefPattern (pat, val) =>
            E_DefPattern (traverse (pat), traverse (val))

          | E_Application (func, arg) =>
            E_Application (traverse (func), traverse (arg))

          | E_Underscore =>
            traverse (expr)

          | E_macrocall (x, namespc, parms) =>
            def go_parm (y) {
              | SyntaxExpr (e) =>
                SyntaxExpr (traverse (e))
              | _ => y
            };
            E_macrocall (x, namespc, List.Map (parms, go_parm))

          | E_spliced (e) => E_spliced (traverse (e))

          | E_expr_list (e) => E_expr_list (traverse (e))

          | E_quoted (quot) =>
            def inner =
            match (quot) {
              | SyntaxExpr (body) => SyntaxExpr (traverse (body))
              | SyntaxType 
              | SyntaxCase 
              | SyntaxCaseGuard
              | SyntaxFunDecl 
              | SyntaxFunParm 
              | SyntaxTType 

              | SyntaxDeclaration 
              | SyntaxTTypeBuilder 
              | SyntaxTField 
              | SyntaxTMethod 
              | SyntaxTProperty 
              | SyntaxTEvent 
              | SyntaxTFunParm => quot
            }
            E_quoted (inner)

          | E_typed_expr | E_typed_pattern => expr

          | E_lambda => Util.ice ("Bad construction of E_lambda")
        };
      call (true, recursed)
    })
  }

  public RecursiveRename (tc : TypeBuilder, expr : Expr, from : Name, to : Name) : Expr
  {
    def rename_expr (is_post, e) {
      if (is_post) 
        match (e) {
          | <[ $(n : name) ]> when n.Equals (from) => 
            <[ $(to : name) ]>

          | <[ def $(n : name) = $val ]> when n.Equals (from) => 
            <[ def $(to : name) = $val ]>

          | <[ mutable $(n : name) = $val ]> when n.Equals (from) => 
            <[ mutable $(to : name) = $val ]>

          | <[ this.$(n : name) ]> when n.Equals (from) =>
            <[ this.$(to : name) ]>

          | <[ $obj.$(n : name) ]> when n.Equals (from) =>
            match (GetIfIsType (tc.env, obj)) {
              | Some (t) when t.SameAs (tc) =>
                <[ $obj.$(to : name) ]>
              | _ => e
            }

          | E_try_with (body, SS_string (exn), exn_ty, handler) 
            when exn.Equals (from) =>
            E_try_with (body, SS_string (to), exn_ty, handler)
          | _ => e    
        }
      else e
    }
    Util.locate (expr.loc, {
      TraverseExpr (None (), expr, rename_expr)
    });
  }
}
} // end ns
