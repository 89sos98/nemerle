(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

namespace Nemerle.Compiler 
{
  open Nemerle.Collections;
  open Nemerle.Compiler;
  open Nemerle.Compiler.Typedtree;

  open System.Reflection;

  (**
   * The library reference exception is typically thrown
   * when unable to load an assembly file.
   *)
  public class LibraryReferenceException extends System.Exception 
  {
    public this () {}
  }


  (**
   * Manager for the referenced libraries
   *)
  class LibraryReferenceManager
  {
    (* -- CONSTRUCTORS ----------------------------------------------------- *)
  
    (**
     * Static constructor. Always load the Framework core library.
     *)
    public static this () {

      _libraries <- [];
      _loaded_types <- Hashtable (1000);
      
      AddLibrary (LoadCoreLibrary ())
    }


    (* -- PUBLIC METHODS --------------------------------------------------- *)
  
    (**
     * Stores the referenced library for later lookup by the namespaces.
     *)
    public static AddLibrary (library : LibraryReference) : void {
    
      _libraries <- library :: _libraries;
    }
    
    // used also by LibraryReference class below
    internal static mutable _loaded_types : Hashtable (string, option (Tycon));
  
    (**
     * Searches for a type name in all referenced external libraries.
     *)
    public static LookupType (type_name : string) : option (Tycon)
    {
      def loop (acc, lib : LibraryReference) {
        match ((acc, lib.Lookup (type_name))) {
          | (_, None) => acc
          | (Some, Some) =>
            Message.fatal_error ("type `" + type_name + 
                                 "' is defined in more then one library")
          | (None, (Some) as x) => x
        }
      };
      match (_loaded_types.Get (type_name)) {
        | Some (r) => r
        | None =>
          def res = List.fold_left (loop, None (), _libraries);
          _loaded_types.Set (type_name, res);
          res
      }
    }
    

    (* -- PRIVATE METHODS -------------------------------------------------- *)

    (**
     * Tries to load the core framework library using both 
     * the .NET Framework and Mono naming conventions.
     *)
    private static LoadCoreLibrary () : LibraryReference {

      def mscorelib = try LibraryReference ("mscorlib.dll")
                      with { _ : System.IO.FileNotFoundException => null };
          
      if (mscorelib == null) {
      
        def corlib = try LibraryReference ("corlib.dll")
                     with { 
                       _ : System.IO.FileNotFoundException =>
                         raise LibraryReferenceException ()
                     };
        
        corlib
      }
      else
        mscorelib    
    }
      
    
    (* -- PRIVATE VARIABLES ------------------------------------------------ *)
    
    (**
     * The referenced library list
     *)
    private static mutable _libraries : list (LibraryReference);
  }


  (**
   * This class stores information extracted from a referenced external library.
   *)
  class LibraryReference
  {
    (**
     * The assembly associated with this object
     *)
    private mutable _library : Assembly;

    (**
     * The location of this library
     *)
    private mutable _location : Location;
    
    (**
     * The assembly's custom attributes
     *)
    private mutable _assembly_attributes : list (System.Object);
       
    (**
     * If set to true, the current assembly declares itself 
     * to be generated by the Nemerle compiler.
     *)
    private mutable _is_generated_by_nemerle : bool;
       
       
    (**
     * Loads an assembly given it's file or assembly name. 
     * Extracts and processes the custom attributes array.
     *)
    public this (name : string) 
    {
      try
        _library <- Assembly.Load (name)
      with { _ : System.IO.FileNotFoundException =>
        _library <- Assembly.LoadFrom (name)
      };

      _location <- Location("[library:" + (_library.GetName ()).Name + "]", 0, 0);
      _assembly_attributes <- List.from_array (_library.GetCustomAttributes (true));
      process_assembly_attributes ()
    } 

    (**
     * Scans the assembly custom attributes looking for something interesting...
     *)
    private process_assembly_attributes () : void
    {
      def loop (attributes : list (System.Object)) : void {
        match (attributes) {
          | [] => ()
          | attribute :: rest =>
            def attribute_type = (attribute :> System.Attribute).GetType ();
            when (attribute_type.FullName == "AssemblyConfigurationAttribute") {
              def configuration_attribute = (attribute :> AssemblyConfigurationAttribute);
              
              when (configuration_attribute.Configuration == "ContainsNemerleTypes") {
                Message.debug ("Loaded assembly " + this._library.FullName + " contains Nemerle types...");
                this._is_generated_by_nemerle <- true
              };
            };
            
            loop (rest)
        }
      };
      
      loop (this._assembly_attributes)
    }


    (**
     * Turns a Framework type into something edible by Nemerle's type system
     *)
    private TypeOfType (framework_type : System.Type) : Type
    {
      def framework_type_as_string = framework_type.FullName;
      
      // FIXME: ref and out types, anyone?
      if (framework_type_as_string == "System.Void")
        T_void ()
      else if (framework_type.IsArray)
        T_array (TypeOfType (framework_type.GetElementType ()))
      else if (framework_type.IsByRef)
        T_ref (TypeOfType (framework_type.GetElementType ()))
      else
        match (LibraryReferenceManager.LookupType (framework_type_as_string)) {
          | Some (tc) => T_app (tc, [])
          | None => Util.ice ("unbound external type " + framework_type_as_string)
        }
    } 

    private TyconOfType (framework_type : System.Type) : Tycon
    {
      match (TypeOfType (framework_type)) {
        | T_app (tc, []) => tc
        | _ => Util.ice ()
      }
    } 

    (**
     * If true, the library seems to have been generated by the Nemerle compiler
     *)
    public IsGeneratedByNemerle () : bool 
    {
      this._is_generated_by_nemerle
    }
    
    (**
     * Looks up a type name in this assembly. The type name is expected
     * to be full, i.e. containing the full namespace qualifier.
     *)
    public Lookup (name : string) : option (Tycon) {

      (* always first check if such a type is defined in the current library *)
      def reflected_type = this._library.GetType (name);

      if (reflected_type != null)
        Some ((NetType (this, reflected_type) : Tycon))
      else None ()
    }

    private class NetType
      implements Tycon
    {
      handle : System.Type;
      library : LibraryReference;
      id : int;
      members : Hashtable (string, list (IMember));

      public this (lib : LibraryReference, h : System.Type)
      {
        // first cache ourself to avoid loops
        LibraryReferenceManager._loaded_types.Set (h.FullName, Some ((this : Tycon)));
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        members <- Hashtable (2);
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        // FIXME: wtf is that?
        (handle :> MemberInfo)
      }

      public GetMemType () : Type
      {
        T_app (this, [])
      }

      public GetKind () : MemberKind
      {
        MK_type (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        [Mod_public ()]
      }

      public IsStatic () : bool
      {
        true
      }

      public GetId () : int
      {
        id
      }

      public GetFullName () : string
      {
        handle.FullName
      }

      public GetTyconKind () : TyconKind
      {
        TK_ExternalNetType (handle)
      }

      public GetTydecl () : Type_decl
      {
        if (handle.IsInterface)
          TD_interface ()
        else
          TD_class ()
      }

      public MakeSubst (parms : list (Type)) : Subst
      {
        match (parms) {
          | [] => ()
          | _ =>
            Message.error ("framework type `" + GetFullName () + "' supplied with type arguments")
        };
        Map.int_map ()
      }

      public FreshSubst () : Subst
      {
        Map.int_map ()
      }

      public SuperType (tc : Tycon) : option (list (Type))
      {
        match (tc.GetTyconKind ()) {
          | TK_ExternalNetType (t) when t.IsAssignableFrom (handle)
          | TK_ExternalNemerleType (t) when t.IsAssignableFrom (handle) => Some ([])
          | _ => None ()
        }
      }

      public SubtypingSubst (_ : Tycon) : Subst
      {
        Map.int_map ()
      }

      public SuperClass () : option (Tycon)
      {
        if (handle.BaseType == null)
          None ()
        else
          Some (library.TyconOfType (handle.BaseType))
      }

      public GetSuperTypes () : list (Type)
      {
        def supertypes = Hashtable (30);
        def add_bt (t : Type) {
          match (t) {
            | T_app (tc, []) =>
              if (supertypes.Contains (tc.GetId ())) ()
              else {
                supertypes.Add (tc.GetId (), t);
                match (tc.SuperClass ()) {
                  | Some (tc) => add_bt (T_app (tc, []))
                  | None => ()
                }
              }
            | _ => Util.ice ()
          }
        };
        List.iter (add_bt, GetDirectSuperTypes ());
        supertypes.Fold (fun (_, tc, acc) { tc :: acc }, [])
      }

      public GetDirectSuperTypes () : list (Type)
      {
        def ifaces = List.map (library.TypeOfType, 
                               List.from_array (handle.GetInterfaces ()));
        match (SuperClass ()) {
          | Some (r) => T_app (r, []) :: ifaces
          | None => ifaces
        }
      }

      public SameAs (tc : Tycon) : bool 
      {
        GetId () == tc.GetId ()
      }

      public GetMembers () : list (IMember) 
      {
        LookupMember ("", LF_all ())
      }

      private collect_members (name : string) : list (IMember) 
      {
        def add_member (acc, m : MemberInfo) {
          def tc = library.TyconOfType (m.DeclaringType);
          if (this.SameAs (tc)) {
            def is_a (x) {
              m.MemberType %& x != (0 :> MemberTypes)
            };
            if (is_a (MemberTypes.Constructor) ||
                is_a (MemberTypes.Method))
              (NetMethod (library, (m :> MethodBase)) : IMember) :: acc
            else if (is_a (MemberTypes.Field))
              (NetField (library, (m :> FieldInfo)) : IMember) :: acc
            else if (is_a (MemberTypes.Property))
              (NetProperty (library, (m :> PropertyInfo)) : IMember) :: acc
            else if (is_a (MemberTypes.NestedType))
              (library.TyconOfType ((m :> System.Type)) : IMember) :: acc
            else
              acc
          } else {
            def fullname = m.ToString ();
            def proper_name (m : IMember) {
              m.GetHandle ().ToString () == fullname
            };
//            Message.debug ("name " + name + " look for " + fullname + " in " + tc.GetFullName () + " from " + GetFullName ());
            match (List.filter (proper_name, tc.LookupMember (name, LF_all ()))) {
              | [] => Util.ice ("no match for " + name)
              | [x] => x :: acc
              | _ =>  Util.ice ("2+ matches for " + name)
            }
          }
        };
        
        def flags = BindingFlags.Public     %|
                    BindingFlags.NonPublic  %|
                    BindingFlags.Static     %|
                    BindingFlags.Instance   ;
                    
        def member_array = 
          if (name == "")
            handle.GetMembers (flags) 
          else 
            handle.GetMember (name, flags);
            
        List.fold_left (add_member, [], List.from_array (member_array))
      }

      public LookupMember (name : string, lookup_flag : LookupFlag) : list (IMember) 
      {
        match (members.Get (name)) {
          | Some (r) =>
            Tyutil.FilterMembers (r, lookup_flag)
          | None =>
            def lst = collect_members (name);
            members.Set (name, lst);
            Tyutil.FilterMembers (lst, lookup_flag)
        }
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (handle.DeclaringType != null &&
           Option.is_some (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsNestedFamily)
      }

      public GetSystemType () : System.Type
      {
        handle
      }
    }
    
    private class NetField 
      implements IField
    {
      handle : FieldInfo;
      library : LibraryReference;
      id : int;

      public this (lib : LibraryReference, h : FieldInfo)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
      }

      public GetFieldInfo () : FieldInfo
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        // FIXME
        (handle :> MemberInfo)
      }

      public GetMemType () : Type
      {
        library.TypeOfType (handle.FieldType);
      }

      public GetKind () : MemberKind
      {
        MK_field (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        if (handle.IsStatic) [Mod_public (); Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        handle.IsStatic
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        ! handle.IsInitOnly
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.is_some (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsFamily)
      }
    }
    
    class NetProperty
      implements IProperty
    {
      handle : PropertyInfo;
      library : LibraryReference;
      id : int;
      is_static : bool;
      getter : NetMethod;
      setter : NetMethod;
      mem_type : Type;

      public this (lib : LibraryReference, h : PropertyInfo)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        is_static <- {
          def get_method = handle.GetGetMethod (true);
          def set_method = handle.GetSetMethod (true);
          (get_method != null && get_method.IsStatic) ||
          (set_method != null && set_method.IsStatic);
        };
        
        unless (handle.GetGetMethod () == null)
          getter <- NetMethod (library, handle.GetGetMethod ());
        unless (handle.GetSetMethod () == null)
          setter <- NetMethod (library, handle.GetSetMethod ());

        def ret_type = library.TypeOfType (handle.PropertyType);

        def fun_args (t) {
          match (t) {
            | T_fun (T_void, _) => []
            | T_fun (T_prod (lst), _) => lst
            | T_fun (t, _) => [t]
            | _ => Util.ice ()
          }
        };

        def args =
          if (getter != null)
            fun_args (getter.GetMemType ())
          else if (setter != null)
            List.rev (List.tl (List.rev (fun_args (setter.GetMemType ()))))
          else
            [];
        
        mem_type <-
          match (args) {
            | [] => ret_type
            | [x] => T_fun (x, ret_type)
            | lst => T_fun (T_prod (lst), ret_type)
          };
      }

      public GetGetter () : IMethod
      {
        getter
      }

      public GetSetter () : IMethod
      {
        setter
      }

      public GetPropertyInfo () : PropertyInfo
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        (handle :> MemberInfo)
      }

      public GetMemType () : Type
      {
        mem_type
      }

      public GetKind () : MemberKind
      {
        MK_property (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        if (is_static) [Mod_public (); Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        is_static
      }

      public GetId () : int
      {
        id
      }

      public IsMutable () : bool
      {
        handle.CanWrite
      }

      public CanAccess (_source : Tycon) : bool
      {
        // FIXME: this is broken... we need to check method attributes
        true
      }
    }
    
    class NetMethod
      implements IMethod
    {
      handle : MethodBase;
      library : LibraryReference;
      id : int;
      fun_header : Fun_header;

      public this (lib : LibraryReference, h : MethodBase)
      {
        id <- Util.next_id ();
        library <- lib;
        handle <- h;
        def mkparm (p : ParameterInfo) {
          Fun_parm (
            loc = library._location,
            name = p.Name,
            ty = library.TypeOfType (p.ParameterType),
            decl = null
          )
        };
        def ret_type =
          if (handle.Name == ".ctor" || handle.Name == ".cctor")
            T_void ()
          else
            library.TypeOfType ((handle :> MethodInfo).ReturnType);
        fun_header <-
          Fun_header (
            loc = library._location,
            name = GetName (),
            id = id,
            ret_type = ret_type,
            parms = List.map (mkparm, List.from_array (handle.GetParameters ())),
            typarms = [],
            tenv = null,
            closure_vars = null, // hm..
            all_locals = null,
            decl = null,
            cg_method = null
          )
      }
      
      public GetExternName () : string
      {
        null
      }

      public GetMethodBase () : MethodBase
      {
        handle
      }
      
      public GetName () : string
      {
        handle.Name
      }

      public GetHandle () : MemberInfo
      {
        (handle :> MemberInfo)
      }

      public GetMemType () : Type
      {
        Tyutil.fun_type (GetHeader ())
      }

      public GetKind () : MemberKind
      {
        MK_method (this)
      }

      public GetDeclaringTycon () : Tycon
      {
        library.TyconOfType (handle.DeclaringType)
      }

      public GetLocation () : Location
      {
        library._location
      }

      public GetModifiers () : list (Modifier)
      {
        // FIXME
        if (handle.IsStatic) [Mod_public (); Mod_static ()]
        else [Mod_public ()]
      }

      public IsStatic () : bool
      {
        handle.IsStatic 
      }

      public GetId () : int
      {
        id
      }

      public GetFreshType () : Type
      {
        GetMemType ()
      }

      public GetFunKind () : Fun_kind
      {
        if (handle.IsConstructor)
          if (handle.IsStatic)
            FK_static_ctor ()
          else
            FK_ctor ()
        else
          if (handle.IsStatic)
            FK_function ()
          else
            FK_bound_method ([])
      }

      public GetConstructorInfo () : ConstructorInfo
      {
        assert (handle.IsConstructor);
        (handle :> ConstructorInfo)
      }

      public GetMethodInfo () : MethodInfo
      {
        assert (!handle.IsConstructor);
        (handle :> MethodInfo)
      }

      public GetHeader () : Fun_header
      {
        fun_header
      }

      public CanAccess (source : Tycon) : bool
      {
        handle.IsPublic || 
          (Option.is_some (source.SuperType (GetDeclaringTycon ())) &&
           handle.IsFamily)
      }
    }
    
  }


  
} (* namespace *)
