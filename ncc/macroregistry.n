(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Nemerle.Collections;
open Nemerle.Compiler.Tyexpr;

namespace PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {

(** Interface, which will be implemented by class encapsulating macro
    function. It will allow dynamic execution of macro by compiler
    itself
 *)
public interface IMacro {
  GetName () : string;
  Run (ctx : CTX, args : list (PT.SyntaxElement)) : PT.Expr;
} 

public module MacroRegistry {
  public mutable macros : Hashtable (string, IMacro * list (Macros.MacroParm));
  public mutable macros_types : Hashtable (string, list (Macros.MacroParm));

  this () {
    macros <- Hashtable ();
    macros_types <- Hashtable ();
  }

  public register_macro (m : IMacro) : void {
    def name = m.GetName ();
    if (macros.Contains (name))
      Util.ice ("macro already registered: " + name)
    else
      match (macros_types.Get (name)) {
        | Some (l) => 
          macros.Set (name, (m, l))        
        | None => 
          Util.ice ("macro " + name + " doesn't have corresponding types list")
      }
  }

  public expand_macro (ctx : CTX, expr : PT.Expr) : PT.Expr {
    def transform_parms (parms, types, acc) {
      def make_parm (p) { PT.SyntaxParm (p) };
      def make_expr (p : PT.Parm) { PT.SyntaxExpr (p.expr) };

      match ((parms, types)) {
        | ([], _) => List.rev (acc)
        | (_, []) => List.append (List.rev (acc), List.map (make_parm, parms))
        | (x :: xs, Macros.MP_expr :: ts) =>
          transform_parms (xs, ts, make_expr (x) :: acc)
        | (x :: xs, Macros.MP_parm :: ts) =>
          transform_parms (xs, ts, make_parm (x) :: acc)
        | (_, [Macros.MP_exprs]) =>
          List.append (List.rev (acc), List.map (make_expr, parms))
        | (_, [Macros.MP_parms]) =>
          List.append (List.rev (acc), List.map (make_parm, parms))
        | _ => Util.ice ("wrong pattern during transformation of macro params")
      }
    };

    match (expr) {
      | PT.E_call (PT.E_ref (n), args) =>
        match (macros.Get (n)) {
          | Some ((x, types)) => 
            expand_macro (ctx, x.Run (ctx, transform_parms (args, types, [])));
          | None => expr
        }
      | _ => expr
    }
  }
}
} // end ns
