/*
 * Copyright (c) 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Matching
 */
namespace Nemerle.Compiler 
{
  using Nemerle.Collections;

  using Nemerle.Compiler;
  using Nemerle.Compiler.CGexpr;
  using Nemerle.Compiler.Tyops;
  using Nemerle.Compiler.Typedtree;

  using System.Reflection;
  using System.Reflection.Emit;


  /**
   * A match effect
   */
  internal class MatchEffect
  {
    public this (index : int, effect : Expr)
    {
      m_index = index;
      m_effect = effect;
    }
    
    public GetIndex () : int
    {
      m_index
    }
    
    public GetEffect () : Expr
    {
      m_effect
    }
    
    public Dump () : void
    {
      Message.debug ("MatchEffect::Dump: " + m_index.ToString ());
    }
            
    private mutable m_index : int;
    private mutable m_effect : Expr;
  }
  
  
  /**
   * Top-level pattern with a guard and effect index
   */
  internal class MatchClause
  {
    public this (pattern : Pattern, guard : Expr, effect : int)
    {
      m_pattern = pattern;

      if (guard_is_always_true (guard))
        m_guard = None ()
      else
        m_guard = Some (guard);

      m_effect = effect;
    }
        
    public GetPattern () : Pattern
    {
      m_pattern
    }
    
    public IsGuarded () : bool
    {
      Option.IsSome (m_guard)
    }
    
    public GetGuard () : Expr
    {
      assert (IsGuarded ());

      Option.UnSome (m_guard)
    }
        
    public GetEffect () : int
    {
      m_effect
    }      

    private guard_is_always_true (guard : Expr) : bool
    {
      match (guard) {
        | E_literal (L_bool (true)) => 
          true
          
        | _ =>
          false
      }
    }

    public Dump () : void
    {
      def dump_pattern (pattern : Pattern) 
      {      
        match (pattern) {
          | P_underscore => 
            "P_underscore"

          | P_as (as_pattern, decl) => 
            "P_as (" + dump_pattern (as_pattern) + ", '" + decl.name + "')"

          | P_tuple (args) =>
            "P_tuple {" + List.FoldLeft (
              args, "", 
              fun (tuple_pattern, desc : string) { 
                (if (desc.Length > 0) desc + ", " else "") + dump_pattern (tuple_pattern)
              }
            ) + "}"

          | P_record (args) =>
            "P_record {" + List.FoldLeft (
              args, "", 
              fun (field_and_tuple_pattern : IField * Pattern, desc : string) {
                def (field, tuple_pattern) = field_and_tuple_pattern;
                                                
                (if (desc.Length > 0) desc + ", " else "") +
                 field.Name + ":" + dump_pattern (tuple_pattern)
              }
            ) + "}"

          | P_cons (name, arg) =>
            "P_cons (" + name.FullName + ", " + dump_pattern (arg) + ")"
            
          | P_literal =>
            "P_literal"

          | P_has_type (t) =>
            "P_has_type (" + t.FullName + ")"
        }
      };
    
      Message.debug ("MatchClause::Dump: " + dump_pattern (m_pattern))
    }


    /**
     * Builds a pattern-matcher expression
     */
    public BuildMatchExpr (ctx : CTX, 
                           vals : SystemMap <int, CG_val>, 
                           val : CG_expr) : CTX * SystemMap <int, CG_val> * CG_expr 
    {
      m_vals = vals;
      m_ctx = ctx;
      
      def pattern_expr =
        build_pattern_expr (val, m_pattern, true);

      def guarded_expr =
        if (Option.IsSome (m_guard))
          CE_if (SystemType.Boolean,
                 pattern_expr,
                 cg_expr (m_ctx, Option.UnSome (m_guard)),
                 CE_literal (L_bool (false)))
        else
          pattern_expr;
        
      (m_ctx, m_vals, guarded_expr)
    }
    
    
    /**
     * Builds an expression that evaluates to true if the pattern matches a value
     */
    private build_pattern_expr (val : CG_expr, pattern : Pattern, is_top_level : bool) : CG_expr
    {
      match (pattern) {
        | P_underscore => 
          //FIXME: check for non-nullness of non-value types
          CE_literal (L_bool (true))

        | P_literal (lit) =>
          CGmatch.emit_compare_with (CE_cast (val, type_of (CE_literal (lit)), true), lit)
        
        | P_has_type (ti) =>
          CE_has_type (val, ti.GetSystemType ())

        | P_cons (cons_name, P_underscore) =>
          if (is_top_level) {
            // no nullness check is required here -- it is guaranteed by the effects switch
            CE_literal (L_bool (true))
          }
          else {
            def tyname = cons_name.GetSystemType ();          
            CE_has_type (val, tyname)
          }
          
        | P_cons (cons_name, subpattern) =>
          def tyname = cons_name.GetSystemType ();
          def cast_expr = CE_cast (val, tyname, true);

          if (is_top_level) {
            // no nullness check is required here -- it is guaranteed by the effects switch
            build_pattern_expr (cast_expr, subpattern, false)
          }
          else {
            def has_type_expr = CE_has_type (val, tyname);
                    
            CE_if (SystemType.Boolean,          
                   has_type_expr,
                   build_pattern_expr (cast_expr, subpattern, false),
                   CE_literal (L_bool (false)))
          }

          // FIXME: something's wrong here -- a type cast is generated
          //        when the subpattern does not get matched (?)
        | P_as (subpattern, decl) =>
          unless (decl.in_closure)
            match (m_vals.Find (decl.id)) {
              | Some => ()
              | None =>
                def (new_ctx, v) = store_local (m_ctx, decl, CE_none ());
                m_ctx = new_ctx;
                m_vals = m_vals.Add (decl.id, v);
            };
              
          def assign_expr = 
            CE_assign (local_ref (m_ctx, decl),
                       maybe_cast (m_ctx, cg_type (m_ctx, decl.ty), val));

          match (subpattern) {
            | P_cons =>
              match (build_pattern_expr (val, subpattern, false)) {
                | (CE_if (c, e_then, e_else)) as e =>
                  CE_if (e.ty, c, CE_sequence ([assign_expr, e_then]), e_else)
                | expr =>
                  CE_sequence ([assign_expr, expr])
              }
            | P_has_type =>
              CE_if (build_pattern_expr (val, subpattern, false),
                     CE_sequence ([assign_expr, CE_literal (L_bool (true))]), 
                     CE_literal (L_bool (false)))
            | _ =>
              CE_sequence ([assign_expr, build_pattern_expr (val, subpattern, false)])
          }
            
        | P_tuple (args) =>
          def len = List.Length (args);

          def f (arg, acc)
          {
            def (pos, ex) = acc;
            def cond = 
              build_pattern_expr (
                tuple_ref (CE_cast (val, tuple_type (len), true), pos, len), 
                arg, 
                false
              );
                                  
            (pos - 1, CE_if (SystemType.Boolean, 
                             cond, ex,
                             CE_literal (L_bool (false))))
          };

          def ini = (len, CE_literal (L_bool (true)));            
          def (_, ex) = List.FoldLeft (List.Rev (args), ini, f);
          ex
            
        | P_record (args) =>
          def val = 
            CE_cast (val, cg_type (m_ctx, pattern.ty), true);
            
          def f (np, ex) 
          {
            def (name, pat) = np;
            def cond = 
              build_pattern_expr (CE_field_ref (val, (name : IField).GetFieldInfo ()), pat, false);
              
            CE_if (SystemType.Boolean, cond, ex, CE_literal (L_bool (false)))
          };
          
          List.FoldLeft (List.Rev (args), CE_literal (L_bool (true)), f)
      }
    }
    
    private mutable m_pattern : Pattern;
    private mutable m_guard : option <Expr>;
    private mutable m_effect : int;

    private mutable m_vals : SystemMap <int, CG_val>;
    private mutable m_ctx : CTX;
  }



  /* -- MATCH COLLECTOR ---------------------------------------------------- */
  
  /**
   * Collects match effects and clauses
   */
  internal class MatchCollector
  {
    public this (matchType : System.Type, ctx : CTX, cases : list <Match_case>)
    {
      m_ctx = ctx;
      m_vals = SystemMap ();
      m_matchType = matchType;
      
      collect_cases (cases, [], 0, [])
    }
  
    public GetEffects () : list <MatchEffect>
    {
      m_effects
    }
    
    public GetClauses () : list <MatchClause>
    {
      m_clauses
    }

    public IsTopLevelMatchingOverCons () : bool
    {
      def walk_clauses (clauses : list <MatchClause>) 
      {
        match (clauses) {
          | [] => false            
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | P_cons => true
              | _ => walk_clauses (rest)
            } 
        }
      };
      
      walk_clauses (m_clauses)
    }
  
    public GetTopLevelConsName () : Tycon
    {
      assert (IsTopLevelMatchingOverCons ());

      def walk_clauses (clauses : list <MatchClause>) 
      {
        match (clauses) {
          | [] => 
            Util.ice ("MatchCollector::GetTopLevelConsName")
            
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | P_cons (name, _) => name
              | _ => walk_clauses (rest)
            } 
        }
      };
      
      walk_clauses (m_clauses)
    }

    public BuildEffectsSwitch (ctx : CTX, matching_expr : CG_expr) : CG_expr
    {
      def walk_effects (effects : list <MatchEffect>) : list <int * CG_expr>
      {
        match (effects) {
          | [] => []
          | effect :: rest =>
            def effect_expr =
              cg_expr (ctx, effect.GetEffect ());

            (effect.GetIndex (), effect_expr) :: walk_effects (rest)
        }
      };

      def match_failure_expr =
        CE_raise (CE_call (CE_ctor_ref (InternalType.MatchFailureException_ctor), []));

      CE_switch (
        m_matchType,
        matching_expr,
        Some (match_failure_expr),
        walk_effects (m_effects)
      )
    }


    private collect_cases (cases : list <Match_case>, 
                           effects : list <MatchEffect>, 
                           effects_counter : int,
                           clauses : list <MatchClause>) : void
    {
      match (cases) {
        | [] =>
          m_effects = List.Rev (effects);
          m_clauses = List.Rev (clauses)
          
        | case :: rest =>
          def walk_patterns (patterns : list <Pattern * Expr>, 
                             new_clauses : list <MatchClause>) {
            match (patterns) {
              | [] =>
                List.Rev (new_clauses)
                
              | (pattern, guard) :: rest =>
                def new_clause =
                  MatchClause (
                    pattern, 
                    guard, 
                    effects_counter
                  );
                          
                walk_patterns (rest, new_clause :: new_clauses) 
            }                             
          };
    
          def new_effect =
            MatchEffect (
              effects_counter, 
              case.body
            );
            
          def new_clauses =
            walk_patterns (case.patterns, []);
                  
          collect_cases (
            rest, 
            new_effect :: effects, 
            effects_counter + 1, 
            List.Append (new_clauses, clauses)
          )
      }
    }
  
    private mutable m_effects : list <MatchEffect>;
    private mutable m_clauses : list <MatchClause>;

    private mutable m_vals : SystemMap <int, CG_val>;
    private mutable m_matchType : System.Type;
    private mutable m_ctx : CTX;
  }



  /* ----------------------------------------------------------------------- */
  /* -- MATCHING PROBLEM CATEGORIZATION ------------------------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Recognized matching problem categories
   */
  internal variant MatchProblemCategory {
    | MPC_cons_list_like
    | MPC_cons_tree_like
    | MPC_cons_sparse
    | MPC_cons_sparse_with_const
    | MPC_cons_general
    | MPC_other
  }


  /**
   * A set of heuristics used to categorize matching problems.
   */
  internal class MatchProblemCategorizer
  {
    public this (variant_options : list <Tycon>, match_collector : MatchCollector)
    {
      m_variant_options = variant_options;
      m_match_collector = match_collector;
            
      m_variant_names = SystemMap ();
      m_const_variant_names = SystemMap ();
            
      m_const_variants = [];

      m_variants_lookup = SystemMap ();
      
      m_non_const_variants_used = [];
      m_const_variants_used = [];
          
      categorize_match_problem ()
    }
    
    
    /**
     * Returns the category of the matching problem
     */
    public GetCategory () : MatchProblemCategory
    {
#if EXTRAMATCHINGDEBUG
      Message.debug ("MatchProblemCategorizer::GetCategory: " + m_category.ToString ());
#endif

      m_category
    }
    
    
    /**
     * Returns the list of constant variants
     */
    public GetConstVariants () : list <Tycon * FieldInfo>
    {
      m_const_variants
    }


    /**
     * Returns the list of used const variants
     */
    public GetConstVariantsUsed () : list <Tycon * FieldInfo>
    {
      m_const_variants_used
    }


    /**
     * Returns the list of used non-const variants
     */
    public GetNonConstVariantsUsed () : list <Tycon>
    {
      m_non_const_variants_used    
    }
    
    
    /*
     * Calculates some statistics on the variant options. 
     * Collect the field infos of the const variants for later use.
     */
    private calculate_variant_statistics (variant_options : list <Tycon>) : void
    {
      match (variant_options) {
        | variant_option :: rest =>
          match (CGmatch.get_constant_object (variant_option)) {
            | Some (const_variant_field_info) => 
              m_const_variant_names =
                m_const_variant_names.Add (variant_option.FullName, 0);

              m_const_variants =
                (variant_option, const_variant_field_info) :: m_const_variants;

              ++m_const_variants_count
              
            | _ => ()
          };

          m_variant_names =
            m_variant_names.Add (variant_option.FullName, 0);
          
          m_variants_lookup =
            m_variants_lookup.Add (variant_option.FullName, variant_option);
          
          calculate_variant_statistics (rest)
          
        | [] => ()
      }
    }


    /*
     * Calculates some statistics on clauses
     */    
    private calculate_clause_statistics (clauses : list <MatchClause>) : void
    {
      def increase_occurence_count (name : string)
      {
        def occurence_count =
          m_variant_names.Get (name);
    
        m_variant_names =
          m_variant_names.Replace (name, occurence_count + 1);
      
        ++m_cons_patterns_count;
      };

      def increase_const_occurence_count (name : string)
      {
        def occurence_count =
          m_const_variant_names.Get (name);
    
        m_const_variant_names =
          m_const_variant_names.Replace (name, occurence_count + 1);
      
        ++m_const_cons_patterns_count;
      };
      
      def classify_pattern (pattern : Pattern) : void
      {
        match (pattern) {
          | P_as (subpattern, _) => 
            classify_pattern (subpattern)
            
          | P_cons (name, _) =>
            def name = 
              name.FullName;
                    
            increase_occurence_count (name);
            
            when (m_const_variant_names.Member (name))
              increase_const_occurence_count (name);
            
          | _ => ()
        }
      };
      
      match (clauses) {
        | clause :: rest =>
          ++m_patterns_count;
          classify_pattern (clause.GetPattern ());
                  
          calculate_clause_statistics (rest)
          
        | [] => ()      
      }
    }


    /*
     * Calculates how many variants have actually been used in clauses
     */
    private count_unique_variants_in_clauses () : void
    {
      def variant_iterator (key : string, value : int) : void
      {
        when (value != 0) {
          def variant_option =
            m_variants_lookup.Get (key);

          ++m_unique_cons_patterns_count;
          
          match (m_const_variant_names.Find (key)) {
            | Some (value) when value != 0 =>                
              def const_variant_field_info =
                Option.UnSome (CGmatch.get_constant_object (variant_option));
                
              m_const_variants_used =
                (variant_option, const_variant_field_info) :: m_const_variants_used;
            
              ++m_unique_const_cons_patterns_count
              
            | _ =>
              m_non_const_variants_used =
                variant_option :: m_non_const_variants_used
          }
        }
      };
      
      m_variant_names.Iter (variant_iterator)
    }


    /*
     * Applies some heuristics to categorize the matching problem
     */    
    private categorize_match_problem () : void
    {
      // step one: count the variants
      m_variants_count = List.Length (m_variant_options);
      
      calculate_variant_statistics (m_variant_options);

      // step two: count the patterns      
      calculate_clause_statistics (m_match_collector.GetClauses ());
      
      // step three: check which variants have actually been used
      count_unique_variants_in_clauses ();
      
      // step four: given above statistics, decide the category of the problem
      m_category =
        if (m_variants_count == 0 || m_cons_patterns_count == 0)
          MPC_other ()
        else {
          if (m_variants_count <= 2 && m_const_variants_count >= 1)
            MPC_cons_list_like ()
          else if (m_variants_count == 3 && m_const_variants_count >= 1)
            MPC_cons_tree_like ()
          else if (m_unique_cons_patterns_count <= 3 && 
                   m_unique_const_cons_patterns_count >= 1)
            MPC_cons_sparse_with_const ()
          else if (m_unique_cons_patterns_count <= 2)
            MPC_cons_sparse ()
          else
            MPC_cons_general ()
        }      
    }

    // input data        
    private mutable m_variant_options : list <Tycon>;
    private mutable m_match_collector : MatchCollector;

    // pattern statistics
    private mutable m_patterns_count : int;
    private mutable m_cons_patterns_count : int;
    private mutable m_const_cons_patterns_count : int;
    
    // unique variants in patterns statistics
    private mutable m_unique_cons_patterns_count : int;
    private mutable m_unique_const_cons_patterns_count : int;
    
    // variants statistics
    private mutable m_variants_count : int;
    private mutable m_const_variants_count : int;

    // names of the variants and their usage counts
    private mutable m_variant_names : SystemMap <string, int>;
    private mutable m_const_variant_names : SystemMap <string, int>;
    
    // the list of constant variant options
    private mutable m_const_variants : list <Tycon * FieldInfo>;
    
    // variants lookup table
    private mutable m_variants_lookup : SystemMap <string, Tycon>;

    // the lists of constant/non-constant variants that actually have been used
    private mutable m_non_const_variants_used : list <Tycon>;
    private mutable m_const_variants_used : list <Tycon * FieldInfo>;
    
    // the calculated category of the matching problem
    private mutable m_category : MatchProblemCategory;
  }
  

  
  /* ----------------------------------------------------------------------- */
  /* -- MATCHING OVER VARIANT CONSTRUCTORS CODE GENERATOR ------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Matching over variant constructors code generator
   */
  internal class MatchingOverVariantCons
  {
    internal this (ctx : CTX, val : CG_expr, match_collector : MatchCollector)
    {
      m_ctx = ctx;
      m_val = val;
      m_vals = SystemMap ();    
      m_match_collector = match_collector;
    
      def (variant_options, variant_code_method_info) =
        fetch_variant_options ();

      m_variant_options = variant_options;
  
      m_variant_code_call_expr =
        CE_call (SystemType.Int32, 
                CE_method_ref (val, variant_code_method_info, false), 
                []);

      m_match_categorizer =
        MatchProblemCategorizer (variant_options, match_collector);
        
      match (m_match_categorizer.GetCategory ()) {
        | MPC_cons_list_like => 
          create_list_like_matcher ()

/*
          | MPC_cons_tree_like => "MPC_cons_tree_like"
*/

        | MPC_cons_sparse_with_const
        | MPC_cons_sparse =>
          create_sparse_matcher ()

        | _ => 
          create_general_matcher ()
      }
    }


    /**
     * Returns the resulting matcher
     */
    internal GetMatcher () : CG_expr
    {
      m_matcher
    }


    /**
     * Returns the method info for the _N_GetVariantCode method defined in a given tycon
     */
    private get_variant_code_method (variant_tycon : Tycon) : System.Reflection.MethodInfo 
    {
      def members = 
        variant_tycon.LookupMember ("_N_GetVariantCode");
      
      match (members) {
        | [variant_code_method] =>
          def variant_code_method = 
            (variant_code_method :> IMethod);
          
          variant_code_method.GetMethodInfo ()
        
        | _ =>
          Util.ice ("MatchingOverVariantCons::get_variant_code_method: expected "
                    "exactly one _N_GetVariantCode method")
      }      
    }


    /**
     * Returns the list of variants we're matching over at the top level
     * and the info on the _N_GetVariantCode method.
     */
    private fetch_variant_options () : list <Tycon> * MethodInfo
    {
      def name = 
        m_match_collector.GetTopLevelConsName ();
        
      match (name.GetTyconKind ()) {
        | TK_NemerleType
        | TK_ExternalNemerleType =>
          def variant_tycon =
            match (name.GetDirectSuperTypes ()) {
              | [T_app (variant_tycon, _)] => variant_tycon
              | _ => Util.ice ("MatchingOverVariantCons::fetch_variant_options: "
                               "got TK_ExternalNemerleType, no tycon found")
            };

          def variant_options =
            match (variant_tycon.GetTydecl ()) {
              | TD_variant (members) => members
              | _ => Util.ice ("wrong tydecl in variant")
            };              

          (variant_options, get_variant_code_method (variant_tycon))
                                          
        | _ =>
          Util.ice ("cg_match_over_cons: not a Nemerle type")
      }
    }


    /**
     * Returns a list of clauses that have to do with a variant option
     */
    private collect_variant_related_clauses (variant_option : Tycon) : list <MatchClause>
    {
      def variant_full_name =
        variant_option.FullName;
        
      def walk_clauses (clauses : list <MatchClause>, 
                        acc : list <MatchClause>) : list <MatchClause>
      {
        match (clauses) {
          | [] =>
            List.Rev (acc)
            
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | P_as (P_cons (name, _), _)
              | P_cons (name, _) =>
                if (name.FullName == variant_full_name)
                  walk_clauses (rest, clause :: acc)
                else
                  walk_clauses (rest, acc);

              | P_as (P_underscore, _)
              | P_underscore =>
                walk_clauses (rest, clause :: acc)
                  
              | _ =>
                clause.Dump ();
                Util.ice ("MatchingOverVariantCons::collect_variant_related_clauses: "
                          "wrong pattern (see the dump above)")
            }
        }
      };
      
      walk_clauses (m_match_collector.GetClauses (), [])
    }


    /**
     * Returns a list of clauses that have do not have to do with a variant option
     */
    private collect_variant_unrelated_clauses () : list <MatchClause>
    {
      def walk_clauses (clauses : list <MatchClause>, 
                        acc : list <MatchClause>) : list <MatchClause>
      {
        match (clauses) {
          | [] =>
            List.Rev (acc)
            
          | clause :: rest =>
            match (clause.GetPattern ()) {
              | P_as (P_cons, _)
              | P_cons =>
                walk_clauses (rest, acc);

              | P_as (P_underscore, _)
              | P_underscore =>
                walk_clauses (rest, clause :: acc)
                  
              | _ =>
                clause.Dump ();
                Util.ice ("MatchingOverVariantCons::collect_variant_unrelated_clauses: "
                          "wrong pattern (see the dump above)")
            }
        }
      };
      
      walk_clauses (m_match_collector.GetClauses (), [])
    }


    /**
     * Performs the last step of matcher generation: wraps the matcher
     * expression with CE_let bindings of P_as-induced variables.
     */
    private finalize_matcher (matcher : CG_expr) : void
    {
      def mklet (_ : int, val : CG_val, acc : CG_expr) : CG_expr
      { 
        CE_let (val, acc) 
      };
      
      m_matcher = 
        m_vals.Fold (mklet, matcher)
    }
    

    /**
     * Binds clauses, creating an expression that evaluates to
     * an integer denoting the effect of each of the clauses.
     * We can perform a CE_switch over that later.
     */
    private bind_clauses_for_switch (clauses : list <MatchClause>) : CG_expr
    {
      match (clauses) {          
        | clause :: rest =>
          def (new_ctx, new_vals, clause_expr) =
            clause.BuildMatchExpr (m_ctx, m_vals, m_val);
            
          m_ctx = new_ctx;
          m_vals = new_vals;
            
          CE_if (SystemType.Boolean,          
                 clause_expr,
                 CE_literal (L_int (clause.GetEffect ())),
                 bind_clauses_for_switch (rest))

        | [] => 
          CE_literal (L_int (-1))
      }          
    }

    
    /**
     * Creates a sparse matcher for top-level variants.
     */
    private create_sparse_matcher () : void
    {
      // collects and bind clauses, builds the corresponding CE_has_type expression
      def process_variant (some_variant : Tycon) : CG_expr * CG_expr
      {
        def some_clauses =
          collect_variant_related_clauses (some_variant);

        def some_clauses_effect_expr =
          bind_clauses_for_switch (some_clauses);

        def some_has_type_expr =
          CE_has_type (m_val, some_variant.GetSystemType ());
          
        (some_has_type_expr, some_clauses_effect_expr)
      };

      // get the matchers for the variant unrelated clauses
      def unrelated_clauses =
        collect_variant_unrelated_clauses ();

      def unrelated_clauses_effect_expr =
        match (unrelated_clauses) {
          | [] => CE_literal (L_int (-1))
          | _ => bind_clauses_for_switch (unrelated_clauses)
        };
            
      // get the matchers for the variant options used
      def fold_non_const_variants (some_variant : Tycon, matcher_expr_acc : CG_expr) : CG_expr
      {
        def (some_has_type_expr, some_clauses_effect_expr) =
          process_variant (some_variant);

        CE_if (
          SystemType.Int32, 
          some_has_type_expr,
          some_clauses_effect_expr,
          matcher_expr_acc
        )        
      };
      
      def non_const_matcher_expr =
        List.FoldLeft (
          m_match_categorizer.GetNonConstVariantsUsed (), 
          unrelated_clauses_effect_expr,
          fold_non_const_variants
        );

      // build the comparers for the const variants
      def fold_const_variants (const_cons : Tycon * FieldInfo, matcher_expr_acc : CG_expr) : CG_expr
      {
        def (some_variant, const_cons_field_info) = 
          const_cons;
        
        def (_, some_clauses_effect_expr) =
          process_variant (some_variant);

        def compare_to_const_expr =
          CE_call (SystemType.Boolean, CE_opcode ("=="),
                  [m_val, CE_global_ref (const_cons_field_info)]);
            
        CE_if (SystemType.Int32,
               compare_to_const_expr,
               some_clauses_effect_expr,
               matcher_expr_acc);
      };

      def matcher_expr =
        List.FoldLeft (
          m_match_categorizer.GetConstVariantsUsed (),
          CE_sequence ([CE_not_null (m_val), non_const_matcher_expr]),
          fold_const_variants
        );

      // builds the effects switch and wrap the matcher with appropriate CE_lets
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, matcher_expr);

      finalize_matcher (effects_switch)      
    }


    /**
     * Creates a matcher for top-level list-like variants
     *
     * NOTE: we could have two constant constructors here
     */
    private create_list_like_matcher () : void
    {
      // get the tycons for the variant options
      def (const_cons_tycon, const_cons_field_info) =
        match (m_match_categorizer.GetConstVariants ()) {
          | const_cons :: _ => const_cons
          | _ => Util.ice ("MatchingOverVariantCons::create_list_like_matcher: "
                           "expected at least one constant variant constructor")
        };

      def non_const_cons_tycon =
        match (m_variant_options) {
          | [left, right] => if (left == const_cons_tycon) right else left
          | _ => Util.ice ("MatchingOverVariantCons::create_list_like_matcher: "
                           "expected exactly two variant options")
        };

      // categorize the clauses, build the effects expressions
      def const_clauses =
        collect_variant_related_clauses (const_cons_tycon);

      def const_clauses_effect_expr =
        bind_clauses_for_switch (const_clauses);
        
      def non_const_clauses =
        collect_variant_related_clauses (non_const_cons_tycon);

      def non_const_clauses_effect_expr =
        bind_clauses_for_switch (non_const_clauses);

      // build the variant checking expression
      def compare_to_const_expr =
        CE_call (SystemType.Boolean, CE_opcode ("=="),
                [m_val, CE_global_ref (const_cons_field_info)]);

      def non_const_check_expr =
        CE_sequence ([CE_not_null (m_val), non_const_clauses_effect_expr]);
            
      def const_check_expr =
        CE_if (SystemType.Int32,
               compare_to_const_expr,
               const_clauses_effect_expr,
               non_const_check_expr);

      // builds the effects switch and wrap the matcher with appropriate CE_lets
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, const_check_expr);

      finalize_matcher (effects_switch)      
    }

    

    /**
     * Builds a general matcher over constructors on the top level
     */
    private create_general_matcher () : void
    {
      def walk_variant_options (index : int, variant_options : list <Tycon>) : list <int * CG_expr>
      {
        match (variant_options) {
          | variant_option :: rest =>
#if EXTRAMATCHINGDEBUG
            Message.debug (index.ToString () + ": " + variant_option.FullName);
#endif

            def patterns =
              collect_variant_related_clauses (variant_option);

            def effect_expr =
              bind_clauses_for_switch (patterns);
            
            (index, effect_expr) :: walk_variant_options (index + 1, rest)
            
          | [] => []
        }
      };

#if EXTRAMATCHINGDEBUG
      Message.debug ("walking variant options of type " + variant_tyinfo.FullName);
#endif

      def cons_switch_cases =
        walk_variant_options (0, m_variant_options);
        
      def cons_switch =
        CE_switch (
          SystemType.Int32,
          m_variant_code_call_expr,
          Some (CE_literal (L_int (-1))),
          cons_switch_cases
        );
        
      def effects_switch = 
        m_match_collector.BuildEffectsSwitch (m_ctx, cons_switch);

      def guarded_effects_switch =
        CE_sequence ([CE_not_null (m_val), effects_switch]);

      finalize_matcher (guarded_effects_switch)
    }  


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable m_ctx : CTX;
    private mutable m_val : CG_expr;
    private mutable m_vals : SystemMap <int, CG_val>;
    private mutable m_match_collector : MatchCollector;
    private mutable m_variant_options : list <Tycon>;
    private mutable m_variant_code_call_expr : CG_expr;
    private mutable m_match_categorizer : MatchProblemCategorizer;
    
    // the resulting matcher
    private mutable m_matcher : CG_expr; 
  }




  /* ----------------------------------------------------------------------- */  
  /* --  OLD APPROACH ------------------------------------------------------ */
  /* ----------------------------------------------------------------------- */

  /**
   * Description of a match pattern:
   *
   * | [pattern] when [guard] => [effect]
   *
   * Additionally, we hold an ordered list of guards that 
   * could possibly override this match.
   */
  internal class MatchPattern
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, pattern : Pattern, 
                 guard : int, effect : int, guard_is_always_true : bool,
                 as_pattern_val : option <CG_val>)
    {
      this.guard_is_always_true = guard_is_always_true;
      this.match_descriptor = match_descriptor;
      this.as_pattern_val = as_pattern_val;
      this.pattern = pattern;
      this.guard = guard;
      this.effect = effect;
      overriden_by = [];
    }
    

    /* -- PUBLIC METHODS --------------------------------------------------- */
    
    public PossiblyOverrides (match_pattern : MatchPattern) : bool
    {
      compare_patterns (pattern, match_pattern.pattern)
    }
        
    public AlwaysOverrides (match_pattern : MatchPattern) : bool
    {
      PossiblyOverrides (match_pattern) && guard_is_always_true
    }
    
    public AddOverridingPattern (match_pattern : MatchPattern) : void
    {
      overriden_by = match_pattern :: overriden_by
    }
    
    public ReverseOverridingList () : void
    {
      overriden_by = List.Rev (overriden_by)
    }
    
    public NeedExtraMatchChecks () : bool
    {
      !guard_is_always_true || List.Length (overriden_by) != 0
    }

    public GetEffectIndex () : int
    {
      effect
    }

    public GetPattern () : Pattern
    {
      pattern
    }

    public GetOverridingPatterns () : list <MatchPattern>
    {
      overriden_by
    }    
    
    public SetOverridingPatterns (overriden_by : list <MatchPattern>) : void
    {
      this.overriden_by = overriden_by
    }
        
    public GetLocation () : Location
    {
      pattern.loc
    }
    
    public IsUnderscore () : bool
    {
      match (pattern) {
        | P_underscore => true
        | P_as (P_underscore, _) => true
        | _ => false
      }
    }


    /**
     * Returns true if a pattern is an ordinal constant (an int 
     * or a char) -- possibly hidden beyond the 'as' construct.
     */
    public static IsOrdinalLiteral (pattern : MatchPattern) : bool
    {
      match (pattern.GetPattern ()) {
        | P_underscore => false
        | P_as (P_underscore, _) => false
        | P_as (P_literal (L_int), _) => true
        | P_as (P_literal (L_char), _) => true
        | P_literal (L_int) => true
        | P_literal (L_char) => true
        | _ => Util.ice ("invalid pattern type")
      }    
    }


    /**
     * Returns true if a pattern is a string constant 
     * (possibly hidden beyond the 'as' construct).
     */
    public static IsStringLiteral (pattern : MatchPattern) : bool
    {
      match (pattern.GetPattern ()) {
        | P_underscore => false
        | P_as (P_underscore, _) => false
        | P_as (P_literal (L_string), _) => true
        | P_literal (L_string) => true
        | _ => Util.ice ("invalid pattern type")
      }    
    }


    public MakeGuardExpr (continuation : option <CG_expr>) : CG_expr
    {
      def guard_expr =
        match (match_descriptor.GetGuard (guard)) {
          | Some (guard) => 
            assert (Option.IsSome (continuation),
                    "need to have a continuation if guards can fail");
            
            CE_if (match_descriptor.GetResultType (), guard,
                   match_descriptor.GetEffect (effect), 
                   Option.UnSome (continuation))
                  
          | None => 
            match_descriptor.GetEffect (effect)
        };
      
      collect_overriding_patterns (overriden_by, guard_expr);
    }


    /**
     * Comparison function that can be used by the List.Sort function
     */
    public static Compare (l : MatchPattern, r : MatchPattern) : int
    {
      def is_string_pattern =
        match (l.GetPattern ()) {
          | P_literal (L_string)
          | P_as (P_literal (L_string), _) => true
          | _ => false
        };
        
      if (is_string_pattern) {
        def get_literal (pattern : MatchPattern) : string {
          match (pattern.GetPattern ()) {
            | P_literal (L_string (literal)) => literal
            | P_as (P_literal (L_string (literal)), _) => literal
            | _ => Util.ice ("invalid pattern type")
          }
        };
        
        System.String.CompareOrdinal (get_literal (r), get_literal (l))
      }
      else {
        def get_literal (pattern : MatchPattern) : int {        
          match (pattern.GetPattern ()) {
            | P_literal (L_int (literal)) => literal
            | P_literal (L_char (literal)) => (literal :> int)
            | P_as (P_literal (L_int (literal)), _) => literal
            | P_as (P_literal (L_char (literal)), _) => (literal :> int)
            | _ => Util.ice ("invalid pattern type")
          }
        };
        
        get_literal (l) - get_literal (r)
      }
    }


    public MakeMatchExpr (compare_to : CG_expr, continuation : CG_expr) : CG_expr
    {
      match (pattern) {
        | P_literal (literal) =>
          def eq_expr = CGmatch.emit_compare_with (compare_to, literal);

          def guard_expr =
            match (match_descriptor.GetGuard (guard)) {
              | Some (guard) => 
                CE_if (match_descriptor.GetResultType (), guard, 
                       match_descriptor.GetEffect (effect), continuation)
              | None =>
                match_descriptor.GetEffect (effect)
            };

          def overriding_expr =
            collect_overriding_patterns (overriden_by, guard_expr);
            
          CE_if (match_descriptor.GetResultType (), eq_expr, overriding_expr,
                 continuation)

        | P_underscore =>
          def guard_expr =
            match (match_descriptor.GetGuard (guard)) {
              | Some (guard) => 
                CE_if (match_descriptor.GetResultType (), guard,
                       match_descriptor.GetEffect (effect), continuation)              
              | None => 
                match_descriptor.GetEffect (effect)
            };

          collect_overriding_patterns (overriden_by, guard_expr)
              
        | P_as (subpattern, _) =>
          def subpattern = 
            MatchPattern (match_descriptor, subpattern, guard, 
                          effect, true, None ());
  
          subpattern.SetOverridingPatterns (GetOverridingPatterns ());
          
          CE_let (Option.UnSome (as_pattern_val), 
                  subpattern.MakeMatchExpr (compare_to, continuation))
          
          /*
          match (subpat) {
            | P_cons =>
              match (cgpat (val, subpat)) {
                | (CE_if (c, e_then, e_else)) as e =>
                  CE_if (e.ty, c, CE_sequence ([ass; e_then]), e_else)
                | _ => Util.ice ()
              }
            | _ =>
              CE_sequence ([ass; cgpat (val, subpat)])
          }
          */
          
        | _ => 
          Util.ice ("pattern type not supported in MakeMatchExpr")
      }
    }
    
    
    public MakeLessThanCondition (compare_to : CG_expr) : CG_expr
    {
      match (pattern) {
        | P_literal (L_string) =>
          Util.ice ("constant string patterns not supported in MakeLessThanCondition")
        | P_literal (L_bool) =>
          Util.ice ("constant boolean patterns not supported in MakeLessThanCondition")
        | P_literal (literal) =>
          CE_call (SystemType.Boolean, CE_opcode ("<.s"),
                   [compare_to, CE_literal (literal)])
        | _ => 
          Util.ice ("non-literal patterns not supported in MakeLessThanCondition")
      }    
    }

    public Dump () : void
    {
      def message =
        match (pattern) {
          | P_literal (L_string (literal)) => "P_literal L_string '" + literal + "'"
          | P_literal (L_int (literal)) => "P_literal L_int " + literal.ToString ()
          | P_literal (L_char (literal)) => "P_literal L_char " + 
            (literal :> int).ToString ()
          | P_underscore => "P_underscore"
          | P_as (P_underscore, _) => "P_as/P_underscore"
          | _ => "other"
        };
        
      Message.debug (message)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    private collect_overriding_patterns (overriden_by : list <MatchPattern>, 
                                         continuation : CG_expr) : CG_expr
    {
      match (overriden_by) {
        | [] => continuation
        | pattern :: rest =>
          // Message.debug (pattern.GetLocation (),
          //                "this pattern is sometimes overriding");
          def continuation = pattern.MakeGuardExpr (Some (continuation));
          collect_overriding_patterns (rest, continuation)
      }
    }
    
    
    private compare_literals (l : Literal, r : Literal) : bool
    {
      match ((l, r)) {
        | (L_null, L_null) => true
        | (L_int (l), L_int (r)) => l == r
        | (L_string (l), L_string (r)) => l == r
        | (L_float (l), L_float (r)) => l == r
        | (L_char (l), L_char (r)) => l == r
        | (L_bool (l), L_bool (r)) => l == r
        | _ => false
      }
    } 
    
    private compare_tuples (l : list <Pattern>, r : list <Pattern>) : bool
    {
      def walk_tuples (l : list <Pattern>, r : list <Pattern>) : bool {
        match ((l, r)) {
          | ([], []) => true
          | (l :: ls, r :: rs) => 
            if (compare_patterns (l, r)) walk_tuples (ls, rs) else false
          | _ => false
        }
      };
      
      walk_tuples (l, r)
    }
    
    private compare_records (l : list <IField * Pattern>,
                             r : list <IField * Pattern>) : bool
    {
      // FIXME
      List.Length (l) != List.Length (r)
    }
    
    private compare_conses (_ln : Tycon, _la : Pattern, _rn : Tycon,
                            _ra : Pattern) : bool
    {
      // FIXME
      false
    }
    
    private compare_patterns (l : Pattern, r : Pattern) : bool
    {
      match ((l, r)) {
        | (P_underscore, _) => true
        | (P_as (P_underscore, _), _) => true
        | (P_literal (l), P_literal (r)) => compare_literals (l, r)      
        | (P_tuple (l), P_tuple (r)) => compare_tuples (l, r)
        | (P_record (l), P_record (r)) => compare_records (l, r)
        | (P_cons (ln, la), P_cons (rn, ra)) => compare_conses (ln, la, rn, ra)       
        | _ => false
      }
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable pattern : Pattern;
    private mutable guard : int;
    private mutable effect : int;
    private mutable as_pattern_val : option <CG_val>;
    private mutable overriden_by : list <MatchPattern>;
    private mutable guard_is_always_true : bool;
  }


  /**
   * Search for a matching pattern is optimized within
   * pattern blocks only.
   */
  internal class MatchBlock
  {
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (patterns : list <MatchPattern>)
    {
      this.patterns = patterns;
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public RemoveOverridenPatterns () : void
    {
      def walk_patterns (patterns : list <MatchPattern>) : list <MatchPattern> {
        | [] => []
        | head :: tail =>
          def overrides (pattern : MatchPattern) : bool {
            if (head.AlwaysOverrides (pattern)) {
              Message.warning (head.GetLocation (), "this pattern overrides pattern:");
              Message.warning (pattern.GetLocation (), "pattern is redundant");
              false
            }
            else true              
          };
          head :: walk_patterns (List.Filter (tail, overrides))
      };
      
      patterns = walk_patterns (patterns)
    }


    public DecidePatternOverriding () : void
    {
      mutable current_pattern_can_be_skipped = false;
      
      def decide_pattern_overriding (head : MatchPattern, 
                           patterns : list <MatchPattern>) : list <MatchPattern>
      {        
        match (patterns) {
          | pattern :: rest =>
            // Message.debug (pattern.GetLocation (), "comparing to this pattern");
            if (head.PossiblyOverrides (pattern)) {
              // add overriding information for possibly hidden patterns
              pattern.AddOverridingPattern (head);
              unless (head.IsUnderscore ()) current_pattern_can_be_skipped = true;
              pattern :: decide_pattern_overriding (head, rest)
            }
            else {
              // leave the rest as is
              pattern :: decide_pattern_overriding (head, rest)
            }
          | [] => []
        }
      };  
      
      def walk_patterns (patterns : list <MatchPattern>) : list <MatchPattern> {
        match (patterns) {
          | pattern :: rest =>
            current_pattern_can_be_skipped = false;
            // Message.debug (pattern.GetLocation (), "deciding overriding for this pattern");
            def rest = decide_pattern_overriding (pattern, rest);
            pattern.ReverseOverridingList ();
            if (!current_pattern_can_be_skipped) {
              // Message.debug (pattern.GetLocation (), "keeping this pattern");
              pattern :: walk_patterns (rest)
            }
            else {
              // Message.debug (pattern.GetLocation (), "skipping this pattern");
              walk_patterns (rest)
            }
          | [] => []
        }
      };
      
      patterns = walk_patterns (patterns)
    }

    public GetMatchPatterns () : list <MatchPattern> 
    {
      patterns
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable patterns : list <MatchPattern>;
  }


  /**
   * A match construct consists of a number of blocks, 
   * guards and effects.
   */
  internal class MatchDescriptor
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    /**
     * Initializes the match descriptor. 
     * Builds the initial patterns block.
     */    
    internal this (context : CTX, result_type : System.Type, 
                   matched_expr : CG_expr, match_cases : list <Match_case>)
    {
      vals = SystemMap ();
      guards = SystemMap ();
      effects = SystemMap ();
            
      current_guard = -1;
      current_effect = -1;
      
      this.context = context;
      this.result_type = result_type;
      this.matched_expr = matched_expr;

      matched_expr_type = type_of (matched_expr);
      match_over_value_type = matched_expr_type.IsValueType;
      
      build_first_block (match_cases)
    }

    
    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetResultType () : System.Type
    {
      result_type
    }
    
    public DecidePatternOverriding () : void
    {
      def decide_pattern_overriding (block : MatchBlock) : void {
        block.DecidePatternOverriding ()
      };
      
      List.Iter (blocks, decide_pattern_overriding)
    }

    public GetMatchBlocks () : list <MatchBlock> 
    {
      blocks
    }

    public GetMatchedExpr () : CG_expr
    {
      matched_expr
    }

    public GetContext () : CTX
    {
      context
    }

    public GetEffect (index : int) : CG_expr
    {
      effects.Get (index)
    }

    public GetGuard (index : int) : option <CG_expr>
    {
      if (index == -1) None () else guards.Get (index)
    }

    public MakeAsPatternAssignment (decl : LocalValue) : CG_expr * CG_val
    {      
      mutable as_pattern_val = null;
      
      unless (decl.in_closure) {
        match (vals.Find (decl.id)) {
          | Some (val) =>
            as_pattern_val = val
          | None =>
            def (context, val) = store_local (context, decl, CE_none ());
            this.context = context;
            as_pattern_val = val;
            vals = vals.Add (decl.id, val);
        }
      };
      
      def assign_expr =
        CE_assign (local_ref (context, decl), 
                   maybe_cast (context, cg_type (context, decl.ty), 
                               matched_expr));
                               
      (assign_expr, as_pattern_val)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */
    
    /**
     * Builds the first block of patterns. This block will have to be either
     * split or the overriding guards information will have to be updated.
     */
    private build_first_block (match_cases : list <Match_case>) : void
    {
      mutable patterns = [];

      def process_pattern (pattern : Pattern, guard : Expr) : void {
        current_guard = current_guard + 1;
        mutable previous_as_pattern_val = None ();
     
        // FIXME: 'as' nesting   
        def guard =
          match (pattern) {
            | P_as (_, decl) =>
              def (assign_expr, as_pattern_val) = MakeAsPatternAssignment (decl); 
              previous_as_pattern_val = Some (as_pattern_val);
              CE_sequence ([assign_expr, cg_expr (context, guard)])
            | _ => 
              cg_expr (context, guard)
          };
          
        def guard_is_always_true =
          match (guard) {
            | CE_literal (L_bool (true)) =>
              guards = guards.Add (current_guard, None ());
              true
            | _ =>
              guards = guards.Add (current_guard, Some (guard));
              false
          };
          
        def pattern =
          MatchPattern (this, pattern, current_guard, current_effect, 
                        guard_is_always_true, previous_as_pattern_val);

        patterns = pattern :: patterns
      };
      
      def walk_match_cases (match_cases : list <Match_case>) : void {
        match (match_cases) {
          | [] => ()
          | match_case :: rest =>
            current_effect = current_effect + 1;
            List.Iter (match_case.patterns, process_pattern);
            effects = effects.Add (current_effect, cg_expr (context, match_case.body));
            walk_match_cases (rest)
        }
      };
      
      walk_match_cases (match_cases);
      patterns = List.Rev (patterns);
      def block = MatchBlock (patterns);
      block.RemoveOverridenPatterns ();
      block.DecidePatternOverriding ();
      blocks = [block]
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable blocks : list <MatchBlock>;
    private mutable guards : SystemMap <int, option <CG_expr>>;
    private mutable effects : SystemMap <int, CG_expr>;
    private mutable current_guard : int;
    private mutable current_effect : int;
    private mutable vals : SystemMap <int, CG_val>;
    
    private mutable context : CTX;
    private mutable result_type : System.Type;
    private mutable matched_expr : CG_expr;

    private mutable matched_expr_type : System.Type;
    private mutable match_over_value_type : bool;
  }
  

  /**
   * Builds an expression that performs a binary search 
   * over a value type (that'd mainly be ints and chars).
   */
  internal class MatchBinarySearch
  {    
    /* -- CONSTRUCTORS ----------------------------------------------------- */

    public this (match_descriptor : MatchDescriptor, 
                 patterns : list <MatchPattern>,
                 continuation : option <CG_expr>)
    {
      assert (List.Length (patterns) > 0);
      
      this.match_descriptor = match_descriptor;
      this.patterns = patterns;
      this.matched_expr = match_descriptor.GetMatchedExpr ();
      this.continuation = continuation;
      
      binary_search_expr = make_binary_search_top_level (patterns)
    }


    /* -- PUBLIC METHODS --------------------------------------------------- */

    public GetBinarySearchExpr () : CG_expr
    {
      binary_search_expr
    }
    
    public DumpMatchPatterns (patterns : list <MatchPattern>) : void {
      def walk_patterns (patterns : list <MatchPattern>) : void {
        match (patterns) {
          | [] => ()
          | pattern :: rest =>
            pattern.Dump ();
            walk_patterns (rest)
        }
      };
      
      Message.debug (" -- dumping " + (List.Length (patterns)).ToString ()
                     + " patterns --");
      walk_patterns (patterns)
    }


    /* -- PRIVATE METHODS -------------------------------------------------- */

    private split_patterns (patterns : list <MatchPattern>) 
      : list <MatchPattern> * MatchPattern * list <MatchPattern>
    {
      assert (List.Length (patterns) > 2);
      
      def split (patterns : list <MatchPattern>, acc : list <MatchPattern>, length : int) 
        : list <MatchPattern> * MatchPattern * list <MatchPattern>
      {
        if (length == 0) (List.Rev (acc), List.Head (patterns), List.Tail (patterns))
        else split (List.Tail (patterns), List.Head (patterns) :: acc, length - 1)      
      };
      
      split (patterns, [], List.Length (patterns) / 2)
    }


    private split_patterns_by_sign (patterns : list <MatchPattern>) 
      : list <MatchPattern> * list <MatchPattern>
    {
      def split (patterns : list <MatchPattern>, acc_neg : list <MatchPattern>,
                 acc_pos : list <MatchPattern>)
          : list <MatchPattern> * list <MatchPattern>
      {
        match (patterns) {
          | [] => (List.Rev (acc_neg), List.Rev (acc_pos))
          | pattern :: rest =>
            match (pattern.GetPattern ()) {
              | P_literal (L_int (k)) =>
                if (k < 0) split (rest, pattern :: acc_neg, acc_pos)
                else split (rest, acc_neg, pattern :: acc_pos)
              | _ =>
                Util.ice ("split_patterns_by_sign: expected P_literal"
                          " L_int patterns only")
            };
        }            
      };
      
      split (patterns, [], [])
    }


    private make_last_match (pattern : MatchPattern) : CG_expr
    {
      match (continuation) {
        | Some (continuation) =>
          pattern.MakeMatchExpr (matched_expr, continuation)          
        | None => 
          Util.ice ("last match case need to have continuation")
      }
    }


    private make_switched_block (patterns : list <MatchPattern>) : CG_expr 
    {
      def get_literal (pattern : MatchPattern) : int {        
        match (pattern.GetPattern ()) {
          | P_literal (L_int (literal)) => literal
          | P_literal (L_char (literal)) => (literal :> int)
          | P_as (P_literal (L_int (literal)), _) => literal
          | P_as (P_literal (L_char (literal)), _) => (literal :> int)
          | _ => Util.ice ("invalid pattern type")
        }
      };

      def walk_patterns (patterns : list <MatchPattern>) : list <int * CG_expr> {
        match (patterns) {
          | pattern :: rest =>
            (get_literal (pattern), pattern.MakeGuardExpr (continuation))
            :: walk_patterns (rest)
          | [] => []
        }            
      };

      CE_switch (matched_expr, continuation, walk_patterns (patterns))
    }

    
    private make_binary_search (patterns : list <MatchPattern>) : CG_expr
    {
      match (patterns) {
        | [l] => make_last_match (l)

        | [l, r] =>
          l.MakeMatchExpr (matched_expr, make_last_match (r))
                                   
        | patterns =>
          def literal_span = 
            - MatchPattern.Compare (List.Head (patterns), List.Last (patterns));

          if (literal_span > 8 && literal_span / List.Length (patterns) > 3) {
            def (l, m, r) = split_patterns (patterns);

            CE_if (match_descriptor.GetResultType (),
                   m.MakeLessThanCondition (matched_expr),
                   make_binary_search (l), make_binary_search (m :: r))
          }
          else
            make_switched_block (patterns)
      }          
    }


    /**
     * Handle the special case when some of the patterns have negative
     * literals and some positive -- it could disrupt the CE_switch emitter
     */
    private make_binary_search_top_level (patterns : list <MatchPattern>) : CG_expr
    {      
      def can_be_negative =
        match (List.Head (patterns).GetPattern ()) {
          | P_literal (L_int) => true
          | _ => false
        };

      if (can_be_negative) {        
        def (negative, positive) = split_patterns_by_sign (patterns);

        if (List.Length (negative) == 0) 
          make_binary_search (positive)
        else if (List.Length (positive) == 0) 
          make_binary_search (negative)
        else {
          def less_than_zero_expr = 
            CE_call (SystemType.Boolean, CE_opcode ("<.s"),
                    [matched_expr, CE_literal (L_int (0))]);

          CE_if (match_descriptor.GetResultType (), less_than_zero_expr,
                 make_binary_search (negative), make_binary_search (positive))
        }
      }
      else
        make_binary_search (patterns)
    }


    /* -- PRIVATE FIELDS --------------------------------------------------- */

    private mutable match_descriptor : MatchDescriptor;
    private mutable patterns : list <MatchPattern>;
    private mutable continuation : option <CG_expr>;
    private mutable matched_expr : CG_expr;
    private mutable binary_search_expr : CG_expr;
  }
  
  
  /**
   * The matching module
   */
  module CGmatch 
  {
    /**
     * Emit comparison code with specific literal.
     */
    internal emit_compare_with (compare_to : CG_expr, literal : Literal) : CG_expr
    {
      def method =
        match (literal) {
          | L_string =>
            // FIXME: move to SystemType (don't always lookup)
            CE_global_ref (SystemType.String.GetMethod ("op_Equality"))
          | L_decimal =>
            CE_global_ref (SystemType.String.GetMethod ("op_Equality"))
          | _ =>
            CE_opcode ("==") 
        };
      CE_call (SystemType.Boolean, method, 
               [compare_to, CE_literal (literal)])
    }

    
    /**
     * Creates an expression that will raise the MatchFailureException
     */
    private raise_match_failure_exception_expr (_match_descriptor : MatchDescriptor)
            : CG_expr
    {
      CE_raise (CE_call (CE_ctor_ref (InternalType.MatchFailureException_ctor), []))
    }


    /**
     * Creates a series of CE_if checking if any of the patterns matches.
     */
    private combine_patterns (match_descriptor : MatchDescriptor, 
                              continuation : option <CG_expr>,
                              patterns : list <MatchPattern>) : option <CG_expr>
    {             
      def match_failure_expr =
        raise_match_failure_exception_expr (match_descriptor);

      def walk_patterns (continuation : option <CG_expr>,
                         patterns : list <MatchPattern>) : option <CG_expr> {      
        match (patterns) {
          | [] => continuation
          | pattern :: rest =>            
            def continuation =
              match (continuation) {
                | Some (continuation) =>
                  pattern.MakeMatchExpr (match_descriptor.GetMatchedExpr (), 
                                         continuation)
                | None =>
                  pattern.MakeMatchExpr (match_descriptor.GetMatchedExpr (), 
                                         match_failure_expr)
              };
            walk_patterns (Some (continuation), rest)
        }
      };

      walk_patterns (continuation, List.Rev (patterns))
    }    
    
    
    /**
     * Matching over ordinal types (integers, chars, etc.)
     */
    cg_match_over_ordinals (match_over_type : System.Type, 
                            context : CTX, 
                            matched_expr : CG_expr, 
                            match_cases : list <Match_case>) : CG_expr
    {
      def match_descriptor = 
        MatchDescriptor (context, match_over_type, matched_expr, match_cases);

      def process_block (block : MatchBlock, continuation : option <CG_expr>)
          : CG_expr
      {
        def (literal_patterns, non_literal_patterns) = 
          List.Partition (block.GetMatchPatterns (), 
                          MatchPattern.IsOrdinalLiteral);

        def continuation = combine_patterns (match_descriptor, continuation, 
                                             non_literal_patterns);

        match (literal_patterns) {
          | [] => Option.UnSome (continuation)
          | _ =>
            def sorted_literal_patterns = 
              List.Sort (literal_patterns, MatchPattern.Compare);
  
            def binary_search = 
              MatchBinarySearch (match_descriptor, sorted_literal_patterns,
                                 continuation);

            binary_search.GetBinarySearchExpr ()
        }
      };
    
      def walk_blocks (blocks : list <MatchBlock>) : CG_expr {
        | [block] => process_block (block, None ())
          
        | block :: rest =>            
          def continuation = walk_blocks (rest);
          process_block (block, Some (continuation))
          
        | _ => Util.ice ("no blocks in match descriptor")
      };
    
      walk_blocks (match_descriptor.GetMatchBlocks ())
    }  


    /**
     * Matching over constant string
     */
    cg_match_over_strings (match_over_type : System.Type, 
                           context : CTX, 
                           matched_expr : CG_expr, 
                           match_cases : list <Match_case>) : CG_expr
    {
      def match_descriptor = 
        MatchDescriptor (context, match_over_type, matched_expr, match_cases);
    
      def process_block (block : MatchBlock, continuation : option <CG_expr>) : CG_expr {
        def (literal_patterns, non_literal_patterns) = 
          List.Partition (block.GetMatchPatterns (), MatchPattern.IsStringLiteral);

        def continuation = combine_patterns (match_descriptor, continuation, 
                                             non_literal_patterns);

        match (literal_patterns) {
          | [] => Option.UnSome (continuation)
          | _ =>
            def sorted_literal_patterns = 
              List.Sort (literal_patterns, MatchPattern.Compare);
  
            // FIXME
            Option.UnSome (combine_patterns (match_descriptor, continuation,
                                             sorted_literal_patterns))
        }
      };
    
      def walk_blocks (blocks : list <MatchBlock>) : CG_expr {
        match (blocks) {
          | [block] =>
            process_block (block, None ())
          | block :: rest =>            
            def continuation = walk_blocks (rest);
            process_block (block, Some (continuation))
          | _ => 
            Util.ice ("no blocks in match descriptor")
        }
      };
    
      walk_blocks (match_descriptor.GetMatchBlocks ())
    }
  
  
    cg_pattern (ctx : CTX, val : CG_expr, pats : list <Pattern * Expr>)
    : CG_expr * bool * CTX * list <CG_val>
    {
      mutable vals = SystemMap ();
      mutable rctx = ctx;
      mutable always_matches = true;
      
      def cgpat (val : CG_expr, pat : Pattern) : CG_expr {
        match (pat) {
          | P_underscore => CE_literal (L_bool (true))
          
          | P_as (subpat, d) =>
            if (d.in_closure) ()
            else
              match (vals.Find (d.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, d, CE_none ());
                  rctx = ctx;
                  vals = vals.Add (d.id, v);
              };
            def ass = CE_assign (local_ref (rctx, d),
                                 maybe_cast (ctx, cg_type (ctx, d.ty), val));
            match (subpat) {
              | P_cons =>
                match (cgpat (val, subpat)) {
                  | (CE_if (c, e_then, e_else)) as e =>
                    CE_if (e.ty, c, CE_sequence ([ass, e_then]), e_else)
                  | _ => Util.ice ()
                }

              | P_has_type (ti) =>
                CE_if (SystemType.Boolean, 
                       CE_has_type (val, ti.GetSystemType ()),
                       CE_sequence ([ass, CE_literal (L_bool (true))]),
                       CE_literal (L_bool (false)))

              | _ =>
                CE_sequence ([ass, cgpat (val, subpat)])
            }
            
          | P_tuple (args) =>
            def len = List.Length (args);
            def f (arg, acc)
              {
                def (pos, ex) = acc;
                def cond = cgpat (tuple_ref (CE_cast (val, tuple_type (len), true),
                                             pos, len), arg);
                (pos - 1, CE_if (SystemType.Boolean, cond, ex,
                                 CE_literal (L_bool (false))))
              };
            def ini = (len, CE_literal (L_bool (true)));
            def (_, ex) = List.FoldLeft (List.Rev (args), ini, f);
            ex

          | P_literal (lit) =>
            emit_compare_with (CE_cast (val, type_of (CE_literal (lit)), true), lit)
            
          | P_record (args) =>
            def val = CE_cast (val, cg_type (ctx, pat.ty), true);
            def f (np, ex) {
              def (name, pat) = np;
              def cond = cgpat (CE_field_ref (val, (name : IField).GetFieldInfo ()), pat);
              CE_if (SystemType.Boolean, cond, ex, CE_literal (L_bool (false)))
            };
            List.FoldLeft (List.Rev (args), CE_literal (L_bool (true)), f)
          
          | P_cons (n, a) =>
            always_matches = false;
            def tyname = n.GetSystemType ();
            def ex = CE_has_type (val, tyname);
            CE_if (SystemType.Boolean, ex, 
                    cgpat (CE_cast (val, tyname, true), a), 
                    CE_literal (L_bool (false)))

          | P_has_type (ti) =>
            always_matches = false;
            CE_has_type (val, ti.GetSystemType ())
        }
      };

      mutable global_always_matches = false;

      def loop (pats) {
        match (pats) {
          | (pat, expr) :: rest =>
            always_matches = true;
            def cond = cgpat (val, pat);
            def cond =
              match (expr) {
                | E_literal (L_bool (true)) => cond
                | _ =>
                  always_matches = false;
                  CE_if (SystemType.Boolean, cond, cg_expr (rctx, expr),
                         CE_literal (L_bool (false)))
              };
            global_always_matches = global_always_matches || always_matches;
            CE_if (SystemType.Boolean, cond, CE_literal (L_bool (true)),
                   loop (rest))
          | [] =>
            CE_literal (L_bool (false))
        }
      };

      def r = loop (pats);
      def collect_vals (_ : int, v : CG_val, acc : list <CG_val>) : list <CG_val> { 
        v :: acc };
      (r, global_always_matches, rctx, vals.Fold (collect_vals, []))
    }

    
    /**
     * Matching over arbitrary types
     */    
    cg_match_general (t : System.Type, ctx : CTX, val : CG_expr,
                      mcs : list <Match_case>) : CG_expr 
    {
      match (mcs) {
        | [] =>
          CE_raise (CE_call (CE_ctor_ref (InternalType.MatchFailureException_ctor), []))

        | m :: ms =>
          // FIXME: do something with always_matches
          def (cond, _always_matches, ctx', vals) = cg_pattern (ctx, val, m.patterns);
          def mklet (v : CG_val, acc : CG_expr) : CG_expr { CE_let (v, acc) };
          def then_part = cg_expr (ctx', m.body);
          def else_part = cg_match_general (t, ctx, val, ms);
          List.FoldLeft (vals, CE_if (t, cond, then_part, else_part), mklet)
      }
    }
    
    
    /**
     * Returns the constant object for a parameterless variant constructor
     */
    public get_constant_object (variant_tycon : Tycon) : option <FieldInfo>
    {
      def members = 
        variant_tycon.LookupMember ("_N_constant_object");
      
      match (members) {
        | [] => 
          None ()
        
        | [constant_object_field] =>
          def constant_object_field =
            (constant_object_field :> IField);
                        
          Some (constant_object_field.GetFieldInfo ())

        | _ =>
          Util.ice ("get_constant_object: expected zero or exactly one _N_constant_object fields")
      }          
    }
           

    /**
     * Matching over arbitrary types
     */
    cg_match_over_any_type (t : System.Type, ctx : CTX, val : CG_expr,
                            mcs : list <Match_case>) : CG_expr 
    {
      def match_collector = MatchCollector (t, ctx, mcs);
        
      if (match_collector.IsTopLevelMatchingOverCons ()) {
        def matcher_generator =
          MatchingOverVariantCons (ctx, val, match_collector);
          
        matcher_generator.GetMatcher ()
      }
      else
        cg_match_general (t, ctx, val, mcs)        
    }


    /**
     * Matching over booleans.
     */
    cg_match_over_booleans (t : System.Type, ctx : CTX, val : CG_expr,
                            mcs : list <Match_case>) : CG_expr
    {
      def type_of_bool = typeof(System.Boolean); // FIXME: how to reflect types here?
      
      mutable vals = SystemMap ();
      mutable rctx = ctx;

      mutable true_handled = false;
      mutable false_handled = false;
      mutable last_pattern_always_matches = false;

      def is_always_true (expr : Expr) : bool {
        match (expr) {
          | E_literal (L_bool (true)) => true
          | _ => false
        }    
      };

      def make_cond (patterns : list <Pattern * Expr>) : CG_expr {
        match (patterns) {        
          | (P_underscore, when_expr) :: _ when is_always_true (when_expr) =>
            last_pattern_always_matches = true;          
            CE_literal (L_bool (true))
        
          | (P_underscore, when_expr) :: rest =>
            CE_if (type_of_bool, cg_expr (rctx, when_expr),
                   CE_literal (L_bool (true)), make_cond (rest))

          | (P_literal (L_bool (literal)), when_expr) :: rest
            when is_always_true (when_expr)
            =>
            def literal_already_handled = if (literal) true_handled else false_handled;   
            when (literal_already_handled)
              Message.warning ("unreachable pattern in matching");
            
            if (literal) true_handled = true else false_handled = true;
                      
            if (true_handled && false_handled) {
              last_pattern_always_matches = true;          
              CE_literal (L_bool (true))
            }
            else {
              CE_if (type_of_bool,
                     emit_compare_with (val, L_bool (literal)),
                     CE_literal (L_bool (true)),
                     make_cond (rest))
            }

          | (P_literal (L_bool (literal)), when_expr) :: rest =>
            def literal_already_handled = if (literal) true_handled else false_handled;
            when (literal_already_handled)
              Message.warning ("unreachable pattern in matching");

            def opposite_handled = if (literal) false_handled else true_handled;

            if (opposite_handled) {
              CE_if (type_of_bool, cg_expr (rctx, when_expr),
                     CE_literal (L_bool (true)), make_cond (rest))          
            }
            else {
              def literal_eq_expr = emit_compare_with (val, L_bool (literal));

              CE_if (type_of_bool, literal_eq_expr, CE_literal (L_bool (true)), 
                CE_if (type_of_bool, cg_expr (rctx, when_expr), CE_literal (L_bool (true)), 
                  make_cond (rest)))
            }

          | (P_as (subpat, decl), _) :: rest =>
            if (decl.in_closure) ()
            else
              match (vals.Find (decl.id)) {
                | Some => ()
                | None =>
                  def (ctx, v) = store_local (rctx, decl, CE_none ());
                  rctx = ctx;
                  vals = vals.Add (decl.id, v);
              };
            def assign_expr = 
              CE_assign (local_ref (rctx, decl),
                         maybe_cast (rctx, cg_type (ctx, decl.ty), val));
            match (subpat) {
              | P_cons =>
                match (make_cond (rest)) {
                  | CE_if (cond_expr, then_expr, else_expr) =>
                    CE_if (type_of_bool, cond_expr,
                           CE_sequence ([assign_expr, then_expr]), else_expr)
                  | _ => Util.ice ()
                }
              | _ =>
                CE_sequence ([assign_expr, make_cond (rest)])
            }

          | [] => CE_literal (L_bool (false))

          | (P_tuple, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_tuple")
          | (P_record, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_record")
          | (P_cons, _) :: _ =>
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind P_cons")

          | _ :: _ => 
            Util.ice ("cg_match_over_booleans::make_cond: unexpected pattern kind")
        }      
      };

      def walk_match_cases (mcs : list <Match_case>) : CG_expr {
        match (mcs) {
          | [] =>
            CE_raise (CE_call (CE_ctor_ref (InternalType.MatchFailureException_ctor), []))

          | mc :: rest =>
            def cond = make_cond (mc.patterns);
            def body = cg_expr (rctx, mc.body);
            
            if (true_handled && false_handled || last_pattern_always_matches) {
              when (List.Length (rest) > 0) Message.warning ("unreachable match cases");
              body
            }
            else
              CE_if (cond, body, walk_match_cases (rest))
        }
      };

      // handle the special cases for the if/when/unless macros
      match (mcs) {
        | [then_case, else_case] =>
          match ((then_case.patterns, else_case.patterns)) {
            | ([(P_literal (L_bool (literal)), then_case_when_expr)],
               [(P_underscore, else_case_when_expr)]) 
              when is_always_true (then_case_when_expr) &&
                   is_always_true (else_case_when_expr) =>
                
              def literal_eq_expr =
                emit_compare_with (val, L_bool (literal));

              CE_if (t, literal_eq_expr, cg_expr (ctx, then_case.body),
                     cg_expr (ctx, else_case.body))         
            | _ => walk_match_cases (mcs)
          }
        | _ => walk_match_cases (mcs)
      }
    }


    /**
     * Matching
     */
    internal cg_match (t : System.Type, ctx : CTX, val : CG_expr,
                       mcs : list <Match_case>) : CG_expr
    {
      match (type_of (val).FullName) {
        | "System.Boolean" when Flags.constant_boolean_matching_opt => 
          cg_match_over_booleans (t, ctx, val, mcs)
        | "System.Char"
        | "System.Int32" when Flags.constant_ordinal_matching_opt => 
          cg_match_over_ordinals (t, ctx, val, mcs)
        | "System.String" when Flags.constant_string_matching_opt =>
          cg_match_over_strings (t, ctx, val, mcs)
        | _ => cg_match_over_any_type (t, ctx, val, mcs)
      }
    }
    
  } // end of the module

} // end of the namespace
