<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Frequently Asked Questions</title>
  <section id="intro">
    <title>Introduction</title>
    <body>
      <p>
        We'll try here to answer few questions about Nemerle.
      </p>
    </body>
  </section>
  <section id="why">
    <title>Why?</title>
    <body>
      <p>
        This section will answer questions about <b>reasons</b> behind
        Nemerle and choices made during development.
      </p>
    </body>
    <qa id="why-cil">
      <title>Platform</title>
      <question>
        Why use CLI/.NET?
      </question>
      <answer>
        <p>
          Mainly interop reasons. There are number of CLI libraries
          and bindings out there already. There is going to be more and
          more. For example GNOME 4 is going to be written in C#.
        </p>
        <p>
          Surely we'll loose WRT to compiled OCaml in terms of
          performance, at least until JIT's are made perfect, but it will
          be easily possible to write GNOME applet or Gimp plugin in 
          Nemerle.
        </p>
      </answer>
    </qa>
    <qa id="csharp">
      <title>Comparing to C#...</title>
      <question>
        Why use Nemerle and not C#?
      </question>
      <answer>
        <p>
          Nemerle is probably going to be used in some applications,
          where C# would be otherwise chosen. Why one would use Nemerle
          and not established, well described C#?
        </p>
        <p>
          In Nemerle you can do mostly everything you would have done in C#.
          ,,mostly'' refers to unsafe code and maybe some C-interfacing
          tricks. But of course you can do more:
        </p>
        <ul>
          <li>
            Program in functional style.  It is sometimes very handy,
            once you get used to it.  Functions are first class values
            so you can pass them to other functions easily (this is much
            like delegates but with better syntax and used more widely).
          </li>
          <li>
            Variants with pattern matching. This feature is very useful when 
            describing tree-like structures like arithmetic expressions or XML.
            This tends to be much shorter and clearer then in C#, and thanks
            to warning about non-exhaustive matching -- much safer.
          </li>
          <li>
            Language extensions. This feature allows skilled programmers to extend
            Nemerle itself, and saves everyone typing the same methods for the Nth
            time for the Nth class.
          </li>
          <li>
            Nemerle saves you typing using type inference:
            instead of:
<code>
Foo.Bar_long_name&lt;Baz.Qux> x = 
  new Foo.Bar_long_name&lt;Baz.Qux> (10)
</code> 
            you write:
<code>
def x = Foo.Bar_long_name (10)
</code>
          </li>
        </ul>
      </answer>
    </qa>
    <qa id="why-rtti">
      <title>Dynamic types</title>
      <question>
        Why dynamic types? Doesn't they impact performance?
      </question>
      <answer>
        <p>
          Probably yes. But dynamic types are inherent part of CLI so
          there is no <b>performance</b> reason to ban them (we would
          have to pay performance cost anyway). Additionally dynamic
          types are useful in some contexts, like dynamic loading of
          classes (or rather dynamic construction of objects).
        </p>
        <p>
          For example
          what static type would you give to polymorphic de-serialization
          function? In OCaml it has type <tt>in_channel -> 'a</tt> which
          is obviously wrong.
        </p>
        <p>
          Of course there are several <a 
          ref="http://www.catb.org/~esr/jargon/html/R/religious-issues.html">
          religious issues</a> about dynamic typing. Our answer is very simple:
          you don't need dynamic types -- don't use them.
        </p>
      </answer>
    </qa>
    <qa id="why-ext">
      <title>Language extensions</title>
      <question>
        What language extensions are good for? Programmers are writing <i>in
        languages</i> not <i>writing languages</i>.
      </question>
      <answer>
        <p>
          That's not true :-) Everyone programming <meta>X</meta>
          had an idea how to change this funny little annoying thing
          in <meta>X</meta>. 
        </p>
        <p>
          Of course not everybody is going to do it, but we're going to
          provide library of useful language extensions along with Nemerle.
          For example extension to generate various methods that can be
          automagically generated from structure of type, like:
        </p>
        <ul>
          <li>Serialization/deserialization (for example to/from XML)</li>
          <li>Good hashing functions</li>
          <li>Clever equality predicates that not fall into cycles</li>
          <li>Types with strong sharing</li>
        </ul>
        <p>
          It is also possible to define other function that we're unable
          to encode in our type-system. Ordinary example is C-like safe
          <tt>printf</tt> function.
        </p>
        <p>
          We are also considering possibility of extending language
          syntax. However it is quite difficult to do this <a 
          ref="http://www.catb.org/~esr/jargon/html/entry/Right-Thing.html">
          The Right Way</a>.
        </p>
      </answer>
    </qa>
  </section>
  <section id="syntax-questions">
    <title>Syntax questions</title>
    <body>
      <p>
        This section will try to answer few questions about Nemerle syntax,
        and sometimes semantics behind it.
      </p>
    </body>
    <qa id="call-parens">
      <title>Function call requires <tt>()</tt></title>
      <question>
        Why does function call require <tt>()</tt>? <tt>f x</tt> looks
        much better then <tt>f(x)</tt>, and in ML you can use both forms.
      </question>
      <answer>
        <p>
          Function call requires <tt>()</tt>. It looks like this:
        </p>
<code>
f (x, y, z);
f (x);
f ();
</code>
        <p>
          Form without <tt>()</tt> (i.e. <tt>f x</tt>) is not allowed.
        </p>
        <p>
          There are some good reasons for that. The main one is that it 
          allows for better overloading resolution (simply when looking
          at <tt>f (x, y)</tt> you know you need function with 2 parameters,
          and it's not partial application). Overloading is likely
          to occur quite frequently in CLI. Another is that following code
          will give you parse error, not weird typing error:
        </p>
<code>
f (x)  (* forgot ';' here *)
g (x)
</code>
        <p>
          Using this syntax it is not possible to do partial application,
          but see <a ref="#partial-application">below</a>.
        </p>
      </answer>
    </qa>
    <qa id="null">
      <title><tt>null</tt> value</title>
      <question>
        There is special <tt>'a option</tt> type in ML, which can be
        <tt>Some x</tt> or <tt>None</tt> and is used where pointer that
        can be null would have been used in C-like languages.  So what
        is <tt>null</tt> value good for? You can have <tt>option</tt>
        type in Nemerle too.
      </question>
      <answer>
        <p>
          Of course you can, you even have it in standard library.
          It's suggested way of handling this matter. 
        </p>
        <p>
          <b>But</b> think about external functions that can
          return references.  By CLI standards they can also
          return <tt>null</tt>. So it would require to have
          all functions returning <tt>foo</tt> in CLI to return
          <tt>option (foo)</tt> in Nemerle, and you would end up using
          <tt>val_of</tt> function over and over again, resulting in
          <tt>None_value</tt> (or something) exceptions instead of
          <tt>Null_pointer_exception</tt>.
        </p>
        <p>
          This is why we have <tt>null</tt> in language. In fact it
          is quite common in Nemerle to have feature just for interop
          reasons.
        </p>
      </answer>
    </qa>
    <qa id="sequence">
      <title>Sequence in <tt>{}</tt></title>
      <question>
        Why sequence needs to be enclosed in <tt>{}</tt>? Wouldn't it
        be possible to assign some priority to <tt>;</tt> operator
        and treat this like expression?
      </question>
      <answer>
        <p>
          It would be possible, but it's quite error-prone and misleading.
          In simple examples it's OK:
        </p>
<code>
let x = 3 in g x; h x       (* Caml *)
{ def x = 3; g (x); h (x) }     (* Nemerle *)
</code>
        <p>
          But consider following snippet of Caml:
        </p>
<code>
  (* Correct *)
  if x > y then
    let x = 3 in
    f x;
    g x
  else
    h ()

  (* Parse error *)
  if x > y then
    f 3;
    g 3
  else 
    h ()
</code>
        <p>
          Thanks to <tt>;</tt> being used only in clear context it is not
          possible in Nemerle.
        </p>
        <p>
          This issue is resolved in similar manner in OCaml Revised Syntax.
        </p>
      </answer>
    </qa>
    <qa id="if-else">
      <title><tt>if</tt> requires <tt>else</tt></title>
      <question>
        Why does <tt>if</tt> require <tt>else</tt>? In OCaml one doesn't
        need to write <tt>else ()</tt>.
      </question>
      <answer>
        <p>
          To avoid confusing grammar ambiguities. Beside this
          is <b>functional</b> language, what is <tt>if</tt>
          <b>expression</b> without <tt>else</tt>?
        </p>
        <p>
          You can also use <tt>when</tt> and <tt>unless</tt> macros for
          <tt>if</tt> without <tt>else</tt> or <tt>else</tt> without
          <tt>if</tt>.
        </p>
      </answer>
    </qa>
  </section>
  <section id="where">
    <title>Where did <meta>X</meta> go?</title>
    <body>
      <p>
        Few explanations about how to do various things in Nemerle.
      </p>
    </body>
    <qa id="partial-application">
      <title>Partial application</title>
      <question>
        Where is partial function application?
      </question>
      <answer>
        <p>
          You simply need to use so called eta-long form:
        </p>
<code>
def f (x, y) { ... };
def g (x) { fun (y) { f (x, y) } };

def plus5 (x) { fun (x) { 5 + x } };
</code>
        <p>
          This prevents partial application bugs, which would be common
          in presence of overloading.
        </p>
      </answer>
    </qa>
  </section>
  
    <!-- 
    <qa id="">
      <title></title>
      <question>
      </question>
      <answer>
        <p>
        </p>
      </answer>
    </qa>
  <section id="">
    <title></title>
    <body>
      <p>
      </p>
    </body>
  </section>
  -->
</document>

<!-- vim: expandtab sw=2
  -->
