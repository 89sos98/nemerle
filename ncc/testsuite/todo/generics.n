// THIS CODE WORKS! :-)

class A ['a] {
  public mutable f : 'a;
  
  public take () : 'a {
    f
  }

// we need Boxing to be emitted by typer  
//  public takeobj () : object {
//    f
//  }
  
  public put (x : 'a) : void {
    _ = A(1);
    f = x;
  }
  
  public this (a : 'a) {
    f = a;
  }
  
  public this () { } 
}

module M {
   obj : A [string];

   this () {  
     obj = A ();
     obj.put ("Ala");
   }

   collections_generic () : void
   {
      def x = typeof (System.Collections.Generic.List [int]);
      System.Console.WriteLine (x.ToString ());
      def x = System.Collections.Generic.List ();
      x.Add (1);
      assert (x[0] == 1);

      //def dict = System.Collections.Generic.Dictionary ();
      //dict.Add (1, "Nemerle");   // IComparable`1 vs IComparable
      //assert (dict [0] == "Nemerle");
   }
   
   Main () : void {
      def x = A(1);
      x.put (2);
      assert (x.f == 2);
      x.f = 2;
      def y = x.take ();
      assert (y == 2);
      assert (obj.take () == "Ala");
      _ = obj.take ();
      collections_generic ();
   }
}

class B ['a] {
  f : 'a;
//  my : B ['a]; // bug in mono?

  public me_init (x : B ['a]) : void {
  }

  protected mutable fld : 'a;
//  public static st_fld : 'a; // Nemerle currently forbids it :/

  protected this () {  }
  protected this (x : 'a) {
      f = x;
  }
}


class C : B [int] {
 
  this () {
    base (1);
    base.fld = 2;
   // fld = 2; // problem with 'base' having 'this' type
  }
}


class D ['b] : B ['b] {
  public this (x : 'b) { base (x) }
}

  
variant genlist ['a] {
    | ConsA { x : int; tl : string; }
    | ConsB { x : 'a; tl : string; }
    | ConsC { x : 'a; tl : genlist [int]; }            
//    | Cons { x : 'a; tl : genlist ['a]; }  // broken broken broken
//  | Nil
}


// THIS CODE DOESN'T WORK

/* generic methods would benefit from removing CGMethod
class B {
  public genmeth ['a] (x : 'a) : 'a { x }  
}
*/

