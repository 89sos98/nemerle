<?xml version='1.0' encoding='UTF-8' ?>
<!--
  Copyright (c) 2003, 2004 The University of Wroclaw.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the University may not be used to endorse or promote
        products derived from this software without specific prior
        written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
  NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<document>
  <title>Nemerle type-safe macros</title>
  <section id="intro">
    <title>Intro</title>    
    <body>
      <p>
        You can think about macros as system of compile-time transformations 
        and automatic generation of code with regard to some rules. 
        It can be used either to automate manipulations performed on similar
        data-types and fragments of code, add syntax shorcuts to language,
        optimize and make some computations safer by moving them from runtime
        to compile-time.
      </p>
      <p>
        Idea of making simple inline operations on code comes from preprocessor
        macros,	which many languages (especially C, C++) contained since early 
        times of compiler design. We are following them in direction of much more
	powerful, and at the same time more secure (type-safe), solutions
	like Haskell Template Meta-programming.
      </p>
    </body>
  </section>
  <section id="features">
    <title>Key features</title>
      <body>
        <ul>
          <li>builtin ability of extending language syntax</li>
	  <li>creating functions, whose amount and type of arguments depend
	    on each other (like C printf) with full typechecking during
            compile-time</li>
	  <li>algorithmic generation of code, which may be dependent on
	    external factors, like XML files, script programs, databases or 
            even remote web sites </li>
	  <li>completing datatypes with automatically created methods for
            performing arbitrary operations, e.g. reading datasets from file,
	    sending them through network or storing in SQL database</li>
	  <li>using context of compilation provided by compiler's internal
	    structures, like line numbers (for error reporting), names of
	    processed type, function, class or namespace, accessing
            datatype definitions by name</li>
	</ul>
    </body>
  </section>
  <section id="description">
    <title>What exactly macro is?</title>
      <body>
        <p>
	  Basically every macro is a function, which takes some fragment
	  of code as parameter(s) and returns some other code. On the highest 
	  level it doesn't matter if they are type definitions, function calls 
	  or just a sequence of assignments. Most important fact is that they are 
	  not common objects (e.g. instances of defined types, like integer 
	  numbers), but their internal representation in compiler (i.e. syntax 
	  tree).
	</p>
	<p>
	  Those functions are defined in program just like any other functions.
	  They are written in common Nemerle syntax and the only difference
	  is the structure of data they operate on (we provide special ways
	  to parse and generate syntax trees).
	</p>
	<p>
	  Macros, once defined, can be used to process some part of the code.
	  It's done by calling them with block(s) of code as parameters. 
	  This operation is in most cases indistinguishable from common function
	  calls, so programmer using macros won't be confused by unknown
	  syntax. Main concept of our design is to make usage of macros as much 
          transparent as possible. From the user point of view, it is not 
          important if particular parameters are passed to ordinary function 
          or one, which would process them at compile-time and insert some new 
          code in their place.
	</p>
      </body>
  </section>
  <section id="defining">
    <title>Defining new macro</title>
      <body>
        <p>
          Writing a macro is as simple as writing common function, except
          it is proceeded by keyword <tt>macro</tt>. This will make compiler
          know about how to use defined method (i.e. run it at compile-time
          when it is called). 
        </p>
        <p>
          Macros can take zero (if we just want to generate new code)
          or more parameters. They are all some of elements of language 
          grammar, so they have type limited to the set of defined
          syntax objects. The same holds for return value of macro.
        </p>
        <p>
          Example:
        </p>  
<code>
macro doNothing () : expr
{
  &lt;[ () ]&gt;
}
</code>
        <p>
          This example macro doesn't take any parameters, so it's used in 
          code by simply writing <tt>doNothing();</tt>. It makes nothing
          special, just inserts '<tt>()</tt>' (return value of its
          execution) in place where it's used.
        </p>
      </body>
  </section>      
  <section id="syntax_trees">
    <title>Operating on syntax trees</title>
      <body>
        <p>
          The example above shows simplest macro, but it also 
          introduced some new syntax used only in writing macros.
          We've written here <tt>&lt;[ ... ]&gt;</tt> constructor to
          build syntax tree of expression '<tt>()</tt>'.
        </p>
        <subsection id="quotation">
          <title>Quotation operator</title>
            <body>
              <p>
                <tt>&lt;[ ... ]&gt;</tt> is used to both construction and 
                decomposition of syntax trees. Those operations are similar to
                quotation of code. Simply, everything which is written inside 
                <tt>&lt;[ ... ]&gt;</tt>, corresponds to its own syntax tree. 
                It can be any valid Nemerle code, so programmer doesn't have to 
                learn internal representation of syntax trees in compiler.
             </p>
<code>
macro fold_one_plus_one (e : expr) : expr
{                   
  match (e) {
    | &lt;[ 1 + 1 ]&gt; =&gt;
        &lt;[ 2 ]&gt;
    | _ =&gt; expr
  }
}
</code>
              <p>
                Quotation alone allows using only constant expressions, which
                is insufficient for most tasks. In next section we introduce
                rest of macros' syntax to operate on general syntax trees.
              </p>
            </body>
        </subsection>
        <subsection id="spliced">
          <title>Matching subexpressions</title>
            <body>
              <p>
                When we want to decompose some large code (or more precisely, 
                its syntax tree), we must bind its smaller parts to variables.
                Then we can process them recursively or just use them in 
                arbitrary way to construct the result.
              </p>
              <p>
                We can operate on entire subexpressions by writing 
                <tt>$( ... )</tt> or <tt>$ID</tt> inside quotation operator 
                <tt>&lt;[ ... ]&gt;</tt>. This means binding <tt>ID</tt>
                or interior of parenthesized expression to part of syntax
                tree described by corresponding quotation.
              </p>
<code>
macro for (init, cond, change, body)
{
  &lt;[ { $init;
       def loop () : void {
         if ($cond) { $body; $change; _N_forloop() } 
         else ()
       };
       loop ();
     }
  ]&gt;
}
</code>
              <p>
                The above macro defines function <tt>for</tt>, which is
                similar to loop known from C. It can be used like this
              </p>
<code>
for (mutable i &lt;- 0; i &lt; 10; i &lt;- i + 1, printf ("%d", i))
</code>
              <p>
                Later we show how to extend language syntax to make syntax
                of <tt>for</tt> exactly the same like in C.
              </p>
            </body>
        </subsection>
        <subsection id="base_splicing">
          <title>Base elements of grammar</title>
            <body>
              <p>
                Sometimes quoted expressions have literals inside of them
                (like strings, integers, etc.) and we want to operate on
                their value, not on their syntax trees. It's possible, 
                because they are constant expressions and their runtime
                value is known during compie-time. 
              </p>
              <p>
                For example we want to generate constant number
                precomputed in compile-time by some function 
                <tt>complex : int -> int</tt>. 
              </p>
<code>
macro precompute ( n : int )
{                   
  &lt;[ $(comlex (n) : int) ]&gt;
}
</code>
              <p>
                Here we see some extension to splicing syntax where we 
                create syntax tree of integer literal from known value.
                It is done by adding <tt>: int</tt> inside of 
                <tt>$(...)</tt> construct. One can think about it as of
                enforcing type of spliced expression to literal (similar
                to common Nemerle type enforcement), but in the matter
                of fact something more is happening here - real value
                is lifted to its representation as syntax tree of literal.
              </p>
              <p>
                Other types of literals are made in the same way. This
                notation can be used also in pattern matching. We can
                match constant values in expressions this way.
              </p>
              <p>
                There is similar schema for splicing and matching 
                variables of given name. <tt>$(v : var)</tt> denotes
                variable, whose name is equal to value of <tt>v</tt> 
                (which is of type <tt>string</tt>).  
              </p>

            </body>
        </subsection>

    </body>
  </section>
</document>
