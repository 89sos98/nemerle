/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;
using Nemerle.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

using PT = Nemerle.Compiler.Parsetree;

namespace Nemerle.Compiler {
module ExhaustivenessChecker {
  
  variant Range {
    | Omega        // _, x, everything
    | Non         // nothing
    | AnyExcept { lits : list [Nemerle.Compiler.Literal]; }
    | Liter { l : Nemerle.Compiler.Literal; }
    | Variant_option { ti : TypeInfo; range : Range; }
    | Enum { fld : IField; }
    | Tuple { ranges : list [Range]; }
    | Record { ranges : list [IMember * Range]; }
    
    | Or { ranges : list [Range]; }
  }

  range_of_pattern (p : Pattern) : Range {
    match (p) {
      | Pattern.Wildcard => Range.Omega ()
      | Pattern.As (p, _) => range_of_pattern (p)
      | Pattern.Tuple (args) => Range.Tuple (List.Map (args, range_of_pattern))
      | Pattern.Record (args) =>
        Range.Record (List.Map (args, fun (n, p) { (n, range_of_pattern (p)) }))
      | Pattern.Application (ti, pat) =>
        Range.Variant_option (ti, range_of_pattern (pat))
      | Pattern.Enum (f, _) => Range.Enum (f)
      | Pattern.Literal (l) => Range.Liter (l)
      | Pattern.HasType => Range.Non ()
      | Pattern.Error => Range.Omega ()
    }
  }

  // debug routine
  string_of_range (r : Range) : string {
    match (r) {
      | Range.Omega => "_"
      | Range.AnyExcept ([Literal.Bool (true)]) => "false"
      | Range.AnyExcept ([Literal.Bool (false)]) => "true"
      | Range.AnyExcept (lst) => "(anything except " + lst.ToString () + ")"
      | Range.Variant_option (ti, r) =>
        ti.FullName + " (" + string_of_range (r) + ")"
      | Range.Enum (f) =>
        f.Name
      | Range.Tuple (ranges) =>
        def concat (r, acc) {
          if (acc == "") string_of_range (r)
          else
            acc + ", " + string_of_range (r)
        };
        "(" + List.FoldLeft (ranges, "", concat) + ")"
        
      | Range.Record (ranges) =>
        def concat (x, acc) {
          def (f, r) = x;
          def r' = f.Name + " = " + string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.FoldLeft (ranges, "", concat) + " }"
        
      | Range.Non => "[[None]]"
      | Range.Liter => "[[Literal]]"
      
      | Range.Or (ranges) =>
        def concat (r : Range, acc : string) : string {
          if (acc == "") string_of_range (r)
          else
            acc + " | " + string_of_range (r)
        };
        "[ " + List.FoldLeft (ranges, "", concat) + " ]"
    }
  }

  // for user error messages, we just present first branch of Range.Or
  user_string_of_range (r : Range) : string {
    match (r) {
      | Range.Omega => "_"
      | Range.AnyExcept ([Literal.Bool (true)]) => "false"
      | Range.AnyExcept ([Literal.Bool (false)]) => "true"
      | Range.AnyExcept (lst) => "(anything except " + lst.ToString () + ")"
      | Range.Variant_option (ti, r) =>
        ti.FullName + " (" + user_string_of_range (r) + ")"
      | Range.Enum (f) =>
        f.Name
      | Range.Tuple (ranges) =>
        def concat (r, acc) {
          if (acc == "") user_string_of_range (r)
          else
            acc + ", " + user_string_of_range (r)
        };
        "(" + List.FoldLeft (ranges, "", concat) + ")"
        
      | Range.Record (ranges) =>
        def concat (x, acc) {
          def (f, r) = x;
          def r' = f.Name + " = " + user_string_of_range (r);
          if (acc == "") r'
          else
            acc + "; " + r'
        };
        "{ " + List.FoldLeft (ranges, "", concat) + " }"
        
      | Range.Non => Util.ice ()
      | Range.Liter => Util.ice ()
      | Range.Or ([]) => Util.ice ()
      
      | Range.Or (x :: _) => user_string_of_range (x)
    }
  }

  simplify_range (r : Range) : Range {
  //  Message.Debug ("simpl: " + string_of_range (r) );
    def aint_none (r : Range) : bool {
      match (r) {
        | Range.Non => false
        | _ => true
      }
    };
    match (r) {
      | Range.Or ([]) => Range.Non ()
      | Range.Or (lst) =>
        match (List.Filter (lst, aint_none)) {
          | [] => Range.Non ()
          | [x] => x
          | l => Range.Or (l)
        }
      | Range.AnyExcept (lst) =>
        if (List.Exists (lst, fun (x) { x matches Literal.Bool (true) }) &&
            List.Exists (lst, fun (x) { x matches Literal.Bool (false) }))
          Range.Non ()
        else if (List.Exists (lst, fun (x) { x matches Literal.Null }))
          Range.AnyExcept (Literal.Null () :: 
                           List.Filter (lst, fun (x) { ! (x matches Literal.Null) }))
        else
          r
      | Range.Variant_option (_, Range.Non) => Range.Non ()
      | Range.Tuple (ranges) =>
        if (List.ForAll (ranges, aint_none)) 
          r
        else
          Range.Non ()
      | Range.Record (ranges) =>
        def is_named_none (_, x) {
          match (x) {
            | Range.Non => true
            | _ => false
          }
        };
        if (List.Exists (ranges, is_named_none))
          Range.Non ()
        else
          r
      | x => x 
    }
  }
    
  subtract (r1 : Range, r2 : Range) : bool * Range {
    mutable did_something = false;

    // subtract new_r from cur_r
    def do_sub (cur_r : Range, new_r : Range) : Range {
    // Message.Debug ("subx: " + string_of_range (cur_r) + "     " + string_of_range (new_r) );
      match ((cur_r, new_r)) {
        | (Range.Non, _) => Range.Non ()

        // Range.Non is generated from (x : foo), so ...
        | (x, Range.Non) =>
          did_something = true;
          x

        | (_, Range.Omega) => 
          did_something = true; 
          Range.Non ()
          
        | (Range.Omega, Range.Liter (l)) =>
          did_something = true;
          Range.AnyExcept ([l])

        | (Range.Or (ranges), _) =>
          Range.Or (List.Map (ranges, fun (r) { sub (r, new_r) }))

        | (Range.AnyExcept (lits), Range.Liter (l)) =>
          // FIXME: check if l is in lits
          did_something = true;
          Range.AnyExcept (l :: lits)

        | (Range.AnyExcept, Range.Enum) =>
          did_something = true;
          cur_r

        | (Range.AnyExcept ([Literal.Null]), _) => did_something = true; cur_r
          
        | (Range.AnyExcept as a, s) =>          
          Util.ice ($ "subtract something strange ($s) from AnyExcept $(string_of_range (a))")

        | (Range.Variant_option (ti1, r1), Range.Variant_option (ti2, r2)) =>
          if (ti1.Equals (ti2))
            Range.Variant_option (ti1, sub (r1, r2))
          else
            cur_r

        | (Range.Enum (f1), Range.Enum (f2)) =>
          //Message.Debug ($ "$f1 equals $f2");
          if (f1.Equals (f2)) {
            //Message.Debug ("yes");
            did_something = true;
            Range.Non ()
          } else cur_r

        | (Range.Enum, Range.Liter) =>
          Message.Warning ("enums without System.Flag attribute cannot be matched with arbitrary values");
          did_something = true;
          cur_r
          
        | (Range.Omega, Range.Enum (f)) =>
          def t = f.DeclaringType;
          //Message.Debug ($ "_ - enum $f ($t)");
          if (t.HasAttribute (InternalType.FlagsAttribute_tc)) {
            //Message.Debug ("did");
            did_something = true;
            Range.Omega ()
          } else {
            def ranges =
              List.FoldLeft (t.GetFields (BindingFlags.Static %| BindingFlags.Public), [],
                             fun (fld : IField, acc) {
                               if (fld.IsLiteral && fld.DeclaringType.Equals (t))
                                 Range.Enum (fld) :: acc
                               else acc
                            });
            sub (Range.Or (ranges), new_r)
          }
          
        | (cur, Range.Variant_option (ti, _)) =>
          def make_range (ti : TypeInfo) : Range {
            Range.Variant_option (ti, cur)
          };
          match (Option.UnSome (ti.SuperClass ()).GetTydecl ()) {
            | TypeDeclaration.Variant (opts) =>
              sub (Range.Or (List.Map (opts, make_range)), new_r)
            | _ =>
              Util.ice ("not variant")
          }

        | (Range.Variant_option, Range.Record) => Util.ice ("FIXME")
       
        | (Range.Omega, Range.Tuple (ranges)) =>
          def args = List.RevMap (ranges, fun (_) { Range.Omega () });
          sub (Range.Tuple (args), new_r)
          
        | (Range.Tuple (r1), Range.Tuple (r2)) =>
          mutable did = true;
          def make_sub (r1 : Range, r2 : Range) : Range {
            def (d, r) = subtract (r1, r2);
            if (d) () else did = false;
            r
          };
          def results = List.Map2 (r1, r2, make_sub);
          if (did) {
            did_something = true;

            mutable output = [];
            // r1 - r2 = r3
            def dosub (pref : list [Range], 
                       cur : list [Range], 
                       after_sub : list [Range]) : void {
              match ((cur, after_sub)) {
                | (x :: xs, y :: ys) => 
                  def args = List.RevAppend (pref, (y :: xs));
                  output = simplify_range (Range.Tuple (args)) :: output;
                  dosub (x :: pref, xs, ys)
                | ([], []) => ()
                | _ => Util.ice ()
              }
            };
            dosub ([], r1, results);
            Range.Or (output)
          } else cur_r
        
        | (Range.Omega, Range.Record) =>
          sub (Range.Record ([]), new_r)

        | (Range.Record (r1), Range.Record (r2)) =>
//          Message.Debug ("ransub: " + string_of_range (cur_r) + "   " + string_of_range (new_r));
          mutable all_did = true;

          def loop (r2, acc) {
            def (name, range) = r2;
            
            def loop2 (acc, l) {
              match (l) {
                | (f, r) :: xs =>
                  if (name.GetId () == f.GetId ()) {
                    def (did, res) = subtract (r, range);
                    if (did) () else all_did = false;
                    List.RevAppend (xs, (f, res) :: acc)
                  } else
                    loop2 ((f, r) :: acc, xs)
                | [] =>
                  (name, sub (Range.Omega (), range)) :: acc
              }
            };

            simplify_range (Range.Record (loop2 ([], r1))) :: acc
          };

          def r = Range.Or (List.FoldLeft (r2, [], loop));

          if (all_did) {
            did_something = true;
            r
          } else cur_r

        | (Range.Variant_option, Range.Tuple) => assert (false)
        | (Range.Variant_option, Range.Liter (Literal.Null)) => did_something = true; cur_r
        | (Range.Variant_option, Range.Liter) => assert (false)
        | (Range.Tuple, Range.Liter) => assert (false)
        | (Range.Record, Range.Liter) => assert (false)
        | (Range.Record, Range.Tuple) => assert (false)
        | (Range.Tuple, Range.Record) => assert (false)
        | (Range.Liter, _) => assert (false)
        | (_, Range.AnyExcept) => assert (false)
        | (_, Range.Or) => assert (false)
        | (Range.Enum, _) =>
          Message.Debug ("enum - " + string_of_range (new_r));
          assert (false)
        | (_, Range.Enum) => assert (false)
      }
    }

    and sub (r1 : Range, r2 : Range) : Range {
      simplify_range (do_sub (r1, r2))
    };

    def ret = sub (r1, r2);
//    Message.Debug ("sub: " + string_of_range (r1) + " - " + string_of_range (r2) + " = " + string_of_range (ret));

    (did_something, ret)
  }

  
  /**
   * Give warnings about ``pattern matching not exhaustive'' and 
   * ``unused match clause''.
   */
  public check_matching (cases : list [Match_case]) : void
  {
    def loop (m : Match_case, acc : Range) : Range
    {
      def loop2 (patex : Pattern * TExpr, acc : Range) : Range
      {
        def (pat, ex) = patex;
        def (did_something, ret) = subtract (acc, range_of_pattern (pat));

        unless (did_something)
          Message.Warning (pat.loc, "this match clause is unused");

        match (ex) {
          | TExpr.Literal (Literal.Bool (true)) => ret
          | _ => acc
        }
      };

      List.FoldLeft (m.patterns, acc, loop2)
    }

    def remaining = List.FoldLeft (cases, Range.Omega (), loop);
    match (remaining) {
      | Range.Non => ()
      | r =>
        Message.Warning ("this matching is not exhaustive, example unmatched value:");
        Message.Warning (user_string_of_range (r))
    }
  }

}
}
