using SC = System.Console;
using System.Text;
using System.Text.RegularExpressions.Regex;
using Nemerle.Text;
using Nemerle.Utility.NString;
using Nemerle.Collections.List;
using Nemerle.Compiler.Parsetree;

module MainClass
{
  Main () : void {
    def print_help () : void  {
      SC.WriteLine ("help\t-\tprint this help");
      SC.WriteLine ("ref\t-\tlink specified assembly\n"
                    "\t\t(ex. ref Nemerle.dll, Nemerle.Compiler.dll)");
      SC.WriteLine ("using\t-\tuse specified namespaces and/or aliases\n"
                    "\t\t(ex. using System, SC=System.Console)");
    }

    def print_welcome () : void {
      SC.WriteLine ("Welcome to Nemerle interpreter.\n");
      SC.WriteLine ("Please enter expressions appended with \";;\".");
      SC.WriteLine ("Built-in commands must be entered on a separate line,");
      SC.WriteLine ("their list is available via \"help;;\"\n");
    }
   
    print_welcome ();

    def e = Evaluator ();

    def readinput (refr : list [string], ns : list [option [string] * string],
                   code : string, prompt : string) : void {
      SC.Write (prompt);
      def line = SC.ReadLine ();
      match (line) {
        | null => ()
        | _ => 
          regexp match (line) {
            | @"^\s*$" => readinput (refr, ns, code, prompt)
            | @"^\s*help\s*(\(\))*[;\s]*;;\s*$" => 
              print_help ();
              readinput (refr, ns, code, "- ")
            | @"^\s*using\s+(?<n>(\w+\s*=\s*){0,1}\w+(\.\w+)*(\s*,\s*(\w+\s*=\s*){0,1}\w+(\.\w+)*)*)[;\s]*;;\s*$" =>
              def tmpns = Split (Replace (n, @"\s", ""), array [',']);
	      def newns = FoldLeft (tmpns, [], fun (x, acc) {
		match (Split (x, array ['='])) {
                  | [h] => (None (), h) :: acc
		  | [h, t] => (Some (h), t) :: acc
		  | _ => assert (false)
		}
	      });
              SC.WriteLine ("Now using " + n);
              readinput (refr, newns + ns, code, "- ")
            | @"^\s*ref\s+(?<r>\w+(\.\w+)*(\s*,\s*(\w+(\.\w+)*))*)[;\s]*;;\s*$" =>
              SC.WriteLine ("Added " + r + " for linking.");
              readinput (Split (Replace (r, @"\s", ""), array [',']) +
                         refr, ns, code, "- ")
            | _ =>  { 
              def l = line.TrimEnd ();
              if (l.EndsWith (";;")) {
                try { 
                  def (vals, ntms) = e.Eval (refr, ns, code + 
		                            l.TrimEnd (array [';',' ','\t']));
		  Iter2 (vals, ntms, fun (x : object, y) {
                    def (y1, y2, y3) = y;
		    match ((y1, y3)) {
/*		      | (false, PExpr.Void) => SC.WriteLine ($"def $y2 : $y3")
		      | (_, PExpr.Void) => SC.WriteLine ($"mutable $y2 : $y3")
		      | (false, _) => SC.WriteLine ($"def $y2 = $x : $y3")
		      | _ => SC.WriteLine ($"mutable $y2 = $x : $y3")       */
		      | (false, PExpr.Void) => SC.WriteLine ("def " + y2 + " : " + y3.ToString ())
		      | (_, PExpr.Void) => SC.WriteLine ("mutable " + y2 + " : " + y3.ToString ())
		      | (false, _) => SC.WriteLine ("def " + y2 + " = " + x.ToString () + " : " + y3.ToString ())
		      | _ => SC.WriteLine ("mutable " + y2 + " = " + x.ToString () + " : " + y3.ToString ())       
		    }
		  })
                } 
                catch {
                  | e is System.Exception =>
                    unless (Nemerle.Compiler.Message.SeenError) {
                      SC.WriteLine (e.Message + e.StackTrace);
                      SC.WriteLine (e.ToString ())
                    }
                } 
                readinput (refr, ns, "", "- "); 
              }
              else { 
                readinput (refr, ns, code + line + " ", "= "); 
              }
            }
          }
      }
    }

    readinput ([], [], "", "- ");
  }
}

