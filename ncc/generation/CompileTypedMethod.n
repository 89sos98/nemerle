/*
 * Copyright (c) 2003-2005 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using Nemerle.Collections;

using Nemerle.Compiler.Typedtree;
using Nemerle.Compiler.CompileTypedTree;

using System.Reflection;

namespace Nemerle.Compiler {

module CompileTypedMethod
{
  internal tuple_type (len : int) : System.Type
  {
    InternalType.GetTupleType (len).SystemType
  }
  
  internal function_type (len : int) : System.Type
  {
    InternalType.GetFunctionType (len).SystemType
  }

  internal get_apply_method (parm_cnt : int) : IMethod
  {
    InternalType.GetFunctionType (parm_cnt).ApplyMethod
  }

  internal tuple_ref (val : CExpr, pos : int, len : int) : CExpr
  {
    def fld = InternalType.GetTupleType (len).GetField (pos);
    CExpr.FieldRef (val, fld.GetFieldInfo ())
  }

  internal tuple_ctor (vals : list [CExpr]) : CExpr
  {
    def len = List.Length (vals);
    def ctor = InternalType.GetTupleType (len).Ctor.GetConstructorInfo ();
    CExpr.Call (CExpr.ConstructorRef (ctor), vals)
  }

  // always return a new copy
  build_cg_method (header : Fun_header) : CG_method
  {
    def mkparm (p : Fun_parm) : CG_val {
      match (p.ty.Fix ()) {
        | MType.Void =>
          // FIXME: do something about it
          Message.FatalError (header.loc, "method `" + header.name + "' has void argument")
        | _ => ()
      };
      set_parm_info (p, 
        CG_val (loc = header.loc,
                name = p.name, 
                ty = p.SystemType,
                val = CExpr.Nop ()))
    };
    def m = CG_method ();
    m.name = header.name;
    m.ret_type = header.ret_type.Fix ().GetSystemType ();
    m.parms = List.Map (header.parms, mkparm);
    m.implemented_methods = [];
    m
  }
  
  fixup_cg_method (meth : IMethod) : void
  {
    def cgm = GetCgMethod (meth);
    cgm.modifiers = meth.Attributes;
  }

  internal GetCgMethod (meth : IMethod) : CG_method
  {
    def header = meth.GetHeader ();
    when (header.cg_method == null) {
      header.cg_method = build_cg_method (header);
      fixup_cg_method (meth);
    };
    header.cg_method
  }
  
  build_cg_method (meth : IMethod) : CG_method
  {
    build_cg_method (meth.GetHeader ())
  }

  // return cached copy for given method
  internal get_cg_method (header : Fun_header) : CG_method
  {
    when (header.cg_method == null) {
      header.cg_method = build_cg_method (header);
    };
    header.cg_method;
  }
 
  internal emit_delegate_ctor (ctx : CTX, m : IMethod, ps : list [Parm]) : CExpr
  {
    def the_problem () {
      Message.FatalError ("delegate construction not supported for this expression")
    };
    mutable the_method = null;
    
    def (this_ptr, cgm) = 
      match (ps) {
        | [parm] =>
          Util.ice ($ "wrong parameter for delegate ctor $(parm.expr)");

        | [Parm where (expr = obj), Parm where (expr = TExpr.MethodAddress (meth))] =>
          unless (meth.DeclaringType is TypeBuilder)
            the_method = meth.GetHandle () :> System.Reflection.MethodInfo;
          (cg_expr (ctx, obj), GetCgMethod (meth))
          
        | _ => the_problem ()
      };
    when (cgm.method_builder != null)
      the_method = cgm.method_builder;
    assert (the_method != null);
    
    CExpr.Call (CExpr.ConstructorRef (m.GetConstructorInfo ()), 
             [this_ptr, CExpr.MethodAddress (the_method)])
  }

  prepare_ctx_for_fun (ctx : CTX, h : Fun_header) : CTX
  {
    def ctx = CTX (ctx);
    _ = get_cg_method (h);
    ctx.locals = SystemMap ();
    ctx.current_fun = h;
    ctx.current_fun_or_loop = h;
    ctx
  }

  /** Generates compiled body of a typed function */
  cg_fun_body (ctx : CTX, hd : Fun_header, mutable body : TExpr, _in_ctor : bool) : void
  {
    def ctx' = CTX (ctx);
    
    // assigments of parameters and 'this' to closure fields
    // interleaved with base (..) call in constructor
    mutable initializers = [];
    // local variables which have to be created from parameters' casted values
    // in case their type in not fully specific (lack of generics?)
    mutable vals = [];

    def loadparm (parm_val : CG_val, fp : Fun_parm) {
      def parm = fp.decl;
      parm.InClosure = false;
      ctx'.locals = ctx'.locals.Add (parm.Id, parm_val);
    };

    def cgm = get_cg_method (hd);

    // we build the initialization stuff of method:
    // 1. method's closure ctor()
    // 2. store parameters into closure
    // 3. base (..) / this (..) for constructors
    // 4. store 'this' in closure
    // 5. execute raw body of method
    
    List.Iter2 (cgm.parms, hd.parms, loadparm);
    
    // compile raw body of method
    mutable cbody = cg_expr (ctx', body);

    // now put the closure initialization stuff before the raw contents
    def buildlet (v : CG_val, e : CExpr) : CExpr { CExpr.Define (v, e) };
    cbody = List.FoldLeft (vals, 
                           CExpr.Sequence (List.Rev (cbody :: initializers)),
                           buildlet);

#if _GENERICS
    when (!cgm.ret_type.IsGenericParameter && cgm.ret_type.Equals (SystemType.Object))
#else
    when (cgm.ret_type.Equals (SystemType.Object))
#endif    
      cbody = box_value (cbody);
  
    cgm.body = cbody;
  }

  cg_global_fun (ctx : CTX, m : IMethod, body : TExpr) : void
  {
    fixup_cg_method (m);
    def hd = m.GetHeader ();
    def ctx = prepare_ctx_for_fun (ctx, hd);
    cg_fun_body (ctx, hd, body, m.GetFunKind () is FunKind.Constructor);
    hd.body = null;
  }

  do_compile_method (meth : NemerleMethod) : void
  {
    match (meth.GetHeader ().body) {
      | FunBody.Parsed => 
        _ = Typer (meth)
      | _ => ()
    };
    def current_type = meth.DeclaringType :> TypeBuilder;
    def ctx = CTX (current_type);

    // now we will create special wrappers implementing interface methods
    // when our methods are co/contra-variant (and .NET doesn't allow it automatically)
    match (meth.GetFunKind ()) {
      | FunKind.BoundMethod (impl_list) =>
        def tb = current_type.GetTypeBuilder ();
              
        def make_impl_wrapper (impl_meth : IMethod, acc) {
          def mkparm (ifp : CG_val, methp : Fun_parm) : CExpr {
            maybe_cast (ctx, methp.SystemType, CExpr.Ref (ifp))
          };
          if (impl_meth.GetMemType ().Equals (meth.GetMemType ())
              && meth.IsPublic) 
            impl_meth :: acc
          else {
            def cgm' = build_cg_method (impl_meth);
            def meth_ref = CExpr.MethodRef (CExpr.This (), meth.GetMethodBuilder (), false);
            //Message.Debug ($"make_impl_wrap: $meth impl $impl_meth $(cgm'.parms) $(meth.GetParameters ())");
            def parms = List.Map2 (cgm'.parms, meth.GetParameters (), mkparm);
            cgm'.body = maybe_cast (ctx, cgm'.ret_type, CExpr.Call (meth_ref, parms));
            cgm'.name = impl_meth.DeclaringType.FullName + "." + impl_meth.Name;
            cgm'.implemented_methods = [impl_meth];
            cgm'.modifiers = NemerleAttributes.Private %| NemerleAttributes.Sealed %|
                             NemerleAttributes.SpecialName;            
            Passes.Emitter.AddMethod (current_type, cgm', tb);
            acc
          }
        };
        // we filter out interface methods, which we have implemented by means of
        // wrappers, the rest are ok to implement them directly
        def thesame = List.FoldLeft (impl_list, [], make_impl_wrapper);
        meth.SetFunKind (FunKind.BoundMethod (thesame));
        // Message.Debug ($"impl: $impl_list --> $thesame");

      | _ => ()
    }

    // Message.Debug (meth.Location, $ "compile: $meth");
    
    Util.locate (meth.Location, {
      match (meth.GetHeader ().body) {
        | FunBody.Compiled => Util.ice ()
        | FunBody.Parsed => Util.ice ()

        | FunBody.Typed when Message.SeenError =>
          // just skip it
          meth.GetHeader ().body = FunBody.Compiled ()
          
        | FunBody.Typed (body) =>
          cg_global_fun (ctx, meth, body);
          // release memory for GC
          meth.GetHeader ().body = FunBody.Compiled ();

          def cgm = GetCgMethod (meth);
          match (meth.GetFunKind ()) {
            | FunKind.BoundMethod (impl_list) =>
              cgm.implemented_methods = impl_list;
              Passes.Emitter.EmitMethod (current_type, cgm);
              
            | FunKind.Constructor => Passes.Emitter.EmitConstructor (current_type, cgm)
              
            | _ => Passes.Emitter.EmitMethod (current_type, cgm);
          }
        | FunBody.Abstract => ()
      }
    });
    
    when (Options.EarlyExit)
      Message.MaybeBailout ();
  }

  internal CompileMethodImmediately (meth : NemerleMethod) : void
  {
    unless (meth.GetHeader ().body is FunBody.Compiled)
      do_compile_method (meth);
  }
} // end module
} // end ns
