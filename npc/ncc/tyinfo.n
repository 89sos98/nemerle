open Nemerle.Compiler;
open Nemerle.Compiler.Tyops;
open Nemerle.Compiler.Tyinfo;
open Nemerle.Collections;

namespace Nemerle.Compiler {

(*
pass 3:
  For each Type_decl collect:
    - set of types we directly or indirectly subtype, present this
      as map from Type_decl to type expression describing variable
      substitution.
    - enclosing type (do we need it?)
    - list of fields and methods (map from name to method list or 
      field), special method -- ".ctor"
    - list of methods we need to implement
*)

class Tyinfo
  {
    variant Member =
      [
        | Mem_methods { methods : list (M_function); }
        | Mem_field { fld : M_field; }
      ]
      
    record Subtyping_relation
      {
        td : Type_decl;
        args : list (option (Type));
      }
    
    field enclosing_type : option (Type_decl);
    field tydecl : Type_decl;
    field ref subtypes : Int_map (Subtyping_relation);
    field ref members : String_map (Member);
    field ref phase : int; // used by iter function
    // FIXME methods to implement
    
    method this (par : option (Type_decl), td : Type_decl) 
      { 
        this#enclosing_type <- par;
        this#tydecl <- td;
        this#subtypes <- Map.int_map ();
        this#members <- Map.string_map ();
      }

    method lookup_method (name : string) : list (M_function) =
      match this#members#find(name) with [
        | Some (Mem_methods (?x)) => x
        | _ => Nil()
      ];
      
    method lookup_field (name : string) : option (M_field) =
      match this#members#find(name) with [
        | Some (Mem_field (?x)) => Some(x)
        | _ => None()
      ];

    method how_subtypes (td : Type_decl) : option (list (option (Type))) =
      match this#subtypes#find(td#id) with [
        | Some (?sr) => Some(sr#args)
        | None => None()
      ];

    method fullname () : string = 
      let td = this#tydecl in td#env#current_namespace + td#name;
    
    method direct_supertypes () : list (Type) =
      let td = this#tydecl in
      match td#t_extends with [
        | Some (?t) => Cons (t, td#t_implements)
        | None => td#t_implements
      ];

    method generic_type () : Type =
      letfun make_tv (id : int) : Type = 
        T_var (Tyvars.name (id), id)
      in
      let vars = List.map (make_tv, Tyvars.get_parms (this#tydecl#id)) in
      T_app (this#fullname (), vars, this#tydecl#id);

    method fresh_generic_type () : Type =
      Tyutil.fresh_vars (this#tydecl, this#generic_type ());
    
    // check if we can access D from THIS
    // FIXME
    method can_access (d : Class_member) : bool = true ;
    
    method can_access_any (ds : list (Class_member)) : bool = 
      List.exists (fun (d : Class_member) : bool => this#can_access (d), ds);

    fun td_name (td : Type_decl) : string = (lookup(td#id))#fullname();

    value ref infos : Int_map(Tyinfo);
    
    fun lookup (id : int) : Tyinfo =
      match infos#find(id) with [
        | Some (?ti) => ti
        | None => Util.ice()
      ];

    fun lookup (td : Decl_base) : Tyinfo = lookup(td#id);
    
    fun lookup_td (id : int) : Type_decl = (lookup (id))#tydecl;
    
    fun make (decls : list (Type_decl)) : void =
      letfun tydecl_f (par : option (Type_decl), d : Type_decl) : option (Type_decl) = {
        if infos#mem (d#id) then ()
        else infos <- infos#add(d#id, Tyinfo(par, d));
        Some (d)
      } and decl_f (par : option (Type_decl), d : Class_member) : void =
        let ti =
          match (d, par) with [
            | (M_type (?td), _) =>
              match infos#find (td#id) with [
                | Some (?ti) => ti
                | None => Tyinfo (par, td)
              ]
            | (_, Some (?td)) => Util.unsome (infos#find (td#id))
            | _ => Util.ice ()
          ]
        in infos <- infos#add (d#id, ti)
      in {
        infos <- Map.int_map();
        Treeutil.decl_walk(tydecl_f, decl_f, None(), decls);
      };

    type Subinfo = Int_map (Subtyping_relation);

    // iterate over tyinfos, but supertypes are always processed before subtypes
    // otherwise source-code order is retained
    fun iter (f : Tyinfo -> void) : void =
      let working_on = Util.next_id () in
      let done = Util.next_id () in
      letfun sub_do (t : Type) : void =
        match t with [
          | T_app ?td => maybe_f (lookup (td#ref_to))
          | _ => ()
        ]
      and maybe_f (ti : Tyinfo) : void =
        if ti#phase == done then ()
        else if ti#phase == working_on then {
          Message.error(ti#tydecl#loc, "type definition for `" + ti#fullname() + "' is cyclic")
        } else {
          ti#phase <- working_on;
          Util.locate (ti#tydecl#loc, fun () : void => {
            List.iter (sub_do, ti#direct_supertypes ());
            f (ti)
          });
          ti#phase <- done
        }
      in infos#iter(fun (_ : int, ti : Tyinfo) : void => maybe_f (ti));
      
    fun determine_subtyping () : void = 
      letfun add_subtyping_of (ti : Tyinfo, s : Subinfo, t : T_app) : Subinfo =
        let (?sub, ?ti') = Tyutil.subst_of_app (t) in
        letfun add_sr (s : Subinfo, sr : Subtyping_relation) : Subinfo =
          match s#find (sr#td#id) with [
            | Some (?sr') =>
              let ref problem = "" in
              letfun opt_eq (a : option (Type), b : option (Type)) : bool =
                match (a, b) with [
                  | (Some (?t1), Some (?t2)) =>
                    if Tyutil.types_eq (t1, t2) then true
                    else {
                      problem <- "types " + t1#as_string() + " and " +
                                 t2#as_string() + " are not compatible";
                      false
                    }
                  | (None, None) => true
                  | _ => false
                ]
              in
              if List.forall2 (opt_eq, sr#args, sr'#args) then s
              else {
                Message.error ("type `" + td_name(sr#td) + 
                               "' is implemented by type `" +
                               ti#fullname() +
                               "' twice under different instantiations");
                if ti'#tydecl#id == sr#td#id then
                  Message.error ("second one directly")
                else
                  Message.error ("second one through `" + ti'#fullname() + "'");
                Message.error (problem);
                s
              }
            | None => 
              s#add (sr#td#id, sr)
          ]
        in
        letfun add_sr_from_parent (s : Subinfo, _ : int, 
                                   sr : Subtyping_relation) : Subinfo =
          letfun apply_sub (t : option (Type)) : option (Type) =
            match t with [ 
              | Some (?x) => Some (x /- sub) 
              | None => None ()
            ]
          in
          let new_sr = Subtyping_relation (sr#td, List.map (apply_sub, sr#args)) in
          add_sr (s, new_sr)
        in {
          let s = ti'#subtypes#fold(add_sr_from_parent, s) in
          let new_sr = 
            Subtyping_relation (ti'#tydecl, 
                                List.map (fun (x : Type) : option (Type) => Some (x), t#args))
          in add_sr (s, new_sr)
        }

      and make_srs (ti : Tyinfo) : void =
        letfun add_srs (s : Subinfo, t : Type) : Subinfo =
          match t with [
            | T_app ?t => add_subtyping_of (ti, s, t)
            | _ =>
              {
                Message.error("cannot implement nor extend non-class type");
                s
              }
          ]
        in ti#subtypes <- List.fold_left (add_srs, Map.int_map (), ti#direct_supertypes ())
      in iter (make_srs);

    method subtyping_subst (ti : Tyinfo) : Subst =
      let td = ti#tydecl in
      if td#id == this#tydecl#id then 
        Map.int_map () // current type, no substitution
      else
        match this#how_subtypes (td) with [
          | None => Util.ice ()
          | Some (?args) =>
            letfun f (t : option (Type)) : Type =
              match t with [
                | Some (?t) => t
                | None => Tyvars.free_variable ()
              ]
            in 
            let (?s, _) = Tyutil.subst_of_app (T_app ("", List.map (f, args), td#id)) in
            s
        ];
    
    // Return type of given member in this type (i.e. if type comes from
    // supertype, substitute it). Only works for methods and fields.
    method member_type (m : Class_member) : Type =
      let t =
        match m with [
          | M_field ?f => f#ty
          | M_function ?f => Tyutil.fun_type (f#fun_header)
        ]
      in t /- this#subtyping_subst (lookup (m#id));
      
    fun make_member_list (ti : Tyinfo) : void =
      let parent_members =
        match ti#tydecl#t_extends with [
          | Some (T_app ?a) =>
            (lookup (a#ref_to))#members
          | _ => Map.string_map ()
        ]
      in
      letfun can_access (m : M_function) : bool = ti#can_access (m) in
      let parent_members = 
        letfun filter_accessible (ms : String_map (Member), n : string, 
                                  m : Member) : String_map (Member) =
          match m with [
            | Mem_field (?f) =>
              if ti#can_access (f) then ms#add (n, m)
              else ms
            | Mem_methods (?meths) =>
              match List.filter (can_access, meths) with [
                | Nil => ms
                | ?meths => ms#add (n, Mem_methods (meths))
              ]
          ]
        in
        parent_members#fold (filter_accessible, Map.string_map ()) 
      in
      letfun process_decl (mem : String_map (Member), d : Class_member) : String_map (Member) =
        Util.locate (d#loc, fun () : String_map (Member) =>
          match d with [
            | M_field ?f =>
              {
                match parent_members#find (f#name) with [
                  | Some (Mem_field ?f') =>
                    if Util.is_new (f) then ()
                    else Message.error ("field `" + f#name + 
                                        "' overrides field from parent, but no `new'")
                  | Some (Mem_methods ?ms) =>
                    Message.error ("name `" + f#name + 
                                   "' used to be method, it cannot be field now")
                  | None => ()
                ];
                mem#add (f#name, Mem_field (f))
              }
            | M_function ?f =>
              let fun_ty = Tyutil.fun_type (f#fun_header) in
              letfun put_f_in (meths : list (M_function)) : String_map (Member) =
                let ref replaced = false in
                letfun replace (acc : list (M_function), old : M_function) : list (M_function) =
                  if Tyutil.types_eq (ti#member_type (old), fun_ty) then {
                    replaced <- true;
                    Cons (f, acc)
                  } else
                    Cons (old, acc)
                in
                let meths = List.fold_left (replace, Nil (), meths) in
                let meths = 
                  if replaced then meths
                  else Cons (f, meths)
                in mem#replace (f#name, Mem_methods (meths))
              in
              letfun store_f () : String_map (Member) =
                match mem#find (f#name) with [
                  | Some (Mem_field) =>
                    {
                      Message.error ("name `" + f#name + 
                                     "' used to be field, it cannot be method now");
                      mem#add (f#name, Mem_methods (List.cons (f)))
                    }
                  | Some (Mem_methods (?meths)) => put_f_in (meths)
                  | None => mem#add (f#name, Mem_methods (List.cons (f)))
                ]
              in
              match f with [
                | {fun_kind = FK_method (?impl)} => store_f ()
                | {fun_kind = FK_ctor} => store_f ()
                | _ => mem
              ]
            | _ => mem
          ])
      in
      let decls =
        match ti#tydecl with [
          | TD_class (?decls) => decls
          | TD_interface (?decls) => decls
          | _ => Nil ()
        ]
      in
      ti#members <- List.fold_left (process_decl, parent_members, decls);

    fun run (decls : list (Type_decl)) : void {
      make(decls);
      determine_subtyping();
      iter (make_member_list);
    }
  }

} // ns
