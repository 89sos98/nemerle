(*
 * Copyright (c) 2003 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *) 


(* Requires $nempath/lib/hashtable.n, $nempath/lib/list.n, $nempath/lib/getopt.n and $nempath/lib/option.n *)

// NO-TEST
open System;
open System.Diagnostics;
open System.ComponentModel;
open System.IO;
open System.Text.RegularExpressions;
open System.String;
open Nemerle.Collections;
open Nemerle.Collections.List;
open Nemerle.Utility;


public class End_test extends System.Exception
{
	public this()
		{}
}

public class Tester{

	private _dnet_runtime:string;
	private _nem_path:string;
	private _nem_runtime:string;
	private _csc_runtime:string;
	private _no_test_regexp:Regex;
	private _bo_regexp:Regex;	
	private _eo_regexp:Regex;
	private _bi_regexp:Regex;	
	private _ei_regexp:Regex;
	private _err_regexp:Regex;
	private _warn_regexp:Regex;
	private _ok_regexp:Regex;
	private _get_short_filename:Regex;	
	private mutable _no_test:bool;
	private mutable _filename:string;
	private mutable _filename_short:string;
	private mutable _checked_msg:Hashtable(string,string);
	private mutable _warn_lines:Hashtable(string,Regex);
	private mutable _err_lines:Hashtable(string,Regex);
	private mutable _err_overall_count:int;
	private mutable _ok_lines:Hashtable(string,string);
	private mutable _is_reading_output:bool;
	private mutable _expected_output:list(string);
	private mutable _was_output:bool;
	private mutable _is_reading_input:bool;
	private mutable _input:list(string);
	private mutable _error_log:StreamWriter;
	private mutable _was_error_header:bool;
	private mutable _log_file_created:bool;


 public this(dnet_runtime:string,nem_path:string,nem_comp:string,csc_comp:string)
	{

		_dnet_runtime<-dnet_runtime;
		_nem_path<-nem_path;
		_nem_runtime<-nem_comp;
		_csc_runtime<-csc_comp;
		_no_test_regexp<-Regex("//\\s*NO-TEST");
		_bo_regexp<-Regex("^BEGIN-OUTPUT");	
		_eo_regexp<-Regex("^END-OUTPUT");	
		_bi_regexp<-Regex("^BEGIN-INPUT");	
		_ei_regexp<-Regex("^END-INPUT");	
		_err_regexp<-Regex("//\\s*E:\\s*(?<1>.*)$");
		_err_overall_count<-0;
		_warn_regexp<-Regex("//\\s*W:\\s*(?<1>.*)$");
		_ok_regexp<-Regex("//\\s*OK\\s{0,1}.*$");
		_get_short_filename<-Regex("(?<1>[^/]{1,}\\.n)$");
		_error_log<-null;
		_log_file_created<-false;
		Init("");
		
 }



 private Init(filename:string):void
	{
	_checked_msg<-Hashtable();
	_filename<-filename;
        when (filename != "")
	        _filename_short<-_get_short_filename.Match(filename).Groups[1].ToString();
	_warn_lines<-Hashtable();
	_err_lines<-Hashtable();
	_ok_lines<-Hashtable();
	_is_reading_output<-false;
	_expected_output<-Nil();
	_was_output<-false;
	_is_reading_input<-false;
	_input<-Nil();
	_no_test<-false;
	_was_error_header<-false;
	when(_error_log!=null){
		_error_log.Close();
		_error_log<-null
	}
	}

 private CheckLine(str:string,line_index:int):void		
	{

		if (_eo_regexp.IsMatch(str))
		   {
			_is_reading_output<-false
		   }
		else
		if (_ei_regexp.IsMatch(str))
		   {
			_is_reading_input<-false
		   }
		else
		if (_is_reading_output)
			{
			 _expected_output<-(str::(_expected_output))
			}
		 else 
		if (_is_reading_input)
			{
			 _input<-(str::(_input))
			}
		else 
		 {
		def _err_match=_err_regexp.Match(str);
		if (_err_match.Success)
		   {
			_err_lines.Add(string_of_int(line_index),Regex((_err_match.Groups[1]).ToString()))
		   }
		else
		 {
		def _warn_match=_warn_regexp.Match(str);
		if (_warn_match.Success)
		   {
			_warn_lines.Add(string_of_int(line_index),Regex(_warn_match.Groups[1].ToString()))
		   }
		else
		if (_bo_regexp.IsMatch(str))
		   {
			_is_reading_output<-true;
			_was_output<-true
		   } 
		else
		if (_bi_regexp.IsMatch(str))
		   {
			_is_reading_input<-true
		   } 
		else
		if (_ok_regexp.IsMatch(str))
		   {
			_ok_lines.Add(string_of_int(line_index),"")
		   }
		else
		when (_no_test_regexp.IsMatch(str))
			raise End_test()
		}
		}			
	}

 private GetLineAndMsgType(out_str:string):int*string
	{
	  def out_line_match=(Regex(""+_filename+":(?<1>\\d*):\\d*:\\s+(?<2>.*)$")).Match(out_str);
	  if (out_line_match.Success){
	  def line_number=((out_line_match.Groups[1]).ToString());
	  def msg_type_str=((out_line_match.Groups[2]).ToString());
	  if (msg_type_str.IndexOf("error:")!=(-1))
		(0,line_number)
	   else
	   if (msg_type_str.IndexOf("warning:")!=(-1))
		(1,line_number)
	   else
	        (-1,line_number)
	  }
	   else
	{
	  (-1,"")
	}
	}

 private HandleMsg(out_str:string):bool
	{
	  match (GetLineAndMsgType(out_str)){
		| (0,line) => 	 match (_err_lines.Get(line)){
				| Some (err) => when(err.Match(out_str).Success&&(!_checked_msg.Contains(line)))
						 _checked_msg.Add(line,"");
						true					
				| None => 
				 if ((_err_lines.Count())==0){
					false
					}
				 else
				 {
				  match (_ok_lines.Get(line)){
					| Some (_) => false
					| None => true
					}
				 }
				}
		| (1,line) =>  	 match (_warn_lines.Get(line)){
				| Some (warn) => when (warn.Match(out_str).Success&&(!_checked_msg.Contains(line)))
						  _checked_msg.Add(line,"");
						true
				| None => (_warn_lines.Count()!=0)
				 }
		| _ => true
		}		 
	}

 private NemerleTest():bool
	{
	
	mutable nem_compile<-Process();
	if (_dnet_runtime.Length>0){
	 nem_compile.StartInfo.FileName<-_dnet_runtime;
	 nem_compile.StartInfo.Arguments<-(_nem_runtime+" "+_nem_path+"/lib/core.n "+_nem_path+"lib/aliases.n "+_nem_path+"lib/list.n "+_nem_path+"lib/input.n "+_filename)
	} else {
	nem_compile.StartInfo.FileName<-(_nem_runtime);
	nem_compile.StartInfo.Arguments<-(""+_nem_path+"lib/core.n "+_nem_path+"lib/aliases.n "+_nem_path+"lib/list.n "+_nem_path+"lib/input.n "+_filename);
	};
	nem_compile.StartInfo.RedirectStandardOutput<-true;
	nem_compile.StartInfo.UseShellExecute<-false;
	try {
 		def _=nem_compile.Start();
	mutable nem_output<-nem_compile.StandardOutput.ReadLine();
	nem_compile.WaitForExit();
	mutable is_ok<-true;
	while(nem_output != null)
	{
	   unless (HandleMsg(nem_output))
		{
		HandleErrorMsg("Unexpected Nemerle compiler's message:\n"+nem_output);
		is_ok<-false
		};
	   nem_output<-nem_compile.StandardOutput.ReadLine()
	}; 

	def Check(line:string,msg:Regex):void
		{
		  match (_checked_msg.Get(line)){
		  | Some (_) => ()
		  | None => HandleErrorMsg("Expected error: \""+msg.ToString()+"\" hasn't occured in line: "+line);
		 	 is_ok<-false
			}
		};
	_err_lines.Iter(Check);
	def Check(line:string,msg:Regex):void
	 {
		  match (_checked_msg.Get(line)){
		  | Some (_) => ()
		  | None => HandleErrorMsg("Expected warning: \""+msg.ToString()+"\" hasn't occured in line: "+line);
		 	 is_ok<-false
			}
	};
	_warn_lines.Iter(Check);
	if (nem_compile.ExitCode!=0&&nem_compile.ExitCode!=1)
	{
		HandleErrorMsg("Nemerle compiler reported internal error");
		false
	}
	else
		is_ok 
	}
	with { err:Win32Exception  =>
		HandleErrorMsg("Error occured while running Nemerle compiler");
		false
		}
    }

 private TestOutput():bool
	{
	try 
	{
	 mutable runtime<-Process();
	if (_dnet_runtime.Length>0){
	 runtime.StartInfo.FileName<-_dnet_runtime;
	 runtime.StartInfo.Arguments<-"./out.exe";
	} else {
	 runtime.StartInfo.FileName<-"./out.exe";
	 runtime.StartInfo.Arguments<-"";
	};
	 runtime.StartInfo.RedirectStandardOutput<-true;
  	 runtime.StartInfo.UseShellExecute<-false;
	 runtime.StartInfo.RedirectStandardInput<-true;
	def _=runtime.Start();
	def WriteInput (in_list:list(string),input:StreamWriter):void
		{
		match(in_list){
		| Nil => ()
		| h::tl => input.WriteLine(h);
			WriteInput(tl,input)
			}
		};
	WriteInput(_input,runtime.StandardInput);
	runtime.WaitForExit();
	def CheckOutput(in_list:list(string),output:string,is_ok:bool):bool
		{
		  match((in_list,output)){
		  | (Nil,null) => is_ok
		  | (Nil,_) => HandleErrorMsg("Runtime output is longer than it should be");
				false
		  | (_,null) => HandleErrorMsg("Unexpected end of runtime output");
				false
		  | (h::tl,str) => if (h.Equals(str))
					CheckOutput(tl,runtime.StandardOutput.ReadLine(),is_ok)
				   else
					{
					HandleErrorMsg("Runtime output: \""+str+"\"\ndoes not match expected: \""+h+"\"");
					CheckOutput(tl,runtime.StandardOutput.ReadLine(),false) 
					}		
		   }
		};
	CheckOutput(_expected_output,runtime.StandardOutput.ReadLine(),true)
	}
	with {err:Win32Exception =>
		HandleErrorMsg("Error occured while running the program");
		false
		}
	}

 private HandleErrorMsg(str:string):void
	{
		
		if (_error_log==null){
		 print_endline("failed\n"+str);
		 if (_log_file_created)
		   _error_log<-File.AppendText("test_error.log")
		 else {
		   _error_log<-File.CreateText("test_error.log");
		   _log_file_created<-true
		}
		}
		else
		print_endline(str);
		when (!_was_error_header){
		_error_log.WriteLine("-------------------------");
		_error_log.WriteLine("Test of "+_filename);
		_error_log.WriteLine("-------------------------");
		_was_error_header<-true
		};
		_error_log.WriteLine(str);
		_error_log.WriteLine("-------------------------")
	}

 public AttachFile(filename:string):bool
	{
	  try {			
		Init(filename);
		def reader=File.OpenText(filename);
		mutable temp_str<-reader.ReadLine();
		mutable index<-1;	
		while(temp_str != null)
		 {
		   CheckLine(temp_str,index);
		   index<-index+1;
		   temp_str<-reader.ReadLine();
		 };
		reader.Close();
		_expected_output<-List.rev(_expected_output);
		_input<-List.rev(_input);
		true 
	  } with {
		| err:End_test => 
		_no_test<-true;
		true
		| err:Exception =>
			if (_filename_short.Equals(""))
			  print_string("Testing "+filename+"...")
			else
			  print_string("Testing "+_filename_short+"...");
			_err_overall_count<-_err_overall_count+1;
			try
			 raise err
			with{
			| err:FileNotFoundException =>
			HandleErrorMsg("File \""+filename+"\" does not exist")
			| err:DirectoryNotFoundException =>
			HandleErrorMsg("This path \""+filename+"\" is invalid")
			| err:PathTooLongException =>
			HandleErrorMsg("This path \""+filename+"\" is invalid")
			| err:Exception =>
			HandleErrorMsg("Error occured while reading the file")
			};
			false
		}
	}

 public Test():void 
	{
	print_string("Testing "+_filename_short+"...");
	if (_no_test)
		print_endline("skipped")
	else 
	{
	try
	{
	if (NemerleTest()){
		if (_err_lines.Count()==0)
		{
		try {
		def csc_compile=Process();
		csc_compile.StartInfo.FileName<-(_csc_runtime);
		csc_compile.StartInfo.RedirectStandardOutput<-true;
		csc_compile.StartInfo.UseShellExecute<-false;
		if (_was_output)
		csc_compile.StartInfo.Arguments<-("/out:out.exe /nowarn:162 /nowarn:649 /nowarn:219 out.cs")
		else
		csc_compile.StartInfo.Arguments<-("/out:out.netmodule /target:module /nowarn:162 /nowarn:649 /nowarn:219 out.cs");
		def _=csc_compile.Start();
		def _=csc_compile.WaitForExit();
		if (csc_compile.ExitCode==0)
		 {
		   print_string("C#...");
		   if (_was_output)
			{
		    	if(TestOutput())
			  print_endline("passed")
			else
			  HandleErrorMsg("Runtime test failed")
			}
			else {
			print_endline("passed")
			 }
		}
	       	else
		   {
		   HandleErrorMsg("C# compilation failed");
		   _err_overall_count<-_err_overall_count+1
		   }
		} with {err:Win32Exception => 
		HandleErrorMsg("Error occured while running C# compiler")
		}
		}
		 else
		print_endline("passed")
	}
	else
	{
		HandleErrorMsg("Nemerle compile test failed");
		_err_overall_count<-_err_overall_count+1
	}
	}
	with {err:Win32Exception => 
		HandleErrorMsg("Error occured while running Nemerle compiler")
		}
	}
	}

 public GetReport():int
	{
	when(_error_log!=null){
	_error_log.Close();
	_error_log<-null
	};
	 if(_err_overall_count==0){
	   print_endline("All tests passed");
	   0
	}
	 else{
	   print_endline(string_of_int(_err_overall_count)+" of tests failed\nSee test_error.log file for details");
	   1
	}
	}

 public static Main (): int 
	{ 

		mutable dnet_env <- "";
		mutable nem_comp <- "../ncc2.exe";
		mutable csc_comp <- "mcs";
		mutable nem_path <- "../../";
		mutable test_files <- Nil();
		def opts = [
        	Getopt.String      (name = "-n", 
                	          aliases = ["-ncc"], 
                        	  help = "use this Nemerle compiler (default: \"../ncc2.exe\")",
                         	 handler = fun (s) { nem_comp<-s; });
		Getopt.String      (name = "-p", 
                	          aliases = ["-nem_path"], 
                        	  help = "the path to the root of Nemerle directory (default: \"../../\")",
                         	 handler = fun (s) { nem_path<-s; });
		Getopt.String      (name = "-c", 
                	          aliases = ["-csc"], 
                        	  help = "use this C# compiler (default: \"msc\")",
                         	 handler = fun (s) { csc_comp<-s; });
		Getopt.String      (name = "-r", 
                	          aliases = ["-runtime"], 
                        	  help = "use this .Net runtime engine (default: none)",
                         	 handler = fun (s) { dnet_env<-(s:String).Trim(); });
		Getopt.NonOption     (name = "", 
                        	  help = "specify file(s) to be tested (default: All *.n files from current directory)",
                         	 handler = fun (s) { test_files<-s::test_files; });
 		];
		Getopt.Parse (opts);
		def tester = Tester(dnet_env,nem_path,nem_comp,csc_comp);
		when (List.is_empty(test_files)){
		 def str = Directory.GetFiles(Directory.GetCurrentDirectory(),"*.n");
		 mutable fcounter<- ((str:Array).Length-1);
		 while(fcounter>=0)
		 {
// For Windows compatibility:
		   test_files<-(str[fcounter].Replace("\\","/"))::test_files;
		   fcounter<-fcounter-1
		 }
		};
		def test_from_list(file_list:list(string)):void 
		{
			match (file_list) {
			| file::tl => when (tester.AttachFile(file))
					tester.Test();
				  test_from_list(tl)
			| Nil => ()
			}
		};
		test_from_list(test_files);
		tester.GetReport()
	}

}
