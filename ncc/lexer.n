/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Text;
using System.Globalization;
using System;

using Nemerle.Collections;

namespace Nemerle.Compiler {

public variant Token
{
  | Tok_identifier { name : string; }
  | Tok_keyword { name : string; }
  | Tok_operator { name : string; priority : int; }

  | Tok_string_literal { value : string; }
  | Tok_char_literal { value : char; }

  | Tok_sbyte_literal { value : SByte; }
  | Tok_byte_literal { value : Byte; }
  | Tok_short_literal { value : Int16; }
  | Tok_ushort_literal { value : UInt16; }
  | Tok_integer_literal { value : int; }
  | Tok_uinteger_literal { value : UInt32; }
  | Tok_long_literal { value : Int64; }
  | Tok_ulong_literal { value : UInt64; }

  | Tok_float_literal { value : float; }
  | Tok_double_literal { value : Double; }
  | Tok_decimal_literal { value : Decimal; }
  | Tok_comment { value : string; } 

  | Tok_EOF
}

public interface ILexer
{
  get_token () : Token;
  get_location () : Location;
}

public class Lexer : ILexer
{
  file : System.IO.FileStream;
  reader : System.IO.TextReader;
  mutable file_name : string;
  file_real : string;           // real filename to revert after `#line 4 "bla"'
  comment_store : StringBuilder;
  mutable line : int;
  mutable col : int;
  mutable line_stack : int; // real line number at moment of `#line 3' occurence
  mutable line_start : int; // how to compute real line after `#line default' occurence
  mutable putback : bool;
  mutable putbackVal : char;
  mutable isPendingChar : bool;  // is there already some first char
  mutable pendingChar : char;
  mutable negated_literal : bool;
  /** if there was only white chars from beginnig of line */
  mutable white_beginning : bool;  
  
  mutable last_line : int;
  mutable last_col : int;

  defines : Hashtable <string, bool>;
  static command_defines : Hashtable <string, bool>;
  
  static keywords : Hashtable <string, int>;

  public class Error : System.Exception
  {
    public name : string;
    public this (name : string) { this.name <- name; }
  }


  private check_last_line_for_lf () : void
  {
    def _ = file.Seek ((-1 :> Int64), IO.SeekOrigin.End);
    
    def inp = file.ReadByte ();
    
    if (inp >= 0) {
      def ch = Convert.ToChar (inp);
      when (ch != '\n') Message.warning (get_location (),
                                         "no new line at the end of the file");
    } else 
      throw Error ("unexpected end of file");
      
    def _ = file.Seek ((0 :> Int64), IO.SeekOrigin.Begin);
    
    ()
  }


  public this (fn : string)
  {
    file_name <- fn;
    file_real <- fn;
    file <- IO.FileStream (fn, IO.FileMode.Open, IO.FileAccess.Read);
    reader <- IO.StreamReader (file, Text.Encoding.UTF8);
    when (Flags.pedantic_lexer)
      check_last_line_for_lf ();
    line <- 1;
    line_stack <- -1;
    col <- 1;
    putback <- false;
    isPendingChar <- false;
    comment_store <- StringBuilder (300);
    negated_literal <- false;
    white_beginning <- true;
    defines <- Hashtable (100);
    foreach (el in command_defines) defines.Add (el, true)
  }

  do_read () : char
  {
    def inp = reader.Read ();
    if (inp >= 0) {
      def ch = (inp :> char);
      match (ch) {
        | '\n' =>
          line <- line + 1;
          col <- 1
        | '\r' =>
          when (Flags.pedantic_lexer)
            Message.warning (get_location (),
                             "CR character found in input stream")
        | '\t' =>
          when (Flags.pedantic_lexer)
            Message.warning (get_location (),
                             "tab character found in input stream")
        | _ =>
          col <- col + 1
      };
      ch
    } else 
      throw Error ("unexpected end of file")
  }
        
  read () : char
  {
    if (!putback)
      do_read ()
    else {
      putback <- false;
      putbackVal
    }
  }

  peek () : char
  {
    unless (putback)
      putbackVal <- do_read ();
    putback <- true;
    putbackVal
  }

  is_id_beg (ch : char) : bool
  {
    Char.IsLetter (ch) || ch == '_'
  }

  static is_opchar (ch : char) : bool
  {
    match (ch) {
      | '=' | '<' | '>' | '@' | '^' | '|' | '&' | '+'
      | '-' | '*' | '/' | '$' | '%' | '!' | '?' | '~'
      | '.' | ':' | '#' | '[' | ']' => true
      | _ => false
    }
  }

  get_op (priority : int, first_ch : char) : Token
  {
    def buf = Text.StringBuilder (5);
    ignore (buf.Append (first_ch));

    mutable go <- true;
    while (go) {
      if (is_opchar (peek ())) {
        def c = read ();
        if (c == '/')
          if (comment_beginning () == '/')
            ignore (buf.Append ('/'))
          else
            go <- false
        else
          ignore (buf.Append (c))
      }
      else
        go <- false;
    };

    def s = buf.ToString ();
    match (s) {
      | "<-" => 
        // force low priority
        Tok_operator ("<-", 9)

      | "|" | ":" | ":>" | "=>" | "=" =>
        // cannot use this as regular operator
        Tok_operator (s, 0)
        
      | _ => 
        Tok_operator (s, priority)
    }
  }

  variant NumberMode {
    | MD_Float
    | MD_Decimal
    | MD_Octal
    | MD_Hex
    | MD_Binary
  }
  
  get_number (first_ch : char) : Token
  {
    def buf = Text.StringBuilder (10);
    when (negated_literal) {
      ignore (buf.Append ('-'));
      negated_literal <- false;
    };
    mutable already_seen_type <- false;  // for the case 0b0 vs 0b
    
    mutable mode <-
      match (first_ch) {
        | '.' => MD_Float ()
        | '0' =>
          match (peek ()) {
            | 'x' | 'X' => ignore (read ()); MD_Hex ()
            | 'o' | 'O' => ignore (read ()); MD_Octal ()
            | 'b' | 'B' =>
              ignore (read ());
              unless (Char.IsDigit (peek ())) already_seen_type <- true;
              MD_Binary ()
              
            | x when Char.IsDigit (x) =>
              Message.warning (get_location (), "trailing zeros looks like"
                               " octal modifiers, but they are not");
              MD_Decimal ()
              
            | _ => MD_Decimal ()
          }
        | _ => MD_Decimal ()
      };
    mutable last_was_digit <- true;

    ignore (buf.Append (first_ch));

    // read digits and . between them if it is present
    def loop () {
      match (peek ()) {
        | '.' => 
          match (mode) {
            | MD_Decimal =>
              mode <- MD_Float ();
              ignore (read ());
              if (Char.IsDigit (peek ())) {
                ignore (buf.Append ('.'));
                loop ()
              }
              else {
                isPendingChar <- true;
                pendingChar <- '.';
                last_was_digit <- false;
                mode <- MD_Decimal ();
              }
            | _ => ()
          }

        | 'a' | 'A' | 'b' | 'B' | 'c' | 'C' | 'd' | 'D'
        | 'e' | 'E' | 'f' | 'F' =>
          match (mode) {
            | MD_Hex =>
              ignore (buf.Append (read ()));
              loop ()
            | _ => ()
          }

        | x when Char.IsDigit (x) =>
          ignore (buf.Append (read ()));
          loop ()
        | _ => ()
      }
    };
    loop ();
    
    def exponent_part (only_realsuf) {
      when (!only_realsuf) {
        match (peek ()) {
          | 'E' | 'e' =>
            ignore (buf.Append (read ()));
            match (peek ()) {
              | '+' | '-' =>
                ignore (buf.Append (read ()));
              | _ => ()
            };
            if (Char.IsDigit (peek ()))
              do {
                ignore (buf.Append (read ()));
              } while (Char.IsDigit (peek ()))
            else
              throw Error ("no digits after exponent sign in float literal")
          | _ => ()
        }
      };
      match (Char.ToLower (peek (), CultureInfo.InvariantCulture)) {
        | 'f' =>
          ignore (read ());
          Tok_float_literal (Single.Parse (buf.ToString (),
                                           NumberFormatInfo.InvariantInfo))
        | 'd' =>
          ignore (read ());          
          Tok_double_literal (Double.Parse (buf.ToString (),
                                           NumberFormatInfo.InvariantInfo))
        | 'm' =>
          ignore (read ());          
          Tok_decimal_literal (Decimal.Parse (buf.ToString (),
                                              NumberFormatInfo.InvariantInfo))
        | _ =>
          Tok_double_literal (Double.Parse (buf.ToString (),
                                            NumberFormatInfo.InvariantInfo))
      }
    };

    // convert given object to appropriate integer value according to type suffix
    def check_type_suffix (val : object) {
      /// we should have integer number here

      def special (c) {
        | 'l' | 's' | 'b' | 'u' =>
          true
        | _ =>
          false
      };

      // check suffixes to make special types conversions
      mutable ch <-
        if (already_seen_type)
          'b'
        else
          Char.ToLower (peek (), CultureInfo.InvariantCulture);
      if (special (ch)) {
        unless (already_seen_type) ignore (read ());
        mutable unsigned <- ch == 'u';

        // we can have two letter suffixes
        def ch' = Char.ToLower (peek (), CultureInfo.InvariantCulture);
        if (special (ch')) {
          ignore (read ());
          if (ch' == 'u') {
            when (unsigned)
              throw Error ("bad integer suffix (unsigned twice)");
            unsigned <- true;
          }
          else {
            // both chars can be different than 'u' and than they must be 'bs'
            match ((ch, ch')) {
              | ('s', 'b') | ('b', 's') =>
                ch <- 'b'
              | _ =>
                unless (unsigned)
                  throw Error ("bad integer suffix (type contraint twice)");
                ch <- ch';
            }
          }
        }
        else
          // only 'b' suffix, so it is unsigned byte
          when (ch == 'b') unsigned <- true;

        // [ch] now contains type meaning or 'u' (then it is uint for sure)
        match (ch) {
          | 'b' =>
            if (unsigned)
              Tok_byte_literal (Convert.ToByte (val, CultureInfo.InvariantCulture))
            else
              Tok_sbyte_literal (Convert.ToSByte (val, CultureInfo.InvariantCulture))
          | 's' =>
            if (unsigned)
              Tok_ushort_literal (Convert.ToUInt16 (val, CultureInfo.InvariantCulture))
            else
              Tok_short_literal (Convert.ToInt16 (val, CultureInfo.InvariantCulture))
          | 'l' =>
            if (unsigned)
              Tok_ulong_literal (Convert.ToUInt64 (val, CultureInfo.InvariantCulture))
            else
              Tok_long_literal (Convert.ToInt64 (val, CultureInfo.InvariantCulture))
          | _ =>
            Tok_uinteger_literal (Convert.ToUInt32 (val, CultureInfo.InvariantCulture))
        }
      }
      else
        Tok_integer_literal (Convert.ToInt32 (val, CultureInfo.InvariantCulture))
    };
    
    try {
      match (mode) {
        | MD_Float =>
          match (peek ()) {
            | 'E' | 'e' => 
              exponent_part (false)
            | _ =>
              exponent_part (true)
          }
        | MD_Decimal =>
          if (last_was_digit)
            match (Char.ToLower (peek (), CultureInfo.InvariantCulture)) {
              | 'e' =>
                exponent_part (false)
              | 'f' | 'd' | 'm' =>
                exponent_part (true)
              | _ =>
                check_type_suffix (buf.ToString ())
            }
          else
            Tok_integer_literal (Convert.ToInt32 (buf.ToString ()))

        | MD_Hex =>
          def val = UInt64.Parse (buf.ToString (), Globalization.NumberStyles.HexNumber,
                                  CultureInfo.InvariantCulture);
          check_type_suffix (val)

        | MD_Binary =>
          mutable value <- 0ul;
          for (mutable i <- 0; i < buf.Length; ++i)
            match (buf[i]) {
              | '0' => value <<= 1
              | '1' => value <<= 1; value += 1ul
              | _ => throw Error ("binary literal numer must be composed of 1 and 0s")
            };
          check_type_suffix (value)

        | MD_Octal =>
          mutable value <- 0ul;
          for (mutable i <- 0; i < buf.Length; ++i)
            match (Convert.ToUInt64 (buf[i]) - 48ul) {
              | x when 0ul <= x && x <= 7ul => value <<= 3; value += x;
              | x =>
                when (0ul <= x && x <= 7ul) Util.ice ("matching error");
                throw Error ("octal literal number must be composed of 0 to 7 digits "
                             + "while it has `" + x.ToString () + "'")
            };
          check_type_suffix (value)
      }
    }
    catch {
      _ : System.OverflowException =>
        throw Error ("number literal " + buf.ToString () +
                     " is too large for given type")
    }
  }

  get_id (first_ch : char) : Token
  {
    if (first_ch == '\'' && !is_id_beg (peek ())) {
      get_char ()
    } else {
      def buf = Text.StringBuilder ();
      ignore (buf.Append (first_ch));

      while (is_id_beg (peek ()) || 
             Char.IsDigit (peek ()) || 
             peek () == '\'') {
        ignore (buf.Append (read ()))
      };
          
      def str = buf.ToString ();
      
      if (first_ch == '\'' && str.Length == 3 && str[2] == '\'')
        Tok_char_literal (str[1])
      else if (keywords.Contains (str))
        Tok_keyword (str)
      else
        Tok_identifier (str)
    }
  }

  escape_value (ch : char) : char
  {
    match (ch) {
      | 'n' => '\n'
      | 't' => '\t'
      | 'r' => '\r'
      | 'b' => '\b'
      | 'e' => '\e'
      | '"' => '"'
      | '\'' => '\''
      | '\\' => '\\'
      | '0' => '\0'
      | _ => throw Error ("bad escape character")
    }
  }
    
  get_char () : Token
  {
    match (get_string ('\'')) {
      | Tok_string_literal (v) =>
        if (v.Length == 0)
          throw Error ("empty character literal")
        else {
          if (v.Length != 1)
            throw Error ("character literal too long")
          else
            Tok_char_literal (v[0])
        }
      | _ => Util.ice ("Value is not string in get_char")
    }
  }

  get_string (end_ch : char) : Token
  {
    def buf = StringBuilder ();
    mutable go <- true;
              
    while (go) {
      match (read ()) {
        | '\\' =>
          def esc = escape_value (read ());
          ignore (buf.Append (esc));
        | '\n' =>
          throw Error ("newline before end of string")
        | ch when ch != end_ch => 
          ignore (buf.Append (ch))
        | _ =>
          def ch = eat_whitespace (' ');
          if (ch == end_ch) 
            when (comment_store.Length > 0) {
              Message.warning (get_location (),
                               "documentation comments between literals are ignored");
              ignore (comment_store.Remove (0, comment_store.Length))
            }
          else {
            isPendingChar <- true;
            pendingChar <- ch;
            go <- false
          }
      }
    };
     
    Tok_string_literal (buf.ToString ())
  }

  get_monkey_string () : Token
  {
    def buf = StringBuilder (32);

    def loop () {
      match (read ()) {
        | '"' => Tok_string_literal (buf.ToString ())
        | ch => ignore (buf.Append (ch)); loop ()
      }
    };

    loop ()
  }

  comment_beginning () : char
  {
    match (peek ()) {
      | '/' =>
        // we are for sure in one line comment
        ignore (read ());
        if (peek () == '/') {
          ignore (read ());
          mutable cc <- ' ';
          do {
            cc <- read ();                
            ignore (comment_store.Append (cc))
          } while (cc != '\n')
        }
        else
          while (read () != '\n') {};
          white_beginning <- true;
        // pass whitespace, so next read would be eof checked
        ' '

      | '*' =>
        // multiline comment
        ignore (read ());
        def loop1 (seen_star, store) {
          def cc = read ();
          when (store)
            ignore (comment_store.Append (cc));

          match (cc) {
            | '*' => loop1 (true, store)
            | '/' when seen_star => ()
            | _ => loop1 (false, store)
          }
        };
        if (peek () == '*') {
          ignore (read ());
          loop1 (true, true);
          if (comment_store.Length == 1)
            ignore (comment_store.Remove (0, 1))
          else
            ignore (comment_store.Remove (comment_store.Length - 2, 2))
        }
        else
          loop1 (false, false);

        // pass whitespace, so next read would be eof checked            
        ' '

      | _ => '/'
    }
  }
  
  eat_whitespace (ch : char) : char
  {
    mutable eof <- false;
    
    def loop (c) {
      | ' ' | '\t' | '\r' | '\n' =>
        when (c == '\n') white_beginning <- true;
        def ch = try read () catch { _ : Error => eof <- true; '_'  };
        if (eof) ' ' else loop (ch)
      | '/' =>
        white_beginning <- false;
        match (comment_beginning ()) {
          | '/' => '/'
          | c => loop (c)
        }
        
      | '#' =>
        if (white_beginning) {
          parse_preprocessor ();
          loop (' ')
        }
        else
          throw Error ("preprocessor directives must occur only in lines beginning"
                       " with whitespaces")
        
      | _ =>
        white_beginning <- false;
        c
    };
    loop (ch)
  }

  parse_preprocessor () : void
  {
    def read_to_the_end_of_line () {
      mutable c <- ' ';
      def line = StringBuilder (80);
      while (c != '\n') {
        ignore (line.Append (c));
        try c <- read ()
        catch { _ : Error => c <- '\n' }
      };
      line.ToString ()
    };
    // eof isn't checked, because we are eating and expecting something
    // not white before end of line
    def eat_spaces () : char {
      mutable c <- ' ';
      while (Char.IsWhiteSpace (c) && c != '\n') 
        c <- read ();
      c
    };
    def read_word () : string {
      def word = StringBuilder (eat_spaces ().ToString ());
      try 
        while (Char.IsLetter (peek ()))
          ignore (word.Append (read ()))
      catch { _ : Error => () };
      word.ToString ()
    };

    def directive = read_word ();
    when (directive == "")
      throw Error ("expected preprocessing directive after `#'");
      
    match (directive) {
      | "if" =>
        def _ = evaluate_preprocessing_expr (read_to_the_end_of_line ().Trim ());
        ()

      | "elif" =>
        def _ = evaluate_preprocessing_expr (read_to_the_end_of_line ().Trim ());
        ()

      | "else" => ignore (read_to_the_end_of_line ())
      | "endif" => ignore (read_to_the_end_of_line ())
        
      | "line" =>
        def num = StringBuilder ();
        mutable c <- eat_spaces ();
        def (new_line, new_file) =
          if (c == 'd') {
            if (read_word () == "efault") {
              ignore (read_to_the_end_of_line ());
              (-1, null)
            }
            else
              throw Error ("expecting line number or `default' indicator")
          }
          else {
            while (Char.IsDigit (c)) {
              ignore (num.Append (c));
              try c <- read () catch { _ : Error => c <- ' ' }
            };
            (Int32.Parse (num.ToString ()), 
             read_to_the_end_of_line ().Trim ())
          };
        if (new_line == -1) {
          line <- line - line_start + line_stack;
          file_name <- file_real;
          line_stack <- -1;
        }
        else {
          // if there is already something on stack, bring real line first
          when (line_stack != -1)
            line <- line - line_start + line_stack;
          line_start <- new_line;
          line_stack <- line;
          line <- new_line;
          when (new_file != "")
            file_name <- new_file
        }

      | "error" => 
        Message.error (read_to_the_end_of_line ().Trim ());
        
      | "warning" =>
        Message.warning (read_to_the_end_of_line ().Trim ());

      | "region" =>
        def line = read_to_the_end_of_line ().Trim ();
        ignore (comment_store.Append ("<region>").Append (line).
                Append ("</region>"));
        
      | "endregion" =>
        def line = read_to_the_end_of_line ();
        ignore (comment_store.Append ("<endregion>").Append (line).
                Append ("</endregion>"));

      | "define" =>
        defines.Set (read_word (), true);
        ignore (read_to_the_end_of_line ())

      | "undef" =>
        defines.Set (read_word (), false);
        ignore (read_to_the_end_of_line ())
        
      | x => throw Error ("unsupported preprocessing directive `" + x + "'")
    }
  }

  evaluate_preprocessing_expr (_str : string) : bool {
    // FIXME
    true
  }
  
  do_get_token (ch : char) : Token
  {
    last_line <- line;
    last_col <- col;
    
    match (ch) {
      | '"' => get_string ('"')

      | '\'' => get_id ('\'')

      | '.' => 
        if (Char.IsDigit (peek ()))
          get_number (ch)
        else
          Tok_operator (ch.ToString (), 0)

      | '{' | '}' 
      | '[' | ']' 
      | ',' | ';' 
      | '(' | ')' => Tok_operator (String (ch, 1), 0)

      | '@' =>
        def next = read ();
        if (is_opchar (next))
          match (get_op (0, next)) {
            | Tok_operator (s, _) => Tok_identifier (s)
            | _ => Util.ice ()
          }
        else if (is_id_beg (next))
          match (get_id (next)) {
            | Tok_identifier (x)
            | Tok_keyword (x) => Tok_identifier (x)
            | _ => Util.ice ()
          }
        else if (next == '"')
          get_monkey_string ()
        else
          throw Error ("expecting operator, identifier or string literal after '@'")
      
      | '*' =>
        if (peek () == '*')
          get_op (1, ch)
        else
          get_op (2, ch)

      | '/' =>
        get_op (2, ch)
                              
      | '%' | '\\'
        => get_op (2, ch)

      | '-' =>
        if (Char.IsDigit (peek())) {
          negated_literal <- true;
          Tok_operator ("+", 3)
        }
        else
          if (peek () != '.') get_op (3, ch) 
          else Tok_operator (ch.ToString (), 3)          

      | '+'  
        =>
           if (peek () != '.') get_op (3, ch) 
           else Tok_operator (ch.ToString (), 3)
      
      | '^' | '$' | '~' | '?' | '#'
        => get_op (4, ch)
        
      | '=' | '<' | '>' | '!' 
        => get_op (5, ch)
        
      | '&' => get_op (6, ch)
      | '|' => get_op (7, ch)
      | ':' => get_op (8, ch)

      // after executing eat_whitespace it is the only possibility for space
      | ' ' => Tok_EOF ()
        
      | _ =>
        if (Char.IsDigit (ch))
          get_number (ch)
        else
          if (is_id_beg (ch))
            get_id (ch)
          else
            throw Error ("invalid character")
    }      
  }

  get_token () : Token implements ILexer.get_token
  {
    def ch = 
      if (isPendingChar) {
        isPendingChar <- false;
        eat_whitespace (pendingChar)
      }
      else
        eat_whitespace (' ');

    if (comment_store.Length > 0) {
      isPendingChar <- true;
      pendingChar <- ch;      
      
      def res = Tok_comment (comment_store.ToString ());
      ignore (comment_store.Remove (0, comment_store.Length));
      res
    }
    else
      do_get_token (ch)
  }

  get_location () : Location implements ILexer.get_location
  {
    Location (file_name, last_line, last_col)
  }

  get_current_location () : Location
  {
    Location (file_name, line, col)
  }

  public static this () 
  {
    def tab = array [
        "_", "abstract", "and", "array", "as", "base", "catch",
        "class", "def", "extends", "extern", "false", "finally", "fun",
        "implements", "interface", "internal", "macro", "match", "module",
        "mutable", "namespace", "new", "null", "out", "override",
        "params", "private", "protected", "public", "ref", "sealed",
        "static", "struct", "syntax", "this", "throw", "true", "try",
        "type", "typeof", "using", "variant", "virtual", "void", "when",
        "where", "event", "delegate", "enum", "postscan", "preadd", "postadd"
    ];
    keywords <- Hashtable ();
    foreach (el in tab) keywords.Add (el, 1);
          
    command_defines <- Hashtable ();
  }

  public static AddKeyword (str : string) : void 
  {
    match (keywords.Get (str)) {
      | Some (level) =>
        keywords.Set (str, level + 1)
      | _ =>
        keywords.Set (str, 1)
    }
  }

  public static RemoveKeyword (str : string) : void 
  {
    match (keywords.Get (str)) {
      | Some (1) =>
        keywords.Remove (str)
      | Some (level) =>
        keywords.Set (str, level - 1)
      | _ =>
        Util.ice ("trying to remove non-existant keyword from lexer")
    }
  }
  
  public static IsOperator (str : string) : bool
  {
    def len = str.Length;
    mutable is <- true;
    for (mutable i <- 0; i < len && is; ++i) {
      def c = str[i];
      is <- is_opchar (c) || c == '(' || c == ')' || c == ';';
    };
    is
  }

  public static IsKeyword (str : string) : bool
  {
    def len = str.Length;
    mutable is <- true;
    for (mutable i <- 0; i < len && is; ++i)
      is <- Char.IsLetter (str[i]);
    is
  }
} // end class Lexer
} // end ns
