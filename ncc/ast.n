/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Globalization;
using Nemerle.Collections;
using Nemerle.Utility;

namespace Nemerle.Compiler {

  public struct Location : Nemerle.IComparable <Location>
  {
    token : int;

    public this (t : int) { token = t; }

    public this (file_idx : int, line : int, col : int) {
      token = ComputeToken (file_idx, line, col);
    }    
    
    public static Default : Location = Location (0);

    public static @== (x : Location, y : Location) : bool { x.token == y.token }
    public static @!= (x : Location, y : Location) : bool { x.token != y.token }    
    
    /** the bit number (from least important as 0) where line info begins */
    static mutable line_bits : int;
    static mutable col_bits : int;

    /** bits reserved for index of file */
    static mutable file_mask : int;

    /** mapping from index to file name */
    static mutable file_names : array [string];
    static mutable file_names_amount : int;
    
    /** encountered file names with mapping to their indices */
    static file_indices : Hashtable [string, int] = Hashtable ();

    static public AddFiles (names : list [string]) : void
    {
      def log2 (x, acc) {
        if (x == 0) acc
        else log2 (x >> 1, acc + 1);
      }

      // we add two bits for the case of dynamic new file names in #line 22 "bla"
      col_bits = log2 (names.Length () + 1, 0) + 2;
      file_mask = (1 << col_bits) - 1;

      // 8 bits for coulmn info
      line_bits = col_bits + 8;
      
      file_names = array (1 << col_bits);
      file_indices.Add ("", 0);
      file_names_amount = 1;
      foreach (x in names) {
        file_indices.Add (x, file_names_amount);
        file_names [file_names_amount] = x;
        ++file_names_amount;
      }
    }

    static public ComputeToken (file_idx : int, line : int, col : int) : int
    {
      def col = if (col > 255) 255 else col;
      (file_idx %& file_mask) %| (line << line_bits) %| (col << col_bits)
    }
    
    static public GetFileIndex (name : string) : int
    {
      match (file_indices.Get (name)) {
        | Some (idx) => idx
        | None =>
          if (file_names_amount == file_names.Length) {
            Message.warning ("too many filenames... Location cache overflow");
            0
          }
          else {
            file_indices.Add (name, file_names_amount);
            file_names [file_names_amount] = name;
            ++file_names_amount;
            file_names_amount
          }
      }
    }
    
    public File : string
    {
      get { file_names [token %& file_mask] }
    }

    public Line : int
    {
      get { token >> line_bits }
    }

    /** we allow only columns in range 0-255 */
    public Column : int
    {
      get { (token >> col_bits) %& 255 }
    }

    public CompareTo (other : Location) : int
    {
      token - other.token
    }

    [Nemerle.OverrideObjectEquals]
    public Equals (other : Location) : bool
    {
      token == other.token
    }
  }
  
  public class Located
  {
    public mutable loc : Location;
    public this () { loc = Location_stack.top (); }
    public this (loc : Location) { this.loc = loc }
  }

  [System.Flags]
  public enum NemerleAttributes
  {
    | None        = 0x0000
    | Public      = 0x0001
    | Private     = 0x0002
    | New         = 0x0004 
    | Protected   = 0x0008
    | Abstract    = 0x0010
    | Virtual     = 0x0020
    | Sealed      = 0x0040
    | Static      = 0x0080
    | Mutable     = 0x0100      
    | Internal    = 0x0200
    | Override    = 0x0400
    | Module      = 0x0800
    | Struct      = 0x1000
    | Macro       = 0x2000
    | Volatile    = 0x4000
    | SpecialName = 0x8000

    | AccessModifiers = Public %| Private %| Protected %| Internal
  }                 

  
  public class Modifiers 
  {
    public mutable mods : NemerleAttributes;
    public mutable custom_attrs : list [Parsetree.PExpr];
    public mutable macro_attrs : list [string * Parsetree.PExpr];

    public static Empty : Modifiers;

    public IsEmpty : bool
    {
      get {
        custom_attrs.IsEmpty () && macro_attrs.IsEmpty ()
      }
    }

    public this (mods : NemerleAttributes, custom_attrs : list [Parsetree.PExpr])
    {
      this.mods = mods;
      this.custom_attrs = custom_attrs;
      this.macro_attrs = [];
    }

    public static this ()
    {
      Empty = Modifiers (NemerleAttributes.None, []);
    }

    public AddCustomAttribute (target : System.AttributeTargets, 
                               expr : Parsetree.PExpr) : void
    {
      ignore (target);
      custom_attrs = expr :: custom_attrs;
    }

    internal SaveCustomAttributes (ti : TypeBuilder,
                                   adder : System.AttributeTargets * 
                                           System.Reflection.Emit.CustomAttributeBuilder -> void) 
                                  : void
    {
      def target = System.AttributeTargets.All;
      foreach (expr in custom_attrs) {
        try {
          adder (target, AttributeCompiler.CompileAttribute (ti.env, ti, expr))
        } catch {
          | _ : Recovery => ()
        }
      };
      foreach ((suff, expr) in macro_attrs) {
        try {
          def (m, parms) = 
            match (MacroRegistry.lookup_macro (ti.env, expr, suff)) {
              | Some ((_, m, parms)) => (m, parms)
              | _ => Util.ice ("macro is not a macro?" +
                               PrettyPrint.SprintExpr (None (), expr))
            };
          def sparms = List.Map (parms, fun (x) { PrettyPrint.SprintExpr (None (), x) });
          def concatenated = NString.Concat ("@", sparms);
//          def _x = ti.env.GetMacroContext ();
          def serialized = <[ 
            Nemerle.Internal.MacroAttribute ($(m.GetNamespace () + m.GetName () : string),
          //                                   $(ti.env.GetMacroContext () : int),
                                             0,
                                             $(concatenated : string)) 
          ]>;
          adder (target, AttributeCompiler.CompileAttribute (ti.env, ti, serialized))
        } catch {
          | _ : Recovery => ()
        }
      };
    }


  }

  public variant Literal
  {
    | Void
    | Null
    | String { val : string; }
    | Float { val : float; }
    | Double { val : double; }
    | Decimal { val : decimal; }
    | Char { val : char; }
    | Bool { val : bool; }
    | SByte { val : sbyte; }
    | Byte { val : byte; }
    | Short { val : short; }
    | UShort { val : ushort; }
    | Int { val : int; }
    | UInt { val : uint; }
    | Long { val : long; }
    | ULong { val : ulong; }

    | Enum { val : Literal; ty : TypeInfo; }


    /**
     * Converts 'this' literal to an equivalent (lexable) string
     */
    public override ToString () : string
    {
      match (this) {
        | Literal.Void           => "()"
        | Literal.Null           => "null"

        | Literal.String   (val) => "\"" + val.Replace ("\n", "\\n") + "\""
        | Literal.Float    (val) => val.ToString (NumberFormatInfo.InvariantInfo) + "f"
        | Literal.Double   (val) => val.ToString (NumberFormatInfo.InvariantInfo) + "d"
        | Literal.Decimal  (val) => val.ToString (NumberFormatInfo.InvariantInfo) + "m"
        | Literal.Char     (val) => "'" + val.ToString () + "'"
        | Literal.Bool     (val) => if (val) "true" else "false"
        | Literal.SByte    (val) => val.ToString () + "sb"
        | Literal.Byte     (val) => val.ToString () + "b"
        | Literal.Short    (val) => val.ToString () + "s"
        | Literal.UShort   (val) => val.ToString () + "us"
        | Literal.Int      (val) => val.ToString ()
        | Literal.UInt     (val) => val.ToString () + "u"
        | Literal.Long     (val) => val.ToString () + "l"
        | Literal.ULong    (val) => val.ToString () + "ul"
          
        | Literal.Enum (val, ty) => "(" + val.ToString () + " :> " + ty.FullName + ")"
      }
    }
  }

  public variant FunBody
  {
    | Parsed { expr : Parsetree.PExpr; }
    | Typed { expr : Typedtree.TExpr; }
    | Compiled
    | Extern { name : string; }
    | Abstract  // for interface method
  }

  public variant FunKind
  {
    | Method { f_implements : list [Parsetree.Splicable]; }
    | BoundMethod { f_implements : list [IMethod]; }
    | Constructor
    | StaticConstructor
    | Function
  }


} // Nemerle.Compiler
