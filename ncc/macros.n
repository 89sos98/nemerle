/*
 * Copyright (c) 2003, 2004 The University of Wroclaw.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *    3. The name of the University may not be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL THE UNIVERSITY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Transformations of quoted expressions into syntax trees
 */

using Nemerle.Collections;
using Nemerle.Utility;

using Nemerle.Compiler.Parsetree;
using System.Text;

namespace Nemerle.Compiler {

public module Macros
{
  /// PUBLIC API FOR USAGE IN MACROS

  /** generates new unique symbol, which can be safely used
      as name of quoted variables, functions, etc.
   */
  public NewSymbol () : Name
  {
    Name (Util.tmpname (""), TypingContext.MacroColor, 0)
  }

  /** controlled hygiene breaking - generates symbol, which
      placed in generated code would bind to variables
      at macro-use site
   */
  public UseSiteSymbol (id : string) : Name
  {
    Name (id, TypingContext.MacroUseColor, TypingContext.MacroUseContext)
  }

  // FIXME: it should be macro, which stores current context number
  public Symbol (id : string) : Name
  {
    Name (id, TypingContext.MacroColor, 0) 
  }
  
  /// DATA STRUCTURES USED IN QUOTATION AND MACROS
 variant MacroParm 
  {
    | MP_expr
    | MP_parm
    | MP_exprs
    | MP_parms
  }
  
  public class QuotationContext 
  {
    public bound : Hashtable <string, list <string * int>>;
    public mutable level : int;

    public this () { bound <- Hashtable () }
  }

  type CTX = TypingContext;

  // some tool methods
  public UnSString (x : Splicable_string) : string {
    | SS_string ({ id = x }) => x
    | _ => throw System.ArgumentException ("Macros.unsstring")
  }

  // QUOTATION HANDLING SECTION

  /** create tree, which constructs list of given elements,
      additionally applying given function to each element 
   */
  make_quoted_list<'a> (f : 'a -> Expr, li : list <'a>) : Expr
   {
     match (li) {
       | [] => <[ [] ]>
       | x::xs => <[ $(f (x)) :: $(make_quoted_list (f, xs)) ]>
     }
   }

  /** this method treats expression as syntax tree of list containing 
      expressions, which are arguments of variable argument constructs
      (sequence, tuple, etc.)
      it also apply given function to each argument
   */
  decompose_list (f : Expr -> Expr, ex : Expr) : Expr
  {
    match (ex) {
      | <[ $h :: $t ]> =>
        <[ $(f (h)) :: $(decompose_list (f, t)) ]>
      | <[ [] ]> => ex
      | E_spliced (e) => e
      | E_spliced_patt => ex
      | _ => 
        Message.fatal_error ("Bad expression in quoted variable arguments list: ")
    }
  }

  decompose_pattern_list (f : Pattern -> Expr, pa : Pattern) : Expr
  {
    match (pa) {
      | <[ pattern: Cons ($h, $t) ]> => 
        <[ $(f (h)) :: $(decompose_pattern_list (f, t)) ]>
      | <[ pattern: [] ]> => <[ [] ]>
      | P_spliced (e) => e
      | _ => 
        Message.fatal_error ("Bad pattern in quoted variable arguments list"); 
    }
  }

  decompose_type_list (f : Type -> Expr, ty : Type) : Expr
  {
    match (ty) {
      | T_prod (types) => 
        make_quoted_list (f, types)
      | T_spliced (e) => e
      | _ => Message.error ("Bad type in quoted variable arguments list: "); 
        f (ty)
    }
  }

  quoted_sstring (st : Splicable_string) : Expr
  { 
    | SS_string ({ id = str }) => 
      <[ Nemerle.Compiler.Parsetree.SS_string (Nemerle.Compiler.Parsetree.Name
                                               ($(str : string))) ]>
    | SS_spliced_expr (E_spliced_special ("var", e)) => 
      <[ Nemerle.Compiler.Parsetree.SS_string ($e) ]>
    | SS_spliced_expr (E_spliced_special ("dyn", e)) => 
      <[ Nemerle.Compiler.Parsetree.SS_string (Nemerle.Compiler.Parsetree.Name ($e)) ]>
    | SS_spliced_expr (e) => e
  }

  quoted_name (n : Name, context : int) : Expr
  {
    <[ Nemerle.Compiler.Parsetree.Name ($(n.id : string), $(context : int)) ]>
  }
  
  quoted_location (loc : Location) : Expr
  {
    <[ Nemerle.Compiler.Location ($(loc.file : string), $(loc.line : int),
                                  $(loc.column : int)) ]>
  }

  public quoted_ttype (ctx : CTX, t : Type) : Expr
  {
    def quotedc_ttype (x) { quoted_ttype (ctx, x) };

    match (t) {
      | <[ type: $tycon < .. $args > ]> =>
        def tyco = match (tycon) { 
          | SS_string ({ id = s }) => <[ $(s : string) ]>
          | SS_spliced_expr (e) => e
        };
        def findtyco = <[
          match ($("_N_ctx" : dyn).env.LookupType ($tyco)) {
            | Some (x) => x
            | None => Message.fatal_error ("unbound type " + $tyco)
          }
        ]>;
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Typedtree.T_app 
                 ($findtyco, $(decompose_type_list (quotedc_ttype, ar))) ]>
          | _ =>
            <[ Nemerle.Compiler.Typedtree.T_app 
                 ($findtyco, $(make_quoted_list (quotedc_ttype, args))) ]>
        }

      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Typedtree.T_ref ($(quoted_ttype (ctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Typedtree.T_out ($(quoted_ttype (ctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Typedtree.T_fun ($(quoted_ttype (ctx, from)),
                                             $(quoted_ttype (ctx, to))) ]>
  
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Typedtree.T_void () ]>
  
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Typedtree.T_prod ($(make_quoted_list (quotedc_ttype, args))) ]>

      | <[ type: array < $ty > ]> =>
        <[ Nemerle.Compiler.Typedtree.T_array ($(quotedc_ttype (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "var" => 
              <[ Nemerle.Compiler.Typedtree.T_var (Nemerle.Compiler.Tyvar.T ($val)) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer =>
        <[ Nemerle.Compiler.Typedtree.T_infer () ]>

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Typedtree.T_prod ($(decompose_type_list (quotedc_ttype, ar))) ]>
    } 
  }

  /** transforms syntax tree of quoted type to its construction tree 
   */
  public quoted_type (ctx : CTX, t : Type) : Expr
  {
    def quotedc_type (x) { quoted_type (ctx, x) };

    match (t) {
      | <[ type: $tycon < .. $args> ]> =>
        match (args) {
          | [T_type_list(ar)] => 
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)),
               $(decompose_type_list (quotedc_type, ar))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.T_app ($(quoted_sstring (tycon)), 
               $(make_quoted_list (quotedc_type, args))) ]>
        }

      | <[ type: ref $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_ref ($(quoted_type (ctx, ty))) ]>
  
      | <[ type: out $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.T_out ($(quoted_type (ctx, ty))) ]>
  
      | <[ type: $from -> $to ]> =>
        <[ Nemerle.Compiler.Parsetree.T_fun ($(quoted_type (ctx, from)),
                                             $(quoted_type (ctx, to))) ]>
  
      | <[ type: void ]> =>
        <[ Nemerle.Compiler.Parsetree.T_void () ]>
  
      | <[ type: .. $args ]> =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(make_quoted_list (quotedc_type, args))) ]>

      | <[ type: array < $ty > ]> =>
        <[ Nemerle.Compiler.Parsetree.T_array ($(quotedc_type (ty))) ]>

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | T_spliced (e) => e

      | T_spliced_special (ty, val) =>
          match (ty) {
            | "var" => 
              <[ Nemerle.Compiler.Parsetree.T_app
                  (Nemerle.Compiler.Parsetree.SS_string
                   (Nemerle.Compiler.Parsetree.Name ($val)), []) ]>
            | _ =>
              Util.ice ("unsupported type of spliced special token in type")
          }

      | T_infer =>
        <[ Nemerle.Compiler.Parsetree.T_infer () ]>

      | T_type_list (ar) =>
        <[ Nemerle.Compiler.Parsetree.T_prod ($(decompose_type_list (quotedc_type, ar))) ]>
    } 
  }

  /// create construction tree of given call parameter
  public quoted_param (ctx : CTX, p : Parm) : Expr
  {
    match (p) {
      | <[ parameter: $name = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Parm (false, 
                                            $(quoted_expr (ctx, expr)), 
                                            $(quoted_sstring (name))) ]>
      | <[ parameter: ref $name = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Parm (true, 
                                            $(quoted_expr (ctx, expr)), 
                                            $(quoted_sstring (name))) ]>
    }
  }

  public quoted_case_guard (ctx : CTX, pair : Pattern * option <Expr>) : Expr
  {
    match (pair) {
      | <[ caseguard: $pat when $gu ]> => 
        <[ ($(quoted_pattern (ctx, pat)), 
            Nemerle.Core.Some ($(quoted_expr (ctx, gu)))) ]>
      | <[ caseguard: $pat ]> =>
        <[ ($(quoted_pattern (ctx, pat)), Nemerle.Core.None ()) ]>
    }
  }

  public quoted_case (ctx : CTX, cas : Match_case) : Expr
  {
    def <[ case: | ..$guards => $expr ]> = cas;
    def quotedc_pattern (x) { quoted_pattern (ctx, x) };
    def quotedc_case_guard (x) { quoted_case_guard (ctx, x) };
    
    match (guards) {
      | [(P_patt_list (args), None)] =>
        <[ Nemerle.Compiler.Parsetree.Match_case ($(decompose_pattern_list (quotedc_pattern,
             args)), $(quoted_expr (ctx, expr))) ]>
      | _ =>
        <[ Nemerle.Compiler.Parsetree.Match_case ($(make_quoted_list (quotedc_case_guard, 
             guards)), $(quoted_expr (ctx, expr))) ]>
    }
  }

  public quoted_fparam (ctx : CTX, p : Fun_parm) : Expr
  {
    match (p) {
      | <[ funparm: $name : $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ctx, ty)),
                                                Nemerle.Compiler.Parsetree.FP_normal ()) ]>
      | <[ funparm: params $name : $ty ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
                                                $(quoted_type (ctx, ty)),
                                                Nemerle.Compiler.Parsetree.FP_params ()) ]>
      | <[ funparm: $name : $ty = $expr ]> =>
        <[ Nemerle.Compiler.Parsetree.Fun_parm ($(quoted_sstring (name)),
             $(quoted_type (ctx, ty)),
             Nemerle.Compiler.Parsetree.FP_default ($(quoted_expr (ctx, expr)))) ]>
    }
  }

  quoted_tparms (ctx : CTX, tyvars : list <string>, 
                 constraints : list <Constraint>) : Expr 
  {
    def quoted_constr (c : Constraint) {
      <[ Nemerle.Compiler.Parsetree.Constraint ($(c.tyvar : string),
                                                $(quoted_type (ctx, c.ty))) ]>
    };
    def quoted_string (s) { <[ $(s : string) ]> };
    def quotedc_expr (x) { quoted_expr (ctx, x) };

    match (constraints) {
      | [("", T_prod ([T_void,T_spliced (e)]))] =>
        <[ Nemerle.Compiler.Parsetree.Typarms ($(make_quoted_list (quoted_string, 
                                                                   tyvars)),
                                               $(decompose_list (quotedc_expr, E_spliced (e)))) ]>

      | [("", T_prod ([T_spliced (e1), T_spliced (e2)]))] =>
        <[ Nemerle.Compiler.Parsetree.Typarms ($(decompose_list (quotedc_expr, E_spliced (e1))),
                                               $(decompose_list (quotedc_expr, E_spliced (e2)))) ]>

      | ("", T_prod ([T_spliced (e), T_void])) :: where_cts =>
        <[ Nemerle.Compiler.Parsetree.Typarms ($(decompose_list (quotedc_expr, E_spliced (e))),
                                               $(make_quoted_list (quoted_constr, 
                                                                   where_cts))) ]>

      | _ =>
        <[ Nemerle.Compiler.Parsetree.Typarms ($(make_quoted_list (quoted_string, 
                                                                   tyvars)),
                                               $(make_quoted_list (quoted_constr, 
                                                                   constraints))) ]>
    }
  }

  make_quoted_fundecl (ctx : CTX, parms : list<Fun_parm>, 
                       qtparms : Expr, ty : Type, qname : Expr, body : Expr) : Expr
  {
    def qparms =
      match (parms) {
        | [{ name = SS_string ({ id = "" }); ty = <[ type: void ]>; 
             attr = FP_default (e); }] =>
          decompose_list (fun (x) { quoted_expr (ctx, x) }, e)
        | _ =>
          make_quoted_list (fun (x) { quoted_fparam (ctx, x) }, parms)
      };
    def qbody = quoted_expr (ctx, body);
    def qtype = quoted_type (ctx, ty);
    <[ Nemerle.Compiler.Parsetree.Function_decl 
        (Nemerle.Compiler.Parsetree.Fun_header ($qtparms, $qname, $qtype, $qparms), 
         $qbody)
    ]>
  }

  public quoted_fundecl (ctx : CTX, d : Function_decl) : Expr
  {
    def <[ fundecl: $name < ..$typarms> (..$args) : $ty 
             where ..$tyconstrs $body ]> = d;
    def qtparms = quoted_tparms (ctx, typarms, tyconstrs);
    def qname = quoted_sstring (name);
    make_quoted_fundecl (ctx, args, qtparms, ty, qname, body)
  }

  public quoted_expr (ctx : CTX, expr : Expr) : Expr 
  {
    def quotedc_expr (x) { quoted_expr (ctx, x) };
    
    match (expr) {
      | <[ $(id : var) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_ref ($(quoted_name (id, ctx.macro_context))) ]>

      | <[ $obj . $mem ]> => 
        <[ Nemerle.Compiler.Parsetree.E_member ($(quotedc_expr (obj)),
                                                $(quoted_sstring (mem))) ]>

      | <[ $func (.. $parms) ]> =>
        match (parms) {
          | [ { expr = E_expr_list (args) }] =>
            <[ Nemerle.Compiler.Parsetree.E_call ($(quoted_expr (ctx, func)),
                                                  $(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_call ($(quotedc_expr (func)), 
               $(make_quoted_list (fun (x) { quoted_param (ctx, x) }, parms))) ]>
        }

      | <[ $target <- $source ]> =>
        <[ Nemerle.Compiler.Parsetree.E_assign ($(quoted_expr (ctx, target)), 
                                                $(quoted_expr (ctx, source))) ]>

      | <[ def $name = $val ]> =>
        <[ Nemerle.Compiler.Parsetree.E_let ($(false : bool), 
                                             $(quoted_sstring (name)), 
                                             $(quoted_expr (ctx, val))) ]>

      | <[ mutable $name <- $val ]> =>
        <[ Nemerle.Compiler.Parsetree.E_let ($(true : bool),
                                             $(quoted_sstring (name)),
                                             $(quoted_expr (ctx, val))) ]>

      | <[ def (.. $elems) = $val ]> =>
        <[ Nemerle.Compiler.Parsetree.E_letpat ($(quoted_pattern (ctx, 
                                                                  P_tuple (elems))), 
                                                $(quoted_expr (ctx, val))) ]>;

      | <[ def .. $funs ]> =>
        match (funs) {
          | [(_, E_expr_list (args))] =>
            <[ Nemerle.Compiler.Parsetree.E_letfun ($(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_letfun (
              $(make_quoted_list (fun (x) { 
                quoted_fundecl (ctx, x) }, funs))) ]>
        };

      | <[ fun < ..$typarms> (..$args) : $ty where .. $tyconstrs $body ]> =>
        def qtparms = quoted_tparms (ctx, typarms, tyconstrs);
        def qname = <[ Nemerle.Compiler.Parsetree.SS_string (
                         Nemerle.Compiler.Parsetree.Name ("")) ]>;
        def fdecl = make_quoted_fundecl (ctx, args, qtparms, ty, qname, body);
        <[ Nemerle.Compiler.Parsetree.E_lambda ($fdecl) ]>

      | <[ match ($expr) {.. $cases } ]> =>
        match (cases) {
          | [cas] when match (cas.patterns) { | [] => true | _ => false } =>
            match (cas.body) {
              | E_expr_list (e) =>
                <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (ctx, expr)), 
                     $(decompose_list (quotedc_expr, e))) ]>
              | _ =>
                Util.ice ("parser generated strange match_case")
            }
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_match ($(quoted_expr (ctx, expr)), 
                 $(make_quoted_list (fun (x) { quoted_case (ctx, x) }, 
                                     cases))) ]>
        }

      | <[ throw $exc ]> =>
        <[ Nemerle.Compiler.Parsetree.E_raise ($(quoted_expr (ctx, exc))) ]>

      | <[ try $body catch { $exn : $exn_ty => $handler } ]> => 
        def qbody = quoted_expr (ctx, body);
        <[ Nemerle.Compiler.Parsetree.E_try_with ($qbody, 
                                                  $(quoted_sstring (exn)),
                                                  $(quoted_type (ctx, exn_ty)), 
                                                  $(quoted_expr (ctx, handler))) ]>

      | <[ try $body finally $handler ]> =>
        <[ Nemerle.Compiler.Parsetree.E_try_finally ($(quoted_expr (ctx, body)), 
             $(quoted_expr (ctx, handler))) ]>

      | <[ () ]> => 
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_void ()) ]>

      | <[ null ]> => 
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_null ()) ]>

      | <[ $(val : int) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

      | <[ $(val : string) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

      | <[ $(val : float) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

      | <[ $(val : bool) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

      | <[ $(val : char) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

      | <[ this ]> =>
        <[ Nemerle.Compiler.Parsetree.E_this () ]>

      | <[ base ]> => 
        <[ Nemerle.Compiler.Parsetree.E_base () ]>

      | <[ typeof ($t) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_typeof ($(quoted_type (ctx, t))) ]>

      | <[ ( $expr :> $ty ) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_type_conversion ($(quoted_expr (ctx, expr)),
                 $(quoted_type (ctx, ty))) ]>

      | <[ ( $expr : $ty ) ]> =>
        <[ Nemerle.Compiler.Parsetree.E_type_enforcement ($(quoted_expr (ctx, expr)),
            $(quoted_type (ctx, ty))) ]>

      | <[ {.. $seq } ]> =>
        match (seq) {
          | [E_expr_list (seq)] =>
            <[ Nemerle.Compiler.Parsetree.E_sequence ($(decompose_list (quotedc_expr, seq))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_sequence ($(make_quoted_list (quotedc_expr, seq))) ]>
        }

      | <[ (.. $args) ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_tuple ($(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_tuple ($(make_quoted_list (quotedc_expr, args))) ]>
        }

      | <[ array [.. $args] ]> =>
        match (args) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_mkarray ($(decompose_list (quotedc_expr, 
                                                                       args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_mkarray ($(make_quoted_list (quotedc_expr, 
                                                                         args))) ]>
        }

      | <[ array (.. $sizes) ]> =>
        match (sizes) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_empty_array ($(decompose_list (quotedc_expr, args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_empty_array ($(make_quoted_list (quotedc_expr, sizes))) ]>
        }

      | <[ $obj [.. $args] ]> =>  
        match (args) {
          | [E_expr_list (args)] =>
            <[ Nemerle.Compiler.Parsetree.E_indexer ($(quotedc_expr (obj)),
                                                     $(decompose_list (quotedc_expr, 
                                                                       args))) ]>
          | _ =>
            <[ Nemerle.Compiler.Parsetree.E_indexer ($(quotedc_expr (obj)),
                                                     $(make_quoted_list (quotedc_expr, 
                                                                         args))) ]>
        }

      // rest of constructs must be in not quoted form, because they define
      // internal data structures
      | E_macrocall (name, parms) =>
        def quoted_syntax (s) {
          | SyntaxExpr (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxExpr ($(quoted_expr (ctx, body))) ]>
          | SyntaxPattern (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxPattern ($(quoted_pattern (ctx, 
                                                                           body))) ]>
          | SyntaxType (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxType ($(quoted_type (ctx, body))) ]>
          | SyntaxParm (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxParm ($(quoted_param (ctx, body))) ]>
          | SyntaxCase (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxCase ($(quoted_case (ctx, body))) ]>
          | SyntaxCaseGuard (body, guard) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxCaseGuard 
                 ($(quoted_case_guard (ctx, (body, guard)))) ]>
          | SyntaxFunDecl (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxFunDecl 
                 ($(quoted_fundecl (ctx, body))) ]>
          | SyntaxFunParm (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxFunParm 
                  ($(quoted_fparam (ctx, body))) ]>  
          | SyntaxTType (body) =>
            <[ Nemerle.Compiler.Parsetree.SyntaxTType ($(quoted_type (ctx, body))) ]>
        };

        <[ Nemerle.Compiler.Parsetree.E_macrocall
             ($(quoted_name (name, ctx.macro_context)),
              $(make_quoted_list (quoted_syntax, parms))) ]>

      | E_spliced (e) => e

      | E_spliced_patt => expr

      | E_spliced_special (ty, val) =>
        match (ty) {
          | "var" => <[ Nemerle.Compiler.Parsetree.E_ref ($val) ]>
          | "dyn" => <[ Nemerle.Compiler.Parsetree.E_ref (Nemerle.Compiler.Parsetree.Name
                                                          ($val)) ]>
          | "int" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_int ($val)) ]>
          | "string" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_string ($val)) ]>
          | "bool" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_bool ($val)) ]>
          | "char" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_char ($val)) ]>
          | "float" => 
            <[ Nemerle.Compiler.Parsetree.E_literal (Nemerle.Compiler.L_float ($val)) ]>
          | "typed" => 
            <[ Nemerle.Compiler.Parsetree.E_typed_expr ($val) ]>
          | _ =>
            Util.ice ("unsupported type of spliced literal in expression")
        }

      | E_lambda =>
        Util.ice ("this kind of quoted fun () ... is not supported")
      | E_quoted => 
        Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed");
      | E_typed_expr => 
        Util.ice ("You've got beer from me for generating such a code...");
      | E_expr_list =>
        // print location
        Message.debug ("list of expression parameters outside of any construct");
        Util.ice ("List of expression parameters outside of any construct")
      | E_letpat => Util.ice ("Bad construction of E_letpat")
    }
  } // end quoted_expr

  /** transforms syntax tree of quoted pattern to its construction
      tree 
   */   
  public quoted_pattern (ctx : CTX, pat : Pattern) : Expr 
    {
      def quotedc_pattern (x) { quoted_pattern (ctx, x) };

      match (pat) {
        | <[ pattern: _ ]> => <[ Nemerle.Compiler.Parsetree.P_underscore () ]>

        | <[ pattern: $(name : var) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_variable ($(quoted_name (name, 0))) ]>

        | <[ pattern: ($pat) as $name ]> => 
          <[ Nemerle.Compiler.Parsetree.P_as ($(quoted_pattern (ctx, pat)), 
                                              $(quoted_sstring (name))) ]>

/* it seems to be impossible to be done, because we would have to write pattern, 
   which matches terms like Cons(x, Cons(y, Cons(z, xs))) into [x;y;z; ?]
        | <[ pattern: [..$elems] ]> =>
          match (elems) {
            | [P_patt_list (args)] => decompose_pattern_list (quoted_pattern, args)
            | _ =>
              make_quoted_list (quoted_pattern, elems)
          }
        | <[ pattern: [$elems] ]> =>
          match (elems) {
            | P_patt_list (args) => quoted_pattern (args)
            | _ =>
              def nl = <[ pattern : [] ]>;
              <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (SS_string ("Cons"))), 
                 $(quoted_pattern (P_tuple ([elems; nl])))) ]>
          }
 <[ pattern: Cons ($elems, Nil) ]>
*/

        | <[ pattern: (.. $args) ]> =>
          match (args) {
            | [P_patt_list (args)] =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(decompose_pattern_list (quotedc_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_tuple 
                   ($(make_quoted_list (quotedc_pattern, args))) ]>
          }
        
        | <[ pattern: {.. $args } ]> =>
          def quoted_named_pattern (patt : string * Pattern) : Expr
            {
              def (name, pat) = patt;
              <[ ($(name : string), $(quoted_pattern (ctx, pat))) ]>
            };
             
          match (args) {
            | [(_, P_patt_list (args))] =>
              <[ Nemerle.Compiler.Parsetree.P_record 
                   ($(decompose_pattern_list (quotedc_pattern, args))) ]>
            | _ =>
              <[ Nemerle.Compiler.Parsetree.P_record
                   ($(make_quoted_list (quoted_named_pattern, args))) ]>
          }

        | <[ pattern: $name (.. []) ]> =>
          match (name) {
              | SS_string ({ id = s }) => printf ("empty args %s\n", s);
              | _ => ()
          };
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                         Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        | <[ pattern: $name (.. $args) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (ctx, 
                                                           P_tuple (args)))) ]>

        | <[ pattern: $name {.. $args} ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
                                                $(quoted_pattern (ctx, 
                                                          P_record (args)))) ]>

        | <[ pattern: $(val : int) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($(val : int))) ]>

        | <[ pattern: $(val : string) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($(val : string))) ]>

        | <[ pattern: $(val : bool) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($(val : bool))) ]>

        | <[ pattern: $(val : float) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($(val : float))) ]>

        | <[ pattern: $(val : char) ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($(val : char))) ]>

        | <[ pattern: () ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_void ()) ]>

        | <[ pattern: null ]> =>
          <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_null ()) ]>

        | <[ pattern: $name _ ]> =>
          <[ Nemerle.Compiler.Parsetree.P_cons ($(quoted_sstring (name)), 
             Nemerle.Compiler.Parsetree.P_underscore ()) ]>

        // rest of constructs must be in not quoted form, because they define
        // internal data structures
        | P_spliced (e) => e

        | P_spliced_special (ty, val) =>
          match (ty) {
            | "var" => <[ Nemerle.Compiler.Parsetree.P_variable ($val) ]>
            | "int" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_int ($val)) ]>
            | "string" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_string ($val)) ]>
            | "bool" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_bool ($val)) ]>
            | "char" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_char ($val)) ]>
            | "float" => 
              <[ Nemerle.Compiler.Parsetree.P_literal (Nemerle.Compiler.L_float ($val)) ]>
            | _ =>
              Util.ice ("unsupported type of spliced literal in pattern")
          }

        | P_quoted =>
          Message.fatal_error ("compound of several <[ ... ]> macro scopes is not allowed")
        | P_patt_list =>
          Message.fatal_error 
            ("Variable pattern arguments list appears outside of proper construct")
        | P_cons (_, _) =>
          Util.ice ("Bad constructed P_cons")
      } 
    }

  /** transforms given expression (which is supposed to be generated from
      quoted expression) into pattern 
   */    
  public expr_to_pattern (exp : Expr) : Pattern 
  {
    def flat_member (obj) {
      def collect_member (obj : Expr, acc) {
        match (obj) {
          | <[ $(id : dyn) ]> => id :: acc
          | <[ $head.$(id : dyn) ]> => collect_member (head, id :: acc)
          | _ => Util.ice ("Corrupted member while flatting member expr -> pattern")
        }
      };
      NString.Concat (".", collect_member (obj, []))
    };

    match (exp) {
      | <[ $(id : var) ]> => <[ pattern: $(id : var) _ ]>
      | <[ $constr (.. $pars) ]> =>
        def con = flat_member (constr);
        match (GlobalEnv.LookupExactType (con)) {
          | Some (tcon) =>
            def convert_params (pars : list <Parm>, mems : list<IMember>,
                                acc : list <string * Pattern>) : Pattern {
              match ((pars, mems)) {
                | ([], []) => 
                  match (acc) {
                    | [] => P_underscore ()
                    | _ => P_record (List.Rev (acc))
                  }
                | (_, m :: ms) when
                  !m.GetDeclaringTycon ().SameAs (tcon) ||
                  match (m.GetKind ()) {
                    | MK_field => false
                    | _ => true
                  }
                  || m.IsStatic ()
                  => convert_params (pars, ms, acc)
                | (<[ parameter: $expr ]> :: xs, m :: ms) =>
                  convert_params (xs, ms, (m.GetName (), expr_to_pattern (expr)) :: acc)

                | ([], _ :: _) => convert_params ([], [], acc)
                  
                | (_ :: _, []) =>
                  Message.fatal_error ("Number of supported patameters is too large")
                | _ => Util.ice ("strange parameters generated from quoting")
              }
            };
            
            match (tcon.GetTydecl ()) {
              | Typedtree.TD_variant_option =>
                P_cons (SS_string (Name (con)),
                        convert_params (pars, tcon.GetMembers (), []))                  
              | Typedtree.TD_class  =>
                // we lose informations about constructor here, but as it's 
                // compiler internal computation we can ignore it
                match (con) {
                  | "Nemerle.Compiler.Parsetree.Name" =>
                    match (pars) {
                      | <[ parameter: $expr ]> :: _ =>
                        <[ pattern: { id = $(expr_to_pattern (expr)) } ]>
                      | _ =>
                        Util.ice ("wrong or not enough parameters supplied to Name class")
                    }
                  | _ =>
                    convert_params (pars, tcon.GetMembers (), [])
                }
              | _ =>
                Util.ice ("expression generated from quotation has nor variant"
                          + " neither class constructor")
            }
          | None =>
            Util.ice ("expression generated from quotation has broken constructor")
        }

      | <[ (..$elems) ]> => <[ pattern: (..$(List.Map (elems, expr_to_pattern))) ]>

      | E_literal (lit) => P_literal (lit)

      | E_spliced_patt (p) => p

      | _ => 
        Util.ice ("Bad constructed quoted expression in pattern matching")
    }
  }

  // GENERATION OF MACRO CLASSES SECTION

  /** Generate class implementing interface [MacroRegistry.IMacro], which
      encapsulates execution of macro. Created methods are:
      [Run] for running macro,
      [GetName] for retrieving its name, 
      [SyntaxExtension] for retrieving syntax extension it defines,
      [CallTransform] for transforming supported call parameters to
        description taken by [Run] method
   */
  public GenerateMacroClass (attrs : list <Modifier>, header : Fun_header, 
                             synt : list <Expr>, expr : Expr) : Type_decl
  {
    def name = 
      match (header.name) {
        | SS_string ({ id = n }) => n
        | _ => Message.fatal_error ("spliced name in macro name is not allowed")
      };

    // walk through parameters given to macro, extract their names,
    // note type names, control if they correspond to Nemerle grammar,
    // handle variable amount of parameters and default values
    // create code decomposing passed parameters if needed
    def analyze_params (pars : list <Fun_parm>, acc, accs, accmp,
                        defaults : list<Name * Expr>, types : list<string>) 
                        : list <Pattern> * list <Expr> * list <MacroParm>
    {
      // build pattern for list from list of patterns
      def roll (li, bu) {
        match (li) {
          | [] => bu
          | x::xs => roll (xs, <[ pattern: $x :: $bu ]>)
        }
      };
      // build expression for list from list of expressions
      def roll_expr (li, bu) {
        match (li) {
          | [] => bu
          | (va, d)::xs => roll_expr (xs, <[ { def $(va : var) = $d; $bu } ]>)
        }
      };

      // handle case of standard (not params or with default value) parameter
      // decompose handled types, note them and build pattern matching
      // parameter's expression
      def normal_parm (t, va) {
        match (t) {
          | T_infer 
          | <[ type: expr ]> => 
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr ($(va : var)) ]>, 
             "expr" :: types, MP_expr ())
          | <[ type: parm ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxParm ($(va : var)) ]>, 
             "parm" :: types, MP_parm ())
          | <[ type: funparm ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxFunParm ($(va : var)) ]>, 
             "funparm" :: types, MP_parm ())
          | <[ type: string ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr (Nemerle.Compiler.
             Parsetree.E_literal (Nemerle.Compiler.L_string ($(va : var)))) ]>,
             "string" :: types, MP_expr ())
          | <[ type: int ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr (Nemerle.Compiler.
             Parsetree.E_literal (Nemerle.Compiler.L_int ($(va : var)))) ]>,
             "int" :: types, MP_expr ())
          | <[ type: bool ]> =>
            (<[ pattern: Nemerle.Compiler.Parsetree.SyntaxExpr (Nemerle.Compiler.
             Parsetree.E_literal (Nemerle.Compiler.L_bool ($(va : var)))) ]>,
             "bool" :: types, MP_expr ())
          | _ =>
            Message.fatal_error ("type not supported")
        }
      };

      // create list of match cases (patterns and expressions) containing
      // cases for default values of parameters, add expressions defining
      // missed parameters according to those default values
      def traverse_patterns (pattss, defaults, defsrest, accpat, accexp) {
        match ((pattss, defaults)) {
          | ([], _) => (accpat, accexp)
          | (patts :: xss, []) =>
            traverse_patterns (xss, [], [], roll (patts, <[ pattern: [] ]>) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
          | (patts :: xss, d :: ds) =>
            def newdrest = d :: defsrest;
            traverse_patterns (xss, ds, newdrest, 
                               roll (patts, <[ pattern: [] ]>) :: accpat,
                               roll_expr (defsrest, expr) :: accexp)
        }
      };

      // iterate through parameters
      match (pars) {
        | [] => 
          // we have fixed amount of parameters, so there is always
          // case, which triggers error, handle it
          def plist = NString.Concat (", ", List.Rev (types));
          def warn = <[ Nemerle.Compiler.Message.fatal_error ("macro `" 
            + $(name : string) + "' expects following list of arguments: (" + 
            $(plist : string) + ")") ]>;
          def (pats, exps) =
            traverse_patterns (acc :: accs, defaults, [], 
                               [ <[ pattern: _ ]> ], [warn]);
          (pats, exps, List.Rev (accmp))

        | { name = SS_string (va); ty = t; attr = at } :: xs =>
          match (at) {
            // variable amount of parameters is handled here
            | FP_params =>
              def (initpat, initex) =
                match (acc) {
                  // if there are some elemnts other than out 'va', then this
                  // pattern won't be exchaustive, and we must supply error msg
                  | _ :: _ =>
                    def plist = NString.Concat (", ", 
                                                List.Rev ("params array" 
                                                          :: types));
                    def warn = <[ Nemerle.Compiler.Message.fatal_error ("macro `"
                      + $(name : string) + "' expects following list of arguments: ("
                      + $(plist : string) + ")") ]>;
                    ([ <[ pattern: _ ]> ], [warn])
                  | _ =>
                    ([], [])
                };
              match (t) {
                | <[ type: array <parm> ]> =>
                  def tmpvar = NewSymbol ();
                  def (pats, exps) =
                    traverse_patterns (accs, defaults, [], 
                      roll (acc, <[ pattern: $(tmpvar : var) ]>) :: initpat,
                        <[
                          def $(va : var) =
                            Nemerle.Collections.List.Map ($(tmpvar : var), 
                                      fun (p : Nemerle.Compiler.Parsetree.SyntaxElement) {
                                        | Nemerle.Compiler.Parsetree.SyntaxParm (e) => e
                                        | _ => Message.fatal_error ("ice")
                                      });
                          $expr
                        ]> :: initex);
                  (pats, exps, List.Rev (MP_parms () :: accmp))

                | <[ type: array <expr> ]> =>
                  def tmpvar = NewSymbol ();
                  def (pats, exps) =
                    traverse_patterns (accs, defaults, [], 
                      roll (acc, <[ pattern: $(tmpvar : var) ]>) :: initpat,
                      <[ 
                        def $(va : var) = 
                          Nemerle.Collections.List.Map ($(tmpvar : var), 
                                    fun (p : Nemerle.Compiler.Parsetree.SyntaxElement) { 
                                      | Nemerle.Compiler.Parsetree.SyntaxExpr (e) => e
                                      | _ => Message.fatal_error ("ice") 
                                    });
                        $expr
                      ]> :: initex);
                  (pats, exps, List.Rev (MP_exprs () :: accmp))
 
                | _ =>
                  Message.fatal_error ("only array of expr or parm are " +
                                       "supported in params")
              }

            // parameter with default value
            | FP_default (e) =>
              match (normal_parm (t, va)) {
                | (p, str :: strs, mp) =>
                  analyze_params (xs, p :: acc, acc :: accs, mp :: accmp, 
                    (va, e) :: defaults, str + "(opt)" :: strs)
                | _ => Util.ice ("normal_parm returned empty types list")
              }
            | FP_normal =>
              match (defaults) {
                | [] =>
                  def (p, str, mp) = normal_parm (t, va);
                  analyze_params (xs, p :: acc, accs, mp :: accmp, defaults, str)
                | _ =>
                  Message.fatal_error ("parameters with default values must not"
                                       + " be mixed with normal")
              }
          }
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro parameters")
      }    
    };

    // creates match caces from pairs of pattern and expression
    def consolide_cases (pats, exps, acc) {
      match ((pats, exps)) {
        | ([], []) => acc
        | (x :: xs, y :: ys) => 
          consolide_cases (xs, ys, <[ case: $x => $y ]> :: acc)
        | _ => Util.ice ()
      }
    };


    // store positions and types of all parameters accessed by their names
    def mapparams (pars : list <Fun_parm>, n, hash : Hashtable <string, int * Type>) {
      match (pars) {
        | [] => hash
        | { name = SS_string ({ id = x }); ty = t } :: xs => 
          if (hash.Contains (x)) 
            Message.fatal_error ("parameter names cannot repeat")
          else
            hash.Add (x, (n, t)); mapparams (xs, n + 1, hash)
        | { name = SS_spliced_expr } :: _ => Util.ice ("spliced in macro params")
      }
    };
    def paramsmap = mapparams (header.parms, 0, Hashtable ());

    // if syntax extending section of macro exists, analyze all tokens and
    // permutation of parameters in its definition
    def analyze_syntax (toks, acc, positacc) {
      match (toks) {
        | [] => 
          // we have reached end of syntax definition, reverse accumulator
          // and return stored tokens and parameters' positions
          match (List.Rev (acc)) {
            | Parser.GE_keyword (key) :: rules =>
              ("_N_" + name + "_call", key, rules, positacc)

            // if there was no syntax definition
            | [] => (name, "", [], [])
            | _ => Message.fatal_error 
                     ("first token of syntax definition must be keyword")
          }
        | <[ $(x : string) ]> :: xs when Lexer.IsKeyword (x) =>
          analyze_syntax (xs, Parser.GE_keyword (x) :: acc, positacc)

        | <[ $(x : string) ]> :: xs when Lexer.IsOperator (x) =>
          analyze_syntax (xs, Parser.GE_operator (x) :: acc, positacc)

        | <[ $(x : dyn) ]> :: xs =>
          match (paramsmap.Get (x)) {
            | Some ((pos, ty)) =>
              paramsmap.Remove (x);
              def grammar_token =
                match (ty) {
                  | <[ type: parm ]> => Parser.GE_parm ()
                  | <[ type: funparm ]> => Parser.GE_funparm ()
                  | <[ type: array <parm> ]> => Parser.GE_parm_list (",")
                  | <[ type: array <expr> ]> => Parser.GE_expression_list (",")
                  | _ => Parser.GE_expression ()
                };
              analyze_syntax (xs, grammar_token :: acc, pos :: positacc)
            | None =>
              Message.fatal_error ("parameters from syntax description doesn't"
                                   + " match macro's")
          }
        | _ => Message.fatal_error ("unsupported syntax token")
      }
    };

    // lifted list of grammar elements
    def roll_gramm_els (l) {
      match (l) {
        | x :: xs =>
          def exp = roll_gramm_els (xs);
          match (x) {
            | Parser.GE_operator (name) =>
              <[ Nemerle.Compiler.Parser.GE_operator ($(name : string)) :: $exp ]>
            | Parser.GE_keyword (name) =>
              <[ Nemerle.Compiler.Parser.GE_keyword ($(name : string)) :: $exp ]>
            | Parser.GE_expression =>
              <[ Nemerle.Compiler.Parser.GE_expression () :: $exp ]>
            | Parser.GE_block =>
              <[ Nemerle.Compiler.Parser.GE_block () :: $exp ]>
            | Parser.GE_expression_list (sep) =>
              <[ Nemerle.Compiler.Parser.GE_expression_list ($(sep : string)) :: $exp ]>
            | Parser.GE_parm_list (sep) =>
              <[ Nemerle.Compiler.Parser.GE_parm_list ($(sep : string)) :: $exp ]>
            | Parser.GE_parm  =>
              <[ Nemerle.Compiler.Parser.GE_parm () :: $exp ]>
            | Parser.GE_funparm =>
              <[ Nemerle.Compiler.Parser.GE_funparm () :: $exp ]>
          }
        | [] => <[ [] ]>
      }
    };
    def roll_ints (l) {
      match (l) {
        | x :: xs =>
          <[ $(x : int) :: $(roll_ints (xs)) ]>
        | [] => <[ [] ]>
      }
    };

    // build SyntaxExtension method
    def (callname, key, rules, positions) = analyze_syntax (synt, [], []);
    def syntHeader =
      Fun_header (header.loc, SS_string (Name ("SyntaxExtension")), 
                  <[ type: string * list <Nemerle.Compiler.Parser.GrammarElement> 
                           * list <int> ]>,
                  []);
    def syntBody = <[ ($(key : string), $(roll_gramm_els (rules)), 
                       $(roll_ints (positions))) ]>;
    def syntFunc = 
      M_function (header = syntHeader, 
                  name = "SyntaxExtension",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.SyntaxExtension"]), 
                  body = FB_parsed_expr (syntBody));

    def (macro_patts, macro_exprs, macro_parms) = 
      analyze_params (header.parms, [], [], [], [], []);
    def macro_cases = List.Rev (consolide_cases (macro_patts, macro_exprs, []));

    // build method Run running macro's body
    def runHeader =
      Fun_header (header.loc, SS_string (Name ("Run")), 
                  <[ type: Nemerle.Compiler.Parsetree.Expr ]>,
                  [Fun_parm (header.loc, SS_string (Name ("_N_ctx")), 
                             <[ type: Nemerle.Compiler.Tyexpr.CTX ]>,
                             FP_normal ()),
                   Fun_parm (header.loc, SS_string (Name ("_N_parms")), 
                             <[ type: list <Nemerle.Compiler.Parsetree.SyntaxElement> ]>,
                             FP_normal ())]);
    def runBody = <[ match ($("_N_parms" : dyn)) { ..$macro_cases } ]>;

    def runFunc = M_function (header = runHeader, 
                              name = "Run",
                              modifiers = [],
                              loc = header.loc,
                              kind = FK_method (["Nemerle.Compiler.IMacro.Run"]), 
                              body = FB_parsed_expr (runBody));
   
    // create decision tree for transformation of supported call
    // parameters to our SyntaxElement description
    def (trans_p, trans_r) = (NewSymbol (), NewSymbol ());
    def create_transform_tree (parms) {
      | MP_parm :: xs =>
        <[ match ($(trans_p : var)) {
             | x :: $(trans_p : var) =>
               $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxParm (x) 
                 :: $(trans_r : var);
               $(create_transform_tree (xs))
             | [] => ()
           }
        ]>
      | MP_expr :: xs =>
        <[ match ($(trans_p : var)) {
             | { expr = x } :: $(trans_p : var) =>
               $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxExpr (x) 
                 :: $(trans_r : var);
               $(create_transform_tree (xs))
             | [] => ()
           }
        ]>
      | [MP_exprs] =>
        <[ def app_expr (l : list <Nemerle.Compiler.Parsetree.Parm>) {
             match (l) {
               | { expr = x } :: xs => 
                 $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxExpr (x) 
                   :: $(trans_r : var);
                 app_expr (xs)
               | [] => ()
             }
           };
           app_expr ($(trans_p : var))
        ]>
      | [MP_parms] =>
        <[ def app_par (l) {
             match (l) {
               | x :: xs => 
                 $(trans_r : var) <- Nemerle.Compiler.Parsetree.SyntaxParm (x) 
                   :: $(trans_r : var);
                 app_par (xs)
               | [] => ()
             }
           };
           app_par ($(trans_p : var))
        ]>

      | [] => <[ () ]>
      | _ => Util.ice ("corrupted macro parameters")
    };
    // build CallTransform method
    def calltrans_body = <[ 
      mutable $(trans_r : var) <- [];
      $(create_transform_tree (macro_parms));
      Nemerle.Collections.List.Rev ($(trans_r : var));
    ]>;
    def calltrans_header =
      Fun_header (header.loc, SS_string (Name ("CallTransform")), 
                  <[ type: list <Nemerle.Compiler.Parsetree.SyntaxElement> ]>,
                  [Fun_parm (header.loc, SS_string (trans_p), 
                             <[ type: list <Nemerle.Compiler.Parsetree.Parm> ]>,
                             FP_normal ())]);
    def calltransFunc = 
      M_function (header = calltrans_header, 
                  name = "CallTransform",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.CallTransform"]), 
                  body = FB_parsed_expr (calltrans_body));

    // build GetName fuction for macro class
    def getnameFunc = 
      M_function (header = Fun_header (header.loc, SS_string (Name ("GetName")), 
                                       <[ type: string ]>, []),
                  name = "GetName",
                  modifiers = [],
                  loc = header.loc,
                  kind = FK_method (["Nemerle.Compiler.IMacro.GetName"]),
                  body = FB_parsed_expr (<[ $(callname : string) ]>));

    def thisFunc =
      M_function (header = Fun_header (header.loc, SS_string (Name (".ctor")), 
                                       <[ type: void ]>, []), 
                  name = ".ctor",
                  modifiers = [Mod_public ()],
                  loc = header.loc,
                  kind = FK_ctor (), 
                  body = FB_parsed_expr (<[ () ]>));

    // build macro class
    def td = TD_class ([syntFunc, calltransFunc, runFunc, thisFunc, getnameFunc]);
    td.modifiers <- Mod_macro () :: Mod_public () :: attrs;
    td.name <- NewSymbol ().id;
    td.t_extends <- [ <[ type: Nemerle.Compiler.IMacro ]> ];
    td.typarms <- Typarms ([],[]);
    td
  }

  public CreatePermutingFunction (positions : list <int>) 
  : list <SyntaxElement> -> list <SyntaxElement>
  {
    def len = List.Length (positions);
    fun (li) {
      def take_first (n, l, acc) {
        match ((n, l)) {
          | (0, _) => (List.Rev (acc), l)
          | (_, []) => Util.ice ("too few parameters")
          | (n, x :: xs) =>
            take_first (n - 1, xs, x :: acc)
        }
      };
      def pararr = (System.Array.CreateInstance (typeof (SyntaxElement), len) 
                    :> array <SyntaxElement>);
      mutable m <- 0;
      def loop (l, ps) {
        match ((l, ps)) {
          | (x :: xs, [p]) =>
            pararr[p] <- x;
            loop (xs, [])
          | (x :: xs, p :: pp) =>
            if (p == len - 1) {
              def (rtail, rfront) = take_first (len - m - 1, 
                                                List.Rev (xs), []);
              pararr[p] <- x;
              loop (List.Append (List.Rev (rtail), List.Rev (rfront)), pp)
            }
            else {
              pararr[p] <- x;
              m <- m + 1;
              loop (xs, pp)
            }
          | (xs, []) => List.Append (List.FromArray (pararr), xs)
          | ([], _) => Util.ice ("too few parameters")
        }
      };
      loop (li, positions)
    }
  }

  // PRETTY PRINTING TOOLS SECTION

  public PrintExpr (ctx : option<CTX>, expr : Expr, empty : string) : void 
  {
    def expr = 
      match (ctx) {
        | Some (c) => MacroRegistry.expand_macro (c, expr)
        | _ => expr
      };

    def print_tparms (pars) {
      | [] => ()
      | [p] => printf ("<%s>", p)
      | p :: ps =>
        printf ("<%s", p);
        List.Iter (ps, fun (x) { printf (", %s", x) });
        printf (">")
    };

    def print_tconstraints (cts : list <Constraint>) {
      | [] => ()
      | x :: xs =>
        printf ("where %s : ", x.tyvar); PrintType (x.ty);
        print_tconstraints (xs)
    };

    def print_funparms (fps) {
      def print_funparm (p : Fun_parm) {
        | <[ funparm: $(name : var) : $ty ]> =>
          printf ("%s : ", name.id); PrintType (ty)
          
        | <[ funparm: params $(name : var) : $ty ]> =>
          printf ("params %s : ", name.id); PrintType (ty)
          
        | <[ funparm: $(name : var) : $ty = $expr ]> =>
          printf ("params %s : ", name.id); PrintType (ty);
          printf (" = "); PrintExpr (ctx, expr, empty)

        | _ => printf ("spliced funparm name")
      };

      match (fps) {
        | [] => ()
        | [p] => print_funparm (p);
        | p :: ps =>
          print_funparm (p);
          List.Iter (ps, fun (x) { printf (", "); print_funparm (x) });
      }
    };
      
    match (expr) {
      | <[ $(id : var) ]> => 
        printf ("%s", id.id)

      | <[ $obj . $(mem : var) ]> => 
        PrintExpr (ctx, obj, empty); printf (".%s", mem.id)

      | <[ [] ]> => printf ("[]")

      | <[ $x :: $xs ]> =>
        PrintExpr (ctx, x, empty);  
        printf (" :: "); PrintExpr (ctx, xs, empty)

      | <[ $func (.. $parms) ]> =>
        def print_params (pars) {
          def print_parm (p : Parm) {
            match (p) {
              | <[ parameter: $(name : var) = $expr ]> =>
                unless (name.id == "") printf ("%s = ", name.id);
                PrintExpr (ctx, expr, empty + "  ")
              | <[ parameter: ref $(name : var) = $expr ]> =>
                unless (name.id == "") printf ("%s = ", name.id);
                PrintExpr (ctx, expr, empty + "  ")
              | _ => Message.error ("spliced in PrintExpr")
            }
          };
          match (pars) {
            | [] => ()
            | [x] => print_parm (x)
            | x :: xs =>
              print_parm (x); printf (", "); print_params (xs)
          }
        };

        PrintExpr (ctx, func, empty); printf (" (");
        print_params (parms); printf (")");

      | <[ $target <- $source ]> =>
        PrintExpr (ctx, target, empty); printf (" <- ");
        PrintExpr (ctx, source, empty);

      | <[ def $(name : var) = $val ]> =>
        printf ("def %s = ", name.id);
        PrintExpr (ctx, val, empty)

      | <[ mutable $(name : var) <- $val ]> =>
        printf ("mutable %s = ", name.id); PrintExpr (ctx, val, empty)

      | <[ def (.. $elems) = $val ]> =>
        printf ("def ("); 
        List.Iter (elems, fun (x) { PrintPattern (x); printf ("; ") });
        printf (") = ");
        PrintExpr (ctx, val, empty);

      | <[ match ($expr) {.. $cases } ]> =>
        def print_case (c : Match_case) {
          def print_guard (g : Pattern * option <Expr>) {
            match (g) {
              | <[ caseguard: $pat when $e ]> =>
                printf ("\n%s| ", empty + "  ");
                PrintPattern (pat);
                printf (" when ");
                PrintExpr (ctx, e, empty + "    ")
              | <[ caseguard: $pat ]> =>
                printf ("\n%s| ", empty + "  "); 
                PrintPattern (pat);
            }
          };

          def <[ case: | ..$guards => $expr ]> = c;
          List.Iter (guards, print_guard);
          printf (" => \n%s", empty + "    ");
          PrintExpr (ctx, expr, empty + "    ")
        };

        printf ("match ("); 
        PrintExpr (ctx, expr, empty); printf (") {");
        List.Iter (cases, print_case);
        printf ("\n%s}", empty)

      | <[ throw $exc ]> =>
        printf ("throw "); PrintExpr (ctx, exc, empty);

      | <[ try $body catch { $(exn : var) : $exn_ty => $handler } ]> => 
        printf ("try\n%s  ", empty);
        PrintExpr (ctx, body, empty + "  ");
        printf ("\n%swith {\n%s", empty, empty + "  ");
        printf ("%s : ", exn.id);
        PrintType (exn_ty); printf ("=>\n%s", empty + "    ");
        PrintExpr (ctx, handler, empty + "    ")

      | <[ try $body finally $handler ]> =>
        printf ("try\n%s  ", empty);
        PrintExpr (ctx, body, empty + "  ");
        printf ("\n%sfinally\n%s  ", empty, empty);
        PrintExpr (ctx, handler, empty + "  ")

      | <[ () ]> => 
        printf ("()")

      | <[ null ]> => 
        printf ("null")

      | <[ $(val : int) ]> =>
        printf ("%d", val)

      | <[ $(val : string) ]> =>
        printf ("\"%s\"", val)

      | <[ $(val : float) ]> =>
        printf ("%f", val)

      | <[ $(val : bool) ]> =>
        if (val) printf ("true") else printf ("false")

      | <[ $(val : char) ]> =>
        printf ("%c", val);

      | <[ this ]> =>
        printf ("this")

      | <[ base ]> => 
        printf ("base")

      | <[ typeof ($t) ]> =>
        printf ("typeof ("); PrintType (t); printf (")")

      | <[ ( $expr :> $ty ) ]> =>
        printf ("("); PrintExpr (ctx, expr, empty); printf (" :> ");
        PrintType (ty); printf (")")

      | <[ ( $expr : $ty ) ]> =>
        printf ("("); PrintExpr (ctx, expr, empty); 
        printf (" : "); PrintType (ty); printf (")")

      | <[ {.. $seq } ]> =>
        printf ("{");
        List.Iter ( seq, fun (x) { 
          printf ("\n%s", empty + "  "); 
          PrintExpr (ctx, x, empty + "  "); 
          printf (";"); 
        });
        printf ("\n%s}", empty)

      | <[ (.. $args) ]> =>
        printf ("(");
        List.Iter (args, fun (x) { 
          printf (", "); 
          PrintExpr (ctx, x, empty) 
        });
        printf (")")

      | <[ array [.. $args] ]> =>
        printf ("array [");
        List.Iter (args, fun (x) { 
          printf ("; "); 
          PrintExpr (ctx, x, empty) 
        });
        printf ("]")

      | <[ $obj [.. $args] ]> =>
        PrintExpr (ctx, obj, empty);
        printf ("[");
        List.Iter (args, fun (x) { printf ("; "); PrintExpr (ctx, x, empty) });
        printf ("]")

      | <[ fun < ..$tparms> (..$args) where ..$tconstrs $body ]> =>
        printf ("fun "); print_tparms (tparms);
        printf (" ("); print_funparms (args); printf (") ");
        print_tconstraints (tconstrs); printf (" ");
        PrintExpr (ctx, body, empty)

      | <[ def ..$funs ]> =>
        def print_fun (f : Function_decl) {
          | <[ fundecl: $(name : var) < ..$tparms> (..$args) where .. $tconstrs $body ]> =>
            printf ("%s ", name.id); print_tparms (tparms);
            printf (" ("); print_funparms (args); printf (") ");
            print_tconstraints (tconstrs); printf (" ");
            PrintExpr (ctx, body, empty)
          | _ => printf ("spliced fun name")
        };
        
        printf ("def ");
        match (funs) {
          | [] => ()
          | [f] =>
            print_fun (f)
          | f :: fs =>
            print_fun (f);
            List.Iter (fs, fun (x) { printf ("\nand "); print_fun (x) })
        }

      | _ => printf ("other")
    }
  }

  public PrintExpr (ctx : option<CTX>, expr : Expr) : void
  {
    PrintExpr (ctx, expr, "");
    printf ("\n");
  }

  public PrintPattern (patt : Pattern) : void
  {
    match (patt) {
      | <[ pattern: _ ]> =>
        printf ("_")

      | <[ pattern: $(name : var) ]> =>
        printf ("%s", name.id)

      | <[ pattern: ($pat) as $(name : var) ]> => 
        printf ("("); PrintPattern (pat); 
        printf (") as %s", name.id)

      | <[ pattern: [] ]> => printf ("[]")

      | <[ pattern: $x :: $xs ]> => 
        PrintPattern (x); printf (" :: "); PrintPattern (xs)

      | <[ pattern: (.. $args) ]> =>
        printf ("(");
        List.Iter (args, fun (x) { PrintPattern (x); printf (", ") });
        printf (")")

      | <[ pattern: {.. $args } ]> =>
        def print_named_pattern (patt : string * Pattern) : void
          {
            def (name, pat) = patt;
            printf ("%s = ", name); PrintPattern (pat);
            printf ("; ")
          };
        printf ("{");
        List.Iter (args, print_named_pattern);
        printf ("}")

      | <[ pattern: $(name : var) (.. []) ]> =>
        printf ("%s", name.id)

      | <[ pattern: $(name : var) (.. $args) ]> =>
        printf ("%s (", name.id);
        List.Iter (args, fun (x) { PrintPattern (x); printf (", ") });
        printf (")");

      | <[ pattern: $(name : var) {.. $args} ]> =>
        printf ("%s {", name.id);
        def print_named_pattern (patt : string * Pattern) : void
          {
            def (name, pat) = patt;
            printf ("%s = ", name); PrintPattern (pat);
            printf ("; ")
          };
        List.Iter (args, print_named_pattern);
        printf ("}")

      | <[ pattern: $(val : int) ]> =>
        printf ("%d", val)

      | <[ pattern: $(val : string) ]> =>
        printf ("\"%s\"", val)

      | <[ pattern: $(val : bool) ]> =>
        if (val) printf ("true") else printf ("false")

      | <[ pattern: $(val : float) ]> =>
        printf ("%f", val)

      | <[ pattern: $(val : char) ]> =>
        printf ("%c", val)

      | <[ pattern: () ]> =>
        printf ("()")

      | <[ pattern: null ]> =>
        printf ("null")

      | <[ pattern: $(name : var) _ ]> =>
        printf ("%s", name.id)

      | _ => printf("other");
    }
  }

  public PrintType (ty : Type) : void 
  {
    match (ty) {
      | <[ type: $(tycon : var) < .. $args> ]> =>
        printf ("%s", tycon.id);
        def loop (l) {
          match (l) {
            | [x] => PrintType (x)
            | x::xs => PrintType (x); printf (" * "); loop (xs)
            | [] => Util.ice()
          }
        };
        match (args) {
          | [] => ()
          | _ => printf (" <"); loop (args); printf (">");
        }

      | <[ type: $(name : var) ]> =>
        printf ("%s", name);

      | <[ type: ref $ty ]> =>
        printf ("ref "); PrintType (ty);

      | <[ type: out $ty ]> =>
        printf ("out "); PrintType (ty);

      | <[ type: $from -> $to ]> =>
        PrintType (from); printf (" -> "); PrintType (to);

      | <[ type: void ]> =>
        printf ("void");

      | <[ type: .. $args ]> =>
        List.Iter (args, fun (x) { PrintType (x); printf (" * ") })

      | <[ type: array < $ty > ]> =>
        printf ("array <"); PrintType (ty); printf (">")

      | _ => printf ("other")
    }
  }
}
} // end ns
