using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace LRPEGCC
{
  [Record]
  internal class RuleRef : Located, IComparable[RuleRef]
  {
    [Accessor] id : string;

    public override ToString() : string
    {
      id
    }

    public override GetHashCode() : int
    {
      id?.GetHashCode()
    }

    public CompareTo(other : RuleRef) : int
    {
      StringComparer.Ordinal.Compare(this.id, other?.id)
    }

    [Nemerle.OverrideObjectEquals]
    public Equals(_ : RuleRef) : bool
    {
      | null => false
      | other => other.id == this.id
    }
  }

  [Record]
  internal variant RuleType : Located
  {
    | List   { ty : RuleType; }
    | Option { ty : RuleType; }
    | Tuple  { types : list[RuleType]; }
    | NType  { ty : FixedType; }
    | Chars
    | None
    | Void
    
    public override ToString() : string
    {
      match (this)
      {
        | List(ty)     => $<#List[$ty]#>
        | Option(ty)   => $<#$ty?#>
        | Tuple(types) => $<#(..$(types, ", "))#>
        | NType(ty)    => $<#$ty#> // We show this string in error message!
        | Chars        => "Chars"
        | None         => "None"
        | Void         => "Void"
      }
    }

    #region comparison and equalities

    public ToFixedType(manager : ManagerClass) : FixedType
    {
      match (this)
      {
        | List(ty)     => FixedType.Class(manager.Lookup("System.Collections.Generic.List", 1), [ty.ToFixedType(manager)])
        | Option(ty)   => FixedType.Class(manager.Lookup("Nemerle.Core.option", 1), [ty.ToFixedType(manager)])
        | Tuple(types) => FixedType.Tuple(types.Map(t => t.ToFixedType(manager)))
        | NType(ty)    => ty
        | Chars
        | None
        | Void         => manager.InternalType.Void
      }
    }

    [OverrideObjectEquals]
    public Equals(other : RuleType) : bool
    {
      Equals(other, (ty1, ty2) => ty1.Equals(ty2))
    }

    public Equals(other : RuleType, equals : FixedType * FixedType -> bool) : bool
    {
      match (this, other)
      {
        | (List(ty1), List(ty2))          => ty1.Equals(ty2)
        | (Option(ty1), Option(ty2))      => ty1.Equals(ty2)
        | (Tuple(types1), Tuple(types2))  => types1.ForAll2(types2, (x, y) => x.Equals(y))
        | (NType(ty1), NType(ty2))        => equals(ty1, ty2)
        | (Chars, Chars)
        | (None , None)
        | (Void , Void)                   => true
        | _                               => false
      }
    }
    
    #endregion
  }

  internal variant CaptureKind
  {
    | Handler  { name : RuleRef; argType : RuleType; retType : RuleType; }
    | Argument { retType : RuleType; }

    public override ToString() : string
    {
      match (this)
      {
      | Handler(name, at, rt) => $"H#$name : $at -> $rt"
      | Argument(ty)          => $"A#$ty"
      }
    }
  }

  [Record]
  internal variant Rule : Located
  {
    | Choice         { rules : list[Rule]; }
    | Sequence       { rules : list[Rule]; }
    | Call           { name : RuleRef; }
    | RepeatMin      { minCount : int; rule : Rule; }
    | RepeatMinMax   { minCount : int; maxCount : int; rule : Rule; }
    | Chars          {
                         chars : list[RangeSet];
                         public IsString : bool { get { chars.ForAll(_.IsSinglChar) } }
                     }
    | Fsm            { fsm : FSM; }
    | Not            { rule : Rule; }
    | And            { rule : Rule; }
    | Capture        { kind : CaptureKind; rule : Rule; }
    | ExtensionPoint { name : RuleRef; }
    | Scope          { name : RuleRef; rule : Rule; }
    | Recovery       { handlerName : RuleRef; skip : Rule; } // Failure recovery
    | Cut                             // Cutoff point

    /*public Walk(func : Rule -> Rule) : Rule
    {
      def loop(rule : Rule) : Rule
      {
        def rule2 = func(rule);
        match (rule2)
        {
          | Choice(rules)                 => Choice(rules.Map(loop))
          | Sequence(rules)               => Sequence(rules.Map(loop))
          | RepeatMin(x, rule)            => RepeatMin(x, loop(rule))
          | RepeatMinMax(min, max, rule)  => RepeatMinMax(min, max, loop(rule))
          | Not(rule)                     => Not(loop(rule))
          | And(rule)                     => And(loop(rule))
          | Capture(kind, rule)           => Capture(kind, loop(rule))
          | Scope(name, rule)             => Scope(name, loop(rule))
          | Call | Chars | ExtensionPoint | Fsm => rule2
        }
      }
      loop(this)
    }*/

    public Priority : int
    {
      get
      {
        match (this)
        {
          | Recovery                    => 5
          | Cut                         => 5
          | Scope                       => 5
          | Chars                       => 5
          | Fsm                         => 5
          | Capture                     => 5
          | ExtensionPoint              => 5
          | Call                        => 5
          | RepeatMin                   => 4
          | RepeatMinMax                => 4
          | Not                         => 3
          | And                         => 3
          | Sequence                    => 2
          | Choice                      => 1
        }
      }
    }

    public override ToString() : string
    {
      def p(rule : Rule)
      {
        if (rule.Priority <= this.Priority)
          $"($rule)"
        else
          rule.ToString()
      }

      match (this)
      {
        | Recovery(name, rule)                           => $"FailureRecovery($name, $rule)"
        | Cut                                            => "#"
        | Scope(name, rule)                              => $<#$name { $rule }#>
        | Choice(rules)                                  => $<#..$(rules; " / "; p)#>
        | Sequence(rules)                                => $<#..$(rules; " "; p)#>
        | Call(name)                                     => name.Id
        | RepeatMin(0, rule)                             => $"$(p(rule))*"
        | RepeatMin(1, rule)                             => $"$(p(rule))+"
        | RepeatMin(x, rule)                             => $"RepeatMin($x, $rule)"
        | RepeatMinMax(0, 1, rule)                       => $"$(p(rule))?"
        | RepeatMinMax(min, max, rule)                   => $"RepeatMinMax($min, $max, $rule)"
        | Chars([chars])                                 => $"[$chars]"
        | Chars(chars) as c when c.IsString              => $<#'..$(chars; ""; r => $"$(r.Ranges.Head.from)")'#>
        | Chars(chars)                                   => $<#(..$(chars; ", "; ch => $"[$ch]"))#>
        | Fsm                                            => "FSM"
        | Not(rule)                                      => $"!$(p(rule))"
        | And(rule)                                      => $"&$(p(rule))"
        | Capture(CaptureKind.Argument(ty), rule)        => $"CaptureA[$ty]($rule)"
        | Capture(CaptureKind.Handler(name, _, _), rule) => $"CaptureH[$name]($rule)"
        | ExtensionPoint(name)                           => $"ExtensionPoint($name)"
      }
    }
  }
}
